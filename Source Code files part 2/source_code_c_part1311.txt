ded
		printf("The cbEncoded is %d, and pbEncoded is:\n",cbEncoded);

		PrintBytes("        ",pbEncoded,cbEncoded);
		printf("\n");
	}

	SAFE_FREE(pbEncoded);

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the PKCS_TIME_REQUEST
//
//--------------------------------------------------------------------------
BOOL	VerifyPKCS_TIME_REQUEST(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL							fSucceeded=TRUE;
	CRYPT_TIME_STAMP_REQUEST_INFO	TimeStampRequest;
	void							*pvStructInfo=NULL;
	DWORD							cbStructInfo=0;
	DWORD							cbEncoded=0;
	BYTE							*pbEncoded=NULL;
	
	//make a hard-coded timestamp request
	BYTE							rgTestData[] = {
        0x1b, 0xf6, 0x92, 0xee, 0x6c, 0x44, 0xc5, 0xed, 0x51};

	BYTE							rgAttribValue1[]={
		0x02, 0x02, 0x11, 0x11};

	BYTE							rgAttribValue2[]={
		0x02, 0x02, 0x11, 0x11};


	//make 3 CRYPT_ATTRIBUTE
	CRYPT_ATTRIBUTE					rgCryptAttribute[3];
	CRYPT_ATTR_BLOB					rgAttribBlob[3];
	
	rgAttribBlob[0].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[0].pbData=rgAttribValue2;

	rgAttribBlob[1].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[1].pbData=rgAttribValue2;

	rgAttribBlob[2].cbData=sizeof(rgAttribValue1);
	rgAttribBlob[2].pbData=rgAttribValue1;


	rgCryptAttribute[0].pszObjId="1.2.3.4";
	rgCryptAttribute[0].cValue=0;
	rgCryptAttribute[0].rgValue=NULL;

	rgCryptAttribute[1].pszObjId="1.2.3.4";
	rgCryptAttribute[1].cValue=1;
	rgCryptAttribute[1].rgValue=rgAttribBlob;

	rgCryptAttribute[2].pszObjId="1.2.3.4";
	rgCryptAttribute[2].cValue=3;
	rgCryptAttribute[2].rgValue=rgAttribBlob;

    // initialize the timestamp structure
    TimeStampRequest.pszTimeStampAlgorithm = szOID_RSA_signingTime;
    TimeStampRequest.pszContentType = szOID_RSA_data;
    TimeStampRequest.Content.cbData = sizeof(rgTestData);
    TimeStampRequest.Content.pbData = rgTestData;
    TimeStampRequest.cAttribute = 3; 
    TimeStampRequest.rgAttribute = rgCryptAttribute;



	//encode the struct into a BLOB
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
		&TimeStampRequest,NULL,&cbEncoded),TRUE)

	pbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbEncoded)

	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
		&TimeStampRequest,pbEncoded,&cbEncoded),TRUE)

   //decode the struct with COPY and NOCOPY options
	TESTC(DecodePKCS_TIME_REQUEST(cbEncoded, pbEncoded, CRYPT_DECODE_COPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	TESTC(DecodePKCS_TIME_REQUEST(cbEncoded, pbEncoded, CRYPT_DECODE_NOCOPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//decode the struct and compare it with the original
	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
	pbEncoded, cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,NULL,&cbStructInfo),TRUE)

	pvStructInfo=SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(pvStructInfo);

	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
	pbEncoded, cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

	//compare two timstamp request
	TESTC(CompareTimeStampRequest(&TimeStampRequest,
	(CRYPT_TIME_STAMP_REQUEST_INFO *)pvStructInfo),TRUE)

	fSucceeded=TRUE;


TCLEANUP:

	SAFE_FREE(pbEncoded);

	SAFE_FREE(pvStructInfo);

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	A general routine to verify the CERT_PUBLIB_KEY_INFO.
//
//	Encode and decode the structure.  Call CryptImportPublicKeyInfo and 
//	CryptImportKey.
//--------------------------------------------------------------------------
BOOL	VerifyPublicKeyInfo(PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
							DWORD dwDecodeFlags,	BOOL fEncode,
							BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL			fSucceeded=FALSE;
	HCRYPTKEY		hKey=NULL;
	DWORD			cbEncoded=0;
	BYTE			*pbEncoded=NULL;

	//call CryptImportPublicKeyInfo
	TESTC(CryptImportPublicKeyInfo(g_hProv,CRYPT_ENCODE_TYPE,
		pPublicKeyInfo,&hKey),TRUE)

	//verify the algorithm
	TESTC(VerifyAlgorithParam(&(pPublicKeyInfo->Algorithm)),TRUE)

	//encode CERT_PUBLIC_KEY_INFO
	TESTC(EncodeStruct(X509_PUBLIC_KEY_INFO, pPublicKeyInfo,&cbEncoded,
					 &pbEncoded),TRUE)

	//decode/encode the publicKeyInfo
	TESTC(DecodeGenericBLOB(X509_PUBLIC_KEY_INFO, cbEncoded, pbEncoded, dwDecodeFlags, 
						fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

	//decode/encode the RSA_CSP_PUBLICKEYBLOB
	TESTC(DecodeRSA_CSP_PUBLICKEYBLOB(pPublicKeyInfo->PublicKey.cbData,
			pPublicKeyInfo->PublicKey.pbData,dwDecodeFlags,fEncode,fStructLengthCheck,
			fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:
	if(hKey)
		TCHECK(CryptDestroyKey(hKey),TRUE);

	SAFE_FREE(pbEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the extentions in a cert.
//
//--------------------------------------------------------------------------
BOOL	VerifyCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension,
							 DWORD  dwDecodeFlags,	BOOL fEncode,
							 BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	DWORD				cbEncoded=0;
	BYTE				*pbEncoded=NULL;
	CERT_EXTENSIONS		CertExtensions;
	DWORD				cbTestEncoded=0;
	BYTE				*pbTestEncoded=NULL;
	DWORD				cbStructInfo=sizeof(CERT_EXTENSIONS);
	CERT_EXTENSIONS		CertTestExtensions;

	//init
	CertExtensions.cExtension=0;
	CertExtensions.rgExtension=NULL;

	//Check the NULL case 

   	//length only calculation
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS, &CertExtensions,NULL,
			&cbTestEncoded),TRUE)

	//allocate memory
	pbTestEncoded=(BYTE *)SAFE_ALLOC(cbTestEncoded);
	CHECK_POINTER(pbTestEncoded);

	//EncodeObject
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS, &CertExtensions,
		pbTestEncoded, &cbTestEncoded),TRUE)

	//DecodeObject
	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS,
	pbTestEncoded,cbTestEncoded,dwDecodeFlags,&CertTestExtensions,&cbStructInfo),TRUE)

	//Verify CertTestExtensions
	TESTC(CertTestExtensions.cExtension, CertExtensions.cExtension)


	//init again
	CertExtensions.cExtension=cExtension;
	CertExtensions.rgExtension=rgExtension;

	//encode CERT_EXTENSIONS
	TESTC(EncodeStruct(X509_EXTENSIONS, &CertExtensions,&cbEncoded,
					 &pbEncoded),TRUE)

	//decode/encode X509_EXTENSIONS
	TESTC(DecodeX509_EXTENSIONS(cbEncoded,
			pbEncoded,dwDecodeFlags,fEncode,fStructLengthCheck,
			fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbEncoded)

	SAFE_FREE(pbTestEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Return the corresponding lpStructInfo based on the objectID passed in
//--------------------------------------------------------------------------
LPCSTR	MapObjID2StructType(LPSTR	szObjectID)
{
	if(szObjectID==NULL)
		return NULL;
	
	if(strcmp(szObjectID,szOID_AUTHORITY_KEY_IDENTIFIER)==0)
		return X509_AUTHORITY_KEY_ID;

	if(strcmp(szObjectID,szOID_KEY_ATTRIBUTES)==0)
		return X509_KEY_ATTRIBUTES;

	if(strcmp(szObjectID,szOID_KEY_USAGE_RESTRICTION)==0)
		return X509_KEY_USAGE_RESTRICTION;

	if(strcmp(szObjectID,szOID_SUBJECT_ALT_NAME)==0)
		return X509_ALTERNATE_NAME;

	if(strcmp(szObjectID,szOID_ISSUER_ALT_NAME)==0)
		return X509_ALTERNATE_NAME;

	if(strcmp(szObjectID,szOID_BASIC_CONSTRAINTS)==0)
		return X509_BASIC_CONSTRAINTS;

	if(strcmp(szObjectID,szOID_KEY_USAGE)==0)
		return X509_KEY_USAGE;

	if(strcmp(szObjectID,szOID_BASIC_CONSTRAINTS2)==0)
		return X509_BASIC_CONSTRAINTS2;

	if(strcmp(szObjectID,szOID_CERT_POLICIES)==0)
		return X509_CERT_POLICIES;

	return NULL;
}

///////////////////////////////////////////////////////////////////////////
//Certificate Manipulation Functions
//--------------------------------------------------------------------------
//	Decode a storefile what has CRL and certificates
//--------------------------------------------------------------------------
BOOL	DecodeCertFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	HCERTSTORE			hCertStore=NULL;
	DWORD				cbCertEncoded=0;
	BYTE				*pbCertEncoded=NULL;
	PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pPrevCertContext=NULL;
	PCCRL_CONTEXT		pCrlContext=NULL;
	PCCRL_CONTEXT		pPrevCrlContext=NULL;
	DWORD				dwFlags=0;
	DWORD				cCount=0;



	//open cert store
	if(!(hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_A, CRYPT_ENCODE_TYPE,
		g_hProv,CERT_STORE_NO_CRYPT_RELEASE_FLAG,pszFileName)))
		PROCESS_ERR_GOTO("Failed to open a store!\n")	

	//get a cert from the store one at a time
	while((pCertContext=CertEnumCertificatesInStore(hCertStore,pPrevCertContext)))
	{
		cCount++;

		printf("//-----------------------------------------\n");
		printf("Decoding the %dth Certificate\n",cCount);

		//retrieve the encoded X_509 BLOBs
		cbCertEncoded=pCertContext->cbCertEncoded;
		pbCertEncoded=pCertContext->pbCertEncoded;

		//verify the hCertStore is connect
		TESTC(hCertStore==pCertContext->hCertStore, TRUE)

		//NULL/invalid parameter testing only once
		if(cCount==1)
			TESTC(ParameterTest(X509_CERT_TO_BE_SIGNED, cbCertEncoded, pbCertEncoded),TRUE)
	
		//decode/encode the certificate blob with NOCOPY option
		TESTC(DecodeX509_CERT(CERT_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCertContext->pCertInfo),TRUE)


		//decode/encode the certificate blob with COPY option
		TESTC(DecodeX509_CERT(CERT_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCertContext->pCertInfo),TRUE)


		pPrevCertContext=pCertContext;
	}

	cCount=0;

	//get a CRL from the store one at a time
   	while((pCrlContext=CertGetCRLFromStore(hCertStore,NULL,pPrevCrlContext,&dwFlags)))
	{
		cCount++;

		printf("//-----------------------------------------\n");
		printf("Decoding the %dth CRL\n",cCount);

		//retrieve the encoded X_509 BLOBs
		cbCertEncoded=pCrlContext->cbCrlEncoded;
		pbCertEncoded=pCrlContext->pbCrlEncoded;

		//verify the hCertStore is connect
		TESTC(hCertStore==pCrlContext->hCertStore, TRUE)

		//NULL/invalid parameter testing only once
		if(cCount==1)
			TESTC(ParameterTest(X509_CERT_CRL_TO_BE_SIGNED, cbCertEncoded, pbCertEncoded),TRUE)
	
		//decode/encode the certificate blob with NOCOPY option
		TESTC(DecodeX509_CERT(CRL_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCrlContext->pCrlInfo),TRUE)


		//decode/encode the certificate blob with COPY option
		TESTC(DecodeX509_CERT(CRL_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCrlContext->pCrlInfo),TRUE)


		pPrevCrlContext=pCrlContext;
	}


	fSucceeded=TRUE;

TCLEANUP:
		
	//release the cert context
	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	//we do not need to free pPreCertContext since it is always freed by
	//CertEnumCertificatesInStore.

	//release the CRL contest
	if(pCrlContext)
		CertFreeCRLContext(pCrlContext);

	//release the cert store
	if(hCertStore)
		TCHECK(CertCloseStore(hCertStore,CERT_CLOSE_STORE_FORCE_FLAG),TRUE);

	return fSucceeded;


}

//--------------------------------------------------------------------------
//	Decode a BLOB file that is an encoded certificate request
//--------------------------------------------------------------------------
BOOL	DecodeCertReqFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbEncoded=0;
	BYTE	*pbEncoded=NULL;


	//Get the cbEncoded and pEncoded BLOB from the file
	TESTC(RetrieveBLOBfromFile(pszFileName,&cbEncoded,&pbEncoded),TRUE)

	//do a parameter testing
	TESTC(ParameterTest(X509_CERT_REQUEST_TO_BE_SIGNED, cbEncoded, pbEncoded),TRUE)

	//decode the BLOB as X509_CERT with COPY option
	TESTC(DecodeX509_CERT(CERT_REQUEST_INFO_STRUCT,cbEncoded,pbEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,NULL),TRUE)

	//decode the BLOB as X509_CERT wiht NOCOPY option
	TESTC(DecodeX509_CERT(CERT_REQUEST_INFO_STRUCT,cbEncoded,pbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,NULL),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbEncoded)

	return fSucceeded;


}

//--------------------------------------------------------------------------
//	Decode a BLOB file that is an signed message
//--------------------------------------------------------------------------
BOOL	DecodeSignedMsgFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	DWORD				cbEncoded=0;
	BYTE				*pbEncoded=NULL;
	DWORD				cbSignerEncoded=0;
	BYTE				*pbSignerEncoded=NULL;
	HCRYPTMSG			hCryptMsg=NULL;
	PCMSG_SIGNER_INFO	pSignerInfo=NULL;	
	DWORD				cbSize=0;
	DWORD				iIndex=0;
	DWORD				cSignerCount=0;



	//Get the cbEncoded and pEncoded BLOB from the file
	TESTC(RetrieveBLOBfromFile(pszFileName,&cbEncoded,&pbEncoded),TRUE)

	//Get the SIGNER_INFO BLOB from the file BLOB
	hCryptMsg=CryptMsgOpenToDecode(MSG_ENCODING_TYPE,0,0,g_hProv,NULL,NULL);

	if(!hCryptMsg)
		goto TCLEANUP;

	TESTC(CryptMsgUpdate(hCryptMsg,pbEncoded,cbEncoded,TRUE),TRUE)

	//Get the count of signer in the message
	cbSize=sizeof(cSignerCount);

	TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_COUNT_PARAM,
	0,&cSignerCount,&cbSize),TRUE)

	//go through the list of all signers
	for(iIndex=0;iIndex<cSignerCount;iIndex++)
	{
		//get the CMSG_SINGER_INFO struct
		TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_INFO_PARAM,
		iIndex,NULL,&cbSize),TRUE)

		//allocation memory
		pSignerInfo=(PCMSG_SIGNER_INFO)SAFE_ALLOC(cbSize);
		CHECK_POINTER(pSignerInfo);

		TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_INFO_PARAM,
		iIndex,pSignerInfo,&cbSize),TRUE)

		//encode the struct info a BLOB.  Add Attributes if possible
		TESTC(EncodeSignerInfoWAttr(pSignerInfo,&cbSignerEncoded,
		&pbSignerEncoded),TRUE)

		//do a parameter testing for the 1st round
		if(iIndex==0)
		{
			TESTC(ParameterTest(PKCS7_SIGNER_INFO, cbSignerEncoded, pbSignerEncoded),TRUE)
		}

		//decode the BLOB as PKCS7_SIGNER_INFO with COPY option
		TESTC(DecodePKCS7_SIGNER_INFO(cbSignerEncoded,pbSignerEncoded, CRYPT_DECODE_COPY_FLAG,
			TRUE,fStructLengthCheck,fBLOBLengthCheck),TRUE)

		//decode the BLOB as PKCS7_SIGNER_INFO wiht NOCOPY option
		TESTC(DecodePKCS7_SIGNER_INFO(cbSignerEncoded,pbSignerEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			TRUE,fStructLengthCheck,fBLOBLengthCheck),TRUE)

		//release the memory
		SAFE_FREE(pSignerInfo);

		SAFE_FREE(pbSignerEncoded);

	}



	fSucceeded=TRUE;

TCLEANUP:
	//close the msg handle
	CryptMsgClose(hCryptMsg);

	SAFE_FREE(pbEncoded)

	SAFE_FREE(pbSignerEncoded)

	SAFE_FREE(pSignerInfo)

	return fSucceeded;


}



//--------------------------------------------------------------------------
//	A general routine to encode a struct based on lpszStructType
//--------------------------------------------------------------------------
BOOL	EncodeStruct(LPCSTR	lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
					 BYTE **ppbEncoded)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbEncoded=NULL;
	BYTE	*pbTestEncoded=NULL;
	DWORD	cbTestEncoded=0;
	DWORD	dwEncodingType=CRYPT_ENCODE_TYPE;

	//init
	*pcbEncoded=0;
	*ppbEncoded=NULL;

	assert(lpszStructType);
	assert(pStructInfo);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	//length only calculation
	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType, pStructInfo,NULL,
			&cbEncoded),TRUE)

	//the struct has to be more than 0 byte
	assert(cbEncoded);

	//allocate the correct amount of memory
	*ppbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(*ppbEncoded);

	//Encode the strcut with *pcbEncoded == the correct length
	*pcbEncoded=cbEncoded;

	//Encode the struct
	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,*ppbEncoded,
		pcbEncoded),TRUE)

	//the length returned has to be less or equal to cbEncoded
	TESTC(cbEncoded>=(*pcbEncoded),TRUE)


	//allocate memory to LENGTH_DELTA byte more than necessary to pbTestEncoded
	pbTestEncoded=(BYTE *)SAFE_ALLOC(cbEncoded+LENGTH_MORE);
	CHECK_POINTER(pbTestEncoded)

  	//Encode the struct with *pcbEncoded > the correct length
	cbTestEncoded=cbEncoded+LENGTH_MORE;

	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,pbTestEncoded,
		&cbTestEncoded),TRUE)

	//*pcbEncoded should be the same as cbEncoded
	TESTC(cbTestEncoded, *pcbEncoded)

	//Verify the pbTestEncoded contain the same bytes as pcbEncoded, starting 
	//at the 1st byte of the BLOB
	TESTC(memcmp(pbTestEncoded, *ppbEncoded,*pcbEncoded),0)

	//Encode the struct with *pcbEncoded < the correct length
	cbTestEncoded=(*pcbEncoded)-LENGTH_LESS;

	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,pbTestEncoded,
		&cbTestEncoded),FALSE)

	//*pcbEncoded should be the same as cbEncoded
	TESTC(cbTestEncoded, *pcbEncoded)

	//GetLastError should be ERROR_MORE_DATA
	TESTC(GetLastError(),ERROR_MORE_DATA)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbTestEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	EncodeAndVerify 
//
//	Encode the pStructInfo and verify the encoded BLOB is the same
//	as expected.
//--------------------------------------------------------------------------
BOOL	EncodeAndVerify(LPCSTR	lpszStructType, void *pvStructInfo, DWORD cbEncoded, 
						BYTE *pbEncoded)
{
	DWORD	cbSecondEncoded=0;
	BYTE	*pbSecondEncoded=0;	
	BOOL	fSucceeded=FALSE;

	
	assert(lpszStructType);
	assert(pvStructInfo);
	assert(cbEncoded);
	assert(pbEncoded);

	//encode the struct back to a BLOB
	TESTC(EncodeStruct(lpszStructType,pvStructInfo,&cbSecondEncoded,&pbSecondEncoded),
		TRUE)

	//make sure the returned encoded BLOB is the same as the original BLOB
	//the two encoded BLOB has to of the same length
	if(!TCHECK(cbSecondEncoded, cbEncoded))
	{
		PROCESS_ERR(szEncodedSizeInconsistent)

		OutputError(lpszStructType,cbSecondEncoded, cbEncoded,pbSecondEncoded,pbEncoded);
	}
		
    if (0 != memcmp(pbSecondEncoded,pbEncoded,cbEncoded)) {
        if (X509_KEY_USAGE == lpszStructType) {
            // Force the unused bits to be the same
            if (3 <= cbSecondEncoded && 3 <= cbEncoded) {
                BYTE bUnusedBits = pbSecondEncoded[2];

                pbSecondEncoded[2] = pbEncoded[2];
                if (0 == memcmp(pbSecondEncoded,pbEncoded,cbEncoded))
                    printf("Warning, difference in reencoded KeyUsage UnusedBit Count\n");
                else
                    pbSecondEncoded[2] = bUnusedBits;
            }
        }
    }

	//the two encoded BLOB has to be of the same content
	if(!TCHECK(memcmp(pbSecondEncoded,pbEncoded,cbEncoded),0))
	{
		PROCESS_ERR(szEncodedContentInconsistent)
		OutputError(lpszStructType,cbSecondEncoded, cbEncoded,pbSecondEncoded,pbEncoded);
	}


	fSucceeded=TRUE;

TCLEANUP:
	
	SAFE_FREE(pbSecondEncoded)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	A general routine to decode a BLOB based on lpszStructType
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//
//--------------------------------------------------------------------------
BOOL  DecodeBLOB(LPCSTR	lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
				  DWORD	dwDecodeFlags, DWORD	*pcbStructInfo, void **ppvStructInfo,
				  BOOL	fStructLengthCheck,BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	LONG	iIndex=0;
	LONG	cbUpperLimit=0;
	DWORD	cbTestStructInfo=0;
	void	*pvTestStructInfo=NULL;
	DWORD	dwEncodingType=CRYPT_ENCODE_TYPE;

	//init
	*pcbStructInfo=0;
	*ppvStructInfo=NULL;

	assert(lpszStructType);
	assert(pbEncoded);
	assert(cbEncoded);

	//Decode 
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
		dwDecodeFlags,NULL,&cbStructInfo),TRUE)

	//the struct has to be more than 0 byte
	assert(cbStructInfo);

	*ppvStructInfo=(BYTE *)SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(*ppvStructInfo);

	//Decode the BLOB with *pcbStructInfo==correct length
	*pcbStructInfo=cbStructInfo;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,*ppvStructInfo,pcbStructInfo),TRUE)


	//make sure the correct length is less than cbStructInfo
	TESTC(cbStructInfo>=(*pcbStructInfo),TRUE);


	//Decode the BLOB with *pcbStructInfo>correct length

	//allocate memory to be LENGTH_DELTA more byte than the correct length
	pvTestStructInfo=SAFE_ALLOC(cbStructInfo+LENGTH_MORE);
	CHECK_POINTER(pvTestStructInfo);

	cbTestStructInfo=cbStructInfo+LENGTH_MORE;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),TRUE)

	//make sure the length is the same
	TESTC(cbTestStructInfo, (*pcbStructInfo));

	//Decode the BLOB with *pcbStructInfo < correct length
	 cbTestStructInfo=(*pcbStructInfo)-LENGTH_LESS;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

	TESTC(GetLastError(), ERROR_MORE_DATA)

	//make sure the length is the same
	TESTC(cbTestStructInfo, (*pcbStructInfo));

	//if fStructLengthCheck is TRUE, we need to do a more rigorous test of *pcbStructInfo
	if(fStructLengthCheck)
	{
	   
	   cbUpperLimit=(*pcbStructInfo)-1;

	   for(iIndex=cbUpperLimit; iIndex>=0; iIndex--)
	   {
			cbTestStructInfo=iIndex;

			//decode the BLOB with *pcbStructInfo<correct bytes
			TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
			dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

			TESTC(GetLastError(), ERROR_MORE_DATA)

			//make sure the length is the same
			TESTC(cbTestStructInfo, *pcbStructInfo);
	  }
	}


	//if fBLOBLengthCheck is TRUE, we need to do a more rigorous test of cbEncoded
	if(fBLOBLengthCheck)
	{
	   
	   cbUpperLimit=cbEncoded-1;

	   for(iIndex=cbUpperLimit; iIndex>=0; iIndex--)
	   {
		   	cbTestStructInfo=cbStructInfo;

			//decode the BLOB with cbEncoded < correct byte
			TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,iIndex,
			dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

			//we are not sure that should be expected here.  The following error has 
			//occurred:
			//E_INVALIDARG, CRYPT_E_OSS_ERROR+PDU_MISMATCH, +DATA_ERROR, or
			//+MORE_INPUT
			
			//make sure at lease S_OK is not returned
			TCHECK(GetLastError()!=S_OK, TRUE);
	  }
	}

						
	fSucceeded=TRUE;

TCLEANUP:

	//reallocate memory
	SAFE_FREE(pvTestStructInfo);


	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_CERT BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT(DWORD	dwCertType,DWORD cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags,BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						void *pInfoStruct)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//verify the algorithm
	TESTC(VerifyAlgorithParam(&(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)

	//Further Decode the X509_CERT_TO_BE_SIGNED
	//Notice we should use the original cbData and pbData passed in for Decode
	//but use ToBeSigned in CERT_SIGNED_CONTENT_INFO for encode purpose
	switch(dwCertType)
	{
		case CERT_INFO_STRUCT:
				TESTC(DecodeX509_CERT_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)	

				//verify the pCertInfo should be encoded correctly
				TCHECK(EncodeAndVerify(X509_CERT_TO_BE_SIGNED, pInfoStruct, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData),TRUE);

			break;

		case CRL_INFO_STRUCT:
				TESTC(DecodeX509_CERT_CRL_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)
				
				//verify the pCrlInfo should be encoded correctly
				TCHECK(EncodeAndVerify(X509_CERT_CRL_TO_BE_SIGNED, pInfoStruct, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData),TRUE);

			break;

		case CERT_REQUEST_INFO_STRUCT:
				TESTC(DecodeX509_CERT_REQUEST_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)	
			break;


	}
	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);


	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}		 



//--------------------------------------------------------------------------
//	Decode X509_CERT_TO_BE_SIGNED BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Verify the signaure algorithm 
	TESTC(VerifyAlgorithParam(&(((PCERT_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)

	//Verify the public Key information
	TESTC(VerifyPublicKeyInfo(&(((PCERT_INFO)pStructInfo)->SubjectPublicKeyInfo),
	dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Decode Issuer in CERT_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Issuer).cbData,
	(((PCERT_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Issuer to X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_INFO)pStructInfo)->Issuer).cbData,
	(((PCERT_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject in CERT_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject to X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the extensions
	TESTC(VerifyCertExtensions(((PCERT_INFO)pStructInfo)->cExtension, 
	((PCERT_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(((PCERT_INFO)pStructInfo)->cExtension, 
	((PCERT_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_CERT_CRL_TO_BE_SIGNED BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_CRL_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	DWORD		iIndex=0;
	PCRL_ENTRY	pCrlEntry=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_CRL_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Verify the signaure algorithm 
	TESTC(VerifyAlgorithParam(&(((PCRL_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)


	//Decode Issuer in CRL_INFO struct
	TESTC(DecodeX509_NAME((((PCRL_INFO)pStructInfo)->Issuer).cbData,
	(((PCRL_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Issuer to the X509_UNICODE_NAME 
	TESTC(DecodeX509_UNICODE_NAME((((PCRL_INFO)pStructInfo)->Issuer).cbData,
	(((PCRL_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the CRL_ENTRY
	for(iIndex=0; iIndex<((PCRL_INFO)pStructInfo)->cCRLEntry; iIndex++)
	{
		pCrlEntry=&(((PCRL_INFO)pStructInfo)->rgCRLEntry[iIndex]);

		TESTC(DecodeCRLEntry(pCrlEntry,dwDecodeFlags,fEncode,
			fStructLengthCheck, fBLOBLengthCheck),TRUE)
	}

	//Verify the extensions
	TESTC(VerifyCertExtensions(((PCRL_INFO)pStructInfo)->cExtension, 
	((PCRL_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(((PCRL_INFO)pStructInfo)->cExtension, 
	((PCRL_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode 509_CERT_REQUEST_TO_BE_SIGNED BLOBS
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_REQUEST_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{

	BOOL				fSucceeded=FALSE;
	DWORD				cbStructInfo=0;
	void				*pStructInfo=NULL;
	DWORD				cCount=0;
	DWORD				iIndex=0;
	PCRYPT_ATTRIBUTE	pCryptAttribute=NULL;
	LPCSTR				lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_REQUEST_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the public Key information
//	TESTC(VerifyPublicKeyInfo(&(((PCERT_REQUEST_INFO)pStructInfo)->SubjectPublicKeyInfo),
//	dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Decode Subject in CERT_REQUEST_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_REQUEST_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_REQUEST_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject in CERT_REQUEST_INFO struct for X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_REQUEST_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_REQUEST_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode the rgAttribute in CERT_REQUEST_INFO
	cCount=((PCERT_REQUEST_INFO)pStructInfo)->cAttribute;
	
	for(iIndex=0; iIndex<cCount; iIndex++)
	{
		pCryptAttribute=&(((PCERT_REQUEST_INFO)pStructInfo)->rgAttribute[iIndex]);

		TESTC(DecodeCryptAttribute(pCryptAttribute,dwDecodeFlags,fEncode,
			fStructLengthCheck, fBLOBLengthCheck),TRUE)
	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}
//--------------------------------------------------------------------------
//	Decode RSA_CSP_PUBLICKEYBLOB
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeRSA_CSP_PUBLICKEYBLOB(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;
	HCRYPTKEY	hKey=NULL;	

	//init
	lpszStructType=RSA_CSP_PUBLICKEYBLOB;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Make sure the pStructInfo can be used by CryptImportKey
	TESTC(CryptImportKey(g_hProv,(BYTE *)pStructInfo,cbStructInfo,
	0,0,&hKey),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	if(hKey)
		TCHECK(CryptDestroyKey(hKey),TRUE);

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode PKCS_TIME_REQUEST
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodePKCS_TIME_REQUEST(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;

	//init
	lpszStructType=PKCS_TIME_REQUEST;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}



//--------------------------------------------------------------------------
//	Decode a genanric BLOB, encode is back to make sure that the same
//  BLOB is returned. 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(LPCSTR	lpszStructType, DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;

	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	Decode X509_NAME BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;
	DWORD	cRDN=0;
	DWORD	cRDNAttr=0;
	DWORD	cRDNCount=0;
	DWORD	cRDNAttrCount=0;
	

	//init
	lpszStructType=X509_NAME;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//We need to further decode CERT_RDN_ATTR if dwValueType is CERT_RDN_ENCODED_BLOB
	cRDNCount=((PCERT_NAME_INFO)pStructInfo)->cRDN;

	for(cRDN=0;cRDN<cRDNCount;cRDN++)
	{
		cRDNAttrCount=(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).cRDNAttr;

		for(cRDNAttr=0; cRDNAttr<cRDNAttrCount; cRDNAttr++)
		{
			//no need to do a length checking since the routine is written and 
			//installed by third party 
			if( (((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].dwValueType==
				CERT_RDN_ENCODED_BLOB)
				TESTC(DecodeBasedOnObjID(
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].pszObjId,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.cbData,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.pbData,
				dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)
		}

	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);

		
	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode PKCS7_SIGNER_INFO
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodePKCS7_SIGNER_INFO(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=PKCS7_SIGNER_INFO;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the issuser name
	TESTC(DecodeX509_NAME((((PCMSG_SIGNER_INFO)pStructInfo)->Issuer).cbData,
	(((PCMSG_SIGNER_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the attributes 
	TESTC(VerifyAttributes(((PCMSG_SIGNER_INFO)pStructInfo)->AuthAttrs.cAttr,
		 ((PCMSG_SIGNER_INFO)pStructInfo)->AuthAttrs.rgAttr,
		 dwDecodeFlags,fEncode,
		fStructLengthCheck, fBLOBLengthCheck),TRUE)

	TESTC(VerifyAttributes(((PCMSG_SIGNER_INFO)pStructInfo)->UnauthAttrs.cAttr,
		 ((PCMSG_SIGNER_INFO)pStructInfo)->UnauthAttrs.rgAttr,
		 dwDecodeFlags,fEncode,
		fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	Decode an array of attributes
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	VerifyAttributes(DWORD	cAttr, PCRYPT_ATTRIBUTE	rgAttr,					
			DWORD dwDecodeFlags, BOOL fEncode, BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	ULONG	iIndex=0;

	for(iIndex=0;iIndex<cAttr;iIndex++)
	{
		TESTC(DecodeCryptAttribute(&(rgAttr[iIndex]),dwDecodeFlags,fEncode,
				 fStructLengthCheck,fBLOBLengthCheck),TRUE)
	}

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_UNICODE_NAME BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_UNICODE_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;
	DWORD	cRDN=0;
	DWORD	cRDNAttr=0;
	DWORD	cRDNCount=0;
	DWORD	cRDNAttrCount=0;
	

	//init
	lpszStructType=X509_UNICODE_NAME;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//We need to further decode CERT_RDN_ATTR if dwValueType is CERT_RDN_ENCODED_BLOB
	cRDNCount=((PCERT_NAME_INFO)pStructInfo)->cRDN;

	for(cRDN=0;cRDN<cRDNCount;cRDN++)
	{
		cRDNAttrCount=(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).cRDNAttr;

		for(cRDNAttr=0; cRDNAttr<cRDNAttrCount; cRDNAttr++)
		{
			//no need to do a length checking since the routine is written and 
			//installed by third party 
			if( (((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].dwValueType==
				CERT_RDN_ENCODED_BLOB)
				TESTC(DecodeBasedOnObjID(
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].pszObjId,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.cbData,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.pbData,
				dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)
		}

	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);

		
	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;


}



//--------------------------------------------------------------------------
//	Decode X509_EXTENSIONS BLOB 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_EXTENSIONS(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;

	//init
	lpszStructType=X509_EXTENSIONS;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode further the pStructInfo which points to an array of CERT_EXTENSION
	TESTC(DecodeCertExtensions(((PCERT_EXTENSIONS)pStructInfo)->cExtension,
	  ((PCERT_EXTENSIONS)pStructInfo)->rgExtension,dwDecodeFlags, fEncode,
	  fStructLengthCheck,fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}
 
//--------------------------------------------------------------------------
//	Decode an array of X509 cert extensions
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	DWORD	iIndex=0;
	BOOL	fSucceeded=FALSE;

	for(iIndex=0; iIndex<cExtension; iIndex++)
	{
		TESTC(DecodeBasedOnObjID((rgExtension[iIndex]).pszObjId,
			(rgExtension[iIndex]).Value.cbData,  (rgExtension[iIndex]).Value.pbData,
			dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
	}

	fSucceeded=TRUE;

TCLEANUP:
	
	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode CRYPT_ATTRIBUTE struct and encode
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCryptAttribute(PCRYPT_ATTRIBUTE pCryptAttribute,DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;	
	DWORD	iIndex=0;

	for(iIndex=0; iIndex<pCryptAttribute->cValue;iIndex++)
	{
		TESTC(DecodeBasedOnObjID(pCryptAttribute->pszObjId,
			(pCryptAttribute->rgValue)[iIndex].cbData,
			(pCryptAttribute->rgValue)[iIndex].pbData,
			dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

	}


	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode CRL_ENTRY struct and encode
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCRLEntry(PCRL_ENTRY pCrlEntry, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;

	//Verify the extensions
	TESTC(VerifyCertExtensions(pCrlEntry->cExtension, 
	pCrlEntry->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(pCrlEntry->cExtension, 
	pCrlEntry->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode one X509 cert extension
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeBasedOnObjID(LPSTR	szObjId,	DWORD	cbData, BYTE	*pbData,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL						fSucceeded=FALSE;
	DWORD						cbStructInfo=0;
	void						*pStructInfo=NULL;
	DWORD						iIndex=0;
	DWORD						cCount=0;
	DWORD						iIndexInner=0;
	DWORD						cCountInner=0;
	CERT_NAME_BLOB				*pBlob=NULL;
	PCERT_ALT_NAME_ENTRY		pCertAltNameEntry=NULL;
	PCERT_POLICY_INFO			pCertPolicyInfo=NULL;
	PCERT_POLICY_QUALIFIER_INFO	pCertPolicyQualifierInfo=NULL;	
	LPCSTR						lpszStructType=NULL;

	//init
	lpszStructType=MapObjID2StructType(szObjId);

	//return TRUE if we can not recognize the object ID.  We can no longer
	//go any further.
	if(!lpszStructType)
		return TRUE;

	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbData, pbData,
		dwDecodeFlags,&cbStructInfo,&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the extension if we know what the struct look like
	switch((DWORD_PTR)lpszStructType)
	{
		//we need to further decode CertIssuer in CERT_AUTHORITY_KEY_ID_INFO
		case	(DWORD_PTR)(X509_AUTHORITY_KEY_ID):
						
						pBlob=&(((PCERT_AUTHORITY_KEY_ID_INFO)pStructInfo)->CertIssuer);

						TESTC(DecodeX509_NAME(pBlob->cbData, pBlob->pbData,
						dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

						//further decode the BLOB to X509_UNICODE_NAME
						TESTC(DecodeX509_UNICODE_NAME(pBlob->cbData, pBlob->pbData,
						dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
				
					break;

		//we need to further decode the CERT_ALT_NAME_ENTRY array
		case	(DWORD_PTR)(X509_ALTERNATE_NAME):
		
				
			/*	cCount=((PCERT_ALT_NAME_INFO)pStructInfo)->cAltEntry;

					for(iIndex=0; iIndex<cCount; iIndex++)
					{
						pCertAltNameEntry=&(((PCERT_ALT_NAME_INFO)pStructInfo)->rgAltEntry[iIndex]);

						TESTC(DecodeCertAltNameEntry(pCertAltNameEntry,dwDecodeFlags,	fEncode,
						fStructLengthCheck, fBLOBLengthCheck),TRUE)

					} 
						  */
					break;
	   											  
		//we need to further decode CERT_BASIC_CONSTRAINTS_INFO
		case	(DWORD_PTR)(X509_BASIC_CONSTRAINTS):

						cCount=((PCERT_BASIC_CONSTRAINTS_INFO)pStructInfo)->cSubtreesConstraint;

						//decode the array of CERT_NAME_BLOB in rgSubtreesConstraint 
						//of CERT_BASIC_CONSTRAINTS_INFO
						for(iIndex=0; iIndex<cCount; iIndex++)
						{
							pBlob=&((((PCERT_BASIC_CONSTRAINTS_INFO)pStructInfo)->rgSubtreesConstraint)[iIndex]);

							TESTC(DecodeX509_NAME(pBlob->cbData, pBlob->pbData,
							dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

							//further decode as X509_UNICODE_NAME
							TESTC(DecodeX509_UNICODE_NAME(pBlob->cbData, pBlob->pbData,
							dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
						}
					break;

		case	(DWORD_PTR)(X509_CERT_POLICIES ):

						cCount=((PCERT_POLICIES_INFO)pStructInfo)->cPolicyInfo;
						
						for(iIndex=0; iIndex<cCount;iIndex++)
						{
							pCertPolicyInfo=&(((PCERT_POLICIES_INFO)pStructInfo)->rgPolicyInfo[iIndex]);

							cCountInner=pCertPolicyInfo->cPolicyQualifier;

							for(iIndexInner=0; iIndexInner<cCountInner; iIndexInner++)
							{

								pCertPolicyQualifierInfo=&((pCertPolicyInfo->rgPolicyQualifier)[iIndexInner]);

								//Although DecodeBasedOnObjID is called here, we have
								//no risk of an infinite loop.  
								//This is a recursive call, which should
								//end when there is no further decodable code, that is, 
								//the pszObjID should not be szOID_CERT_POLICIES

								TESTC(DecodeBasedOnObjID(pCertPolicyQualifierInfo->pszPolicyQualifierId,
								pCertPolicyQualifierInfo->Qualifier.cbData,
								pCertPolicyQualifierInfo->Qualifier.pbData,
								dwDecodeFlags, fEncode,fStructLengthCheck,
								fBLOBLengthCheck),TRUE)

							}
						}
					break;

		default:
				
					break;
	}	

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbData, 
		pbData),TRUE);

	fSucceeded=TRUE;

TCLEANUP:


	SAFE_FREE(pStructInfo)

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode one X509 cert extension
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCertAltNameEntry(PCERT_ALT_NAME_ENTRY	pCertAltNameEntry,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL						fSucceeded=FALSE;
	PCRYPT_ATTRIBUTE_TYPE_VALUE	pAttributeTypeValue=NULL;

	assert(pCertAltNameEntry);

	switch(pCertAltNameEntry->dwAltNameChoice)
	{
		case	CERT_ALT_NAME_DIRECTORY_NAME:

					//further decode the NAME_BLOB in DirectoryName
					TESTC(DecodeX509_NAME(pCertAltNameEntry->DirectoryName.cbData,
					pCertAltNameEntry->DirectoryName.pbData,
					dwDecodeFlags,fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

					//decode it as UNICODE
					TESTC(DecodeX509_UNICODE_NAME(pCertAltNameEntry->DirectoryName.cbData,
					pCertAltNameEntry->DirectoryName.pbData,
					dwDecodeFlags,fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

				break;

		default:
				break;
	}

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tctlfunc\tctlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tctlfunc.cpp
//
//  Contents:   CertVerifyCTLUsage Function Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    08-May-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: tctlfunc [options] <SubjectCertFile1> <SubjectCertFile2> ...\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -U<ObjectID>          - Usage Identifier\n");
    printf("  -L<text>              - List Identifier\n");
    printf("  -A                    - Test via AnySubjectType\n");
    printf("  -c<filename>          - CTL store file\n");
    printf("  -C<storename>         - CTL system store\n");
    printf("  -s<filename>          - Signer store file\n");
    printf("  -S<storename>         - Signer system store\n");
    printf("  -e<Expected Error>    - For example, -e0x0\n");
    printf("  -f<number>            - Verify dwFlags\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("\n");
}

static HCERTSTORE OpenSignerStore(
    LPSTR pszStore,
    BOOL fSystemStore
    )
{
    HCERTSTORE hStore;

    if (fSystemStore)
        hStore = CertOpenSystemStore(NULL, pszStore);
    else
        hStore = CertOpenStore(
                CERT_STORE_PROV_FILENAME_A,
                dwMsgAndCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                (const void *) pszStore
                );
    return hStore;
}


// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}

static HCERTSTORE OpenCtlStore(
    LPSTR pszStore,
    BOOL fSystemStore
    )
{
    HCERTSTORE hStore;

    if (!fSystemStore)
        hStore = OpenCtlStoreFile(pszStore);
    else
        hStore = NULL;

    if (NULL == hStore)
        hStore = OpenSignerStore(pszStore, fSystemStore);
    return hStore;
}

static PCCERT_CONTEXT OpenSubjectCert(
    LPSTR pszFilename
    )
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        return NULL;

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    TestFree(pbEncoded);
    return pCert;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

    DWORD dwError = 0;
    DWORD dwFlags = 0;
    DWORD dwSubjectType = CTL_CERT_SUBJECT_TYPE;
    DWORD dwDisplayFlags = 0;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];
    CTL_USAGE SubjectUsage = {0, rgpszUsageId};

#define MAX_CTL_STORE_COUNT     16
    HCERTSTORE rghCtlStore[MAX_CTL_STORE_COUNT];
#define MAX_SIGNER_STORE_COUNT  16
    HCERTSTORE rghSignerStore[MAX_SIGNER_STORE_COUNT];
#define MAX_SUBJECT_COUNT       16
    PCCERT_CONTEXT rgpSubject[MAX_SUBJECT_COUNT];
    DWORD cSubject = 0;

    CTL_VERIFY_USAGE_PARA VerifyPara;
    CTL_VERIFY_USAGE_STATUS VerifyStatus;
    CTL_ANY_SUBJECT_INFO AnySubjectInfo;
    BYTE rgbHash[MAX_HASH_LEN];

    PCCTL_CONTEXT pCtl = NULL;
    PCCERT_CONTEXT pSigner = NULL;

    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara); 
    VerifyPara.rghCtlStore = rghCtlStore;
    VerifyPara.rghSignerStore = rghSignerStore;

    memset(&VerifyStatus, 0, sizeof(VerifyStatus));
    VerifyStatus.cbSize = sizeof(VerifyStatus); 
    VerifyStatus.ppCtl = &pCtl;
    VerifyStatus.ppSigner = &pSigner;

    DWORD i;

    while (--argc>0) {
        if (**++argv == '-')
        {
            BOOL fSystemStore = FALSE;

            switch(argv[0][1])
            {
            case 'U':
                if (SubjectUsage.cUsageIdentifier >= MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                rgpszUsageId[SubjectUsage.cUsageIdentifier++] = argv[0] + 2;
                break;
            case 'L':
                if (0 == strlen(argv[0] + 2))
                    VerifyPara.ListIdentifier.cbData =
                        CTL_FIND_NO_LIST_ID_CBDATA;
                else {
                    VerifyPara.ListIdentifier.cbData = strlen(argv[0] + 2);
                    VerifyPara.ListIdentifier.pbData = (BYTE *) argv[0] + 2;
                }
                break;
            case 'A':
                dwSubjectType = CTL_ANY_SUBJECT_TYPE;
                break;
            case 'C':
                fSystemStore = TRUE;
            case 'c':
                if (VerifyPara.cCtlStore >= MAX_CTL_STORE_COUNT) {
                    printf("Maximum number of CTL Stores: %d\n",
                        MAX_CTL_STORE_COUNT);
            		goto BadUsage;
                }
                
                if (rghCtlStore[VerifyPara.cCtlStore] = OpenCtlStore(
                        argv[0] + 2, fSystemStore))
                    VerifyPara.cCtlStore++;
                else {
                    printf("OpenCtlStore(%s) failed\n", argv[0] + 2);
                    goto BadUsage;
                }
                break;
            case 'S':
                fSystemStore = TRUE;
            case 's':
                if (VerifyPara.cSignerStore >= MAX_SIGNER_STORE_COUNT) {
                    printf("Maximum number of Signer Stores: %d\n",
                        MAX_SIGNER_STORE_COUNT);
            		goto BadUsage;
                }
                
                if (rghSignerStore[VerifyPara.cSignerStore] = OpenSignerStore(
                        argv[0] + 2, fSystemStore))
                    VerifyPara.cSignerStore++;
                else {
                    printf("OpenSignerStore(%s) failed\n", argv[0] + 2);
                    goto BadUsage;
                }
                break;
            case 'e':
                dwError = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                dwFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (cSubject >= MAX_SUBJECT_COUNT) {
                printf("Exceeded maximum Subject count of %d\n",
                    MAX_SUBJECT_COUNT);
                goto BadUsage;
            }
            if (rgpSubject[cSubject] = OpenSubjectCert(argv[0]))
                cSubject++;
            else {
                printf("OpenSubjectCert(%s) failed\n", argv[0]);
                goto BadUsage;
            }
        }
    }

    if (cSubject == 0) {
        printf("Missing Subject Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    for (i = 0; i < cSubject; i++) {
        BOOL fResult;
        void *pvSubject;

        printf("=====  Subject[%d]  =====\n", i);

        if (CTL_ANY_SUBJECT_TYPE == dwSubjectType) {
            memset(&AnySubjectInfo, 0, sizeof(AnySubjectInfo));
            AnySubjectInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

            AnySubjectInfo.SubjectIdentifier.cbData = MAX_HASH_LEN;
            if (!CertGetCertificateContextProperty(
                    rgpSubject[i],
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &AnySubjectInfo.SubjectIdentifier.cbData) ||
                        0 == AnySubjectInfo.SubjectIdentifier.cbData) {
                printf("failed => unable to get SHA1 hash for Subject[%d]\n",
                    i);
                continue;
            }
            AnySubjectInfo.SubjectIdentifier.pbData = rgbHash;

            pvSubject = &AnySubjectInfo;
        } else
            pvSubject = (void *) rgpSubject[i];


        fResult = CertVerifyCTLUsage(
            dwCertEncodingType,
            dwSubjectType,
            pvSubject,
            &SubjectUsage,
            dwFlags,
            &VerifyPara,
            &VerifyStatus);
        if (fResult) {
            if (pCtl) {
                printf("-----  CTL  -----\n");
                DisplayCtl(pCtl, dwDisplayFlags | DISPLAY_NO_ISSUER_FLAG, 0);
                printf("\nSubject Index:: %d\n", VerifyStatus.dwCtlEntryIndex);
            } else
                printf("Failed, CertVerifyCTLUsage didn't return CTL\n");

            if (pSigner) {
                printf("-----  Signer [%d]  -----\n",
                    VerifyStatus.dwSignerIndex);
                DisplayCert(pSigner, 0);
                if (pCtl && (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
                    DisplaySignerInfo(
                        pCtl->hCryptMsg,
                        VerifyStatus.dwSignerIndex,
                        dwDisplayFlags);
                CertFreeCertificateContext(pSigner);
                pSigner = NULL;
            } else
                printf("Failed, CertVerifyCTLUsage didn't return Signer\n");

            if (pCtl) {
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
            }

            if (0 != VerifyStatus.dwError)
                printf("CertVerifyCTLUsage returned dwError: 0x%x (%d)\n",
                    VerifyStatus.dwError, VerifyStatus.dwError);
            if (0 != VerifyStatus.dwFlags)
                printf("CertVerifyCTLUsage returned dwFlags: 0x%x\n",
                    VerifyStatus.dwFlags);


            if (0 != dwError)
                printf("Failed, CertVerifyCTLUsage returned Success, not the expected dwError: 0x%x (%d)\n",
                    dwError, dwError);
        } else {
            printf("CertVerifyCTLUsage:: dwError: 0x%x (%d)\n",
                VerifyStatus.dwError, VerifyStatus.dwError);
            if (dwError != VerifyStatus.dwError)
                printf("Failed, CertVerifyCTLUsage didn't return the expected dwError: 0x%x (%d)\n",
                    dwError, dwError);
        }
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    while (cSubject--)
        CertFreeCertificateContext(rgpSubject[cSubject]);
    while (VerifyPara.cCtlStore--) {
        if (!CertCloseStore(VerifyPara.rghCtlStore[VerifyPara.cCtlStore],
                 CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(CtlStore)");
    }
    while (VerifyPara.cSignerStore--) {
        if (!CertCloseStore(VerifyPara.rghSignerStore[VerifyPara.cSignerStore],
                 CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(SignerStore)");
    }
        

    return status;

BadUsage:
    Usage();
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tdecode\tdecode.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tdecode.h
//
//  Contents:   The header of tdecode.cpp.  The API testing of CryptEncodeObject/CryptDecodeObject.  
//
//  History:    22-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __TDECODE_H__
#define __TDECODE_H__


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


#include "wincrypt.h"
#include "asn1code.h"


//--------------------------------------------------------------------------
//	  Contant Defines
//--------------------------------------------------------------------------
#define	CRYPT_DECODE_COPY_FLAG			0 
#define	MSG_ENCODING_TYPE				PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING
#define	CRYPT_ENCODE_TYPE				X509_ASN_ENCODING	
#define	LENGTH_LESS						1
#define	LENGTH_MORE						100
#define INVALID_LPSZSTRUCTTYPE			((LPCSTR) 5000)

#define	CERT_CRL_FILE					0x1
#define	CERT_REQUEST_FILE				0x2
#define	SIGNED_MSG_FILE					0x4

#define	CERT_INFO_STRUCT				0x1
#define	CRL_INFO_STRUCT					0x2
#define	CERT_REQUEST_INFO_STRUCT		0x4

#define	CROW							16

char	szSubsystemProtocol[] = "MY";
char	szEncodedSizeInconsistent[] = "The two encoded BLOBs have different size!\n";
char	szEncodedContentInconsistent[] = "The two encoded BLOBs have different content!\n";

//--------------------------------------------------------------------------
//	 Macros
//--------------------------------------------------------------------------

//Macros for memory management
#define SAFE_FREE(p1)	{if(p1) {free(p1);p1=NULL;}}  
#define SAFE_ALLOC(p1) malloc(p1)
#define	CHECK_POINTER(pv) { if(!pv) goto TCLEANUP;}


//Macros for error checking
#define TESTC(rev,exp)   {if(!TCHECK(rev,exp)) goto TCLEANUP; }
#define TCHECK(rev,exp)	 (Validate(GetLastError(), (rev)==(exp), (char *)(__FILE__), __LINE__))
#define TCHECKALL(rev, exp1, exp2) (Validate((DWORD) (rev), ((rev)==(exp1)||(rev)==(exp2)), (char *)(__FILE__), __LINE__))	
#define	PROCESS_ERR(ErrMsg) {printf(ErrMsg);g_dwErrCnt++;}
#define	PROCESS_ERR_GOTO(ErrMsg)	{PROCESS_ERR(ErrMsg); goto TCLEANUP;}




//--------------------------------------------------------------------------
//	Inline Function 
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//	 Function Prototype
//--------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//Error Manipulations
void	DisplayTestResult(DWORD	dwErrCnt);
BOOL	Validate(DWORD dwErr, BOOL	fSame, char *szFile, DWORD	dwLine);
static	void Usage(void);
void	OutputError(LPCSTR	lpszStructType, DWORD cbSecondEncoded, DWORD cbEncoded,
					BYTE *pbSecondEncoded, BYTE *pbEncoded);

void	PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize);

///////////////////////////////////////////////////////////////////////////////
//Certificate Manipulations
BOOL	DecodeCertFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);

BOOL	DecodeCertReqFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);

BOOL	DecodeSignedMsgFile(LPSTR	pszFileName, BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);


BOOL	DecodeBLOB(LPCSTR	lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
				   DWORD	dwDecodeFlags, DWORD	*pcbStructInfo, void **ppvStructInfo,
				   BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	EncodeStruct(LPCSTR	lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
					 BYTE **ppbEncoded);

BOOL	EncodeAndVerify(LPCSTR	lpszStructType, void *pvStructInfo, DWORD cbEncoded, 
						BYTE *pbEncoded);

BOOL	DecodeX509_CERT(DWORD	dwCertType,DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						void *pInfoStruct);

BOOL	DecodeX509_CERT_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeX509_CERT_REQUEST_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeX509_CERT_CRL_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeRSA_CSP_PUBLICKEYBLOB(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodePKCS_TIME_REQUEST(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeX509_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodePKCS7_SIGNER_INFO(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeX509_UNICODE_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeX509_EXTENSIONS(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCryptAttribute(PCRYPT_ATTRIBUTE pCryptAttribute,DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeCRLEntry(PCRL_ENTRY pCrlEntry, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeBasedOnObjID(LPSTR	szObjId,	DWORD	cbData, BYTE	*pbData,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCertAltNameEntry(PCERT_ALT_NAME_ENTRY	pCertAltNameEntry,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeGenericBLOB(LPCSTR	lpszStructInfo, DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

///////////////////////////////////////////////////////////////////////////////
//General Parameter Testing routines
BOOL	ParameterTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded);
BOOL	MismatchTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded,
						DWORD	cbStructInfo);

///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines
BOOL	RetrieveBLOBfromFile(LPSTR	pszFileName,DWORD *pcbEncoded,BYTE **ppbEncoded);

BOOL	EncodeSignerInfoWAttr(PCMSG_SIGNER_INFO pSignerInfo,DWORD *pbSignerEncoded,
								BYTE **ppbSignerEncoded);

BOOL	CompareTimeStampRequest(CRYPT_TIME_STAMP_REQUEST_INFO *pReqNew,
								CRYPT_TIME_STAMP_REQUEST_INFO *pReqOld);

BOOL	VerifyAlgorithParam(PCRYPT_ALGORITHM_IDENTIFIER pAlgorithm);

BOOL	VerifyPKCS_UTC_TIME(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyPKCS_TIME_REQUEST(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyAttributes(DWORD	cAttr, PCRYPT_ATTRIBUTE	rgAttr,					
			DWORD dwDecodeFlags, BOOL fEncode, BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyPublicKeyInfo(PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
							DWORD dwDecodeFlags,	BOOL fEncode,
							BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension,
							 DWORD  dwDecodeFlags,	BOOL fEncode,
							 BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

LPCSTR	MapObjID2StructType(LPSTR	szObjectID);

#endif // __TDECODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\textstor\textstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       textstor.cpp
//
//  Contents:   Test External Certificate Store Provider
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              DllMain
//              DllCanUnloadNow
//              I_CertDllOpenTestExtStoreProvW
//
//  History:    09-Sep-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20

static HMODULE hMyModule;

#define sz_CERT_STORE_PROV_TEST_EXT     "TestExt"
#define TEST_EXT_OPEN_STORE_PROV_FUNC   "I_CertDllOpenTestExtStoreProvW"


//+-------------------------------------------------------------------------
//  External Store Provider handle information
//--------------------------------------------------------------------------


typedef struct _FIND_EXT_INFO FIND_EXT_INFO, *PFIND_EXT_INFO;
struct _FIND_EXT_INFO {
    DWORD               dwContextType;
    void                *pvContext;
};

typedef struct _EXT_STORE {
    HCERTSTORE          hExtCertStore;
} EXT_STORE, *PEXT_STORE;



//+-------------------------------------------------------------------------
//  External Store Provider Functions.
//--------------------------------------------------------------------------
static void WINAPI ExtStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
static BOOL WINAPI ExtStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
static BOOL WINAPI ExtStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
static BOOL WINAPI ExtStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static BOOL WINAPI ExtStoreProvFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCERT_CONTEXT pPrevCertContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static BOOL WINAPI ExtStoreProvFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCRL_CONTEXT pPrevCrlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static BOOL WINAPI ExtStoreProvFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCTL_CONTEXT pPrevCtlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static void * const rgpvExtStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    ExtStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    ExtStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    ExtStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    ExtStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    ExtStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    ExtStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    ExtStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    ExtStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    ExtStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    ExtStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    ExtStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    ExtStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    ExtStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    ExtStoreProvControl,
    // CERT_STORE_PROV_FIND_CERT_FUNC          14
    ExtStoreProvFindCert,
    // CERT_STORE_PROV_FREE_FIND_CERT_FUNC     15
    ExtStoreProvFreeFindCert,
    // CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC  16
    ExtStoreProvGetCertProperty,
    // CERT_STORE_PROV_FIND_CRL_FUNC           17
    ExtStoreProvFindCrl,
    // CERT_STORE_PROV_FREE_FIND_CRL_FUNC      18
    ExtStoreProvFreeFindCrl,
    // CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC   19
    ExtStoreProvGetCrlProperty,
    // CERT_STORE_PROV_FIND_CTL_FUNC           20
    ExtStoreProvFindCtl,
    // CERT_STORE_PROV_FREE_FIND_CTL_FUNC      21
    ExtStoreProvFreeFindCtl,
    // CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC   22
    ExtStoreProvGetCtlProperty
};
#define EXT_STORE_PROV_FUNC_COUNT (sizeof(rgpvExtStoreProvFunc) / \
                                    sizeof(rgpvExtStoreProvFunc[0]))



//+-------------------------------------------------------------------------
//  CertStore allocation and free functions
//--------------------------------------------------------------------------
static void *CSAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void *CSRealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void CSFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Create, add, remove and free external store find info functions
//--------------------------------------------------------------------------


static PFIND_EXT_INFO CreateExtInfo(
    IN DWORD dwContextType,
    IN void *pvContext              // already AddRef'ed
    )
{
    PFIND_EXT_INFO pFindExtInfo;

    if (pFindExtInfo = (PFIND_EXT_INFO) CSAlloc(sizeof(FIND_EXT_INFO))) {
        pFindExtInfo->dwContextType = dwContextType;
        pFindExtInfo->pvContext = pvContext;
    }
    return pFindExtInfo;
}

static void FreeExtInfo(
    IN PFIND_EXT_INFO pFindExtInfo
    )
{
    void *pvContext;

    if (NULL == pFindExtInfo)
        return;

    pvContext = pFindExtInfo->pvContext;
    if (pvContext) {
        switch (pFindExtInfo->dwContextType) {
            case (CERT_STORE_CERTIFICATE_CONTEXT - 1):
                CertFreeCertificateContext((PCCERT_CONTEXT) pvContext);
                break;
            case (CERT_STORE_CRL_CONTEXT - 1):
                CertFreeCRLContext((PCCRL_CONTEXT) pvContext);
                break;
            case (CERT_STORE_CTL_CONTEXT - 1):
                CertFreeCTLContext((PCCTL_CONTEXT) pvContext);
                break;
            default:
                assert(pFindExtInfo->dwContextType < CERT_STORE_CTL_CONTEXT);
        }
    }

    CSFree(pFindExtInfo);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hMyModule = hModule;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    default:
        break;
    }

    return TRUE;
}

STDAPI  DllCanUnloadNow(void)
{
    // Return S_FALSE inhibit unloading.
    // return S_FALSE;
    return S_OK;
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

static HRESULT GetDllFilename(
    OUT WCHAR wszModule[_MAX_PATH]
    )
{
    char szModule[_MAX_PATH];
    LPSTR pszModule;
    int cchModule;

    // Get name of this DLL.
    if (0 == GetModuleFileNameA(hMyModule, szModule, _MAX_PATH))
        return HError();

    // Strip off the Dll filename's directory components
    cchModule = strlen(szModule);
    pszModule = szModule + cchModule;
    while (cchModule-- > 0) {
        pszModule--;
        if ('\\' == *pszModule || ':' == *pszModule) {
            pszModule++;
            break;
        }
    }
    if (0 >= MultiByteToWideChar(
            CP_ACP,
            0,                      // dwFlags
            pszModule,
            -1,                     // null terminated
            wszModule,
            _MAX_PATH))
        return HError();

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllRegisterServer
//--------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    WCHAR wszModule[_MAX_PATH];

    if (FAILED(hr = GetDllFilename(wszModule)))
        return hr;

    if (!CryptRegisterOIDFunction(
            0,                                // dwEncodingType
            CRYPT_OID_OPEN_STORE_PROV_FUNC,
            sz_CERT_STORE_PROV_TEST_EXT,
            wszModule,
            TEST_EXT_OPEN_STORE_PROV_FUNC
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllUnregisterServer
//--------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    WCHAR wszModule[_MAX_PATH];

    if (FAILED(hr = GetDllFilename(wszModule)))
        return hr;
    if (!CryptUnregisterOIDFunction(
            0,                                // dwEncodingType
            CRYPT_OID_OPEN_STORE_PROV_FUNC,
            sz_CERT_STORE_PROV_TEST_EXT
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            return HError();
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//  Implement the "test" external store by opening the corresponding system
//  registry store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenTestExtStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    PEXT_STORE pExtStore = NULL;

    if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    dwFlags |= CERT_STORE_NO_CRYPT_RELEASE_FLAG;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara
            );
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
        if (0 == GetLastError())
            return TRUE;
        else
            return FALSE;
    }

    if (NULL == (pExtStore = (PEXT_STORE) CSAlloc(sizeof(EXT_STORE))))
        goto OutOfMemory;
    memset(pExtStore, 0, sizeof(EXT_STORE));

    if (NULL == (pExtStore->hExtCertStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara
            )))
        goto OpenStoreError;

    pStoreProvInfo->cStoreProvFunc = EXT_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvExtStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pExtStore;
    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_EXTERNAL_FLAG;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    ExtStoreProvClose((HCERTSTOREPROV) pExtStore, 0);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(OpenStoreError)
}


//+-------------------------------------------------------------------------
//  Close the registry's store by closing its opened registry subkeys
//--------------------------------------------------------------------------
static void WINAPI ExtStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    if (pExtStore) {
        if (pExtStore->hExtCertStore)
            CertCloseStore(pExtStore->hExtCertStore, 0);
        CSFree(pExtStore);
    }
}

//+---------------------------------------------------------------------------
//  Find certificate in system store corresponding to pCertContext
//----------------------------------------------------------------------------
static PCCERT_CONTEXT FindCorrespondingCertificate (
    IN HCERTSTORE hExtCertStore,
    IN PCCERT_CONTEXT pCertContext
    )
{
    DWORD           cbHash = MAX_HASH_LEN;
    BYTE            aHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    if ( CertGetCertificateContextProperty(
             pCertContext,
             CERT_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    HashBlob.cbData = cbHash;
    HashBlob.pbData = aHash;

    return( CertFindCertificateInStore(
                hExtCertStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_HASH,
                &HashBlob,
                NULL
                ) );
}

//+---------------------------------------------------------------------------
//  Find CRL in system store corresponding to pCrlContext
//----------------------------------------------------------------------------
static PCCRL_CONTEXT FindCorrespondingCrl (
    IN HCERTSTORE hExtCertStore,
    IN PCCRL_CONTEXT pCrlContext
    )
{
    DWORD         cbHash = MAX_HASH_LEN;
    BYTE          aHash[MAX_HASH_LEN];
    DWORD         cbFindHash = MAX_HASH_LEN;
    BYTE          aFindHash[MAX_HASH_LEN];
    PCCRL_CONTEXT pFindCrl = NULL;
    DWORD         dwFlags = 0;

    if ( CertGetCRLContextProperty(
             pCrlContext,
             CERT_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    while ( ( pFindCrl = CertGetCRLFromStore(
                             hExtCertStore,
                             NULL,
                             pFindCrl,
                             &dwFlags
                             ) ) != NULL )
    {
        if ( CertGetCRLContextProperty(
                 pFindCrl,
                 CERT_HASH_PROP_ID,
                 aFindHash,
                 &cbFindHash
                 ) == TRUE )
        {
            if ( cbHash == cbFindHash )
            {
                if ( memcmp( aHash, aFindHash, cbHash ) == 0 )
                {
                    return( pFindCrl );
                }
            }
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//  Find CTL in system store corresponding to pCtlContext
//----------------------------------------------------------------------------
static PCCTL_CONTEXT FindCorrespondingCtl (
    IN HCERTSTORE hExtCertStore,
    IN PCCTL_CONTEXT pCtlContext
    )
{
    DWORD           cbHash = MAX_HASH_LEN;
    BYTE            aHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    if ( CertGetCTLContextProperty(
             pCtlContext,
             CERT_SHA1_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    HashBlob.cbData = cbHash;
    HashBlob.pbData = aHash;

    return( CertFindCTLInStore(
                hExtCertStore,
                X509_ASN_ENCODING,
                0,
                CTL_FIND_SHA1_HASH,
                &HashBlob,
                NULL
                ) );
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the certificate and its properties from
//  the registry and create a new certificate context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCertContext = FindCorrespondingCertificate(
        pExtStore->hExtCertStore, pStoreCertContext);

    *ppProvCertContext = pProvCertContext;
    return NULL != pProvCertContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded certificate and its properties and write to
//  the registry.
//
//  Called before the certificate is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCertificateContextToStore(
        pExtStore->hExtCertStore,
        pCertContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the registry.
//
//  Called before the certificate is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCertificate(
            pExtStore->hExtCertStore, pCertContext))
        return CertDeleteCertificateFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified certificate from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the certificate to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the certificate in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCertificate(
            pExtStore->hExtCertStore, pCertContext)) {
        BOOL fResult;

        fResult = CertSetCertificateContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCertificateContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CRL and its properties from
//  the registry and create a new CRL context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pProvCrlContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCrlContext = FindCorrespondingCrl(
        pExtStore->hExtCertStore, pStoreCrlContext);

    *ppProvCrlContext = pProvCrlContext;
    return NULL != pProvCrlContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CRL and its properties and write to
//  the registry.
//
//  Called before the CRL is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCRLContextToStore(
        pExtStore->hExtCertStore,
        pCrlContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified CRL from the registry.
//
//  Called before the CRL is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCrl(
            pExtStore->hExtCertStore, pCrlContext))
        return CertDeleteCRLFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified CRL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CRL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CRL in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCrl(
            pExtStore->hExtCertStore, pCrlContext)) {
        BOOL fResult;

        fResult = CertSetCRLContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCRLContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CTL and its properties from
//  the registry and create a new CTL context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pProvCtlContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCtlContext = FindCorrespondingCtl(
        pExtStore->hExtCertStore, pStoreCtlContext);

    *ppProvCtlContext = pProvCtlContext;
    return NULL != pProvCtlContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CTL and its properties and write to
//  the registry.
//
//  Called before the CTL is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCTLContextToStore(
        pExtStore->hExtCertStore,
        pCtlContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified CTL from the registry.
//
//  Called before the CTL is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCtl(
            pExtStore->hExtCertStore, pCtlContext))
        return CertDeleteCTLFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified CTL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CTL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CTL in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCtl(
            pExtStore->hExtCertStore, pCtlContext)) {
        BOOL fResult;

        fResult = CertSetCTLContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCTLContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}


static BOOL WINAPI ExtStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    assert(pExtStore && pExtStore->hExtCertStore);
    return CertControlStore(
        pExtStore->hExtCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
        );
}

static BOOL WINAPI ExtStoreProvFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCERT_CONTEXT pPrevCertContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCERT_CONTEXT pPrevExtContext;
    PCCERT_CONTEXT pProvCertContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCERT_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCertContext == pPrevExtContext);

    if (pProvCertContext = CertFindCertificateInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCertificateContext(
                pProvCertContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CERTIFICATE_CONTEXT - 1,
                    (void *) pProvCertContext
                    ))
                pProvCertContext = CertDuplicateCertificateContext(
                    pProvCertContext);
            else {
                CertFreeCertificateContext(pProvCertContext);
                pProvCertContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCert(
            hStoreProv,
            pPrevCertContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCertContext = pProvCertContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCertContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

static PCCRL_CONTEXT WINAPI FindCrlInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    DWORD dwFlags = 0;

    switch (dwFindType) {
        case CRL_FIND_ANY:
            return CertGetCRLFromStore(
                hCertStore,
                NULL,               // pIssuerContext,
                pPrevCrlContext,
                &dwFlags
                );
            break;

        case CRL_FIND_ISSUED_BY:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvFindPara;

                return CertGetCRLFromStore(
                    hCertStore,
                    pIssuer,
                    pPrevCrlContext,
                    &dwFlags
                    );
            }
            break;

        case CRL_FIND_EXISTING:
            {
                PCCRL_CONTEXT pCrl = pPrevCrlContext;

                while (pCrl = CertGetCRLFromStore(
                        hCertStore,
                        NULL,               // pIssuerContext,
                        pCrl,
                        &dwFlags)) {
                    PCCRL_CONTEXT pNew = (PCCRL_CONTEXT) pvFindPara;
                    if (pNew->dwCertEncodingType == pCrl->dwCertEncodingType &&
                            CertCompareCertificateName(
                                pNew->dwCertEncodingType,
                                &pCrl->pCrlInfo->Issuer,
                                &pNew->pCrlInfo->Issuer))
                        return pCrl;
                }
                return NULL;
            }
            break;

        default:
            SetLastError((DWORD) ERROR_NOT_SUPPORTED);
            return NULL;
    }

}

static BOOL WINAPI ExtStoreProvFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCRL_CONTEXT pPrevCrlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCRL_CONTEXT pPrevExtContext;
    PCCRL_CONTEXT pProvCrlContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CRL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCRL_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCrlContext == pPrevExtContext);

    if (pProvCrlContext = FindCrlInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCRLContext(
                pProvCrlContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CRL_CONTEXT - 1,
                    (void *) pProvCrlContext
                    ))
                pProvCrlContext = CertDuplicateCRLContext(
                    pProvCrlContext);
            else {
                CertFreeCRLContext(pProvCrlContext);
                pProvCrlContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCrl(
            hStoreProv,
            pPrevCrlContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCrlContext = pProvCrlContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCrlContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CRL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

static BOOL WINAPI ExtStoreProvFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCTL_CONTEXT pPrevCtlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCTL_CONTEXT pPrevExtContext;
    PCCTL_CONTEXT pProvCtlContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CTL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCTL_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCtlContext == pPrevExtContext);

    if (pProvCtlContext = CertFindCTLInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCTLContext(
                pProvCtlContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CTL_CONTEXT - 1,
                    (void *) pProvCtlContext
                    ))
                pProvCtlContext = CertDuplicateCTLContext(pProvCtlContext);
            else {
                CertFreeCTLContext(pProvCtlContext);
                pProvCtlContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCtl(
            hStoreProv,
            pPrevCtlContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCtlContext = pProvCtlContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCtlContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CTL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tdotoid\tdotoid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tdotoid.cpp
//
//  Contents:   Convert Dot OID ("1.2.3") to ASN.1 encoded content octets.
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Jan-01   philh   created
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"
#include "asn1util.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};

const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - type EncodedObjectID,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
};

#define ATTR_OID_VALUE_INDEX        1
#define ATTR_VALUE_COUNT            \
    (sizeof(rgExtractAttrPara) / sizeof(rgExtractAttrPara[0]))

void DotValToEncodedOid(
    LPCSTR pszDotVal
    )
{
    CRYPT_ATTRIBUTE Attr;
    BYTE rgbEncoded[512];
    DWORD cbEncoded;
    CRYPT_DER_BLOB rgValueBlob[ATTR_VALUE_COUNT];
    DWORD cValue;
    DWORD i;
    BYTE *pb;
    DWORD cb;

    // Encode an Attribute that only has the OID.
    Attr.pszObjId = (LPSTR) pszDotVal;
    Attr.cValue = 0;
    Attr.rgValue = NULL;

    cbEncoded = sizeof(rgbEncoded);
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            &Attr,
            rgbEncoded,
            &cbEncoded
            )) {
        printf("\n");
        printf("Asn1Encode(%s)", pszDotVal);
        PrintLastError("");
        return;
    }

    cValue = ATTR_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            rgbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &cValue,
            rgExtractAttrPara,
            rgValueBlob
            ) || ATTR_OID_VALUE_INDEX >= cValue) {
        printf("\n");
        printf("ExtractValues(%s)", pszDotVal);
        PrintLastError("");
        return;
    }

    pb = rgValueBlob[ATTR_OID_VALUE_INDEX].pbData;
    cb = rgValueBlob[ATTR_OID_VALUE_INDEX].cbData;

    printf("\n// \"%s\"\n{", pszDotVal);
    for (i = 0; i < cb; i++) {
        printf("0x%02X", pb[i]);
        if ((i+1) < cb)
            printf(", ");
    }
    printf("};\n\n");
}


void Usage(void)
{
    int i;

    printf("Usage: tdotoid <OID String 1> <OID String 2> ...\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{

    int ReturnStatus;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'h':
                default:
                    goto BadUsage;
            }
        } else
            DotValToEncodedOid(argv[0]);
    }

    ReturnStatus = 0;
CommonReturn:
    return ReturnStatus;

BadUsage:
    Usage();
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tencode\tencode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tencode.cpp
//
//  Contents:   Test the encode/decode APIs. Test all the different length
//              cases.
//
//
//  Functions:  main
//
//  History:    17-Dec-96   philh   created
//              
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#define DELTA_MORE_LENGTH    32
#define DELTA_LESS_LENGTH    8

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    IN DWORD dwFlags = 0,
    IN BOOL fIgnoreError = FALSE
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        dwFlags | CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult && !fIgnoreError) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *AllocAndDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbStructInfo = NULL,
    IN DWORD        dwFlags = 0
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}


static void TestX942OtherInfo()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_X942_OTHER_INFO pInfo = NULL;

    CRYPT_X942_OTHER_INFO X942OtherInfo;
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgbPubInfo[] = {0x11, 0x22, 0x33, 0x44, 0x55};

    X942OtherInfo.pszContentEncryptionObjId = (LPSTR) pszObjId;
    X942OtherInfo.rgbCounter[0] = 0x00;
    X942OtherInfo.rgbCounter[1] = 0x11;
    X942OtherInfo.rgbCounter[2] = 0x22;
    X942OtherInfo.rgbCounter[3] = 0x33;
    X942OtherInfo.rgbKeyLength[0] = 192;
    X942OtherInfo.rgbKeyLength[1] = 0x00;
    X942OtherInfo.rgbKeyLength[2] = 0x00;
    X942OtherInfo.rgbKeyLength[3] = 0x00;
    X942OtherInfo.PubInfo.cbData = sizeof(rgbPubInfo);
    X942OtherInfo.PubInfo.pbData = rgbPubInfo;

    printf("Test encode/decode X942_OTHER_INFO\n");
    if (!AllocAndEncodeObject(
            X942_OTHER_INFO,
            &X942OtherInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_X942_OTHER_INFO) AllocAndDecodeObject(
            X942_OTHER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszContentEncryptionObjId, pszObjId) ||
            pInfo->PubInfo.cbData != sizeof(rgbPubInfo) ||
            0 != memcmp(pInfo->PubInfo.pbData, rgbPubInfo,
                sizeof(rgbPubInfo)) ||
            0 != memcmp(X942OtherInfo.rgbCounter, pInfo->rgbCounter,
                sizeof(X942OtherInfo.rgbCounter)) ||
            0 != memcmp(X942OtherInfo.rgbKeyLength, pInfo->rgbKeyLength,
                sizeof(X942OtherInfo.rgbKeyLength)))
        printf("X942_OTHER_INFO failed => decode != encode input\n");


    printf("Test encode/decode X942_OTHER_INFO with No PubInfo\n");
    X942OtherInfo.PubInfo.cbData = 0;
    X942OtherInfo.PubInfo.pbData = NULL;

    TestFree(pbEncoded);
    if (!AllocAndEncodeObject(
            X942_OTHER_INFO,
            &X942OtherInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    TestFree(pInfo);
    if (NULL == (pInfo = (PCRYPT_X942_OTHER_INFO) AllocAndDecodeObject(
            X942_OTHER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszContentEncryptionObjId, pszObjId) ||
            pInfo->PubInfo.cbData != 0 ||
            0 != memcmp(X942OtherInfo.rgbCounter, pInfo->rgbCounter,
                sizeof(X942OtherInfo.rgbCounter)) ||
            0 != memcmp(X942OtherInfo.rgbKeyLength, pInfo->rgbKeyLength,
                sizeof(X942OtherInfo.rgbKeyLength)))
        printf("X942_OTHER_INFO failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}


static void TestExtensions()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbT61Encoded = NULL;
    DWORD cbT61Encoded;

    PCERT_EXTENSIONS pInfo = NULL;

    BYTE rgbExt[] = {0x1, 0x2, 0x3};
    CERT_EXTENSION Ext[2] = {
        "1.2.3.4.5", TRUE, sizeof(rgbExt), rgbExt,
        "1.2.3.6.7", FALSE, sizeof(rgbExt), rgbExt
    };
    CERT_EXTENSIONS ExtsInfo;
    CERT_NAME_VALUE T61ExtsInfo;

    ExtsInfo.cExtension = 2;
    ExtsInfo.rgExtension = Ext;

    printf("Test encode/decode X509_EXTENSIONS\n");
    if (!AllocAndEncodeObject(
            X509_EXTENSIONS,
            &ExtsInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
            X509_EXTENSIONS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cExtension != ExtsInfo.cExtension ||
        0 != strcmp(pInfo->rgExtension[0].pszObjId,
            ExtsInfo.rgExtension[0].pszObjId))
        printf("X509_EXTENSIONS failed => decode != encode input\n");

    TestFree(pInfo);
    pInfo = NULL;

    printf("Test encode/decode T61 wrapped X509_EXTENSIONS\n");

    T61ExtsInfo.dwValueType = CERT_RDN_T61_STRING;
    T61ExtsInfo.Value.cbData = cbEncoded;
    T61ExtsInfo.Value.pbData = pbEncoded;

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &T61ExtsInfo,
            &pbT61Encoded,
            &cbT61Encoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
            X509_EXTENSIONS,
            pbT61Encoded,
            cbT61Encoded
            ))) goto CommonReturn;

    if (pInfo->cExtension != ExtsInfo.cExtension ||
        0 != strcmp(pInfo->rgExtension[0].pszObjId,
            ExtsInfo.rgExtension[0].pszObjId))
        printf("T61 wrapped X509_EXTENSIONS failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pbT61Encoded)
        TestFree(pbT61Encoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestPKCSAttribute()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTE pInfo = NULL;

    CRYPT_ATTRIBUTE Attribute;
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    Attribute.pszObjId = (LPSTR) pszObjId;
    Attribute.cValue = 2;
    Attribute.rgValue = rgValue;

    printf("Test encode/decode PKCS_ATTRIBUTE\n");
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTE) AllocAndDecodeObject(
            PKCS_ATTRIBUTE,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, pszObjId) ||
            pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("PKCS_ATTRIBUTE failed => decode != encode input\n");


    printf("Test encode/decode PKCS_ATTRIBUTE with empty OID\n");
    TestFree(pbEncoded);
    Attribute.pszObjId = "";
    if (AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded,
            0,                  // dwFlags
            TRUE))              // fIgnoreError
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        printf("  Got LastError: 0x%x (%d)\n",  dwErr, dwErr);
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestPKCSAttributes()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTES pInfo = NULL;
    DWORD i;

#define ATTRIBUTE_CNT   3
    CRYPT_ATTRIBUTES Attributes;
    CRYPT_ATTRIBUTE rgAttribute[ATTRIBUTE_CNT];
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    for (i = 0; i < ATTRIBUTE_CNT; i++) {
        rgAttribute[i].pszObjId = (LPSTR) pszObjId;
        rgAttribute[i].cValue = 2;
        rgAttribute[i].rgValue = rgValue;
    }

    Attributes.cAttr = ATTRIBUTE_CNT;
    Attributes.rgAttr = rgAttribute;

    printf("Test encode/decode PKCS_ATTRIBUTES\n");
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTES,
            &Attributes,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTES) AllocAndDecodeObject(
            PKCS_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    // Note, ATTRIBUTES is a SET OF. Entries are re-ordered
    if (pInfo->cAttr != ATTRIBUTE_CNT)
        printf("PKCS_ATTRIBUTES failed => decode != encode attr count\n");
    else {
        for (i = 0; i < ATTRIBUTE_CNT; i++) {
            PCRYPT_ATTRIBUTE pAttr = &pInfo->rgAttr[i];
            if (0 != strcmp(pAttr->pszObjId, pszObjId) ||
                    pAttr->cValue != 2 ||
                    pAttr->rgValue[0].cbData != sizeof(rgb0) ||
                    0 != memcmp(pAttr->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
                    pAttr->rgValue[1].cbData != sizeof(rgb1) ||
                    0 != memcmp(pAttr->rgValue[1].pbData, rgb1, sizeof(rgb1))) {
                printf("PKCS_ATTRIBUTES failed => decode != encode input\n");
                break;
            }
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestContentInfoSequenceOfAny()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo = NULL;

    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY SeqOfAny;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb1[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    CRYPT_DER_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    SeqOfAny.pszObjId = szOID_NETSCAPE_CERT_SEQUENCE;
    SeqOfAny.cValue = 2;
    SeqOfAny.rgValue = rgValue;


    printf("Test encode/decode PKCS_CONTENT_INFO_SEQUENCE_OF_ANY\n");
    if (!AllocAndEncodeObject(
            PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
            &SeqOfAny,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY) AllocAndDecodeObject(
        PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, szOID_NETSCAPE_CERT_SEQUENCE) ||
            pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("PKCS_CONTENT_INFO_SEQUENCE_OF_ANY failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestSequenceOfAny()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_SEQUENCE_OF_ANY pInfo = NULL;

    CRYPT_SEQUENCE_OF_ANY SeqOfAny;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb1[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    CRYPT_DER_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    SeqOfAny.cValue = 2;
    SeqOfAny.rgValue = rgValue;


    printf("Test encode/decode X509_SEQUENCE_OF_ANY\n");
    if (!AllocAndEncodeObject(
            X509_SEQUENCE_OF_ANY,
            &SeqOfAny,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCRYPT_SEQUENCE_OF_ANY) AllocAndDecodeObject(
        X509_SEQUENCE_OF_ANY,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("X509_SEQUENCE_OF_ANY failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestInteger(
        int iEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    int iDecode = 0;
    DWORD cbInfo;

    printf("Test encode/decode X509_INTEGER: 0x%x (%d)\n", iEncode, iEncode);

    if (!AllocAndEncodeObject(
            X509_INTEGER,
            &iEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(iDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_INTEGER,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &iDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(X509_INTEGER)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(iDecode))
        printf("X509_INTEGER failed => unexpected decode length\n");

    if (iEncode != iDecode)
        printf("X509_INTEGER failed => decoded output (%d) != encode input\n",
            iDecode);

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestInteger()
{
    TestInteger(0);
    TestInteger(0x12345678);
    TestInteger(-1234);
    TestInteger(123);
}

static void TestMultiByteInteger(
    BYTE *pb,
    DWORD cb
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_INTEGER_BLOB pInfo = NULL;

    CRYPT_INTEGER_BLOB MultiByteInteger = {cb, pb };

    printf("Test encode/decode X509_MULTI_BYTE_INTEGER\n");
    PrintBytes("  ", pb, cb);
    if (!AllocAndEncodeObject(
            X509_MULTI_BYTE_INTEGER,
            &MultiByteInteger,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_INTEGER_BLOB) AllocAndDecodeObject(
            X509_MULTI_BYTE_INTEGER,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (!CertCompareIntegerBlob(pInfo, &MultiByteInteger))
        printf("X509_MULTI_BYTE_INTEGER failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestMultiByteInteger()
{
    BYTE rgb1[] = {0x11, 0x22, 0x33, 0x44, 0x55};
    BYTE rgb2[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0xFF, 0x00};
    BYTE rgb3[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0xFF, 0xFF};
    BYTE rgb4[] = {0x11, 0x22, 0x33, 0x44, 0x80, 0xFF, 0xFF};
    BYTE rgb5[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x00};
    BYTE rgb6[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x00, 0x00, 0x00};

    TestMultiByteInteger(rgb1, sizeof(rgb1));
    TestMultiByteInteger(rgb2, sizeof(rgb2));
    TestMultiByteInteger(rgb3, sizeof(rgb2));
    TestMultiByteInteger(rgb4, sizeof(rgb2));
    TestMultiByteInteger(rgb5, sizeof(rgb2));
    TestMultiByteInteger(rgb6, sizeof(rgb2));
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

static void TestBits(
    PCRYPT_BIT_BLOB pBits
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_BIT_BLOB pInfo = NULL;

    printf("Test encode/decode X509_BITS(cb:%d, cUnused: %d)\n",
        pBits->cbData, pBits->cUnusedBits);
    PrintBytes("  ", pBits->pbData, pBits->cbData);
    if (!AllocAndEncodeObject(
            X509_BITS,
            pBits,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cbData != pBits->cbData ||
            pInfo->cUnusedBits != pBits->cUnusedBits)
        printf("X509_BITS failed => decode != encode (cbData or cUnusedBits)\n");
    else {
        DWORD cbData = pInfo->cbData;

        if (cbData > 1) {
            if (0 != memcmp(pInfo->pbData, pBits->pbData, cbData - 1))
                printf("X509_BITS failed => decode != encode input\n");
        }

        if (cbData > 0) {
            if ((pBits->pbData[cbData - 1] &
                        rgbUnusedAndMask[pInfo->cUnusedBits]) !=
                    pInfo->pbData[cbData - 1])
                printf("X509_BITS failed => decode != encode (last byte)\n");
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestBits()
{
    BYTE rgb1[] = {0xFF, 0x00, 0x00, 0x00};
    BYTE rgb2[] = {0x00, 0xFE, 0xFC};
    CRYPT_BIT_BLOB Bits;

    memset(&Bits, 0, sizeof(Bits));
    TestBits(&Bits);

    Bits.pbData = rgb1;
    TestBits(&Bits);
    Bits.cbData = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.cbData = sizeof(rgb1);
    Bits.cUnusedBits = 0;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.pbData = rgb2;
    Bits.cUnusedBits = 0;
    Bits.cbData = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.cbData = sizeof(rgb2);
    Bits.cUnusedBits = 0;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);
}


static void TestBitsWithoutTrailingZeroes(
    PCRYPT_BIT_BLOB pBits,
    DWORD cbData,
    DWORD cUnusedBits
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_BIT_BLOB pInfo = NULL;

    printf("Test encode/decode X509_BITS_WO_ZEROES(cb:%d, cUnused: %d) Expected(cb:%d, cUnused:%d)\n",
        pBits->cbData, pBits->cUnusedBits, cbData, cUnusedBits);
    PrintBytes("    Input:: ", pBits->pbData, pBits->cbData);
    if (!AllocAndEncodeObject(
            X509_BITS_WITHOUT_TRAILING_ZEROES,
            pBits,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
            X509_BITS_WITHOUT_TRAILING_ZEROES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;
    PrintBytes("  Encoded:: ", pbEncoded, cbEncoded);

    if (pInfo->cbData != cbData ||
            pInfo->cUnusedBits != cUnusedBits)
        printf("X509_BITS_WO_ZEROES failed => decode != encode (cbData or cUnusedBits)\n");
    else {
        if (cbData > 1) {
            if (0 != memcmp(pInfo->pbData, pBits->pbData, cbData - 1))
                printf("X509_BITS_WO_ZEROES failed => decode != encode input\n");
        }

        if (cbData > 0) {
            if ((pBits->pbData[cbData - 1] &
                        rgbUnusedAndMask[cUnusedBits]) !=
                    pInfo->pbData[cbData - 1])
                printf("X509_BITS_WO_ZEROES failed => decode != encode (last byte)\n");
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestBitsWithoutTrailingZeroes()
{
    BYTE rgb1[] = {0xFF, 0x00, 0x00, 0x00};
    BYTE rgb2[] = {0x00, 0xFE, 0xFC};
    BYTE rgb3[] = {0x00, 0x18, 0x00, 0x20};
    CRYPT_BIT_BLOB Bits;
    int i;
    BYTE b;

    memset(&Bits, 0, sizeof(Bits));
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);

    Bits.pbData = rgb1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cbData = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,1);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 1,7);

    Bits.cbData = sizeof(rgb1);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);

    Bits.pbData = rgb2;
    Bits.cUnusedBits = 0;
    Bits.cbData = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);

    Bits.cbData = sizeof(rgb2);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 2;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 4;
    TestBitsWithoutTrailingZeroes(&Bits, 3,4);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 3,7);

    Bits.pbData = rgb3;
    Bits.cbData = sizeof(rgb3);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 3;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 4;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 5;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 6;
    TestBitsWithoutTrailingZeroes(&Bits, 2,3);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 2,3);

    Bits.pbData = &b;
    Bits.cbData = 1;
    for (i = 0; i <= 7; i++) {
        b = 1 << i;
        Bits.cUnusedBits = 0;
        TestBitsWithoutTrailingZeroes(&Bits, 1,i);
        Bits.cUnusedBits = i;
        TestBitsWithoutTrailingZeroes(&Bits, 1,i);
    }
}

static void TestOID(
    IN LPCSTR pszObjId
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTE pInfo = NULL;

    CRYPT_ATTRIBUTE Attribute;
    memset(&Attribute, 0, sizeof(Attribute));

    Attribute.pszObjId = (LPSTR) pszObjId;
    printf("Test encode/decode OID: %s\n", pszObjId);
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTE) AllocAndDecodeObject(
            PKCS_ATTRIBUTE,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, pszObjId))
        printf("OID failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestOID()
{
    TestOID("0.1");
    TestOID("0.9.2342.19200300.100.1.25");
    TestOID("1.2.3.111111111144444444444");
    TestOID("1.2.3.111111111144444444444.55555555555555555.666666666666666");
    TestOID("1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20");
}


static void TestUnicodeAnyString(
        DWORD dwValueType,
        LPCWSTR pwszValue,
        DWORD dwExpectedErr,
        DWORD dwExpectedErrLocation,
        DWORD dwFlags = 0
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_VALUE pInfo = NULL;

    CERT_NAME_VALUE NameValue;

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = dwValueType;
    NameValue.Value.pbData = (BYTE *) pwszValue;

    if (dwExpectedErr ) {
        printf("Test encode X509_UNICODE_ANY_STRING:: dwValueType: %d 0x%x Expected Err: 0x%x Location: %d\n",
            dwValueType, dwValueType, dwExpectedErr, dwExpectedErrLocation);
        if (CryptEncodeObject(
                dwCertEncodingType,
                X509_UNICODE_ANY_STRING,
                &NameValue,
                NULL,               // pbEncoded
                &cbEncoded
                ))
            printf("  failed => expected error\n");
        else {
            DWORD dwErr = GetLastError();
            if (dwErr != dwExpectedErr)
                printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                    dwExpectedErr, dwExpectedErr, dwErr, dwErr);
            if (dwExpectedErrLocation != cbEncoded)
                printf("  ErrLocation failed => expected: %d, got: %d\n", 
                    dwExpectedErrLocation, cbEncoded);
        }
    }

    printf("Test alloc encode/decode X509_UNICODE_ANY_STRING:: dwValueType: %d 0x%x string: %S\n",
        dwValueType, dwValueType, pwszValue);
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded,
            dwFlags,
            dwExpectedErr != 0   // fIgnoreError
            )) {
        if (dwExpectedErr) {
            DWORD dwErr = GetLastError();
            if (dwErr != dwExpectedErr)
                printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                    dwExpectedErr, dwExpectedErr, dwErr, dwErr);
            if (dwExpectedErrLocation != cbEncoded)
                printf("  ErrLocation failed => expected: %d, got: %d\n", 
                    dwExpectedErrLocation, cbEncoded);
        }
        goto CommonReturn;
    } else if (dwExpectedErr)
        printf("  failed => expected error\n");

    if (NULL == (pInfo = (PCERT_NAME_VALUE) AllocAndDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            NULL,
            dwFlags
            ))) goto CommonReturn;

    if (wcslen(pwszValue) != wcslen((LPWSTR) pInfo->Value.pbData) ||
            wcslen(pwszValue) * 2 != pInfo->Value.cbData ||
            0 != wcscmp(pwszValue, (LPWSTR) pInfo->Value.pbData))
        printf("X509_UNICODE_ANY_STRING failed => decoded output (%S) != encode input\n",
            (LPWSTR) pInfo->Value.pbData);

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestUnicodeAnyString(
        DWORD dwValueType,
        PCRYPT_DATA_BLOB pDataBlob,
        DWORD dwExpectedErr
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD cbInfo;

    CERT_NAME_VALUE NameValue;

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = dwValueType;
    NameValue.Value.pbData = pDataBlob->pbData;
    NameValue.Value.cbData = pDataBlob->cbData;

    printf("Test encode/decode X509_UNICODE_ANY_STRING:: dwValueType: %d Expected Err: 0x%x\n",
        dwValueType, dwExpectedErr);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            &NameValue,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  Encode failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (dwErr != dwExpectedErr)
            printf("  Encode LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    }

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (CryptDecodeObject(
            dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            NULL,               // pInfo
            &cbInfo
            ))
        printf("  Decode failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (dwErr != dwExpectedErr)
            printf("  Decode LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestUnicodeAnyString()
{
    DWORD dwValueType;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x80, 0x33, 0x00};

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // Encoded INTEGER
    CRYPT_DATA_BLOB EncodedBlob = {sizeof(rgb0), rgb0};

    BYTE rgb1[] = {0, 0x11, 0x22, 0x33, 0x44, 0x55};
    CRYPT_DATA_BLOB OctetString = {sizeof(rgb1), rgb1};

    TestUnicodeAnyString(CERT_RDN_ENCODED_BLOB, &EncodedBlob,
        (DWORD) CRYPT_E_NOT_CHAR_STRING);
    TestUnicodeAnyString(CERT_RDN_OCTET_STRING, &OctetString,
        (DWORD) CRYPT_E_NOT_CHAR_STRING);

    TestUnicodeAnyString(CERT_RDN_NUMERIC_STRING,
        L"0123456789 ",
        0, 0);

    for (dwValueType = CERT_RDN_PRINTABLE_STRING;
                        dwValueType <= CERT_RDN_BMP_STRING; dwValueType++)
        TestUnicodeAnyString(dwValueType,
            L"UNICODE string to be encoded",
            0, 0);

    TestUnicodeAnyString(CERT_RDN_ANY_TYPE, L"InvalidArg",
        (DWORD) CRYPT_E_NOT_CHAR_STRING, 0);

    TestUnicodeAnyString(CERT_RDN_NUMERIC_STRING,
//        0123456789012345678901234567890
        L"0123456789a013",
        (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, 10);
    TestUnicodeAnyString(CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, 18);

    TestUnicodeAnyString(CERT_RDN_DISABLE_CHECK_TYPE_FLAG |
        CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        0, 0);

    TestUnicodeAnyString(CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        0, 0,
        CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG);

    TestUnicodeAnyString(CERT_RDN_T61_STRING,
//        0123456789012345678901234567890
        L"T61 ### az AZ 09 \'()+,-./:=?",
        0, 0, 0);

    TestUnicodeAnyString(CERT_RDN_T61_STRING,
//        0123456789012345678901234567890
        L"T61 ### az AZ 09 \'()+,-./:=?",
        0, 0, CERT_RDN_DISABLE_IE4_UTF8_FLAG);

    TestUnicodeAnyString(CERT_RDN_IA5_STRING,
        rgwBadIA5,
        (DWORD) CRYPT_E_INVALID_IA5_STRING, 3);

}

static void TestUniversalString()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_VALUE pInfo = NULL;

    CERT_NAME_VALUE NameValue;

    DWORD rgdwUniversal[] = {
        0x00ffff,
        0x110000,
        0x010000,
        0xffffffff,
        0x110001,
        0x10FFFF,
        };

    LPWSTR pwszExpectedUniversal =
        L"\xffff"
        L"\xfffd"
        L"\xd800\xdc00"
        L"\xfffd"
        L"\xfffd"
        L"\xdbff\xdfff"
        ;

    TestUnicodeAnyString(CERT_RDN_UNIVERSAL_STRING,
        L"SPECIAL UNIVERSAL with Surrogate Pairs: "
        L"\xd800\xdc00\xdbff\xdfff"
        L"\xdbfe\xdc03\xd801\xdfcf"
        L"\xd801\x0081\xdc01\xdc02"
        L"\xd805\xd806\xd807\xdc04"
        L"\xd802\xd803\xfffe\xd804",
        0, 0, 0);


    // Encode a universal string containing characters > 0x10FFFF. These
    // Should be converted to 0xFFFD

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = CERT_RDN_UNIVERSAL_STRING;
    NameValue.Value.pbData = (BYTE *) rgdwUniversal;
    NameValue.Value.cbData = sizeof(rgdwUniversal);

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded
            )) {
        goto CommonReturn;
    }

    if (NULL == (pInfo = (PCERT_NAME_VALUE) AllocAndDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            NULL
            ))) goto CommonReturn;

    if (wcslen(pwszExpectedUniversal) != wcslen((LPWSTR) pInfo->Value.pbData) ||
            wcslen(pwszExpectedUniversal) * 2 != pInfo->Value.cbData ||
            0 != wcscmp(pwszExpectedUniversal, (LPWSTR) pInfo->Value.pbData))
        printf("UniversalString encode/decode failed\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestChoiceOfTime(
        FILETIME *pftEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    FILETIME ftDecode;
    DWORD cbInfo;

    printf("Test encode/decode X509_CHOICE_OF_TIME: %s\n",
        FileTimeText(pftEncode));
    if (!AllocAndEncodeObject(
            X509_CHOICE_OF_TIME,
            pftEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(ftDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_CHOICE_OF_TIME,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &ftDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(X509_CHOICE_OF_TIME)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(ftDecode))
        printf("X509_CHOICE_OF_TIME failed => unexpected decode length\n");

    if (0 != memcmp(pftEncode, &ftDecode, sizeof(ftDecode)))
        printf("X509_CHOICE_OF_TIME failed => decode (%s) != encode input\n",
            FileTimeText(&ftDecode));

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestChoiceOfTime()
{
    FILETIME ft;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = 2000;
    t.wMonth  = 1;
    t.wDay    = 2;
    t.wHour   = 3;
    t.wMinute = 4;
    t.wSecond = 5;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);

    t.wYear   = 1900;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);

    t.wYear   = 2080;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);
}

static void TestUtcTime(
        FILETIME *pftEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    FILETIME ftDecode;
    DWORD cbInfo;

    printf("Test encode/decode PKCS_UTC_TIME: %s\n",
        FileTimeText(pftEncode));
    if (!AllocAndEncodeObject(
            PKCS_UTC_TIME,
            pftEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(ftDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            PKCS_UTC_TIME,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &ftDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(PKCS_UTC_TIME)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(ftDecode))
        printf("PKCS_UTC_TIME failed => unexpected decode length\n");

    if (0 != memcmp(pftEncode, &ftDecode, sizeof(ftDecode)))
        printf("PKCS_UTC_TIME failed => decode (%s) != encode input\n",
            FileTimeText(&ftDecode));

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestUtcTime()
{
    FILETIME ft;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = 1950;
    t.wMonth  = 1;
    t.wDay    = 2;
    t.wHour   = 3;
    t.wMinute = 4;
    t.wSecond = 5;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);

    t.wYear   = 2049;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);

    t.wMonth  = 1;
    t.wDay    = 1;
    t.wHour   = 0;
    t.wMinute = 0;
    t.wSecond = 0;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);
}

static void TestBadAltName(
        PCERT_ALT_NAME_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_ALTERNATE_NAME:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAltName()
{
    CERT_ALT_NAME_INFO AltNameInfo;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define ALT_NAME_ENTRY_CNT  4
    CERT_ALT_NAME_ENTRY rgAltNameEntry[ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"URL string";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = rgwBadIA5;
    rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[3].pwszRfc822Name = L"RFC822";

    AltNameInfo.cAltEntry = ALT_NAME_ENTRY_CNT;
    AltNameInfo.rgAltEntry = rgAltNameEntry;
    TestBadAltName(&AltNameInfo, 2, 4);
}

static void TestBadAuthorityInfoAccess(
        PCERT_AUTHORITY_INFO_ACCESS pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_AUTHORITY_INFO_ACCESS:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_INFO_ACCESS,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAuthorityInfoAccess()
{
    CERT_AUTHORITY_INFO_ACCESS AuthorityInfoAccess;
    CERT_ACCESS_DESCRIPTION rgAccess[5];
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x80, 0x37, 0x00};

    rgAccess[0].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[0].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[1].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[1].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[1].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[2].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[2].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAccess[2].AccessLocation.pwszRfc822Name = L"issuer@mail.com";

    rgAccess[3].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[3].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[3].AccessLocation.pwszURL = rgwBadIA5;

    rgAccess[4].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[4].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[4].AccessLocation.pwszURL = L"URL to the POLICY";

    AuthorityInfoAccess.cAccDescr = 5;
    AuthorityInfoAccess.rgAccDescr = rgAccess;
    TestBadAuthorityInfoAccess(&AuthorityInfoAccess, 3, 6);
}

static void TestBadAuthorityKeyId2(
        PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_AUTHORITY_KEY_ID2:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_KEY_ID2,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAuthorityKeyId2()
{
    CERT_AUTHORITY_KEY_ID2_INFO KeyId2Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define KEY_ID_ALT_NAME_ENTRY_CNT  2
    CERT_ALT_NAME_ENTRY rgAltNameEntry[KEY_ID_ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = rgwBadIA5;

    memset(&KeyId2Info, 0, sizeof(KeyId2Info));
    KeyId2Info.AuthorityCertIssuer.cAltEntry = KEY_ID_ALT_NAME_ENTRY_CNT;
    KeyId2Info.AuthorityCertIssuer.rgAltEntry = rgAltNameEntry;
    TestBadAuthorityKeyId2(&KeyId2Info, 1, 4);
}


static void TestBadNameConstraints(
        PCERT_NAME_CONSTRAINTS_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex,
        BOOL fExcludedSubtree
        )
{
    DWORD cbEncoded;

    printf("Test encode NAME_CONSTRAINTS:: Bad Entry: %d Value: %d fExcluded: %d\n",
        dwEntryIndex, dwValueIndex, fExcludedSubtree);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME_CONSTRAINTS,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
        if (fExcludedSubtree != IS_CERT_EXCLUDED_SUBTREE(cbEncoded))
            printf("  fExcludedSubtree failed => expected: %d, got: %d\n", 
                fExcludedSubtree, IS_CERT_EXCLUDED_SUBTREE(cbEncoded));
    }
}

static void TestBadNameConstraints()
{
    CERT_NAME_CONSTRAINTS_INFO Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define NAME_CONSTRAINTS_SUBTREE_CNT  2
    CERT_GENERAL_SUBTREE rgSubtree[NAME_CONSTRAINTS_SUBTREE_CNT];

    memset(rgSubtree, 0, sizeof(rgSubtree));
    rgSubtree[0].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgSubtree[0].Base.pwszRfc822Name = L"RFC822";
    rgSubtree[1].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgSubtree[1].Base.pwszURL = rgwBadIA5;

    memset(&Info, 0, sizeof(Info));
    Info.cPermittedSubtree = NAME_CONSTRAINTS_SUBTREE_CNT;
    Info.rgPermittedSubtree = rgSubtree;
    TestBadNameConstraints(&Info, 1, 4, FALSE);

    memset(&Info, 0, sizeof(Info));
    Info.cExcludedSubtree = NAME_CONSTRAINTS_SUBTREE_CNT;
    Info.rgExcludedSubtree = rgSubtree;
    TestBadNameConstraints(&Info, 1, 4, TRUE);
}


static void TestBadIssuingDistPoint(
        PCRL_ISSUING_DIST_POINT pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode ISSUING_DIST_POINT:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_ISSUING_DIST_POINT,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadIssuingDistPoint()
{
    CRL_ISSUING_DIST_POINT Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define IDP_ALT_NAME_ENTRY_CNT  2
    CERT_ALT_NAME_ENTRY rgAltNameEntry[IDP_ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = rgwBadIA5;

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = IDP_ALT_NAME_ENTRY_CNT;
    Info.DistPointName.FullName.rgAltEntry = rgAltNameEntry;
    TestBadIssuingDistPoint(&Info, 1, 4);
}

static void TestCryptExportPublicKeyInfo()
{
    BOOL fResult;
    LPCSTR pszResult;

    HCRYPTPROV hProv = 0;
    PCERT_PUBLIC_KEY_INFO pCorrectInfo = NULL;
    DWORD cbCorrectInfo;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cbTotal;

    printf("\n");
    if (0 == (hProv = GetCryptProv()))
        goto ErrorReturn;

    // Test: cbInfo == correct length
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            NULL,               // pInfo
            &cbCorrectInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo(pInfo == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pCorrectInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(
            cbCorrectInfo)))
        goto ErrorReturn;

    cbTotal = cbCorrectInfo + DELTA_MORE_LENGTH;
    if (NULL == (pInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pCorrectInfo, 0, cbCorrectInfo);
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pCorrectInfo,
            &cbCorrectInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo(cbInfo == correct length)");
        goto ErrorReturn;
    }

    printf("For cbInfo == correct length\n");
    printf("Info Length = %d (0x%x)  Content::\n",
        cbCorrectInfo, cbCorrectInfo);
    PrintBytes("  ", (BYTE *)pCorrectInfo, cbCorrectInfo);

    // Test: cbInfo < correct length
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = cbCorrectInfo - DELTA_LESS_LENGTH;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptExportPublicKeyInfo(cbInfo < correct length) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptExportPublicKey(cbInfo < correct length) LastError == 0\n");
        else
            printf(
                "CryptExportPublicKey(cbInfo < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For cbInfo < correct length, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);
    if (cbInfo != cbCorrectInfo)
        printf("failed => for cbInfo < correct length::  wrong cbInfo\n");

    // Test: cbInfo > correct length
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = cbTotal;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult)
        pszResult = "TRUE";
    else {
        pszResult = "FALSE";
        PrintLastError("CryptExportPublicKeyInfo(cbInfo > correct length)");
    }

    printf("For cbInfo > correct length, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);

    if (cbInfo != cbCorrectInfo)
        printf("failed => for cbInfo > correct length::  wrong cbInfo\n");

    // Test: pInfo != NULL, cbInfo == 0
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = 0;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) LastError == 0\n");
        else
            printf(
                "CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For pInfo != NULL, cbInfo == 0, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    if (pCorrectInfo)
        TestFree(pCorrectInfo);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return;
ErrorReturn:
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_DATA_BLOB structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualCryptDataBlob(
    IN PCRYPT_DATA_BLOB    p1,
    IN PCRYPT_DATA_BLOB    p2)
{
    if (p1->cbData != p2->cbData)
        return FALSE;

    if (p1->cbData == 0)
        return TRUE;

    return (0 == memcmp(p1->pbData, p2->pbData, p1->cbData));
}

//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ATTRIBUTE structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAttribute(
    IN PCRYPT_ATTRIBUTE    patr1,
    IN PCRYPT_ATTRIBUTE    patr2)
{
    BOOL        fRet;
    DWORD       i;
    PCRYPT_ATTR_BLOB  pabl1;
    PCRYPT_ATTR_BLOB  pabl2;

    fRet  = (0 == strcmp( patr1->pszObjId, patr2->pszObjId));
    fRet &= (patr1->cValue == patr2->cValue);
    if (fRet) {
        for (i=patr1->cValue, pabl1=patr1->rgValue, pabl2=patr2->rgValue;
                i>0;
                i--, pabl1++, pabl2++) {
            fRet &= (pabl1->cbData == pabl2->cbData);
            if (fRet) {
                fRet &= (0 == memcmp( pabl1->pbData, 
                                      pabl2->pbData,
                                      pabl1->cbData));
            }
        }
    }

	return fRet;
}

static void TestCmcData()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_DATA_INFO pInfo = NULL;
    CMC_DATA_INFO CmcData;

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb2[] = {0x30, 0x0};                              // Empty SEQUENCE
    CRYPT_ATTR_BLOB rgValue[3] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1,
        sizeof(rgb2), rgb2
    };

    CMC_TAGGED_ATTRIBUTE rgTagAttr[2];
    CMC_TAGGED_CERT_REQUEST rgTagCertReq[3];
    CMC_TAGGED_REQUEST rgTagReq[3];
    CMC_TAGGED_CONTENT_INFO rgTagContentInfo[2];
    CMC_TAGGED_OTHER_MSG rgTagOtherMsg[2];

    DWORD i;

    rgTagAttr[0].dwBodyPartID = 0x7FFFFFFF;
    rgTagAttr[0].Attribute.pszObjId = "1.2.3.4";
    rgTagAttr[0].Attribute.cValue = 2;
    rgTagAttr[0].Attribute.rgValue = rgValue;
    rgTagAttr[1].dwBodyPartID = 0x80000001;
    rgTagAttr[1].Attribute.pszObjId = "1.2.3.5";
    rgTagAttr[1].Attribute.cValue = 0;
    rgTagAttr[1].Attribute.rgValue = NULL;
    CmcData.cTaggedAttribute = 2;
    CmcData.rgTaggedAttribute = rgTagAttr;

    rgTagCertReq[0].dwBodyPartID = 0x12345678;
    rgTagCertReq[0].SignedCertRequest = rgValue[0];
    rgTagCertReq[1].dwBodyPartID = 0x87654321;
    rgTagCertReq[1].SignedCertRequest = rgValue[1];
    rgTagCertReq[2].dwBodyPartID = 0x1;
    rgTagCertReq[2].SignedCertRequest = rgValue[2];
    rgTagReq[0].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[0].pTaggedCertRequest = &rgTagCertReq[0];
    rgTagReq[1].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[1].pTaggedCertRequest = &rgTagCertReq[1];
    rgTagReq[2].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[2].pTaggedCertRequest = &rgTagCertReq[2];
    CmcData.cTaggedRequest = 3;
    CmcData.rgTaggedRequest = rgTagReq;

    rgTagContentInfo[0].dwBodyPartID = 2;
    rgTagContentInfo[0].EncodedContentInfo = rgValue[0];
    rgTagContentInfo[1].dwBodyPartID = 3;
    rgTagContentInfo[1].EncodedContentInfo = rgValue[2];
    CmcData.cTaggedContentInfo = 2;
    CmcData.rgTaggedContentInfo = rgTagContentInfo;

    rgTagOtherMsg[0].dwBodyPartID = 14;
    rgTagOtherMsg[0].pszObjId = "1.2.44.55.66";
    rgTagOtherMsg[0].Value = rgValue[0];
    rgTagOtherMsg[1].dwBodyPartID = 15;
    rgTagOtherMsg[1].pszObjId = "1.2.44.55.66.77";
    rgTagOtherMsg[1].Value = rgValue[1];
    CmcData.cTaggedOtherMsg = 2;
    CmcData.rgTaggedOtherMsg = rgTagOtherMsg;

    printf("Test encode/decode CMC_DATA\n");
    if (!AllocAndEncodeObject(
            CMC_DATA,
            &CmcData,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_DATA_INFO) AllocAndDecodeObject(
        CMC_DATA,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != CmcData.cTaggedAttribute ||
            pInfo->cTaggedRequest != CmcData.cTaggedRequest ||
            pInfo->cTaggedContentInfo != CmcData.cTaggedContentInfo ||
            pInfo->cTaggedOtherMsg != CmcData.cTaggedOtherMsg) {
        printf("CMC_DATA failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

    for (i = 0; i < CmcData.cTaggedAttribute; i++) {
        if (CmcData.rgTaggedAttribute[i].dwBodyPartID !=
                pInfo->rgTaggedAttribute[i].dwBodyPartID ||
                !EqualAttribute(&CmcData.rgTaggedAttribute[i].Attribute,
                    &pInfo->rgTaggedAttribute[i].Attribute)) {
            printf("CMC_DATA failed => invalid decoded tagged attribute\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedRequest; i++) {
        PCMC_TAGGED_CERT_REQUEST pEncodeTagReq;
        PCMC_TAGGED_CERT_REQUEST pDecodeTagReq;
        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pInfo->rgTaggedRequest[i].dwTaggedRequestChoice) {
            printf("CMC_DATA failed => invalid decoded tagged request\n");
            goto CommonReturn;
        }

        pEncodeTagReq = CmcData.rgTaggedRequest[i].pTaggedCertRequest;
        pDecodeTagReq = pInfo->rgTaggedRequest[i].pTaggedCertRequest;
        if (pEncodeTagReq->dwBodyPartID != pDecodeTagReq->dwBodyPartID ||
                !EqualCryptDataBlob(&pEncodeTagReq->SignedCertRequest,
                    &pDecodeTagReq->SignedCertRequest)) {
            printf("CMC_DATA failed => invalid decoded tagged request\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedContentInfo; i++) {
        if (CmcData.rgTaggedContentInfo[i].dwBodyPartID !=
                pInfo->rgTaggedContentInfo[i].dwBodyPartID ||
                !EqualCryptDataBlob(
                    &CmcData.rgTaggedContentInfo[i].EncodedContentInfo,
                    &pInfo->rgTaggedContentInfo[i].EncodedContentInfo)) {
            printf("CMC_DATA failed => invalid decoded tagged ContentInfo\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedOtherMsg; i++) {
        if (CmcData.rgTaggedOtherMsg[i].dwBodyPartID !=
                pInfo->rgTaggedOtherMsg[i].dwBodyPartID ||
                0 != strcmp(CmcData.rgTaggedOtherMsg[i].pszObjId,
                    pInfo->rgTaggedOtherMsg[i].pszObjId) ||
                !EqualCryptDataBlob(&CmcData.rgTaggedOtherMsg[i].Value,
                    &pInfo->rgTaggedOtherMsg[i].Value)) {
            printf("CMC_DATA failed => invalid decoded tagged OtherMsg\n");
            goto CommonReturn;
        }
    }

    TestFree(pbEncoded);
    pbEncoded = NULL;
    TestFree(pInfo);
    pInfo = NULL;

    // Do and encode/decode without any tagged entries
    memset(&CmcData, 0, sizeof(CmcData));

    printf("Test encode/decode CMC_DATA(No Tagged Entries)\n");
    if (!AllocAndEncodeObject(
            CMC_DATA,
            &CmcData,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_DATA_INFO) AllocAndDecodeObject(
        CMC_DATA,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != 0 ||
            pInfo->cTaggedRequest != 0 ||
            pInfo->cTaggedContentInfo != 0 ||
            pInfo->cTaggedOtherMsg != 0) {
        printf("CMC_DATA failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcResponse()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_RESPONSE_INFO pInfo = NULL;
    CMC_RESPONSE_INFO CmcResponse;

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb2[] = {0x30, 0x0};                              // Empty SEQUENCE
    CRYPT_ATTR_BLOB rgValue[3] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1,
        sizeof(rgb2), rgb2
    };

    CMC_TAGGED_ATTRIBUTE rgTagAttr[2];
    CMC_TAGGED_CONTENT_INFO rgTagContentInfo[2];
    CMC_TAGGED_OTHER_MSG rgTagOtherMsg[2];

    DWORD i;

    rgTagAttr[0].dwBodyPartID = 0x7FFFFFFF;
    rgTagAttr[0].Attribute.pszObjId = "1.2.3.4";
    rgTagAttr[0].Attribute.cValue = 2;
    rgTagAttr[0].Attribute.rgValue = rgValue;
    rgTagAttr[1].dwBodyPartID = 0x80000001;
    rgTagAttr[1].Attribute.pszObjId = "1.2.3.5";
    rgTagAttr[1].Attribute.cValue = 0;
    rgTagAttr[1].Attribute.rgValue = NULL;
    CmcResponse.cTaggedAttribute = 2;
    CmcResponse.rgTaggedAttribute = rgTagAttr;

    rgTagContentInfo[0].dwBodyPartID = 2;
    rgTagContentInfo[0].EncodedContentInfo = rgValue[0];
    rgTagContentInfo[1].dwBodyPartID = 3;
    rgTagContentInfo[1].EncodedContentInfo = rgValue[2];
    CmcResponse.cTaggedContentInfo = 2;
    CmcResponse.rgTaggedContentInfo = rgTagContentInfo;

    rgTagOtherMsg[0].dwBodyPartID = 14;
    rgTagOtherMsg[0].pszObjId = "1.2.44.55.66";
    rgTagOtherMsg[0].Value = rgValue[0];
    rgTagOtherMsg[1].dwBodyPartID = 15;
    rgTagOtherMsg[1].pszObjId = "1.2.44.55.66.77";
    rgTagOtherMsg[1].Value = rgValue[1];
    CmcResponse.cTaggedOtherMsg = 2;
    CmcResponse.rgTaggedOtherMsg = rgTagOtherMsg;

    printf("Test encode/decode CMC_RESPONSE\n");
    if (!AllocAndEncodeObject(
            CMC_RESPONSE,
            &CmcResponse,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_RESPONSE_INFO) AllocAndDecodeObject(
        CMC_RESPONSE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != CmcResponse.cTaggedAttribute ||
            pInfo->cTaggedContentInfo != CmcResponse.cTaggedContentInfo ||
            pInfo->cTaggedOtherMsg != CmcResponse.cTaggedOtherMsg) {
        printf("CMC_RESPONSE failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

    for (i = 0; i < CmcResponse.cTaggedAttribute; i++) {
        if (CmcResponse.rgTaggedAttribute[i].dwBodyPartID !=
                pInfo->rgTaggedAttribute[i].dwBodyPartID ||
                !EqualAttribute(&CmcResponse.rgTaggedAttribute[i].Attribute,
                    &pInfo->rgTaggedAttribute[i].Attribute)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged attribute\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcResponse.cTaggedContentInfo; i++) {
        if (CmcResponse.rgTaggedContentInfo[i].dwBodyPartID !=
                pInfo->rgTaggedContentInfo[i].dwBodyPartID ||
                !EqualCryptDataBlob(
                    &CmcResponse.rgTaggedContentInfo[i].EncodedContentInfo,
                    &pInfo->rgTaggedContentInfo[i].EncodedContentInfo)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged ContentInfo\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcResponse.cTaggedOtherMsg; i++) {
        if (CmcResponse.rgTaggedOtherMsg[i].dwBodyPartID !=
                pInfo->rgTaggedOtherMsg[i].dwBodyPartID ||
                0 != strcmp(CmcResponse.rgTaggedOtherMsg[i].pszObjId,
                    pInfo->rgTaggedOtherMsg[i].pszObjId) ||
                !EqualCryptDataBlob(&CmcResponse.rgTaggedOtherMsg[i].Value,
                    &pInfo->rgTaggedOtherMsg[i].Value)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged OtherMsg\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}


static void TestCmcStatus(
    DWORD dwOtherInfoChoice
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_STATUS_INFO pInfo = NULL;
    CMC_STATUS_INFO CmcStatus;

    DWORD rgdwBodyList[3] = {0x80000000, 0x7FFFFFFF, 0x123 };

    BYTE rgbPendToken[] = {1,2,3,4,5};
    CMC_PEND_INFO PendInfo;
    SYSTEMTIME  t;
    DWORD i;

    CmcStatus.dwStatus = 0x12345678;
    CmcStatus.cBodyList = 3;
    CmcStatus.rgdwBodyList = rgdwBodyList;

    switch (dwOtherInfoChoice) {
        case CMC_OTHER_INFO_FAIL_CHOICE:
            CmcStatus.pwszStatusString = L"\0";
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
            CmcStatus.dwFailInfo = 0x11223344;
            break;

        case CMC_OTHER_INFO_PEND_CHOICE:
            CmcStatus.pwszStatusString = L"Status String";
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
            CmcStatus.pPendInfo = &PendInfo;
            PendInfo.PendToken.cbData = sizeof(rgbPendToken);
            PendInfo.PendToken.pbData = rgbPendToken;

            memset(&t, 0, sizeof(t));
            t.wYear   = 2000;
            t.wMonth  = 1;
            t.wDay    = 2;
            t.wHour   = 3;
            t.wMinute = 4;
            t.wSecond = 5;
            t.wMilliseconds = 678;
            if (!SystemTimeToFileTime(&t, &PendInfo.PendTime)) {
                PrintLastError("SystemTimeToFileTime");
                return;
            }
            break;

        case CMC_OTHER_INFO_NO_CHOICE:
        default:
            CmcStatus.pwszStatusString = NULL;
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_NO_CHOICE;
            CmcStatus.cBodyList = 0;
            CmcStatus.rgdwBodyList = NULL;
    }

    printf("Test encode/decode CMC_STATUS(OtherInfoChoice:%d)\n",
        dwOtherInfoChoice);
    if (!AllocAndEncodeObject(
            CMC_STATUS,
            &CmcStatus,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_STATUS_INFO) AllocAndDecodeObject(
        CMC_STATUS,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcStatus.dwStatus != pInfo->dwStatus ||
            CmcStatus.cBodyList != pInfo->cBodyList ||
            CmcStatus.dwOtherInfoChoice != pInfo->dwOtherInfoChoice) {
        printf("CMC_STATUS failed => encode/decode mismatch\n");
        goto CommonReturn;
    }

    switch (CmcStatus.dwOtherInfoChoice) {
        case CMC_OTHER_INFO_FAIL_CHOICE:
            if (pInfo->pwszStatusString != NULL)
                printf("CMC_STATUS failed => expected NULL StatusString\n");

            if (CmcStatus.dwFailInfo != pInfo->dwFailInfo)
                printf("CMC_STATUS failed => bad FailInfo\n");
            break;

        case CMC_OTHER_INFO_PEND_CHOICE:
            {
                PCMC_PEND_INFO pEncodePendInfo;
                PCMC_PEND_INFO pDecodePendInfo;
                
                if (pInfo->pwszStatusString == NULL ||
                        0 != wcscmp(CmcStatus.pwszStatusString,
                                pInfo->pwszStatusString))
                    printf("CMC_STATUS failed => bad StatusString\n");

                pEncodePendInfo = CmcStatus.pPendInfo;
                pDecodePendInfo = pInfo->pPendInfo;
                if (!EqualCryptDataBlob(
                        &pEncodePendInfo->PendToken,
                        &pDecodePendInfo->PendToken))
                    printf("CMC_STATUS failed => bad PendToken\n");

                if (0 != memcmp(&pEncodePendInfo->PendTime,
                        &pDecodePendInfo->PendTime,
                            sizeof(pDecodePendInfo->PendTime)))
                    printf("CMC_STATUS failed => bad PendTime\n");
            }
            break;

        case CMC_OTHER_INFO_NO_CHOICE:
        default:
            if (pInfo->pwszStatusString != NULL)
                printf("CMC_STATUS failed => expected NULL StatusString\n");
    }

    for (i = 0; i < CmcStatus.cBodyList; i++) {
        if (CmcStatus.rgdwBodyList[i] != pInfo->rgdwBodyList[i]) {
            printf("CMC_STATUS failed => invalid decoded tagged BodyList\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcAddExtensions()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_ADD_EXTENSIONS_INFO pInfo = NULL;
    CMC_ADD_EXTENSIONS_INFO CmcAddExtensions;

    DWORD rgdwCertReference[3] = {0x80000000, 0x7FFFFFFF, 0x123 };
    BYTE rgbExt[] = {0x1, 0x2, 0x3};
    CERT_EXTENSION rgExt[2] = {
        "1.2.3.4.5", TRUE, sizeof(rgbExt), rgbExt,
        "1.2.3.6.7", FALSE, sizeof(rgbExt), rgbExt
    };

    DWORD i;

    CmcAddExtensions.dwCmcDataReference = 0x12345678;
    CmcAddExtensions.cCertReference = 3;
    CmcAddExtensions.rgdwCertReference = rgdwCertReference;
    CmcAddExtensions.cExtension = 2;
    CmcAddExtensions.rgExtension = rgExt;

    printf("Test encode/decode CMC_ADD_EXTENSIONS\n");
    if (!AllocAndEncodeObject(
            CMC_ADD_EXTENSIONS,
            &CmcAddExtensions,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_ADD_EXTENSIONS_INFO) AllocAndDecodeObject(
        CMC_ADD_EXTENSIONS,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcAddExtensions.dwCmcDataReference != pInfo->dwCmcDataReference ||
            CmcAddExtensions.cCertReference != pInfo->cCertReference ||
            CmcAddExtensions.cExtension != pInfo->cExtension) {
        printf("CMC_ADD_EXTENSIONS failed => encode/decode mismatch\n");
        goto CommonReturn;
    }


    for (i = 0; i < CmcAddExtensions.cCertReference; i++) {
        if (CmcAddExtensions.rgdwCertReference[i] !=
                pInfo->rgdwCertReference[i]) {
            printf("CMC_ADD_EXTENSIONS failed => invalid decoded CertReference\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcAddExtensions.cExtension; i++) {
        PCERT_EXTENSION pEncodeExt = &CmcAddExtensions.rgExtension[i];
        PCERT_EXTENSION pDecodeExt = &pInfo->rgExtension[i];
        if (0 != strcmp(pEncodeExt->pszObjId, pDecodeExt->pszObjId) ||
                pEncodeExt->fCritical != pDecodeExt->fCritical ||
                !EqualCryptDataBlob(&pEncodeExt->Value, &pEncodeExt->Value)) {
            printf("CMC_ADD_EXTENSIONS failed => invalid decoded Extensions\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcAddAttributes()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = NULL;
    CMC_ADD_ATTRIBUTES_INFO CmcAddAttributes;

    DWORD rgdwCertReference[3] = {0x80000000, 0x7FFFFFFF, 0x123 };
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    CRYPT_ATTRIBUTE rgAttr[3] = {
        "1.2.3.6.8", 0, NULL,
        "1.2.3.6.7", 1, rgValue,
        "1.2.3.4.5", 2, rgValue,
    };

    DWORD i;

    CmcAddAttributes.dwCmcDataReference = 0x12345678;
    CmcAddAttributes.cCertReference = 3;
    CmcAddAttributes.rgdwCertReference = rgdwCertReference;
    CmcAddAttributes.cAttribute = 3;
    CmcAddAttributes.rgAttribute = rgAttr;

    printf("Test encode/decode CMC_ADD_ATTRIBUTES\n");
    if (!AllocAndEncodeObject(
            CMC_ADD_ATTRIBUTES,
            &CmcAddAttributes,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_ADD_ATTRIBUTES_INFO) AllocAndDecodeObject(
        CMC_ADD_ATTRIBUTES,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcAddAttributes.dwCmcDataReference != pInfo->dwCmcDataReference ||
            CmcAddAttributes.cCertReference != pInfo->cCertReference ||
            CmcAddAttributes.cAttribute != pInfo->cAttribute) {
        printf("CMC_ADD_ATTRIBUTES failed => encode/decode mismatch\n");
        goto CommonReturn;
    }


    for (i = 0; i < CmcAddAttributes.cCertReference; i++) {
        if (CmcAddAttributes.rgdwCertReference[i] !=
                pInfo->rgdwCertReference[i]) {
            printf("CMC_ADD_ATTRIBUTES failed => invalid decoded CertReference\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcAddAttributes.cAttribute; i++) {
        PCRYPT_ATTRIBUTE pEncodeAttr = &CmcAddAttributes.rgAttribute[i];
        PCRYPT_ATTRIBUTE pDecodeAttr = &pInfo->rgAttribute[i];

        if (!EqualAttribute(pEncodeAttr, pDecodeAttr))
            printf("CMC_ADD_ATTRIBUTES failed => invalid decoded Attributes\n");
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCertTemplate()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_TEMPLATE_EXT pInfo = NULL;

    CERT_TEMPLATE_EXT CertTemplate;

    CertTemplate.pszObjId = "1.2.3.4.5.6.7.8.9";
    CertTemplate.dwMajorVersion = 0x11223344;
    CertTemplate.fMinorVersion = FALSE;


    printf("Test encode/decode X509_CERTIFICATE_TEMPLATE\n");
    if (!AllocAndEncodeObject(
            X509_CERTIFICATE_TEMPLATE,
            &CertTemplate,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCERT_TEMPLATE_EXT) AllocAndDecodeObject(
        X509_CERTIFICATE_TEMPLATE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, CertTemplate.pszObjId) ||
            pInfo->dwMajorVersion != CertTemplate.dwMajorVersion ||
            pInfo->fMinorVersion != CertTemplate.fMinorVersion)
        printf("X509_CERTIFICATE_TEMPLATE failed => decode != encode input\n");

    TestFree(pbEncoded);
    pbEncoded = NULL;

    TestFree(pInfo);
    pInfo = NULL;

    CertTemplate.fMinorVersion = TRUE;
    CertTemplate.dwMinorVersion = 12345678;

    if (!AllocAndEncodeObject(
            szOID_CERTIFICATE_TEMPLATE,
            &CertTemplate,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCERT_TEMPLATE_EXT) AllocAndDecodeObject(
        szOID_CERTIFICATE_TEMPLATE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, CertTemplate.pszObjId) ||
            pInfo->dwMajorVersion != CertTemplate.dwMajorVersion ||
            pInfo->fMinorVersion != CertTemplate.fMinorVersion ||
            pInfo->dwMinorVersion != CertTemplate.dwMinorVersion)
        printf("szOID_CERTIFICATE_TEMPLATE failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPCSTR pszResult;

    CERT_NAME_INFO Name;
    CERT_RDN Rdn[2];
    CERT_RDN_ATTR RdnAttr[2];

#define ATTR_VALUE0 "Name 0"
    RdnAttr[0].pszObjId = "1.2.3.4";
    RdnAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RdnAttr[0].Value.pbData = (BYTE *) ATTR_VALUE0;
    RdnAttr[0].Value.cbData = strlen(ATTR_VALUE0);
#define ATTR_VALUE1 "Name 11111"
    RdnAttr[1].pszObjId = "1.2.3.4.1";
    RdnAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RdnAttr[1].Value.pbData = (BYTE *) ATTR_VALUE1;
    RdnAttr[1].Value.cbData = strlen(ATTR_VALUE1);

    Rdn[0].cRDNAttr = 2;
    Rdn[0].rgRDNAttr = RdnAttr;
    Rdn[1].cRDNAttr = 1;
    Rdn[1].rgRDNAttr = &RdnAttr[1];

    Name.cRDN = 2;
    Name.rgRDN = Rdn;


    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbCorrectEncoded = NULL;
    DWORD cbCorrectEncoded;
    DWORD cbTotal;

    PCERT_NAME_INFO pDecodedInfo = NULL;
    DWORD cbDecodedInfo;
    PCERT_NAME_INFO pCorrectDecodedInfo = NULL;
    DWORD cbCorrectDecodedInfo;

    printf("command line: %s\n", GetCommandLine());

    TestExtensions();
    TestX942OtherInfo();
    TestPKCSAttribute();
    TestPKCSAttributes();
    TestContentInfoSequenceOfAny();
    TestSequenceOfAny();
    TestInteger();
    TestMultiByteInteger();
    TestBits();
    TestBitsWithoutTrailingZeroes();
    TestOID();
    TestUnicodeAnyString();
    TestUniversalString();
    TestChoiceOfTime();
    TestUtcTime();
    TestBadAltName();
    TestBadAuthorityInfoAccess();
    TestBadAuthorityKeyId2();
    TestBadNameConstraints();
    TestBadIssuingDistPoint();
    TestCmcData();
    TestCmcResponse();
    TestCmcStatus(CMC_OTHER_INFO_NO_CHOICE);
    TestCmcStatus(CMC_OTHER_INFO_FAIL_CHOICE);
    TestCmcStatus(CMC_OTHER_INFO_PEND_CHOICE);
    TestCmcAddExtensions();
    TestCmcAddAttributes();
    TestCertTemplate();

    TestCryptExportPublicKeyInfo();

    // Test: cbEncoded == correct length
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbCorrectEncoded
            )) {
        PrintLastError("CryptEncodeObject(pbEncoded == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pbCorrectEncoded = (BYTE *) TestAlloc(cbCorrectEncoded)))
        goto ErrorReturn;

    cbTotal = cbCorrectEncoded + DELTA_MORE_LENGTH;
    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pbCorrectEncoded, 0, cbCorrectEncoded);
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbCorrectEncoded,
            &cbCorrectEncoded
            )) {
        PrintLastError("CryptEncodeObject(cbEncoded == correct length)");
        goto ErrorReturn;
    }

    printf("For cbEncoded == correct length\n");
    printf("Encoded Length = %d (0x%x)  Content::\n",
        cbCorrectEncoded, cbCorrectEncoded);
    PrintBytes("  ", pbCorrectEncoded, cbCorrectEncoded);

    // Test: cbEncoded < correct length
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = cbCorrectEncoded - DELTA_LESS_LENGTH;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptEncodeObject(cbEncoded < correct length) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptEncodeObject(cbEncoded < correct length) LastError == 0\n");
        else
            printf(
                "CryptEncodeObject(cbEncoded < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For cbEncoded < correct length, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);
    if (cbEncoded != cbCorrectEncoded)
        printf("failed => for cbEncoded < correct length::  wrong cbEncoded\n");

    // Test: cbEncoded > correct length
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = cbTotal;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult)
        pszResult = "TRUE";
    else {
        pszResult = "FALSE";
        PrintLastError("CryptEncodeObject(cbEncoded > correct length)");
    }

    printf("For cbEncoded > correct length, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);

    if (cbEncoded != cbCorrectEncoded)
        printf("failed => for cbEncoded > correct length::  wrong cbEncoded\n");
    else if (0 != memcmp(pbEncoded, pbCorrectEncoded, cbCorrectEncoded))
        printf("failed => for cbEncoded > correct length:: bad pbEncoded content\n");

    // Test: pbEncoded != NULL, cbEncoded == 0
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = 0;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) LastError == 0\n");
        else
            printf(
                "CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For pbEncoded != NULL, cbEncoded == 0, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);

    printf("\n");
    // Test: cbDecodedInfo == correct length
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                  // dwFlags
            NULL,               // pvStructInfo
            &cbCorrectDecodedInfo
            )) {
        PrintLastError("CryptDecodeObject(pvStructInfo == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pCorrectDecodedInfo = (PCERT_NAME_INFO) TestAlloc(
            cbCorrectDecodedInfo)))
        goto ErrorReturn;

    cbTotal = cbCorrectDecodedInfo + DELTA_MORE_LENGTH;
    if (NULL == (pDecodedInfo = (PCERT_NAME_INFO) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pCorrectDecodedInfo, 0, cbCorrectDecodedInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pCorrectDecodedInfo,
            &cbCorrectDecodedInfo
            )) {
        PrintLastError("CryptDecodeObject(cbStructInfo == correct length)");
        goto ErrorReturn;
    }

    // Test: cbDecodedInfo > correct length
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbTotal;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (!fResult)
        PrintLastError("CryptDecodeObject(cbStructInfo > correct length)");

    if (cbDecodedInfo != cbCorrectDecodedInfo)
        printf("failed => for cbStructInfo > correct length::  wrong cbStructInfo\n");

    // Test: cbDecodedInfo < correct length
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbCorrectDecodedInfo - DELTA_LESS_LENGTH;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(cbStructInfo < correct length) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(cbStructInfo < correct length) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(cbStructInfo < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }
    if (cbDecodedInfo != cbCorrectDecodedInfo)
        printf("failed => for cbStructInfo < correct length::  wrong cbStructInfo\n");


    // Test: pvStructInfo != NULL, cbStructInfo == 0
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    // Test decoding missing the last bytes
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbCorrectDecodedInfo;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded -30,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(incomplete cbEncoded) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(incomplete cbEncoded) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(incomplete cbEncoded) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }



ErrorReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pbCorrectEncoded)
        TestFree(pbCorrectEncoded);
    if (pDecodedInfo)
        TestFree(pDecodedInfo);
    if (pCorrectDecodedInfo)
        TestFree(pCorrectDecodedInfo);

    printf("Done.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\teku\teku.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       teku.cpp
//
//  Contents:   Cert Enhanced Key Usage tests
//
//  History:    27-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define szOID_STUFF1 "2.2.2.4"
#define szOID_STUFF2 "2.2.2.5"
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: teku [options]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -f<filename>          - Cert file (.CER)\n");
    printf("  -s<store name>        - Place cert in store\n");
    printf("\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndDisplayEKU
//
//  Synopsis:   gets and displays enhanced key usage
//
//----------------------------------------------------------------------------
static void GetAndDisplayEKU (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    DWORD              cbUsage;
    DWORD              cCount;
    PCERT_ENHKEY_USAGE pUsage;

    //
    // Get the usage
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                NULL,
                &cbUsage
                ) == FALSE )
    {
        if ( GetLastError() == CRYPT_E_NOT_FOUND )
        {
            printf("No enhanced key usage present\n\n");
        }
        else
        {
            printf(
               "Error: Could not get enhanced key usage %x\n\n",
               GetLastError()
               );
        }

        return;
    }

    pUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbUsage];
    if ( pUsage != NULL )
    {
        if ( CertGetEnhancedKeyUsage(
                    pCertContext,
                    dwFlags,
                    pUsage,
                    &cbUsage
                    ) == FALSE )
        {
            if ( GetLastError() == CRYPT_E_NOT_FOUND )
            {
                printf("No enhanced key usage present\n\n");
            }
            else
            {
                printf(
                   "Error: Could not get enhanced key usage %x\n\n",
                   GetLastError()
                   );
            }

            delete pUsage;
            return;
        }
    }
    else
    {
        printf("Out of Memory!\n\n");
        return;
    }

    //
    // Display the usage
    //

    printf(
       "%d enhanced key usage OID(s) present:\n",
       pUsage->cUsageIdentifier
       );

    for ( cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++ )
    {
        printf("\t%s\n", pUsage->rgpszUsageIdentifier[cCount]);
    }
    printf("\n");

    //
    // Cleanup
    //

    delete pUsage;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndDisplayAllEKUForms
//
//  Synopsis:   displays all EKU forms
//
//----------------------------------------------------------------------------
static void GetAndDisplayAllEKUForms (PCCERT_CONTEXT pCertContext)
{
    //
    // Get and display EKU extension
    //

    printf("Certificate EKU extension\n\n");
    GetAndDisplayEKU(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG);

    //
    // Get and display EKU property
    //

    printf("Certificate EKU property\n\n");
    GetAndDisplayEKU(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG);

    //
    // Get and display both EKU extension and property
    //

    printf("Certificate EKU extension and property\n\n");
    GetAndDisplayEKU(
          pCertContext,
          CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG |
          CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG
          );
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
    LPSTR          pszCertFile = NULL;
    DWORD          cbEncoded;
    LPBYTE         pbEncoded;
    PCCERT_CONTEXT pCertContext;
    PCCERT_CONTEXT pContextToUse;
    LPSTR          pszStore = NULL;
    HCERTSTORE     hStore;

    while ( --argc > 0 )
    {
        if ( **++argv == '-' )
        {
            switch( argv[0][1] )
            {
            case 'f':
            case 'F':
                pszCertFile = argv[0]+2;
                if ( *pszCertFile == '\0' )
                {
                    printf("Need to specify filename\n");
                    Usage();
                    return( -1 );
                }
                break;
            case 's':
            case 'S':
                pszStore = argv[0]+2;
                if ( *pszStore == '\0' )
                {
                    printf("Need to specify store name\n");
                    Usage();
                    return( -1 );
                }
                break;
            default:
                Usage();
                return -1;
            }
        }
    }

    printf("command line: %s\n", GetCommandLineA());

    //
    // For now we must have a certificate file to process
    //

    if ( pszCertFile == NULL )
    {
        printf("Must specify a certificate file to process\n");
        Usage();
        return( -1 );
    }

    //
    // Use our input to get a certificate context to play with
    //

    if ( ReadDERFromFile(pszCertFile, &pbEncoded, &cbEncoded) == FALSE )
    {
        printf("Error reading CERT!\n");
        return(-1);
    }

    pCertContext = CertCreateCertificateContext(
                             X509_ASN_ENCODING,
                             pbEncoded,
                             cbEncoded
                             );

    TestFree(pbEncoded);

    if ( pCertContext == NULL )
    {
        printf( "Error create certificate context\n" );
        return( -1 );
    }

    //
    // If store action is requested ...
    //

    if ( pszStore != NULL )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_A,
                     0,
                     NULL,
                     CERT_SYSTEM_STORE_CURRENT_USER,
                     pszStore
                     );

        if ( hStore == NULL )
        {
            CertFreeCertificateContext( pCertContext );
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        if ( CertEnumCertificatesInStore( hStore, NULL ) != NULL )
        {
            CertFreeCertificateContext( pCertContext );
            CertCloseStore( hStore, 0 );
            printf( "Must be a new or empty store\n" );
            return( -1 );
        }

        if ( CertAddCertificateContextToStore(
                 hStore,
                 pCertContext,
                 CERT_STORE_ADD_NEW,
                 NULL
                 ) == FALSE )
        {
            CertFreeCertificateContext( pCertContext );
            CertCloseStore( hStore, 0 );
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        CertFreeCertificateContext( pCertContext );

        pCertContext = CertEnumCertificatesInStore( hStore, NULL );
        if ( pCertContext == NULL )
        {
            CertCloseStore( hStore, 0 );
            printf( "Error finding certificate from store\n" );
            return( -1 );
        }

        printf( "hStore = %p\n", hStore );
        printf( "pCertContext->hCertStore = %p\n", pCertContext->hCertStore );

        pContextToUse = CertDuplicateCertificateContext( pCertContext );

        printf( "pContextToUse->hCertStore = %p\n", pContextToUse->hCertStore );

        CertCloseStore( hStore, 0 );

        printf( "pContextToUse->hCertStore = %p\n", pContextToUse->hCertStore );
    }
    else
    {
        pContextToUse = CertDuplicateCertificateContext( pCertContext );
        CertFreeCertificateContext( pCertContext );
    }

    //
    // Get and display all EKU forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Add a identifier property
    //

    printf("Adding %s enhanced key usage OID to the cert\n", szOID_STUFF1);

    if ( CertAddEnhancedKeyUsageIdentifier(
                pContextToUse,
                szOID_STUFF1
                ) == FALSE )
    {
        printf("Error adding key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Add another identifier property
    //

    printf("Adding %s enhanced key usage OID to the cert\n", szOID_STUFF2);

    if ( CertAddEnhancedKeyUsageIdentifier(
                pContextToUse,
                szOID_STUFF2
                ) == FALSE )
    {
        printf("Error adding key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    if ( pszStore != NULL )
    {
        CertFreeCertificateContext( pContextToUse );

        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_A,
                     0,
                     NULL,
                     CERT_SYSTEM_STORE_CURRENT_USER,
                     pszStore
                     );

        if ( hStore == NULL )
        {
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        pContextToUse = CertEnumCertificatesInStore( hStore, NULL );
        if ( pContextToUse != NULL )
        {
            pContextToUse = CertDuplicateCertificateContext( pContextToUse );
        }
        else
        {
            printf( "Error enumerating certificate in store\n" );
            CertCloseStore( hStore, 0 );
            return( -1 );
        }

        CertCloseStore( hStore, 0 );

        printf( "Check EKUs after playing with store\n" );
        GetAndDisplayAllEKUForms(pContextToUse);
    }


    //
    // Remove an OID
    //

    printf("Removing %s enhanced key usage OID from the cert\n", szOID_STUFF2);

    if ( CertRemoveEnhancedKeyUsageIdentifier(
                   pContextToUse,
                   szOID_STUFF2
                   ) == FALSE )
    {
        printf("Error removing key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Remove an OID
    //

    printf("Removing %s enhanced key usage OID from the cert\n", szOID_STUFF1);

    if ( CertRemoveEnhancedKeyUsageIdentifier(
                   pContextToUse,
                   szOID_STUFF1
                   ) == FALSE )
    {
        printf("Error removing key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Free the certificate context
    //

    if ( pszStore != NULL )
    {
        CertDeleteCertificateFromStore( pContextToUse );
    }

    CertFreeCertificateContext(pContextToUse);

    printf("Test succeeded\n");

    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tfindclt\tfindclt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tfindclt.cpp
//
//  Contents:   FindCertsByIssuer, CertFindChainInStore APIs test
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    21-May-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              01-Mar-98   philh   Added to call CertFindChainInStore
//
//--------------------------------------------------------------------------

#define CERT_CHAIN_FIND_BY_ISSUER_PARA_HAS_EXTRA_FIELDS 1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     AT_SIGNATURE,
    "Xchg",     AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))

static DWORD dwDisplayFlags = 0;


static void Usage(void)
{
    printf("Usage: tfindclt [options] [<Issuer CertFilename> [<KeyType>]]\n");
    printf("Options are:\n");
    printf("  -CompareKey\n");
    printf("  -ComplexChain\n");
    printf("  -CacheOnly\n");
    printf("  -NoKey\n");
    printf("\n");
    printf("  -c<SystemStore>       - Chain System Store\n");
    printf("  -C<FileSystemStore>   - Chain File System Store\n");
    printf("  -u<OID String>        - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -S[<FileName>]        - Use issuer cert's subject name (default)\n");
    printf("  -I[<FileName>]        - Use issuer cert's issuer name\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");

    int i;
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}

//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",
    "CERT_TRUST_IS_NOT_TIME_NESTED",
    "CERT_TRUST_IS_REVOKED",
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",
    "CERT_TRUST_IS_UNTRUSTED_ROOT",
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "CERT_TRUST_IS_PARTIAL_CHAIN",
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status"
};

LPSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "Unknown Info Status",              // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "Unknown Info Status",              // 0x00000100
    "Unknown Info Status",              // 0x00000200
    "Unknown Info Status",              // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN const CERT_TRUST_STATUS *pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    printf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                printf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                printf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    printf("\n");
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement
    )
{
    DisplayCert( pElement->pCertContext, dwDisplayFlags );
    printf("\n");
    DisplayTrustStatus( &pElement->TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain
    )
{
    DWORD cElement;

    DisplayTrustStatus( &pChain->TrustStatus );
    printf("Chain Element Count = %d\n", pChain->cElement);
    for ( cElement = 0; cElement < pChain->cElement; cElement++ )
    {
        printf("Chain Element [%d]\n", cElement);
        DisplayChainElement( pChain->rgpElement[ cElement ]);
    }
}

void DisplayComplexChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD cChain;

    if (NULL == pChainContext)
        return;

    DisplayTrustStatus(&pChainContext->TrustStatus );
    printf("\n");
    printf("Simple Chain Count = %d\n\n", pChainContext->cChain );

    for ( cChain = 0; cChain < pChainContext->cChain; cChain++ )
    {
        printf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( pChainContext->rgpChain[ cChain ]);
    }
}

#define FIND_BY_ISSUER_ARG    0x1539beef
BOOL WINAPI FindByIssuerCallback(
    IN PCCERT_CONTEXT pCert,
    IN void *pvFindArg
    )
{
    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        printf(">>>>>  FindByIssuerCallback  <<<<<\n");
    if (pvFindArg != (void *) FIND_BY_ISSUER_ARG)
        printf("failed => wrong pvFindArg\n");

    return TRUE;
}

static BOOL CreateChainByIssuer(
    IN HCERTSTORE hChainStore,
    IN DWORD dwFindFlags,
    IN LPCSTR pszUsageIdentifier,
    IN DWORD dwKeySpec,
    IN DWORD cIssuer,
    IN PCERT_NAME_BLOB rgIssuer
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwChainIndex = 0;
    DWORD dwIssuerChainIndex = 0;
    DWORD dwIssuerElementIndex = 0;

    CERT_CHAIN_FIND_BY_ISSUER_PARA FindPara;
    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.pszUsageIdentifier = pszUsageIdentifier;
    FindPara.dwKeySpec = dwKeySpec;
    FindPara.cIssuer = cIssuer;
    FindPara.rgIssuer = rgIssuer;
    FindPara.pfnFindCallback = FindByIssuerCallback;
    FindPara.pvFindArg = (void *) FIND_BY_ISSUER_ARG;
    FindPara.pdwIssuerChainIndex = &dwIssuerChainIndex;
    FindPara.pdwIssuerElementIndex = &dwIssuerElementIndex;

    while (pChainContext = CertFindChainInStore(
            hChainStore,
            dwCertEncodingType,
            dwFindFlags,
            CERT_CHAIN_FIND_BY_ISSUER,
            &FindPara,
            pChainContext
            )) {
        printf("\n");
        printf("=======================   CHAIN[%d,%d] %d   =======================\n",
            dwIssuerChainIndex, dwIssuerElementIndex, dwChainIndex);
        dwChainIndex++;

        DisplayComplexChain(pChainContext);
        dwIssuerChainIndex = 0;
        dwIssuerElementIndex = 0;
    }

    if (0 == dwChainIndex)
        printf(">>>>  No Chains  <<<<\n");

    return TRUE;
}


static BOOL AllocAndGetEncodedIssuer(
    LPSTR pszCertFilename,
    BOOL fUseIssuerName,
    PCERT_NAME_BLOB pIssuer
    )
{
    BOOL fResult;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbEncodedIssuer;
    DWORD cbEncodedIssuer;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("AllocAndGetEncodedIssuer::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("AllocAndGetEncodedIssuer::CertCreateCertificateContext");
        goto ErrorReturn;
    }
    if (fUseIssuerName) {
        cbEncodedIssuer = pCert->pCertInfo->Issuer.cbData;
        pbEncodedIssuer = pCert->pCertInfo->Issuer.pbData;
    } else {
        cbEncodedIssuer = pCert->pCertInfo->Subject.cbData;
        pbEncodedIssuer = pCert->pCertInfo->Subject.pbData;
    }
    pIssuer->pbData = (BYTE *) TestAlloc(cbEncodedIssuer);
    if (pIssuer->pbData == NULL) goto ErrorReturn;
    memcpy(pIssuer->pbData, pbEncodedIssuer, cbEncodedIssuer);
    pIssuer->cbData = cbEncodedIssuer;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    if (pCert)
        CertFreeCertificateContext(pCert);
    return fResult;
}

int _cdecl main(int argc, char * argv[])
{
    HRESULT hr;
    int ReturnStatus;
    BOOL fUseIssuerName = FALSE;
    LPSTR pszCertFilename = NULL;
    LPSTR pszKeyType = NULL;
    DWORD dwKeySpec;

#define MAX_ISSUER_CNT      32
    DWORD cIssuer = 0;
    CERT_NAME_BLOB rgIssuer[MAX_ISSUER_CNT];

    PCERT_CHAIN pCertChains = NULL;
    DWORD cbCertChains;
    DWORD cCertChains;
    DWORD i,j;

    HCERTSTORE hChainStore = NULL;
    LPSTR pszUsageIdentifier = NULL;
    DWORD dwFindFlags = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "CompareKey")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "ComplexChain")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "CacheOnly")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoKey")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG;
            } else {
                switch(argv[0][1])
                {
                case 'c':
                case 'C':
                    if (hChainStore) {
                        printf("Only one chain store allowed\n");
                        goto BadUsage;
                    }
                    if (NULL == (hChainStore =
                            OpenSystemStoreOrFile(
                                argv[0][1] == 'c',  // fSystemStore
                                argv[0]+2,
                                0                   // dwFlags
                                )))
                        goto BadUsage;
                    break;
                case 'S':
                case 'I':
                    if ('S' == argv[0][1])
                        fUseIssuerName = FALSE;
                    else
                        fUseIssuerName = TRUE;
                    if (argv[0][2]) {
                        if (MAX_ISSUER_CNT <= cIssuer) {
                            printf("Exceeded Maximum Issuer Count %d\n",
                                MAX_ISSUER_CNT);
                            goto BadUsage;
                        } else  {
                            if (!AllocAndGetEncodedIssuer(argv[0]+2,
                                    fUseIssuerName, &rgIssuer[cIssuer]))
                                goto ErrorReturn;
                            cIssuer++;
                        }
                    }
                    break;
                case 'u':
                    pszUsageIdentifier = argv[0]+2;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszCertFilename == NULL)
                pszCertFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    printf("command line: %s\n", GetCommandLine());


    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszCertFilename == NULL || *pszCertFilename == '\0') {
        if (0 == cIssuer) {
            rgIssuer[0].cbData = 0;
            rgIssuer[0].pbData = NULL;
            printf("Match any Issuer\n");
        }
    } else if (MAX_ISSUER_CNT <= cIssuer) {
        printf("Exceeded Maximum Issuer Count %d\n", MAX_ISSUER_CNT);
        goto BadUsage;
    } else  {
        if (!AllocAndGetEncodedIssuer(pszCertFilename, fUseIssuerName,
                &rgIssuer[cIssuer]))
            goto ErrorReturn;
        cIssuer++;
    }

    if (NULL == hChainStore && 1 < cIssuer) {
        printf("Only one issuer for FindCertsByIssuer\n");
        goto BadUsage;
    }

    dwKeySpec = 0;
    if (pszKeyType) {
        DWORD KeyIdx;
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0) {
                dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
                break;
            }
        }
        if (dwKeySpec == 0) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else
        printf("Match any key type\n");

    if (hChainStore) {
        if (CreateChainByIssuer(
                hChainStore,
                dwFindFlags,
                pszUsageIdentifier,
                dwKeySpec,
                cIssuer,
                rgIssuer
                ))
            goto SuccessReturn;
        else
            goto ErrorReturn;
    }


    cbCertChains = 0;
    hr = FindCertsByIssuer(
        NULL,               // pCertChains
        &cbCertChains,
        &cCertChains,
        rgIssuer[0].pbData,
        rgIssuer[0].cbData,
        NULL,               // pwszPurpose   "ClientAuth" or "CodeSigning"
        dwKeySpec
        );
    if (cbCertChains == 0) {
        if (hr == CRYPT_E_NOT_FOUND)
            printf("NO Certificate Chains\n");
        else {
            SetLastError((DWORD) hr);
            PrintLastError("FindCertsByIssuer");
        }
        goto ErrorReturn;
    }

    if (NULL == (pCertChains = (PCERT_CHAIN) TestAlloc(cbCertChains)))
        goto ErrorReturn;
    if (FAILED(hr = FindCertsByIssuer(
            pCertChains,
            &cbCertChains,
            &cCertChains,
            rgIssuer[0].pbData,
            rgIssuer[0].cbData,
            NULL,               // pwszPurpose   "ClientAuth" or "CodeSigning"
            dwKeySpec
            ))) {
        SetLastError((DWORD) hr);
        PrintLastError("FindCertsByIssuer");
        goto ErrorReturn;
    }

    for (i = 0; i < cCertChains; i++) {
        PCRYPT_KEY_PROV_INFO pKeyInfo = &pCertChains[i].keyLocatorInfo;
        printf("\n");
        printf("#####  Chain %d  #####\n", i);
        printf("Key Provider:: %d", pKeyInfo->dwProvType);
        if (pKeyInfo->pwszProvName)
            printf(" %S", pKeyInfo->pwszProvName);
        if (pKeyInfo->dwFlags)
            printf(" Flags: 0x%x", pKeyInfo->dwFlags);
        if (pKeyInfo->pwszContainerName)
            printf(" Container: %S", pKeyInfo->pwszContainerName);
        if (pKeyInfo->cProvParam)
            printf(" Params: %d", pKeyInfo->cProvParam);
        if (pKeyInfo->dwKeySpec)
            printf(" KeySpec: %d", pKeyInfo->dwKeySpec);
        printf("\n");
        for (j = 0; j < pCertChains[i].cCerts; j++) {
            PCCERT_CONTEXT pCert;
            if (pCert = CertCreateCertificateContext(
                    dwCertEncodingType,
                    pCertChains[i].certs[j].pbData,
                    pCertChains[i].certs[j].cbData
                    )) {
                printf("=====  %d  =====\n", j);
                DisplayCert(pCert, dwDisplayFlags);
                CertFreeCertificateContext(pCert);
            } else {
                printf("Unable to decode cert %d\n", j);
                PrintLastError("CertCreateCertificateContext");
            }
        }
    }

SuccessReturn:
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    while (cIssuer--)
        TestFree(rgIssuer[cIssuer].pbData);
    if (pCertChains)
        TestFree(pCertChains);
    if (hChainStore) {
        if (!CertCloseStore(hChainStore, 0))
            PrintLastError("CertCloseStore(ChainStore)");
    }
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tfindcer\tfindcer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tfindcer.cpp
//
//  Contents:   Cert Store Find API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    11-Apr-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "cryptuiapi.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}


static void Usage(void)
{
    printf("Usage: tfindcer [options] <StoreName> [<Name String>]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -D<digest>            - Find cert matching Digest (Hash)\n");
    printf("  -S                    - Find cert matching Subject\n");
    printf("  -I                    - Find cert matching Issuer\n");
    printf("  -U<ObjectID>          - Find cert matching Usage Identifiers\n");
    printf("  -F<number>            - Find Flags\n");
    printf("  -f<filename>          - Get matching Name from cert file\n");
    printf("  -o<ObjectID>          - Object Identifier (1.2.3.4)\n");
    printf("  -t<ValueType>         - Attribute value type (printableString - %d)\n", CERT_RDN_PRINTABLE_STRING);
    printf("  -a[<attributeString>] - Attribute value match\n");
    printf("  -A[<attributeString>] - Attribute value match (test unicode)\n");
    printf("  -C                    - Case Insensitive Attribute value match\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -p<filename>          - Put encoded cert to file\n");
    printf("  -d                    - Delete cert\n");
    printf("  -7[<SaveFilename>]    - PKCS# 7 formated save for delete\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -u                    - UI Dialog Viewer//Selection\n");
    printf("  -c                    - Verify checks enabled\n");
    printf("  -q                    - Quiet. Don't display certs\n");
    printf("  -xDelete              - Delete CrossCertDistPoint property\n");
    printf("  -x<number>            - CrossCertDistPoint sync delta seconds\n");
    printf("  -x<Url>               - CrossCertDistPoint Url\n");
    printf("  -X<Url>               - CrossCertDistPoint Alternate Url\n");
    printf("\n");
    printf("Default: find all certs in the store\n");
}

static BOOL AllocAndGetEncodedName(
    LPSTR pszCertFilename,
    DWORD dwFindInfo,
    BYTE **ppbEncodedName,
    DWORD *pcbEncodedName)
{
    BOOL fResult;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbAllocEncodedName = NULL;
    BYTE *pbEncodedName;
    DWORD cbEncodedName;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("AllocAndGetEncodedName::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("AllocAndGetEncodedName::CertCreateCertificateContext");
        goto ErrorReturn;
    }
    if (dwFindInfo == CERT_INFO_SUBJECT_FLAG) {
        cbEncodedName = pCert->pCertInfo->Subject.cbData;
        pbEncodedName = pCert->pCertInfo->Subject.pbData;
    } else {
        cbEncodedName = pCert->pCertInfo->Issuer.cbData;
        pbEncodedName = pCert->pCertInfo->Issuer.pbData;
    }
    pbAllocEncodedName = (BYTE *) TestAlloc(cbEncodedName);
    if (pbAllocEncodedName == NULL) goto ErrorReturn;
    memcpy(pbAllocEncodedName, pbEncodedName, cbEncodedName);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbAllocEncodedName) {
        TestFree(pbAllocEncodedName);
        pbAllocEncodedName = NULL;
    }
    cbEncodedName = 0;
    fResult = FALSE;
CommonReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    if (pCert)
        CertFreeCertificateContext(pCert);
    *ppbEncodedName = pbAllocEncodedName;
    *pcbEncodedName = cbEncodedName;
    return fResult;
}

static void DisplayFindAttr(DWORD cRDNAttr, CERT_RDN_ATTR rgRDNAttr[])
{
    DWORD i;

    for (i = 0; i < cRDNAttr; i++) {
        LPSTR pszObjId = rgRDNAttr[i].pszObjId;
        LPSTR pszValue = (LPSTR) rgRDNAttr[i].Value.pbData;
        printf("  [%d] ", i);
        if (pszObjId)
            printf("%s ", pszObjId);
        if (rgRDNAttr[i].dwValueType)
            printf("ValueType: %d ", rgRDNAttr[i].dwValueType);
        if (pszValue == NULL)
            pszValue = "<NONE>";
        else {
            if (rgRDNAttr[i].Value.cbData)
                printf("Value: %s\n", pszValue);
            else
                // For UNICODE, cbData is 0.
                printf("Value: %S\n", (LPCSTR) pszValue);
        }
    }
}

typedef PCCERT_CONTEXT (WINAPI *PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE)(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,
    IN OPTIONAL LPCWSTR pwszDisplaystring,
    IN DWORD dwDontUseColumn,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

void SelectCertficateFromStoreUI(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags
    )
{
    HMODULE hDll = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE
        pfnCryptUIDlgSelectCertificateFromStore;

    if (NULL == (hDll = LoadLibraryA("cryptui.dll"))) {
        PrintLastError("LoadLibraryA(cryptui.dll)");
        goto CommonReturn;
    }

    if (NULL == (pfnCryptUIDlgSelectCertificateFromStore =
            (PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE)
                GetProcAddress(hDll, "CryptUIDlgSelectCertificateFromStore"))) {
        PrintLastError("GetProcAddress(CryptUIDlgSelectCertificateFromStore)");
        goto CommonReturn;
    }

    pCert = pfnCryptUIDlgSelectCertificateFromStore(
        hStore,
        NULL,       // hwnd
        NULL,       // pwszTitle
        NULL,       // pwszDisplaystring
        CRYPTUI_SELECT_INTENDEDUSE_COLUMN |
            CRYPTUI_SELECT_FRIENDLYNAME_COLUMN |
            CRYPTUI_SELECT_LOCATION_COLUMN,
        0,          // dwFlags
        NULL        // pvReserved
        );

    if (NULL == pCert)
        PrintLastError("CryptUIDlgSelectCertificateFromStore");
    else {
        printf("=====  Selected Certificate  =====\n");
        DisplayCert(pCert, dwDisplayFlags & ~DISPLAY_UI_FLAG);
    }

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (hDll)
        FreeLibrary(hDll);
}


int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus;

    DWORD dwFindCmp = CERT_COMPARE_ANY;
    DWORD dwFindInfo = 0;
    LPSTR pszFindInfo = NULL;
    DWORD dwFindType;
    DWORD dwFindFlags = 0;
    void *pvFindPara = NULL;

    DWORD cbHash = 0;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    CERT_NAME_BLOB NameBlob;
    BYTE *pbEncodedName = NULL;
    DWORD cbEncodedName;

#define MAX_RDN_ATTR 20
    DWORD cRDNAttr = 0;
    CERT_RDN_ATTR rgRDNAttr[MAX_RDN_ATTR + 1];
    memset (rgRDNAttr, 0, sizeof(rgRDNAttr));
    CERT_RDN NameRDN;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];
    CTL_USAGE CtlUsage = {0, rgpszUsageId};

    BOOL fSystemStore = FALSE;
    BOOL fDelete = FALSE;
    LPSTR pszCertFilename = NULL;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszPutFilename = NULL;
    LPSTR pszFindStr = NULL;
    DWORD dwDisplayFlags = 0;
    BOOL fQuiet = FALSE;

    BOOL fPKCS7Save = FALSE;
    LPSTR pszSaveFilename = NULL;

#define MAX_DIST_POINT                  10
#define MAX_DIST_POINT_ALT_NAME_ENTRY   20
    CERT_ALT_NAME_INFO rgDistPoint[MAX_DIST_POINT];
    CERT_ALT_NAME_ENTRY rgDistPointAltNameEntry[MAX_DIST_POINT_ALT_NAME_ENTRY];
    CROSS_CERT_DIST_POINTS_INFO XCertInfo = {0, 0, rgDistPoint};
    DWORD cDistPointAltNameEntry = 0;
    BOOL fAddXCertProp = FALSE;
    BOOL fDeleteXCertProp = FALSE;
    BYTE *pbEncodedXCert = NULL;
    DWORD cbEncodedXCert;

    HANDLE hStore;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'D':
                {
                    char *pszHash = argv[0]+2;
                    int cchHash = strlen(pszHash);
                    char rgch[3];
                    if (!(cchHash == 32 || cchHash == 40)) {
                        printf("Need 32 digits (MD5) or 40 digits (SHA) ");
                        printf("for hash , not %d digits\n", cchHash);
            			goto BadUsage;
                    }
                    if (32 == cchHash)
                        dwFindCmp = CERT_COMPARE_MD5_HASH;
                    else
                        dwFindCmp = CERT_COMPARE_SHA1_HASH;
                    cbHash = 0;
                    while (cchHash > 0) {
                        rgch[0] = *pszHash++;
                        rgch[1] = *pszHash++;
                        rgch[2] = '\0';
                        rgbHash[cbHash++] = (BYTE) strtoul(rgch, NULL, 16);
                        cchHash -= 2;
                    }
                }
                break;
            case 'S':
                dwFindInfo = CERT_INFO_SUBJECT_FLAG;
                pszFindInfo = "subject";
                break;
            case 'I':
                dwFindInfo = CERT_INFO_ISSUER_FLAG;
                pszFindInfo = "issuer";
                break;
            case 'f':
                pszCertFilename = argv[0]+2;
                if (*pszCertFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                dwFindCmp = CERT_COMPARE_NAME;
                break;
            case 'o':
                rgRDNAttr[cRDNAttr].pszObjId = argv[0] + 2;
                break;
            case 't':
                rgRDNAttr[cRDNAttr].dwValueType =
                    (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'a':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
            		goto BadUsage;
                }
                rgRDNAttr[cRDNAttr].Value.cbData = strlen(argv[0] + 2);
                if (rgRDNAttr[cRDNAttr].Value.cbData == 0)
                    rgRDNAttr[cRDNAttr].Value.pbData = NULL;
                else
                    rgRDNAttr[cRDNAttr].Value.pbData = (BYTE *) (argv[0] + 2);
                cRDNAttr++;
                dwFindCmp = CERT_COMPARE_ATTR;
                break;
            case 'A':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
            		goto BadUsage;
                }
                rgRDNAttr[cRDNAttr].Value.pbData =
                    (BYTE *) AllocAndSzToWsz(argv[0]+2);
                rgRDNAttr[cRDNAttr].Value.cbData = 0;
                cRDNAttr++;
                dwFindFlags |= CERT_UNICODE_IS_RDN_ATTRS_FLAG;
                dwFindCmp = CERT_COMPARE_ATTR;
                break;
            case 'C':
                dwFindFlags |= CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG;
                break;
            case 'U':
                if (CtlUsage.cUsageIdentifier >= MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                if (0 < strlen(argv[0] + 2))
                    rgpszUsageId[CtlUsage.cUsageIdentifier++] = argv[0] + 2;
                dwFindCmp = CERT_COMPARE_CTL_USAGE;
                break;
            case 'F':
                dwFindFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case '7':
                fPKCS7Save = TRUE;
                if (argv[0][2])
                    pszSaveFilename = argv[0]+2;
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'u':
                dwDisplayFlags |= DISPLAY_UI_FLAG;
                break;
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 's':
                fSystemStore = TRUE;
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;

            case 'x':
            case 'X':
                fAddXCertProp = TRUE;
                if (argv[0][2] == 0)
                    ;
                else if (0 == _stricmp(argv[0]+2, "Delete"))
                    fDeleteXCertProp = TRUE;
                else if (isdigit(argv[0][2]))
                    XCertInfo.dwSyncDeltaTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                else {
                    if (cDistPointAltNameEntry >=
                            MAX_DIST_POINT_ALT_NAME_ENTRY) {
                        printf("Exceeded DistPointAltNameEntry MaxCount(%d)\n",
                            MAX_DIST_POINT_ALT_NAME_ENTRY);
                        goto BadUsage;
                    }
                    if (XCertInfo.cDistPoint == 0 ||
                            argv[0][1] == 'x') {
                        if (XCertInfo.cDistPoint >= MAX_DIST_POINT) {
                            printf("Exceeded DistPoint MaxCount(%d)\n",
                                MAX_DIST_POINT);
                            goto BadUsage;
                        }
                        XCertInfo.rgDistPoint[XCertInfo.cDistPoint].cAltEntry =
                            0;
                        XCertInfo.rgDistPoint[XCertInfo.cDistPoint].rgAltEntry =
                            &rgDistPointAltNameEntry[cDistPointAltNameEntry];
                        XCertInfo.cDistPoint++;
                    }

                    rgDistPointAltNameEntry[cDistPointAltNameEntry].dwAltNameChoice =
                        CERT_ALT_NAME_URL;
                    rgDistPointAltNameEntry[cDistPointAltNameEntry].pwszURL =
                        AllocAndSzToWsz(argv[0]+2);
                    cDistPointAltNameEntry++;
                    XCertInfo.rgDistPoint[XCertInfo.cDistPoint - 1].cAltEntry++;


                }
                break;
                
            case 'h':
            default:
            	goto BadUsage;
            }
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if (pszFindStr == NULL) {
                if (dwFindCmp != CERT_COMPARE_ANY) {
                    printf("Invalid options for <Name String>\n");
                    goto BadUsage;
                }
                dwFindCmp = CERT_COMPARE_NAME_STR_A;
                if (dwFindInfo == 0) {
                    dwFindInfo = CERT_INFO_SUBJECT_FLAG;
                    pszFindInfo = "subject";
                }
                pszFindStr = argv[0];
            } else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }
    
    printf("command line: %s\n", GetCommandLine());

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    if (pszSaveFilename == NULL) {
        if (!fSystemStore)
            pszSaveFilename = pszStoreFilename;
    }

    dwFindType = dwFindCmp << CERT_COMPARE_SHIFT | dwFindInfo;
    switch (dwFindType) {
        case CERT_FIND_ANY:
            if (dwDisplayFlags & DISPLAY_UI_FLAG)
                printf("UI certificate selection\n");
            else
                printf("Finding all certificates\n");
            break;
        case CERT_FIND_MD5_HASH:
        case CERT_FIND_SHA1_HASH:
            {
                if (CERT_FIND_MD5_HASH == dwFindType)
                    printf("Finding MD5 hash:: ");
                else
                    printf("Finding SHA1 hash:: ");

                DWORD cb = cbHash;
                BYTE *pb = rgbHash;
                for (; cb > 0; cb--, pb++)
                    printf("%02X", *pb);
                printf("\n");
            }
            HashBlob.pbData = rgbHash;
            HashBlob.cbData = cbHash;
            pvFindPara = &HashBlob;
            break;
        case CERT_FIND_SUBJECT_NAME:
        case CERT_FIND_ISSUER_NAME:
            printf("Finding %s name using CertFile %s\n",
                pszFindInfo, pszCertFilename);
            if (!AllocAndGetEncodedName(pszCertFilename, dwFindInfo,
                    &pbEncodedName, &cbEncodedName))
                goto ErrorReturn;
            NameBlob.pbData = pbEncodedName;
            NameBlob.cbData = cbEncodedName;
            pvFindPara = &NameBlob;
            break;
        case CERT_FIND_SUBJECT_ATTR:
        case CERT_FIND_ISSUER_ATTR:
            printf("Finding %s name using attributes::\n", pszFindInfo);
            DisplayFindAttr(cRDNAttr, rgRDNAttr);
            NameRDN.cRDNAttr = cRDNAttr;
            NameRDN.rgRDNAttr = rgRDNAttr;
            pvFindPara = &NameRDN;
            break;
        case CERT_FIND_SUBJECT_STR_A:
        case CERT_FIND_ISSUER_STR_A:
            printf("Finding %s name matching:: %s\n", pszFindInfo, pszFindStr);
            pvFindPara = pszFindStr;
            break;
        case CERT_FIND_CTL_USAGE:
            if (dwFindFlags & CERT_FIND_OPTIONAL_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_OPTIONAL_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_NO_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_NO_CTL_USAGE_FLAG\n");
            if (0 == CtlUsage.cUsageIdentifier) {
                printf("No Usage Identifiers\n");
                pvFindPara = NULL;
            } else {
                LPSTR *ppszId = CtlUsage.rgpszUsageIdentifier;
                DWORD i;

                printf("Usage Identifiers::\n");
                for (i = 0; i < CtlUsage.cUsageIdentifier; i++, ppszId++)
                    printf(" [%d] %s\n", i, *ppszId);

                pvFindPara = &CtlUsage;
            }
            break;
        default:
            printf("Bad dwFindType: %x\n", dwFindType);
            goto BadUsage;
    }

    if (fAddXCertProp && !fDeleteXCertProp) {
        printf("Encoding Cross Certificate Property\n");
        if (!AllocAndEncodeObject(
                X509_CROSS_CERT_DIST_POINTS,
                &XCertInfo,
                &pbEncodedXCert,
                &cbEncodedXCert))
            goto ErrorReturn;
    }
        

    // Attempt to open the store
    hStore = OpenStore(fSystemStore, pszStoreFilename);
    if (hStore == NULL)
        return -1;

    if (CERT_FIND_ANY == dwFindType && (dwDisplayFlags & DISPLAY_UI_FLAG)) {
        SelectCertficateFromStoreUI(hStore, dwDisplayFlags);
    } else {
        int i;
        PCCERT_CONTEXT pCert = NULL;
        PCCERT_CONTEXT pDeleteCert = NULL;

        for (i = 0;; i++) {
            pCert = CertFindCertificateInStore(
                hStore,
                dwCertEncodingType,
                dwFindFlags,
                dwFindType,
                pvFindPara,
                pCert
                );
            if (pCert == NULL) {
                if (i == 0) {
                    if (GetLastError() == CRYPT_E_NOT_FOUND)
                        printf(
                            "CertFindCertificateInStore warning => cert not found\n");
                    else
                        PrintLastError("CertFindCertificateInStore");
                }
                break;
            }

            if (fDeleteXCertProp) {
                printf("Deleting Cross Certificate Property from following =>\n");

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        ))
                    PrintLastError("CertSetCertificateContextProperty(Delete)");
            } else if (fAddXCertProp) {
                CRYPT_DATA_BLOB Data;

                printf("Adding Cross Certificate Property to following =>\n");

                Data.pbData = pbEncodedXCert;
                Data.cbData = cbEncodedXCert;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError("CertSetCertificateContextProperty");
            }

            if (!fQuiet) {
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, dwDisplayFlags);
            }

            if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded
                        ))
                    PrintLastError("Put Cert::WriteDERToFile");
            }

            if (fDelete) {
                printf("Deleting\n");
                if (pDeleteCert) {
                    if (!CertDeleteCertificateFromStore(pDeleteCert))
                        PrintLastError("CertDeleteCertificateFromStore");
                }
                pDeleteCert = CertDuplicateCertificateContext(pCert);
            }
        }

        if (pDeleteCert) {
            if (!CertDeleteCertificateFromStore(pDeleteCert))
                PrintLastError("CertDeleteCertificateFromStore");

            if (!fSystemStore)
                SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);
        } else if (fAddXCertProp || fDeleteXCertProp) {
            if (!fSystemStore)
                SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);
        }


    }

    if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
        PrintLastError("CertCloseStore");
    if (pbEncodedName)
        TestFree(pbEncodedName);

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    while (cRDNAttr--) {
        if (0 == rgRDNAttr[cRDNAttr].Value.cbData &&
                rgRDNAttr[cRDNAttr].Value.pbData)
            // Allocated for unicode
            TestFree(rgRDNAttr[cRDNAttr].Value.pbData);
    }

    while (cDistPointAltNameEntry--)
        TestFree(rgDistPointAltNameEntry[cDistPointAltNameEntry].pwszURL);
    TestFree(pbEncodedXCert);

    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tfindctl\tfindctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tfindctl.cpp
//
//  Contents:   Find CTL in Cert Store API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    06-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tfindctl [options] <StoreName>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -D<digest>            - Find CTL matching Digest (Hash)\n");
    printf("  -S<filename>          - Subject certificate file\n");
    printf("  -I<filename>          - CTL issuer certificate file\n");
    printf("  -U<ObjectID>          - Usage Identifiers\n");
    printf("  -L<text>              - List Identifier\n");
    printf("  -A                    - Test via AnySubjectType\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -p<filename>          - Put encoded CTL to file\n");
    printf("  -d                    - Delete CTL\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -c                    - Verify checks enabled\n");
    printf("  -q                    - Quiet. Don't display CTLs\n");
    printf("  -fTimeValid           - Only Time Valid CTLs\n");
    printf("  -fTimeInvalid         - Only Time Invalid CTLs\n");
    printf("  -fSameUsage           - Only CTLs with same -U<ObjectID>'s\n");
    printf("\n");
    printf("Default: find all CTLs in the store\n");
}

static PCCERT_CONTEXT GetCertFromFile(
    LPSTR pszCertFilename
    )
{
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("GetCertFromFile::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("GetCertFromFile::CertCreateCertificateContext");
        goto ErrorReturn;
    }

ErrorReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    return pCert;
}

// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}


int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus;

    DWORD dwFindType = CTL_FIND_ANY;
    DWORD dwFindFlags = 0;
    void *pvFindPara = NULL;

    DWORD cbHash = 0;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    LPSTR pszSubjectFilename = NULL;        // not allocated
    PCCERT_CONTEXT pSubjectCert = NULL;

    LPSTR pszIssuerFilename = NULL;         // not allocated
    PCCERT_CONTEXT pIssuerCert = NULL;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];

    CTL_FIND_USAGE_PARA FindUsagePara;
    CTL_FIND_SUBJECT_PARA FindSubjectPara;

    CTL_ANY_SUBJECT_INFO AnySubjectInfo;

    BOOL fFindUsagePara = FALSE;
    BOOL fFindSubjectPara = FALSE;
    BOOL fAnySubjectType = FALSE;

    BOOL fSystemStore = FALSE;
    BOOL fDelete = FALSE;
    BOOL fTimeValid = FALSE;
    BOOL fTimeInvalid = FALSE;
    LPSTR pszStoreFilename = NULL;          // not allocated
    LPSTR pszPutFilename = NULL;            // not allocated
    DWORD dwDisplayFlags = 0;
    BOOL fQuiet = FALSE;
    HCERTSTORE hStore = NULL;

    memset(&FindUsagePara, 0, sizeof(FindUsagePara));
    FindUsagePara.cbSize = sizeof(FindUsagePara);
    memset(&FindSubjectPara, 0, sizeof(FindSubjectPara));
    FindSubjectPara.cbSize = sizeof(FindSubjectPara);

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'D':
                {
                    char *pszHash = argv[0]+2;
                    int cchHash = strlen(pszHash);
                    char rgch[3];
                    if (!(cchHash == 32 || cchHash == 40)) {
                        printf("Need 32 digits (MD5) or 40 digits (SHA) ");
                        printf("for hash , not %d digits\n", cchHash);
            			goto BadUsage;
                    }
                    if (32 == cchHash)
                        dwFindType = CTL_FIND_MD5_HASH;
                    else
                        dwFindType = CTL_FIND_SHA1_HASH;
                    cbHash = 0;
                    while (cchHash > 0) {
                        rgch[0] = *pszHash++;
                        rgch[1] = *pszHash++;
                        rgch[2] = '\0';
                        rgbHash[cbHash++] = (BYTE) strtoul(rgch, NULL, 16);
                        cchHash -= 2;
                    }
                }
                break;
            case 'U':
                if (FindUsagePara.SubjectUsage.cUsageIdentifier >=
                        MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                FindUsagePara.SubjectUsage.rgpszUsageIdentifier = rgpszUsageId;
                rgpszUsageId[FindUsagePara.SubjectUsage.cUsageIdentifier++] =
                    argv[0] + 2;
                fFindUsagePara = TRUE;
                break;
            case 'L':
                if (0 == strlen(argv[0] + 2))
                    FindUsagePara.ListIdentifier.cbData =
                        CTL_FIND_NO_LIST_ID_CBDATA;
                else {
                    FindUsagePara.ListIdentifier.cbData = strlen(argv[0] + 2);
                    FindUsagePara.ListIdentifier.pbData = (BYTE *) argv[0] + 2;
                }
                fFindUsagePara = TRUE;
                break;
            case 'I':
                if (0 == strlen(argv[0] + 2))
                    FindUsagePara.pSigner = CTL_FIND_NO_SIGNER_PTR;
                else
                    pszIssuerFilename = argv[0]+2;
                fFindUsagePara = TRUE;
                break;
            case 'S':
                pszSubjectFilename = argv[0]+2;
                if (*pszSubjectFilename == '\0') {
                    printf("Need to specify SubjectFilename\n");
            		goto BadUsage;
                }
                fFindSubjectPara = TRUE;
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                break;
            case 'A':
                fAnySubjectType = TRUE;
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "TimeValid"))
                        fTimeValid = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "TimeInvalid"))
                        fTimeInvalid = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "SameUsage"))
                        dwFindFlags |= CTL_FIND_SAME_USAGE_FLAG;
                    else {
                        printf("Need to specify -fTimeValid | -fTimeInvalid | -fSameUsage\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -fTimeValid | -fTimeInvalid | -fSameUsage\n");
                    goto BadUsage;
                }
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 's':
                fSystemStore = TRUE;
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
            	goto BadUsage;
            }
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }
    
    printf("command line: %s\n", GetCommandLine());

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    if (pszIssuerFilename) {
        if (NULL == (pIssuerCert = GetCertFromFile(pszIssuerFilename))) {
            printf("Unable to read/decode IssuerFilename\n");
            goto ErrorReturn;
        }
        FindUsagePara.pSigner = pIssuerCert->pCertInfo;
    }

    if (pszSubjectFilename) {
        if (NULL == (pSubjectCert = GetCertFromFile(pszSubjectFilename))) {
            printf("Unable to read/decode SubjectFilename\n");
            goto ErrorReturn;
        }

        if (fAnySubjectType) {
            memset(&AnySubjectInfo, 0, sizeof(AnySubjectInfo));
            AnySubjectInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

            AnySubjectInfo.SubjectIdentifier.cbData = MAX_HASH_LEN;
            if (!CertGetCertificateContextProperty(
                    pSubjectCert,
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &AnySubjectInfo.SubjectIdentifier.cbData) ||
                        0 == AnySubjectInfo.SubjectIdentifier.cbData) {
                printf("failed => unable to get SHA1 hash for Subject Cert\n");
                goto ErrorReturn;;
            }
            AnySubjectInfo.SubjectIdentifier.pbData = rgbHash;

            FindSubjectPara.dwSubjectType = CTL_ANY_SUBJECT_TYPE;
            FindSubjectPara.pvSubject = &AnySubjectInfo;
        } else {
            FindSubjectPara.dwSubjectType = CTL_CERT_SUBJECT_TYPE;
            FindSubjectPara.pvSubject = (void *) pSubjectCert;
        }
    }

    if (fFindSubjectPara) {
        if (fFindUsagePara)
            FindSubjectPara.pUsagePara = &FindUsagePara;
        dwFindType = CTL_FIND_SUBJECT;
    } else if (fFindUsagePara)
        dwFindType = CTL_FIND_USAGE;

    switch (dwFindType) {
        case CTL_FIND_ANY:
            printf("Finding all CTLs\n");
            break;
        case CTL_FIND_MD5_HASH:
        case CTL_FIND_SHA1_HASH:
            {
                if (CTL_FIND_MD5_HASH == dwFindType)
                    printf("Finding MD5 hash:: ");
                else
                    printf("Finding SHA1 hash:: ");

                DWORD cb = cbHash;
                BYTE *pb = rgbHash;
                for (; cb > 0; cb--, pb++)
                    printf("%02X", *pb);
                printf("\n");
            }
            HashBlob.pbData = rgbHash;
            HashBlob.cbData = cbHash;
            pvFindPara = &HashBlob;
            break;
        case CTL_FIND_USAGE:
            printf("Finding by Usage\n");
            pvFindPara = &FindUsagePara;
            break;
        case CTL_FIND_SUBJECT:
            if (FindSubjectPara.pUsagePara)
                printf("Finding by Usage and Subject\n");
            else
                printf("Finding by Subject\n");
            pvFindPara = &FindSubjectPara;
            break;
        default:
            printf("Bad dwFindType: %x\n", dwFindType);
            goto BadUsage;
    }

    if (fFindUsagePara) {
        DWORD cUsageId = FindUsagePara.SubjectUsage.cUsageIdentifier;
        if (0 == cUsageId)
            printf("No Usage Identifiers\n");
        else {
            LPSTR *ppszId = FindUsagePara.SubjectUsage.rgpszUsageIdentifier;
            DWORD i;

            printf("Usage Identifiers::\n");
            for (i = 0; i < cUsageId; i++, ppszId++)
                printf(" [%d] %s\n", i, *ppszId);
        }

        if (CTL_FIND_NO_LIST_ID_CBDATA == FindUsagePara.ListIdentifier.cbData)
            printf("Enabled:: CTL_FIND_NO_LIST_ID_CBDATA\n");
        else if (0 == FindUsagePara.ListIdentifier.cbData)
            printf("Matching any ListIdentifier\n");
        else
            printf("Matching ListIdentifier: %s\n",
                FindUsagePara.ListIdentifier.pbData);

        if (CTL_FIND_NO_SIGNER_PTR == FindUsagePara.pSigner)
            printf("Enabled:: CTL_FIND_NO_SIGNER_PTR\n");
        else if (NULL == FindUsagePara.pSigner)
            printf("Matching any Signer\n");
        else
            printf("Matching signer with certificate from %s\n",
                pszIssuerFilename);
    }

    if (fFindSubjectPara) {
        printf("Matching subject with certificate from %s", pszSubjectFilename);
        if (FindSubjectPara.dwSubjectType == CTL_ANY_SUBJECT_TYPE)
            printf("Using CTL_ANY_SUBJECT_TYPE\n");
        else
            printf("\n");
    }
        

    if (!fSystemStore)
        // Attempt to open as encoded CTL file
        hStore = OpenCtlStoreFile(pszStoreFilename);
    else
        hStore = NULL;

    if (NULL == hStore) {
        // Attempt to open the store
        hStore = OpenStore(fSystemStore, pszStoreFilename);
        if (hStore == NULL)
            goto ErrorReturn;
    }

    {
        PCCTL_CONTEXT pCtl = NULL;
        DWORD i = 0;
        while (pCtl = CertFindCTLInStore(
                hStore,
                dwMsgAndCertEncodingType,
                dwFindFlags,
                dwFindType,
                pvFindPara,
                pCtl
                )) {
            if (fTimeValid && !IsTimeValidCtl(pCtl))
                continue;
            if (fTimeInvalid && IsTimeValidCtl(pCtl))
                continue;

            if (!fQuiet) {
                printf("=====  %d  =====\n", i);
                DisplayCtl(pCtl, dwDisplayFlags, hStore);
                if (fFindSubjectPara) {
                    PCTL_ENTRY pEntry;
                
                    pEntry = CertFindSubjectInCTL(
                        dwMsgAndCertEncodingType,
                        FindSubjectPara.dwSubjectType,
                        FindSubjectPara.pvSubject,
                        pCtl,
                        0                           // dwFlags
                        );
                    printf("\n");
                    if (pEntry)
                        printf("Subject Index:: %d\n",
                            pEntry - pCtl->pCtlInfo->rgCTLEntry);
                    else
                        PrintLastError("CertFindSubjectInCTL");
                }
            }
            i++;

            if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCtl->pbCtlEncoded,
                        pCtl->cbCtlEncoded
                        ))
                    PrintLastError("Put Ctl::WriteDERToFile");
            }

            if (fDelete) {
                PCCTL_CONTEXT pDeleteCtl;
                printf("Deleting\n");
                pDeleteCtl = CertDuplicateCTLContext(pCtl);
                if (!CertDeleteCTLFromStore(pDeleteCtl))
                    PrintLastError("CertDeleteCTLFromStore");
            }
        }

        if (i == 0) {
            if (GetLastError() == CRYPT_E_NOT_FOUND)
                printf("CertFindCTLsInStore warning => CTL not found\n");
            else
                PrintLastError("CertFindCTLsInStore");
        } else if (fDelete && !fSystemStore)
            SaveStore(hStore, pszStoreFilename);
    }

    if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
        PrintLastError("CertCloseStore");

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (pSubjectCert)
        CertFreeCertificateContext(pSubjectCert);
    if (pIssuerCert)
        CertFreeCertificateContext(pIssuerCert);

    if (!ReturnStatus)
        printf("Passed\n");
    else
        printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tgetopus\tgetopus.cpp ===
//+-------------------------------------------------------------------------
//  File:       tgetopus.cpp
//
//  Contents:   Example code to get OPUS info from an authenticode signed
//              file. The OPUS info contains the publisher specified
//              program name and more info URL.
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>


//+-------------------------------------------------------------------------
//  The returned OPUS info must be freed via LocalFree().
//
//  NULL is returned if unable to extract the OPUS info from the file.
//  Call GetLastError() to get additional error info.
//
//  Interesting fields:
//      pOpusInfo->pwszProgramName
//      pOpusInfo->pMoreInfo, where normally
//          pOpusInfo->pMoreInfo->dwLinkChoice == SPC_URL_LINK_CHOICE
//          pOpusInfo->pMoreInfo->pwszUrl
//
//--------------------------------------------------------------------------
PSPC_SP_OPUS_INFO
GetOpusInfoFromSignedFile(
    IN LPCWSTR pwszFilename
    )
{
    DWORD dwLastError = 0;
    PSPC_SP_OPUS_INFO pOpusInfo = NULL;
    HCRYPTMSG hCryptMsg = NULL;
    PCMSG_SIGNER_INFO pSignerInfo = NULL;
    DWORD cbInfo;
    PCRYPT_ATTRIBUTE pOpusAttr;             // not allocated

    // Extract the PKCS 7 message from the signed file
    if (!CryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            (const void *) pwszFilename,
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
            CERT_QUERY_FORMAT_FLAG_BINARY,
            0,                                  // dwFlags
            NULL,                               // pdwMsgAndCertEncodingType
            NULL,                               // pdwContentType
            NULL,                               // pdwFormatType
            NULL,                               // phCertStore
            &hCryptMsg,
            NULL                                // ppvContext
            ))
        goto ExtractPKCS7FromSignedFileError;

    // Get the signer info for the first signer. Note, authenticode
    // currently only has one signer.
    cbInfo = 0;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_SIGNER_INFO_PARAM,
            0,                          // dwSignerIndex
            NULL,                       // pvData
            &cbInfo
            ))
        goto GetSignerInfoError;
    if (NULL == (pSignerInfo = (PCMSG_SIGNER_INFO) LocalAlloc(LPTR, cbInfo)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_SIGNER_INFO_PARAM,
            0,                          // dwSignerIndex
            pSignerInfo,
            &cbInfo
            ))
        goto GetSignerInfoError;

    // If present, the OPUS info is an authenticated signer attribute
    if (NULL == (pOpusAttr = CertFindAttribute(
            SPC_SP_OPUS_INFO_OBJID,
            pSignerInfo->AuthAttrs.cAttr,
            pSignerInfo->AuthAttrs.rgAttr
            )) || 0 == pOpusAttr->cValue) {
        SetLastError(CRYPT_E_ATTRIBUTES_MISSING);
        goto NoOpusAttr;
    }

    // Simply allocate and decode the OPUS info stored in the above
    // authenticated attribute. Note, the returned allocated structure
    // must be freed via LocalAlloc()
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            SPC_SP_OPUS_INFO_STRUCT,
            pOpusAttr->rgValue[0].pbData,
            pOpusAttr->rgValue[0].cbData,
            CRYPT_DECODE_ALLOC_FLAG,
            (void *) &pOpusInfo,
            &cbInfo
            ))
        goto DecodeOpusInfoError;

CommonReturn:
    if (hCryptMsg)
        CryptMsgClose(hCryptMsg);
    if (pSignerInfo)
        LocalFree(pSignerInfo);

    if (dwLastError)
        SetLastError(dwLastError);
    return pOpusInfo;

ExtractPKCS7FromSignedFileError:
GetSignerInfoError:
OutOfMemory:
NoOpusAttr:
DecodeOpusInfoError:
    goto CommonReturn;
}


void Usage(void)
{
    printf("Usage: tgetopus <filename>\n");
}


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR) LocalAlloc(LPTR, cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("Bad AllocAndSzToWsz\n");
failed:
    if (pwsz) {
        LocalFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

int _cdecl main(int argc, char * argv[]) 
{
    int iStatus = 0;
    LPCSTR pszFilename = NULL;      // not allocated
    LPWSTR pwszFilename = NULL;
    PSPC_SP_OPUS_INFO pOpusInfo = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'h':
                default:
                    goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename \n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (NULL == (pwszFilename = AllocAndSzToWsz(pszFilename)))
        goto ErrorReturn;

    if (NULL == (pOpusInfo = GetOpusInfoFromSignedFile(pwszFilename))) {
        PrintLastError("GetOpusInfoFromSignedFile");
        goto ErrorReturn;
    }

    if (pOpusInfo->pwszProgramName)
        printf("ProgramName:: %S\n", pOpusInfo->pwszProgramName);
    else
        printf("NO ProgramName\n");

    if (pOpusInfo->pMoreInfo &&
            SPC_URL_LINK_CHOICE == pOpusInfo->pMoreInfo->dwLinkChoice)
        printf("ProgramUrl:: %S\n", pOpusInfo->pMoreInfo->pwszUrl);
    else
        printf("NO ProgramUrl\n");


    printf("Passed\n");
    iStatus = 0;

CommonReturn:
    if (pwszFilename)
        LocalFree(pwszFilename);
    if (pOpusInfo)
        LocalFree(pOpusInfo);

    return iStatus;
ErrorReturn:
    iStatus = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tkeyid\tkeyid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       tkeyid.cpp
//
//  Contents:   Key Identifier Property Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    15-Mar-98   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static BOOL fVerify = FALSE;

static void Usage(void)
{
    printf("Usage: tkeyid [options] <TestName>\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -c<Cert Filename>     - Key Identifier obtained from cert\n");
    printf("  -k<Hash>              - Key Identifier Hash\n");
    printf("  -s<SystemStore>       - Get cert properties from system store\n");
    printf("  -S<FileSystemStore>   - Get cert properties from file store\n");
    printf("  -p<Number>            - Property Id\n");
    printf("  -M[<ComputerName>]    - LocalMachine Key Identifiers\n");
    printf("  -f<Number>            - Flags\n");
    printf("  -V                    - Verify KeyProvInfo property\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Set\n");
    printf("  Get\n");
    printf("  Delete\n");
    printf("  DeleteAll\n");
    printf("  DeleteWithoutCert\n");
    printf("  Enum\n");
    printf("\n");
}

static PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

static BOOL TestSet(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult = TRUE;

    if (0 == dwPropId) {
        BOOL fProp = FALSE;

        // Copy all the certificate properties to the KeyIdentifier
        while (dwPropId = CertEnumCertificateContextProperties(
                pCert, dwPropId)) {
            fProp = TRUE;
            fResult &= TestSet(
                pKeyIdentifier,
                pCert,
                dwPropId,
                dwFlags,
                pwszComputerName
                );
        }

        if (!fProp)
            printf("Certificate doesn't have any properties\n");
    } else {
        // Attempt to get and copy the specified certificate property
        // to the KeyIdentifier.

        void *pvData = NULL;
        DWORD cbData;
        CRYPT_DATA_BLOB DataBlob;
        void *pvSetData;

        printf("Setting PropId %d (0x%x)\n", dwPropId, dwPropId);
        if (!CertGetCertificateContextProperty(
                pCert,
                dwPropId,
                NULL,                           // pvData
                &cbData
                )) {
            PrintLastError("CertGetCertificateContextProperty");
            goto ErrorReturn;
        }

        if (cbData) {
            if (NULL == (pvData = TestAlloc(cbData)))
                goto ErrorReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    pvData,
                    &cbData
                    )) {
                PrintLastError("CertGetCertificateContextProperty");
                TestFree(pvData);
                goto ErrorReturn;
            }
        }

        if (CERT_KEY_PROV_INFO_PROP_ID != dwPropId) {
            DataBlob.pbData = (BYTE *) pvData;
            DataBlob.cbData = cbData;
            pvSetData = &DataBlob;
        } else
            pvSetData = pvData;

        fResult = CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,                   // pvReserved
            pvSetData
            );
        TestFree(pvData);
        if (!fResult)
            PrintLastError("CryptSetKeyIdentifierProperty");
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL TestDelete(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult;

    if (0 == dwPropId) {
        printf("Deleting KeyIdentifier and all its properties\n");
        dwFlags |= CRYPT_KEYID_DELETE_FLAG;
    } else
        printf("Deleting PropId %d (0x%x)\n", dwPropId, dwPropId);

    fResult = CryptSetKeyIdentifierProperty(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        NULL                    // pvData
        );
    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr)
            fResult = TRUE;
        if (!fResult)
            PrintLastError("CryptSetKeyIdentifierProperty");
    }

    return fResult;
}

static void VerifyKeyProvInfo(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
    )
{
    BOOL fResult;
    DWORD dwErr;
    DWORD dwAcquireFlags;
    HCRYPTPROV hCryptProv = 0;
    HCRYPTKEY hPubKey = 0;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash;

    dwAcquireFlags = pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID;

    fResult = CryptAcquireContextU(
            &hCryptProv,
            pKeyProvInfo->pwszContainerName,
            pKeyProvInfo->pwszProvName,
            pKeyProvInfo->dwProvType,
            dwAcquireFlags
            );
    if (!fResult && PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
                (NULL == pKeyProvInfo->pwszProvName ||
                    L'\0' == *pKeyProvInfo->pwszProvName)) {
        dwErr = GetLastError();
        fResult = CryptAcquireContextU(
            &hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            dwAcquireFlags
            );
        if (!fResult)
            SetLastError(dwErr);
    }

    if (!fResult) {
        PrintLastError("CryptAcquireContext");
        return;
    }


    if (!CryptGetUserKey(
            hCryptProv,
            pKeyProvInfo->dwKeySpec,
            &hPubKey
            )) {
        hPubKey = 0;
        PrintLastError("CryptGetUserKey");
        goto ErrorReturn;
    }

    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0)) {
        PrintLastError("CryptExportKey");
        goto ErrorReturn;
    }

    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) TestAlloc(
            cbPubKeyStruc)))
        goto ErrorReturn;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            )) {
        PrintLastError("CryptExportKey");
        goto ErrorReturn;
    }

    cbHash = sizeof(rgbHash);
    if (!CryptCreateKeyIdentifierFromCSP(
            dwCertEncodingType,
            NULL,                           // pszPubKeyOID
            pPubKeyStruc,
            cbPubKeyStruc,
            0,                              // dwFlags
            NULL,                           // pvReserved
            rgbHash,
            &cbHash
            )) {
        PrintLastError("CryptCreateKeyIdentifierFromCSP");
        goto ErrorReturn;
    }

    if (pKeyIdentifier->cbData == cbHash &&
            0 == memcmp(pKeyIdentifier->pbData, rgbHash, cbHash))
        printf("  Verified KeyIdentifier with CSP\n");
    else {
        printf("  KeyIdentifier mismatch with CSP provider hash::\n");
        PrintBytes("    ", rgbHash, cbHash);
    }

ErrorReturn:
    TestFree(pPubKeyStruc);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
}

static void DisplayProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN const void *pvData,
    IN DWORD cbData
    )
{
    if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
        PCRYPT_KEY_PROV_INFO pInfo = (PCRYPT_KEY_PROV_INFO) pvData;
        
        printf("  Key Provider:: Type: %d", pInfo->dwProvType);
        if (pInfo->pwszProvName)
            printf(" Name: %S", pInfo->pwszProvName);
        if (pInfo->dwFlags) {
            printf(" Flags: 0x%x", pInfo->dwFlags);
            if (pInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                printf(" (MACHINE_KEYSET)");
            if (pInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID)
                printf(" (SET_KEY_CONTEXT_PROP)");
            printf(" ");
        }
        if (pInfo->pwszContainerName)
            printf(" Container: %S", pInfo->pwszContainerName);
        if (pInfo->cProvParam)
            printf(" Params: %d", pInfo->cProvParam);
        if (pInfo->dwKeySpec)
            printf(" KeySpec: %d", pInfo->dwKeySpec);
        printf("\n");

        if (fVerify) {
            VerifyKeyProvInfo(pKeyIdentifier, pInfo);
        }
    } else {
        printf("  PropId %d (0x%x) ::\n", dwPropId, dwPropId);
        PrintBytes("    ", (BYTE *) pvData, cbData);
    }
}

static void DisplayKeyIdentifier(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier
    )
{
    DWORD cbKeyId = pKeyIdentifier->cbData;
    BYTE *pbKeyId = pKeyIdentifier->pbData;
    printf("KeyIdentifier:: ");
    if (cbKeyId == 0)
        printf("???");
    else {
        ULONG cb;

        while (cbKeyId > 0) {
            cb = min(4, cbKeyId);
            cbKeyId -= cb;
            for (; cb > 0; cb--, pbKeyId++)
                printf("%02X", *pbKeyId);
            printf(" ");
        }
    }
    printf("\n");
}

static void DisplayKeyIdentifierCerts(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN HCERTSTORE hStore
    )
{
    if (NULL == hStore)
        return;

    PCCERT_CONTEXT pCert = NULL;
    DWORD i = 0;
    while (pCert = CertFindCertificateInStore(
            hStore,
            0,                      // dwCertEncodingType
            0,                      // dwFindFlags
            CERT_FIND_KEY_IDENTIFIER,
            pKeyIdentifier,
            pCert
            )) {
        DWORD cbData = 0;

        printf("\n");

        if (CertGetCertificateContextProperty(
                pCert,
                CERT_ARCHIVED_PROP_ID,
                NULL,                           // pvData
                &cbData
                ))
            printf("----------   ARCHIVED Cert [%d]   ----------\n", i);
        else
            printf("----------   Cert [%d]   ----------\n", i);
        i++;
        DisplayCert(pCert, 0);
    }

    if (0 == i)
        printf(">>>>  No Key Identifier Certificates  <<<<\n");
}

typedef struct _TEST_ENUM_ARG {
    HCERTSTORE  hStore;
    DWORD       dwDisplayFlags;
} TEST_ENUM_ARG, *PTEST_ENUM_ARG;


static BOOL WINAPI TestEnumCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwFlags,
    IN void *pvReserved,
    IN void *pvArg,
    IN DWORD cProp,
    IN DWORD *rgdwPropId,
    IN void **rgpvData,
    IN DWORD *rgcbData
    )
{
    PTEST_ENUM_ARG pArg = (PTEST_ENUM_ARG) pvArg;

    if (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        printf("\n");
        printf(
"=========================================================================\n");
    }
    DisplayKeyIdentifier(pKeyIdentifier);

    if (pArg->dwDisplayFlags & DISPLAY_BRIEF_FLAG)
        return TRUE;

    if (0 == cProp)
        printf("No Properties\n");
    else {
        DWORD i;
        for (i = 0; i < cProp; i++) {
            DWORD dwPropId = rgdwPropId[i];
            DisplayProperty(pKeyIdentifier, dwPropId, rgpvData[i], rgcbData[i]);
        }
    }

    if (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DisplayKeyIdentifierCerts(pKeyIdentifier, pArg->hStore);
    }

    return TRUE;
}

static HCERTSTORE OpenMyStore(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    DWORD dwOpenFlags;
    LPWSTR pwszAllocStore = NULL;
    LPWSTR pwszStore;
    HCERTSTORE hStore = NULL;

    pwszStore = L"My";
    if (dwFlags & CRYPT_KEYID_MACHINE_FLAG) {
        if (pwszComputerName) {
            DWORD cchStore;

            cchStore = wcslen(pwszComputerName) + 1 + wcslen(pwszStore) + 1;
            if (pwszAllocStore = (LPWSTR) TestAlloc(
                    cchStore * sizeof(WCHAR))) {
                wcscpy(pwszAllocStore, pwszComputerName);
                wcscat(pwszAllocStore, L"\\");
                wcscat(pwszAllocStore, pwszStore);
                pwszStore = pwszAllocStore;
            }
        }
        dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    } else
        dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    dwOpenFlags |= CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;

    hStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,                      // dwCertEncodingType
        0,                      // hCryptProv
        dwOpenFlags,
        (const void *) pwszStore
        );
    if (NULL == hStore) {
        if (dwFlags & CRYPT_KEYID_MACHINE_FLAG)
            printf("Unable to open LocalMachine store: %S\n", pwszStore);
        else
            printf("Unable to open CurrentUser store: %S\n", pwszStore);
        PrintLastError("CertOpenStore");
    }

    TestFree(pwszAllocStore);
    return hStore;
}

static BOOL TestEnum(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN DWORD dwDisplayFlags
    )
{
    BOOL fResult;
    TEST_ENUM_ARG TestArg;
    HCERTSTORE hStore;

    hStore = OpenMyStore(dwFlags, pwszComputerName);
    TestArg.hStore = hStore;
    TestArg.dwDisplayFlags = dwDisplayFlags;

    fResult = CryptEnumKeyIdentifierProperties(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        &TestArg,
        TestEnumCallback
        );
    if (!fResult)
        PrintLastError("CryptEnumKeyIdentifierProperty");

    if (hStore)
        CertCloseStore(hStore, 0);
    return fResult;
}

typedef struct _TEST_DELETE_ENUM_ARG {
    HCERTSTORE          hStore;
    LPCSTR              pszTestName;
    DWORD               cKeyIdentifier;
    PCRYPT_HASH_BLOB    rgKeyIdentifier;
} TEST_DELETE_ENUM_ARG, *PTEST_DELETE_ENUM_ARG;


static BOOL WINAPI TestDeleteEnumCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwFlags,
    IN void *pvReserved,
    IN void *pvArg,
    IN DWORD cProp,
    IN DWORD *rgdwPropId,
    IN void **rgpvData,
    IN DWORD *rgcbData
    )
{
    PTEST_DELETE_ENUM_ARG pArg = (PTEST_DELETE_ENUM_ARG) pvArg;
    BYTE *pbCopy = NULL;
    PCRYPT_HASH_BLOB pNewKeyIdentifier;
    DWORD cKeyIdentifier;


    if (0 == _stricmp("DeleteWithoutCert", pArg->pszTestName)) {
        PCCERT_CONTEXT pCert = NULL;
        if (pCert = CertFindCertificateInStore(
                pArg->hStore,
                0,                      // dwCertEncodingType
                0,                      // dwFindFlags
                CERT_FIND_KEY_IDENTIFIER,
                pKeyIdentifier,
                NULL                    // pPrevCert
                )) {
            CertFreeCertificateContext(pCert);
            return TRUE;
        }
    }

    if (NULL == (pbCopy = (BYTE *) TestAlloc(pKeyIdentifier->cbData)))
        return TRUE;
    memcpy(pbCopy, pKeyIdentifier->pbData, pKeyIdentifier->cbData);

    cKeyIdentifier = pArg->cKeyIdentifier;
    if (NULL == (pNewKeyIdentifier = (PCRYPT_HASH_BLOB) TestRealloc(
            pArg->rgKeyIdentifier,sizeof(CRYPT_HASH_BLOB) *
                (cKeyIdentifier + 1)))) {
        TestFree(pbCopy);
        return TRUE;
    }

    pNewKeyIdentifier[cKeyIdentifier].pbData = pbCopy;
    pNewKeyIdentifier[cKeyIdentifier].cbData = pKeyIdentifier->cbData;
    pArg->cKeyIdentifier = cKeyIdentifier + 1;
    pArg->rgKeyIdentifier = pNewKeyIdentifier;

    return TRUE;
}

static BOOL TestDeleteEnum(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN LPCSTR pszTestName
    )
{
    BOOL fResult;
    TEST_DELETE_ENUM_ARG TestArg;
    HCERTSTORE hStore = NULL;
    DWORD cKeyIdentifier;
    PCRYPT_HASH_BLOB pKeyIdentifier;

    memset(&TestArg, 0, sizeof(TestArg));
    TestArg.pszTestName = pszTestName;
    if (0 == _stricmp("DeleteWithoutCert", pszTestName)) {
        hStore = OpenMyStore(dwFlags, pwszComputerName);
        if (NULL == hStore)
            return FALSE;
        TestArg.hStore = hStore;
    }

    fResult = CryptEnumKeyIdentifierProperties(
        NULL,                   // pKeyIdentifier
        0,                      // dwPropId
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        &TestArg,
        TestDeleteEnumCallback
        );
    if (!fResult)
        PrintLastError("CryptEnumKeyIdentifierProperty");

    cKeyIdentifier = TestArg.cKeyIdentifier;
    pKeyIdentifier = TestArg.rgKeyIdentifier;
    printf("Deleting %d Key Identifiers\n", cKeyIdentifier);
    for ( ; cKeyIdentifier > 0; cKeyIdentifier--, pKeyIdentifier++) {
        if (!CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            0,                  // dwPropId
            dwFlags | CRYPT_KEYID_DELETE_FLAG,
            pwszComputerName,
            NULL,                   // pvReserved
            NULL                    // pvData
            ))
        PrintLastError("CryptSetKeyIdentifierProperty(Delete)");

        TestFree(pKeyIdentifier->pbData);
    }
    TestFree(TestArg.rgKeyIdentifier);


    if (hStore)
        CertCloseStore(hStore, 0);
    return fResult;
}

static BOOL TestGet(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN DWORD dwDisplayFlags
    )
{
    BOOL fResult;
    void *pvData = NULL;
    DWORD cbData;
    if (0 == dwPropId)
        return TestEnum(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            dwDisplayFlags
            );

    dwFlags |= CRYPT_KEYID_ALLOC_FLAG;
    fResult = CryptGetKeyIdentifierProperty(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,               // pvReserved,
        &pvData,
        &cbData
        );

    if (!fResult)
        PrintLastError("CryptGetKeyIdentifierProperty");
    else {
        DisplayProperty(pKeyIdentifier, dwPropId, pvData, cbData);
    }

    if (pvData && cbData) {
        BOOL fResult2;
        DWORD cbData2;

        dwFlags &= ~CRYPT_KEYID_ALLOC_FLAG;

        cbData2 = cbData;
        fResult2 = CryptGetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,               // pvReserved,
            NULL,               // pvData
            &cbData2
            );

        if (!fResult2)
            PrintLastError("CryptGetKeyIdentifierProperty");
        else if (cbData2 != cbData)
            printf("failed => wrong cbData for nonAlloc\n");

        cbData2 = cbData - 1;
        fResult2 = CryptGetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,               // pvReserved,
            pvData,
            &cbData2
            );
        if (fResult2)
            printf("failed => returned success for too small buffer\n");
        else {
            DWORD dwErr = GetLastError();
            if (ERROR_MORE_DATA != dwErr)
                printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
        }
        if (cbData2 != cbData)
            printf("failed => wrong size returned for small buffer\n");
    }

    if (pvData)
        LocalFree((HLOCAL) pvData);
    return fResult;
}

#define SHA1_HASH_LEN  20
#define MAX_KEY_ID_LEN SHA1_HASH_LEN
#define SHA1_CHAR_LEN  (SHA1_HASH_LEN * 2)

//+-------------------------------------------------------------------------
//  Converts the ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
static void StrToBytes(
    IN LPCSTR psz,
    OUT BYTE rgb[MAX_KEY_ID_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    char ch;

    while (cb < MAX_KEY_ID_LEN && (ch = *psz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (ch >= '0' && ch <= '9')
            b = ch - '0';
        else if (ch >= 'a' && ch <= 'f')
            b = 10 + ch - 'a';
        else if (ch >= 'A' && ch <= 'F')
            b = 10 + ch - 'A';
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = b << 4;
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = rgb[cb] | b;
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status;
    LONG lStatus;
    LPSTR pszTestName = NULL;
    LPSTR pszCertFilename = NULL;
    BOOL fPropSystemStore = FALSE;
    LPSTR pszPropStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BOOL fMachine = FALSE;
    LPWSTR pwszComputerName = NULL;
    DWORD dwDisplayFlags = 0;
    DWORD dwPropId = 0;
    DWORD dwFlags = 0;
    DWORD i;

    HCERTSTORE hPropStore = NULL;

    BYTE rgbKeyIdentifier[SHA1_HASH_LEN];
    DWORD cbKeyIdentifier;
    CRYPT_HASH_BLOB KeyIdentifier = { 0, NULL };

    while (--argc>0) {
        if (**++argv == '-')
        {
            {
                switch(argv[0][1])
                {
                case 'c':
                    pszCertFilename = argv[0]+2;
                    break;
                case 's':
                    pszPropStore = argv[0]+2;
                    fPropSystemStore = TRUE;
                    break;
                case 'S':
                    pszPropStore = argv[0]+2;
                    fPropSystemStore = FALSE;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'p':
                    dwPropId = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'f':
                    dwFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'V':
                    fVerify = TRUE;
                    break;
                case 'M':
                    fMachine = TRUE;
                    if (argv[0][2])
                        pwszComputerName = AllocAndSzToWsz(argv[0]+2);
                    break;
                case 'k':
                    StrToBytes(
                        argv[0]+2,
                        rgbKeyIdentifier,
                        &cbKeyIdentifier
                        );
                    if (0 == cbKeyIdentifier) {
                        printf("No Hash digits\n");
                        goto BadUsage;
                    }
                    KeyIdentifier.pbData = rgbKeyIdentifier;
                    KeyIdentifier.cbData = cbKeyIdentifier;
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszTestName) {
                printf("Multiple TestNames:: %s %s\n", pszTestName, argv[0]);
                goto BadUsage;
            }
            pszTestName = argv[0];
        }
    }

    if (pszTestName == NULL) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (pszPropStore) {
        if (NULL == (hPropStore = OpenSystemStoreOrFile(
                fPropSystemStore,
                pszPropStore,
                0                   // dwFlags
                )))
            goto BadUsage;
    }

    if (pszCertFilename) {
        if (KeyIdentifier.cbData) {
            printf("-c option invalid with -k option\n");
            goto BadUsage;
        }
        if (NULL == (pCert = ReadCert(pszCertFilename)))
            goto ErrorReturn;

        if (hPropStore) {
            PCCERT_CONTEXT pPropCert = NULL;

            // Try to find the certificate in the specified store
            pPropCert = CertFindCertificateInStore(
                hPropStore,
                0,          // dwCertEncodingType
                0,          // dwFindFlags
                CERT_FIND_EXISTING,
                pCert,
                NULL        // pPrevCertContext
                );
            if (NULL == pPropCert) {
                printf("Failed, unable to find certificate in store\n");
                goto BadUsage;
            }

            CertFreeCertificateContext(pCert);
            pCert = pPropCert;
        }

        cbKeyIdentifier = MAX_KEY_ID_LEN;
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                rgbKeyIdentifier,
                &cbKeyIdentifier
                )) {
            KeyIdentifier.pbData = rgbKeyIdentifier;
            KeyIdentifier.cbData = cbKeyIdentifier;
        } else {
            PrintLastError(
                "CertGetCertificateContextProperty(KEY_IDENTIFIER)");
            goto ErrorReturn;
        }
    }

    if (fMachine)
        dwFlags |= CRYPT_KEYID_MACHINE_FLAG;

    if (0 == _stricmp("Set", pszTestName)) {
        if (NULL == pCert) {
            printf("Set: requires -c option\n");
            goto BadUsage;
        }

        if (!TestSet(
                &KeyIdentifier,
                pCert,
                dwPropId,
                dwFlags,
                pwszComputerName
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Get", pszTestName)) {
        if (0 == KeyIdentifier.cbData) {
            printf("Get: requires -c or -k option\n");
            goto BadUsage;
        }

        if (!TestGet(
                &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName,
                dwDisplayFlags
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Delete", pszTestName)) {
        if (0 == KeyIdentifier.cbData) {
            printf("Delete: requires -c or -k option\n");
            goto BadUsage;
        }

        if (!TestDelete(
                &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Enum", pszTestName)) {
        if (!TestEnum(
                (0 == KeyIdentifier.cbData) ? NULL : &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName,
                dwDisplayFlags
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("DeleteAll", pszTestName) ||
            0 == _stricmp("DeleteWithoutCert", pszTestName)) {
        if (!TestDeleteEnum(
                dwFlags,
                pwszComputerName,
                pszTestName
                ))
            goto ErrorReturn;
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    CertCloseStore(hPropStore, 0);
    CertFreeCertificateContext(pCert);
    TestFree(pwszComputerName);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\toidfunc\toidfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       toidfunc.cpp
//
//  Contents:   OID Function Tests: Register, Unregister or Enum
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    24-Nov-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: toidfunc [options] <TestName>\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -o<OID string>            - For example, -o1.2.3.4\n");
    printf("  -o%s                      - Default Dlls\n", CRYPT_DEFAULT_OID);
    printf("  -O<OID number>            - For example, -O1000\n");
    printf("  -f<FuncName>              - For example, -fCryptDllEncodeObject\n");
    printf("  -F<FuncName Override>     - For example, -FMyEncodeObject\n");
    printf("  -e<EncodeType Number>     - For example, -e1 (X509_ASN)\n");
    printf("  -i<index number>          - Default Dlls index\n");
    printf("  -d<Dll filename>          - For example, -dsetx509.dll\n");
    printf("  -G<Group number>          - For example, -G7\n");
    printf("  -v[RegType] <name> <data> - Registry value\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Enum          options: [-o|-O] [-f] [-e], defaults to any\n");
    printf("  Register      options: -o|-O -f [-F] [-e] [-d] [-v] [-v] ...\n");
    printf("  Unregister    options: -o|-O -f [-e]\n");
    printf("  EnumInfo      options: [-G], defaults to all groups\n");
    printf("\n");
    printf("  Register      options: -o%s -f [-i] -d [-v] [-v] ...\n",
        CRYPT_DEFAULT_OID);
    printf("  Unregister    options: -o%s -f -d\n", CRYPT_DEFAULT_OID);
    printf("\n");
    printf("Defaults:\n");
    printf("  -e%d (X509_ASN_ENCODING)\n", X509_ASN_ENCODING);
    printf("  -i0x%x\n", CRYPT_REGISTER_LAST_INDEX);
    printf("\n");
    printf("RegTypes: REG_SZ | REG_EXPAND_SZ | REG_DWORD\n");
    printf("\n");
    printf("OID number range: 1 .. 0xFFFF\n");
    printf("\n");
    printf("-v option: the next two arguments contain Registry Value name and data\n");
    printf("  For example, -vREG_SZ FuncName MyDllDecodeObject\n");
    printf("\n");
}

static DWORD ToRegType(
    IN LPCSTR pszOption,
    IN LPCSTR pszRegType
    )
{
    DWORD RegType;
    if (NULL == pszRegType || '\0' == *pszRegType ||
            0 == _stricmp("REG_SZ", pszRegType))
        RegType = REG_SZ;
    else if (0 == _stricmp("REG_EXPAND_SZ", pszRegType))
        RegType = REG_EXPAND_SZ;
    else if (0 == _stricmp("REG_DWORD", pszRegType))
        RegType = REG_DWORD;
    else if (0 == _stricmp("REG_MULTI_SZ", pszRegType))
        RegType = REG_MULTI_SZ;
    else {
        printf("Option (%s) : has an invalid RegType: %s\n",
            pszOption, pszRegType);
        RegType = REG_NONE;
    }
    return RegType;
}

static LPCSTR FromRegType(
    IN DWORD dwType
    )
{
    LPCSTR pszType;
    switch (dwType) {
        case REG_DWORD:
            pszType = "REG_DWORD";
            break;
        case REG_SZ:
            pszType = "REG_SZ";
            break;
        case REG_EXPAND_SZ:
            pszType = "REG_EXPAND_SZ";
            break;
        case REG_MULTI_SZ:
            pszType = "REG_MULTI_SZ";
            break;
        case REG_BINARY:
            pszType = "REG_BINARY";
            break;
        default:
            pszType = "REG_????";
    }
    return pszType;
}

#define ENUM_ARG "EnumCallback arg"

static BOOL WINAPI EnumCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    if (NULL == pvArg || 0 != strcmp(ENUM_ARG, (LPCSTR) pvArg)) {
        fResult = FALSE;
        printf("CryptEnumOIDFunction failed: invalid pvArg passed to callback\n");
    }

    printf("  EncodingType %d\\%s\\%s\n", dwEncodingType, pszFuncName, pszOID);
    for (DWORD i = 0; i < cValue; i++) {
        DWORD dwType = rgdwValueType[i];
        if (REG_MULTI_SZ == dwType) {
            DWORD j;
            DWORD cch;
            LPWSTR pwszData = (LPWSTR) rgpbValueData[i];
            for (j = 0; 0 != (cch = wcslen(pwszData));
                                                j++, pwszData += cch + 1) {
                printf("    %S[%d] : %S\n", rgpwszValueName[i], j, pwszData);
            }
        } else if (REG_BINARY == dwType) {
            printf("    %S (REG_BINARY) :\n", rgpwszValueName[i]);
            PrintBytes("     ", (BYTE *) rgpbValueData[i], rgcbValueData[i]);
        } else {
            printf("    %S : ", rgpwszValueName[i]);
            if (rgpbValueData[i] && rgcbValueData[i]) {
                switch (dwType) {
                case REG_DWORD:
                    {
                        DWORD dwData = *((DWORD *) rgpbValueData[i]);
                        printf("0x%x (%d)", dwData, dwData);
                    }
                    break;
                case REG_SZ:
                case REG_EXPAND_SZ:
                    printf("%S", rgpbValueData[i]);
                    break;
                default:
                    printf("UNEXPECTED VALUE TYPE");
                }
                if (REG_SZ != dwType)
                    printf(" (%s)", FromRegType(dwType));
            } else
                printf("EMPTY");
            printf("\n");
        }
    }
    return fResult;
}

static BOOL WINAPI EnumInfoCallback(
    IN PCCRYPT_OID_INFO pInfo,
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    DWORD cExtra;
    DWORD *pdwExtra;
    DWORD i;

    if (NULL == pvArg || 0 != strcmp(ENUM_ARG, (LPCSTR) pvArg)) {
        fResult = FALSE;
        printf("CryptEnumOIDInfo failed: invalid pvArg passed to callback\n");
    }

    printf("  Group: %d  OID: %s Name: %S  Algid: 0x%x",
        pInfo->dwGroupId, pInfo->pszOID, pInfo->pwszName, pInfo->Algid);

    cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
    pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

    for (i = 0; i < cExtra; i++) 
        printf(" Extra[%d]: %d (0x%x)", i, pdwExtra[i], pdwExtra[i]);

    printf("\n");
    return fResult;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;
    LPSTR pszTestName = NULL;
    LPSTR pszOID = NULL;
    LPSTR pszFuncName = NULL;
    LPSTR pszOverrideFuncName = NULL;
    DWORD dwEncodingType = X509_ASN_ENCODING;
    BOOL fEncodingType = FALSE;
    LPWSTR pwszDllFile = NULL;
    DWORD dwDllIndex = CRYPT_REGISTER_LAST_INDEX;

    DWORD dwGroupId = 0;

#define MAX_VALUE_COUNT 16
    DWORD cValue = 0;
    DWORD rgdwValueType[MAX_VALUE_COUNT];
    LPWSTR rgpwszValueName[MAX_VALUE_COUNT];
    BYTE *rgpbValueData[MAX_VALUE_COUNT];
    DWORD rgcbValueData[MAX_VALUE_COUNT];
    DWORD rgdwValueData[MAX_VALUE_COUNT];

    DWORD RegType;
    DWORD i;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'o':
                pszOID = argv[0]+2;
                break;
            case 'O':
                {
                    DWORD dwOID = strtoul(argv[0]+2, NULL, 0);
                    if (dwOID == 0 || dwOID > 0xFFFF) {
                        printf(
                            "Option (-O) : OID constant (%d,0x%x) out of range\n",
                                dwOID, dwOID);
                        goto BadUsage;
                    }
                    pszOID = (LPSTR)(ULONG_PTR) dwOID;
                }
                break;
            case 'f':
                pszFuncName = argv[0]+2;
                break;
            case 'F':
                pszOverrideFuncName = argv[0]+2;
                break;
            case 'e':
                dwEncodingType = strtoul(argv[0]+2, NULL, 0);
                fEncodingType = TRUE;
                break;
            case 'i':
                dwDllIndex = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'd':
                pwszDllFile = AllocAndSzToWsz(argv[0]+2);
                break;
            case 'v':
                if (argc < 3 || argv[1][0] == '-' || argv[2][0] == '-') {
                    printf("Option (-v) : missing name and data arguments\n");
                    goto BadUsage;
                }
                if (cValue >= MAX_VALUE_COUNT) {
                    printf("Exceeded maximum value count of %d\n",
                        MAX_VALUE_COUNT);
                    goto BadUsage;
                }
                if (REG_NONE == (RegType = ToRegType("-v", argv[0] + 2)))
                    goto BadUsage;
                rgdwValueType[cValue] = RegType;

                rgpwszValueName[cValue] = AllocAndSzToWsz(argv[1]);
                if (REG_DWORD == RegType) {
                    rgdwValueData[cValue] = strtoul(argv[2], NULL, 0);
                    rgpbValueData[cValue] =
                        (BYTE *) &rgdwValueData[cValue];
                    rgcbValueData[cValue] = sizeof(DWORD);
                } else {
                    LPWSTR pwsz = AllocAndSzToWsz(argv[2]);
                    if (pwsz) {
                        rgpbValueData[cValue] = (BYTE *) pwsz;
                        rgcbValueData[cValue] =
                            (wcslen(pwsz) + 1) * sizeof(WCHAR);
                    } else {
                        rgpbValueData[cValue] = NULL;
                        rgcbValueData[cValue] = 0;
                    }
                }
                cValue++;
                argc -= 2;
                argv += 2;
                break;
            case 'G':
                dwGroupId = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszTestName) {
                printf("Multiple TestNames:: %s %s\n", pszTestName, argv[0]);
                goto BadUsage;
            }
            pszTestName = argv[0];
        }
    }

    if (pszTestName == NULL) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (0 == _stricmp("Register", pszTestName)) {
        if (pszOID == NULL) {
            printf("Register Test:: missing OID option (-o) or (-O)\n");
            goto BadUsage;
        }
        if (pszFuncName == NULL) {
            printf("Register Test:: missing function name option (-f)\n");
            goto BadUsage;
        }

        if ((DWORD_PTR) pszOID > 0xFFFF &&
                0 == _stricmp(CRYPT_DEFAULT_OID, pszOID)) {
            if (pwszDllFile == NULL) {
                printf("Register Test:: missing dll option (-d)\n");
                goto BadUsage;
            }

            if (!CryptRegisterDefaultOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    dwDllIndex,
                    pwszDllFile
                    )) {
                PrintLastError("CryptRegisterDefaultOIDFunction");
                goto ErrorReturn;
            }
        } else {
            if (!CryptRegisterOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pszOID,
                    pwszDllFile,
                    pszOverrideFuncName
                    )) {
                PrintLastError("CryptRegisterOIDFunction");
                goto ErrorReturn;
            }
        }

        for (i = 0; i < cValue; i++) {
            if (!CryptSetOIDFunctionValue(
                    dwEncodingType,
                    pszFuncName,
                    pszOID,
                    rgpwszValueName[i],
                    rgdwValueType[i],
                    rgpbValueData[i],
                    rgcbValueData[i]
                    )) {
                PrintLastError("CryptSetOIDFunctionValue");
                goto ErrorReturn;
            }
        }
        printf("Successful Register\n");

    } else if (0 == _stricmp("Unregister", pszTestName)) {
        if (pszOID == NULL) {
            printf("Unregister test:: missing OID option (-o) or (-O)\n");
            goto BadUsage;
        }
        if (pszFuncName == NULL) {
            printf("Unregister test:: missing function name option (-f)\n");
            goto BadUsage;
        }

        if ((DWORD_PTR) pszOID > 0xFFFF &&
                0 == _stricmp(CRYPT_DEFAULT_OID, pszOID)) {
            if (pwszDllFile == NULL) {
                printf("Unregister Test:: missing dll option (-d)\n");
                goto BadUsage;
            }

            if (!CryptUnregisterDefaultOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pwszDllFile
                    )) {
                PrintLastError("CryptUnregisterDefaultOIDFunction");
                goto ErrorReturn;
            }
        } else {
            if (!CryptUnregisterOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pszOID
                    )) {
                PrintLastError("CryptUnregisterOIDFunction");
                goto ErrorReturn;
            }
        }
        printf("Successful Unregister\n");

    } else if (0 == _stricmp("Enum", pszTestName)) {
        if (!CryptEnumOIDFunction(
                fEncodingType ? dwEncodingType : CRYPT_MATCH_ANY_ENCODING_TYPE,
                pszFuncName,
                pszOID,
                0,              // dwFlags
                ENUM_ARG,
                EnumCallback
                )) {
            PrintLastError("CryptEnumOIDFunction");
            goto ErrorReturn;
        } else
            printf("Successful Enum\n");
    } else if (0 == _stricmp("EnumInfo", pszTestName)) {
        if (!CryptEnumOIDInfo(
                dwGroupId,
                0,              // dwFlags
                ENUM_ARG,
                EnumInfoCallback
                )) {
            PrintLastError("CryptEnumOIDInfo");
            goto ErrorReturn;
        } else
            printf("Successful EnumInfo\n");
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    status = 0;

CommonReturn:
    if (pwszDllFile)
        TestFree(pwszDllFile);
    while(cValue--) {
        if (rgdwValueType[cValue] != REG_DWORD && rgpbValueData[cValue])
            TestFree(rgpbValueData[cValue]);
        if (rgpwszValueName[cValue])
            TestFree(rgpwszValueName[cValue]);
    }
    return status;

BadUsage:
    Usage();
    status = 0;
    goto CommonReturn;

ErrorReturn:
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tprov\tprov.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tprov.cpp
//
//  Contents:   Get provider information
//
//
//  Functions:  main
//
//  History:    10-Jun-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void DisplayProvContainers(
    IN HCRYPTPROV hProv,
    IN LPWSTR pwszProvName,
    IN DWORD dwProvType,
    IN DWORD dwProvFlags
    )
{

    LPSTR pszContainerName = NULL;
    DWORD cchContainerName;
    DWORD cchMaxContainerName;
    LPWSTR pwszContainerName = NULL;
    DWORD dwEnumFlags;

    // Get maximum container name length
    dwEnumFlags = CRYPT_FIRST;
    cchMaxContainerName = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMCONTAINERS,
            NULL,           // pbData
            &cchMaxContainerName,
            dwEnumFlags
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_MORE_DATA != dwErr) {
            if (ERROR_FILE_NOT_FOUND == dwErr || ERROR_NO_MORE_ITEMS == dwErr)
                printf("    <No Containers>\n");
            else if (ERROR_INVALID_PARAMETER == dwErr)
                printf("    <Invalid Parameter>\n");
            else
                PrintLastError("CryptGetProvParam(PP_ENUMCONTAINERS)");
            goto ErrorReturn;
        }
    }

    if (0 == cchMaxContainerName) {
        printf("   MaxContainerName length = 0\n");
        goto ErrorReturn;
    }


    if (NULL == (pszContainerName = (LPSTR) TestAlloc(
            cchMaxContainerName + 1)))
        goto ErrorReturn;

    while (TRUE) {
        HCRYPTPROV hContainerProv;

        cchContainerName = cchMaxContainerName;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMCONTAINERS,
                (BYTE *) pszContainerName,
                &cchContainerName,
                dwEnumFlags
                )) {
            DWORD dwEnumErr = GetLastError();
            if (!(ERROR_NO_MORE_ITEMS == dwEnumErr ||
                    ERROR_FILE_NOT_FOUND == dwEnumErr)) {
                PrintLastError("CryptGetProvParam(PP_ENUMCONTAINERS)");
            }
            break;
        }
        dwEnumFlags = 0;        // CRYPT_NEXT

        if (NULL == (pwszContainerName = MkWStr(pszContainerName))) {
            PrintLastError("MkWStr");
            goto ErrorReturn;
        }

        printf("   %S\n", pwszContainerName);

        if (!CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                pwszProvName,
                dwProvType,
                dwProvFlags
                )) {
            DWORD dwErr = GetLastError();
            if (PROV_RSA_FULL == dwProvType &&
                    0 == _wcsicmp(pwszProvName, MS_DEF_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
            else if (PROV_DSS == dwProvType && 
		    0 == _wcsicmp(pwszProvName, MS_DEF_DSS_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_DSS_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
	    else if (PROV_DSS_DH == dwProvType && 
		    0 == _wcsicmp(pwszProvName, MS_DEF_DSS_DH_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_DSS_DH_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
            else
                PrintLastError("CryptAcquireContextU(Container)");
        } else
            CryptReleaseContext(hContainerProv, 0);
        FreeWStr(pwszContainerName);
        pwszContainerName = NULL;
    }


ErrorReturn:
    TestFree(pszContainerName);
    FreeWStr(pwszContainerName);
}

static void DisplayProvAlgidEx(HCRYPTPROV hProv)
{
    DWORD i;
    CHAR *pszAlgType = NULL;
    PROV_ENUMALGS_EX Data;
    DWORD cbData;
    DWORD dwFlags;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {

        cbData = sizeof(Data);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &Data,
                &cbData,
                dwFlags
                )) {
            DWORD dwErr = GetLastError();
            if (ERROR_INVALID_PARAMETER == dwErr)
                printf("    <Invalid Parameter>\n");
            else if (NTE_BAD_TYPE == dwErr)
                printf("    <Bad Parameter Type>\n");
            else if (ERROR_NO_MORE_ITEMS != dwErr)
                PrintLastError("CryptGetProvParam(PP_ENUMALGS_EX)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(Data.aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, %-4d - %-4d, Type:%s\n",
            Data.aiAlgid, Data.dwDefaultLen, Data.dwMinLen, Data.dwMaxLen,
            pszAlgType
            );

        printf("  Name: %s  LongName: %s Protocols: 0x%x\n",
            Data.szName, Data.szLongName, Data.dwProtocols
            );
    }

    printf("\n");
}

static void DisplayProvAlgid(HCRYPTPROV hProv)
{
    DWORD i;
    CHAR *pszAlgType = NULL;
    PROV_ENUMALGS Data;
    DWORD cbData;
    DWORD dwFlags;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {

        cbData = sizeof(Data);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                (BYTE *) &Data,
                &cbData,
                dwFlags
                )) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(Data.aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            Data.aiAlgid, Data.dwBitLen, pszAlgType, Data.dwNameLen,
            Data.szName
        );
    }

    printf("\n");
}

#if 0
static void DisplayProvAlgid(HCRYPTPROV hProv)
{
    BYTE *ptr = NULL;
    DWORD i;
    ALG_ID aiAlgid;
    DWORD dwBits;
    DWORD dwNameLen;
    CHAR szName[100];         // Often allocated dynamically
    CHAR *pszAlgType = NULL;

    BYTE *pbData = NULL;
    DWORD cbMaxData;
    DWORD cbData;
    DWORD dwFlags;

    // Get maximum length of provider algorithm parameter data
    cbMaxData = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMALGS,
            NULL,           // pbData
            &cbMaxData,
            CRYPT_FIRST     // dwFlags
            ) || 0 == cbMaxData) {
        PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
        goto ErrorReturn;
    }
    if (NULL == (pbData = (BYTE *) TestAlloc(cbMaxData)))
        goto ErrorReturn;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {
        ALG_ID aiProv;

        cbData = cbMaxData;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                pbData,
                &cbData,
                dwFlags
                )) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Extract algorithm information from the 'pbData' buffer.
        ptr = pbData;
        aiAlgid = *(ALG_ID *)ptr;
        ptr += sizeof(ALG_ID);
        dwBits = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        dwNameLen = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        strncpy(szName, (LPSTR) ptr, dwNameLen);

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            aiAlgid, dwBits, pszAlgType, dwNameLen, szName
        );
    }

ErrorReturn:
    TestFree(pbData);
}
#endif


int _cdecl main(int argc, char * argv[]) 
{
    DWORD dwProvIndex;
    printf("command line: %s\n", GetCommandLine());

    for (dwProvIndex = 0; TRUE; dwProvIndex++) {
        BOOL fResult;
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptEnumProvidersU");
            break;
        }
        if (NULL == (pwszProvName = (LPWSTR) TestAlloc(
                (cbProvName + 1) * sizeof(WCHAR))))
            break;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            TestFree(pwszProvName);
            PrintLastError("CryptEnumProvidersU");
            break;
        }

        printf("\n============   [%d]   ============\n", dwProvIndex);
        printf("Provider:: Type(%d) %S\n\n", dwProvType, pwszProvName);

        fResult = FALSE;
        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            PrintLastError("CryptAcquireContextU");
        } else {
            DisplayProvAlgidEx(hProv);
            DisplayProvAlgid(hProv);
            printf("\nCurrentUser Containers::\n");
            DisplayProvContainers(hProv, pwszProvName, dwProvType, 0);

            CryptReleaseContext(hProv, 0);
        }

        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET // dwFlags
                )) {
            DWORD dwErr = GetLastError();
            
            if (NTE_BAD_FLAGS == dwErr) {
                printf("CryptAcquireContextU(CRYPT_MACHINE_KEYSET) returned NTE_BAD_FLAGS\n");
            }
            else {
                PrintLastError("CryptAcquireContextU(CRYPT_MACHINE_KEYSET)");
            }
        } else {
            printf("\nLocalMachine Containers::\n");
            DisplayProvContainers(hProv, pwszProvName, dwProvType,
                CRYPT_MACHINE_KEYSET);
            CryptReleaseContext(hProv, 0);
        }

        TestFree(pwszProvName);
    }

    printf("Done.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tpvkload\tpvkload.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvkload.cpp
//
//  Contents:   Private Key Load Test
//
//              See Usage() for list of load options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//              31-May-96   helles  Removed check for a particular error code,
//                                  NTE_BAD_KEYSET, since this can get
//                                  overwritten due to known problem with
//                                  the msvcr40d.dll on Win95.
//              07-Jun-96   HelleS  Added printing the command line
//                                  and Failed or Passed at the end.
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "pvkhlpr.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: tpvkload [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -F                    - Force load if keys already exist\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -m                    - test memory version of API\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fMem = FALSE;
    BOOL fForce = FALSE;
    BOOL fExportable = FALSE;
    BYTE *pbKey = NULL;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
    DWORD dwKeySpec;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'F':
                fForce = TRUE;
                break;
            case 'E':
                fExportable = TRUE;
                break;
            case 'm':
                fMem = TRUE;
                break;
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());
    
    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("missing KeyType\n");
        goto BadUsage;
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }

    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            0               // dwFlags
            )) {

//  Removed check for a particular error code,
//  NTE_BAD_KEYSET, since this can get overwritten due to known problem 
//  with the msvcr40d.dll on Win95. 
//        if (GetLastError() != NTE_BAD_KEYSET) {
//            PrintLastError("CryptAcquireContext");
//            goto ErrorReturn;
//        }

        hProv = 0;
        if (!CryptAcquireContext(
                &hProv,
                pszContainer,
                NULL,           // pszProvider
                dwProvType,
                CRYPT_NEWKEYSET
                ) || hProv == 0) {
            PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
            goto ErrorReturn;
        }
    } else {
        HCRYPTKEY hKey = 0;
        if (!CryptGetUserKey(hProv, KeyTypes[KeyIdx].dwKeySpec, &hKey)) {
            if (GetLastError() != NTE_NO_KEY) {
                PrintLastError("CryptGetUserKey");
                goto ErrorReturn;
            }
        } else {
            CryptDestroyKey(hKey);
            if (!fForce) {
                printf("Private key already exists, use -F to delete private keys\n");
                goto ErrorReturn;
            }

            // Delete the existing keys
            CryptReleaseContext(hProv, 0);
            printf("Deleting existing private keys\n");

            // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
            // and must not be released.
            if (!CryptAcquireContext(
                    &hProv,
                    pszContainer,
                    NULL,           // pszProvider
                    dwProvType,
                    CRYPT_DELETEKEYSET
                    ))
                PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");

            // Create new keyset
            hProv = 0;
            if (!CryptAcquireContext(
                    &hProv,
                    pszContainer,
                    NULL,           // pszProvider
                    dwProvType,
                    CRYPT_NEWKEYSET
                    ) || hProv == 0) {
                PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
                goto ErrorReturn;
            }
        }
    }

    dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
    if (fMem) {
        DWORD cbKey;
        DWORD cbRead;

        cbKey = GetFileSize(hFile, NULL);
        if (cbKey == 0) {
            printf( "empty file %s\n", pszFilename);
            goto ErrorReturn;
        }
        if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
            goto ErrorReturn;

        if (!ReadFile(hFile, pbKey, cbKey, &cbRead, NULL) ||
                (cbRead != cbKey)) {
            printf( "can't read %s\n", pszFilename);
            goto ErrorReturn;
        }
        if (!PvkPrivateKeyLoadFromMemory(
                hProv,
                pbKey,
                cbKey,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                fExportable ? CRYPT_EXPORTABLE : 0, // dwFlags
                &dwKeySpec
                )) {
            PrintLastError("PrivateKeyLoadFromMemory");
            goto ErrorReturn;
        }
    } else {
        if (!PvkPrivateKeyLoad(
                hProv,
                hFile,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                fExportable ? CRYPT_EXPORTABLE : 0, // dwFlags
                &dwKeySpec
                )) {
            PrintLastError("PrivateKeyLoad");
            goto ErrorReturn;
        }
    }

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tpvkdel\tpvkdel.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvksave.cpp
//
//  Contents:   Private Key Delete Test
//
//              See Usage() for list of delete options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    int i;

    printf("Usage: tpvkdel [options]\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider\n");
    printf("  -h                    - This message\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    DWORD dwProvType = PROV_RSA_FULL;
    LPSTR pszContainer = NULL;
    BOOL fDelete = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            printf("Too many arguments\n");
            goto BadUsage;
        }
    }

    if (!fDelete) 
        goto BadUsage;

    printf("command line: %s\n", GetCommandLine());

    printf("Deleting existing private keys\n");

    // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
    // and must not be released.
    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            CRYPT_DELETEKEYSET
            ))
    {        
        PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
    	ReturnStatus = -1;
	}
	else
    	ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\trevfunc\trevfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       trevfunc.cpp
//
//  Contents:   CertVerifyRevocation Function Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    21-Dec-96   philh   created
//--------------------------------------------------------------------------


#define CERT_REVOCATION_PARA_HAS_EXTRA_FIELDS   1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: trevfunc [options] <FileName1> <FileName2> ...\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -r<RevocationType Number> - For example, -r1 (Certificate)\n");
    printf("  -e<Expected Error>        - For example, -e0x0\n");
    printf("  -i<Expected Index>        - For example, -i0\n");
    printf("  -s<SystemStore>           - Additional System Store\n");
    printf("  -S<FileSystemStore>       - Additional File System Store\n");
    printf("  -L<Loop Count>            - Defaults to 1 iteration\n");
    printf("  -t<Number>                - Url timeout (milliseconds)\n");
    printf("  -T<Number>                - Accumulative Url timeout (milliseconds)\n");
    printf("  -f<Number>                - Freshness (seconds)\n");
    printf("\n");
    printf("Defaults:\n");
    printf("  -r%d (Certificate)\n", CERT_CONTEXT_REVOCATION_TYPE);
    printf("  -e0 (All files successfully verified)\n");
    printf("\n");
}



int _cdecl main(int argc, char * argv[])
{
    int status;
    BOOL fResult;

    DWORD dwError = 0;
    DWORD dwIndex = 0;
    DWORD dwRevType = CERT_CONTEXT_REVOCATION_TYPE;

#define MAX_CONTEXT_COUNT 16
    DWORD cFileName = 0;
    LPSTR rgpszFileName[MAX_CONTEXT_COUNT];
    DWORD cContext = 0;
    PVOID rgpvContext[MAX_CONTEXT_COUNT];

    CERT_REVOCATION_STATUS RevStatus;
    CERT_REVOCATION_PARA RevPara;
    PCERT_REVOCATION_PARA pRevPara = NULL;
    HCERTSTORE hAdditionalStore = NULL;

    DWORD i;
    DWORD dwLoopCnt = 1;

    DWORD dwUrlRetrievalTimeout = 0;
    BOOL fCheckFreshnessTime = FALSE;
    DWORD dwFreshnessTime;
    DWORD dwFlags = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'r':
                dwRevType = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'e':
                dwError = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'i':
                dwIndex = strtoul(argv[0]+2, NULL, 0);
                break;
            case 's':
            case 'S':
                if (NULL == (hAdditionalStore =
                        OpenSystemStoreOrFile(
                            argv[0][1] == 's',  // fSystemStore
                            argv[0]+2,
                            0                   // dwFlags
                            )))
                    goto BadUsage;
                break;
            case 'L':
                dwLoopCnt = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'T':
                dwFlags |= CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;
            case 't':
                dwUrlRetrievalTimeout = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                fCheckFreshnessTime = TRUE;
                dwFreshnessTime = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (cFileName >= MAX_CONTEXT_COUNT) {
                printf("Exceeded maximum FileName count of %d\n",
                        MAX_CONTEXT_COUNT);
                goto BadUsage;
            }
            rgpszFileName[cFileName++] = argv[0];
        }
    }

    if (cFileName == 0) {
        printf("Missing FileNames\n");
        goto BadUsage;
    }

    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE) {
        printf("Currently only support revocation type (-r%d) (certificates)\n",
            CERT_CONTEXT_REVOCATION_TYPE);
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    for (i = 0; i < cFileName; i++) {
        BYTE *pbDER;
        DWORD cbDER;
        PCCERT_CONTEXT pCert;

        if (!ReadDERFromFile(
                rgpszFileName[i],
                &pbDER,
                &cbDER)) goto ErrorReturn;
        pCert = CertCreateCertificateContext(dwCertEncodingType, pbDER, cbDER);
        TestFree(pbDER);
        if (pCert == NULL) {
            printf("Unable to create certificate context for: %s\n",
                rgpszFileName[i]);
            PrintLastError("CertCreateCertificateContext");
            goto ErrorReturn;
        }
        rgpvContext[cContext++] = (void *) pCert;
    }

    memset(&RevPara, 0, sizeof(RevPara));
    RevPara.cbSize = sizeof(RevPara);

    if ( hAdditionalStore != NULL )
    {
        RevPara.cCertStore = 1;
        RevPara.rgCertStore = &hAdditionalStore;
        RevPara.hCrlStore = hAdditionalStore;
        pRevPara = &RevPara;
    }

    if (dwUrlRetrievalTimeout  || fCheckFreshnessTime) {
        RevPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;
        RevPara.fCheckFreshnessTime = fCheckFreshnessTime;
        RevPara.dwFreshnessTime = dwFreshnessTime;
        pRevPara = &RevPara;
    }

  while (dwLoopCnt--)
  {
    memset(&RevStatus, 0, sizeof(RevStatus));
    RevStatus.cbSize = sizeof(RevStatus);

    fResult = CertVerifyRevocation(
        dwCertEncodingType | dwMsgEncodingType,
        dwRevType,
        cContext,
        rgpvContext,
        dwFlags,
        pRevPara,               // pvReserved
        &RevStatus);

    if (fResult) {
        if (0 == dwError) {
            printf("CertVerifyRevocation:: verified all files\n");
            if (RevStatus.fHasFreshnessTime)
                printf("FreshnessTime: %d\n", RevStatus.dwFreshnessTime);
        } else {
            printf("Failed, CertVerifyRevocation returned Success, not the expected dwError: 0x%x (%d)\n",
                dwError, dwError);
            if (dwLoopCnt == 0)
                goto ErrorReturn;
        }
    } else {
        printf("CertVerifyRevocation:: dwIndex: %d dwError: 0x%x (%d), dwReason: %d\n",
            RevStatus.dwIndex, RevStatus.dwError, RevStatus.dwError,
            RevStatus.dwReason);
        if (RevStatus.fHasFreshnessTime)
            printf("FreshnessTime: %d\n", RevStatus.dwFreshnessTime);
        if (dwError != RevStatus.dwError || dwIndex != RevStatus.dwIndex) {
            printf("Failed, CertVerifyRevocation didn't return the expected dwIndex: %d or dwError: 0x%x (%d)\n",
                dwIndex, dwError, dwError);
            if (dwLoopCnt == 0)
                goto ErrorReturn;
        }
    }
  }

    printf("Passed\n");
    status = 0;

CommonReturn:
    while (cContext--)
        CertFreeCertificateContext((PCCERT_CONTEXT) rgpvContext[cContext]);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);

    return status;

BadUsage:
    Usage();
    status = 0;
    goto CommonReturn;

ErrorReturn:
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tpvksave\tpvksave.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvksave.cpp
//
//  Contents:   Private Key Save Test
//
//              See Usage() for list of save options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "pvkhlpr.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: tpvksave [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider after saving\n");
    printf("  -m                    - Test memory version of API\n");
	printf("  -n                    - Use machine key\n");
	printf("  -3                    - Export as VER3 blob\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fDelete = FALSE;
    BOOL fMem = FALSE;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    BYTE *pbKey = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
	DWORD dwFlags = 0;
    DWORD dwSaveFlags = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'd':
                fDelete = TRUE;
                break;
            case 'm':
                fMem = TRUE;
                break;
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
			case 'n':
				dwFlags = CRYPT_MACHINE_KEYSET;
				break;
			case '3':
				dwSaveFlags |= CRYPT_BLOB_VER3;
				break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }


    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("missing KeyType\n");
        goto BadUsage;
    }

    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            dwFlags        // dwFlags
            )) {
        PrintLastError("CryptAcquireContext");
        goto ErrorReturn;
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }

    if (fMem) {
        DWORD cbKey;
        DWORD cbWritten;

        cbKey = 0;
        PvkPrivateKeySaveToMemory(
                hProv,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags,
                NULL,                           // pbKey
                &cbKey
                );
        if (cbKey == 0) {
            PrintLastError("PrivateKeySaveToMemory(cbKey == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
            goto ErrorReturn;
        if (!PvkPrivateKeySaveToMemory(
                hProv,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags,
                pbKey,
                &cbKey
                )) {
            PrintLastError("PrivateKeySaveToMemory");
            goto ErrorReturn;
        }

        if (!WriteFile(hFile, pbKey, cbKey, &cbWritten, NULL)) {
            PrintLastError("WriteFile");
            goto ErrorReturn;
        }
    } else {
        if (!PvkPrivateKeySave(
                hProv,
                hFile,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags
                )) {
            PrintLastError("PrivateKeySave");
            goto ErrorReturn;
        }
    }

    if (fDelete) {
        // Delete the existing keys
        CryptReleaseContext(hProv, 0);
        printf("Deleting existing private keys\n");

        // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
        // and must not be released.
        if (!CryptAcquireContext(
                &hProv,
                pszContainer,
                NULL,           // pszProvider
                dwProvType,
                CRYPT_DELETEKEYSET
                ))
            PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
        hProv = 0;
    }
            

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        DeleteFile(pszFilename);
    }
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tsca\tsca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tsca.cpp
//
//  Contents:   Simplified Cryptographic API (SCA) Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    08-Mar-96   philh   created
//              20-Aug-96   jeffspel name changes
//              
//--------------------------------------------------------------------------

#define CMS_PKCS7       1

#ifdef CMS_PKCS7
#define CRYPT_SIGN_MESSAGE_PARA_HAS_CMS_FIELDS      1
#endif  // CMS_PKCS7

#define CRYPT_DECRYPT_MESSAGE_PARA_HAS_EXTRA_FIELDS 1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <time.h>
#include <malloc.h>
#include <dbgdef.h>

// #define ENABLE_SCA_STREAM_TEST              1
#define SCA_STREAM_ENABLE_FLAG              0x80000000
#define SCA_INDEFINITE_STREAM_FLAG          0x40000000

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCryptProvType = PROV_RSA_FULL;
static DWORD dwPubKeyBitLen = 0;
static LPCSTR pszHashName = "md5";
static LPCSTR pszEncryptName = "rc2";
static DWORD dwEncryptBitLen = 0;
static BOOL fEncryptIV = FALSE;
static BOOL fVerbose = FALSE;

static HCERTSTORE hCertStore = 0;
static LPSTR pszMsgCertFilename = NULL;
static LPSTR pszMsgEncodedFilename = NULL;
static LPSTR pszReadEncodedFilename = NULL;
static BOOL fDetached = FALSE;
static DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
static DWORD dwCertEncodingType = X509_ASN_ENCODING;
static DWORD dwSignKeySpec = AT_SIGNATURE;
static BOOL fInnerSigned = FALSE;
static LPSTR pszCertNameFindStr = NULL;

#ifdef ENABLE_SCA_STREAM_TEST
static BOOL fStream = FALSE;
static BOOL fIndefiniteStream = FALSE;
#endif

BOOL fNoRecipients = FALSE;
BOOL fAllRecipients = FALSE;
BOOL fDhRecipient = FALSE;
BOOL fEncapsulatedContent = FALSE;
#ifdef CMS_PKCS7
BOOL fSP3Encrypt = FALSE;
BOOL fDefaultGetSigner = FALSE;
BOOL fRecipientKeyId = FALSE;
BOOL fSignerKeyId = FALSE;
BOOL fHashEncryptionAlgorithm = FALSE;

BOOL fNoSalt = FALSE;
#define MAX_SALT_LEN    11
BYTE rgbSalt[MAX_SALT_LEN];
CMSG_RC4_AUX_INFO RC4AuxInfo;

BOOL fSilentKey = FALSE;

#endif


#define MAX_MSG_CERT        30
#define MAX_MSG_CRL         30
#define MAX_RECIPIENT_CERT  50

#define MAX_HASH_LEN      20

static LPCSTR pszMsgContent = "Message Content Message Content";
static LPCSTR pszMsgContent2 = "Second Message Content";
static LPCSTR pszMsgContent3 = "Third Message Content";
static const BYTE *pbToBeEncoded = (const BYTE *) pszMsgContent;
static DWORD cbToBeEncoded = strlen(pszMsgContent) + 1;

#define DETACHED_CONTENT_CNT    3
static const BYTE *rgpbDetachedToBeEncoded[DETACHED_CONTENT_CNT] = {
    (const BYTE *) pszMsgContent,
    (const BYTE *) pszMsgContent2,
    (const BYTE *) pszMsgContent3
};
static DWORD rgcbDetachedToBeEncoded[DETACHED_CONTENT_CNT] = {
    strlen(pszMsgContent) + 1,
    strlen(pszMsgContent2) + 1,
    strlen(pszMsgContent3) + 1
};

#define DELTA_LESS_LENGTH   8
#define DELTA_MORE_LENGTH   32

static CMSG_RC2_AUX_INFO RC2AuxInfo;

BOOL fAuthAttr = FALSE;
#define AUTH_ATTR_COUNT     2
BYTE    attr1[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','1',0};
BYTE    attr2[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','2',0};
BYTE    attr3[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','3',0};
CRYPT_ATTR_BLOB rgatrblob1[] = {
    { sizeof( attr1), attr1}
};
CRYPT_ATTR_BLOB rgatrblob2[] = {
    { sizeof( attr2), attr2},
    { sizeof( attr3), attr3}
};
CRYPT_ATTRIBUTE rgAuthAttr[AUTH_ATTR_COUNT] = {
    {"1.2.3.5.7",  1, rgatrblob1},
    {"1.2.3.5.11", 2, rgatrblob2}
};

static inline IsDSSProv(
    IN DWORD dwProvType
    )
{
    return (PROV_DSS == dwProvType || PROV_DSS_DH == dwProvType);
}


//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

static void CheckLessLength(
    LPCSTR pszMsg,
    BOOL fResult,
    DWORD cbActual,
    DWORD cbExpected
    )
{
    if (fResult)
        printf("%s failed => expected ERROR_MORE_DATA\n", pszMsg);
    else {
        DWORD dwErr = GetLastError();
        if (fVerbose)
            printf("%s with less length got expected error => 0x%x (%d)\n",
                pszMsg, dwErr, dwErr);
        if (ERROR_MORE_DATA != dwErr)
            printf("%s failed => LastError = %d, expected = %d\n",
                pszMsg, dwErr, ERROR_MORE_DATA);
    }

    if (cbActual != cbExpected)
        printf("%s failed => ", pszMsg);
    if (fVerbose || cbActual != cbExpected)
        printf("cbData = %d, expected = %d\n", cbActual, cbExpected);
}

static void CheckMoreLength(
    LPCSTR pszMsg,
    DWORD cbActual,
    DWORD cbExpected
    )
{
    if (cbActual != cbExpected) {
        printf("%s failed => ", pszMsg);
        printf("cbData = %d, expected = %d\n", cbActual, cbExpected);
    }
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static void *TestAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}
static void TestFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    fResult = CryptEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            NULL,           // pbEncoded
            &cbEncoded);
    if (!fResult || cbEncoded == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d, cbEncoded == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s, cbEncoded == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static PCCRYPT_OID_INFO GetOIDInfo(LPCSTR pszName, DWORD dwGroupId = 0)
{
    WCHAR wszName[256];
    PCCRYPT_OID_INFO pInfo;

    MultiByteToWideChar(
        CP_ACP,
        0,                      // dwFlags
        pszName,
        -1,                     // null terminated
        wszName,
        sizeof(wszName) / sizeof(wszName[0]));

    return CryptFindOIDInfo(
        CRYPT_OID_INFO_NAME_KEY,
        (void *) wszName,
        dwGroupId
        );
}

static LPCSTR GetOID(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->pszOID;
    else
        return NULL;
}

static ALG_ID GetAlgid(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->Algid;
    else
        return 0;
}

#define CROW 16
static void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
static BOOL ReadDERFromFile(
	LPCSTR	pszFileName,
	PBYTE	*ppbDER,
	PDWORD	pcbDER
	)
{
	BOOL		fRet;
    HANDLE      hFile = 0;
	PBYTE		pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

	*ppbDER = pbDER;
	*pcbDER = cbDER;
	fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
	return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
	*ppbDER = NULL;
	*pcbDER = 0;
	fRet = FALSE;
	goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
static BOOL WriteDERToFile(
	LPCSTR	pszFileName,
	PBYTE	pbDER,
	DWORD	cbDER
	)
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszStoreFilename);

        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");
    return hStore;
}

static void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

static void DisplayCert(PCCERT_CONTEXT pCert);
static void DisplayCrl(PCCRL_CONTEXT pCrl);

//+-------------------------------------------------------------------------
//  Functions for initializing and freeing SCA parameters
//--------------------------------------------------------------------------
static BOOL InitSignPara(OUT PCRYPT_SIGN_MESSAGE_PARA pPara);
static void FreeSignPara(IN PCRYPT_SIGN_MESSAGE_PARA pPara);
static BOOL InitVerifyPara(OUT PCRYPT_VERIFY_MESSAGE_PARA pPara);
static void FreeVerifyPara(IN PCRYPT_VERIFY_MESSAGE_PARA pPara);
static BOOL InitEncryptPara(
    OUT PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    OUT DWORD *pcRecipientCert,
    OUT PCCERT_CONTEXT **pppRecipientCert
    );
static void FreeEncryptPara(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT *ppRecipientCert
    );
static BOOL InitDecryptPara(OUT PCRYPT_DECRYPT_MESSAGE_PARA pPara);
static void FreeDecryptPara(IN PCRYPT_DECRYPT_MESSAGE_PARA pPara);
static BOOL InitHashPara(OUT PCRYPT_HASH_MESSAGE_PARA pPara);
static void FreeHashPara(IN PCRYPT_HASH_MESSAGE_PARA pPara);


//+-------------------------------------------------------------------------
//  Top Level Test Functions
//--------------------------------------------------------------------------
static BOOL TestSign()
{
    BOOL fResult;
    CRYPT_SIGN_MESSAGE_PARA SignPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbSignedBlob = NULL;
    DWORD cbSignedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    DWORD *pcbDecoded;
    PCCERT_CONTEXT pSignerCert = NULL;
    PCCERT_CONTEXT pSignerCert2 = NULL;
    LONG lSignerCount;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;
    DWORD cbData;
    DWORD dwInnerContentType = 0x1233467;

    DWORD cToBeSigned;
    const BYTE **ppbToBeSigned;
    DWORD *pcbToBeSigned;

    ppbToBeSigned = rgpbDetachedToBeEncoded;
    pcbToBeSigned = rgcbDetachedToBeEncoded;
    if (fDetached)
        cToBeSigned = DETACHED_CONTENT_CNT;
    else if (0 == cbToBeEncoded) {
        cToBeSigned = 0;
        ppbToBeSigned = NULL;
        pcbToBeSigned = NULL;
    } else
        cToBeSigned = 1;

    if (pszReadEncodedFilename)
        fResult = TRUE;
    else
        fResult = InitSignPara(&SignPara);
    fResult &= InitVerifyPara(&VerifyPara);
    if (!fResult) goto ErrorReturn;

    if (pszReadEncodedFilename) {
        if (!ReadDERFromFile(
                pszReadEncodedFilename,
                &pbSignedBlob,
                &cbSignedBlob
                ))
            goto ErrorReturn;
    } else {
        cbSignedBlob = 1;       // bad length should be ignored
        fResult = CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                NULL,           // pbSignedBlob
                &cbSignedBlob
                );
        if (!fResult || cbSignedBlob == 0) {
            PrintLastError("CryptSignMessage(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbSignedBlob = (BYTE *) TestAlloc(
                cbSignedBlob + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        if (!CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbSignedBlob
                )) {
            PrintLastError("CryptSignMessage");
            goto ErrorReturn;
        }

        cbData = cbSignedBlob - DELTA_LESS_LENGTH;
        fResult = CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbData
                );
        // Note, length varies for DSS
        if (!IsDSSProv(dwCryptProvType))
            CheckLessLength("CryptSignMessage", fResult, cbData, cbSignedBlob);

        cbData = cbSignedBlob + DELTA_MORE_LENGTH;
        if (!CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbData
                )) {
            PrintLastError("CryptSignMessage");
            goto ErrorReturn;
        }
        // Note, length varies for DSS
        if (!IsDSSProv(dwCryptProvType))
            CheckMoreLength("CryptSignMessage", cbData, cbSignedBlob);

        cbSignedBlob = cbData;
    }

    if (NULL == pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbSignedBlob, cbSignedBlob);

    if (pszMsgCertFilename) {
        HCERTSTORE hMsgCertStore;
        if (hMsgCertStore = CryptGetMessageCertificates(
                dwMsgEncodingType | dwCertEncodingType,
                0,                                      // hCryptProv,
                0,                                      // dwFlags
                pbSignedBlob,
                cbSignedBlob
                )) {
            SaveStore(hMsgCertStore, pszMsgCertFilename);
            CertCloseStore(hMsgCertStore, 0);
        } else
            PrintLastError("CryptGetMessageCertificates");
    }

    lSignerCount = CryptGetMessageSignerCount(dwMsgEncodingType,
        pbSignedBlob, cbSignedBlob);
    if (lSignerCount < 0)
        PrintLastError("CryptGetMessageSignerCount");
    else if (fVerbose)
        printf("Signer Count: %d\n", lSignerCount);

    if (fDetached) {
        if (!CryptVerifyDetachedMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                &pSignerCert
                )) {
            PrintLastError("CryptVerifyDetachedMessageSignature");
            goto ErrorReturn;
        }
    } else {
        cbDecoded = 3;          // bad length should be ignored
        if (!CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL            // ppSignerCert
                )) {
            PrintLastError("CryptVerifyMessageSignature");
            goto ErrorReturn;
        }
        if (cbDecoded == 0)
            // Message doesn't contain any content, only certs and CRLs
            pcbDecoded = NULL;
        else {
            pcbDecoded = &cbDecoded;
            if (NULL == (pbDecoded = (BYTE *) TestAlloc(
                cbDecoded + DELTA_MORE_LENGTH)))
                    goto ErrorReturn;
        }
        if (!CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                pbDecoded,
                pcbDecoded,
                &pSignerCert
                )) {
            if (GetLastError() == CRYPT_E_NO_SIGNER) {
                printf("message has no signers\n");

                // Try again with all out parameters set to NULL.
                // GetSignerCertificate should still be called
                fResult = CryptVerifyMessageSignature(
                        &VerifyPara,
                        0,              // dwSignerIndex
                        pbSignedBlob,
                        cbSignedBlob,
                        NULL,           // pbDecoded
                        NULL,           // pcbDecoded
                        NULL            // ppSignerCert
                        );
                if (fResult) {
                    printf("CryptVerifyMessageSignature(no signer, NULL outs)");
                    printf(" failed => returned SUCCESS\n");
                } else if (GetLastError() != CRYPT_E_NO_SIGNER)
                    PrintLastError("CryptVerifyMessageSignature(no signer, NULL outs)");
            } else {
                PrintLastError("CryptVerifyMessageSignature");
                goto ErrorReturn;
            }
        }

        if (cbDecoded > DELTA_LESS_LENGTH) {
            cbData = cbDecoded - DELTA_LESS_LENGTH;
            fResult = CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                pbDecoded,
                &cbData,
                NULL            // ppSignerCert
                );
            CheckLessLength("CryptVerifyMessageSignature", fResult, cbData,
                cbDecoded);

            cbData = cbDecoded + DELTA_MORE_LENGTH;
            if (!CryptVerifyMessageSignature(
                    &VerifyPara,
                    0,              // dwSignerIndex
                    pbSignedBlob,
                    cbSignedBlob,
                    pbDecoded,
                    &cbData,
                    NULL            // ppSignerCert
                    )) {
                if (GetLastError() == CRYPT_E_NO_SIGNER)
                    printf("message has no signers\n");
                else {
                    PrintLastError("CryptVerifyMessageSignature");
                    goto ErrorReturn;
                }
            }
            CheckMoreLength("CryptVerifyMessageSignature", cbData, cbDecoded);
        }
    }
    if (pSignerCert) {
        if (fVerbose) {
            printf("-----  Verifier  -----\n");
            DisplayCert(pSignerCert);
        }
    } else
        printf("no verifier cert\n");

    if (!fDetached) {
        if (!pszReadEncodedFilename) {
            if (cbDecoded == cbToBeEncoded &&
                memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                    if (fVerbose)
                        printf("SUCCESS:: Decoded == ToBeEncoded\n");
            } else
                printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        }
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }

        if (pszReadEncodedFilename && pszMsgEncodedFilename)
            WriteDERToFile(pszMsgEncodedFilename, pbDecoded, cbDecoded);

        cbDecoded2 = cbDecoded;
        if (cbDecoded2 ) {
            if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(
                cbDecoded2 + DELTA_MORE_LENGTH)))
                    goto ErrorReturn;
        }
        if (!CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                &dwInnerContentType,
                pbDecoded2,
                &cbDecoded2,
                NULL,               // ppXchgCert
                &pSignerCert2
                )) {
            if (GetLastError() == CRYPT_E_NO_SIGNER)
                printf("message has no signers\n");
            else {
                PrintLastError("CryptDecodeMessage(CMSG_SIGNED)");
                goto ErrorReturn;
            }
        }
        if (cbDecoded2 > DELTA_LESS_LENGTH) {
            cbData = cbDecoded2 - DELTA_LESS_LENGTH;
            fResult = CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                NULL,               // pdwInnerContentType
                pbDecoded2,
                &cbData,
                NULL,               // ppXchgCert
                NULL                // ppSignerCert
                );
            CheckLessLength("CryptDecodeMessage(SIGN)", fResult, cbData,
                cbDecoded2);

            cbData = cbDecoded2 + DELTA_MORE_LENGTH;
            if (!CryptDecodeMessage(
                    CMSG_ALL_FLAGS,
                    NULL,               // pDecryptPara
                    &VerifyPara,
                    0,                  // dwSignerIndex
                    pbSignedBlob,
                    cbSignedBlob,
                    0,                  // dwPrevInnerContentType
                    &dwMsgType,
                    &dwInnerContentType,
                    pbDecoded2,
                    &cbData,
                    NULL,               // ppXchgCert
                    NULL                // ppSignerCert
                    )) {
                if (GetLastError() == CRYPT_E_NO_SIGNER)
                    printf("message has no signers\n");
                else {
                    PrintLastError("CryptDecodeMessage(CMSG_SIGNED)");
                    goto ErrorReturn;
                }
            }
            CheckMoreLength("CryptDecodeMessage", cbData, cbDecoded2);
        }

        if (dwMsgType != CMSG_SIGNED)
            printf("failed :: dwMsgType(%d) != CMSG_SIGNED\n", dwMsgType);
        else if (fVerbose)
            printf("SUCCESS:: CryptDecodeMessage(CMSG_SIGNED)\n");
#ifdef CMS_PKCS7
        if ((fEncapsulatedContent && dwInnerContentType != CMSG_HASHED) ||
                (!fEncapsulatedContent && dwInnerContentType != CMSG_DATA)) {
#else
        if (dwInnerContentType != CMSG_DATA) {
#endif // CMS_PKCS7
            if (pszReadEncodedFilename)
                printf("SIGNED InnerContentType = %d\n", dwInnerContentType);
            else {
#ifdef CMS_PKCS7
                if (fEncapsulatedContent)
                    printf("SIGNED failed :: dwInnerContentType(%d) != CMSG_HASHED\n",
                        dwInnerContentType);
                else
#endif // CMS_PKCS7
                    printf("SIGNED failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                        dwInnerContentType);
            }
        }
        if (cbDecoded2 != cbDecoded ||
                (cbDecoded > 0 &&
                    memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
            printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_SIGNED)\n");
        if (pSignerCert && (pSignerCert2 == NULL ||
                !CertCompareCertificate(dwCertEncodingType, 
                    pSignerCert->pCertInfo, pSignerCert2->pCertInfo)))
            printf("failed :: bad signer cert for CryptDecodeMessage(CMSG_SIGNED)\n");
            
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (!pszReadEncodedFilename)
        FreeSignPara(&SignPara);
    FreeVerifyPara(&VerifyPara);
    if (pbSignedBlob)
        TestFree(pbSignedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (pSignerCert2)
        CertFreeCertificateContext(pSignerCert2);
    return fResult;
}

static BOOL TestEnvelope()
{
    BOOL fResult;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cRecipientCert;
    PCCERT_CONTEXT *ppRecipientCert;
    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    BYTE *pbEncryptedBlob = NULL;
    DWORD cbEncryptedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    PCCERT_CONTEXT pXchgCert = NULL;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;
    PCCERT_CONTEXT pXchgCert2 = NULL;
    DWORD cbData;

    DWORD dwInnerContentType = 0x1233467;

    if (pszReadEncodedFilename)
        fResult = TRUE;
    else
        fResult = InitEncryptPara(&EncryptPara, &cRecipientCert,
            &ppRecipientCert);
    fResult &= InitDecryptPara(&DecryptPara);
    if (!fResult) goto ErrorReturn;

    if (pszReadEncodedFilename) {
        if (!ReadDERFromFile(
                pszReadEncodedFilename,
                &pbEncryptedBlob,
                &cbEncryptedBlob
                ))
            goto ErrorReturn;
    } else {
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                NULL,           // pbEncryptedBlob
                &cbEncryptedBlob
                );
        if (!fResult || cbEncryptedBlob == 0) {
            PrintLastError("CryptEncryptMessage(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbEncryptedBlob = (BYTE *) TestAlloc(
                cbEncryptedBlob + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbEncryptedBlob
                );
        if (!fResult) {
            PrintLastError("CryptEncryptMessage");
            goto ErrorReturn;
        }

        cbData = cbEncryptedBlob - DELTA_LESS_LENGTH;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbData
                );
        // Note, length varies for DH
        if (!fDhRecipient)
            CheckLessLength("CryptEncryptMessage", fResult, cbData,
                cbEncryptedBlob);

        cbData = cbEncryptedBlob + DELTA_MORE_LENGTH;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbData
                );
        if (!fResult) {
            PrintLastError("CryptEncryptMessage");
            goto ErrorReturn;
        }

        // Note, length varies for DH
        if (!fDhRecipient)
            CheckMoreLength("CryptEncryptMessage", cbData, cbEncryptedBlob);

        cbEncryptedBlob = cbData;
    }

    if (NULL == pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbEncryptedBlob, cbEncryptedBlob);

    cbDecoded = 0;
    fResult = CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            NULL,           // pbDecoded
            &cbDecoded,
            NULL            // ppXchgCert
            );
    if (!fResult && GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
        printf("message has no recipients\n");
    else if (!fResult || (cbToBeEncoded > 0 && cbDecoded == 0 &&
            NULL == pszReadEncodedFilename)) {
        PrintLastError("CryptDecryptMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            pbDecoded,
            &cbDecoded,
            &pXchgCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecryptMessage");
            goto ErrorReturn;
        }
    }

    if (pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbDecoded, cbDecoded);

    if (cbDecoded > DELTA_LESS_LENGTH) {
        cbData = cbDecoded - DELTA_LESS_LENGTH;
        fResult = CryptDecryptMessage(
                &DecryptPara,
                pbEncryptedBlob,
                cbEncryptedBlob,
                pbDecoded,
                &cbData,
                NULL                // ppXchgCert
                );
        CheckLessLength("CryptDecryptMessage", fResult, cbData, cbDecoded);
    }

    cbData = cbDecoded + DELTA_MORE_LENGTH;
    if (!CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            pbDecoded,
            &cbData,
            NULL                // ppXchgCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecryptMessage");
            goto ErrorReturn;
        }
    }
    CheckMoreLength("CryptDecryptMessage", cbData, cbDecoded);

    if (pXchgCert) {
        if (fVerbose) {
            printf("-----  XchgCert  -----\n");
            DisplayCert(pXchgCert);
        }
    } else
        printf("no xchg cert\n");

    if (!pszReadEncodedFilename && !fNoRecipients) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
    }
    if (fVerbose) {
        printf("Decoded bytes::\n");
        PrintBytes("  ", pbDecoded, cbDecoded);
    }

    cbDecoded2 = cbDecoded;
    if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(
            cbDecoded2 + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            &dwInnerContentType,
            pbDecoded2,
            &cbDecoded2,
            &pXchgCert2,
            NULL                // pSignerCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecodeMessage(CMSG_ENVELOPED)");
            goto ErrorReturn;
        }
    }
    if (cbDecoded2 > DELTA_LESS_LENGTH) {
        cbData = cbDecoded2 - DELTA_LESS_LENGTH;
        fResult = CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            NULL,               // pdwInnerContentType
            pbDecoded2,
            &cbData,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            );
        CheckLessLength("CryptDecodeMessage(ENVELOPE)", fResult, cbData,
            cbDecoded2);
    }

    cbData = cbDecoded2 + DELTA_MORE_LENGTH;
    if (!CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            &dwInnerContentType,
            pbDecoded2,
            &cbData,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecodeMessage(CMSG_ENVELOPED)");
            goto ErrorReturn;
        }
    }
    CheckMoreLength("CryptDecodeMessage(ENVELOPE)", cbData, cbDecoded2);

    if (dwMsgType != CMSG_ENVELOPED)
        printf("failed :: dwMsgType(%d) != CMSG_ENVELOPED\n", dwMsgType);
    else if (fVerbose)
        printf("SUCCESS:: CryptDecodeMessage(CMSG_ENVELOPED)\n");
    if (!pszReadEncodedFilename) {
#ifdef CMS_PKCS7
        if ((fEncapsulatedContent && dwInnerContentType != CMSG_HASHED) ||
                (!fEncapsulatedContent && dwInnerContentType != CMSG_DATA)) {
#else
        if (dwInnerContentType != CMSG_DATA) {
#endif // CMS_PKCS7
#ifdef CMS_PKCS7
                if (fEncapsulatedContent)
                    printf("ENVELOPE failed :: dwInnerContentType(%d) != CMSG_HASHED\n",
                        dwInnerContentType);
                else
#endif // CMS_PKCS7
                printf("ENVELOPE failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                    dwInnerContentType);
        }
    }
    if (cbDecoded2 != cbDecoded ||
            (cbDecoded > 0 &&
                memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
        printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_ENVELOPED)\n");
    if (pXchgCert && (pXchgCert2 == NULL ||
            !CertCompareCertificate(dwCertEncodingType, 
                pXchgCert->pCertInfo, pXchgCert2->pCertInfo)))
        printf("failed :: bad xchg cert for CryptDecodeMessage(CMSG_ENVELOPED)\n");

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (!pszReadEncodedFilename)
        FreeEncryptPara(&EncryptPara, cRecipientCert, ppRecipientCert);
    FreeDecryptPara(&DecryptPara);
    if (pbEncryptedBlob)
        TestFree(pbEncryptedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (pXchgCert2)
        CertFreeCertificateContext(pXchgCert2);
    return fResult;
}

static BOOL TestSignAndEnvelope()
{
    BOOL fResult;
    CRYPT_SIGN_MESSAGE_PARA SignPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cRecipientCert;
    PCCERT_CONTEXT *ppRecipientCert;
    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;

    BYTE *pbEncodedBlob = NULL;
    DWORD cbEncodedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    PCCERT_CONTEXT pSignerCert = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;

    DWORD cbData;

    fResult = InitSignPara(&SignPara);
    fResult &= InitVerifyPara(&VerifyPara);
    fResult &= InitEncryptPara(&EncryptPara, &cRecipientCert, &ppRecipientCert);
    fResult &= InitDecryptPara(&DecryptPara);
    if (!fResult) goto ErrorReturn;

    if (fInnerSigned || fEncapsulatedContent) {
        SignPara.dwFlags |= CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
        EncryptPara.dwInnerContentType = CMSG_SIGNED;
    }

    fResult = CryptSignAndEncryptMessage(
            &SignPara,
            &EncryptPara,
            cRecipientCert,
            ppRecipientCert,
            pbToBeEncoded,
            cbToBeEncoded,
            NULL,           // pbEncodedBlob
            &cbEncodedBlob
            );
    if (!fResult || cbEncodedBlob == 0) {
        PrintLastError("CryptSignAndEncryptMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbEncodedBlob = (BYTE *) TestAlloc(
            cbEncodedBlob + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbEncodedBlob
        );
    if (!fResult){
        PrintLastError("CryptSignAndEncryptMessage");
        goto ErrorReturn;
    }

    cbData = cbEncodedBlob - DELTA_LESS_LENGTH;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbData
        );
    // Note, length varies for DSS or DH
    if (!IsDSSProv(dwCryptProvType) && !fDhRecipient)
        CheckLessLength("CryptSignAndEncryptMessage", fResult, cbData,
            cbEncodedBlob);

    cbData = cbEncodedBlob + DELTA_MORE_LENGTH;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbData
        );
    if (!fResult){
        PrintLastError("CryptSignAndEncryptMessage");
        goto ErrorReturn;
    }
    // Note, length varies for DSS or DH
    if (!IsDSSProv(dwCryptProvType) && !fDhRecipient)
        CheckMoreLength("CryptSignAndEncryptMessage", cbData, cbEncodedBlob);
    cbEncodedBlob = cbData;

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbEncodedBlob, cbEncodedBlob);

    fResult = CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            NULL,           // pbDecoded
            &cbDecoded,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            );
    if (!fResult || cbDecoded == 0) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(
            cbDecoded + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbDecoded,
            &pXchgCert,
            &pSignerCert
            )) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature");
        goto ErrorReturn;
    }

    cbData = cbDecoded - DELTA_LESS_LENGTH;
    fResult = CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbData,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            );
    CheckLessLength("CryptDecryptAndVerifyMessageSignature", fResult, cbData,
        cbDecoded);

    cbData = cbDecoded + DELTA_MORE_LENGTH;
    if (!CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbData,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            )) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature");
        goto ErrorReturn;
    }
    CheckMoreLength("CryptDecryptAndVerifyMessageSignature", cbData,
        cbDecoded);

    if (pXchgCert) {
        if (fVerbose) {
            printf("-----  XchgCert  -----\n");
            DisplayCert(pXchgCert);
        }
    } else
        printf("no xchg cert\n");
    if (pSignerCert) {
        if (fVerbose) {
            printf("-----  Verifier  -----\n");
            DisplayCert(pSignerCert);
        }
    } else
        printf("no verifier cert\n");

    if (cbDecoded == cbToBeEncoded &&
        memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
            if (fVerbose)
                printf("SUCCESS:: Decoded == ToBeEncoded\n");
    } else
        printf("*****  ERROR:: Decoded != ToBeEncoded\n");
    if (fVerbose) {
        printf("Decoded bytes::\n");
        PrintBytes("  ", pbDecoded, cbDecoded);
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeSignPara(&SignPara);
    FreeVerifyPara(&VerifyPara);
    FreeEncryptPara(&EncryptPara, cRecipientCert, ppRecipientCert);
    FreeDecryptPara(&DecryptPara);
    if (pbEncodedBlob)
        TestFree(pbEncodedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    return fResult;
}

static BOOL TestHash()
{
    BOOL fResult;
    CRYPT_HASH_MESSAGE_PARA HashPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbHashedBlob = NULL;
    DWORD cbHashedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;

    DWORD cbData;
    DWORD dwInnerContentType = 0x1233467;

    fResult = InitHashPara(&HashPara);
    if (!fResult) goto ErrorReturn;

    cbHashedBlob = 0;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            NULL,           // pbHashedBlob
            &cbHashedBlob,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            );
    if (!fResult || cbHashedBlob == 0) {
        PrintLastError("CryptHashMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbHashedBlob = (BYTE *) TestAlloc(
            cbHashedBlob + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbHashedBlob,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }

    cbData = cbHashedBlob - DELTA_LESS_LENGTH;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbData,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            );
    CheckLessLength("CryptHashMessage", fResult, cbData, cbHashedBlob);

    cbData = cbHashedBlob + DELTA_MORE_LENGTH;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbData,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }
    CheckMoreLength("CryptHashMessage", cbData, cbHashedBlob);

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbHashedBlob, cbHashedBlob);

    if (fDetached) {
        if (!CryptVerifyDetachedMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyDetachedMessageHash");
            goto ErrorReturn;
        }
    } else {
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                );
        if (!fResult || cbDecoded == 0) {
            PrintLastError("CryptVerifyMessageHash(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbDecoded = (BYTE *) TestAlloc(
                cbDecoded + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        if (!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbDecoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }

        cbData = cbDecoded - DELTA_LESS_LENGTH;
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbData,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                );
        CheckLessLength("CryptVerifyMessageHash", fResult, cbData, cbDecoded);

        cbData = cbDecoded + DELTA_MORE_LENGTH;
        if (!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbData,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }
        CheckMoreLength("CryptVerifyMessageHash", cbData, cbDecoded);
    }

    if (!fDetached) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }

        cbDecoded2 = cbDecoded;
        if (cbDecoded2 ) {
            if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(cbDecoded2)))
                    goto ErrorReturn;
        }
        InitVerifyPara(&VerifyPara);
        if (!CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbHashedBlob,
                cbHashedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                &dwInnerContentType,
                pbDecoded2,
                &cbDecoded2,
                NULL,               // ppXchgCert
                NULL                // ppSignCert
                )) {
            PrintLastError("CryptDecodeMessage(CMSG_HASHED)");
            goto ErrorReturn;
        }
        if (dwMsgType != CMSG_HASHED)
            printf("failed :: dwMsgType(%d) != CMSG_HASHED\n", dwMsgType);
        else if (fVerbose)
            printf("SUCCESS:: CryptDecodeMessage(CMSG_HASHED)\n");
        if (dwInnerContentType != CMSG_DATA) {
                printf("HASHED failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                    dwInnerContentType);
        }
        if (cbDecoded2 != cbDecoded ||
                (cbDecoded > 0 &&
                    memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
            printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_HASHED)\n");
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeHashPara(&HashPara);
    if (pbHashedBlob)
        TestFree(pbHashedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    return fResult;
}

static BOOL TestComputedHash()
{
    BOOL fResult;
    CRYPT_HASH_MESSAGE_PARA HashPara;
    BYTE *pbHashedBlob = NULL;
    DWORD cbHashedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;

    BYTE rgbEncodedComputedHash[MAX_HASH_LEN];
    BYTE rgbDecodedComputedHash[MAX_HASH_LEN];
    DWORD cbEncodedComputedHash;
    DWORD cbDecodedComputedHash;

    fResult = InitHashPara(&HashPara);
    if (!fResult) goto ErrorReturn;

    cbHashedBlob = 0;
    cbEncodedComputedHash = 0;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            NULL,           // pbHashedBlob
            &cbHashedBlob,
            NULL,           // pbComputedHash
            &cbEncodedComputedHash
            );
    if (!fResult || cbHashedBlob == 0) {
        PrintLastError("CryptHashMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (cbEncodedComputedHash == 0) {
        PrintLastError("CryptHashMessage(cbComputedHash == 0)");
        goto ErrorReturn;
    }
    if (cbEncodedComputedHash > MAX_HASH_LEN) {
        PrintLastError("CryptHashMessage(cbComputedHash > MAX_HASH_LEN)");
        goto ErrorReturn;
    }

    if (NULL == (pbHashedBlob = (BYTE *) TestAlloc(cbHashedBlob)))
        goto ErrorReturn;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbHashedBlob,
            rgbEncodedComputedHash,
            &cbEncodedComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }
    if (fVerbose) {
        printf("Encoded Computed Hash::\n");
        PrintBytes("  ", rgbEncodedComputedHash, cbEncodedComputedHash);
    }

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbHashedBlob, cbHashedBlob);

    if (fDetached) {
        cbDecodedComputedHash = MAX_HASH_LEN;
        if(!CryptVerifyDetachedMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                rgbDecodedComputedHash,
                &cbDecodedComputedHash
                )) {
            PrintLastError("CryptVerifyDetachedMessageHash");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash == 0) {
            PrintLastError("CryptVerifyDetachedMessageHash(cbComputedHash == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash > MAX_HASH_LEN) {
            PrintLastError("CryptVerifyDetachedMessageHash(cbComputedHash > MAX_HASH_LEN)");
            goto ErrorReturn;
        }
    } else {
        cbDecoded = 0;
        cbDecodedComputedHash = 0;
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL,           // pbComputedHash
                &cbDecodedComputedHash
                );
        if (!fResult || cbDecoded == 0) {
            PrintLastError("CryptVerifyMessageHash(cb == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash == 0) {
            PrintLastError("CryptVerifyMessageHash(cbComputedHash == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash > MAX_HASH_LEN) {
            PrintLastError("CryptVerifyMessageHash(cbComputedHash > MAX_HASH_LEN)");
            goto ErrorReturn;
        }
        if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded)))
            goto ErrorReturn;
        if(!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbDecoded,
                rgbDecodedComputedHash,
                &cbDecodedComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }
    }

    if (fVerbose) {
        printf("Decoded Computed Hash::\n");
        PrintBytes("  ", rgbDecodedComputedHash, cbDecodedComputedHash);
    }

    if (cbDecodedComputedHash == cbEncodedComputedHash &&
            memcmp(rgbDecodedComputedHash, rgbEncodedComputedHash,
                cbDecodedComputedHash) == 0) {
        if (fVerbose)
            printf("SUCCESS:: Computed Hash Decoded == ToBeEncoded\n");
    } else
        printf("*****  ERROR:: Computed Hash Decoded != ToBeEncoded\n");

    if (!fDetached) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeHashPara(&HashPara);
    if (pbHashedBlob)
        TestFree(pbHashedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    return fResult;
}

static BOOL TestNoCertSign()
{
    BOOL fResult;
    HCRYPTPROV hCryptProv = 0;
    CRYPT_KEY_SIGN_MESSAGE_PARA SignPara;
    CRYPT_KEY_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbSignedBlob = NULL;
    DWORD cbSignedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;

    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo1 = NULL;
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo2 = NULL;
    DWORD cbInfo;
    BYTE *pbEncodedKey = NULL;
    DWORD cbEncodedKey;

    fResult = CryptAcquireContext(
            &hCryptProv,
            NULL,           // pszContainer
            NULL,           // pszProvider
            dwCryptProvType,
            0               // dwFlags
            );
    if (!fResult) {
        hCryptProv = 0;
        PrintLastError("TestNoCertSign::CryptAcquireContext");
        goto ErrorReturn;
    }

    cbInfo = 0;
    fResult = CryptExportPublicKeyInfo(
            hCryptProv,
            dwSignKeySpec,
            dwCertEncodingType,
            NULL,           // pPubKeyInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pPublicKeyInfo1 = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            dwSignKeySpec,
            dwCertEncodingType,
            pPublicKeyInfo1,
            &cbInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    cbEncodedKey = 0;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pPublicKeyInfo1,
            NULL,           // pbEncodedKey
            &cbEncodedKey
            );
    if (!fResult || cbEncodedKey == 0) {
        PrintLastError("CryptEncodeObject(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbEncodedKey = (BYTE *) TestAlloc(cbEncodedKey)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pPublicKeyInfo1,
            pbEncodedKey,
            &cbEncodedKey
            )) {
        PrintLastError("CryptEncodeObject");
        goto ErrorReturn;
    }

    memset(&SignPara, 0, sizeof(SignPara));
    SignPara.cbSize = sizeof(SignPara);
    SignPara.dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
    SignPara.hCryptProv = hCryptProv;
    SignPara.dwKeySpec = dwSignKeySpec;
    if (NULL == (SignPara.HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s)\n", pszHashName);
        goto ErrorReturn;
    }

    if (IsDSSProv(dwCryptProvType)) {
        SignPara.cbSize = sizeof(SignPara);
        SignPara.PubKeyAlgorithm.pszObjId = (LPSTR) GetOID(
            "Dss", CRYPT_PUBKEY_ALG_OID_GROUP_ID);
    } else
        SignPara.cbSize = offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
            PubKeyAlgorithm);

    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara);
    VerifyPara.dwMsgEncodingType = dwMsgEncodingType;
    VerifyPara.hCryptProv = 0;

    cbSignedBlob = 0;
    fResult = CryptSignMessageWithKey(
            &SignPara,
            pbEncodedKey,
            cbEncodedKey,
            NULL,           // pbSignedBlob
            &cbSignedBlob
            );
    if (!fResult || cbSignedBlob == 0) {
        PrintLastError("CryptSignMessageWithKey(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbSignedBlob = (BYTE *) TestAlloc(cbSignedBlob)))
        goto ErrorReturn;
    if (!CryptSignMessageWithKey(
            &SignPara,
            pbEncodedKey,
            cbEncodedKey,
            pbSignedBlob,
            &cbSignedBlob
            )) {
        PrintLastError("CryptSignMessageWithKey");
        goto ErrorReturn;
    }

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbSignedBlob, cbSignedBlob);

    // First get the encoded public key info (ie, don't verify the signature)
    cbDecoded = 0;
    fResult = CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            NULL,           // pPublicKeyInfo
            pbSignedBlob,
            cbSignedBlob,
            NULL,           // pbDecoded
            &cbDecoded
            );
    if (!fResult || cbDecoded == 0) {
        PrintLastError("CryptVerifyMessageSignatureWithKey(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded)))
        goto ErrorReturn;
    if(!CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            NULL,           // pPublicKeyInfo
            pbSignedBlob,
            cbSignedBlob,
            pbDecoded,
            &cbDecoded
            )) {
        PrintLastError("CryptVerifyMessageSignatureWithKey");
        goto ErrorReturn;
    }

    // Now decode the public key info stored in the signed message
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pbDecoded,
            cbDecoded,
            0,                  // dwFlags
            NULL,               // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("CryptDecodeObject(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pPublicKeyInfo2 = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pbDecoded,
            cbDecoded,
            0,                              // dwFlags
            pPublicKeyInfo2,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject");
        goto ErrorReturn;
    }

    if (fVerbose) {
        printf("Decoded Algorithm Identifier:: %s\n",
            pPublicKeyInfo2->Algorithm.pszObjId);
        printf("Decoded public key bytes::\n");
        PrintBytes("  ",  pPublicKeyInfo2->PublicKey.pbData,
            pPublicKeyInfo2->PublicKey.cbData);
    }

    if (strcmp(pPublicKeyInfo1->Algorithm.pszObjId,
            pPublicKeyInfo2->Algorithm.pszObjId) == 0 &&
        CertComparePublicKeyInfo(
            dwCertEncodingType,
                pPublicKeyInfo1,
                pPublicKeyInfo2)) {
        if (fVerbose)
            printf("SUCCESS:: Decoded PublicKeyInfo == PublicKeyInfo\n");
    } else {
        printf("*****  ERROR:: Decoded PublicKeyInfo != PublicKeyInfo\n");
        if (fVerbose) {
            printf("Expected Algorithm Identifier:: %s\n",
                pPublicKeyInfo1->Algorithm.pszObjId);
            printf("Expected public key bytes::\n");
            PrintBytes("  ",  pPublicKeyInfo1->PublicKey.pbData,
                pPublicKeyInfo1->PublicKey.cbData);
        }
        goto ErrorReturn;
    }

    // Use the public key info to verify the signature
    if (!CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            pPublicKeyInfo2,
            pbSignedBlob,
            cbSignedBlob,
            NULL,           // pbDecoded
            NULL            // pcbDecoded
            )) {
        PrintLastError("CryptVerifyMessageSignatureWithKey(pPublicKeyInfo verify)");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    if (pPublicKeyInfo1)
        TestFree(pPublicKeyInfo1);
    if (pPublicKeyInfo2)
        TestFree(pPublicKeyInfo2);
    if (pbSignedBlob)
        TestFree(pbSignedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbEncodedKey)
        TestFree(pbEncodedKey);
    return fResult;
}


static BOOL TimeStampTest(PCRYPT_TIME_STAMP_REQUEST_INFO pTSInfo) {
    BYTE *                          pbDer       = NULL;
    DWORD                           cbEncode    = 0;
    DWORD                           cbDecode    = 0;
    PCRYPT_TIME_STAMP_REQUEST_INFO  pbTSInfo    = NULL;
    BOOL                            fOk         = TRUE;

    // encode it
    if( 
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pTSInfo,
            NULL,
            &cbEncode)                                  ||
       (pbDer = (PBYTE) _alloca(cbEncode)) == NULL      ||
       !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pTSInfo,
            pbDer,
            &cbEncode)  )
    {
        goto CryptEncodeTimeRequestError;
    }
        

    // decode it
    if( 
        !CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pbDer,
            cbEncode,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,
            &cbDecode)              ||
        (pbTSInfo = (PCRYPT_TIME_STAMP_REQUEST_INFO) _alloca(cbDecode)) == NULL  ||
        !CryptDecodeObject(
		    CRYPT_ASN_ENCODING,
		    PKCS_TIME_REQUEST,
            pbDer,
            cbEncode,
            CRYPT_DECODE_NOCOPY_FLAG,
            pbTSInfo,
            &cbDecode) )
    {
        goto CryptDecodeTimeRequestError;
    }

    // compare encoded data with decoded data
    if(
        _stricmp(pTSInfo->pszTimeStampAlgorithm, pbTSInfo->pszTimeStampAlgorithm)          ||
        _stricmp(pTSInfo->pszContentType, pbTSInfo->pszContentType)                        ||
        pTSInfo->Content.cbData != pbTSInfo->Content.cbData                                ||
        pTSInfo->cAttribute != pbTSInfo->cAttribute                                       )
    {
        goto CompareTimeRequestError;
    }

    if(pTSInfo->Content.cbData != 0  &&
        memcmp(pTSInfo->Content.pbData, pbTSInfo->Content.pbData, pTSInfo->Content.cbData) )
    {
        goto CompareTimeRequestError;
    }

CommonReturn:
 
    return(fOk);

ErrorReturn:

    fOk = FALSE;
    goto CommonReturn;

    // TRACE_ERROR(BuildTimeStampError);
    TRACE_ERROR(CryptEncodeTimeRequestError);
    TRACE_ERROR(CryptDecodeTimeRequestError);
    TRACE_ERROR(CompareTimeRequestError);
}

static BOOL TestTimeStamp()
{
    CRYPT_TIME_STAMP_REQUEST_INFO   TSInfo;
    BOOL                            fOk;
    
    BYTE rgTestData[] = {
        0x1b, 0xf6, 0x92, 0xee, 0x6c, 0x44, 0xc5, 0xed, 0x51, 0xe4, 0x1a, 0xac, 0x21, 0x07, 0x2f, 0x63,
        0x6b, 0xc9, 0x27, 0x30, 0x90, 0xb8, 0x3c, 0xa6, 0x75, 0xf8, 0x17, 0x5a, 0x28, 0x2b, 0xe7, 0x3f,
        0xd7, 0x47, 0xad, 0x82, 0x1a, 0x34, 0x37, 0x27, 0x22, 0xd2, 0x64, 0x8b, 0x24, 0xe6, 0x42, 0x55,
        0x8a, 0xfe, 0xd1, 0xb4, 0xcf, 0x96, 0xa3, 0xea, 0x90, 0xf9, 0x2b, 0xeb, 0x16, 0x27, 0xaa, 0x5b
    };
    
    // initialize the timestamp structure
    TSInfo.pszTimeStampAlgorithm = szOID_RSA_signingTime;
    TSInfo.pszContentType = szOID_RSA_data;
    TSInfo.Content.cbData = sizeof(rgTestData);
    TSInfo.Content.pbData = rgTestData;
    TSInfo.cAttribute = 0; 
    TSInfo.rgAttribute = NULL;

    if( (fOk = TimeStampTest(&TSInfo) ) == TRUE ) {
        TSInfo.Content.cbData = 0;
        TSInfo.Content.pbData = NULL;    
        fOk = TimeStampTest(&TSInfo);
    }
    
    return(fOk);
}

static BOOL TestPKCS10Attr() {

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR    nameValuePair   = {L"Name", L"Value"};
    PCRYPT_ENROLLMENT_NAME_VALUE_PAIR   pNameValuePair  = NULL;
    DWORD                               cb              = 0;
    CRYPT_DATA_BLOB                     blob;
    BOOL                                fOk             = TRUE;

    BYTE                                signatureData[] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA};
    CRYPT_CSP_PROVIDER                  cspProvider     = {32, L"My CSP", {sizeof(signatureData), signatureData, 0}};
    PCRYPT_CSP_PROVIDER                 pCSPProvider    = NULL;
    
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));

    if(!CryptEncodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_NAME_VALUE_PAIR,
        &nameValuePair,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &blob.pbData,
        &blob.cbData
        ))
        goto ErrorCryptEncodeNameValuePair;

    if(!CryptDecodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_NAME_VALUE_PAIR,
        blob.pbData,
        blob.cbData,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &pNameValuePair,
        &cb
        ))
        goto ErrorCryptDecodeNameValuePair;

    if(
        wcscmp(nameValuePair.pwszName, pNameValuePair->pwszName)    ||
        wcscmp(nameValuePair.pwszValue, pNameValuePair->pwszValue)  )
        goto CompareNameValuePair;
            

    // szOID_ENROLLMENT_CSP_PROVIDER
    assert(blob.pbData != NULL);
    LocalFree(blob.pbData);
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
    cb = 0;

    if(!CryptEncodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_CSP_PROVIDER,
        &cspProvider,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &blob.pbData,
        &blob.cbData
        ))
        goto ErrorCryptEncodeCSPProvider;

    if(!CryptDecodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_CSP_PROVIDER,
        blob.pbData,
        blob.cbData,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &pCSPProvider,
        &cb
        ))
        goto ErrorCryptDecodeCSPProvider;

    if(
        wcscmp(cspProvider.pwszProviderName, pCSPProvider->pwszProviderName)    ||
        cspProvider.Signature.cbData != pCSPProvider->Signature.cbData  ||
        cspProvider.Signature.cUnusedBits != pCSPProvider->Signature.cUnusedBits  ||
        cspProvider.dwKeySpec != pCSPProvider->dwKeySpec                            ||
        memcmp(cspProvider.Signature.pbData, pCSPProvider->Signature.pbData, cspProvider.Signature.cbData)  )
        goto CompareCSPProvider;

CommonReturn:

    if(blob.pbData != NULL)
        LocalFree(blob.pbData);
        
    if(pNameValuePair != NULL)
        LocalFree(pNameValuePair);
        
    if(pCSPProvider != NULL)
        LocalFree(pCSPProvider);
        
    return(fOk);

ErrorReturn:

    fOk = FALSE;
    goto CommonReturn;

    // TRACE_ERROR(BuildTimeStampError);
    TRACE_ERROR(ErrorCryptEncodeNameValuePair);
    TRACE_ERROR(ErrorCryptDecodeNameValuePair);
    TRACE_ERROR(CompareNameValuePair);
    TRACE_ERROR(ErrorCryptEncodeCSPProvider);
    TRACE_ERROR(ErrorCryptDecodeCSPProvider);
    TRACE_ERROR(CompareCSPProvider);

}



typedef BOOL (*PFN_TEST)(void);
static struct
{
    LPCSTR      pszName;
    PFN_TEST    pfn;
} Tests[] = {
    "Sign",             TestSign,
    "Envelope",         TestEnvelope,
    "SignAndEnvelope",  TestSignAndEnvelope,
    "Hash",             TestHash,
    "ComputedHash",     TestComputedHash,
    "NoCertSign",       TestNoCertSign,
    "TimeStamp",        TestTimeStamp,
    "PKCS10Attr",       TestPKCS10Attr
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static void Usage(void)
{
    int i;

    printf("Usage: tsca [options] <StoreFilename> [<TestName>] [<CertNameString>]\n");
    printf("Options are:\n");
#ifdef CMS_PKCS7
    printf("  -EncapsulatedContent  - CMS encapsulated content\n");
    printf("  -SP3Encrypt           - SP3 compatible encrypt\n");
    printf("  -DefaultGetSigner     - Use default GetSignerCertificate\n");
    printf("  -NoRecipients         - No Envelope Recipients\n");
    printf("  -AllRecipients        - All Envelope Recipients in store\n");
    printf("  -RecipientKeyId       - Use KeyId for recipients\n");
    printf("  -SignerKeyId          - Use KeyId for signers\n");
    printf("  -HashEncryptionAlgorithm - Use signature as hash encrypt algorithm\n");
    printf("  -NoSalt               - NoSalt for RC4\n");
    printf("  -SilentKey            - Silent private key usage\n");
#endif  // CMS_PKCS7
    printf("  -h                    - This message\n");
    printf("  -A                    - Authenticated Attributes\n");
    printf("  -D                    - Detached Hash or Signature\n");
    printf("  -I                    - Inner Signed Content for SignAndEnvelope\n");
    printf("  -X                    - Sign using keyeXchange\n");
    printf("  -l                    - Print command line\n");
    printf("  -v                    - Verbose\n");
    printf("  -H<name>              - Hash algorithm, default of \"md5\"\n");
    printf("  -E<name>              - Encrypt algorithm, default of \"rc2\"\n");
    printf("  -e<EncryptBitLen>     - Encrypt key bit length\n");
    printf("  -i                    - Include IV in encrypt parameters\n");
    printf("  -p<provider>          - Specify crypto provider type number\n");
    printf("  -P<PubKeyBitLen>      - Public key bit length\n");
    printf("  -r<filename>          - Read encoded message from file\n");
    printf("  -m<filename>          - Write encoded message to file\n");
    printf("  -c<filename>          - Write message cert store to file\n");
    printf("  -0                    - Zero length content\n");
#ifdef ENABLE_SCA_STREAM_TEST
    printf("  -s                    - Enable streaming\n");
    printf("  -S                    - Enable indefinite length streaming\n");
#endif
    printf("\n");
    printf("Tests are (case insensitive name):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: ALL Tests\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszTestName = NULL;
    int TestIdx = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
#ifdef CMS_PKCS7
            if (0 == _stricmp(argv[0]+1, "EncapsulatedContent")) {
                fEncapsulatedContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SP3Encrypt")) {
                fSP3Encrypt = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "DefaultGetSigner")) {
                fDefaultGetSigner = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoRecipients")) {
                fNoRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AllRecipients")) {
                fAllRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "RecipientKeyId")) {
                fRecipientKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SignerKeyId")) {
                fSignerKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "HashEncryptionAlgorithm")) {
                fHashEncryptionAlgorithm = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSalt")) {
                fNoSalt = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SilentKey")) {
                fSilentKey = TRUE;
            } else {
#endif  // CMS_PKCS7
                switch(argv[0][1])
                {
                case 'A':
                    fAuthAttr = TRUE;
                    break;
                case 'D':
                    fDetached = TRUE;
                    break;
                case 'I':
                    fInnerSigned = TRUE;
                    break;
                case 'l':
                    printf("command line: %s\n", GetCommandLine());
                    break;
                case 'p':
                    dwCryptProvType = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'P':
                    dwPubKeyBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'H':
                    pszHashName = argv[0]+2;
                    break;
                case 'E':
                    pszEncryptName = argv[0]+2;
                    break;
                case 'e':
                    dwEncryptBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'i':
                    fEncryptIV = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'X':
                    dwSignKeySpec = AT_KEYEXCHANGE;
                    break;
                case 'm':
                    pszMsgEncodedFilename = argv[0]+2;
                    if (*pszMsgEncodedFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'c':
                    pszMsgCertFilename = argv[0]+2;
                    if (*pszMsgCertFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'r':
                    pszReadEncodedFilename = argv[0]+2;
                    if (*pszReadEncodedFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case '0':
                    cbToBeEncoded = 0;
                    rgcbDetachedToBeEncoded[0] = 0;
                    break;
    #ifdef ENABLE_SCA_STREAM_TEST
                case 'S':
                    fIndefiniteStream = TRUE;
                case 's':
                    fStream = TRUE;
                    break;
    #endif
                case 'h':
                default:
                    Usage();
                    return -1;
                }
#ifdef CMS_PKCS7
            }
#endif  // CMS_PKCS7
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if(pszTestName == NULL)
                pszTestName = argv[0];
            else if (pszCertNameFindStr == NULL)
                pszCertNameFindStr = argv[0];
            else {
                printf("Too many arguments\n");
                Usage();
                return -1;
            }
        }
    }

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    if (pszTestName) {
        for (TestIdx = 0; TestIdx < NTESTS; TestIdx++) {
            if (_stricmp(pszTestName, Tests[TestIdx].pszName) == 0)
                break;
        }
        if (TestIdx >= NTESTS) {
            printf("Bad TestName: %s\n", pszTestName);
            Usage();
            return -1;
        }
            
    } else
        TestIdx = 0;

    if (fDetached) printf("Detached Enabled ");
    if (pszReadEncodedFilename)
        printf("Reading encoded msg from file: %s ", pszReadEncodedFilename);
    if (pszMsgEncodedFilename)
        printf("Writing encoded msg to file: %s ", pszMsgEncodedFilename);
    if (pszMsgCertFilename)
        printf("Writing msg cert store to file: %s ", pszMsgCertFilename);
    printf("\n");

    // Attempt to open the store
    hCertStore = OpenStore(pszStoreFilename);
    if (hCertStore == NULL)
        goto ErrorReturn;

    for ( ; TestIdx < NTESTS; TestIdx++) {
        printf("Starting %s Test\n", Tests[TestIdx].pszName);
        fResult = Tests[TestIdx].pfn();
        if (fResult)
            printf("Passed\n");
        else
            printf("Failed\n");
        printf("\n");
        if (pszTestName)
            break;
    }

ErrorReturn:
    if (hCertStore) {
        if (!CertCloseStore(hCertStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }
    return 0;
}

static BOOL NameAttributeValueCompare(
    IN const BYTE *pbValue,
    IN DWORD cbValue,
    IN PCERT_NAME_BLOB pName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            NULL,                   // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError(
            "NameAttributeValueCompare::CryptDecodeObject(cbInfo == 0)");
        goto ErrorReturn;
    }
    pInfo = (PCERT_NAME_INFO) TestAlloc(cbInfo);
    if (pInfo == NULL) goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pName->pbData,
            pName->cbData,
            0,                              // dwFlags
            pInfo,
            &cbInfo
            )) {
        PrintLastError("NameAttributeValueCompare::CryptDecodeObject");
        goto ErrorReturn;
    }

    for (cRDN = pInfo->cRDN, pRDN = pInfo->rgRDN; cRDN > 0; cRDN--, pRDN++) {
        for (cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr;
                                                cAttr > 0; cAttr--, pAttr++) {
            if (pAttr->Value.cbData == cbValue &&
                    memcmp(pAttr->Value.pbData, pbValue, cbValue) == 0) {
                fResult = TRUE;
                goto CommonReturn;
            }
        }
    }
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static PCCERT_CONTEXT FindCertWithKey(IN DWORD dwKeySpec)
{
    PCCERT_CONTEXT pCert;
    void *pvFindPara;
    DWORD dwFindType;

    if (pszCertNameFindStr) {
        dwFindType = CERT_FIND_SUBJECT_STR_A;
        pvFindPara = (void *) pszCertNameFindStr;
    } else {
        dwFindType = CERT_FIND_ANY;
        pvFindPara = NULL;
    }

    // Find the first certificate in the store with a CRYPT_KEY_PROV_INFO
    // property matching the specified dwSignKeySpec, dwCryptProvType and
    // dwPubKeyBitLen
    pCert = NULL;
    while (TRUE) {
        pCert = CertFindCertificateInStore(
            hCertStore,
            dwCertEncodingType,
            0,                      // dwFindFlags,
            dwFindType,
            pvFindPara,
            pCert
            );
        if (pCert == NULL)
            break;

        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbInfo
            );
        if (cbInfo >= sizeof(CRYPT_KEY_PROV_INFO) &&
                (pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo))) {
            BOOL fMatch = FALSE;
            if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo) && 
                    dwKeySpec == pInfo->dwKeySpec &&
                    dwCryptProvType == pInfo->dwProvType) {
                if (0 == dwPubKeyBitLen)
                    fMatch = TRUE;
                else
                    fMatch = (dwPubKeyBitLen == CertGetPublicKeyLength(
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->SubjectPublicKeyInfo));
            }
            TestFree(pInfo);
            if (fMatch)
                break;
        }
    }
    return pCert;
}
    

static BOOL InitSignPara(OUT PCRYPT_SIGN_MESSAGE_PARA pPara)
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    PCCERT_CONTEXT pIssuer;
    PCCRL_CONTEXT pCrl;
    DWORD dwFlags;
    BYTE bIntendedKeyUsage;

    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    if (NULL == (pPara->HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s) for signing\n",
            pszHashName);
        goto ErrorReturn;
    }


#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream) {
        pPara->dwFlags |= SCA_STREAM_ENABLE_FLAG;
        if (fIndefiniteStream)
            pPara->dwFlags |= SCA_INDEFINITE_STREAM_FLAG;
    }
#endif

#ifdef CMS_PKCS7
    if (fSignerKeyId)
        pPara->dwFlags |= CRYPT_MESSAGE_KEYID_SIGNER_FLAG;
    if (fEncapsulatedContent) {
        pPara->dwFlags |= CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG;
        pPara->dwInnerContentType = CMSG_HASHED;
    }

    if (fSilentKey)
        pPara->dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;
#endif  // CMS_PKCS7

    pPara->rgpMsgCert = (PCCERT_CONTEXT*) TestAlloc(
        sizeof(PCCERT_CONTEXT) * MAX_MSG_CERT);
    if (pPara->rgpMsgCert == NULL) goto ErrorReturn;
    pPara->rgpMsgCrl = (PCCRL_CONTEXT*) TestAlloc(
        sizeof(PCCRL_CONTEXT) * MAX_MSG_CRL);
    if (pPara->rgpMsgCrl == NULL) goto ErrorReturn;

    pCert = FindCertWithKey(dwSignKeySpec);
    if (pCert == NULL) {
        PrintError("Couldn't find a cert having a key provider");
        goto ErrorReturn;
    } else if (fVerbose) {
        printf("-----  Signer  -----\n");
        DisplayCert(pCert);
    }

#ifdef CMS_PKCS7
    if (fHashEncryptionAlgorithm) {
        pPara->HashEncryptionAlgorithm = pCert->pCertInfo->SignatureAlgorithm;
    }
#endif  // CMS_PKCS7

    pPara->pSigningCert = pCert;
    pPara->cMsgCert = 1;
    pPara->rgpMsgCert[0] = pCert;

    // Add the cert's issuer certs to the message. Add the issuer CRLs to
    // the message.
    while (TRUE) {
        dwFlags = 0;
        pIssuer = CertGetIssuerCertificateFromStore(
            hCertStore,
            pCert,
            NULL,           // pPrevIssuerContext
            &dwFlags
            );
        if (pIssuer == NULL) break;
        if (pPara->cMsgCert == MAX_MSG_CERT) {
            PrintError("cMsgCert == MAX_MSG_CERT");
            CertFreeCertificateContext(pIssuer);
            break;
        }
        pCert = pIssuer;
        pPara->rgpMsgCert[pPara->cMsgCert++] = pCert;

        pCrl = NULL;
        while (TRUE) {
            dwFlags = 0;
            pCrl = CertGetCRLFromStore(
                pIssuer->hCertStore,
                pIssuer,
                pCrl,
                &dwFlags
                );
            if (pCrl == NULL) break;
            if (pPara->cMsgCrl == MAX_MSG_CRL) {
                PrintError("cMsgCrl == MAX_MSG_CRL");
                CertFreeCRLContext(pCrl);
                break;
            }
            pPara->rgpMsgCrl[pPara->cMsgCrl++] = CertDuplicateCRLContext(pCrl);
        }
    }

    if (fAuthAttr) {
        pPara->cAuthAttr = AUTH_ATTR_COUNT;
        pPara->rgAuthAttr = rgAuthAttr;
    }

    if (fVerbose) {
        DWORD i;

        printf("Msg Certs: %d MsgCrls: %d\n", pPara->cMsgCert, pPara->cMsgCrl);
        for (i = 0; i < pPara->cMsgCert; i++) {
            printf("-----  Msg Cert[%i]  -----\n", i);
            DisplayCert(pPara->rgpMsgCert[i]);
        }
        for (i = 0; i < pPara->cMsgCrl; i++) {
            printf("-----  Msg Crl[%i]  -----\n", i);
            DisplayCrl(pPara->rgpMsgCrl[i]);
        }
    }
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeSignPara(pPara);
    fResult = FALSE;
CommonReturn:
    return fResult;
}

static void FreeSignPara(IN PCRYPT_SIGN_MESSAGE_PARA pPara)
{
    while (pPara->cMsgCert-- > 0)
        CertFreeCertificateContext(pPara->rgpMsgCert[pPara->cMsgCert]);
    while (pPara->cMsgCrl-- > 0)
        CertFreeCRLContext(pPara->rgpMsgCrl[pPara->cMsgCrl]);

    if (pPara->rgpMsgCert)
        TestFree(pPara->rgpMsgCert);
    if (pPara->rgpMsgCrl)
        TestFree(pPara->rgpMsgCrl);
    memset(pPara, 0, sizeof(*pPara));
}

static PCCERT_CONTEXT WINAPI GetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields are used
    IN HCERTSTORE hMsgCertStore
    )
{
    if (fVerbose)
        printf("GetSignerCertificate pSignerId = 0x%p\n", pSignerId);
    return CertGetSubjectCertificateFromStore(hMsgCertStore, dwCertEncodingType,
        pSignerId);
}

static BOOL InitVerifyPara(OUT PCRYPT_VERIFY_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream)
        pPara->dwMsgAndCertEncodingType |= SCA_STREAM_ENABLE_FLAG;
#endif
    pPara->hCryptProv = 0;
#ifdef CMS_PKCS7
    if (!fDefaultGetSigner)
#endif
        pPara->pfnGetSignerCertificate = GetSignerCertificate;
    return TRUE;
}

static void FreeVerifyPara(IN PCRYPT_VERIFY_MESSAGE_PARA pPara)
{
}

#define IV_LENGTH 8
static BOOL GetIV(BYTE rgbIV[IV_LENGTH])
{

    SYSTEMTIME st;
    GetSystemTime(&st);
    assert(IV_LENGTH == sizeof(FILETIME));
    SystemTimeToFileTime(&st, (LPFILETIME) rgbIV);
    return TRUE;
}


static BOOL InitEncryptPara(
    OUT PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    OUT DWORD *pcRecipientCert,
    OUT PCCERT_CONTEXT **pppRecipientCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    BYTE bIntendedKeyUsage;

    PCRYPT_OBJID_BLOB pAlgPara;

    *pppRecipientCert = NULL;
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    pPara->hCryptProv = 0;

#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream) {
        pPara->dwFlags |= SCA_STREAM_ENABLE_FLAG;
        if (fIndefiniteStream)
            pPara->dwFlags |= SCA_INDEFINITE_STREAM_FLAG;
    }
#endif

#ifdef CMS_PKCS7
    if (fRecipientKeyId)
        pPara->dwFlags |= CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG;

    if (fEncapsulatedContent) {
        pPara->dwFlags |= CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG;
        pPara->dwInnerContentType = CMSG_HASHED;
    }
#endif  // CMS_PKCS7

    if (NULL == (pPara->ContentEncryptionAlgorithm.pszObjId = (LPSTR) GetOID(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown encrypt name (%s)\n", pszEncryptName);
        goto ErrorReturn;
    }
    pAlgPara = &pPara->ContentEncryptionAlgorithm.Parameters;

    if (0 != dwEncryptBitLen && CALG_RC2 == GetAlgid(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID)) {
        if (fEncryptIV) {
            CRYPT_RC2_CBC_PARAMETERS RC2Parameters;

            switch (dwEncryptBitLen) {
                case 40:
                    RC2Parameters.dwVersion = CRYPT_RC2_40BIT_VERSION;
                    break;
                case 64:
                    RC2Parameters.dwVersion = CRYPT_RC2_64BIT_VERSION;
                    break;
                case 128:
                    RC2Parameters.dwVersion = CRYPT_RC2_128BIT_VERSION;
                    break;
                default:
                    printf("Failed => unknown RC2 length (%d)\n",
                        dwEncryptBitLen);
                    goto ErrorReturn;
            }
            RC2Parameters.fIV = fEncryptIV;
            if (fEncryptIV) {
                if (!GetIV(RC2Parameters.rgbIV))
                    goto ErrorReturn;
            }

            if (!AllocAndEncodeObject(
                    PKCS_RC2_CBC_PARAMETERS,
                    &RC2Parameters,
                    &pAlgPara->pbData,
                    &pAlgPara->cbData))
                goto ErrorReturn;
        } else {
            RC2AuxInfo.cbSize = sizeof(RC2AuxInfo);
            RC2AuxInfo.dwBitLen = dwEncryptBitLen;
            pPara->pvEncryptionAuxInfo = &RC2AuxInfo;
#ifdef CMS_PKCS7
            if (fSP3Encrypt)
                RC2AuxInfo.dwBitLen |= CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
#endif
        }
    } else if (CALG_RC4 == GetAlgid(pszEncryptName,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID)) {
        if (fEncryptIV) {
            CRYPT_DATA_BLOB Salt;
            DWORD i;

            for (i = 0; i < MAX_SALT_LEN; i++)
                rgbSalt[i] = (BYTE) i;

            Salt.cbData = MAX_SALT_LEN;
            Salt.pbData = rgbSalt;

            if (!AllocAndEncodeObject(
                    X509_OCTET_STRING,
                    &Salt,
                    &pAlgPara->pbData,
                    &pAlgPara->cbData
                    ))
                goto ErrorReturn;
        } else if (0 != dwEncryptBitLen) {
            memset(&RC4AuxInfo, 0, sizeof(RC4AuxInfo));
            RC4AuxInfo.cbSize = sizeof(RC4AuxInfo);
            RC4AuxInfo.dwBitLen = dwEncryptBitLen;
            if (fNoSalt)
                RC4AuxInfo.dwBitLen |= CMSG_RC4_NO_SALT_FLAG;
            pPara->pvEncryptionAuxInfo = &RC4AuxInfo;
        }
    } else if (fEncryptIV) {
        BYTE rgbIV[IV_LENGTH];
        CRYPT_DATA_BLOB Data;

        Data.pbData = rgbIV;
        Data.cbData = sizeof(rgbIV);

        if (!GetIV(rgbIV))
            goto ErrorReturn;
        if (!AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Data,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    else if (fSP3Encrypt) {
        RC2AuxInfo.cbSize = sizeof(RC2AuxInfo);
        RC2AuxInfo.dwBitLen = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        pPara->pvEncryptionAuxInfo = &RC2AuxInfo;
    }
#endif

    *pcRecipientCert = 0;
    *pppRecipientCert = (PCCERT_CONTEXT*) TestAlloc(
        sizeof(PCCERT_CONTEXT) * MAX_RECIPIENT_CERT);
    if (*pppRecipientCert == NULL) goto ErrorReturn;

#ifdef CMS_PKCS7
    if (fNoRecipients)
        ;
    else if (fAllRecipients) {
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hCertStore, pCert)) {
            if (*pcRecipientCert == MAX_RECIPIENT_CERT) {
                PrintError("cRecipientCert == MAX_RECIPIENT_CERT");
                CertFreeCertificateContext(pCert);
                break;
            }
            (*pppRecipientCert)[*pcRecipientCert] =
                CertDuplicateCertificateContext(pCert);
            *pcRecipientCert += 1;
        }
    } else
#endif  // CMS_PKCS7
    if (0 != dwPubKeyBitLen && !IsDSSProv(dwCryptProvType)) {
        // Get exchange cert of the specified key length
        pCert = FindCertWithKey(AT_KEYEXCHANGE);
        if (pCert == NULL) {
            printf(
                "Failed => couldn't find an exchange cert with key length (%d)\n",
                    dwPubKeyBitLen);
            goto ErrorReturn;
        } else {
            (*pppRecipientCert)[*pcRecipientCert] = pCert;
            *pcRecipientCert += 1;
        }
    } else {
        // Find certificates in the store with xchg key usage
        pCert = NULL;
        while (TRUE) {
            pCert = CertEnumCertificatesInStore(
                hCertStore,
                pCert);
            if (pCert == NULL)
                break;

            CertGetIntendedKeyUsage(
                dwCertEncodingType,
                pCert->pCertInfo,
                &bIntendedKeyUsage,
                1                   // cbKeyUsage
                );
            if (bIntendedKeyUsage &
                    (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                        CERT_DATA_ENCIPHERMENT_KEY_USAGE |
                        CERT_KEY_AGREEMENT_KEY_USAGE)) {
                if (*pcRecipientCert == MAX_RECIPIENT_CERT) {
                    PrintError("cRecipientCert == MAX_RECIPIENT_CERT");
                    CertFreeCertificateContext(pCert);
                    break;
                }
                (*pppRecipientCert)[*pcRecipientCert] =
                    CertDuplicateCertificateContext(pCert);
                *pcRecipientCert += 1;
            }
        }
    }

#ifdef CMS_PKCS7
    if (fNoRecipients)
        ;
    else
#endif  // CMS_PKCS7
    if (*pcRecipientCert == 0) {
        PrintError("Couldn't find a recipient xchg cert");
        goto ErrorReturn;
    } else {
        DWORD i;

        if (fVerbose)
            printf("Recipient Certs: %d\n", *pcRecipientCert);
        for (i = 0; i < *pcRecipientCert; i++) {
            if (fVerbose) {
                printf("-----  Recipient Cert[%i]  -----\n", i);
                DisplayCert((*pppRecipientCert)[i]);
            }

            if (!fDhRecipient) {
                PCERT_INFO pCertInfo = (*pppRecipientCert)[i]->pCertInfo;
                PCERT_PUBLIC_KEY_INFO pPublicKeyInfo =
                    &pCertInfo->SubjectPublicKeyInfo;
                PCCRYPT_OID_INFO pOIDInfo;
                ALG_ID aiPubKey;

                if (pOIDInfo = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        pPublicKeyInfo->Algorithm.pszObjId,
                        CRYPT_PUBKEY_ALG_OID_GROUP_ID))
                    aiPubKey = pOIDInfo->Algid;
                else
                    aiPubKey = 0;

                if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM) {
                    printf("Has Diffie Hellman recipients\n");
                    fDhRecipient = TRUE;
                }
            }
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeEncryptPara(pPara, *pcRecipientCert, *pppRecipientCert);
    *pcRecipientCert = 0;
    *pppRecipientCert = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

static void FreeEncryptPara(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT *ppRecipientCert
    )
{
    TestFree(pPara->ContentEncryptionAlgorithm.Parameters.pbData);
    pPara->ContentEncryptionAlgorithm.Parameters.pbData = NULL;
    if (ppRecipientCert) {
        while (cRecipientCert-- > 0) {
            CertFreeCertificateContext(ppRecipientCert[cRecipientCert]);
        }
        TestFree(ppRecipientCert);
    }
}

static BOOL InitDecryptPara(OUT PCRYPT_DECRYPT_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream)
        pPara->dwMsgAndCertEncodingType |= SCA_STREAM_ENABLE_FLAG;
#endif
    pPara->rghCertStore = (HCERTSTORE*) TestAlloc(sizeof(HCERTSTORE));


    if (fSilentKey)
        pPara->dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;

    if (pPara->rghCertStore) {
        pPara->rghCertStore[0] = hCertStore;
        pPara->cCertStore = 1;
        return TRUE;
    } else
        return FALSE;
}

static void FreeDecryptPara(IN PCRYPT_DECRYPT_MESSAGE_PARA pPara)
{
    if (pPara->rghCertStore) {
        TestFree(pPara->rghCertStore);
        pPara->rghCertStore = 0;
    }
}

static BOOL InitHashPara(OUT PCRYPT_HASH_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    pPara->hCryptProv = 0;
    if (NULL == (pPara->HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s)\n", pszHashName);
        return FALSE;
    }
    return TRUE;
}

static void FreeHashPara(IN PCRYPT_HASH_MESSAGE_PARA pPara)
{
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            NULL,                   // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("DecodeName::CryptDecodeObject(cbInfo == 0)");
        goto ErrorReturn;
    }
    pInfo = (PCERT_NAME_INFO) TestAlloc(cbInfo);
    if (pInfo == NULL) goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbEncoded,
            cbEncoded,
            0,                              // dwFlags
            pInfo,
            &cbInfo
            )) {
        PrintLastError("DecodeName::CryptDecodeObject");
        goto ErrorReturn;
    }

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            if ((pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                printf("  [%d,%d] %s ValueType: %d\n",
                    i, j, pszObjId, pAttr->dwValueType);
            } else
                printf("  [%d,%d] %s %s\n",
                    i, j, pszObjId, pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DisplayCert(PCCERT_CONTEXT pCert)
{
    printf("Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData);
    printf("Issuer::\n");
    DecodeName(pCert->pCertInfo->Issuer.pbData,
        pCert->pCertInfo->Issuer.cbData);

    {
        DWORD cb;
        BYTE *pb;
        printf("SerialNumber::");
        for (cb = pCert->pCertInfo->SerialNumber.cbData,
             pb = pCert->pCertInfo->SerialNumber.pbData + (cb - 1);
                                                        cb > 0; cb--, pb--) {
            printf(" %02X", *pb);
        }
        printf("\n");
    }
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i; 

    for (i = 0; i < cEntry; i++, pEntry++) {
        DWORD cb;
        BYTE *pb;
        printf(" [%d] SerialNumber::", i);
        for (cb = pEntry->SerialNumber.cbData,
             pb = pEntry->SerialNumber.pbData + (cb - 1); cb > 0; cb--, pb++) {
            printf(" %02X", *pb);
        }
        printf("\n");

    }
}

static void DisplayCrl(PCCRL_CONTEXT pCrl)
{
    printf("Issuer::\n");
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
        pCrl->pCrlInfo->Issuer.cbData);

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tsstore\tsstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tsstore.cpp
//
//  Contents:   System Store Tests: Register, Unregister or Enum
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    26-Aug-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf(
      "Usage: tsstore [options] <TestName> [<SystemName> [<PhysicalName>]]\n");
    printf("Options are:\n");
    printf("  -h                            - This message\n");
    printf("  -e<Expected Error>            - For example, -e0x0\n");
    printf("  -f<number>                    - Flags (excludes store location)\n");
    printf("  -P<string>                    - Store Location Parameter\n");
    printf("  -R<string>                    - Current User Relocate\n");
    printf("  -RHKCU\\<string>               - Current User Relocate\n");
    printf("  -RHKLM\\<string>               - Local Machine Relocate\n");
    printf("  -RNULL                        - Test NULL HKEY Relocate\n");
    printf("  -v                            - Verbose\n");
    printf("\n");
    printf("Store Location:\n");
    printf("  -lCurrentUser                 - Store Location: CurrentUser\n");
    printf("  -lLocalMachine                - Store Location: LocalMachine\n");
    printf("  -lCurrentService              - Store Location: CurrentService\n");
    printf("  -lServices                    - Store Location: Services\n");
    printf("  -lUsers                       - Store Location: Users\n");
    printf("  -lCUGP                        - Store Location: CU GroupPolicy\n");
    printf("  -lLMGP                        - Store Location: LM GroupPolicy\n");
    printf("  -lEnterprise                  - Store Location: LM Enterprise\n");
    printf("  -L<number>                    - Store Location: ID Number\n");
    printf("\n");
    printf("RegPhy parameters:\n");
    printf("  -pOpenStoreProvider <string>  - For example, System\n");
    printf("  -pOpenStoreProvider #<number> - For example, #10\n");
    printf("  -pOpenParameters <string>     - For example, My\n");
    printf("  -pOpenEncodingType <number>   - For example, 0x00010001\n");
    printf("  -pOpenFlags <number>          - For example, 0x00010000\n");
    printf("  -pFlags <number>              - For example, 0x1\n");
    printf("  -pPriority <number>           - For example, 0\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Enum                          - Enum ALL recursively, default\n");
    printf("  EnumLoc                       - Enum store locations\n");
    printf("  EnumSys                       - Enum -l or -L store location\n");
    printf("  EnumPhy <SysName>             - Enum physical stores\n");
    printf("  RegSys <SysName>              - Register system store\n");
    printf("  UnregSys <SysName>            - Unregister, delete system store\n");
    printf("  RegPhy <SysName> <PhyName>    - Register physical store\n");
    printf("  UnregPhy <SysName> <PhyName>  - Unregister physical store\n");
    printf("\n");
    printf("Defaults:\n");
    printf("  Enum\n");
    printf("  -e0x0\n");
    printf("  -f0x0\n");
    printf("  -lCurrentUser\n");
    printf("  -pOpenStoreProvider System\n");
    printf("\n");
}


#define SYSTEM_STORE_PROVIDER_FLAG   0x1
#define ASCII_STORE_PROVIDER_FLAG    0x2
#define UNICODE_STORE_PROVIDER_FLAG  0x4

#define CONST_OID_STR_PREFIX_CHAR   '#'

static DWORD GetStoreProviderTypeFlags(
    IN LPCSTR pszStoreProvider
    )
{
    DWORD dwFlags = 0;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    dwFlags = UNICODE_STORE_PROVIDER_FLAG;
    if (CERT_STORE_PROV_FILENAME_A == pszStoreProvider)
        dwFlags = ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_FILENAME_W == pszStoreProvider)
        dwFlags = UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (0xFFFF < (DWORD_PTR) pszStoreProvider) {
        if (0 == _stricmp(sz_CERT_STORE_PROV_FILENAME_W, pszStoreProvider))
            dwFlags = UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W, pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_PHYSICAL_W,
                pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    }

    return dwFlags;
}

static BOOL IsSystemStoreProvider(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        SYSTEM_STORE_PROVIDER_FLAG;
}
static BOOL IsAsciiOpenParameters(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        ASCII_STORE_PROVIDER_FLAG;
}

static BOOL IsUnicodeOpenParameters(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        UNICODE_STORE_PROVIDER_FLAG;
}

static void DisplayOpenFlags(
    IN LPCSTR pszHdr,
    IN LPCSTR pszStoreProvider,
    IN DWORD dwFlags
    )
{
    printf("%s = 0x%x :: ", pszHdr, dwFlags);
    if (IsSystemStoreProvider(pszStoreProvider)) {
        DWORD dwLocationID = (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
            CERT_SYSTEM_STORE_LOCATION_SHIFT;
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwLocationID)
            printf("CurrentUser");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwLocationID)
            printf("LocalMachine");
        else if (CERT_SYSTEM_STORE_CURRENT_SERVICE_ID == dwLocationID)
            printf("CurrentService");
        else if (CERT_SYSTEM_STORE_SERVICES_ID == dwLocationID)
            printf("Services");
        else if (CERT_SYSTEM_STORE_USERS_ID == dwLocationID)
            printf("Users");
        else if (CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID ==
                dwLocationID)
            printf("CurrentUserGroupPolicy");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID ==
                dwLocationID)
            printf("LocalMachineGroupPolicy");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID ==
                dwLocationID)
            printf("LocalMachineEnterprise");
        else
            printf("StoreLocation = %d", dwLocationID);
    }

    if (dwFlags & CERT_STORE_DELETE_FLAG)
        printf(", DELETE");
    if (dwFlags & CERT_STORE_READONLY_FLAG)
        printf(", READONLY");
    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        printf(", BACKUP_RESTORE");
    if (dwFlags & CERT_STORE_OPEN_EXISTING_FLAG)
        printf(", OPEN_EXISTING");
    if (dwFlags & CERT_STORE_CREATE_NEW_FLAG)
        printf(", CREATE_NEW");
    if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG)
        printf(", MAXIMUM_ALLOWED");
    if (dwFlags & CERT_STORE_MANIFOLD_FLAG)
        printf(", MANIFOLD");
    if (dwFlags & CERT_STORE_ENUM_ARCHIVED_FLAG)
        printf(", ENUM_ARCHIVED");
    if (dwFlags & CERT_STORE_UPDATE_KEYID_FLAG)
        printf(", UPDATE_KEYID");
    printf("\n");
}

static void DisplayPhysicalStoreInfo(
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo
    )
{
    DWORD dwFlags;
    LPCSTR pszStoreProvider = pStoreInfo->pszOpenStoreProvider;
    if (0xFFFF >= (DWORD_PTR) pszStoreProvider)
        printf("      OpenStoreProvider: %d", (DWORD)(DWORD_PTR) pszStoreProvider);
    else
        printf("      OpenStoreProvider: %s", pszStoreProvider);

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);
    if (0xFFFF >= (DWORD_PTR) pszStoreProvider) {
        if (CERT_STORE_PROV_FILENAME_A == pszStoreProvider)
            printf(" (FILENAME_A)");
        else if (CERT_STORE_PROV_FILENAME_W == pszStoreProvider)
            printf(" (FILENAME_W)");
        else if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
            printf(" (SYSTEM_A)");
        else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
            printf(" (SYSTEM_W)");
        else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
            printf(" (SYSTEM_REGISTRY_A)");
        else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
            printf(" (SYSTEM_REGISTRY_W)");
        else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
            printf(" (PHYSICAL_W)");
    }
    printf("\n");

    printf("      OpenEncodingType: 0x%x\n", pStoreInfo->dwOpenEncodingType);
    DisplayOpenFlags("      OpenFlags", pStoreInfo->pszOpenStoreProvider,
        pStoreInfo->dwOpenFlags);

    if (0 == pStoreInfo->OpenParameters.cbData)
        printf("      OpenParameters:: NONE\n");
    else if (IsSystemStoreProvider(pStoreInfo->pszOpenStoreProvider)) {
        if (IsUnicodeOpenParameters(pStoreInfo->pszOpenStoreProvider))
            printf("      OpenParameters: %S\n",
                pStoreInfo->OpenParameters.pbData);
        else
            printf("      OpenParameters: %s\n",
                pStoreInfo->OpenParameters.pbData);
    } else {
        printf("      OpenParameters::\n");
        PrintBytes("        ",
            pStoreInfo->OpenParameters.pbData,
            pStoreInfo->OpenParameters.cbData
            );
    }

    dwFlags = pStoreInfo->dwFlags;
    printf("      Flags: 0x%x", dwFlags);
    if (dwFlags)
        printf(" ::");
    if (dwFlags & CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG)
        printf(" ADD_ENABLE");
    if (dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG)
        printf(" OPEN_DISABLE");
    if (dwFlags & CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)
        printf(" REMOTE_OPEN_DISABLE_FLAG");
    if (dwFlags & CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG)
        printf(" INSERT_COMPUTER_NAME_ENABLE_FLAG");
    printf("\n");

    printf("      Priority: %d\n", pStoreInfo->dwPriority);
}

typedef struct _ENUM_ARG {
    BOOL        fAll;
    BOOL        fVerbose;
    DWORD       dwFlags;
    const void  *pvStoreLocationPara;
    HKEY        hKeyBase;
} ENUM_ARG, *PENUM_ARG;

static BOOL GetSystemName(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PENUM_ARG pEnumArg,
    OUT LPCWSTR *ppwszSystemName
    )
{

    *ppwszSystemName = NULL;

    if (pEnumArg->hKeyBase &&
            0 == (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)) {
        printf("failed => RELOCATE_FLAG not set in callback\n");
        return FALSE;
    } else if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara;

        if (NULL == pEnumArg->hKeyBase) {
            printf("failed => RELOCATE_FLAG is set in callback\n");
            return FALSE;
        }
        pRelocatePara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemStore;
        if (pRelocatePara->hKeyBase != pEnumArg->hKeyBase) {
            printf("failed => wrong hKeyBase passed to callback\n");
            return FALSE;
        }
        *ppwszSystemName = pRelocatePara->pwszSystemStore;
    } else
        *ppwszSystemName = (LPCWSTR) pvSystemStore;
    return TRUE;
}

static BOOL WINAPI EnumPhyCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    LPCWSTR pwszSystemStore;

    if (!GetSystemName(pvSystemStore, dwFlags, pEnumArg, &pwszSystemStore))
        return FALSE;

    printf("    %S", pwszStoreName);
    if (pEnumArg->fVerbose &&
            (dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG))
        printf(" (implicitly created)");
    printf("\n");
    if (pEnumArg->fVerbose)
        DisplayPhysicalStoreInfo(pStoreInfo);
    return TRUE;
}


static BOOL WINAPI EnumSysCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    LPCWSTR pwszSystemStore;

    if (!GetSystemName(pvSystemStore, dwFlags, pEnumArg, &pwszSystemStore))
        return FALSE;

    printf("  %S\n", pwszSystemStore);
    if (pEnumArg->fAll || pEnumArg->fVerbose) {
        dwFlags &= CERT_SYSTEM_STORE_MASK;
        dwFlags |= pEnumArg->dwFlags & ~CERT_SYSTEM_STORE_MASK;
        if (!CertEnumPhysicalStore(
                pvSystemStore,
                dwFlags,
                pEnumArg,
                EnumPhyCallback
                )) {
            DWORD dwErr = GetLastError();
            if (!(ERROR_FILE_NOT_FOUND == dwErr ||
                    ERROR_NOT_SUPPORTED == dwErr))
                PrintLastError("    CertEnumPhysicalStore");
        }
    }
    return TRUE;
}

static BOOL WINAPI EnumLocCallback(
    IN LPCWSTR pwszStoreLocation,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    DWORD dwLocationID = (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT;

    printf("======   %S   ======\n", pwszStoreLocation);

    if (pEnumArg->fAll) {
        dwFlags &= CERT_SYSTEM_STORE_MASK;
        dwFlags |= pEnumArg->dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK;
        if (!CertEnumSystemStore(
                dwFlags,
                (void *) pEnumArg->pvStoreLocationPara,
                pEnumArg,
                EnumSysCallback
                )) {
            DWORD dwErr = GetLastError();
            if (E_INVALIDARG == dwErr && pEnumArg->pvStoreLocationPara)
                // \\ComputerName, ServiceName, or \\ComputerName\Service
                // not supported for all store locations
                ;
            else if (!(ERROR_FILE_NOT_FOUND == dwErr ||
                    ERROR_PROC_NOT_FOUND == dwErr))
                PrintLastError("  CertEnumSystemStore");
        }
    }
    return TRUE;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status = 0;
    DWORD dwError;
    BOOL fVerbose = FALSE;
    DWORD dwExpectedError = 0;
    DWORD dwLocationID = CERT_SYSTEM_STORE_CURRENT_USER_ID;
    DWORD dwFlags = 0;
    CERT_PHYSICAL_STORE_INFO PhyStoreInfo;
    memset(&PhyStoreInfo, 0, sizeof(PhyStoreInfo));
    PhyStoreInfo.cbSize = sizeof(PhyStoreInfo);
    PhyStoreInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_SYSTEM_W;

    ENUM_ARG EnumArg;

    LPSTR pszStoreParameters = NULL;            // not allocated
    LPSTR pszStoreLocationPara = NULL;          // not allocated 
    LPWSTR pwszStoreParameters = NULL;
    LPWSTR pwszSystemName = NULL;
    LPWSTR pwszPhysicalName = NULL;
    LPWSTR pwszStoreLocationPara = NULL;

    void *pvSystemName;                         // not allocated
    void *pvStoreLocationPara;                  // not allocated

#define TEST_NAME_INDEX     0
#define SYS_NAME_INDEX      1
#define PHY_NAME_INDEX      2
#define MAX_NAME_CNT        3
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;

    BOOL fRelocate = FALSE;
    HKEY hKeyRelocate = HKEY_CURRENT_USER;
    LPSTR pszRelocate = NULL;                   // not allocated
    CERT_SYSTEM_STORE_RELOCATE_PARA SystemNameRelocatePara;
    CERT_SYSTEM_STORE_RELOCATE_PARA StoreLocationRelocatePara;
    HKEY hKeyBase = NULL;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'l':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "CurrentUser"))
                        dwLocationID = CERT_SYSTEM_STORE_CURRENT_USER_ID;
                    else if (0 == _stricmp(argv[0]+2, "LocalMachine"))
                        dwLocationID = CERT_SYSTEM_STORE_LOCAL_MACHINE_ID;
                    else if (0 == _stricmp(argv[0]+2, "CurrentService"))
                        dwLocationID = CERT_SYSTEM_STORE_CURRENT_SERVICE_ID;
                    else if (0 == _stricmp(argv[0]+2, "Services"))
                        dwLocationID = CERT_SYSTEM_STORE_SERVICES_ID;
                    else if (0 == _stricmp(argv[0]+2, "Users"))
                        dwLocationID = CERT_SYSTEM_STORE_USERS_ID;
                    else if (0 == _stricmp(argv[0]+2, "CUGP"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID;
                    else if (0 == _stricmp(argv[0]+2, "LMGP"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID;
                    else if (0 == _stricmp(argv[0]+2, "Enterprise"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID;
                    else {
                        printf("Need to specify -l<StoreLocation>\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -l<StoreLocation>\n");
                    goto BadUsage;
                }
                break;
            case 'L':
                dwLocationID = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'P':
                pszStoreLocationPara = argv[0]+2;
                break;
            case 'R':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "NULL")) {
                        hKeyRelocate = NULL;
                        pszRelocate = NULL;
                    } else if (0 == _strnicmp(argv[0]+2, "HKCU", 4)) {
                        hKeyRelocate = HKEY_CURRENT_USER;
                        pszRelocate = argv[0]+2+4;
                        if ('\\' == *pszRelocate)
                            pszRelocate++;
                    } else if (0 == _strnicmp(argv[0]+2, "HKLM", 4)) {
                        hKeyRelocate = HKEY_LOCAL_MACHINE;
                        pszRelocate = argv[0]+2+4;
                        if ('\\' == *pszRelocate)
                            pszRelocate++;
                    } else {
                        hKeyRelocate = HKEY_CURRENT_USER;
                        pszRelocate = argv[0]+2;
                    }
                } else {
                    hKeyRelocate = HKEY_CURRENT_USER;
                    pszRelocate = NULL;
                }
                fRelocate = TRUE;
                break;
            case 'f':
                dwFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'p':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("Option (%s) : missing parameter argument\n",
                        argv[0]);
                    goto BadUsage;
                }

                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "OpenStoreProvider")) {
                        if (CONST_OID_STR_PREFIX_CHAR == argv[1][0])
                            // Convert "#<number>" string to its
                            // corresponding constant OID value
                            PhyStoreInfo.pszOpenStoreProvider =
                                (LPSTR)(DWORD_PTR) atol(argv[1] + 1);
                        else
                            PhyStoreInfo.pszOpenStoreProvider = argv[1];
                    } else if (0 == _stricmp(argv[0]+2, "OpenEncodingType"))
                        PhyStoreInfo.dwOpenEncodingType =
                            strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "OpenFlags"))
                        PhyStoreInfo.dwOpenFlags = strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "OpenParameters"))
                        pszStoreParameters = argv[1];
                    else if (0 == _stricmp(argv[0]+2, "Flags"))
                        PhyStoreInfo.dwFlags = strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "Priority"))
                        PhyStoreInfo.dwPriority = strtoul(argv[1], NULL, 0);
                    else {
                        printf("Invalid -p<ParameterName>\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -p<ParameterName>\n");
                    goto BadUsage;
                }
                argc -= 1;
                argv += 1;
                break;

            case 'v':
                fVerbose = TRUE;
                break;
            case 'e':
                dwExpectedError = strtoul(argv[0]+2, NULL, 0);
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());
    if (pszStoreLocationPara)
        pwszStoreLocationPara = AllocAndSzToWsz(pszStoreLocationPara);

    if (0 == dwNameCnt)
        rgpszName[dwNameCnt++] = "Enum";
    pszTestName = rgpszName[TEST_NAME_INDEX];

    if (SYS_NAME_INDEX < dwNameCnt)
        pwszSystemName = AllocAndSzToWsz(rgpszName[SYS_NAME_INDEX]);
    if (PHY_NAME_INDEX < dwNameCnt)
        pwszPhysicalName = AllocAndSzToWsz(rgpszName[PHY_NAME_INDEX]);

    dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
    dwFlags |= (dwLocationID << CERT_SYSTEM_STORE_LOCATION_SHIFT) &
        CERT_SYSTEM_STORE_LOCATION_MASK;

    DisplayOpenFlags("Flags", sz_CERT_STORE_PROV_SYSTEM_W, dwFlags);


    if (fRelocate) {
        printf("Relocation Enabled:  ");

        if (hKeyRelocate) {
            LONG err;

            if (HKEY_CURRENT_USER == hKeyRelocate)
                printf("HKEY_CURRENT_USER\\%s\n", pszRelocate);
            else if (HKEY_LOCAL_MACHINE == hKeyRelocate)
                printf("HKEY_LOCAL_MACHINE\\%s\n", pszRelocate);
            else
                printf("???\\%s\n", pszRelocate);

            if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                    hKeyRelocate,
                    pszRelocate,
                    0,                      // dwReserved
                    KEY_ALL_ACCESS,
                    &hKeyBase))) {
                printf("RegOpenKeyExA(%s) failed => %d 0x%x\n",
                    pszRelocate, err, err);
                goto ErrorReturn;
            }

        } else
            printf("NULL hKeyBase\n");

        dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

        SystemNameRelocatePara.hKeyBase = hKeyBase;
        SystemNameRelocatePara.pwszSystemStore = pwszSystemName;
        pvSystemName = &SystemNameRelocatePara;

        StoreLocationRelocatePara.hKeyBase = hKeyBase;
        StoreLocationRelocatePara.pwszSystemStore = pwszStoreLocationPara;
        pvStoreLocationPara = &StoreLocationRelocatePara;
    } else {
        pvSystemName = pwszSystemName;
        pvStoreLocationPara = pwszStoreLocationPara;
    }

    memset(&EnumArg, 0, sizeof(EnumArg));
    EnumArg.fVerbose = fVerbose;
    EnumArg.dwFlags = dwFlags;
    EnumArg.hKeyBase = hKeyBase;
    if (pwszStoreLocationPara) {
        printf("System Store Location Parameter :: %S\n",
            pwszStoreLocationPara);
        EnumArg.pvStoreLocationPara = pvStoreLocationPara;
    } else if (fRelocate)
        EnumArg.pvStoreLocationPara = pvStoreLocationPara;

    {
        WCHAR wszCurrentComputer[_MAX_PATH + 1];
        DWORD cch = _MAX_PATH;
        if (!GetComputerNameU(wszCurrentComputer, &cch))
            PrintLastError("GetComputeName");
        else
            printf("CurrentComputer :: %S\n", wszCurrentComputer);
    }

    printf("\n");
    if (0 == _stricmp("Enum", pszTestName)) {
        printf("Enumeration of ALL System Stores\n\n");
        EnumArg.fAll = TRUE;
        fResult = CertEnumSystemStoreLocation(
            dwFlags,
            &EnumArg,
            EnumLocCallback
            );
    } else if (0 == _stricmp("EnumLoc", pszTestName)) {
        printf("Enumeration of System Store Locations\n\n");
        fResult = CertEnumSystemStoreLocation(
            dwFlags,
            &EnumArg,
            EnumLocCallback
            );
    } else if (0 == _stricmp("EnumSys", pszTestName)) {
        printf("Enumeration of System Stores\n\n");
        fResult = CertEnumSystemStore(
            dwFlags,
            pvStoreLocationPara,
            &EnumArg,
            EnumSysCallback
            );
    } else if (0 == _stricmp("EnumPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }

        printf("Enumeration of Physical Stores for System Store %S\n",
            pwszSystemName);

        fResult = CertEnumPhysicalStore(
            pvSystemName,
            dwFlags,
            &EnumArg,
            EnumPhyCallback
            );
    } else if (0 == _stricmp("RegSys", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        printf("Registering System Store %S\n", pwszSystemName);
        fResult = CertRegisterSystemStore(
            pvSystemName,
            dwFlags,
            NULL,           // pSystemStoreInfo
            NULL            // pvReserved
            );
    } else if (0 == _stricmp("UnregSys", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        printf("Unregistering System Store %S\n", pwszSystemName);
        fResult = CertUnregisterSystemStore(
            pvSystemName,
            dwFlags
            );
        if (!fResult && 0 == dwExpectedError) {
            if (ERROR_FILE_NOT_FOUND == GetLastError()) {
                if (fVerbose)
                    printf("System store doesn't exist\n");
                fResult = TRUE;
            }
        }
    } else if (0 == _stricmp("RegPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        if (NULL == pwszPhysicalName) {
            printf("Missing <PhysicalName>\n");
            goto BadUsage;
        }
        printf("Registering Physical Store (%S) in System Store (%S)\n",
            pwszPhysicalName, pwszSystemName);

        if (pszStoreParameters) {
            if (IsUnicodeOpenParameters(PhyStoreInfo.pszOpenStoreProvider)) {
                if (pwszStoreParameters = AllocAndSzToWsz(
                        pszStoreParameters)) {
                    PhyStoreInfo.OpenParameters.pbData =
                        (BYTE *) pwszStoreParameters;
                    PhyStoreInfo.OpenParameters.cbData =
                        (wcslen(pwszStoreParameters) + 1) * sizeof(WCHAR);
                }
            } else {
                PhyStoreInfo.OpenParameters.pbData =
                    (BYTE *) pszStoreParameters;
                PhyStoreInfo.OpenParameters.cbData =
                    strlen(pszStoreParameters) + 1;
            }
        }
        printf("Physical Store Info::\n");
            DisplayPhysicalStoreInfo(&PhyStoreInfo);
        fResult = CertRegisterPhysicalStore(
            pvSystemName,
            dwFlags,
            pwszPhysicalName,
            &PhyStoreInfo,
            NULL            // pvReserved
            );
    } else if (0 == _stricmp("UnregPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        if (NULL == pwszPhysicalName) {
            printf("Missing <PhysicalName>\n");
            goto BadUsage;
        }
        printf("Unregistering Physical Store (%S) in System Store (%S)\n",
            pwszPhysicalName, pwszSystemName);
        fResult = CertUnregisterPhysicalStore(
            pvSystemName,
            dwFlags,
            pwszPhysicalName
            );
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    printf("\n");

    if (fResult) {
        dwError = 0;
        printf("Successful %s\n", pszTestName);
    } else
        dwError = GetLastError();

    if (dwError != dwExpectedError) {
        if (!fResult)
            PrintLastError(pszTestName);
        status = -1;
        printf("Failed. Expected error => 0x%x (%d) \n",
            dwExpectedError, dwExpectedError);
    } else
        status = 0;

CommonReturn:
    if (hKeyBase)
        RegCloseKey(hKeyBase);
    TestFree(pwszStoreParameters);
    TestFree(pwszSystemName);
    TestFree(pwszPhysicalName);
    TestFree(pwszStoreLocationPara);
    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstgdir\tstgdir.cpp ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993
//
//  File:       tstgdir.cpp
//
//  Contents:   Recursive directory display of a storage
//              document
//
//  Functions:	main
//
//  History:    04 Nov 94 - Created by philh
//
//-------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>



static int indent = 0;
static BOOL fVerbose = FALSE;
static BOOL fDebug = FALSE;
static BOOL fRead  = FALSE;
static BOOL fReadVerbose  = FALSE;
static BOOL fBrief  = FALSE;

#define READ_BUF_SIZE 10000
static BYTE readBuf[READ_BUF_SIZE];

static CLSID NullClsid;


typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    E_NOINTERFACE, "E_NOINTERFACE",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))


// Convert a HRESULT to text
static char *hResultText(HRESULT hResult)
{
    static char buf[80];
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == hResult)
	    return scodes[i].text;
    sprintf(buf, "%lx", hResult);
    return buf;
}

static void DirPrintf(const char * Format, ...)
{
    int i = indent;
    va_list pArgs;
    char    aBuf[256];

    while (i-- > 0)
        printf("  ");

    va_start( pArgs, Format );
    vsprintf(aBuf, Format, pArgs);
    printf("%s", aBuf);
}


#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

static char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}

static char *FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;
        
    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

static void DispStatStg(STATSTG *pStatStg)
{
    char *szSTGTY;

    switch (pStatStg->type) {
        case STGTY_STORAGE:
            szSTGTY = "STGTY_STORAGE";
            break;
        case STGTY_STREAM:
            szSTGTY = "STGTY_STREAM";
            break;
        case STGTY_LOCKBYTES:
            szSTGTY = "STGTY_LOCKBYTES";
            break;
        default:
            szSTGTY = "STGTY_???";
    }

    
    if (pStatStg->type == STGTY_STREAM)
        DirPrintf("%S %s size:%ld\n", pStatStg->pwcsName, szSTGTY,
            pStatStg->cbSize.LowPart);
    else {
        DirPrintf("%S %s\n", pStatStg->pwcsName, szSTGTY);
        if (!fBrief && pStatStg->clsid != NullClsid)
            DirPrintf("CLSID: %s\n", GuidText(&pStatStg->clsid));
    }
    if (fVerbose) {
        DirPrintf("size: %ld,%ld Mode: %lx StateBits: %lx Locks: %ld\n",
            pStatStg->cbSize.HighPart, pStatStg->cbSize.LowPart,
            pStatStg->grfMode, pStatStg->grfStateBits,
            pStatStg->grfLocksSupported);
        if ((pStatStg->mtime.dwHighDateTime != 0) ||
            (pStatStg->mtime.dwLowDateTime != 0))
            DirPrintf("mtime %s\n", FileTimeText(&pStatStg->mtime));
        if ((pStatStg->ctime.dwHighDateTime != 0) ||
            (pStatStg->ctime.dwLowDateTime != 0))
            DirPrintf("ctime %s\n", FileTimeText(&pStatStg->ctime));
        if ((pStatStg->atime.dwHighDateTime != 0) ||
            (pStatStg->atime.dwLowDateTime != 0))
            DirPrintf("atime %s\n", FileTimeText(&pStatStg->atime));
    }
}

#define CROW 16
void BinText(ULONG cbSize, BYTE *pb)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

void DispStream(IStream *pstm);
void DispStorage(IStorage *pstg);


void DispStream(IStream *pstm)
{
    HRESULT hResult;
    STATSTG statStg;

	hResult = pstm->Stat(&statStg, STATFLAG_DEFAULT);
    if (SUCCEEDED(hResult)) {
        DispStatStg(&statStg);
        if (statStg.pwcsName != NULL)
            CoTaskMemFree(statStg.pwcsName);
    } else {
        DirPrintf("Stat => %lx\n", hResult);
        return;
    }

    if (fRead) {
	    ULONG ulTotalRead = 0;
	    ULONG ulBytesRead;
        int i = 0;
        while (TRUE) {
            ulBytesRead = 0;
            hResult = pstm->Read(readBuf, READ_BUF_SIZE, &ulBytesRead);
            if (FAILED(hResult)) {
                DirPrintf("IStream->Read => %lx\n", hResult);
                break;
            }
            if (fReadVerbose) {
                DirPrintf("%lu bytes starting at offset: 0x%08lX\n",
                    ulBytesRead, ulTotalRead);
                BinText(ulBytesRead, readBuf);
            }
            ulTotalRead += ulBytesRead;
            if (ulBytesRead < READ_BUF_SIZE)
                break;
            i++;
            if (i % 10 == 0) {
                if (fReadVerbose)
                    DirPrintf("Read %ld bytes\n", ulTotalRead);
                else
                    DirPrintf("Read %ld bytes\r", ulTotalRead);
            }
        }
        DirPrintf("Read %ld bytes\n", ulTotalRead);
    }
}


void DispStorage(IStorage *pstg)
{
    HRESULT	hResult;
    DWORD	grfMode;
    STATSTG statStg;
    CLSID readClsid;

    IStorage *pstgChild;
    IStream *pstmChild;
    IEnumSTATSTG *penumStatStg;

	hResult = pstg->Stat(&statStg, STATFLAG_DEFAULT);
    if (SUCCEEDED(hResult)) {
        DispStatStg(&statStg);
        if (statStg.pwcsName != NULL)
            CoTaskMemFree(statStg.pwcsName);
    } else {
        DirPrintf("Stat => %s\n", hResultText(hResult));
        return;
    }
        
    hResult = ReadClassStg(pstg, &readClsid);
    if (SUCCEEDED(hResult)) {
        if (readClsid != statStg.clsid)
            DirPrintf("ReadClassStg CLSID: %s\n", GuidText(&readClsid));
    } else
		DirPrintf("ReadClassStg => %s\n", hResultText(hResult));

    indent += 2;
    hResult = pstg->EnumElements(0, NULL, 0, &penumStatStg);
    if (FAILED(hResult))
		DirPrintf("EnumElements => %lx\n", hResult);
    else {
        while(TRUE) {
            hResult = penumStatStg->Next(1, &statStg, NULL);
            if (hResult == S_FALSE) break;
            if (FAILED(hResult)) {
                DirPrintf("EnumStatStg => %lx\n", hResult);
                break;
            } else {
                switch (statStg.type) {
                case STGTY_STORAGE:
                    if ((statStg.pwcsName == NULL) || 
                        (statStg.pwcsName[0] == L'.'))
                        DispStatStg(&statStg);
                    else {
                        grfMode =
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
                        hResult = pstg->OpenStorage(
                            statStg.pwcsName,
                            NULL,               // pstgPriority
                            grfMode,
                            NULL,               // snbExclude
                            0,                  // dwReserved
                            &pstgChild);
                        if (FAILED(hResult)) {
                            DispStatStg(&statStg);
                            DirPrintf("OpenStorage => %lx\n", hResult);
                        } else {
                            if (fDebug) {
                                DirPrintf("---  Enum  ---\n");
                                DispStatStg(&statStg);
                                DirPrintf("---  Enum  ---\n");
                            }
                            DispStorage(pstgChild);
                            pstgChild->Release();
                        }
                    }
                    break;
                case STGTY_STREAM:
                    if ((statStg.pwcsName == NULL) || 
                        (statStg.pwcsName[0] == L'.'))
                        DispStatStg(&statStg);
                    else {
                        grfMode =
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
                        hResult = pstg->OpenStream(
                            statStg.pwcsName,
                            NULL,               // pReserved1
                            grfMode,
                            0,                  // dwReserved2
                            &pstmChild);
                        if (FAILED(hResult)) {
                            DispStatStg(&statStg);
                            DirPrintf("OpenStream => %lx\n", hResult);
                        } else {
                            if (fDebug) {
                                DirPrintf("---  Enum  ---\n");
                                DispStatStg(&statStg);
                                DirPrintf("---  Enum  ---\n");
                            }
                            DispStream(pstmChild);
                            pstmChild->Release();
                        }
                    }
                    break;
                default:
                    DispStatStg(&statStg);
                }
                if (statStg.pwcsName != NULL)
                    CoTaskMemFree(statStg.pwcsName);
            }
        } // while loop
        penumStatStg->Release();
    }
    indent -= 2;
}

static void Usage(void)
{
    printf("Usage: tstgdir [options] <filename>\n");
    printf("Options are:\n");
    printf("  -h    - This message\n");
    printf("  -b    - Brief\n");
    printf("  -d    - Debug\n");
    printf("  -r    - Read streams (don't display)\n");
    printf("  -R    - Read streams (display contents)\n");
    printf("  -v    - Verbose\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    WCHAR wcsFile[_MAX_PATH];
    HRESULT	hResult;
    DWORD	grfMode;
    IStorage *pstgRoot;

    wcscpy(wcsFile, L"");
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'b':
                fBrief = TRUE;
                break;
            case 'd':
                fDebug = TRUE;
                break;
            case 'R':
                fReadVerbose = TRUE;
            case 'r':
                fRead = TRUE;
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        }
        else
            mbstowcs(wcsFile, argv[0], strlen(argv[0]) + 1);
    }

    if (wcsFile[0] == L'\0') {
        printf("missing filename\n");
        Usage();
        return -1;
    }

    if (fVerbose)
        fBrief = FALSE;


    if (FAILED(hResult = CoInitialize(NULL))) {
        printf("CoInitialize => %s\n", hResultText(hResult));
        return -1;
    }

    grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE;
    hResult = StgOpenStorage(wcsFile,
               NULL,    //pstgPriority
               grfMode,
               NULL,    // snbExclude
               0,       //dwReserved
               &pstgRoot);
    if (FAILED(hResult)) {
        CoUninitialize();
        printf("StgOpenStorage => %s\n", hResultText(hResult));
        return -1;
    }

    DispStorage(pstgRoot);
    pstgRoot->Release();

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\trootlist\trootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trootlist.cpp
//
//  Contents:   Test for the Signed List of Trusted Roots APIs
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    01-Aug-99   philh    created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: trootlist [options] <FileOrUrl>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -U                    - URL (file default)\n");
    printf("  -C                    - Intermediate CAs\n");
    printf("\n");
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status;
    LPCSTR pszFileOrUrl = NULL;     // Not allocated
    LPWSTR pwszUrl = NULL;          // TestAlloc()'ed
    BYTE *pbEncoded = NULL;         // TestAlloc()'ed
    DWORD cbEncoded;
    DWORD dwDisplayFlags = 0;
    BOOL fUrl = FALSE;
    BOOL fCAs = FALSE;

    CRYPT_DATA_BLOB EncodedBlob;
    void *pvList;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'U':
                    fUrl = TRUE;
                    break;
                case 'C':
                    fCAs = TRUE;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'h':
                default:
                    goto BadUsage;
            }
        } else {
            if (pszFileOrUrl == NULL)
                pszFileOrUrl = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFileOrUrl == NULL) {
        printf("missing FileOrUrl \n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fUrl) {
        pwszUrl = AllocAndSzToWsz(pszFileOrUrl);
        pvList = (void *) pwszUrl;
    } else {
        if (!ReadDERFromFile(pszFileOrUrl, &pbEncoded, &cbEncoded))
            goto ErrorReturn;
        EncodedBlob.pbData = pbEncoded;
        EncodedBlob.cbData = cbEncoded;
        pvList = (void *) &EncodedBlob;
    }

    if (fCAs) {
        fResult = CertInstallIntermediateCAs(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            fUrl ? CERT_INSTALL_CA_FORMAT_URL : CERT_INSTALL_CA_FORMAT_BLOB,
            pvList,
            0,                  // dwFlags
            NULL                // pvReserved
            );
        if (!fResult)
            PrintLastError("CertInstallIntermediateCAs");
        else
            printf("Successful CertInstallIntermediateCAs\n");
    } else {
        fResult = CertInstallSignedListOfTrustedCertificates(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CERT_INSTALL_SIGNED_LIST_PURPOSE_TRUSTED_ROOTS,
            fUrl ? CERT_INSTALL_SIGNED_LIST_FORMAT_URL :
                   CERT_INSTALL_SIGNED_LIST_FORMAT_BLOB,
            pvList,
            0,                  // dwFlags
            NULL                // pvReserved
            );
        if (!fResult)
            PrintLastError("CertInstallSignedListOfTrustedCertificates");
        else
            printf("Successful CertInstallSignedListOfTrustedCertificates\n");
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pwszUrl)
        TestFree(pwszUrl);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstore\tstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore.cpp
//
//  Contents:   Cert Store API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Mar-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "crypthlp.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

//
// FIsWinNT: check OS type on x86.  On non-x86, assume WinNT
//

#ifdef _M_IX86

static BOOL WINAPI FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}

#else

static BOOL WINAPI FIsWinNT(void) {
    return(TRUE);
}

#endif

static void PrintExpectedError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s got expected error => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

static BOOL AddCert(HCERTSTORE hStore, LPSTR pszAddFilename,
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCert");
        return FALSE;
    }

    fResult = FALSE;
    if (!CertAddEncodedCertificateToStore(hStore, dwCertEncodingType,
            pbEncoded, cbEncoded, dwAddDisposition, &pCert)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCertificateToStore");
        else
            PrintLastError("CertAddEncodedCertificateToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCertificateToStore");
        else
            fResult = TRUE;
        printf("=====  Added Cert  =====\n");
        DisplayCert(pCert, 0, 0);
        CertFreeCertificateContext(pCert);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCert(
        HCERTSTORE hStore,
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return FALSE;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCertificateContext");
    } else {
        fResult = TRUE;
        DisplayCert2(hStore, pCert, dwDisplayFlags);
        CertFreeCertificateContext(pCert);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an embedded PKCS#7 via SIP
static HCERTSTORE OpenSIPStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore = NULL;
    LPWSTR pwszStoreFilename = NULL;
    CRYPT_DATA_BLOB SignedData;
    memset(&SignedData, 0, sizeof(SignedData));
    DWORD dwGetEncodingType;

    GUID gSubject;
    SIP_DISPATCH_INFO SipDispatch;
    SIP_SUBJECTINFO SubjectInfo;

    if (NULL == (pwszStoreFilename = AllocAndSzToWsz(pszStoreFilename)))
        goto CommonReturn;

    if (!CryptSIPRetrieveSubjectGuid(
            pwszStoreFilename,
            NULL,                       // hFile
            &gSubject)) goto CommonReturn;

    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);
    if (!CryptSIPLoad(
            &gSubject,
            0,                  // dwFlags
            &SipDispatch)) goto CommonReturn;

    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszStoreFilename;
    // SubjectInfo.pwsDisplayName = 
    // SubjectInfo.lpSIPInfo = 
    // SubjectInfo.dwReserved = 
    // SubjectInfo.hProv = 
    // SubjectInfo.DigestAlgorithm =
    // SubjectInfo.dwFlags =
    SubjectInfo.dwEncodingType = dwMsgAndCertEncodingType;
    // SubjectInfo.lpAddInfo =
        
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            NULL                        // pbSignedData
            ) || 0 == SignedData.cbData)
        goto CommonReturn;
    if (NULL == (SignedData.pbData = (BYTE *) TestAlloc(SignedData.cbData)))
        goto CommonReturn;
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            SignedData.pbData
            ))
        goto CommonReturn;

    hStore = CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) &SignedData
        );

    if (hStore) {
        WCHAR wszGUID[128];
        StringFromGUID2(gSubject, wszGUID, 128);
        printf("Opening Store as SIP Subject GUID:: %S \n", wszGUID);
    }

CommonReturn:
    TestFree(pwszStoreFilename);
    TestFree(SignedData.pbData);
    return hStore;
}

static HCERTSTORE OpenCertStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;

    if (hStore = OpenSIPStoreFile(pszStoreFilename))
        return hStore;

    return NULL;
}

static BOOL AddCrl(HCERTSTORE hStore, LPSTR pszAddFilename, 
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCRL_CONTEXT pCrl = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCrl");
        return FALSE;
    }

    fResult = FALSE;
    if (!CertAddEncodedCRLToStore(hStore, dwCertEncodingType, pbEncoded,
            cbEncoded, dwAddDisposition, &pCrl)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCRLToStore");
        else
            PrintLastError("CertAddEncodedCRLToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCRLToStore");
        else
            fResult = TRUE;
        printf("=====  Added CRL  =====\n");
        DisplayCrl(pCrl, 0);
        CertFreeCRLContext(pCrl);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCrl(
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCRL_CONTEXT pCrl;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCrl");
        return FALSE;
    }

    pCrl = CertCreateCRLContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCrl == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCRLContext");
    } else {
        fResult = TRUE;
        DisplayCrl(pCrl, dwDisplayFlags);
        CertFreeCRLContext(pCrl);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an encoded CRL.
static HCERTSTORE OpenCrlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        return NULL;

    if (!CertAddEncodedCRLToStore(
            hStore,
            dwCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCrlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

    TestFree(pbEncoded);
    return hStore;
}

static BOOL AddRootCtl(
    HCERTSTORE hStore,
    PCCTL_CONTEXT pCtl,
    DWORD dwAddDisposition,
    BOOL fExpectError
    )
{
    BOOL fResult;
    DWORD i;
    DWORD cCtlEntry = pCtl->pCtlInfo->cCTLEntry;
    PCTL_ENTRY pCtlEntry = pCtl->pCtlInfo->rgCTLEntry;
    HCERTSTORE hMsgStore = NULL;

    hMsgStore = CertOpenStore(
        CERT_STORE_PROV_MSG,
        dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) pCtl->hCryptMsg
        );

    if (NULL == hMsgStore) {
        PrintLastError("Open Msg Store");
        goto ErrorReturn;
    }

    // Loop through entries. Either add or remove the certificate from the
    // store

    for (i = 0; i< cCtlEntry; i++, pCtlEntry++) {
        PCRYPT_ATTRIBUTE pDelAttr;

        pDelAttr = CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            );
        if (pDelAttr) {
            BYTE rgbDelValue[] = {0x02, 0x1, 0x1};
            if (0 == pDelAttr->cValue || 3 != pDelAttr->rgValue[0].cbData ||
                    0 != memcmp(pDelAttr->rgValue[0].pbData, rgbDelValue, 3))
                printf("Failed ==> bad delete attribute for Cert[%d]\n", i);
            else {
                PCCERT_CONTEXT pDelCert;

                pDelCert = CertFindCertificateInStore(
                    hStore,
                    0,                  // dwCertEncodingType
                    0,                  // dwFindFlags
                    CERT_FIND_SHA1_HASH,
                    (const void *) &pCtlEntry->SubjectIdentifier,
                    NULL                //pPrevCertContext
                    );
                if (pDelCert) {
                    if (CertDeleteCertificateFromStore(pDelCert))
                        printf("=====  Deleted Root Cert[%d]  =====\n", i);
                    else
                        printf("Failed ==> delete Cert[%d]\n", i);
                }
            }
        } else {
            PCCERT_CONTEXT pAddCert;

            pAddCert = CertFindCertificateInStore(
                hMsgStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &pCtlEntry->SubjectIdentifier,
                NULL                //pPrevCertContext
                );
            if (pAddCert) {
                if (!CertSetCertificateContextPropertiesFromCTLEntry(
                        pAddCert,
                        pCtlEntry,
                        CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
                        ))
                    printf("Failed ==> SetPropFromCTLEntry for Cert [%d]\n",
                        i);
                else {
                    if (!CertAddCertificateContextToStore(
                            hStore,
                            pAddCert,
                            dwAddDisposition,
                            NULL                // ppStoreContext
                            ))
                        printf("Failed ==> Add Cert [%d]\n", i);
                    else
                        printf("=====  Added Root Cert[%d]  =====\n", i);
                }
                CertFreeCertificateContext(pAddCert);
            } else
                printf("Failed ==> No Cert [%d]\n", i);
        }
    }

    fResult = TRUE;

CommonReturn:
    if (hMsgStore)
        CertCloseStore(hMsgStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL AddCtl(HCERTSTORE hStore, LPSTR pszAddFilename, 
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCtl");
        return FALSE;
    }

    // Determine if Root CTL
    pCtl = CertCreateCTLContext(
        dwMsgAndCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCtl) {
        PCTL_USAGE pSubjectUsage = &pCtl->pCtlInfo->SubjectUsage;

        if (0 == pSubjectUsage->cUsageIdentifier ||
                0 != strcmp(pSubjectUsage->rgpszUsageIdentifier[0],
                        szOID_ROOT_LIST_SIGNER)) {
            CertFreeCTLContext(pCtl);
            pCtl = NULL;
        }
    }

    fResult = FALSE;
    if (pCtl) {
        fResult = AddRootCtl(
            hStore,
            pCtl,
            dwAddDisposition,
            fExpectError
            );
        CertFreeCTLContext(pCtl);
    } else if (!CertAddEncodedCTLToStore(hStore, dwMsgAndCertEncodingType, pbEncoded,
            cbEncoded, dwAddDisposition, &pCtl)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCTLToStore");
        else
            PrintLastError("CertAddEncodedCTLToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCTLToStore");
        else
            fResult = TRUE;
        printf("=====  Added CTL  =====\n");
        DisplayCtl(pCtl, 0, hStore);
        CertFreeCTLContext(pCtl);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCtl(
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCTL_CONTEXT pCtl;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCtl");
        return FALSE;
    }

    pCtl = CertCreateCTLContext(
        dwMsgAndCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCtl == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCTLContext");
    } else {
        fResult = TRUE;
        DisplayCtl(pCtl, dwDisplayFlags, NULL);
        CertFreeCTLContext(pCtl);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}

static PCCERT_CONTEXT GetNthCert(
    IN HCERTSTORE hStore,
    IN DWORD N
    )
{
    PCCERT_CONTEXT pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        if (0 == N--)
            break;
    }
    return pCert;
}

static void SetKeyProvParams(
    IN PCCERT_CONTEXT pCert
    )
{
    CRYPT_KEY_PROV_INFO Info;
    CRYPT_KEY_PROV_PARAM Param[3];
    DWORD i;
    BYTE rgb[11*3];

    Info.pwszContainerName = L"Test Container With Parameters";
    Info.pwszProvName = L"test provider with parameters";
    Info.dwProvType = 77;
    Info.dwFlags = 0x12345678;
    Info.cProvParam = 3;
    Info.rgProvParam = Param;
    Info.dwKeySpec = 66;

    for (i = 0; i < sizeof(rgb); i++)
        rgb[i] = (BYTE) i;

    for (i = 0; i < 3; i++) {
        Param[i].dwParam = 0x10 + i;
        if (i == 0)
            Param[i].pbData = NULL;
        else
            Param[i].pbData = rgb;
        Param[i].cbData = i * 11;
        Param[i].dwFlags = 1 << i;
    }

    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            0,                          // dwFlags
            &Info
            ))
        PrintLastError("CertSetCertificateContextProperty(KeyProvParams)");
}



static void Usage(void)
{
    printf("Usage: tstore [options] <StoreName>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -c                    - Verify ALL checks enabled\n");
    printf("  -cSign                - Verify Signature check enabled\n");
    printf("  -cTime                - Verify Time Validity check enabled\n");
    printf("  -d                    - Delete cert/CRL/CTL\n");
    printf("  -dALL                 - Delete all certs/CRLs/CTLs\n");
    printf("  -P                    - Set or Delete property\n");
    printf("  -PKey                 - Find or Delete KeyProvInfo property\n");
    printf("  -PSilentKey           - Silent Find or Delete KeyProvInfo property\n");
    printf("  -PArchive             - Find or Delete Archive property\n");
    printf("  -PKeyProvParam        - Set KeyProvInfo with parameters\n");
    printf("  -F                    - Test Force store close\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -f<number>            - Open dwFlags\n");
    printf("  -E                    - Error is expected for add, delete or set\n");
    printf("  -i<number>            - Cert/CRL/CTL index\n");
    printf("  -l                    - List (Default)\n");
    printf("  -R                    - Revocation (CRL)\n");
    printf("  -T                    - Trust (CTL)\n");
    printf("  -N                    - Enable change Notify\n");
    printf("  -C                    - Commit before close\n");
    printf("  -CForce               - Force Commit before close\n");
    printf("  -CClear               - Clear Commit before close\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -s<StoreProviderName> - Open using store provider\n");
    printf("  -v                    - Verbose\n");
    printf("  -u                    - UI Dialog Viewer\n");
    printf("  -a<filename>          - Add encoded cert/CRL/CTL from file\n");
    printf("  -A<filename>          - Add (replace) encoded cert/CRL/CTL from file\n");
    printf("  -I<filename>          - Add (inherit properties) encoded cert/CRL/CTL from file\n");
    printf("  -p<filename>          - Put encoded cert/CRL/CTL to file\n");
    printf("  -r<filename>          - Read encoded cert/CRL/CTL from file\n");
    printf("  -t                    - Save thumprints (digests/hashes) in store\n");
    printf("  -K                    - Display Public Key Thumbprint\n");
    printf("  -S[<SaveFilename>]    - Save store to file\n");
    printf("  -7[<SaveFilename>]    - PKCS# 7 formated save\n");
    printf("\n");
    printf("Default: list of certs for the store\n");
}


int _cdecl main(int argc, char * argv[])
{
    DWORD dwDisplayFlags = 0;
    LONG lIndex = -1;
    BOOL fDelete = FALSE;
    BOOL fDeleteAll = FALSE;
    DWORD dwOpenFlags = 0;
    BOOL fExpectError = FALSE;
    BOOL fProperty = FALSE;
    BOOL fKeyProperty = FALSE;
    BOOL fKeyProvParam = FALSE;
    BOOL fSilentKey = FALSE;
    BOOL fArchiveProperty = FALSE;
    DWORD dwContextType = CERT_STORE_CERTIFICATE_CONTEXT;
    BOOL fThumbprint = FALSE;
    BOOL fSystemStore = FALSE;
    BOOL fForceClose = FALSE;
    BOOL fSave = FALSE;
    BOOL fPKCS7Save = FALSE;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
    LPSTR pszAddFilename = NULL;
    LPSTR pszPutFilename = NULL;
    LPSTR pszReadFilename = NULL;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszSaveFilename = NULL;

    LPSTR pszStoreProvider = NULL;
    HCERTSTORE hStore;

    BOOL fNotify = FALSE;
    HANDLE hEvent = NULL;
    BOOL fCommit = FALSE;
    DWORD dwCommitFlags = 0;

    BOOL fDeferClose = FALSE;
#define DEFER_CERT_CNT  5
    PCCERT_CONTEXT rgpDeferCert[DEFER_CERT_CNT];
    memset(rgpDeferCert, 0, sizeof(rgpDeferCert));

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Sign"))
                        dwDisplayFlags |= DISPLAY_CHECK_SIGN_FLAG;
                    else if (0 == _stricmp(argv[0]+2, "Time"))
                        dwDisplayFlags |= DISPLAY_CHECK_TIME_FLAG;
                    else {
                        printf("Need to specify -cSign | -cTime\n");
                        Usage();
                        return -1;
                    }
                }
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'u':
                dwDisplayFlags |= DISPLAY_UI_FLAG;
                break;
            case 'K':
                dwDisplayFlags |= DISPLAY_KEY_THUMB_FLAG;
                break;
            case 'd':
                if (argv[0][2]) {
                    if (0 != _stricmp(argv[0]+2, "ALL")) {
                        printf("Need to specify -dALL\n");
                        Usage();
                        return -1;
                    }
                    fDeleteAll = TRUE;
                } else
                    fDelete = TRUE;
                break;
            case 'P':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Key"))
                        fKeyProperty = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "Archive"))
                        fArchiveProperty = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "KeyProvParam"))
                        fKeyProvParam = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "SilentKey")) {
                        fKeyProperty = TRUE;
                        fSilentKey = TRUE;
                    } else {
                        printf("Need to specify -PKey\n");
                        Usage();
                        return -1;
                    }
                } else
                    fProperty = TRUE;
                break;
            case 'F':
                fForceClose = TRUE;
                break;
            case 'R':
                dwContextType = CERT_STORE_CRL_CONTEXT;
                break;
            case 'T':
                dwContextType = CERT_STORE_CTL_CONTEXT;
                break;
            case 'N':
                fNotify = TRUE;
                break;
            case 'C':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Force"))
                        dwCommitFlags |= CERT_STORE_CTRL_COMMIT_FORCE_FLAG;
                    else if (0 == _stricmp(argv[0]+2, "Clear"))
                        dwCommitFlags |= CERT_STORE_CTRL_COMMIT_CLEAR_FLAG;
                    else {
                        printf("Need to specify -CForce or -CClear\n");
                        Usage();
                        return -1;
                    }
                }
                fCommit = TRUE;
                break;
            case 's':
                if (argv[0][2])
                    pszStoreProvider = argv[0]+2;
                fSystemStore = TRUE;
                break;
            case 't':
                fThumbprint = TRUE;
                break;
            case 'l':
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                dwOpenFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'E':
                fExpectError = TRUE;
                break;
            case 'i':
                lIndex = (DWORD) strtol(argv[0]+2, NULL, 0);
                break;
            case 'a':
            case 'A':
            case 'I':
                pszAddFilename = argv[0]+2;
                if (*pszAddFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                if (argv[0][1] == 'A')
                    dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                else if (argv[0][1] == 'I')
                    dwAddDisposition =
                        CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
                else
                    dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                break;
            case 'r':
                pszReadFilename = argv[0]+2;
                if (*pszReadFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                break;
            case '7':
                fPKCS7Save = TRUE;
            case 'S':
                fSave = TRUE;
                if (argv[0][2])
                    pszSaveFilename = argv[0]+2;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        } else
            pszStoreFilename = argv[0];
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    if (pszSaveFilename == NULL) {
        if (!fSystemStore)
            pszSaveFilename = pszStoreFilename;
        else if (fSave) {
            printf("missing save filename\n");
            Usage();
            return -1;
        }
    }

    if (lIndex < 0 && (fDelete || pszPutFilename)) {
        printf("Must specify index value\n");
        Usage();
        return -1;
    }
    
    printf("command line: %s\n", GetCommandLine());
    {
        DWORD dwFileVersionMS;    /* e.g. 0x00030075 = "3.75" */
        DWORD dwFileVersionLS;    /* e.g. 0x00000031 = "0.31" */
        if (I_CryptGetFileVersion(L"crypt32.dll",
                &dwFileVersionMS, &dwFileVersionLS))
            printf("crypt32.dll file version:: %d.%d.%d.%d\n",
                (dwFileVersionMS >> 16) & 0xFFFF,
                dwFileVersionMS & 0xFFFF,
                (dwFileVersionLS >> 16) & 0xFFFF,
                dwFileVersionLS & 0xFFFF
                );
        else
            PrintLastError("I_CryptGetFileVersion(crypt32.dll)");
    }

    hStore = NULL;
    if (pszStoreProvider) {
        LPWSTR pwszStore;
        if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
            hStore = CertOpenStore(
                pszStoreProvider,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                dwOpenFlags,
                pwszStore
                );
            TestFree(pwszStore);
        }
        if (hStore == NULL) {
            if (dwOpenFlags & CERT_STORE_DELETE_FLAG) {
                if (0 == GetLastError())
                    printf("Successful delete store\n");
                else
                    PrintLastError("CertOpenStore(CERT_STORE_DELETE_FLAG)");
                return 0;
            } else {
                PrintLastError("CertOpenStore");
                return -1;
            }
        }
    } else if (!fSystemStore) {
        // Attempt to open as encoded certificate CRL or CTL file
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                hStore = OpenCrlStoreFile(pszStoreFilename);
                break;
            case CERT_STORE_CTL_CONTEXT:
                hStore = OpenCtlStoreFile(pszStoreFilename);
                break;
            case CERT_STORE_CERTIFICATE_CONTEXT:
                hStore = OpenCertStoreFile(pszStoreFilename);
            default:
                break;
        }
    }
    
    if (NULL == hStore) {
        // Attempt to open the store
        if (!fSystemStore && fCommit) {
            dwOpenFlags |= CERT_FILE_STORE_COMMIT_ENABLE_FLAG;
            pszSaveFilename = NULL;
        }
        dwOpenFlags |= CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        hStore = OpenStoreEx(fSystemStore, pszStoreFilename, dwOpenFlags);
        if (hStore == NULL)
            return -1;
    }

    if (dwOpenFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
        printf("CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG was set\n");
        if (!fForceClose)
            fDeferClose = TRUE;
    }

#if 0
    if (fNotify && fSystemStore && !FIsWinNT()) {
        printf("Change Notify not supported for Win95 Registry\n");
        fNotify = FALSE;
    }
#endif

    if (fNotify) {
        // Create event to be notified
        if (NULL == (hEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            PrintLastError("CreateEvent");
        else {
            // Register the event to be signaled when the store changes
            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_NOTIFY_CHANGE,
                    &hEvent
                    )) {
                PrintLastError("CertControlStore(NOTIFY_CHANGE)");
                fNotify = FALSE;
            } else
               Sleep(5);        // Allow callback thread to be scheduled
        }
    }

    if (pszReadFilename) {
        printf("Reading\n");
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                ReadCrl(pszReadFilename, dwDisplayFlags);
                break;
            case CERT_STORE_CTL_CONTEXT:
                ReadCtl(pszReadFilename, dwDisplayFlags);
                break;
            default:
                ReadCert(hStore, pszReadFilename, dwDisplayFlags);
        }
    } else if (pszAddFilename) {
        BOOL fResult;
        printf("Adding\n");
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                fResult = AddCrl(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
                break;
            case CERT_STORE_CTL_CONTEXT:
                fResult = AddCtl(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
                break;
            default:
                fResult = AddCert(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
        }
        if (fResult)
            fSave = TRUE;
    } else if (fDeleteAll & !fArchiveProperty) {
        printf("Deleting All\n");
        if (CERT_STORE_CRL_CONTEXT == dwContextType) {
            PCCRL_CONTEXT pCrl;
            while (pCrl = CertEnumCRLsInStore(hStore, NULL)) {
                if (!CertDeleteCRLFromStore(pCrl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCRLFromStore");
                    else
                        PrintLastError("CertDeleteCRLFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCRLFromStore");
                else
                    fSave = TRUE;
            }
        } else if (CERT_STORE_CTL_CONTEXT == dwContextType) {
            PCCTL_CONTEXT pCtl;
            while (pCtl = CertEnumCTLsInStore(hStore, NULL)) {
                if (!CertDeleteCTLFromStore(pCtl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCTLFromStore");
                    else
                        PrintLastError("CertDeleteCTLFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCTLFromStore");
                else
                    fSave = TRUE;
            }
        } else {
            PCCERT_CONTEXT pCert;
            while (pCert = CertEnumCertificatesInStore(hStore, NULL)) {
                if (!CertDeleteCertificateFromStore(pCert)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCertificateFromStore");
                    else
                        PrintLastError("CertDeleteCertificateFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCertificateFromStore");
                else
                    fSave = TRUE;
            }
        }
    } else if (CERT_STORE_CRL_CONTEXT == dwContextType) {
        BOOL fFound = FALSE;
        LONG i;
        PCCRL_CONTEXT pCrl = NULL;
        DWORD dwFlags;

        for (i = 0;; i++) {
            dwFlags = CERT_STORE_TIME_VALIDITY_FLAG;
            pCrl = CertGetCRLFromStore(
                hStore,
                NULL,   // pIssuerContext
                pCrl,
                &dwFlags);
            if (pCrl == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;
            if (fProperty) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCRLContextProperty");
                    else
                        PrintLastError("CertSetCRLContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCRLContextProperty");
                else
                    fSave = TRUE;
            }
            if (fDelete) {
                printf("Deleting\n");
                if (!CertDeleteCRLFromStore(pCrl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCRLFromStore");
                    else
                        PrintLastError("CertDeleteCRLFromStore");
                } else if (fExpectError)
                    PrintNoError("CertDeleteCRLFromStore");
                else
                    fSave = TRUE;
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCrl->pbCrlEncoded,
                        pCrl->cbCrlEncoded
                        ))
                    PrintLastError("Put CRL::WriteDERToFile");
                CertFreeCRLContext(pCrl);
                break;
            } else {
                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCrl(pCrl, dwDisplayFlags);
                DisplayVerifyFlags("CRL", dwFlags);
                if (lIndex == i) {
                    CertFreeCRLContext(pCrl);
                    break;
                }
            }
        }

        if (!fFound)
            printf("CRL not found\n");
    } else if (CERT_STORE_CTL_CONTEXT == dwContextType) {
        BOOL fFound = FALSE;
        LONG i;
        PCCTL_CONTEXT pCtl = NULL;

        for (i = 0;; i++) {
            pCtl = CertEnumCTLsInStore(
                hStore,
                pCtl);
            if (pCtl == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;
            if (fProperty) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCTLContextProperty(
                        pCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCTLContextProperty");
                    else
                        PrintLastError("CertSetCTLContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCTLContextProperty");
                else
                    fSave = TRUE;
            }
            if (fDelete) {
                printf("Deleting\n");
                if (!CertDeleteCTLFromStore(pCtl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCTLFromStore");
                    else
                        PrintLastError("CertDeleteCTLFromStore");
                } else if (fExpectError)
                    PrintNoError("CertDeleteCTLFromStore");
                else
                    fSave = TRUE;
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCtl->pbCtlEncoded,
                        pCtl->cbCtlEncoded
                        ))
                    PrintLastError("Put CTL::WriteDERToFile");
                CertFreeCTLContext(pCtl);
                break;
            } else {
                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCtl(pCtl, dwDisplayFlags, hStore);
                if (lIndex == i) {
                    CertFreeCTLContext(pCtl);
                    break;
                }
            }
        }

        if (!fFound)
            printf("CTL not found\n");
    } else {
        BOOL fFound = FALSE;
        LONG i;
        PCCERT_CONTEXT pCert = NULL;

        pCert = NULL;
        for (i = 0;; i++) {
            pCert = CertEnumCertificatesInStore(
                hStore,
                pCert);
            if (pCert == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;

            if (fForceClose)
                CertDuplicateCertificateContext(pCert);
            else if (fDeferClose) {
                CertFreeCertificateContext(rgpDeferCert[0]);
                rgpDeferCert[0] = CertDuplicateCertificateContext(pCert);
            }
            if (fProperty && !fDelete) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCertificateContextProperty");
                    else
                        PrintLastError("CertSetCertificateContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCertificateContextProperty");
                else
                    fSave = TRUE;

                // Test that we properly update the PROV_HANDLE and KEY_SPEC
                // properties
                HCRYPTPROV hProv = (HCRYPTPROV) 0x12345678;
                HCRYPTPROV hProv2 = 0;
                DWORD dwKeySpec = 0xdeadbeef;
                DWORD dwKeySpec2 = 0;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_HANDLE_PROP_ID,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        (void *) hProv
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(PROV_HANDLE)");
                else if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_SPEC_PROP_ID,
                        0,                          // dwFlags
                        &dwKeySpec
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(KEY_SPEC)");
                else {
                    DWORD cbData = sizeof(hProv);
                    CERT_KEY_CONTEXT KeyContext;
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_PROV_HANDLE_PROP_ID,
                            &hProv2,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(PROV_HANDLE)");
                    else if (hProv2 != hProv)
                        PrintLastError(
                            "PROV_HANDLE property not updated properly\n");

                    cbData = sizeof(dwKeySpec);
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_SPEC_PROP_ID,
                            &dwKeySpec2,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(KEY_SPEC)");
                    else if (dwKeySpec2 != dwKeySpec)
                        PrintLastError(
                            "KEY_SPEC property not updated properly\n");

                    cbData = sizeof(KeyContext);
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_CONTEXT_PROP_ID,
                            &KeyContext,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(KEY_CONTEXT)");
                    else if (KeyContext.dwKeySpec != dwKeySpec ||
                            KeyContext.hCryptProv != hProv)
                        PrintLastError(
                            "KEY_CONTEXT property not updated properly\n");
                }

                hProv = 0;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_HANDLE_PROP_ID,
                        0,                          // dwFlags
                        (void *) hProv
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(PROV_HANDLE)");
            }

            if (fKeyProperty && !fDelete) {
                if (!CryptFindCertificateKeyProvInfo(
                        pCert,
                        fSilentKey ? CRYPT_FIND_SILENT_KEYSET_FLAG : 0,
                        NULL            // pvReserved
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CryptFindCertificateKeyProvInfo");
                    else
                        PrintLastError("CryptFindCertificateKeyProvInfo");
                } else {
                    printf("Found KEY_PROV_INFO property\n");

                    if (fExpectError)
                        PrintNoError("CryptFindCertificateKeyProvInfo");
                    else {
                        HCRYPTPROV hProv1 = 0;
                        HCRYPTPROV hProv2 = 0;
                        DWORD dwKeySpec1;
                        DWORD dwKeySpec2;
                        BOOL fCallerFreeProv;

                        fSave = TRUE;
                        
                        dwKeySpec1 = 0x12341111;
                        fCallerFreeProv = TRUE;
                        if (!CryptAcquireCertificatePrivateKey(
                                pCert,
                                (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                CRYPT_ACQUIRE_CACHE_FLAG |
                                    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                NULL,                           // pvReserved
                                &hProv1,
                                &dwKeySpec1,
                                &fCallerFreeProv
                                ))
                            PrintLastError("CryptAcquireCertificatePrivateKey");
                        else if (fCallerFreeProv)
                            printf("failed => cached acquire returned FreeProv\n");
                        dwKeySpec2 = 0x12342222;
                        fCallerFreeProv = FALSE;
                        if (!CryptAcquireCertificatePrivateKey(
                                pCert,
                                (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                NULL,                           // pvReserved
                                &hProv2,
                                &dwKeySpec2,
                                &fCallerFreeProv
                                ))
                            PrintLastError("CryptAcquireCertificatePrivateKey");
                        else {
                            if (!fCallerFreeProv)
                                printf("failed => uncached acquire didn't return FreeProv\n");
                            if (hProv2 == hProv1)
                                printf("failed => uncached == cached hProv\n");
                            if (dwKeySpec2 != dwKeySpec1)
                                printf("failed => uncached != cached dwKeySpec\n");

                            CryptReleaseContext(hProv2, 0);
                        }

                        if (hProv1) {
                            dwKeySpec2 = 0x12343333;
                            fCallerFreeProv = TRUE;
                            if (!CryptAcquireCertificatePrivateKey(
                                    pCert,
                                    (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                        CRYPT_ACQUIRE_CACHE_FLAG |
                                        CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                    NULL,                           // pvReserved
                                    &hProv2,
                                    &dwKeySpec2,
                                    &fCallerFreeProv
                                    ))
                                PrintLastError("CryptAcquireCertificatePrivateKey");
                            else {
                                if (fCallerFreeProv)
                                    printf("failed => uncached acquire returned FreeProv\n");
                                if (hProv2 != hProv1)
                                    printf("failed => cached != cached hProv\n");
                                if (dwKeySpec2 != dwKeySpec1)
                                    printf("failed => cached != cached dwKeySpec\n");
                            }
                        }
                    }
                }
            }

            if (fArchiveProperty) {
                CRYPT_DATA_BLOB ArchiveBlob = { 0, NULL };

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_ARCHIVED_PROP_ID,
                        0,                          // dwFlags
                        (fDelete || fDeleteAll) ? NULL : &ArchiveBlob
                        )) {
                    if (fExpectError)
                        PrintExpectedError(
                            "CertSetCertificateContextProperty(ARCHIVE)");
                    else
                        PrintLastError(
                            "CertSetCertificateContextProperty(ARCHIVE)");
                }
            } else if (fDelete) {
                if (fProperty || fKeyProperty) {
                    DWORD PropId;

                    if (fKeyProperty) {
                        printf("Deleting KEY_PROV_INFO property\n");
                        PropId = CERT_KEY_PROV_INFO_PROP_ID;
                    } else {
                        printf("Deleting property\n");
                        PropId = CERT_FIRST_USER_PROP_ID;
                    }
                    if (!CertSetCertificateContextProperty(
                            pCert,
                            PropId,
                            0,                          // dwFlags
                            NULL
                            )) {
                        if (fExpectError)
                            PrintExpectedError("CertSetCertificateContextProperty");
                        else
                            PrintLastError("CertSetCertificateContextProperty");
                    } else if (fExpectError)
                        PrintNoError("CertSetCertificateContextProperty");
                    else
                        fSave = TRUE;
                    CertFreeCertificateContext(pCert);
                } else {
                    printf("Deleting\n");
                    if (!CertDeleteCertificateFromStore(pCert)) {
                        if (fExpectError)
                            PrintExpectedError("CertDeleteCertificateFromStore");
                        else
                            PrintLastError("CertDeleteCertificateFromStore");
                    } else if (fExpectError)
                        PrintNoError("CertDeleteCertificateFromStore");
                    else
                        fSave = TRUE;
                }
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded
                        ))
                    PrintLastError("Put Cert::WriteDERToFile");
                CertFreeCertificateContext(pCert);
                break;
            } else {
                if (fKeyProvParam) {
                    printf("Setting KeyProvInfo parameters\n");
                    SetKeyProvParams(pCert);
                }

                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, dwDisplayFlags);
                if (lIndex == i) {
                    CertFreeCertificateContext(pCert);
                    break;
                }
            }
        }

        if (!fFound)
            printf("Certificate not found\n");

        if (fForceClose) {
            // Do incomplete enumerations to test out external store
            // logic
            pCert = GetNthCert(hStore, 0);
            CertFreeCertificateContext(pCert);

            pCert = GetNthCert(hStore, 0);
            GetNthCert(hStore, (i-1)/2);
            GetNthCert(hStore, i-1);
        } else if (fDeferClose) {
            rgpDeferCert[1] = GetNthCert(hStore, 0);
            CertFreeCertificateContext(rgpDeferCert[1]);

            rgpDeferCert[1] = GetNthCert(hStore, 0);
            rgpDeferCert[2] = GetNthCert(hStore, (i-1)/2);
            rgpDeferCert[3] = GetNthCert(hStore, i-1);
        }
    }

    if (fSave && pszSaveFilename)
        SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);

    if (fCommit) {
        printf("Committing store changes::");
        if (dwCommitFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
            printf(" FORCE");
        if (dwCommitFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
            printf(" CLEAR");
        printf("\n");
        if (!CertControlStore(
                hStore,
                dwCommitFlags,
                CERT_STORE_CTRL_COMMIT,
                NULL
                ))
            PrintLastError("CertControlStore(COMMIT)");
    }

    if (fNotify) {
        BOOL fSignaled;
        // Check if event was signaled
        if (WAIT_TIMEOUT == WaitForSingleObjectEx(
                hEvent,
                100,                        // dwMilliseconds
                FALSE                       // bAlertable
                ))
            fSignaled = FALSE;
        else
            fSignaled = TRUE;

        if (!fSignaled) {
            printf("No store change notify\n");
            if (pszAddFilename || fDeleteAll || fDelete || fProperty)
                printf("failed => expected notify for add, delete or property\n");
        } else {
            printf("There was a store change notify\n");
            if (!(pszAddFilename || fDeleteAll || fDelete || fProperty))
                printf("failed => unexpected notify\n");

            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_RESYNC,
                    NULL            // pvCtrlPara
                    ))
                PrintLastError("CertControlStore(RESYNC)");
            else {
                printf("\n");
                printf(">>>>>  After Resync  >>>>>\n");
                DisplayStore(hStore, DISPLAY_BRIEF_FLAG);
            }
        }
    }

    if (hEvent)
        CloseHandle(hEvent);

    if (fForceClose) {
        CertDuplicateStore(hStore);
        if (CertCloseStore(hStore, 
                CERT_CLOSE_STORE_CHECK_FLAG | CERT_CLOSE_STORE_FORCE_FLAG))
            printf("failed => CertCloseStore(FORCE) didn't fail as expected\n");
        else
            printf("CertCloseStore(FORCE) returned expected nonzero status: 0x%x\n",
                GetLastError());
    } else  if (fDeferClose) {
        // Check if any defered certificates
        DWORD i;

        fDeferClose = FALSE;
        for (i = 0; i < DEFER_CERT_CNT; i++) {
            if (rgpDeferCert[i]) {
                fDeferClose = TRUE;
                break;
            }
        }

        if (fDeferClose) {
            CertDuplicateStore(hStore);
            CertCloseStore(hStore, 0);

            if (CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
                printf("failed => CertCloseStore(DEFER) didn't fail as expected\n");
            else
                printf("CertCloseStore(DEFER) returned expected nonzero status: 0x%x\n",
                    GetLastError());
            for (i = 0; i < DEFER_CERT_CNT; i++) {
                CertFreeCertificateContext(rgpDeferCert[i]);
            }
        } else {
            if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
                PrintLastError("CertCloseStore(DEFER)");
        }
    } else {
        if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstore2\tstore2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore2.cpp
//
//  Contents:   Cert Store API Tests: Create and Add a chain of certificates
//              and CRLs to the store.
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    07-Mar-96   philh   created
//              31-May-96   helles  Removed check for a particular error code,
//                                  NTE_PROV_TYPE_NOT_DEF, since this can get
//                                  overwritten due to known problem with
//                                  the msvcr40d.dll on Win95.
//              07-Jun-96   HelleS  Added printing the command line
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#define CMS_PKCS7   1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "setcert.h"
#include "signcde.h"
#include "softpub.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

//#define TEST_PROV_DSS   PROV_DSS
#define TEST_PROV_DSS   PROV_DSS_DH

// # of bytes for a hash. Such as, SHA1 (20) or MD5 (16)
#define MAX_HASH_LEN  20

#if 1
// client authentication doesn't know about sha1
#define SIGNATURE_ALG_OBJID     szOID_RSA_MD5RSA
#else
#define SIGNATURE_ALG_OBJID     szOID_OIWSEC_sha1RSASign
#endif

#define DSS_SIGNATURE_ALG_OBJID szOID_X957_SHA1DSA

#define ENH_1024_CONTAINER_NAME_A "Regression 1024"
#define ENH_1024_CONTAINER_NAME_W L"Regression 1024"
#define ENH_2048_CONTAINER_NAME_A "Regression 2048"
#define ENH_2048_CONTAINER_NAME_W L"Regression 2048"
#define DSS_512_CONTAINER_NAME_A "Regression 512"
#define DSS_512_CONTAINER_NAME_W L"Regression 512"

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCertEncodingType = X509_ASN_ENCODING;
static DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
static DWORD dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
static SYSTEMTIME TestTime;
static LPSTR pszContainer = NULL;
static LPWSTR pwszContainer = NULL;
static HCRYPTPROV hRSACryptProv = 0;
static HCRYPTPROV hEnh1024CryptProv = 0;
static HCRYPTPROV hEnh2048CryptProv = 0;
static HCRYPTPROV hDSSCryptProv = 0;
static HCRYPTPROV hDSS512CryptProv = 0;
static BOOL fGenerate = FALSE;
static BOOL fExportable = FALSE;
static BOOL fProviders = FALSE;
static BOOL fMachine = FALSE;
static BOOL fInheritParameters = FALSE;

#define TIME_INVALID_PARA_FLAG      0x00000001
#define REVOKED_PARA_FLAG           0x00000002
#define PROV_PARA_FLAG              0x00000004
#define XCHG_PARA_FLAG              0x00000008
#define CA_PARA_FLAG                0x00000010
#define NO_NAME_PARA_FLAG           0x00000020
#define ALT_DIR_NAME_PARA_FLAG      0x00000040
#define SET_PARA_FLAG               0x00000080
#define ALL_EXT_PARA_FLAG           0x00000100
#define SPC_EXT_PARA_FLAG           0x00000200
#define SPC_COM_PARA_FLAG           0x00000400
#define SPC_AGENCY_PARA_FLAG        0x00000800
#define SPC_AGENCY_INFO_PARA_FLAG   0x00001000
// "Valid" certs to give to other companies to test interoperability
#define VALID_PARA_FLAG             0x00002000
#define DELTA_CRL_PARA_FLAG         0x00004000
#define AUX1_PARA_FLAG              0x00010000
#define AUX2_PARA_FLAG              0x00020000
// For duplicate, use previous cert's serial number
#define DUPLICATE_PARA_FLAG         0x00040000
#define NO_EXT_PARA_FLAG            0x00080000
#define DUPLICATE_CRL_PARA_FLAG     0x00100000
#define NO_CRL_EXT_PARA_FLAG        0x00200000
#define GENERALIZED_TIME_PARA_FLAG  0x00400000
#define NETSCAPE_PARA_FLAG          0x00800000

#define CTL1_PARA_FLAG              0x01000000
#define CTL2_PARA_FLAG              0x02000000
#define USE1_PARA_FLAG              0x04000000
#define USE2_PARA_FLAG              0x08000000
#define HTTP_PARA_FLAG              0x10000000

#define DSS_PARA_FLAG               0x80000000
#define DSS_512_PARA_FLAG           0x40000000
#define ENH_1024_PARA_FLAG          0x40000000
#define ENH_2048_PARA_FLAG          0x20000000


#define szSignManifold    "Signer Manifold"
#define szXchgManifold    "Recipient Manifold"

typedef struct _CERT_PARA {
    LPSTR       pszName;
    DWORD       dwIssuer;
    DWORD       dwFlags;
    LPSTR       pszManifold;
} CERT_PARA;

#define BASE_OR_DELTA_CA_ISSUER             1
#define UPDATE_CTL_SIGNER                   1

#define POLICY_ROOT                         0
#define POLICY_CA                           1

#define CERT_CNT   67
static CERT_PARA CertPara[CERT_CNT] = {
    "root",         0, CA_PARA_FLAG,                            // 0
                            NULL,
    "CA",           0, CA_PARA_FLAG |
                            DUPLICATE_CRL_PARA_FLAG,            // 1
                            NULL,
    "TestRoot",     2, CA_PARA_FLAG |
                            ENH_2048_PARA_FLAG |
                            VALID_PARA_FLAG,                    // 2
                            NULL,
    "TestSigner",   2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 3
                            szSignManifold,
    "TestRecipient",2, PROV_PARA_FLAG | XCHG_PARA_FLAG |
                            VALID_PARA_FLAG | USE1_PARA_FLAG,   // 4
                            szXchgManifold,
    "me",           1, PROV_PARA_FLAG |
                            ENH_1024_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 5
                            NULL,
    "me",           1, PROV_PARA_FLAG |
                            ENH_1024_PARA_FLAG |
                            XCHG_PARA_FLAG,                     // 6
                            NULL,
    "setrevoked",   1, REVOKED_PARA_FLAG | PROV_PARA_FLAG |
                            SET_PARA_FLAG |
                            ENH_2048_PARA_FLAG,                 // 7
                            NULL,
    "setrevoked",   1, REVOKED_PARA_FLAG | XCHG_PARA_FLAG |
                            SET_PARA_FLAG |
                            PROV_PARA_FLAG | ENH_2048_PARA_FLAG,// 8
                            NULL,
    "time invalid", 1, TIME_INVALID_PARA_FLAG,                  // 9
                            NULL,
    "setkeith",     1, SET_PARA_FLAG,                           // 10
                            NULL,
    "setkeith",     1, XCHG_PARA_FLAG | USE2_PARA_FLAG |        // 11
                            SET_PARA_FLAG,
                            NULL,
    "kevin",        1, 0,                                       // 12
                            NULL,
    "kevin",        1, XCHG_PARA_FLAG | USE2_PARA_FLAG,         // 13
                            NULL,
    "all ext",      1, ALL_EXT_PARA_FLAG | AUX1_PARA_FLAG |
                            SET_PARA_FLAG |
                            ALT_DIR_NAME_PARA_FLAG |
                            AUX2_PARA_FLAG |
                            USE1_PARA_FLAG | USE2_PARA_FLAG,    // 14
                            NULL,
    "MSPub",       17, SPC_EXT_PARA_FLAG | SPC_COM_PARA_FLAG |
                            PROV_PARA_FLAG | USE1_PARA_FLAG,    // 15
                            NULL,
    "PhilPub",     17, SPC_EXT_PARA_FLAG | PROV_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 16
                            NULL,
    "MSAgency",     1, SPC_EXT_PARA_FLAG | SPC_AGENCY_PARA_FLAG |
                            PROV_PARA_FLAG | CA_PARA_FLAG,      // 17
                            NULL,
    "AgencyInfo",   1, SPC_AGENCY_INFO_PARA_FLAG,               // 18
                            NULL,
    "duplicate1",   1, AUX1_PARA_FLAG | NO_EXT_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 19
                            NULL,
    "duplicate2",   1, AUX2_PARA_FLAG | NO_EXT_PARA_FLAG |
                            DUPLICATE_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 20
                            NULL,
    "GeneralRoot",  21, CA_PARA_FLAG |
                            GENERALIZED_TIME_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 21
                            NULL,
    "GeneralTime",  21,  GENERALIZED_TIME_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_512_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 22
                            NULL,
    "Generalrevoked", 21, REVOKED_PARA_FLAG | DSS_PARA_FLAG,    // 23
                            NULL,
    "NoCRLExtCA",   0, CA_PARA_FLAG | NO_CRL_EXT_PARA_FLAG,     // 24
                            NULL,
    "NoCRLExtrevoked", 24, REVOKED_PARA_FLAG,                   // 25
                            NULL,
    "NetscapeCA",   0, NETSCAPE_PARA_FLAG | CA_PARA_FLAG |
                            DSS_PARA_FLAG |
                            REVOKED_PARA_FLAG,                  // 26
                            NULL,
    "Netscape",    26, NETSCAPE_PARA_FLAG | REVOKED_PARA_FLAG,  // 27
                            NULL,
    "Ctl0",         1, CTL1_PARA_FLAG | NO_EXT_PARA_FLAG,       // 28
                            NULL,
    "Ctl1",         2, CTL1_PARA_FLAG,                          // 29
                            NULL,
    "Ctl1Invalid",  2, CTL1_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG,                // 30
                            NULL,
    "Ctl2",         1, CTL2_PARA_FLAG,                          // 31
                            NULL,
    "Ctl2Invalid",  1, CTL2_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG,                // 32
                            NULL,
    "Http2",        1, CTL2_PARA_FLAG | HTTP_PARA_FLAG |
                            NO_EXT_PARA_FLAG,                   // 33
                            NULL,
    "Http2Invalid", 1, CTL2_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG | HTTP_PARA_FLAG |
                            NO_EXT_PARA_FLAG,                   // 34
                            NULL,
    "NoNameIssuer1", 0, CA_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG,  // 35
                            NULL,
    "NoNameSubject1", 35, NO_NAME_PARA_FLAG,                    // 36
                            NULL,
    "NoNameIssuer2", 0, CA_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG,  // 37
                            NULL,
    "NoNameSubject2", 37, NO_NAME_PARA_FLAG |
                            ALT_DIR_NAME_PARA_FLAG,             // 38
                            NULL,
    "Hellman",  21, XCHG_PARA_FLAG | NO_EXT_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 39
                            NULL,
    "TestSigner2", 2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 40
                            szSignManifold,
    "TestRecipient2", 2, PROV_PARA_FLAG | XCHG_PARA_FLAG |
                            VALID_PARA_FLAG | USE1_PARA_FLAG,   // 41
                            szXchgManifold,
    "TestSigner3", 2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 42
                            szSignManifold,
    "UTF8", 2, VALID_PARA_FLAG | NO_EXT_PARA_FLAG,              // 43
                            NULL,
    "DssRoot", 44, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 44
                            NULL,
    "DssCA", 44, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 45
                            NULL,
    "DssEnd", 45, VALID_PARA_FLAG | NO_EXT_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 46
                            NULL,
    "ZeroNotAfter", 2, VALID_PARA_FLAG |
                            PROV_PARA_FLAG,                     // 47
                            NULL,
    "V1", 48, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            NO_CRL_EXT_PARA_FLAG,               // 48
                            NULL,
    "V2", 48, VALID_PARA_FLAG | NO_EXT_PARA_FLAG,               // 49
                            NULL,
    "DeltaEndValid", 1, DELTA_CRL_PARA_FLAG,                    // 50
                            NULL,
    "DeltaNoValid", 1, DELTA_CRL_PARA_FLAG | NO_EXT_PARA_FLAG,  // 51
                            NULL,
    "DeltaEndRevoked", 1, DELTA_CRL_PARA_FLAG |                 // 52
                            REVOKED_PARA_FLAG,
                            NULL,
    "DeltaCAValid", 1, DELTA_CRL_PARA_FLAG |                    // 53
                            CA_PARA_FLAG,
                            NULL,
    "DeltaCARevoked", 1, DELTA_CRL_PARA_FLAG |                  // 54
                            CA_PARA_FLAG |
                            REVOKED_PARA_FLAG,
                            NULL,
    "NoCDPValid",   1, DELTA_CRL_PARA_FLAG,                     // 55
                            NULL,
    "NoCDPRevoked", 1, DELTA_CRL_PARA_FLAG |                    // 56
                            REVOKED_PARA_FLAG,
                            NULL,
    "UnsupportedCDP", 1, DELTA_CRL_PARA_FLAG |                  // 57
                            REVOKED_PARA_FLAG,
                            NULL,
    "NotPermitted", 1, ALT_DIR_NAME_PARA_FLAG,                  // 58
                            NULL,
    "Excluded",     1, ALT_DIR_NAME_PARA_FLAG,                  // 59
                            NULL,

    "TestAIARoot", 60, CA_PARA_FLAG | NO_EXT_PARA_FLAG |        // 60
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIARevokeRoot", 61, CA_PARA_FLAG | NO_EXT_PARA_FLAG |  // 61
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIACA",  60, CA_PARA_FLAG | NO_EXT_PARA_FLAG |         // 62
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIACA",  61, CA_PARA_FLAG | NO_EXT_PARA_FLAG |
                            NO_CRL_EXT_PARA_FLAG |
                            REVOKED_PARA_FLAG,                  // 63
                            NULL,
    "TestAIAEnd",  63, NO_EXT_PARA_FLAG,                        // 64
                            NULL,
    "MissingNCCA", 0, CA_PARA_FLAG,                             // 65
                            NULL,
    "MissingNCEnd", 65, 0,                                      // 66
                            NULL,
};


#define EXPIRED_CRL_FLAG                    0x00000001
#define REMOVE_FROM_CRL_FLAG                0x00000002
#define HOLD_CRL_FLAG                       0x00000004
#define FRESHEST_CRL_FLAG                   0x00000010
#define NO_FRESHEST_CDP_CRL_FLAG            0x00000020
#define NO_IDP_CRL_FLAG                     0x00000100
#define ONLY_USERS_CRL_FLAG                 0x00000200
#define ONLY_CAS_CRL_FLAG                   0x00000400
#define UNSUPPORTED_IDP_OPTIONS_CRL_FLAG    0x00000800
#define UNSUPPORTED_CRITICAL_EXT_CRL_FLAG   0x00001000
#define NO_ENTRIES_CRL_FLAG                 0x00002000

typedef struct _BASE_DELTA_CRL_PARA {
    int         iBase;
    DWORD       dwFlags;
} BASE_DELTA_CRL_PARA;

static BASE_DELTA_CRL_PARA BaseDeltaCrlPara[] = {
    // Users Only: Base and Delta
    1, ONLY_USERS_CRL_FLAG,
    1, ONLY_USERS_CRL_FLAG | FRESHEST_CRL_FLAG,

    // CAs Only: Base and Delta
    2, ONLY_CAS_CRL_FLAG,
    2, ONLY_CAS_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Base has entries, Delta has no entries
    3, HOLD_CRL_FLAG,
    3, NO_ENTRIES_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Base has no entries, Delta has entries
    4, NO_ENTRIES_CRL_FLAG,
    4, FRESHEST_CRL_FLAG,

    // Base has entries, Delta has remove entries
    5, HOLD_CRL_FLAG,
    5, REMOVE_FROM_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Valid base, delta has unsupported IDP options
    6, HOLD_CRL_FLAG,
    6, FRESHEST_CRL_FLAG | UNSUPPORTED_IDP_OPTIONS_CRL_FLAG,

    // Expired base, valid delta
    7, EXPIRED_CRL_FLAG,
    7, FRESHEST_CRL_FLAG,

    // Valid base, expired delta
    8, 0,
    8, EXPIRED_CRL_FLAG | FRESHEST_CRL_FLAG,
    

    // Expired base, without a freshest CDP extension
    9, EXPIRED_CRL_FLAG | NO_FRESHEST_CDP_CRL_FLAG,
    9, FRESHEST_CRL_FLAG,

    // Base without IDP and no freshest, delta CRL
    10, NO_IDP_CRL_FLAG | NO_FRESHEST_CDP_CRL_FLAG,

    // Base and Delta CRL with unsupported critical ext
    11, UNSUPPORTED_CRITICAL_EXT_CRL_FLAG,
    11, UNSUPPORTED_CRITICAL_EXT_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Valid base with number > above delta indicator
    100, 0,
};
#define BASE_DELTA_CRL_CNT              \
                (sizeof(BaseDeltaCrlPara)/sizeof(BaseDeltaCrlPara[0]))

typedef struct _UPDATE_CTL_PARA {
    BOOL        fTimeInvalid;
    LPSTR       pszUsageObjId;
    LPSTR       pszListIdentifier;
    LPWSTR      pwszUrl;
} UPDATE_CTL_PARA;

static UPDATE_CTL_PARA UpdateCtlPara[] = {
    FALSE, "1.3.2000.1", "UpdateCtl1", L"file://testupdate1.ctl",
    TRUE,  "1.3.2000.1", "UpdateCtl1", L"file://testupdate1.ctl",
    FALSE, "1.3.2000.2", "UpdateCtl2", L"file://testupdate2.ctl",
    TRUE,  "1.3.2000.2", "UpdateCtl2", L"file://testupdate2.ctl",
};
#define UPDATE_CTL_CNT  (sizeof(UpdateCtlPara)/sizeof(UpdateCtlPara[0]))



#define RDN_CNT         4
#define ATTR_CNT        4

#define ATTR_0_OBJID    szOID_COMMON_NAME
#define ATTR_1_OBJID    "1.2.1"
#define ATTR_2_OBJID    "1.2.2"
#define UTF8_NAME       L"*** UTF8 ***"

// Attr[0] - CertPara[].pszName
// Attr[1] - "xchg" | "sign"
// Attr[2] - "default" | pszContainer

static LPSTR rgpszUsageIdentifier[] = {
    "1.2.3.0",                          // 0
    "1.2.3.1",                          // 1
    "1.2.3.2",                          // 2
    "1.2.3.2.1"                         // 3
};

static CTL_USAGE rgCtlUsage[] = {
    1, &rgpszUsageIdentifier[0],        // 0
    1, &rgpszUsageIdentifier[1],        // 1
    2, &rgpszUsageIdentifier[2],        // 2
    3, &rgpszUsageIdentifier[1]         // 3
};

static PCCERT_CONTEXT rgpCertContext[CERT_CNT];

void MySystemTimeToFileTime(
    SYSTEMTIME *pSystemTime,
    FILETIME   *pFileTime
    )
{
    SYSTEMTIME TmpTime;

    if (!SystemTimeToFileTime(pSystemTime, pFileTime)) {
        TmpTime = *pSystemTime;

        // Following is a fix for Feb 29, 2000 when advancing the year forward or backward.
        TmpTime.wDay = 1;
        SystemTimeToFileTime(&TmpTime, pFileTime);
    }
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}


//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}


static
VOID
WINAPI
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
static LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    PrintError("Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

static HCRYPTPROV GetCryptProv(
    DWORD dwProvType,
    LPCSTR pszProvider = NULL,
    LPCSTR pszInContainer = pszContainer,
    DWORD dwBitLen = 0
    )
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;
    DWORD dwFlags;

    if (fMachine)
        dwFlags = CRYPT_MACHINE_KEYSET;
    else
        dwFlags = 0;

    fResult = CryptAcquireContext(
            &hProv,
            pszInContainer,
            pszProvider,
            dwProvType,
            dwFlags
            );

    if (fResult) {
        if (fGenerate) {
            // Delete the existing keys
            CryptReleaseContext(hProv, 0);
            printf("Deleting existing private keys\n");
    
            // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
            // and must not be released.
            fResult = CryptAcquireContext(
                    &hProv,
                    pszInContainer,
                    pszProvider,
                    dwProvType,
                    dwFlags | CRYPT_DELETEKEYSET
                    );
            if (!fResult) {
                PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
                return 0;
            }
            hProv = 0;
        }
    }

    if (0 == hProv) {
        printf("Creating new private keys\n");
        fResult = CryptAcquireContext(
                &hProv,
                pszInContainer,
                pszProvider,
                dwProvType,
                dwFlags | CRYPT_NEWKEYSET
                );
        if (!fResult || hProv == 0) {
            PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
            return 0;
        }
    }

    HCRYPTKEY hKey = 0;
    dwFlags = dwBitLen << 16;
    if (fExportable)
        dwFlags |= CRYPT_EXPORTABLE;

    if (CryptGetUserKey(
            hProv,
            AT_SIGNATURE,
            &hKey
            )) {
        printf("Using existing SIGNATURE private key\n");
        CryptDestroyKey(hKey);
        hKey = 0;
    } else {
        printf("Generating SIGNATURE private key\n");
        fResult = CryptGenKey(
                hProv,
                AT_SIGNATURE,
                dwFlags,
                &hKey
                );
        if (!fResult || hKey == 0)
            PrintLastError("CryptGenKey(AT_SIGNATURE)");
        else
            CryptDestroyKey(hKey);
    }

    if (PROV_DSS == dwProvType)
        return hProv;

    if (CryptGetUserKey(
            hProv,
            AT_KEYEXCHANGE,
            &hKey
            )) {
        printf("Using existing EXCHANGE private key\n");
        CryptDestroyKey(hKey);
        hKey = 0;
    } else {
        printf("Generating EXCHANGE private key\n");
        hKey = 0;
        fResult = CryptGenKey(
                hProv,
                AT_KEYEXCHANGE,
                dwFlags,
                &hKey
                );
        if (!fResult || hKey == 0)
            PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
        else
            CryptDestroyKey(hKey);
    }

    return hProv;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hCryptProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");

    return hStore;
}

static void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}

static BOOL CreateEnhancedKeyUsage(
        IN DWORD dwFlags,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    PCTL_USAGE pCtlUsage;

    dwFlags &= USE1_PARA_FLAG | USE2_PARA_FLAG;

    switch (dwFlags) {
        case 0:
            pCtlUsage = &rgCtlUsage[0];
            break;
        case USE1_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[1];
            break;
        case USE2_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[2];
            break;
        case USE1_PARA_FLAG | USE2_PARA_FLAG:
        default:
            pCtlUsage = &rgCtlUsage[3];
            break;
    }

    return AllocAndEncodeObject(
        X509_ENHANCED_KEY_USAGE,
        (const void *) pCtlUsage,
        ppbEncoded,
        pcbEncoded
        );
}


static BOOL CreateNextUpdateLocation(
        DWORD dwCert,
        BOOL fProp,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded,
        IN OPTIONAL LPWSTR pwszUrl = NULL
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_ALT_NAME_INFO AltNameInfo;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[5];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://file1.ctl";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = L"http://timestamp/ctltest/http1.ctl";

    rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[3].pwszURL = L"file://file2.ctl";
    rgAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[4].pwszURL = L"http://timestamp/ctltest/http2.ctl";

    if (dwCert == UPDATE_CTL_SIGNER) {
        rgAltNameEntry[1].pwszURL = L"file://nonexistant1.ctl";
        rgAltNameEntry[2].pwszURL = L"file://nonexistant2.ctl";
        if (pwszUrl)
            rgAltNameEntry[3].pwszURL = pwszUrl;
        else
            rgAltNameEntry[3].pwszURL = L"file://testupdate1.ctl";
        rgAltNameEntry[4].pwszURL = L"file://nonexistant3.ctl";
        AltNameInfo.cAltEntry = 5;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[0];
    } else if (fProp) {
        if (CertPara[dwCert].dwFlags & HTTP_PARA_FLAG)
            AltNameInfo.cAltEntry = 2;
        else
            AltNameInfo.cAltEntry = 1;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[3];
    } else {
        if (CertPara[dwCert].dwFlags & HTTP_PARA_FLAG)
            AltNameInfo.cAltEntry = 5;
        else
            AltNameInfo.cAltEntry = 2;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[0];
    }

    if (!AllocAndEncodeObject(
            X509_ALTERNATE_NAME,
            &AltNameInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL AddCert(
    HCERTSTORE hStore,
    DWORD dwCert,
    BYTE *pbEncoded,
    DWORD cbEncoded)
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;

    fResult = CertAddEncodedCertificateToStore(hStore, dwCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            printf("Cert already exists in store. Adding duplicate\n");
            fResult = CertAddEncodedCertificateToStore(hStore,
                dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_ALWAYS, &pCert);
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCertificateToStore");
    } else {
        fResult = CertAddEncodedCertificateToStore(hStore,
            dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCert);
        if (!fResult)
            PrintLastError("CertAddEncodedCertificateToStore");
    }
    if (pCert) {
        if (CertPara[dwCert].dwFlags & PROV_PARA_FLAG) {
            CRYPT_KEY_PROV_INFO KeyProvInfo;
            memset(&KeyProvInfo, 0, sizeof(KeyProvInfo));
            if ((CertPara[dwCert].dwFlags & DSS_PARA_FLAG) &&
                    (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG))
                KeyProvInfo.pwszContainerName = DSS_512_CONTAINER_NAME_W;
            else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
                KeyProvInfo.pwszContainerName = ENH_1024_CONTAINER_NAME_W;
            else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
                KeyProvInfo.pwszContainerName = ENH_2048_CONTAINER_NAME_W;
            else if (pwszContainer)
                KeyProvInfo.pwszContainerName = pwszContainer;
            if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG)
                KeyProvInfo.dwProvType = TEST_PROV_DSS;
            else
                KeyProvInfo.dwProvType = PROV_RSA_FULL;
            if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG) {
                KeyProvInfo.dwFlags = CERT_SET_KEY_PROV_HANDLE_PROP_ID;
                KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
            } else
                KeyProvInfo.dwKeySpec = AT_SIGNATURE;
            if (fMachine)
                KeyProvInfo.dwFlags |= CRYPT_MACHINE_KEYSET;

            fResult = CertSetCertificateContextProperty(
                pCert,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,                          // dwFlags
                &KeyProvInfo
                );
            if (!fResult)
                PrintLastError("CertSetCertificateContextProperty");
        }

        if (((CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) &&
                (CertPara[dwCert].dwFlags &
                    (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))
                        ||
            (CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) ==
                (USE1_PARA_FLAG | USE2_PARA_FLAG)) {

            CRYPT_DATA_BLOB Data;
            DWORD dwFlags = CertPara[dwCert].dwFlags;
            if (0 == (CertPara[dwCert].dwFlags &
                    (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))
                dwFlags = 0;
            if (CreateEnhancedKeyUsage(
                    dwFlags,
                    &Data.pbData,
                    &Data.cbData)) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CTL_USAGE_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(CTL_USAGE)");
                TestFree(Data.pbData);
            }
        }

        if (CertPara[dwCert].dwFlags & AUX1_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[4];
            BYTE rgbAux0[] = {0x11, 0x0};
            BYTE rgbAux1[] = {0x11, 0x1};
            BYTE rgbAux2[] = {0x11, 0x2, 0x2};
            BYTE rgbAux3[] = {0x11, 0x3, 0x3, 0x3};

            Data[0].pbData = NULL;
            Data[0].cbData = 0;
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);
            Data[3].pbData = rgbAux3;
            Data[3].cbData = sizeof(rgbAux3);

            for (i = 0; i < 4; i++) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                    break;
                }
            }
        }

        if (CertPara[dwCert].dwFlags & AUX2_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[3];
            BYTE rgbAux0[] = {0x22, 0x2, 0x2};
            BYTE rgbAux1[] = {0x22, 0x3, 0x3, 0x3};
            BYTE rgbAux2[] = {0x22, 0x4, 0x4, 0x4, 0x4, 0x12, 0x34};

            Data[0].pbData = rgbAux0;
            Data[0].cbData = sizeof(rgbAux0);
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);

            for (i = 0; i < 3; i++) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + 2 + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                    break;
                }
            }

            if (CertPara[dwCert].dwFlags & AUX1_PARA_FLAG) {
                // Delete CERT_FIRST_USER_PROP_ID + 1
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + 1,
                        0,                          // dwFlags
                        NULL
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                }
            }
        }
        CertFreeCertificateContext(pCert);
    }
    return fResult;
}

static BOOL AddCrl(
    HCERTSTORE hStore,
    DWORD dwCert,
    DWORD dwAuxFlags,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    BOOL fDuplicate = FALSE
    )
{
    BOOL fResult;
    PCCRL_CONTEXT pCrl = NULL;

    fResult = CertAddEncodedCRLToStore(hStore, dwCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            if (fDuplicate ||
                    0 == strcmp("TestAIACA", CertPara[dwCert].pszName)) {
                printf("CRL already exists in store. Adding duplicate\n");
                fResult = CertAddEncodedCRLToStore(hStore,
                    dwCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, &pCrl);
            }
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCRLToStore");
    } else {
        if (fDuplicate)
            printf("AddCrl failed => ADD_NEW duplicate succeeded\n");

        fResult = CertAddEncodedCRLToStore(hStore,
            dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCrl);
        if (!fResult)
            PrintLastError("CertAddEncodedCRLToStore");
    }
    if (pCrl) {
        if (dwAuxFlags & AUX1_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[4];
            BYTE rgbAux0[] = {0x11, 0x0};
            BYTE rgbAux1[] = {0x11, 0x1};
            BYTE rgbAux2[] = {0x11, 0x2, 0x2};
            BYTE rgbAux3[] = {0x11, 0x3, 0x3, 0x3};

            Data[0].pbData = NULL;
            Data[0].cbData = 0;
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);
            Data[3].pbData = rgbAux3;
            Data[3].cbData = sizeof(rgbAux3);

            for (i = 0; i < 4; i++) {
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCRLContextProperty");
                    break;
                }
            }
        }

        if (dwAuxFlags & AUX2_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[3];
            BYTE rgbAux0[] = {0x22, 0x2, 0x2};
            BYTE rgbAux1[] = {0x22, 0x3, 0x3, 0x3};
            BYTE rgbAux2[] = {0x22, 0x4, 0x4, 0x4, 0x4, 0x12, 0x34};

            Data[0].pbData = rgbAux0;
            Data[0].cbData = sizeof(rgbAux0);
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);

            for (i = 0; i < 3; i++) {
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID + 2 + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCRLContextProperty");
                    break;
                }
            }
        }
        CertFreeCRLContext(pCrl);
    }
    return fResult;
}


static BOOL AddCtl(
    HCERTSTORE hStore,
    DWORD dwCert,
    BYTE *pbEncoded,
    DWORD cbEncoded)
{
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;

    fResult = CertAddEncodedCTLToStore(hStore, dwMsgAndCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            printf("CTL already exists in store. Adding duplicate\n");
            fResult = CertAddEncodedCTLToStore(hStore,
                dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_ALWAYS, &pCtl);
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCTLToStore");
    } else {
        fResult = CertAddEncodedCTLToStore(hStore,
            dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCtl);
        if (!fResult)
            PrintLastError("CertAddEncodedCTLToStore");
    }
    if (pCtl) {
        if (0 == (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)) {
            CRYPT_DATA_BLOB Data;

            if (CreateNextUpdateLocation(
                    dwCert,
                    TRUE,               // fProp
                    &Data.pbData,
                    &Data.cbData)) {
                if (!CertSetCTLContextProperty(
                        pCtl,
                        CERT_NEXT_UPDATE_LOCATION_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(NEXT_UPDATE)");
                TestFree(Data.pbData);
            }
        }
        CertFreeCTLContext(pCtl);
    }
    return fResult;
}

#define AKI2_KEYID              0
#define AKI2_NONE               1
#define AKI2_FULL               2
#define AKI2_BAD_KEYID          3
#define AKI2_BAD_ISSUER         4
#define AKI2_BAD_SERIAL_NUMBER  5

#define AKI2_CNT                6

// On 02-May-01 updated to not look at the IssuerAndSerialNumber in the CRL's
// AKI
#define AKI2_BAD_CNT            1



static BOOL EncodeCert(DWORD dwCert, BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL EncodeCrl(
    DWORD dwCert,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded,
    DWORD dwAki = AKI2_KEYID
    );
static BOOL EncodeBaseOrDeltaCrl(
    DWORD dwIssuer,
    int iBase,
    DWORD dwFlags,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );
static BOOL EncodeCtl(DWORD dwCert, DWORD dwEncodeFlags, BYTE **ppbEncoded,
        DWORD *pcbEncoded);

static BOOL EncodeUpdateCtl(
    BOOL fTimeInvalid,
    LPSTR pszUsageObjId,
    LPSTR pszListIdentifier,
    LPWSTR pwszUrl,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );



static void Usage(void)
{
    printf("Usage: tstore2 [options] <StoreFilename>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -g                    - Generate new keys\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -M                    - Store in local Machine, not current User\n");
    printf("  -P                    - Use enhanced and DSS providers\n");
    printf("  -I                    - Inherit DSS public key parameters\n");
    printf("  -K                    - Keep extra Crls\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[])
{
    LPSTR pszStoreFilename = NULL;
    HANDLE hStore = 0;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD i;
    BOOL fKeepCrls = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                pszContainer = argv[0]+2;
                pwszContainer = AllocAndSzToWsz(pszContainer);
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    Usage();
                    return -1;
                }
                break;
            case 'g':
                fGenerate = TRUE;
                break;
            case 'E':
                fExportable = TRUE;
                break;
            case 'M':
                fMachine = TRUE;
                break;
            case 'P':
                fProviders = TRUE;
                break;
            case 'I':
                fInheritParameters = TRUE;
                break;
            case 'K':
                fKeepCrls = TRUE;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        } else
            pszStoreFilename = argv[0];
    }


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    printf("command line: %s\n", GetCommandLine());

    // Get time used time stamping and serial numbers
    GetSystemTime(&TestTime);
    TestTime.wMilliseconds = 0;

    printf("Getting RSA provider\n");
    hRSACryptProv = GetCryptProv(PROV_RSA_FULL, MS_DEF_PROV_A);
    if (hRSACryptProv == 0)
        return -1;

    printf("Getting DSS provider\n");
    hDSSCryptProv = GetCryptProv(TEST_PROV_DSS);

    if (fProviders) {
        printf("Getting Enhanced RSA provider (1024 bit)\n");
        hEnh1024CryptProv = GetCryptProv(PROV_RSA_FULL, MS_ENHANCED_PROV_A,
            ENH_1024_CONTAINER_NAME_A, 1024);
        if (hEnh1024CryptProv == 0)
            return -1;

        printf("Getting Enhanced RSA provider (2048 bit)\n");
        hEnh2048CryptProv = GetCryptProv(PROV_RSA_FULL, MS_ENHANCED_PROV_A,
            ENH_2048_CONTAINER_NAME_A, 2048);
        if (hEnh2048CryptProv == 0)
            return -1;

        printf("Getting DSS provider (512 bit)\n");
        hDSS512CryptProv = GetCryptProv(TEST_PROV_DSS, NULL,
            DSS_512_CONTAINER_NAME_A, 512);
    } else {
        // Disable all enhanced provider flags
        for (i = 0; i < CERT_CNT; i++)
            CertPara[i].dwFlags &= ~(DSS_512_PARA_FLAG |
                ENH_1024_PARA_FLAG | ENH_2048_PARA_FLAG);
    }

    // Attempt to open the store
    hStore = OpenStore(pszStoreFilename);
    if (hStore == NULL)
        goto ErrorReturn;

    // Encode certs and CRLs and add to the store.
    for (i = 0; i < CERT_CNT; i++) {
        if (EncodeCert(i, &pbEncoded, &cbEncoded)) {
            rgpCertContext[i] = CertCreateCertificateContext(
                dwCertEncodingType, pbEncoded, cbEncoded);
            AddCert(hStore, i, pbEncoded, cbEncoded);
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }

        if (CertPara[i].dwFlags & CA_PARA_FLAG) {
            if (CertPara[i].dwFlags & DUPLICATE_CRL_PARA_FLAG) {
                DWORD dwAki;
                for (dwAki = 0; dwAki < AKI2_CNT; dwAki++) {
                    if (EncodeCrl(i, &pbEncoded, &cbEncoded, dwAki)) {
                        if (AKI2_BAD_SERIAL_NUMBER == dwAki)
                            // Modify the signature
                            pbEncoded[cbEncoded -1] ^= 0xFF;

                        AddCrl(hStore, i, AUX1_PARA_FLAG, pbEncoded, cbEncoded);
                        AddCrl(hStore, i, AUX2_PARA_FLAG, pbEncoded, cbEncoded,
                            TRUE);
                        TestFree(pbEncoded);
                        pbEncoded = NULL;
                    }
                }
            } else {
                if (EncodeCrl(i, &pbEncoded, &cbEncoded)) {
                    AddCrl(hStore, i, 0, pbEncoded, cbEncoded);
                    TestFree(pbEncoded);
                    pbEncoded = NULL;
                }
            }
        }
    }

    // Test CertFindCRLInStore(CRL_FIND_ISSUED_BY)
    for (i = 0; i < CERT_CNT; i++) {
        if ((CA_PARA_FLAG | DUPLICATE_CRL_PARA_FLAG) ==
                ((CA_PARA_FLAG | DUPLICATE_CRL_PARA_FLAG) &
                    CertPara[i].dwFlags)) {
            PCCERT_CONTEXT pIssuer = rgpCertContext[i];
            DWORD dwCnt;
            PCCRL_CONTEXT pCrl;

            printf("CertFindCRLInStore(CRL_FIND_ISSUED_BY) [%d]\n", i);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    0,                      // dwFindFlags
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if ((AKI2_CNT * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY failed count => expected: %d actual: %d\n",
                    AKI2_CNT * 2, dwCnt);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    CRL_FIND_ISSUED_BY_AKI_FLAG,
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if (((AKI2_CNT - AKI2_BAD_CNT) * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY(AKI_FLAG) failed count => expected: %d actual: %d\n",
                    (AKI2_CNT - AKI2_BAD_CNT) * 2, dwCnt);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    CRL_FIND_ISSUED_BY_SIGNATURE_FLAG,
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if (((AKI2_CNT - 1) * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY(SIGNATURE_FLAG) failed count => expected: %d actual: %d\n",
                    (AKI2_CNT - 1) * 2, dwCnt);

            if (!fKeepCrls) {
                // Delete all but the last pair of duplicates

                dwCnt = 0;
                pCrl = NULL;
                while (pCrl = CertFindCRLInStore(
                        hStore,
                        dwCertEncodingType,
                        0,                      // dwFindFlags
                        CRL_FIND_ISSUED_BY,
                        (const void *) pIssuer,
                        pCrl
                        )) {
                    PCCRL_CONTEXT pDeleteCrl = CertDuplicateCRLContext(pCrl);
                    CertDeleteCRLFromStore(pDeleteCrl);
                    if (((AKI2_CNT - 1) * 2) == ++dwCnt) {
                        CertFreeCRLContext(pCrl);
                        break;
                    }
                }

                dwCnt = 0;
                pCrl = NULL;
                while (pCrl = CertFindCRLInStore(
                        hStore,
                        dwCertEncodingType,
                        CRL_FIND_ISSUED_BY_AKI_FLAG |
                            CRL_FIND_ISSUED_BY_SIGNATURE_FLAG,
                        CRL_FIND_ISSUED_BY,
                        (const void *) pIssuer,
                        pCrl
                        ))
                    dwCnt++;
                if (2 != dwCnt)
                    printf("CRL_FIND_ISSUED_BY(After delete) failed count => expected: %d actual: %d\n",
                        2, dwCnt);
            }
        }
    }

    // Encode CTLs and add to the store.
    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwFlags & (CTL1_PARA_FLAG | CTL2_PARA_FLAG)) {
            if (EncodeCtl(i, 0, &pbEncoded, &cbEncoded)) {
                AddCtl(hStore, i, pbEncoded, cbEncoded);
                TestFree(pbEncoded);
                pbEncoded = NULL;
            }
            if (EncodeCtl(
                    i,
#ifdef CMS_PKCS7
                    CMSG_CMS_ENCAPSULATED_CTL_FLAG |
#endif  // CMS_PKCS7
                    CMSG_ENCODE_SORTED_CTL_FLAG |
                        ((CertPara[i].dwFlags & CTL1_PARA_FLAG) ? 0 :
                            CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG),
                    &pbEncoded,
                    &cbEncoded)) {
                AddCtl(hStore, i, pbEncoded, cbEncoded);
                TestFree(pbEncoded);
                pbEncoded = NULL;
            }
        }
    }

    for (i = 0; i < BASE_DELTA_CRL_CNT; i++) {
        if (EncodeBaseOrDeltaCrl(
                BASE_OR_DELTA_CA_ISSUER,
                BaseDeltaCrlPara[i].iBase,
                BaseDeltaCrlPara[i].dwFlags,
                &pbEncoded,
                &cbEncoded)) {
            BOOL fResult;

            fResult = CertAddEncodedCRLToStore(hStore,
                dwCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, NULL);
            if (!fResult)
                PrintLastError("CertAddEncodedCRLToStore");
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }
    }

    for (i = 0; i < UPDATE_CTL_CNT; i++) {
        if (EncodeUpdateCtl(
                UpdateCtlPara[i].fTimeInvalid,
                UpdateCtlPara[i].pszUsageObjId,
                UpdateCtlPara[i].pszListIdentifier,
                UpdateCtlPara[i].pwszUrl,
                &pbEncoded,
                &cbEncoded)) {
            BOOL fResult;

            fResult = CertAddEncodedCTLToStore(hStore,
                dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, NULL);
            if (!fResult)
                PrintLastError("CertAddEncodedCTLToStore");
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }
    }

    for (i = 0; i < CERT_CNT; i++)
        CertFreeCertificateContext(rgpCertContext[i]);


    SaveStore(hStore, pszStoreFilename);

ErrorReturn:
    if (pbEncoded)
        TestFree(pbEncoded);

    if (hStore) {
        if (!CertCloseStore(hStore, 0))
            PrintLastError("CertCloseStore");
    }

    if (hRSACryptProv)
        CryptReleaseContext(hRSACryptProv, 0);
    if (hEnh1024CryptProv)
        CryptReleaseContext(hEnh1024CryptProv, 0);
    if (hEnh2048CryptProv)
        CryptReleaseContext(hEnh2048CryptProv, 0);
    if (hDSSCryptProv)
        CryptReleaseContext(hDSSCryptProv, 0);
    if (hDSS512CryptProv)
        CryptReleaseContext(hDSS512CryptProv, 0);

    if (pwszContainer)
        TestFree(pwszContainer);

    printf("Done.\n");

    return 0;
}


static BOOL AllocAndSignToBeSigned(
    DWORD dwIssuer,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    BYTE **ppbSignature,
    DWORD *pcbSignature)
{
    BOOL fResult;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    HCRYPTPROV hProv;

    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwIssuer].dwFlags & DSS_512_PARA_FLAG)
            hProv = hDSS512CryptProv;
        else
            hProv = hDSSCryptProv;
    } else if (CertPara[dwIssuer].dwFlags & ENH_1024_PARA_FLAG)
        hProv = hEnh1024CryptProv;
    else if (CertPara[dwIssuer].dwFlags & ENH_2048_PARA_FLAG)
        hProv = hEnh2048CryptProv;
    else
        hProv = hRSACryptProv;

    cbSignature = 0;
    CryptSignCertificate(
                hProv,
                AT_SIGNATURE,
                dwCertEncodingType,
                pbToBeSigned,
                cbToBeSigned,
                pSignatureAlgorithm,
                NULL,                   // pvHashAuxInfo
                NULL,                   // pbSignature
                &cbSignature
                );
    if (cbSignature == 0) {
        PrintLastError("AllocAndSignToBeSigned::CryptSignCertificate(cb == 0)");
        goto ErrorReturn;
    }
    pbSignature = (BYTE *) TestAlloc(cbSignature);
    if (pbSignature == NULL) goto ErrorReturn;
    if (!CryptSignCertificate(
                hProv,
                AT_SIGNATURE,
                dwCertEncodingType,
                pbToBeSigned,
                cbToBeSigned,
                pSignatureAlgorithm,
                NULL,                   // pvHashAuxInfo
                pbSignature,
                &cbSignature
                )) {
        PrintLastError("AllocAndSignToBeSigned::CryptSignCertificate");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pbSignature) {
        TestFree(pbSignature);
        pbSignature = NULL;
    }
    cbSignature = 0;
CommonReturn:
    *ppbSignature = pbSignature;
    *pcbSignature = cbSignature;
    return fResult;
}

static BOOL EncodeSignedContent(
    DWORD dwIssuer,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    CERT_SIGNED_CONTENT_INFO CertEncoding;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        SIGNATURE_ALG_OBJID, 0, 0
    };

    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;

    if (!AllocAndSignToBeSigned(dwIssuer, pbToBeSigned, cbToBeSigned,
            &SignatureAlgorithm, &pbSignature, &cbSignature))
        goto ErrorReturn;

    memset(&CertEncoding, 0, sizeof(CertEncoding));
    CertEncoding.ToBeSigned.pbData = pbToBeSigned;
    CertEncoding.ToBeSigned.cbData = cbToBeSigned;
    CertEncoding.SignatureAlgorithm = SignatureAlgorithm;
    CertEncoding.Signature.pbData = pbSignature;
    CertEncoding.Signature.cbData = cbSignature;

    if (!AllocAndEncodeObject(
            X509_CERT,
            &CertEncoding,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSignature)
        TestFree(pbSignature);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL GetPublicKey(
    DWORD dwCert,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo)
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD dwKeySpec;
    HCRYPTPROV hProv;

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        dwKeySpec = AT_KEYEXCHANGE;
    else
        dwKeySpec = AT_SIGNATURE;

    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG)
            hProv = hDSS512CryptProv;
        else
            hProv = hDSSCryptProv;
    } else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
        hProv = hEnh1024CryptProv;
    else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
        hProv = hEnh2048CryptProv;
    else
        hProv = hRSACryptProv;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbPubKeyInfo);
    if (pPubKeyInfo == NULL) goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    if (fInheritParameters) {
        DWORD dwIssuer = CertPara[dwCert].dwIssuer;

        if (dwCert != dwIssuer &&
                0 == (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG) &&
                0 == (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG) &&
                0 != (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) &&
                0 == (CertPara[dwIssuer].dwFlags & DSS_512_PARA_FLAG) &&
                0 != (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)) {
            pPubKeyInfo->Algorithm.Parameters.cbData = 0;
            pPubKeyInfo->Algorithm.Parameters.pbData = NULL;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        TestFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}

#define SHA1_HASH_LEN 20
static BOOL Sha1HashPublicKey(
    DWORD dwCert,
    BYTE rgbHash[SHA1_HASH_LEN]
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbHash;

    // Get Certificates's PUBLIC KEY. SHA1 hash the encoded public key.
    if (!GetPublicKey(dwCert, &pPubKeyInfo)) goto ErrorReturn;

#if 1
    cbHash = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            0,                  // hCryptProv
            CALG_SHA1,
            0,
            dwCertEncodingType,
            pPubKeyInfo,
            rgbHash,
            &cbHash)) {
        PrintLastError("Sha1HashPublicKey::CryptHashPublicKeyInfo");
        goto ErrorReturn;
    }
#else
    cbHash = SHA1_HASH_LEN;
    if (!CryptHashCertificate(
            0,                  // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            pPubKeyInfo->PublicKey.pbData,
            pPubKeyInfo->PublicKey.cbData,
            rgbHash,
            &cbHash)) {
        PrintLastError("Sha1HashPublicKey::CryptHashCertificate");
        goto ErrorReturn;
    }
#endif

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    memset(rgbHash, 0, SHA1_HASH_LEN);
CommonReturn:
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    return fResult;
}

static void CreateNameInfo(
    DWORD dwCert,
    PCERT_NAME_INFO pInfo,
    PCERT_RDN pRDN,
    CERT_RDN_ATTR rgAttr[]
    )
{
    LPSTR pszKey;
    LPSTR pszUser;
    DWORD i;


    assert(RDN_CNT == ATTR_CNT);
    for (i = 0; i < RDN_CNT; i++) {
        pRDN[i].cRDNAttr = 1;
        pRDN[i].rgRDNAttr = &rgAttr[i];
    }

    if (CertPara[dwCert].dwFlags & NO_NAME_PARA_FLAG) {
        pInfo->cRDN = 0;
        pInfo->rgRDN = NULL;
    } else if (CertPara[dwCert].dwFlags & VALID_PARA_FLAG) {
        pInfo->cRDN = 1;
        pInfo->rgRDN = pRDN;
    } else if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        pInfo->cRDN = RDN_CNT - 1;
        pInfo->rgRDN = pRDN;
    } else {
        pInfo->cRDN = RDN_CNT;
        pInfo->rgRDN = pRDN;
    }

    rgAttr[0].pszObjId = ATTR_0_OBJID;
    if (0 == strcmp("UTF8", CertPara[dwCert].pszName)) {
        rgAttr[0].dwValueType = CERT_RDN_UTF8_STRING;
        rgAttr[0].Value.pbData = (BYTE *) UTF8_NAME;
        rgAttr[0].Value.cbData = wcslen(UTF8_NAME) * sizeof(WCHAR);
    } else {
        rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
        rgAttr[0].Value.pbData = (BYTE *) CertPara[dwCert].pszName;
        rgAttr[0].Value.cbData = strlen(CertPara[dwCert].pszName);
    }

    rgAttr[1].pszObjId = ATTR_1_OBJID;
    rgAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        pszKey = "xchg";
    else
        pszKey = "sign";
    rgAttr[1].Value.pbData = (BYTE *) pszKey;
    rgAttr[1].Value.cbData = strlen(pszKey);

    rgAttr[2].pszObjId = ATTR_2_OBJID;
    rgAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (pszContainer)
        pszUser = pszContainer;
    else
        pszUser = "default";
    rgAttr[2].Value.pbData = (BYTE *) pszUser;
    rgAttr[2].Value.cbData = strlen(pszUser);

    rgAttr[3].pszObjId = szOID_RSA_emailAddr;
    rgAttr[3].dwValueType = CERT_RDN_IA5_STRING;
    rgAttr[3].Value.pbData = (BYTE *) "MyEmail@WhereEver.com";
    rgAttr[3].Value.cbData = strlen("MyEmail@WhereEver.com");

    assert(ATTR_CNT == 3+1);
}

static BOOL CreateAuthorityKeyId(
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_KEY_ID_INFO KeyIdInfo;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber;

    memset(&KeyIdInfo, 0, sizeof(KeyIdInfo));

    // Issuer's KeyId
    KeyIdInfo.KeyId.pbData = (BYTE *) &dwIssuer;
    KeyIdInfo.KeyId.cbData = sizeof(dwIssuer);

    // Issuer's Issuer
    CreateNameInfo(CertPara[dwIssuer].dwIssuer,
        &Name, rgRDN, rgAttr);

    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbNameEncoded,
            &cbNameEncoded))
        goto ErrorReturn;

    KeyIdInfo.CertIssuer.pbData = pbNameEncoded;
    KeyIdInfo.CertIssuer.cbData = cbNameEncoded;

    // Issuer's SerialNumber
    {
        SYSTEMTIME SystemTime = TestTime;
        SystemTime.wMilliseconds += (WORD) dwIssuer;
        MySystemTimeToFileTime(&SystemTime, &SerialNumber);
    }
    KeyIdInfo.CertSerialNumber.pbData = (BYTE *) &SerialNumber;
    KeyIdInfo.CertSerialNumber.cbData = sizeof(SerialNumber);

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateAuthorityKeyId2(
        DWORD dwCert,
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded,
        IN DWORD dwAki = AKI2_KEYID
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_KEY_ID2_INFO KeyId2Info;
    CERT_ALT_NAME_ENTRY AltNameEntry;

    BYTE rgbPubKeyHash[SHA1_HASH_LEN];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber;

    memset(&KeyId2Info, 0, sizeof(KeyId2Info));

    // Issuer's KeyId
    if (AKI2_BAD_KEYID == dwAki)
        memset(rgbPubKeyHash, 0xba, sizeof(rgbPubKeyHash));
    else
        Sha1HashPublicKey(dwIssuer, rgbPubKeyHash);
    KeyId2Info.KeyId.pbData = rgbPubKeyHash;
    KeyId2Info.KeyId.cbData = sizeof(rgbPubKeyHash);

    if (AKI2_FULL == dwAki ||
            AKI2_BAD_ISSUER == dwAki ||
            AKI2_BAD_SERIAL_NUMBER == dwAki ||
            (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG)) {

        if (AKI2_BAD_ISSUER == dwAki) {
            Name.cRDN = 1;
            Name.rgRDN = rgRDN;
            rgRDN[0].cRDNAttr = 1;
            rgRDN[0].rgRDNAttr = rgAttr;

            rgAttr[0].pszObjId = szOID_COMMON_NAME;
            rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
            rgAttr[0].Value.pbData = (BYTE *) "AKI2BadIssuer";
            rgAttr[0].Value.cbData = strlen("AKI2BadIssuer");
        } else
            // Issuer's Issuer
            CreateNameInfo(CertPara[dwIssuer].dwIssuer,
                &Name, rgRDN, rgAttr);

        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbNameEncoded,
                &cbNameEncoded))
            goto ErrorReturn;

        AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        AltNameEntry.DirectoryName.pbData = pbNameEncoded;
        AltNameEntry.DirectoryName.cbData = cbNameEncoded;
        KeyId2Info.AuthorityCertIssuer.cAltEntry = 1;
        KeyId2Info.AuthorityCertIssuer.rgAltEntry = &AltNameEntry;

        // Issuer's SerialNumber
        {
            SYSTEMTIME SystemTime = TestTime;
            if (AKI2_BAD_SERIAL_NUMBER == dwAki)
                SystemTime.wMilliseconds += CERT_CNT;
            else
                SystemTime.wMilliseconds += (WORD) dwIssuer;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber);
        }
        KeyId2Info.AuthorityCertSerialNumber.pbData = (BYTE *) &SerialNumber;
        KeyId2Info.AuthorityCertSerialNumber.cbData = sizeof(SerialNumber);
    }

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_KEY_ID2,
            &KeyId2Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateAuthorityInfoAccess(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwIssuer = CertPara[dwCert].dwIssuer;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_INFO_ACCESS AuthorityInfoAccess;

#define ACCESS_DESCR_COUNT  10 
    CERT_ACCESS_DESCRIPTION rgAccess[ACCESS_DESCR_COUNT];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;

    // Issuer's Issuer
    CreateNameInfo(CertPara[dwIssuer].dwIssuer, &Name, rgRDN, rgAttr);

    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbNameEncoded,
            &cbNameEncoded))
        goto ErrorReturn;

    rgAccess[0].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[0].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[1].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[1].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgAccess[1].AccessLocation.DirectoryName.pbData = pbNameEncoded;
    rgAccess[1].AccessLocation.DirectoryName.cbData = cbNameEncoded;
    rgAccess[2].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[2].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAccess[2].AccessLocation.pwszRfc822Name = L"issuer@mail.com";
    rgAccess[3].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[3].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[3].AccessLocation.pwszURL = L"URL to the POLICY";
    rgAccess[4].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[4].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[4].AccessLocation.pwszURL = L"http://URLToTheIssuerCertificate";
    rgAccess[5].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[5].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[5].AccessLocation.pwszURL = L"ldap://ntdev.microsoft.com/c=us??sub";
    rgAccess[6].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[6].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[6].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[7].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[7].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[7].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[8].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[8].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[8].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[9].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[9].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[9].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";

    memset(&AuthorityInfoAccess, 0, sizeof(AuthorityInfoAccess));
    if (0 == strcmp("TestAIAEnd", CertPara[dwCert].pszName)) {
        rgAccess[0].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
        rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAccess[0].AccessLocation.pwszURL = L"file://TestAIACA.p7b";
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        AuthorityInfoAccess.cAccDescr = 9;
        AuthorityInfoAccess.rgAccDescr = &rgAccess[1];
    } else {
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    }

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_INFO_ACCESS,
            &AuthorityInfoAccess,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BYTE CrlIPAddress[] =    {1,2,3,4};
#define CRL_DNS_NAME            L"CRL.DNS.NAME.COM"
#define CRL_EMAIL_NAME          L"email@CRL.DNS.NAME.COM"
#define CRL_URL_NAME1           L"file://crltest1.p7b"
#define CRL_URL_NAME2           L"file://crltest2.p7b"
#define CRL_REGISTERED_ID       "1.2.3.4.5.6"

static BYTE rgbCrlOtherName[] = {0x02, 0x02, 0x11, 0x22};
static CERT_OTHER_NAME CrlOtherName = {
    "1.2.33.44.55.66", sizeof(rgbCrlOtherName), rgbCrlOtherName };

#define CRL_DIST_POINTS_DELTA_FLAG          0x1
#define CRL_DIST_POINTS_UNSUPPORTED_FLAG    0x2

static BOOL CreateCrlDistPoints(
        DWORD dwIssuer,
        BOOL dwFlags,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_DIST_POINTS_INFO CrlDistPointsInfo;

    BYTE bReasonFlags;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[9];
    CERT_ALT_NAME_ENTRY rgIssuerAltNameEntry[1];
    CRL_DIST_POINT rgDistPoint[5];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    BYTE *pbIssuerNameEncoded = NULL;
    DWORD cbIssuerNameEncoded;

    if (dwFlags & CRL_DIST_POINTS_DELTA_FLAG) {
        // ISSUER
        CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbIssuerNameEncoded,
                &cbIssuerNameEncoded
                ))
            goto ErrorReturn;


        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgAltNameEntry[0].pwszDNSName = CRL_DNS_NAME;
        rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgAltNameEntry[1].pwszRfc822Name = CRL_EMAIL_NAME;
        rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgAltNameEntry[2].IPAddress.pbData = CrlIPAddress;
        rgAltNameEntry[2].IPAddress.cbData = sizeof(CrlIPAddress);
        rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgAltNameEntry[3].pszRegisteredID = CRL_REGISTERED_ID;
        rgAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[4].pwszURL = CRL_URL_NAME2;
        rgAltNameEntry[5].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[5].pOtherName = &CrlOtherName;
        rgAltNameEntry[6].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[6].pwszURL = CRL_URL_NAME1;
        rgAltNameEntry[7].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgAltNameEntry[7].DirectoryName.pbData = pbIssuerNameEncoded;
        rgAltNameEntry[7].DirectoryName.cbData = cbIssuerNameEncoded;
        rgAltNameEntry[8].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[8].pwszURL = L"file://BadUnsupportedChoice.crl";


        rgIssuerAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIssuerAltNameEntry[0].pwszURL = L"CRL Issuer URL";

        memset(rgDistPoint, 0, sizeof(rgDistPoint));

        // [0] has unsupported ReasonFlags
        rgDistPoint[0].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[0].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[0].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[8];
        rgDistPoint[0].ReasonFlags.cbData = 1;
        rgDistPoint[0].ReasonFlags.pbData = &bReasonFlags;
        rgDistPoint[0].ReasonFlags.cUnusedBits = 1;
        bReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
            CRL_REASON_CA_COMPROMISE_FLAG;
        // [1] has unsupported CRLIssuer
        rgDistPoint[1].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[1].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[1].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[8];
        rgDistPoint[1].CRLIssuer.cAltEntry = 1;
        rgDistPoint[1].CRLIssuer.rgAltEntry = rgIssuerAltNameEntry;
        // [2] is empty
        rgDistPoint[3].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[3].DistPointName.FullName.cAltEntry = 5;
        rgDistPoint[3].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];
        rgDistPoint[4].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[4].DistPointName.FullName.cAltEntry = 3;
        rgDistPoint[4].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[5];

        memset(&CrlDistPointsInfo, 0, sizeof(CrlDistPointsInfo));
        CrlDistPointsInfo.rgDistPoint = &rgDistPoint[0];
        if (dwFlags & CRL_DIST_POINTS_UNSUPPORTED_FLAG)
            CrlDistPointsInfo.cDistPoint = 1;
        else
            CrlDistPointsInfo.cDistPoint = 5;
    } else {
        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[0].pwszURL = L"file://test1.crl";

        memset(rgDistPoint, 0, sizeof(rgDistPoint));
        rgDistPoint[0].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[0].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[0].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

        memset(&CrlDistPointsInfo, 0, sizeof(CrlDistPointsInfo));
        CrlDistPointsInfo.rgDistPoint = &rgDistPoint[0];
        CrlDistPointsInfo.cDistPoint = 1;
    }

    if (!AllocAndEncodeObject(
            X509_CRL_DIST_POINTS,
            &CrlDistPointsInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if(pbIssuerNameEncoded)
        TestFree(pbIssuerNameEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateCertIssuingDistPoint(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_ISSUING_DIST_POINT Info;

    BYTE bOnlySomeReasonFlags;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[2];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://test1.crl";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://test1.crl";

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice =
        CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = 2;
    Info.DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

    Info.OnlySomeReasonFlags.cbData = 1;
    Info.OnlySomeReasonFlags.pbData = &bOnlySomeReasonFlags;
    Info.OnlySomeReasonFlags.cUnusedBits = 1;
    bOnlySomeReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
        CRL_REASON_CA_COMPROMISE_FLAG;

    Info.fIndirectCRL = TRUE;
    Info.fOnlyContainsUserCerts = TRUE;
    Info.fOnlyContainsCACerts = TRUE;

    if (!AllocAndEncodeObject(
            X509_ISSUING_DIST_POINT,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCrlIssuingDistPoint(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_ISSUING_DIST_POINT Info;

    CERT_ALT_NAME_ENTRY rgAltNameEntry[1];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://test1.crl";

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice =
        CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = 1;
    Info.DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

    if (!AllocAndEncodeObject(
            szOID_ISSUING_DIST_POINT,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateNameConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_CONSTRAINTS_INFO pInfo;

    CERT_NAME_CONSTRAINTS_INFO RootInfo;
    CERT_GENERAL_SUBTREE rgRootPermitted[15];
    CERT_GENERAL_SUBTREE rgRootExcluded[15];

    CERT_NAME_CONSTRAINTS_INFO CaInfo;
    CERT_GENERAL_SUBTREE rgCaPermitted[15];

    CERT_NAME_CONSTRAINTS_INFO MissingInfo;
    CERT_GENERAL_SUBTREE rgMissingPermitted[15];
    CERT_GENERAL_SUBTREE rgMissingExcluded[15];

    BYTE rgbMissing[2] = {5, 0};        // NULL
    CERT_OTHER_NAME MissingOtherName =
        {"1.2.3.4.5.6", sizeof(rgbMissing), rgbMissing};

    CERT_NAME_VALUE NameValue;
    CERT_OTHER_NAME PermittedUPNOtherName;
    BYTE *pbPermittedUPNNameEncoded = NULL;
    DWORD cbPermittedUPNNameEncoded;

    CERT_OTHER_NAME ExcludedUPNOtherName;
    BYTE *pbExcludedUPNNameEncoded = NULL;
    DWORD cbExcludedUPNNameEncoded;

    CERT_OTHER_NAME AnyUPNOtherName;
    BYTE *pbAnyUPNNameEncoded = NULL;
    DWORD cbAnyUPNNameEncoded;

    BYTE rgbDefaultIPAddress[] = {1,1,0,0, 255,255,0,0};
    BYTE rgbAllExtIPAddress[] = {
        1,    2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,  16,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0xF0};
    BYTE rgbExcludedIPAddress[] = {2,2,2,2, 255,254,254,254};

    CERT_RDN rgRDN[3];
    CERT_RDN_ATTR rgAttr[3];
    CERT_NAME_INFO NameInfo;
    BYTE *pbPermittedNameEncoded = NULL;
    DWORD cbPermittedNameEncoded;
    BYTE *pbExcludedNameEncoded = NULL;
    DWORD cbExcludedNameEncoded;
    BYTE *pbAnyOUNameEncoded = NULL;
    DWORD cbAnyOUNameEncoded;
    BYTE *pbAnyNameEncoded = NULL;
    DWORD cbAnyNameEncoded;
    LPSTR pszSign = "\n sign \r";

    DWORD i;

    NameValue.dwValueType = CERT_RDN_UTF8_STRING;
    NameValue.Value.pbData = (BYTE *) L"@UPN.COM";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbPermittedUPNNameEncoded,
            &cbPermittedUPNNameEncoded))
        goto ErrorReturn;

    PermittedUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    PermittedUPNOtherName.Value.pbData = pbPermittedUPNNameEncoded;
    PermittedUPNOtherName.Value.cbData = cbPermittedUPNNameEncoded;

    NameValue.dwValueType = CERT_RDN_UTF8_STRING;
    NameValue.Value.pbData = (BYTE *) L"excluded@UPN.com";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbExcludedUPNNameEncoded,
            &cbExcludedUPNNameEncoded))
        goto ErrorReturn;

    ExcludedUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    ExcludedUPNOtherName.Value.pbData = pbExcludedUPNNameEncoded;
    ExcludedUPNOtherName.Value.cbData = cbExcludedUPNNameEncoded;

    NameValue.dwValueType = CERT_RDN_UTF8_STRING;
    NameValue.Value.pbData = (BYTE *) L"";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbAnyUPNNameEncoded,
            &cbAnyUPNNameEncoded))
        goto ErrorReturn;

    AnyUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    AnyUPNOtherName.Value.pbData = pbAnyUPNNameEncoded;
    AnyUPNOtherName.Value.cbData = cbAnyUPNNameEncoded;


    for (i = 0; i < 3; i++) {
        rgRDN[i].cRDNAttr = 1;
        rgRDN[i].rgRDNAttr = &rgAttr[i];
    }

    // Any
    rgAttr[0].pszObjId = ATTR_0_OBJID;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = NULL;
    rgAttr[0].Value.cbData = 0;

    rgAttr[1].pszObjId = ATTR_1_OBJID;
    rgAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[1].Value.pbData = (BYTE *) pszSign;
    rgAttr[1].Value.cbData = strlen(pszSign);

    rgAttr[2].pszObjId = ATTR_2_OBJID;
    rgAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[2].Value.pbData = (BYTE *) "default";
    rgAttr[2].Value.cbData = strlen("default");

    NameInfo.cRDN = 3;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbPermittedNameEncoded,
            &cbPermittedNameEncoded
            ))
        goto ErrorReturn;

    rgAttr[0].pszObjId = ATTR_0_OBJID;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) "excluded";
    rgAttr[0].Value.cbData = strlen("excluded");
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbExcludedNameEncoded,
            &cbExcludedNameEncoded
            ))
        goto ErrorReturn;

    rgAttr[0].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = NULL;
    rgAttr[0].Value.cbData = 0;
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbAnyOUNameEncoded,
            &cbAnyOUNameEncoded
            ))
        goto ErrorReturn;

    NameInfo.cRDN = 0;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbAnyNameEncoded,
            &cbAnyNameEncoded
            ))
        goto ErrorReturn;

    memset(&rgRootPermitted, 0, sizeof(rgRootPermitted));
    rgRootPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootPermitted[0].Base.pwszDNSName = L"dns Name  ";
    rgRootPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootPermitted[1].Base.pwszRfc822Name = L"  eMail.COM";
    rgRootPermitted[2].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootPermitted[2].Base.pwszDNSName = L" kevin  ";
    rgRootPermitted[3].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgRootPermitted[3].Base.pwszURL = L".url.com";
    rgRootPermitted[4].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootPermitted[4].Base.pOtherName = &PermittedUPNOtherName;

    rgRootPermitted[5].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootPermitted[5].Base.IPAddress.pbData = rgbDefaultIPAddress;
    rgRootPermitted[5].Base.IPAddress.cbData = sizeof(rgbDefaultIPAddress);
    rgRootPermitted[6].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootPermitted[6].Base.IPAddress.pbData = rgbAllExtIPAddress;
    rgRootPermitted[6].Base.IPAddress.cbData = sizeof(rgbAllExtIPAddress);

    rgRootPermitted[7].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootPermitted[7].Base.pwszRfc822Name = L"MyEmail@WhereEver.com";

    rgRootPermitted[8].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootPermitted[8].Base.DirectoryName.pbData = pbPermittedNameEncoded;
    rgRootPermitted[8].Base.DirectoryName.cbData = cbPermittedNameEncoded;
    rgRootPermitted[9].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootPermitted[9].Base.DirectoryName.pbData = pbAnyOUNameEncoded;
    rgRootPermitted[9].Base.DirectoryName.cbData = cbAnyOUNameEncoded;


    memset(&rgRootExcluded, 0, sizeof(rgRootExcluded));
    rgRootExcluded[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootExcluded[0].Base.pwszDNSName = L"www.ExcLuDed.dns.com  ";
    rgRootExcluded[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootExcluded[1].Base.pwszRfc822Name = L"Excluded@email.com";
    rgRootExcluded[2].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgRootExcluded[2].Base.pwszURL = L"excluded.url.com";
    rgRootExcluded[3].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootExcluded[3].Base.pOtherName = &ExcludedUPNOtherName;

    rgRootExcluded[4].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootExcluded[4].Base.IPAddress.pbData = rgbExcludedIPAddress;
    rgRootExcluded[4].Base.IPAddress.cbData = sizeof(rgbExcludedIPAddress);

    rgRootExcluded[5].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootExcluded[5].Base.DirectoryName.pbData = pbExcludedNameEncoded;
    rgRootExcluded[5].Base.DirectoryName.cbData = cbExcludedNameEncoded;


    memset(&RootInfo, 0, sizeof(RootInfo));
    RootInfo.cPermittedSubtree = 10;
    RootInfo.rgPermittedSubtree = rgRootPermitted;
    RootInfo.cExcludedSubtree = 6;
    RootInfo.rgExcludedSubtree = rgRootExcluded;


    memset(&rgCaPermitted, 0, sizeof(rgCaPermitted));
    rgCaPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgCaPermitted[0].Base.pwszDNSName = L"";
    rgCaPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgCaPermitted[1].Base.pwszRfc822Name = L"";
    rgCaPermitted[2].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgCaPermitted[2].Base.pwszURL = L"";
    rgCaPermitted[3].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgCaPermitted[3].Base.pOtherName = &AnyUPNOtherName;
    rgCaPermitted[4].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgCaPermitted[4].Base.IPAddress.pbData = NULL;
    rgCaPermitted[4].Base.IPAddress.cbData = 0;
    rgCaPermitted[5].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgCaPermitted[5].Base.DirectoryName.pbData = pbAnyNameEncoded;
    rgCaPermitted[5].Base.DirectoryName.cbData = cbAnyNameEncoded;


    memset(&CaInfo, 0, sizeof(CaInfo));
    CaInfo.cPermittedSubtree = 6;
    CaInfo.rgPermittedSubtree = rgCaPermitted;
    CaInfo.cExcludedSubtree = 0;
    CaInfo.rgExcludedSubtree = NULL;

    memset(&rgMissingPermitted, 0, sizeof(rgMissingPermitted));
    rgMissingPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingPermitted[0].Base.pwszDNSName = L"a super dns Name  ";
    rgMissingPermitted[0].dwMinimum = 1;
    rgMissingPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgMissingPermitted[1].Base.pOtherName = &MissingOtherName;

    memset(&rgMissingExcluded, 0, sizeof(rgMissingExcluded));
    rgMissingExcluded[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingExcluded[0].Base.pwszDNSName = L"www.ReallyExcLuDed.dns.com  ";
    rgMissingExcluded[1].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingExcluded[1].Base.pwszDNSName = L"www.ExcLuDed.dns.com  ";
    rgMissingExcluded[1].fMaximum = TRUE;
    rgMissingExcluded[1].dwMaximum = 2;
    rgMissingExcluded[2].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgMissingExcluded[2].Base.pOtherName = &MissingOtherName;

    memset(&MissingInfo, 0, sizeof(MissingInfo));
    MissingInfo.cPermittedSubtree = 2;
    MissingInfo.rgPermittedSubtree = rgMissingPermitted;
    MissingInfo.cExcludedSubtree = 3;
    MissingInfo.rgExcludedSubtree = rgMissingExcluded;

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else if (0 == strcmp(CertPara[dwCert].pszName, "MissingNCCA"))
        pInfo = &MissingInfo;
    else
        goto ErrorReturn;

    if (!AllocAndEncodeObject(
            X509_NAME_CONSTRAINTS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    TestFree(pbPermittedUPNNameEncoded);
    TestFree(pbExcludedUPNNameEncoded);
    TestFree(pbAnyUPNNameEncoded);
    TestFree(pbPermittedNameEncoded);
    TestFree(pbExcludedNameEncoded);
    TestFree(pbAnyOUNameEncoded);
    TestFree(pbAnyNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreatePolicyMappings(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_POLICY_MAPPINGS_INFO pInfo;

    CERT_POLICY_MAPPING rgRootPolicyMapping[] = {
        "1.1.22", "1.2.22.1",
        "1.1.22", "1.2.22.2",       // multiple subjects may map to same issuer
        "1.1.4444", "1.2.4444",
        "1.1.4444", "1.1.4444",     // multiple subjects for same issuer
        "1.1.22.333", "1.2.22.1",   // duplicate subject
        "1.1.22", "1.2.22.3",
        "1.1.333", "1.2.333.1",
        "1.1.333", "1.2.333.2",
        "1.1.333", "1.2.333.3",
        "1.1.22", "1.2.22.3",       // multiple subjects for same issuer
        "1.1.22", "1.2.22.3",       // duplicate subject
        "1.1.22", "1.2.22.4",       // multiple subjects for same issuer
    };
    CERT_POLICY_MAPPINGS_INFO RootInfo = {
        sizeof(rgRootPolicyMapping) / sizeof(rgRootPolicyMapping[0]),
        rgRootPolicyMapping
    };

    CERT_POLICY_MAPPING rgCaPolicyMapping[] = {
        "1.1.1", "1.3.1.1",
        "1.1.1", "1.3.1.2",
        "1.2.22.2", "1.3.22.2.1",   // -> 1.1.22
        "1.2.22.2", "1.3.22.2.2",   // -> 1.1.22
    };
    CERT_POLICY_MAPPINGS_INFO CaInfo = {
        sizeof(rgCaPolicyMapping) / sizeof(rgCaPolicyMapping[0]),
        rgCaPolicyMapping
    };

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else
        goto ErrorReturn;

    if (!AllocAndEncodeObject(
            X509_POLICY_MAPPINGS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreatePolicyConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_POLICY_CONSTRAINTS_INFO pInfo;

    CERT_POLICY_CONSTRAINTS_INFO RootInfo = {
        TRUE,       // fRequireExplicitPolicy
        1,          // dwRequireExplicitPolicySkipCerts
        TRUE,       // fInhibitPolicyMapping
        1           // dwInhibitPolicyMappingSkipCerts
    };

    CERT_POLICY_CONSTRAINTS_INFO CaInfo = {
        TRUE,       // fRequireExplicitPolicy
        0,          // dwRequireExplicitPolicySkipCerts
        TRUE,       // fInhibitPolicyMapping
        0           // dwInhibitPolicyMappingSkipCerts
    };

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else
        goto ErrorReturn;
        
    if (!AllocAndEncodeObject(
            X509_POLICY_CONSTRAINTS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCrossCertDistPoints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CROSS_CERT_DIST_POINTS_INFO Info;
    CERT_ALT_NAME_INFO rgDistPoint[2];
    CERT_ALT_NAME_ENTRY rgAltNameEntry[3];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://vsgood.cer";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://nt.store";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = L"file://win95.store";

    rgDistPoint[0].cAltEntry = 1;
    rgDistPoint[0].rgAltEntry = &rgAltNameEntry[0];
    rgDistPoint[1].cAltEntry = 2;
    rgDistPoint[1].rgAltEntry = &rgAltNameEntry[1];

    memset(&Info, 0, sizeof(Info));
    Info.dwSyncDeltaTime = 60 * 60 * 8;
    Info.cDistPoint = 2;
    Info.rgDistPoint = rgDistPoint;

    if (!AllocAndEncodeObject(
            X509_CROSS_CERT_DIST_POINTS,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyId(
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbPubKeyHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB KeyIdentifier;

    Sha1HashPublicKey(dwIssuer, rgbPubKeyHash);

    KeyIdentifier.pbData = rgbPubKeyHash;
    KeyIdentifier.cbData = sizeof(rgbPubKeyHash);

    return AllocAndEncodeObject(
        X509_OCTET_STRING,
        &KeyIdentifier,
        ppbEncoded,
        pcbEncoded
        );
}

static BOOL CreateKeyAttributes(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_ATTRIBUTES_INFO KeyAttrInfo;
    CERT_PRIVATE_KEY_VALIDITY KeyValidity;

    BYTE bIntendedKeyUsage;

    memset(&KeyAttrInfo, 0, sizeof(KeyAttrInfo));

    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        // Issuer's KeyId
        KeyAttrInfo.KeyId.pbData = (BYTE *) &dwCert;
        KeyAttrInfo.KeyId.cbData = sizeof(dwCert);
    }

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bIntendedKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bIntendedKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bIntendedKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyAttrInfo.IntendedKeyUsage.pbData = &bIntendedKeyUsage;
    KeyAttrInfo.IntendedKeyUsage.cbData = 1;
    KeyAttrInfo.IntendedKeyUsage.cUnusedBits = 1;

    {
        SYSTEMTIME SystemTime = TestTime;

        SystemTime.wMilliseconds = 123;
        MySystemTimeToFileTime(&SystemTime, &KeyValidity.NotBefore);
        SystemTime.wYear += 2;
        SystemTime.wMilliseconds = 456;

        MySystemTimeToFileTime(&SystemTime, &KeyValidity.NotAfter);
    }
    KeyAttrInfo.pPrivateKeyUsagePeriod = &KeyValidity;

    if (!AllocAndEncodeObject(
            X509_KEY_ATTRIBUTES,
            &KeyAttrInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyUsageRestriction(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_USAGE_RESTRICTION_INFO KeyUsageInfo;
    BYTE bRestrictedKeyUsage;

    LPSTR rgpszCertPolicyElementId[4] = {
        "1.2.333.1",
        "1.2.333.22",
        "1.2.333.333",
        "1.2.333.4444"
    };
    CERT_POLICY_ID rgCertPolicyId[3] = {
        0, NULL,
        1, rgpszCertPolicyElementId,
        4, rgpszCertPolicyElementId
    };

    LPSTR rgpszSpcCertPolicyElementId[2] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID,
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID
    };
    CERT_POLICY_ID rgSpcCertPolicyId[2] = {
        1, &rgpszSpcCertPolicyElementId[0],
        1, &rgpszSpcCertPolicyElementId[1]
    };

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bRestrictedKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bRestrictedKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bRestrictedKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyUsageInfo.RestrictedKeyUsage.pbData = &bRestrictedKeyUsage;
    KeyUsageInfo.RestrictedKeyUsage.cbData = 1;
    KeyUsageInfo.RestrictedKeyUsage.cUnusedBits = 1;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 2;
        KeyUsageInfo.rgCertPolicyId = rgSpcCertPolicyId;
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 1;
        KeyUsageInfo.rgCertPolicyId = &rgSpcCertPolicyId[1];
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 1;
        KeyUsageInfo.rgCertPolicyId = &rgSpcCertPolicyId[0];
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 3;
        KeyUsageInfo.rgCertPolicyId = rgCertPolicyId;
    }


    if (!AllocAndEncodeObject(
            X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateBasicConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSubtreesEncoded = NULL;
    DWORD cbSubtreesEncoded;
    CERT_NAME_BLOB rgSubtreesConstraint[2];

    CERT_BASIC_CONSTRAINTS_INFO BasicConstraintsInfo;
    BYTE bSubjectType;

    memset(&BasicConstraintsInfo, 0, sizeof(BasicConstraintsInfo));

    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        bSubjectType = CERT_CA_SUBJECT_FLAG;
        BasicConstraintsInfo.fPathLenConstraint = TRUE;
        BasicConstraintsInfo.dwPathLenConstraint = dwCert + 1;
    } else
        bSubjectType = CERT_END_ENTITY_SUBJECT_FLAG;
    BasicConstraintsInfo.SubjectType.pbData = &bSubjectType;
    BasicConstraintsInfo.SubjectType.cbData = 1;
    BasicConstraintsInfo.SubjectType.cUnusedBits = 6;

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        CERT_RDN rgRDN[RDN_CNT];
        CERT_RDN_ATTR rgAttr[ATTR_CNT];
        CERT_NAME_INFO Name;

        CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
        cbSubtreesEncoded = 0;

        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbSubtreesEncoded,
                &cbSubtreesEncoded
                ))
            goto ErrorReturn;

        BasicConstraintsInfo.cSubtreesConstraint = 2;
        BasicConstraintsInfo.rgSubtreesConstraint = rgSubtreesConstraint;
        rgSubtreesConstraint[0].pbData = pbSubtreesEncoded;
        rgSubtreesConstraint[0].cbData = cbSubtreesEncoded;
        rgSubtreesConstraint[1].pbData = pbSubtreesEncoded;
        rgSubtreesConstraint[1].cbData = cbSubtreesEncoded;
    }

    if (!AllocAndEncodeObject(
            X509_BASIC_CONSTRAINTS,
            &BasicConstraintsInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSubtreesEncoded)
        TestFree(pbSubtreesEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyUsage(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_BIT_BLOB KeyUsageInfo;
    BYTE bKeyUsage;

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyUsageInfo.pbData = &bKeyUsage;
    KeyUsageInfo.cbData = 1;
    KeyUsageInfo.cUnusedBits = 1;

    if (!AllocAndEncodeObject(
            X509_KEY_USAGE,
            &KeyUsageInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateBasicConstraints2(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_BASIC_CONSTRAINTS2_INFO BasicConstraints2Info;

    memset(&BasicConstraints2Info, 0, sizeof(BasicConstraints2Info));

    if (dwCert == POLICY_ROOT) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        BasicConstraints2Info.dwPathLenConstraint = 1;
    } else if (dwCert == POLICY_CA) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        BasicConstraints2Info.dwPathLenConstraint = 0;
    } else if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        BasicConstraints2Info.dwPathLenConstraint = dwCert + 1;
    } else
        BasicConstraints2Info.fCA = FALSE;

    if (!AllocAndEncodeObject(
            X509_BASIC_CONSTRAINTS2,
            &BasicConstraints2Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreatePolicies(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbQualifier2[] = {5, 0};                      // NULL
    BYTE rgbQualifier4[] = {4, 8, 1,2,3,4,5,6,7,8};     // Octet String

    CERT_POLICY_QUALIFIER_INFO rgQualifierInfo[4] = {
        "1.2.1", 0, NULL,
        "1.2.2", sizeof(rgbQualifier2), rgbQualifier2,
        "1.2.3", 0, NULL,
        "1.2.4", sizeof(rgbQualifier4), rgbQualifier4
    };

    // Root has the following policies:
    //  1.1.1
    //  1.1.55555
    //  1.1.22
    //  1.1.333
    //  1.1.4444
    CERT_POLICY_INFO rgRootPolicyInfo[] = {
        "1.1.1", 0, NULL,
        "1.1.55555", 0, NULL,
        "1.1.22", 2, rgQualifierInfo,
        "1.1.333", 2, &rgQualifierInfo[2],
        "1.1.333", 0, NULL,                     // duplicate, should be removed
        "1.1.4444", 1, rgQualifierInfo,
        "1.1.4444", 0, NULL,                    // duplicate
        "1.1.1", 0, NULL,                       // duplicate
        "1.1.1", 0, NULL,                       // duplicate
    };

    // After mapping, the CA has the following policies:
    //  1.1.1
    //  1.1.22
    //  1.1.333
    //  1.1.4444
    CERT_POLICY_INFO rgCaPolicyInfo[] = {
        "1.2.22.1", 0, NULL,    // 1.1.22
        "1.2.22.2", 0, NULL,    // 1.1.22
        "1.2.22.3", 0, NULL,    // 1.1.22
        "1.2.333.1", 0, NULL,   // 1.1.333
        "1.2.333.2", 0, NULL,   // 1.1.333
        "1.2.4444", 0, NULL,    // 1.1.4444
        "1.1.4444", 0, NULL,    // 1.1.4444
        "1.1.1", 0, NULL,       // 1.1.1
        "1.2.333.3", 0, NULL,   // 1.1.333
        "1.2.55555", 0, NULL,   // no mapping
    };

    // After mapping, the cert has the following policies:
    //  1.1.1
    //  1.1.22
    CERT_POLICY_INFO rgPolicyInfo[] = {
        "1.1.55555", 0, NULL,       // no mapping via ca
        "1.3.22.2.1", 0, NULL,      // 1.2.22.2 -> 1.1.22
        "1.3.1.1", 0, NULL,         // 1.1.1
        "1.2.55555", 0, NULL,       // no mapping via root
    };

    // After mapping, the cert has the following policies:
    //  1.1.1
    //  1.1.22
    //  1.1.4444
    CERT_POLICY_INFO rgAllExtPolicyInfo[] = {
        "1.3.1.2", 0, NULL,         // 1.1.1
        "1.3.22.2.2", 0, NULL,      // 1.2.22.2 -> 1.1.22
        "1.1.55555", 0, NULL,       // no mapping via ca
        "1.2.55555", 0, NULL,       // not mapping via root
        "1.1.4444", 0, NULL,        // 1.1.4444
    };

    CERT_POLICY_INFO rgSpcPolicyInfo[2] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID, 0, NULL,
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID, 0, NULL
    };

    CERT_POLICY_INFO rgDssCAPolicyInfo[] = {
        szOID_ANY_CERT_POLICY, 0, NULL,
    };

    CERT_POLICY_INFO rgDssEndPolicyInfo[] = {
        "1.1.4444", 0, NULL,
        "1.1.55555", 0, NULL,
    };

    CERT_POLICIES_INFO PoliciesInfo;
    memset(&PoliciesInfo, 0, sizeof(PoliciesInfo));

    if (0 == strcmp(CertPara[dwCert].pszName, "DssCA")) {
        PoliciesInfo.cPolicyInfo = sizeof(rgDssCAPolicyInfo) /
            sizeof(rgDssCAPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgDssCAPolicyInfo;
    } else if (0 == strcmp(CertPara[dwCert].pszName, "DssEnd")) {
        PoliciesInfo.cPolicyInfo = sizeof(rgDssEndPolicyInfo) /
            sizeof(rgDssEndPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgDssEndPolicyInfo;
    } else if (POLICY_ROOT == dwCert) {
        PoliciesInfo.cPolicyInfo = sizeof(rgRootPolicyInfo) /
            sizeof(rgRootPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgRootPolicyInfo;
    } else if (POLICY_CA == dwCert) {
        PoliciesInfo.cPolicyInfo = sizeof(rgCaPolicyInfo) /
            sizeof(rgCaPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgCaPolicyInfo;
    } else if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 2;
        PoliciesInfo.rgPolicyInfo = rgSpcPolicyInfo;
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 1;
        PoliciesInfo.rgPolicyInfo = &rgSpcPolicyInfo[1];
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 1;
        PoliciesInfo.rgPolicyInfo = &rgSpcPolicyInfo[0];
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = sizeof(rgAllExtPolicyInfo) /
            sizeof(rgAllExtPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgAllExtPolicyInfo;
    } else {
        PoliciesInfo.cPolicyInfo = sizeof(rgPolicyInfo) /
            sizeof(rgPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgPolicyInfo;
    }

    return AllocAndEncodeObject(
            X509_CERT_POLICIES,
            &PoliciesInfo,
            ppbEncoded,
            pcbEncoded);
}

static BOOL CreateSMIMECapabilities(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgb128BitLen[] = {2, 2, 0, 128};   // Integer
    BYTE rgb40BitLen[] = {2, 1, 40};        // Integer

    CRYPT_SMIME_CAPABILITY rgCapability[4] = {
        szOID_RSA_DES_EDE3_CBC, 0, NULL,
        szOID_RSA_RC2CBC, sizeof(rgb128BitLen), rgb128BitLen,
        szOID_RSA_RC2CBC, sizeof(rgb40BitLen), rgb40BitLen,
        szOID_RSA_preferSignedData, 0, NULL
    };

    CRYPT_SMIME_CAPABILITIES Capabilities = {
        sizeof(rgCapability)/sizeof(rgCapability[0]), rgCapability
    };

    return AllocAndEncodeObject(
            PKCS_SMIME_CAPABILITIES,
            &Capabilities,
            ppbEncoded,
            pcbEncoded);
}


static BOOL CreateAltName(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_ALT_NAME_INFO AltNameInfo;
#define ALT_NAME_ENTRY_CNT  15
    CERT_ALT_NAME_ENTRY rgAltNameEntry[ALT_NAME_ENTRY_CNT];
    DWORD i;

    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;

    CERT_OTHER_NAME UPNOtherName;
    BYTE *pbUPNNameEncoded = NULL;
    DWORD cbUPNNameEncoded;

    LPWSTR pwszEmail = NULL;
    LPWSTR pwszUrl = NULL;
    LPWSTR pwszUPN = NULL;
    LPWSTR pwszDns = NULL;

    BYTE rgbOtherName[] = {0x02, 0x02, 0x11, 0x22};
    CERT_OTHER_NAME OtherName;
    PCERT_OTHER_NAME pOtherName = NULL;

    LPSTR pszRegisteredID = NULL;

    BYTE rgbDefaultIPAddress[] = {1,1,0,0};
    BYTE rgbAllExtIPAddress[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17};
    BYTE rgbExcludedIPAddress[] = {2,2,3,3};
    BYTE rgbNotPermittedIPAddress[] = {3,3,3,3};
    BYTE *pbIPAddress = NULL;
    DWORD cbIPAddress = 0;

    if (CertPara[dwCert].dwFlags &
            (NO_NAME_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG)) {
        pwszEmail = L"Name@email.com";
    }

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        pwszEmail = L"   AllExt@email.com    ";
        pwszUrl = L" http://www.AllExt.url.com:388/more url stuff";
        pwszDns = L"DNS name";
        pwszUPN = L"AllExt@UPN.com";
        pbIPAddress = rgbAllExtIPAddress;
        cbIPAddress = sizeof(rgbAllExtIPAddress);
    } else if (0 == strcmp(CertPara[dwCert].pszName, "Excluded")) {
        pwszEmail = L" Excluded@email.com  ";
        pwszUrl = L" http://Excluded.url.com/more url stuff";
        pwszDns = L"www.excluded.dns.com";
        pwszUPN = L"excluded@UPN.com";
        pbIPAddress = rgbExcludedIPAddress;
        cbIPAddress = sizeof(rgbExcludedIPAddress);
    } else if (0 == strcmp(CertPara[dwCert].pszName, "NotPermitted")) {
        pwszEmail = L"JoeCool@email.not"; 
        pwszUrl = L"http://www.url.not/more url stuff";
        pwszDns = L"www.excluded.dns.not";
        pwszUPN = L"notpermitted@UPN.not";
        pbIPAddress = rgbNotPermittedIPAddress;
        cbIPAddress = sizeof(rgbNotPermittedIPAddress);

        OtherName.pszObjId = "1.2.33.44.55.66";
        OtherName.Value.pbData = rgbOtherName;
        OtherName.Value.cbData = sizeof(rgbOtherName);
        pOtherName = &OtherName;
        pszRegisteredID = "1.2.3.4.5.6.7";
    } else {
        pwszUPN = L"    Default@UPN.com   ";
        pbIPAddress = rgbDefaultIPAddress;
        cbIPAddress = sizeof(rgbDefaultIPAddress);
    }


    i = 0;
    if (pwszEmail) {
        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgAltNameEntry[0].pwszRfc822Name = pwszEmail;
        i++;
    }

    if (pwszUPN) {
        CERT_NAME_VALUE UPNNameValue;

        UPNNameValue.dwValueType = CERT_RDN_UTF8_STRING;
        UPNNameValue.Value.pbData = (BYTE *) pwszUPN;
        UPNNameValue.Value.cbData = 0;
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &UPNNameValue,
                &pbUPNNameEncoded,
                &cbUPNNameEncoded))
            goto ErrorReturn;

        UPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
        UPNOtherName.Value.pbData = pbUPNNameEncoded;
        UPNOtherName.Value.cbData = cbUPNNameEncoded;

        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[i].pOtherName = &UPNOtherName;
        i++;
    }

    if (pwszUrl) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[i].pwszURL = pwszUrl;
        i++;
    }

    if (pwszDns) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgAltNameEntry[i].pwszDNSName = pwszDns;
        i++;
    }

    if (pszRegisteredID) {
        rgAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgAltNameEntry[4].pszRegisteredID = pszRegisteredID;
        i++;
    }

    if (pbIPAddress && cbIPAddress) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgAltNameEntry[i].IPAddress.pbData = pbIPAddress;
        rgAltNameEntry[i].IPAddress.cbData = cbIPAddress;
        i++;
    }

    if (pOtherName) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[i].pOtherName = pOtherName;
        i++;
    }


    if (CertPara[dwCert].dwFlags & ALT_DIR_NAME_PARA_FLAG) {
        CERT_NAME_INFO NameInfo;
        CERT_RDN rgRDN[1];
        CERT_RDN_ATTR rgAttr[1];

        NameInfo.cRDN = 1;
        NameInfo.rgRDN = rgRDN;

        rgRDN[0].cRDNAttr = 1;
        rgRDN[0].rgRDNAttr = rgAttr;

        rgAttr[0].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
        rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
        rgAttr[0].Value.pbData = (BYTE *) CertPara[dwCert].pszName;
        rgAttr[0].Value.cbData = strlen(CertPara[dwCert].pszName);

        if (!AllocAndEncodeObject(
                X509_NAME,
                &NameInfo,
                &pbNameEncoded,
                &cbNameEncoded))
            goto ErrorReturn;

        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgAltNameEntry[i].DirectoryName.pbData = pbNameEncoded;
        rgAltNameEntry[i].DirectoryName.cbData = cbNameEncoded;
        i++;
    }

    AltNameInfo.cAltEntry = i;
    AltNameInfo.rgAltEntry = rgAltNameEntry;

    if (!AllocAndEncodeObject(
            X509_ALTERNATE_NAME,
            &AltNameInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    TestFree(pbNameEncoded);
    TestFree(pbUPNNameEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETAccountAlias(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    BOOL bInfo;

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG)
        bInfo = TRUE;
    else
        bInfo = FALSE;


    if (!AllocAndEncodeObject(
            X509_SET_ACCOUNT_ALIAS,
            &bInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETHashedRootKey(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    BYTE i;
    BYTE rgbInfo[SET_HASHED_ROOT_LEN];

    for (i = 0; i < SET_HASHED_ROOT_LEN; i++)
        rgbInfo[i] = i;

    if (!AllocAndEncodeObject(
            X509_SET_HASHED_ROOT_KEY,
            rgbInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETCertificateType(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CRYPT_BIT_BLOB Info;
    BYTE rgbType[2] = {0,0};

    if (dwCert < 8)
        rgbType[0] = 1 << (dwCert % 8);
    else
        rgbType[1] = 0x40 << (dwCert % 2);
    Info.pbData = rgbType;
    Info.cbData = 2;
    Info.cUnusedBits = 6;

    if (!AllocAndEncodeObject(
            X509_SET_CERTIFICATE_TYPE,
            &Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETMerchantData(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SET_MERCHANT_DATA_INFO Info;

    memset(&Info, 0, sizeof(Info));
    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        Info.pszMerID = "ID";
        Info.pszMerAcquirerBIN = "0123456";
        Info.pszMerTermID = "TermID";
        Info.pszMerName = "Name";
        Info.pszMerCity = "City";
        Info.pszMerStateProvince = "StateProvince";
        Info.pszMerPostalCode = "PostalCode";
        Info.pszMerCountry = "Country/Region";
        Info.pszMerPhone = "Phone";
        Info.fMerPhoneRelease = TRUE;
        Info.fMerAuthFlag = TRUE;
    } else {
        Info.pszMerID = "";
        Info.pszMerAcquirerBIN = "";
        Info.pszMerTermID = "";
        Info.pszMerName = "";
        Info.pszMerCity = "";
        Info.pszMerStateProvince = "";
        Info.pszMerPostalCode = "";
        Info.pszMerCountry = "";
        Info.pszMerPhone = "";
        Info.fMerPhoneRelease = FALSE;
        Info.fMerAuthFlag = FALSE;
    }


    if (!AllocAndEncodeObject(
            X509_SET_MERCHANT_DATA,
            &Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSpcSpAgency(
        DWORD dwCert,
        DWORD dwLevel,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SPC_LINK UrlLink;
    SPC_LINK MonikerLink;
#define MONIKER_DATA "Moniker Serialized Data"
    SPC_LINK FileLink;
    SPC_IMAGE Image;
    SPC_SP_AGENCY_INFO AgencyInfo;

#define BIT_MAP "Bit Map"
#define META_FILE "Metafile"
#define ENHANCED_META_FILE "Enhanced Metafile"
#define GIF_FILE "Gif File"

    int i;

    UrlLink.dwLinkChoice = SPC_URL_LINK_CHOICE;
    UrlLink.pwszUrl = L"http://microsoft.com";

    MonikerLink.dwLinkChoice = SPC_MONIKER_LINK_CHOICE;
    for (i = 0; i < sizeof(MonikerLink.Moniker.ClassId); i++)
        MonikerLink.Moniker.ClassId[i] = (BYTE) (i + 1);
    MonikerLink.Moniker.SerializedData.cbData = strlen(MONIKER_DATA);
    MonikerLink.Moniker.SerializedData.pbData = (BYTE *) MONIKER_DATA;

    FileLink.dwLinkChoice = SPC_FILE_LINK_CHOICE;
    FileLink.pwszFile = L"Unicode File Link";

    memset(&Image, 0, sizeof(Image));
    memset(&AgencyInfo, 0, sizeof(AgencyInfo));

    AgencyInfo.pLogoImage = &Image;

    if (dwLevel >= 1) {
        AgencyInfo.pPolicyInformation = &UrlLink;
        AgencyInfo.pwszPolicyDisplayText = L"MICROSOFT PRODUCTS POLICY";
        AgencyInfo.pLogoImage = NULL;
    }

    if (dwLevel >= 2) {
        AgencyInfo.pPolicyInformation = &UrlLink;
        AgencyInfo.pwszPolicyDisplayText = L"Unicode String";
        Image.Bitmap.cbData = strlen(BIT_MAP);
        Image.Bitmap.pbData = (BYTE *) BIT_MAP;
    }

    if (dwLevel >= 3) {
        AgencyInfo.pwszPolicyDisplayText = L"Policy Display Unicode String";
        AgencyInfo.pLogoLink = &MonikerLink;
        Image.pImageLink = &FileLink;
        Image.Metafile.cbData = strlen(META_FILE);
        Image.Metafile.pbData = (BYTE *) META_FILE;
        Image.EnhancedMetafile.cbData = strlen(ENHANCED_META_FILE);
        Image.EnhancedMetafile.pbData = (BYTE *) ENHANCED_META_FILE;
        Image.GifFile.cbData = strlen(GIF_FILE);
        Image.GifFile.pbData = (BYTE *) GIF_FILE;
    }

    if (!AllocAndEncodeObject(
            SPC_SP_AGENCY_INFO_STRUCT,
            &AgencyInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSpcCommonName(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

#define SPC_AGENCY_NAME L"Microsoft Code Signing Agency"
#define SPC_COM_NAME "Microsoft Software Products"

    CERT_NAME_VALUE NameValue;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
        NameValue.Value.pbData =  (BYTE *) SPC_AGENCY_NAME;
        NameValue.Value.cbData = wcslen(SPC_AGENCY_NAME) * sizeof(WCHAR);
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        NameValue.dwValueType = CERT_RDN_IA5_STRING;
        NameValue.Value.pbData =  (BYTE *) SPC_COM_NAME;
        NameValue.Value.cbData = strlen(SPC_COM_NAME);
    } else {
        NameValue.dwValueType = CERT_RDN_PRINTABLE_STRING;
        NameValue.Value.pbData =  (BYTE *) CertPara[dwCert].pszName;
        NameValue.Value.cbData = strlen(CertPara[dwCert].pszName);
    }

    if (!AllocAndEncodeObject(
            X509_NAME_VALUE,
            &NameValue,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCRLReason(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    static int iReason = -1;

    iReason += 1;

    iReason = iReason % CRL_REASON_CERTIFICATE_HOLD;
    return AllocAndEncodeObject(
        X509_ENUMERATED,
        (const void *) &iReason,
        ppbEncoded,
        pcbEncoded
        );
}

static BOOL EncodeCert(DWORD dwCert, BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    BYTE *pbKeyIdEncoded = NULL;
    DWORD cbKeyIdEncoded;
    BYTE *pbKeyId2Encoded = NULL;
    DWORD cbKeyId2Encoded;
    BYTE *pbSubjectKeyIdEncoded = NULL;
    DWORD cbSubjectKeyIdEncoded;
    BYTE *pbAuthorityInfoAccessEncoded = NULL;
    DWORD cbAuthorityInfoAccessEncoded;
    BYTE *pbCrlDistPointsEncoded = NULL;
    DWORD cbCrlDistPointsEncoded;
    BYTE *pbKeyAttrEncoded = NULL;
    DWORD cbKeyAttrEncoded;
    BYTE *pbAltNameEncoded = NULL;
    DWORD cbAltNameEncoded;
    BYTE *pbIssuerAltNameEncoded = NULL;
    DWORD cbIssuerAltNameEncoded;
    BYTE *pbKeyUsageRestrictionEncoded = NULL;
    DWORD cbKeyUsageRestrictionEncoded;
    BYTE *pbBasicConstraintsEncoded = NULL;
    DWORD cbBasicConstraintsEncoded;
    BYTE *pbKeyUsageEncoded = NULL;
    DWORD cbKeyUsageEncoded;
    BYTE *pbBasicConstraints2Encoded = NULL;
    DWORD cbBasicConstraints2Encoded;
    BYTE *pbPoliciesEncoded = NULL;
    DWORD cbPoliciesEncoded;

    BYTE *pbSETAccountAliasEncoded = NULL;
    DWORD cbSETAccountAliasEncoded;
    BYTE *pbSETHashedRootKeyEncoded = NULL;
    DWORD cbSETHashedRootKeyEncoded;
    BYTE *pbSETCertificateTypeEncoded = NULL;
    DWORD cbSETCertificateTypeEncoded;
    BYTE *pbSETMerchantDataEncoded = NULL;
    DWORD cbSETMerchantDataEncoded;

    BYTE *pbSpcSpAgencyEncoded0 = NULL;
    DWORD cbSpcSpAgencyEncoded0;
    BYTE *pbSpcSpAgencyEncoded1 = NULL;
    DWORD cbSpcSpAgencyEncoded1;
    BYTE *pbSpcSpAgencyEncoded2 = NULL;
    DWORD cbSpcSpAgencyEncoded2;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded;

    BYTE *pbNetscapeCertType = NULL;
    DWORD cbNetscapeCertType;
    BYTE *pbNetscapeComment = NULL;
    DWORD cbNetscapeComment;
    BYTE *pbNetscapeBaseUrl = NULL;
    DWORD cbNetscapeBaseUrl;
    BYTE *pbNetscapeRevUrl = NULL;
    DWORD cbNetscapeRevUrl;

    BYTE *pbEnhancedKeyUsageEncoded = NULL;
    DWORD cbEnhancedKeyUsageEncoded;

    BYTE *pbSMIMECapabilitiesEncoded = NULL;
    DWORD cbSMIMECapabilitiesEncoded;

    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    BYTE *pbNameConstraintsEncoded = NULL;
    DWORD cbNameConstraintsEncoded;

    BYTE *pbPolicyMappingsEncoded = NULL;
    DWORD cbPolicyMappingsEncoded;
    BYTE *pbPolicyConstraintsEncoded = NULL;
    DWORD cbPolicyConstraintsEncoded;
    BYTE *pbCrossCertDistPointsEncoded = NULL;
    DWORD cbCrossCertDistPointsEncoded;

    FILETIME SerialNumber;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    CERT_INFO Cert;

    DWORD dwIssuer = CertPara[dwCert].dwIssuer;

    DWORD dwCrlDistFlags;

#define CERT_EXTENSION_CNT 30
    CERT_EXTENSION rgExt[CERT_EXTENSION_CNT];

    // SUBJECT
    CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbSubjectEncoded,
            &cbSubjectEncoded
            ))
        goto ErrorReturn;

    // ISSUER
    CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerEncoded,
            &cbIssuerEncoded
            ))
        goto ErrorReturn;

    // PUBLIC KEY
    if (!GetPublicKey(dwCert, &pPubKeyInfo)) goto ErrorReturn;

    // CERT
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    {
        SYSTEMTIME SystemTime = TestTime;
        if (CertPara[dwCert].dwFlags & DUPLICATE_PARA_FLAG)
            // Use same serial number as previous certificate
            SystemTime.wMilliseconds += (WORD) (dwCert - 1);
        else
            SystemTime.wMilliseconds += (WORD) dwCert;
        MySystemTimeToFileTime(&SystemTime, &SerialNumber);
    }
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);
    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        Cert.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Cert.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (CertPara[dwCert].dwFlags & TIME_INVALID_PARA_FLAG) {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
            SystemTime.wYear--;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
        } else if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1920;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            SystemTime.wYear = 2070;

            if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
                SystemTime.wHour = 1;
            else
                SystemTime.wHour = 0;
            SystemTime.wMinute = 59 - (WORD) dwCert;
            SystemTime.wSecond = 0;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        } else if (0 == strcmp("ZeroNotAfter", CertPara[dwCert].pszName)) {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            // NotAfter has already been zeroed
        } else {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            SystemTime.wYear++;
            if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
                SystemTime.wHour = 1;
            else
                SystemTime.wHour = 0;
            if (dwCert < 60) {
                SystemTime.wMinute = 59 - (WORD) dwCert;
                SystemTime.wSecond = 0;
            } else {
                SystemTime.wMinute = 0;
                SystemTime.wSecond = 0;
            }
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        }
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKeyInfo;

    // Cert Extensions
    if (!CreateAuthorityKeyId(
            dwIssuer,
            &pbKeyIdEncoded,
            &cbKeyIdEncoded))
        goto ErrorReturn;
    if (!CreateAuthorityKeyId2(
            dwCert,
            dwIssuer,
            &pbKeyId2Encoded,
            &cbKeyId2Encoded))
        goto ErrorReturn;
    if (!CreateAuthorityInfoAccess(
            dwCert,
            &pbAuthorityInfoAccessEncoded,
            &cbAuthorityInfoAccessEncoded))
        goto ErrorReturn;

    dwCrlDistFlags = 0;
    if (CertPara[dwCert].dwFlags & DELTA_CRL_PARA_FLAG)
        dwCrlDistFlags |= CRL_DIST_POINTS_DELTA_FLAG;
    if (0 == strcmp(CertPara[dwCert].pszName, "UnsupportedCDP"))
        dwCrlDistFlags |= CRL_DIST_POINTS_UNSUPPORTED_FLAG;
    if (!CreateCrlDistPoints(
            CertPara[dwCert].dwIssuer,
            dwCrlDistFlags,
            &pbCrlDistPointsEncoded,
            &cbCrlDistPointsEncoded))
        goto ErrorReturn;

    if (!CreateKeyAttributes(
            dwCert,
            &pbKeyAttrEncoded,
            &cbKeyAttrEncoded))
        goto ErrorReturn;
    if (!CreateAltName(
            dwCert,
            &pbAltNameEncoded,
            &cbAltNameEncoded))
        goto ErrorReturn;
    if (!CreateKeyUsageRestriction(
            dwCert,
            &pbKeyUsageRestrictionEncoded,
            &cbKeyUsageRestrictionEncoded))
        goto ErrorReturn;
    if (!CreateBasicConstraints(
            dwCert,
            &pbBasicConstraintsEncoded,
            &cbBasicConstraintsEncoded))
        goto ErrorReturn;
    if (!CreateKeyUsage(
            dwCert,
            &pbKeyUsageEncoded,
            &cbKeyUsageEncoded))
        goto ErrorReturn;
    if (!CreateBasicConstraints2(
            dwCert,
            &pbBasicConstraints2Encoded,
            &cbBasicConstraints2Encoded))
        goto ErrorReturn;
    if (!CreatePolicies(
            dwCert,
            &pbPoliciesEncoded,
            &cbPoliciesEncoded))
        goto ErrorReturn;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_INFO_PARA_FLAG) {
        if (!CreateSpcSpAgency(
                dwCert,
                0,          // dwLevel
                &pbSpcSpAgencyEncoded0,
                &cbSpcSpAgencyEncoded0))
            goto ErrorReturn;
        if (!CreateSpcSpAgency(
                dwCert,
                2,          // dwLevel
                &pbSpcSpAgencyEncoded1,
                &cbSpcSpAgencyEncoded1))
            goto ErrorReturn;
        if (!CreateSpcSpAgency(
                dwCert,
                3,          // dwLevel
                &pbSpcSpAgencyEncoded2,
                &cbSpcSpAgencyEncoded2))
            goto ErrorReturn;
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        if (!CreateSpcSpAgency(
                dwCert,
                1,          // dwLevel
                &pbSpcSpAgencyEncoded0,
                &cbSpcSpAgencyEncoded0))
            goto ErrorReturn;
        if (!CreateSpcCommonName(
                dwCert,
                &pbSpcCommonNameEncoded,
                &cbSpcCommonNameEncoded))
            goto ErrorReturn;
    } else {
        if (!CreateSETAccountAlias(
                dwCert,
                &pbSETAccountAliasEncoded,
                &cbSETAccountAliasEncoded))
            goto ErrorReturn;
        if (!CreateSETHashedRootKey(
                dwCert,
                &pbSETHashedRootKeyEncoded,
                &cbSETHashedRootKeyEncoded))
            goto ErrorReturn;
        if (!CreateSETCertificateType(
                dwCert,
                &pbSETCertificateTypeEncoded,
                &cbSETCertificateTypeEncoded))
            goto ErrorReturn;
        if (!CreateSETMerchantData(
                dwCert,
                &pbSETMerchantDataEncoded,
                &cbSETMerchantDataEncoded))
            goto ErrorReturn;
    }


    rgExt[0].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbKeyIdEncoded;
    rgExt[0].Value.cbData = cbKeyIdEncoded;
    rgExt[1].pszObjId = szOID_KEY_ATTRIBUTES;
    rgExt[1].fCritical = FALSE;
    rgExt[1].Value.pbData = pbKeyAttrEncoded;
    rgExt[1].Value.cbData = cbKeyAttrEncoded;
    rgExt[2].pszObjId = szOID_BASIC_CONSTRAINTS;
    rgExt[2].fCritical = FALSE;
    rgExt[2].Value.pbData = pbBasicConstraintsEncoded;
    rgExt[2].Value.cbData = cbBasicConstraintsEncoded;
    rgExt[3].pszObjId = szOID_KEY_USAGE_RESTRICTION;
    rgExt[3].fCritical = FALSE;
    rgExt[3].Value.pbData = pbKeyUsageRestrictionEncoded;
    rgExt[3].Value.cbData = cbKeyUsageRestrictionEncoded;
    rgExt[4].pszObjId = szOID_KEY_USAGE;
    rgExt[4].fCritical = FALSE;
    rgExt[4].Value.pbData = pbKeyUsageEncoded;
    rgExt[4].Value.cbData = cbKeyUsageEncoded;
    rgExt[5].pszObjId = szOID_BASIC_CONSTRAINTS2;
    rgExt[5].fCritical = FALSE;
    rgExt[5].Value.pbData = pbBasicConstraints2Encoded;
    rgExt[5].Value.cbData = cbBasicConstraints2Encoded;
    rgExt[6].pszObjId = szOID_CERT_POLICIES;
    rgExt[6].fCritical = FALSE;
    rgExt[6].Value.pbData = pbPoliciesEncoded;
    rgExt[6].Value.cbData = cbPoliciesEncoded;

    rgExt[7].pszObjId = szOID_SUBJECT_ALT_NAME;
    rgExt[7].fCritical = FALSE;
    if (0 == strcmp(CertPara[dwCert].pszName, "InvalidNCEnd_AV")) {
        static BYTE rgbExt[] = {5,0};

        rgExt[7].Value.pbData = rgbExt;
        rgExt[7].Value.cbData = 0;  // sizeof(rgbExt);
    } else {
        rgExt[7].Value.pbData = pbAltNameEncoded;
        rgExt[7].Value.cbData = cbAltNameEncoded;
    }

    if (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)
        Cert.cExtension = 0;
    else if (CertPara[dwCert].dwFlags & VALID_PARA_FLAG)
        Cert.cExtension = 6;
    else if (CertPara[dwCert].dwFlags & SPC_AGENCY_INFO_PARA_FLAG) {
        rgExt[8].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[8].fCritical = TRUE;
        rgExt[8].Value.pbData = pbSpcSpAgencyEncoded2;
        rgExt[8].Value.cbData = cbSpcSpAgencyEncoded2;
        rgExt[9].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbSpcSpAgencyEncoded0;
        rgExt[9].Value.cbData = cbSpcSpAgencyEncoded0;
        rgExt[10].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbSpcSpAgencyEncoded1;
        rgExt[10].Value.cbData = cbSpcSpAgencyEncoded1;
        Cert.cExtension = 11;
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        rgExt[8].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbSpcSpAgencyEncoded0;
        rgExt[8].Value.cbData = cbSpcSpAgencyEncoded0;
        if (CertPara[dwCert].dwFlags &
                (SPC_AGENCY_PARA_FLAG | SPC_COM_PARA_FLAG)) {
            rgExt[9].pszObjId = SPC_COMMON_NAME_OBJID;
            rgExt[9].fCritical = FALSE;
            rgExt[9].Value.pbData = pbSpcCommonNameEncoded;
            rgExt[9].Value.cbData = cbSpcCommonNameEncoded;
            Cert.cExtension = 10;
        } else
            Cert.cExtension = 9;
    } else if (CertPara[dwCert].dwFlags & NETSCAPE_PARA_FLAG) {
        BYTE bCertType;
        CRYPT_BIT_BLOB BitBlob;
        CERT_NAME_VALUE Comment;
        CERT_NAME_VALUE RevUrl;
        CERT_NAME_VALUE BaseUrl;

        BitBlob.pbData = &bCertType;
        BitBlob.cbData = 1;
        BitBlob.cUnusedBits = 2;
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
            bCertType = NETSCAPE_SSL_CA_CERT_TYPE;
        else
            bCertType = NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE;

        if (!AllocAndEncodeObject(
                X509_BITS,
                &BitBlob,
                &pbNetscapeCertType,
                &cbNetscapeCertType))
            goto ErrorReturn;
        rgExt[8].pszObjId = szOID_NETSCAPE_CERT_TYPE;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbNetscapeCertType;
        rgExt[8].Value.cbData = cbNetscapeCertType;

        memset(&Comment, 0, sizeof(Comment));
        Comment.dwValueType = CERT_RDN_IA5_STRING;
        Comment.Value.pbData = (BYTE *) L"This is an IA5 Netscape Comment";
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &Comment,
                &pbNetscapeComment,
                &cbNetscapeComment))
            goto ErrorReturn;
        rgExt[9].pszObjId = szOID_NETSCAPE_COMMENT;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbNetscapeComment;
        rgExt[9].Value.cbData = cbNetscapeComment;

        memset(&BaseUrl, 0, sizeof(BaseUrl));
        BaseUrl.dwValueType = CERT_RDN_IA5_STRING;
#if 0
        BaseUrl.Value.pbData = (BYTE *) L"http://status.verisign.com/";
#else
        BaseUrl.Value.pbData = (BYTE *) L"https://www.netscape.com/";
#endif
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &BaseUrl,
                &pbNetscapeBaseUrl,
                &cbNetscapeBaseUrl))
            goto ErrorReturn;
        rgExt[10].pszObjId = szOID_NETSCAPE_BASE_URL;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbNetscapeBaseUrl;
        rgExt[10].Value.cbData = cbNetscapeBaseUrl;

        memset(&RevUrl, 0, sizeof(RevUrl));
        RevUrl.dwValueType = CERT_RDN_IA5_STRING;
#if 0
        RevUrl.Value.pbData = (BYTE *) L"status/check/ver/1/ID/";
#else
        RevUrl.Value.pbData = (BYTE *) L"cgi-bin/check-rev.cgi?";
#endif
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &RevUrl,
                &pbNetscapeRevUrl,
                &cbNetscapeRevUrl))
            goto ErrorReturn;
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
            rgExt[11].pszObjId = szOID_NETSCAPE_CA_REVOCATION_URL;
        else
            rgExt[11].pszObjId = szOID_NETSCAPE_REVOCATION_URL;
        rgExt[11].fCritical = FALSE;
        rgExt[11].Value.pbData = pbNetscapeRevUrl;
        rgExt[11].Value.cbData = cbNetscapeRevUrl;

        Cert.cExtension = 12;
    } else if (CertPara[dwCert].dwFlags & SET_PARA_FLAG) {
        rgExt[8].pszObjId = szOID_SET_ACCOUNT_ALIAS;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbSETAccountAliasEncoded;
        rgExt[8].Value.cbData = cbSETAccountAliasEncoded;
        rgExt[9].pszObjId = szOID_SET_HASHED_ROOT_KEY;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbSETHashedRootKeyEncoded;
        rgExt[9].Value.cbData = cbSETHashedRootKeyEncoded;
        rgExt[10].pszObjId = szOID_SET_CERTIFICATE_TYPE;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbSETCertificateTypeEncoded;
        rgExt[10].Value.cbData = cbSETCertificateTypeEncoded;
        rgExt[11].pszObjId = szOID_SET_MERCHANT_DATA;
        rgExt[11].fCritical = FALSE;
        rgExt[11].Value.pbData = pbSETMerchantDataEncoded;
        rgExt[11].Value.cbData = cbSETMerchantDataEncoded;
        Cert.cExtension = 12;
    } else {
        Cert.cExtension = 8;
    }

    if ((CertPara[dwCert].dwFlags & DELTA_CRL_PARA_FLAG) ||
            (0 == (CertPara[dwCert].dwFlags &
                (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))) {
        DWORD cExt = Cert.cExtension;

        if (0 == (CertPara[CertPara[dwCert].dwIssuer].dwFlags &
                NO_CRL_EXT_PARA_FLAG)) {
            if (0 != strncmp(CertPara[dwCert].pszName, "NoCDP", 5)) {
                rgExt[cExt].pszObjId = szOID_CRL_DIST_POINTS;
                rgExt[cExt].fCritical = FALSE;
                rgExt[cExt].Value.pbData = pbCrlDistPointsEncoded;
                rgExt[cExt].Value.cbData = cbCrlDistPointsEncoded;
                cExt++;
            }
        }

        if (0 == strcmp(CertPara[dwCert].pszName, "DeltaEndValid")) {
            rgExt[cExt].pszObjId = szOID_FRESHEST_CRL;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbCrlDistPointsEncoded;
            rgExt[cExt].Value.cbData = cbCrlDistPointsEncoded;
            cExt++;
        }

        Cert.cExtension = cExt;
    }

    if (0 == strcmp(CertPara[dwCert].pszName, "DssCA") ||
            0 == strcmp(CertPara[dwCert].pszName, "DssEnd")) {
        DWORD cExt = Cert.cExtension;
        PCTL_USAGE pCtlUsage;

        rgExt[cExt].pszObjId = szOID_CERT_POLICIES;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPoliciesEncoded;
        rgExt[cExt].Value.cbData = cbPoliciesEncoded;
        cExt++;

        if (0 == strcmp(CertPara[dwCert].pszName, "DssCA"))
            pCtlUsage = &rgCtlUsage[0];
        else
            pCtlUsage = &rgCtlUsage[2];

        if (!AllocAndEncodeObject(
                X509_ENHANCED_KEY_USAGE,
                (const void *) pCtlUsage,
                &pbEnhancedKeyUsageEncoded,
                &cbEnhancedKeyUsageEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbEnhancedKeyUsageEncoded;
        rgExt[cExt].Value.cbData = cbEnhancedKeyUsageEncoded;
        cExt++;

        Cert.cExtension = cExt;
    } else if (0 == strcmp("TestAIAEnd", CertPara[dwCert].pszName)) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_INFO_ACCESS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbAuthorityInfoAccessEncoded;
        rgExt[cExt].Value.cbData = cbAuthorityInfoAccessEncoded;
        cExt++;

        Cert.cExtension = cExt;
    } else if (0 == (CertPara[dwCert].dwFlags &
            (NO_EXT_PARA_FLAG | VALID_PARA_FLAG))) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbKeyId2Encoded;
        rgExt[cExt].Value.cbData = cbKeyId2Encoded;
        cExt++;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_INFO_ACCESS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbAuthorityInfoAccessEncoded;
        rgExt[cExt].Value.cbData = cbAuthorityInfoAccessEncoded;
        cExt++;

#if 1
        if (TRUE) {
#else
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
#endif
            if (!CreateKeyId(
                    dwCert,
                    &pbSubjectKeyIdEncoded,
                    &cbSubjectKeyIdEncoded))
                goto ErrorReturn;
            rgExt[cExt].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbSubjectKeyIdEncoded;
            rgExt[cExt].Value.cbData = cbSubjectKeyIdEncoded;
            cExt++;
        }

        if (CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) {
            if (!CreateEnhancedKeyUsage(
                    CertPara[dwCert].dwFlags,
                    &pbEnhancedKeyUsageEncoded,
                    &cbEnhancedKeyUsageEncoded))
                goto ErrorReturn;
            rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbEnhancedKeyUsageEncoded;
            rgExt[cExt].Value.cbData = cbEnhancedKeyUsageEncoded;
            cExt++;
        }

        Cert.cExtension = cExt;
    }


    if (dwCert == POLICY_ROOT || dwCert == POLICY_CA) {
        // 0 - Root
        // 1 - CA

        DWORD cExt = Cert.cExtension;

        if (!CreatePolicyMappings(
                dwCert,
                &pbPolicyMappingsEncoded,
                &cbPolicyMappingsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_POLICY_MAPPINGS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPolicyMappingsEncoded;
        rgExt[cExt].Value.cbData = cbPolicyMappingsEncoded;
        cExt++;

        if (!CreatePolicyConstraints(
                dwCert,
                &pbPolicyConstraintsEncoded,
                &cbPolicyConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_POLICY_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPolicyConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbPolicyConstraintsEncoded;
        cExt++;

        if (!CreateNameConstraints(
                dwCert,
                &pbNameConstraintsEncoded,
                &cbNameConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbNameConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbNameConstraintsEncoded;
        cExt++;

        Cert.cExtension = cExt;

    } else if (0 == strcmp(CertPara[dwCert].pszName, "MissingNCCA")) {
        DWORD cExt = Cert.cExtension;

        if (!CreateNameConstraints(
                dwCert,
                &pbNameConstraintsEncoded,
                &cbNameConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbNameConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbNameConstraintsEncoded;
        cExt++;

        Cert.cExtension = cExt;

    } else if (0 == strcmp(CertPara[dwCert].pszName, "InvalidNCCA_AV")) {
        DWORD cExt = Cert.cExtension;
        static BYTE rgbExt[] = {5,0};

        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgbExt;
        rgExt[cExt].Value.cbData = 0;  // sizeof(rgbExt);
        cExt++;

        Cert.cExtension = cExt;

    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        DWORD cExt = Cert.cExtension;

        if (!CreateSMIMECapabilities(
                dwCert,
                &pbSMIMECapabilitiesEncoded,
                &cbSMIMECapabilitiesEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_RSA_SMIMECapabilities;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSMIMECapabilitiesEncoded;
        rgExt[cExt].Value.cbData = cbSMIMECapabilitiesEncoded;
        cExt++;

        if (!CreateCertIssuingDistPoint(
                dwCert,
                &pbIDPEncoded,
                &cbIDPEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbIDPEncoded;
        rgExt[cExt].Value.cbData = cbIDPEncoded;
        cExt++;

        if (!CreateCrossCertDistPoints(
                dwCert,
                &pbCrossCertDistPointsEncoded,
                &cbCrossCertDistPointsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_CROSS_CERT_DIST_POINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbCrossCertDistPointsEncoded;
        rgExt[cExt].Value.cbData = cbCrossCertDistPointsEncoded;
        cExt++;

        Cert.cExtension = cExt;
    }

    if (CertPara[dwCert].dwFlags & ALT_DIR_NAME_PARA_FLAG) {
        DWORD cExt = Cert.cExtension;

        if (!CreateAltName(
                dwIssuer,
                &pbIssuerAltNameEncoded,
                &cbIssuerAltNameEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_ISSUER_ALT_NAME2;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbIssuerAltNameEncoded;
        rgExt[cExt].Value.cbData = cbIssuerAltNameEncoded;
        cExt++;

        Cert.cExtension = cExt;
    }

    if (CertPara[dwCert].pszManifold) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_CERT_MANIFOLD;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = (BYTE *) CertPara[dwCert].pszManifold;
        rgExt[cExt].Value.cbData = strlen(CertPara[dwCert].pszManifold);
        cExt++;

        Cert.cExtension = cExt;
    }

    if (0 == strcmp("V1", CertPara[dwCert].pszName)) {
        Cert.dwVersion = CERT_V1;
        Cert.cExtension = 0;
    } else if (0 == strcmp("V2", CertPara[dwCert].pszName)) {
        Cert.dwVersion = CERT_V2;
        Cert.cExtension = 0;

#define ISSUER_UNIQUE_ID    "Issuer Unique Id"
#define SUBJECT_UNIQUE_ID   "Subject Unique Id"
        Cert.IssuerUniqueId.pbData = (BYTE *) ISSUER_UNIQUE_ID;
        Cert.IssuerUniqueId.cbData = strlen(ISSUER_UNIQUE_ID);
        Cert.IssuerUniqueId.cUnusedBits = 0;

        Cert.SubjectUniqueId.pbData = (BYTE *) SUBJECT_UNIQUE_ID;
        Cert.SubjectUniqueId.cbData = strlen(SUBJECT_UNIQUE_ID);
        Cert.SubjectUniqueId.cUnusedBits = 0;
    }

    Cert.rgExtension = rgExt;

    if (!AllocAndEncodeObject(
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &pbCertEncoded,
            &cbCertEncoded))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwIssuer,
            pbCertEncoded,
            cbCertEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeyIdEncoded)
        TestFree(pbKeyIdEncoded);
    if (pbKeyId2Encoded)
        TestFree(pbKeyId2Encoded);
    if (pbSubjectKeyIdEncoded)
        TestFree(pbSubjectKeyIdEncoded);
    if (pbAuthorityInfoAccessEncoded)
        TestFree(pbAuthorityInfoAccessEncoded);
    if (pbCrlDistPointsEncoded)
        TestFree(pbCrlDistPointsEncoded);
    if (pbKeyAttrEncoded)
        TestFree(pbKeyAttrEncoded);
    if (pbAltNameEncoded)
        TestFree(pbAltNameEncoded);
    if (pbIssuerAltNameEncoded)
        TestFree(pbIssuerAltNameEncoded);
    if (pbKeyUsageRestrictionEncoded)
        TestFree(pbKeyUsageRestrictionEncoded);
    if (pbBasicConstraintsEncoded)
        TestFree(pbBasicConstraintsEncoded);
    if (pbKeyUsageEncoded)
        TestFree(pbKeyUsageEncoded);
    if (pbBasicConstraints2Encoded)
        TestFree(pbBasicConstraints2Encoded);
    if (pbPoliciesEncoded)
        TestFree(pbPoliciesEncoded);
    if (pbSETAccountAliasEncoded)
        TestFree(pbSETAccountAliasEncoded);
    if (pbSETHashedRootKeyEncoded)
        TestFree(pbSETHashedRootKeyEncoded);
    if (pbSETCertificateTypeEncoded)
        TestFree(pbSETCertificateTypeEncoded);
    if (pbSETMerchantDataEncoded)
        TestFree(pbSETMerchantDataEncoded);
    if (pbSpcSpAgencyEncoded0)
        TestFree(pbSpcSpAgencyEncoded0);
    if (pbSpcSpAgencyEncoded1)
        TestFree(pbSpcSpAgencyEncoded1);
    if (pbSpcSpAgencyEncoded2)
        TestFree(pbSpcSpAgencyEncoded2);
    if (pbSpcCommonNameEncoded)
        TestFree(pbSpcCommonNameEncoded);
    if (pbNetscapeCertType)
        TestFree(pbNetscapeCertType);
    if (pbNetscapeComment)
        TestFree(pbNetscapeComment);
    if (pbNetscapeRevUrl)
        TestFree(pbNetscapeRevUrl);
    if (pbNetscapeBaseUrl)
        TestFree(pbNetscapeBaseUrl);

    if (pbSubjectEncoded)
        TestFree(pbSubjectEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (pbEnhancedKeyUsageEncoded)
        TestFree(pbEnhancedKeyUsageEncoded);
    if (pbSMIMECapabilitiesEncoded)
        TestFree(pbSMIMECapabilitiesEncoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbNameConstraintsEncoded)
        TestFree(pbNameConstraintsEncoded);
    if (pbPolicyMappingsEncoded)
        TestFree(pbPolicyMappingsEncoded);
    if (pbPolicyConstraintsEncoded)
        TestFree(pbPolicyConstraintsEncoded);
    if (pbCrossCertDistPointsEncoded)
        TestFree(pbCrossCertDistPointsEncoded);

    return fResult;
}

static BOOL EncodeCrl(
    DWORD dwCert,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded,
    DWORD dwAki
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;
    BYTE *pbKeyId2Encoded = NULL;
    DWORD cbKeyId2Encoded;
    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    DWORD i;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;

    CRL_ENTRY rgEntry[CERT_CNT];
    CRL_INFO Crl;

    FILETIME SerialNumber[CERT_CNT];

#define CRL_EXTENSION_CNT 2
    CERT_EXTENSION rgExt[CRL_EXTENSION_CNT];

    // Max of 1 extension per entry
    CERT_EXTENSION rgEntryExt[CERT_CNT];
    memset(rgEntryExt, 0, sizeof(rgEntryExt));

    // ISSUER
    CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerEncoded,
            &cbIssuerEncoded
            ))
        goto ErrorReturn;

    // CRL
    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG)
        Crl.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Crl.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Crl.Issuer.pbData = pbIssuerEncoded;
    Crl.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1921;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 2071;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            if (0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
            }
        }
    }

    Crl.cCRLEntry = 0;
    Crl.rgCRLEntry = rgEntry;
    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwIssuer == dwCert &&
            (CertPara[i].dwFlags & REVOKED_PARA_FLAG)) {
            DWORD j;

            SYSTEMTIME SystemTime = TestTime;

            j = Crl.cCRLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            SystemTime.wMilliseconds += (WORD) i;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber[j]);

            rgEntry[j].SerialNumber.pbData = (BYTE *) &SerialNumber[j];
            rgEntry[j].SerialNumber.cbData = sizeof(SerialNumber[j]);
            if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
                SystemTime.wYear = 1922;
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);
            } else
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);

            if (0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                if (!CreateCRLReason(
                        &rgEntryExt[j].Value.pbData,
                        &rgEntryExt[j].Value.cbData))
                    goto ErrorReturn;
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = FALSE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            }

        }
    }

    if (AKI2_NONE != dwAki &&
            0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
        // Crl Extensions
        if (!CreateAuthorityKeyId2(
                dwCert,
                dwCert,
                &pbKeyId2Encoded,
                &cbKeyId2Encoded,
                dwAki
                ))
            goto ErrorReturn;

        rgExt[0].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
        rgExt[0].fCritical = FALSE;
        rgExt[0].Value.pbData = pbKeyId2Encoded;
        rgExt[0].Value.cbData = cbKeyId2Encoded;

        if (!CreateCrlIssuingDistPoint(
                &pbIDPEncoded,
                &cbIDPEncoded
                ))
            goto ErrorReturn;

        rgExt[1].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[1].fCritical = FALSE;
        rgExt[1].Value.pbData = pbIDPEncoded;
        rgExt[1].Value.cbData = cbIDPEncoded;

        Crl.cExtension = CRL_EXTENSION_CNT;
        Crl.rgExtension = rgExt;
    }

    if (0 == strcmp("V1", CertPara[dwCert].pszName)) {
        Crl.dwVersion = CRL_V1;
        Crl.cExtension = 0;
    }

    if (!AllocAndEncodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            &pbCrlEncoded,
            &cbCrlEncoded
            ))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwCert,
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeyId2Encoded)
        TestFree(pbKeyId2Encoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);
    for (i = 0; i < CERT_CNT; i++) {
        if (rgEntryExt[i].Value.pbData)
            TestFree(rgEntryExt[i].Value.pbData);
    }

    return fResult;
}

static BOOL EncodeBaseOrDeltaCrl(
    DWORD dwIssuer,
    int iBase,
    DWORD dwFlags,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbIssuerNameEncoded = NULL;
    DWORD cbIssuerNameEncoded;
    BYTE *pbCDPEncoded = NULL;
    DWORD cbCDPEncoded;
    BYTE *pbBaseEncoded;
    DWORD cbBaseEncoded;
    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber[CERT_CNT];
    CRL_ENTRY rgEntry[CERT_CNT];
    CRL_INFO Crl;
    CERT_EXTENSION rgExt[10];
    DWORD cExt = 0;

    // Max of 1 extension per entry
    CERT_EXTENSION rgEntryExt[CERT_CNT];
    memset(rgEntryExt, 0, sizeof(rgEntryExt));

    // ISSUER
    CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerNameEncoded,
            &cbIssuerNameEncoded
            ))
        goto ErrorReturn;

    // CRL
    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        Crl.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Crl.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Crl.Issuer.pbData = pbIssuerNameEncoded;
    Crl.Issuer.cbData = cbIssuerNameEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (dwFlags & EXPIRED_CRL_FLAG) {
            SystemTime.wYear = 1997;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 1998;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else if (CertPara[dwIssuer].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1921;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 2071;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            if (0 == (CertPara[dwIssuer].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
            }
        }
    }

    Crl.cCRLEntry = 0;
    Crl.rgCRLEntry = rgEntry;
    if (0 == (dwFlags & NO_ENTRIES_CRL_FLAG)) {
      for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwIssuer == dwIssuer &&
            (CertPara[i].dwFlags & REVOKED_PARA_FLAG)) {
            DWORD j;

            SYSTEMTIME SystemTime = TestTime;

            j = Crl.cCRLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            SystemTime.wMilliseconds += (WORD) i;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber[j]);

            rgEntry[j].SerialNumber.pbData = (BYTE *) &SerialNumber[j];
            rgEntry[j].SerialNumber.cbData = sizeof(SerialNumber[j]);
            if (CertPara[dwIssuer].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
                SystemTime.wYear = 1922;
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);
            } else
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);

            if (dwFlags & REMOVE_FROM_CRL_FLAG) {
                int iReason = CRL_REASON_REMOVE_FROM_CRL;
                if (!AllocAndEncodeObject(
                        X509_ENUMERATED,
                        (const void *) &iReason,
                        &rgEntryExt[j].Value.pbData,
                        &rgEntryExt[j].Value.cbData))
                    goto ErrorReturn;
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = TRUE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            } else if (0 == (CertPara[dwIssuer].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                if (dwFlags & HOLD_CRL_FLAG) {
                    int iReason = CRL_REASON_CERTIFICATE_HOLD;
                    if (!AllocAndEncodeObject(
                            X509_ENUMERATED,
                            (const void *) &iReason,
                            &rgEntryExt[j].Value.pbData,
                            &rgEntryExt[j].Value.cbData))
                        goto ErrorReturn;
                } else {
                    if (!CreateCRLReason(
                            &rgEntryExt[j].Value.pbData,
                            &rgEntryExt[j].Value.cbData))
                        goto ErrorReturn;
                }
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = FALSE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            }

        }
      }
    }

    // Extensions
    memset(&rgExt, 0, sizeof(rgExt));
    if (!AllocAndEncodeObject(
            X509_INTEGER,
            (const void *) &iBase,
            &pbBaseEncoded,
            &cbBaseEncoded))
        goto ErrorReturn;
    if (dwFlags & FRESHEST_CRL_FLAG) {
        rgExt[0].pszObjId = szOID_DELTA_CRL_INDICATOR;
        rgExt[0].fCritical = TRUE;
    } else {
        rgExt[0].pszObjId = szOID_CRL_NUMBER;
        rgExt[0].fCritical = FALSE;
    }
    rgExt[0].Value.pbData = pbBaseEncoded;
    rgExt[0].Value.cbData = cbBaseEncoded;
    cExt = 1;

    if (dwFlags & UNSUPPORTED_CRITICAL_EXT_CRL_FLAG) {
        rgExt[cExt].pszObjId = "1.2.3.4.1999.2000";
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbBaseEncoded;
        rgExt[cExt].Value.cbData = cbBaseEncoded;
        cExt++;
    }

    if (0 == (dwFlags & FRESHEST_CRL_FLAG) &&
            0 == (dwFlags & NO_FRESHEST_CDP_CRL_FLAG)) {
        if (!CreateCrlDistPoints(
                dwIssuer,
                CRL_DIST_POINTS_DELTA_FLAG,
                &pbCDPEncoded,
                &cbCDPEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_FRESHEST_CRL;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbCDPEncoded;
        rgExt[cExt].Value.cbData = cbCDPEncoded;
        cExt++;
    }



    if (0 == (dwFlags & NO_IDP_CRL_FLAG)) {
        CRL_ISSUING_DIST_POINT IDP;
        PCERT_ALT_NAME_INFO pIDPAltNameInfo;
        
        CERT_ALT_NAME_ENTRY rgIDPAltNameEntry[8];
        BYTE bOnlySomeReasonFlags;

        memset(&IDP, 0, sizeof(IDP));
        if (dwFlags & UNSUPPORTED_IDP_OPTIONS_CRL_FLAG) {
            IDP.OnlySomeReasonFlags.cbData = 1;
            IDP.OnlySomeReasonFlags.pbData = &bOnlySomeReasonFlags;
            IDP.OnlySomeReasonFlags.cUnusedBits = 1;
            bOnlySomeReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
                CRL_REASON_CA_COMPROMISE_FLAG;

            IDP.fIndirectCRL = TRUE;
        }

        if (dwFlags & ONLY_USERS_CRL_FLAG)
            IDP.fOnlyContainsUserCerts = TRUE;
        if (dwFlags & ONLY_CAS_CRL_FLAG)
            IDP.fOnlyContainsCACerts = TRUE;

        IDP.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

        rgIDPAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgIDPAltNameEntry[0].pOtherName = &CrlOtherName;
        rgIDPAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgIDPAltNameEntry[1].DirectoryName.pbData = pbIssuerNameEncoded;
        rgIDPAltNameEntry[1].DirectoryName.cbData = cbIssuerNameEncoded;
        rgIDPAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgIDPAltNameEntry[2].pwszDNSName = CRL_DNS_NAME;
        rgIDPAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgIDPAltNameEntry[3].pwszRfc822Name = CRL_EMAIL_NAME;
        rgIDPAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgIDPAltNameEntry[4].pszRegisteredID = CRL_REGISTERED_ID;
        rgIDPAltNameEntry[5].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgIDPAltNameEntry[5].IPAddress.pbData = CrlIPAddress;
        rgIDPAltNameEntry[5].IPAddress.cbData = sizeof(CrlIPAddress);
        rgIDPAltNameEntry[6].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIDPAltNameEntry[6].pwszURL = CRL_URL_NAME2;
        rgIDPAltNameEntry[7].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIDPAltNameEntry[7].pwszURL = CRL_URL_NAME1;

        pIDPAltNameInfo = &IDP.DistPointName.FullName;
        switch (iBase) {
            case 1:
                pIDPAltNameInfo->cAltEntry = 1;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[0];
                break;
            case 2:
                pIDPAltNameInfo->cAltEntry = 1;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[1];
                break;
            case 3:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[2];
                break;
            case 4:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[4];
                break;
            default:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[6];
                break;
        }

        if (!AllocAndEncodeObject(
                szOID_ISSUING_DIST_POINT,
                &IDP,
                &pbIDPEncoded,
                &cbIDPEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbIDPEncoded;
        rgExt[cExt].Value.cbData = cbIDPEncoded;
        cExt++;
    }

    Crl.cExtension = cExt;
    Crl.rgExtension = rgExt;

    if (!AllocAndEncodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            &pbCrlEncoded,
            &cbCrlEncoded
            ))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwIssuer,
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbIssuerNameEncoded)
        TestFree(pbIssuerNameEncoded);
    if (pbBaseEncoded)
        TestFree(pbBaseEncoded);
    if (pbCDPEncoded)
        TestFree(pbCDPEncoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);
    for (i = 0; i < CERT_CNT; i++) {
        if (rgEntryExt[i].Value.pbData)
            TestFree(rgEntryExt[i].Value.pbData);
    }

    return fResult;
}

static BOOL EncodeCtl(DWORD dwCert, DWORD dwEncodeFlags, BYTE **ppbEncoded,
        DWORD *pcbEncoded)
{
    BOOL fResult;

    BYTE *pbNextUpdateLoc = NULL;
    DWORD cbNextUpdateLoc;
    BYTE *pbCtlEncoded = NULL;
    DWORD cbCtlEncoded;

    DWORD dwFlags;
    DWORD dwCtlFlags;
    DWORD dwUseFlag;
    DWORD i;

    struct {
        FILETIME    ft;
        DWORD       dwCert;
    } SequenceNumber;

    PCTL_USAGE pCtlUsage;           // not allocated

    BYTE rgbHash[CERT_CNT][MAX_HASH_LEN];
    BYTE rgbZero[1] = {0};

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CRYPT_ATTR_BLOB rgAttrBlob[2] = {
            2, (BYTE *) NullDer,
            3, (BYTE *) IntegerDer
    };
    CRYPT_ATTRIBUTE rgAttr[] = {
        "1.2.3.4.5.0",
            1, rgAttrBlob,
        "1.2.1.1.1.1.1.1",
            2, rgAttrBlob
    };

    CMSG_SIGNER_ENCODE_INFO SignerInfo;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    CRYPT_ATTRIBUTE SignerAttr;
    CRYPT_ATTR_BLOB SignerAttrBlob;
    CERT_BLOB CertBlob;

    CTL_ENTRY rgEntry[CERT_CNT];
#define CTL_EXTENSION_CNT 1
    CERT_EXTENSION rgExt[CTL_EXTENSION_CNT];
    CTL_INFO Ctl;

    if (NULL == rgpCertContext[dwCert])
        goto ErrorReturn;

    dwFlags = CertPara[dwCert].dwFlags;

    // CTL
    memset(&Ctl, 0, sizeof(Ctl));
    Ctl.dwVersion = CTL_V1;

    dwCtlFlags = dwFlags & (CTL1_PARA_FLAG | CTL2_PARA_FLAG);
    dwUseFlag = 0;
    switch (dwCtlFlags) {
        case CTL1_PARA_FLAG:
            if (dwFlags & NO_EXT_PARA_FLAG)
                pCtlUsage = &rgCtlUsage[0];
            else {
                pCtlUsage = &rgCtlUsage[1];
                dwUseFlag = USE1_PARA_FLAG;
            }
            break;
        case CTL2_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[2];
            dwUseFlag = USE2_PARA_FLAG;
            break;
        case CTL1_PARA_FLAG | CTL2_PARA_FLAG:
        default:
            pCtlUsage = &rgCtlUsage[3];
            break;
    }
    Ctl.SubjectUsage = *pCtlUsage;

    if (dwFlags & CTL2_PARA_FLAG) {
        DWORD dwIdx;
        if (dwFlags & TIME_INVALID_PARA_FLAG) {
            assert(dwFlags & DUPLICATE_PARA_FLAG);
            dwIdx = dwCert - 1;
        } else
            dwIdx = dwCert;
        Ctl.ListIdentifier.pbData = (BYTE *) CertPara[dwIdx].pszName;
        Ctl.ListIdentifier.cbData = strlen(CertPara[dwIdx].pszName);

        MySystemTimeToFileTime(&TestTime, &SequenceNumber.ft);
        SequenceNumber.dwCert = dwCert;
        Ctl.SequenceNumber.pbData = (BYTE *) &SequenceNumber;
        Ctl.SequenceNumber.cbData = sizeof(SequenceNumber);
    }


    {
        SYSTEMTIME SystemTime = TestTime;

        if (dwFlags & TIME_INVALID_PARA_FLAG) {
            SystemTime.wYear -=2;
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            if (dwUseFlag) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
            }
        }
    }

    Ctl.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    Ctl.cCTLEntry = 0;
    Ctl.rgCTLEntry = rgEntry;

    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwFlags & dwUseFlag) {
            DWORD j;
            DWORD cbHash;

            if (NULL == rgpCertContext[i])
                continue;

            j = Ctl.cCTLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            cbHash = MAX_HASH_LEN;
            if (CertGetCertificateContextProperty(
                    rgpCertContext[i],
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash[j],
                    &cbHash)) {
                rgEntry[j].SubjectIdentifier.pbData = rgbHash[j];
                rgEntry[j].SubjectIdentifier.cbData = cbHash;
            } else {
                PrintLastError(
                    "CertGetCertificateContextProperty(SHA1_HASH)");
                rgEntry[j].SubjectIdentifier.pbData = rgbZero;
                rgEntry[j].SubjectIdentifier.cbData = sizeof(rgbZero);
            }

            if (CertPara[i].dwFlags & ALL_EXT_PARA_FLAG) {
                rgEntry[j].cAttribute = sizeof(rgAttr) / sizeof(rgAttr[0]);
                rgEntry[j].rgAttribute = rgAttr;
            }
        }

    }

    if (!CreateNextUpdateLocation(
            dwCert,
            FALSE,              // fProp
            &pbNextUpdateLoc,
            &cbNextUpdateLoc))
        goto ErrorReturn;

    // Ctl Extensions

    rgExt[0].pszObjId = szOID_NEXT_UPDATE_LOCATION;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbNextUpdateLoc;
    rgExt[0].Value.cbData = cbNextUpdateLoc;

    if (0 == (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)) {
        Ctl.cExtension = 1;
        Ctl.rgExtension = rgExt;
    }

    memset(&SignerInfo, 0, sizeof(SignerInfo));
    SignerInfo.cbSize = sizeof(SignerInfo);
    SignerInfo.pCertInfo = rgpCertContext[dwCert]->pCertInfo;
    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG)
            SignerInfo.hCryptProv = hDSS512CryptProv;
        else
            SignerInfo.hCryptProv = hDSSCryptProv;
    } else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
        SignerInfo.hCryptProv = hEnh1024CryptProv;
    else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
        SignerInfo.hCryptProv = hEnh2048CryptProv;
    else
        SignerInfo.hCryptProv = hRSACryptProv;
    SignerInfo.dwKeySpec = AT_SIGNATURE;
    SignerInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    if (dwFlags & CTL2_PARA_FLAG) {
        // Signer Attributes
        memset(&SignerAttr, 0, sizeof(SignerAttr));
        SignerAttr.pszObjId = szOID_NEXT_UPDATE_LOCATION;
        SignerAttr.cValue = 1;
        SignerAttr.rgValue = &SignerAttrBlob;
        SignerAttrBlob.pbData = pbNextUpdateLoc;
        SignerAttrBlob.cbData = cbNextUpdateLoc;

        SignerInfo.cAuthAttr = 1;
        SignerInfo.rgAuthAttr = &SignerAttr;
        SignerInfo.cUnauthAttr = 1;
        SignerInfo.rgUnauthAttr = &SignerAttr;
    }

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    if (dwUseFlag) {
        SignInfo.cSigners = 1;
        SignInfo.rgSigners = &SignerInfo;
        SignInfo.cCertEncoded = 1;
        CertBlob.pbData = rgpCertContext[dwCert]->pbCertEncoded;
        CertBlob.cbData = rgpCertContext[dwCert]->cbCertEncoded;
        SignInfo.rgCertEncoded = &CertBlob;
    }

    cbCtlEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            dwEncodeFlags,
            NULL,               // pbEncoded
            &cbCtlEncoded
            ) || 0 == cbCtlEncoded) {
        PrintLastError("EncodeCtl::CryptMsgEncodeAndSignCTL(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCtlEncoded = (BYTE *) TestAlloc(cbCtlEncoded);
    if (pbCtlEncoded == NULL) goto ErrorReturn;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            dwEncodeFlags,
            pbCtlEncoded,
            &cbCtlEncoded
            )) {
        PrintLastError("EncodeCtl::CryptMsgEncodeAndSignCTL");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbCtlEncoded)
        TestFree(pbCtlEncoded);
    pbCtlEncoded = NULL;
    cbCtlEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNextUpdateLoc)
        TestFree(pbNextUpdateLoc);
    *ppbEncoded = pbCtlEncoded;
    *pcbEncoded = cbCtlEncoded;

    return fResult;
}

static BOOL EncodeUpdateCtl(
    BOOL fTimeInvalid,
    LPSTR pszUsageObjId,
    LPSTR pszListIdentifier,
    LPWSTR pwszUrl,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    )
{
    BOOL fResult;

    BYTE *pbNextUpdateLoc = NULL;
    DWORD cbNextUpdateLoc;
    BYTE *pbCtlEncoded = NULL;
    DWORD cbCtlEncoded;

    CERT_BLOB CertBlob;
    CMSG_SIGNER_ENCODE_INFO SignerInfo;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    CERT_EXTENSION rgExt[1];
    CTL_INFO Ctl;

    if (NULL == rgpCertContext[UPDATE_CTL_SIGNER])
        goto ErrorReturn;

    // CTL
    memset(&Ctl, 0, sizeof(Ctl));
    Ctl.dwVersion = CTL_V1;
    Ctl.SubjectUsage.cUsageIdentifier = 1;
    Ctl.SubjectUsage.rgpszUsageIdentifier = &pszUsageObjId;

    Ctl.ListIdentifier.pbData = (BYTE *) pszListIdentifier;
    Ctl.ListIdentifier.cbData = strlen(pszListIdentifier);


    {
        SYSTEMTIME SystemTime = TestTime;

        if (fTimeInvalid) {
            SystemTime.wYear -=2;
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        }
    }

    Ctl.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    if (!CreateNextUpdateLocation(
            UPDATE_CTL_SIGNER,  // dwCert
            FALSE,              // fProp
            &pbNextUpdateLoc,
            &cbNextUpdateLoc,
            pwszUrl))
        goto ErrorReturn;

    // Ctl Extensions

    rgExt[0].pszObjId = szOID_NEXT_UPDATE_LOCATION;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbNextUpdateLoc;
    rgExt[0].Value.cbData = cbNextUpdateLoc;

    Ctl.cExtension = 1;
    Ctl.rgExtension = rgExt;

    memset(&SignerInfo, 0, sizeof(SignerInfo));
    SignerInfo.cbSize = sizeof(SignerInfo);
    SignerInfo.pCertInfo = rgpCertContext[UPDATE_CTL_SIGNER]->pCertInfo;
    SignerInfo.hCryptProv = hRSACryptProv;
    SignerInfo.dwKeySpec = AT_SIGNATURE;
    SignerInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    SignInfo.cSigners = 1;
    SignInfo.rgSigners = &SignerInfo;
    SignInfo.cCertEncoded = 1;
    CertBlob.pbData = rgpCertContext[UPDATE_CTL_SIGNER]->pbCertEncoded;
    CertBlob.cbData = rgpCertContext[UPDATE_CTL_SIGNER]->cbCertEncoded;
    SignInfo.rgCertEncoded = &CertBlob;

    cbCtlEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            0,                  // dwEncodeFlags
            NULL,               // pbEncoded
            &cbCtlEncoded
            ) || 0 == cbCtlEncoded) {
        PrintLastError("EncodeUpdateCtl::CryptMsgEncodeAndSignCTL(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCtlEncoded = (BYTE *) TestAlloc(cbCtlEncoded);
    if (pbCtlEncoded == NULL) goto ErrorReturn;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            0,                  // dwEncodeFlags
            pbCtlEncoded,
            &cbCtlEncoded
            )) {
        PrintLastError("EncodeUpdateCtl::CryptMsgEncodeAndSignCTL");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbCtlEncoded)
        TestFree(pbCtlEncoded);
    pbCtlEncoded = NULL;
    cbCtlEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNextUpdateLoc)
        TestFree(pbNextUpdateLoc);
    *ppbEncoded = pbCtlEncoded;
    *pcbEncoded = cbCtlEncoded;

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\ttrust\hashexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       hashexample.cpp
//
//  Contents:   An example calling WTHelperGetFileHash to get the hash
//              of a signed file
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <wintrustp.h>

#define MAX_HASH_LEN    20


// Returns ERROR_SUCCESS if the file has a valid signed hash
LONG GetSignedFileHashExample(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[MAX_HASH_LEN],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    )
{
    return WTHelperGetFileHash(
        pwszFilename,
        0,              // dwFlags
        NULL,           // pvReserved
        rgbFileHash,
        pcbFileHash,
        pHashAlgid
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstore4\tstore4.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore4.cpp
//
//  Contents:   Test certificate store resync and notify change functions
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    28-Aug-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tstore4 [options] <SystemStoreName>\n");
    printf("Options are:\n");
    printf("  -h            - This message\n");
    printf("  -v            - Verbose\n");
    printf("  -t<number>    - Timeout (milliseconds, default INFINITE)\n");
    printf("  -f<number>    - Flags\n");
    printf("  -i            - Iterations (default to infinite)\n");
    printf("  -a            - Auto Resync\n");
    printf("  -A            - Auto Resync (user prompt to display)\n");
    printf("  -s            - System store (ignored)\n");
    printf("  -RefreshCUGP  - Refresh client CurrentUser GPT\n");
    printf("  -RefreshLMGP  - Refresh client LocalMachine GPT\n");
    printf("\n");
}

typedef BOOL (WINAPI *PFN_REFRESH_POLICY)(
    IN BOOL bMachine
    );

#define sz_USERENV_DLL                  "userenv.dll"
#define sz_RefreshPolicy                "RefreshPolicy"

static void CallRefreshPolicy(
    IN BOOL fMachine
    )
{
    HMODULE hDll = NULL;

    PFN_REFRESH_POLICY pfnRefreshPolicy;

    if (NULL == (hDll = LoadLibraryA(sz_USERENV_DLL))) {
        PrintLastError("LoadLibrary(userenv.dll)");
        goto ErrorReturn;
    }

    if (NULL == (pfnRefreshPolicy = 
            (PFN_REFRESH_POLICY) GetProcAddress(
                hDll, sz_RefreshPolicy))) {
        PrintLastError("GetProcAddress(RefreshPolicy)");
        goto ErrorReturn;
    }

    if (!pfnRefreshPolicy(fMachine)) {
        PrintLastError("RefreshPolicy");
        goto ErrorReturn;
    }

ErrorReturn:
    if (hDll)
        FreeLibrary(hDll);

    return;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status = 0;
    DWORD i;
    DWORD dwError;
    DWORD dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    HCERTSTORE hStoreToClose = NULL;
    HCERTSTORE hStore = NULL;
    DWORD dwFlags = CERT_STORE_READONLY_FLAG;
    DWORD dwMilliseconds = INFINITE;
    BOOL fAutoResync = FALSE;
    BOOL fUserPrompt = FALSE;
    DWORD dwIterations = 0;

    BOOL fRefreshPolicy = FALSE;
    BOOL fMachine = FALSE;

    HANDLE hEvent = NULL;
    HANDLE hEvent2 = NULL;
    HANDLE hEventToClose = NULL;

    LPSTR pszSystemName = NULL;     // not allocated

    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "RefreshCUGP")) {
                fRefreshPolicy = TRUE;
                fMachine = FALSE;
            } else if (0 == _stricmp(argv[0]+1, "RefreshLMGP")) {
                fRefreshPolicy = TRUE;
                fMachine = TRUE;
            } else {
                switch(argv[0][1])
                {

                case 'v':
                    dwDisplayFlags = DISPLAY_VERBOSE_FLAG;
                    break;
                case 'i':
                    dwIterations = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'f':
                    dwFlags = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwMilliseconds = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'A':
                    fUserPrompt = TRUE;
                case 'a':
                    fAutoResync = TRUE;
                    break;

                case 's':
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszSystemName) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            pszSystemName = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (fRefreshPolicy) {
        CallRefreshPolicy(fMachine);
        goto SuccessReturn;
    }

    if (NULL == pszSystemName) {
        printf("Missing <SystemStoreName>\n");
        goto BadUsage;
    }

    hStore = OpenStoreEx(TRUE, pszSystemName, dwFlags);

    if (NULL == hStore) {
        PrintLastError("CertOpenStore");
        goto ErrorReturn;
    }

    // Create event to be notified
    if (NULL == (hEvent = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL))) {   // lpszEventName
        PrintLastError("CreateEvent");
        goto ErrorReturn;
    }

    // Create second event to be notified
    if (NULL == (hEvent2 = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL))) {   // lpszEventName
        PrintLastError("CreateEvent");
        goto ErrorReturn;
    }


    if (!fUserPrompt) {
        hStoreToClose = OpenStoreEx(TRUE, pszSystemName, dwFlags);
        if (NULL == hStoreToClose) {
            PrintLastError("CertOpenStore(StoreToClose)");
            goto ErrorReturn;
        }

        if (NULL == (hEventToClose = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))) {   // lpszEventName
            PrintLastError("CreateEvent");
            goto ErrorReturn;
        }

        // Register the event to be signaled when the store changes
        if (!CertControlStore(
                hStoreToClose,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEventToClose
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register second event to be signaled when the store changes
        if (!CertControlStore(
                hStoreToClose,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEventToClose
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register the event to be signaled when the store changes
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register second event to be signaled when the store changes
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent2
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        CertCloseStore(hStoreToClose, 0);
        hStoreToClose = NULL;
    }

    if (fAutoResync) {
        printf("Auto Resync is enabled\n");
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL            // pvCtrlPara
                )) {
            PrintLastError("CertControlStore(AUTO_RESYNC)");
            goto ErrorReturn;
        }
    }

    // Loop and wait for store changes
    i = 0;
    while (TRUE) {
        if (fUserPrompt) {
            int c;
            fputs("Waiting to sync (q)uit ->", stdout);
            fflush(stdin);
            fflush(stdout);
            c = getchar();
            if ('q' == c)
                break;
        } else {
            DWORD dwWait;
            dwWait = WaitForSingleObjectEx(
                    hEvent,
                    dwMilliseconds,
                    FALSE                       // bAlertable
                    );
            if (!(WAIT_OBJECT_0 == dwWait || WAIT_TIMEOUT == dwWait)) {
                PrintLastError("WaitForSingleObjectEx");
                goto ErrorReturn;
            }

        }

        i++;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        printf("\n");
        if (fAutoResync) {
            printf(">>>>>  Auto Resync[%d] at: %s  >>>>>\n",
                i, FileTimeText(&FileTime));

            if (!fUserPrompt) {
                if (!CertControlStore(
                        hStore,
                        0,              // dwFlags
                        CERT_STORE_CTRL_RESYNC,
                        &hEvent
                        )) {
                    PrintLastError("CertControlStore(RESYNC, for AutoResync)");
                    goto ErrorReturn;
                }
            }

            DisplayStore(hStore, dwDisplayFlags);
        } else {
            printf(">>>>>  Before Resync[%d]  >>>>>\n", i);
            DisplayStore(hStore, dwDisplayFlags);

            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_RESYNC,
                    fUserPrompt ? NULL : &hEvent
                    )) {
                PrintLastError("CertControlStore(RESYNC)");
                goto ErrorReturn;
            }


            printf("\n");
            printf(">>>>>  After Resync[%d] at: %s  >>>>>\n",
                i, FileTimeText(&FileTime));
            DisplayStore(hStore, dwDisplayFlags);
        }

        if (!fUserPrompt) {
            // Check that the second event is still signalled
            DWORD dwWait;
            dwWait = WaitForSingleObjectEx(
                    hEvent2,
                    0,
                    FALSE                       // bAlertable
                    );
            if (WAIT_OBJECT_0 != dwWait) {
                printf("@@@@ second event NOT signaled 0x%x @@@@\n", dwWait);
            } else {
                printf("second event signalled\n");
                if (!CertControlStore(
                        hStore,
                        0,              // dwFlags
                        CERT_STORE_CTRL_RESYNC,
                        &hEvent2
                        )) {
                    PrintLastError(
                        "CertControlStore(RESYNC, for second event)");
                    goto ErrorReturn;
                }
            }
        }

        if (0 != dwIterations && i == dwIterations)
            break;
    }

SuccessReturn:
    status = 0;

CommonReturn:
    if (hEvent)
        CloseHandle(hEvent);
    if (hEvent2)
        CloseHandle(hEvent2);
    if (hEventToClose)
        CloseHandle(hEventToClose);
    if (hStoreToClose)
        CertCloseStore(hStoreToClose, 0);
    if (hStore)
        CertCloseStore(hStore, 0);
    return status;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

ErrorReturn:
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\ttrust\wvtexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       wvtexample.cpp
//
//  Contents:   An example calling WinVerifyTrust for Safer
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>


void SaferVerifyFileExample(
    IN LPCWSTR pwszFilename
    )
{
    LONG lStatus;
    DWORD dwLastError;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;

    //
    // Initialize the WinVerifyTrust input data structure
    //
    memset(&wvtData, 0, sizeof(wvtData));   // default all fields to 0
    wvtData.cbStruct = sizeof(wvtData);
    // wvtData.pPolicyCallbackData =        // use default code signing EKU
    // wvtData.pSIPClientData =             // no data to pass to SIP

    // Display UI if not already trusted or disallowed. Note, admin policy
    // may disable UI.
    wvtData.dwUIChoice = WTD_UI_ALL;

    // wvtData.fdwRevocationChecks =        // do revocation checking if
                                            // enabled by admin policy or
                                            // IE advanced user options
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;

    // wvtData.dwStateAction =              // default verification
    // wvtData.hWVTStateData =              // not applicable for default
    // wvtData.pwszURLReference =           // not used

    // Enable safer semantics:
    //   - if the subject isn't signed, return immediately without UI
    //   - ignore NO_CHECK revocation errors
    //   - always search the code hash and publisher databases, even when
    //     UI has been disabled in dwUIChoice.
    wvtData.dwProvFlags = WTD_SAFER_FLAG;

    //
    // Initialize the WinVerifyTrust file info data structure
    //
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));   // default all fields to 0
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = pwszFilename;
    // wvtFileInfo.hFile =              // allow WVT to open
    // wvtFileInfo.pgKnownSubject       // allow WVT to determine

    //
    // Call WinVerifyTrust
    //
    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                &wvtFileActionID,
                &wvtData
                );


    //
    // Process the WinVerifyTrust errors
    //

    switch (lStatus) {
        case ERROR_SUCCESS:
            // Signed file:
            //   - Hash representing the subject is trusted.
            //   - Trusted publisher without any verification errors.
            //   - UI was disabled in dwUIChoice. No publisher or timestamp
            //     chain errors.
            //   - UI was enabled in dwUIChoice and the user clicked "Yes"
            //     when asked to install and run the signed subject.
            break;

        case TRUST_E_NOSIGNATURE:
            // The file wasn't signed or had an invalid signature

            // Get the reason for no signature
            dwLastError = GetLastError();

            if (TRUST_E_NOSIGNATURE == dwLastError ||
                    TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError ||
                    TRUST_E_PROVIDER_UNKNOWN == dwLastError) {
                // The file wasn't signed
            } else {
                // Invalid signature or error opening the file
            }
            break;

        case TRUST_E_EXPLICIT_DISTRUST:
            // The hash representing the subject or the publisher is
            // disallowed by the admin or user
            break;

        case TRUST_E_SUBJECT_NOT_TRUSTED:
            // The user clicked "No" when asked to install and run
            break;

        case CRYPT_E_SECURITY_SETTINGS:
            // The hash representing the subject or the publisher wasn't
            // explicitly trusted by the admin and admin policy has
            // disabled user trust. No signature, publisher or timestamp
            // errors.
            break;

        default:
            // UI was disabled in dwUIChoice or admin policy has disabled
            // user trust.  lStatus contains the publisher or timestamp
            // chain error.
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstore5\tstore5.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore5.cpp
//
//  Contents:   Test certificate store collection and context link functions
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    06-Sep-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tstore5 [options] <StoreName1> <StoreName2>\n");
    printf("Options are:\n");
    printf("  -h                - This message\n");
    printf("  -C                - Collection tests (default)\n");
    printf("  -L                - Context Link tests\n");
    printf("  -C -L             - Context Links enumerated in Collection\n");
    printf("  -R                - Replace contexts that exist\n");
    printf("  -A                - Always add a new context\n");
    printf("  -P                - Set property\n");
    printf("  -v                - Verbose\n");
    printf("  -b                - Brief\n");
    printf("  -f<number>        - Open System Store Flags\n");
    printf("\n");
    printf("If <StoreName> has embedded \".\", File. Otherwise System Store\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;
    DWORD i;
    DWORD dwDisplayFlags = 0;
    DWORD dwOpenFlags = 0;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
    BOOL fVerbose = FALSE;
    BOOL fProperty = FALSE;

#define COLLECTION_TEST_FLAG    0x1
#define LINK_TEST_FLAG          0x2
    DWORD dwTestFlags = 0;

#define MAX_STORE_CNT       32
    DWORD dwStoreCnt = 0;
    LPCSTR rgpszStore[MAX_STORE_CNT];
    HCERTSTORE rghStore[MAX_STORE_CNT];
    memset(rghStore, 0, sizeof(rghStore));
    HCERTSTORE hCollectionStore = NULL;
    HCERTSTORE hLinkStore = NULL;

    PCCERT_CONTEXT pSiblingCert = NULL;
    PCCRL_CONTEXT pSiblingCrl = NULL;
    PCCTL_CONTEXT pSiblingCtl = NULL;

    PCCERT_CONTEXT pLinkCert = NULL;
    PCCRL_CONTEXT pLinkCrl = NULL;
    PCCTL_CONTEXT pLinkCtl = NULL;

    DWORD dwCertAddCnt = 0;
    DWORD dwCrlAddCnt = 0;
    DWORD dwCtlAddCnt = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {

            case 'C':
                dwTestFlags |= COLLECTION_TEST_FLAG;
                break;
            case 'L':
                dwTestFlags |= LINK_TEST_FLAG;
                break;
            case 'v':
                fVerbose = TRUE;
                dwDisplayFlags = DISPLAY_VERBOSE_FLAG;
                break;
            case 'b':
                dwDisplayFlags = DISPLAY_BRIEF_FLAG;
                break;
            case 'f':
                dwOpenFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'R':
                dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                break;
            case 'A':
                dwAddDisposition = CERT_STORE_ADD_ALWAYS;
                break;
            case 'P':
                fProperty = TRUE;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_STORE_CNT <= dwStoreCnt) {
                printf("Too many store names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszStore[dwStoreCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwStoreCnt) {
        printf("Missing store names\n");
        goto BadUsage;
    }

    // Attempt to open the store names
    for (i = 0; i < dwStoreCnt; i++) {
        DWORD dwFlags;
        BOOL fSystemStore;
        LPCSTR psz;
        char ch;

        // Check if store name has an embedded ".".
        fSystemStore = TRUE;
        psz = rgpszStore[i];
        while (ch = *psz++) {
            if ('.' == ch) {
                fSystemStore = FALSE;
                break;
            }
        }

        
        if (fSystemStore &&
                0 == (dwOpenFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
            dwFlags = dwOpenFlags | CERT_SYSTEM_STORE_CURRENT_USER;
        else
            dwFlags = dwOpenFlags;

        rghStore[i] = OpenSystemStoreOrFile(fSystemStore, rgpszStore[i],
            dwOpenFlags);
    }

    if (0 == dwTestFlags)
        dwTestFlags = COLLECTION_TEST_FLAG;

    if (dwTestFlags & COLLECTION_TEST_FLAG) {
        // Open collection store
        hCollectionStore = CertOpenStore(
            CERT_STORE_PROV_COLLECTION,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
        if (NULL == hCollectionStore) {
            PrintLastError("CertOpenStore(COLLECTION)");
            goto ErrorReturn;
        }
    }

    if (dwTestFlags & LINK_TEST_FLAG) {
        HCERTSTORE hParentStore;

        // Open memory store to hold the context links
        hLinkStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
        if (NULL == hLinkStore) {
            PrintLastError("CertOpenStore(MEMORY)");
            goto ErrorReturn;
        }

        if (dwTestFlags & COLLECTION_TEST_FLAG) {
            if (!CertAddStoreToCollection(
                    hCollectionStore,
                    hLinkStore,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                                       // dwPriority
                    )) {
                PrintLastError("CertAddStoreToCollection");
                goto ErrorReturn;
            }
            hParentStore = hCollectionStore;
        } else
            hParentStore = hLinkStore;

        // Loop through stores and add the certificate, CRL and CTL contexts
        // as links
        for (i = 0; i < dwStoreCnt; i++) {
            HCERTSTORE hStore;
            PCCERT_CONTEXT pCert;
            PCCRL_CONTEXT pCrl;
            PCCTL_CONTEXT pCtl;
            DWORD dwCrlFlags;

            if (NULL == (hStore = rghStore[i]))
                continue;

            pCert = NULL;
            while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                if (!CertAddCertificateLinkToStore(
                        hLinkStore,
                        pCert,
                        dwAddDisposition,
                        (0 == dwCertAddCnt) ? &pLinkCert : NULL
                        )) {
                    PrintLastError("CertAddCertificateLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCertAddCnt) {
                    if (NULL == pLinkCert) {
                        printf("failed => didn't return cert link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCert = CertDuplicateCertificateContext(pCert);
                }
                dwCertAddCnt++;

                if (CertAddCertificateLinkToStore(
                        hLinkStore,
                        pCert,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCert
                        ))
                    printf("failed => expected CertAddCertificateLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCertificateLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }

            dwCrlFlags = 0;
            pCrl = NULL;
            while (pCrl = CertGetCRLFromStore(hStore, NULL, pCrl,
                    &dwCrlFlags)) {
                if (!CertAddCRLLinkToStore(
                        hLinkStore,
                        pCrl,
                        dwAddDisposition,
                        (0 == dwCrlAddCnt) ? &pLinkCrl : NULL
                        )) {
                    PrintLastError("CertAddCRLLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCrlAddCnt) {
                    if (NULL == pLinkCrl) {
                        printf("failed => didn't return crl link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCrl = CertDuplicateCRLContext(pCrl);
                }
                dwCrlAddCnt++;

                if (CertAddCRLLinkToStore(
                        hLinkStore,
                        pCrl,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCrl
                        ))
                    printf("failed => expected CertAddCRLLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCRLLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }

            pCtl = NULL;
            while (pCtl = CertEnumCTLsInStore(hStore, pCtl)) {
                if (!CertAddCTLLinkToStore(
                        hLinkStore,
                        pCtl,
                        dwAddDisposition,
                        (0 == dwCtlAddCnt) ? &pLinkCtl : NULL
                        )) {
                    PrintLastError("CertAddCTLLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCtlAddCnt) {
                    if (NULL == pLinkCtl) {
                        printf("failed => didn't return crl link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCtl = CertDuplicateCTLContext(pCtl);
                }
                dwCtlAddCnt++;

                if (CertAddCTLLinkToStore(
                        hLinkStore,
                        pCtl,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCtl
                        ))
                    printf("failed => expected CertAddCTLLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCTLLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }
        }

        printf("Added %d Certificates\n", dwCertAddCnt);
        printf("Added %d CRLs\n", dwCrlAddCnt);
        printf("Added %d CTLs\n", dwCtlAddCnt);

        printf("\n");
        printf("$$$$$  Certificate Context Links  $$$$$\n");
        DisplayStore(hParentStore, dwDisplayFlags);

        if (fProperty) {
            CRYPT_DATA_BLOB LinkSetData;
            BYTE rgbLinkSet[4] = {0xDE, 0xAD, 0xBE, 0xEF};
            LinkSetData.pbData = rgbLinkSet;
            LinkSetData.cbData = sizeof(rgbLinkSet);
            CRYPT_DATA_BLOB SiblingSetData;
            BYTE rgbSiblingSet[4] = {0xDE, 0xAF, 0xCA, 0xFE};
            SiblingSetData.pbData = rgbSiblingSet;
            SiblingSetData.cbData = sizeof(rgbSiblingSet);
            BYTE rgbGet[4];
            DWORD cbData;

            if (pLinkCert) {
                printf("Setting Certificate Context Link Property\n");

                // First make sure the property is deleted
                CertSetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCertificateContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCertificateContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCertificateContextProperty(LINK)");
                else if (!CertGetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCertificateContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => cert sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCertificateContextProperty(SIBLING)");
                else if (!CertGetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCertificateContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => cert link not updated with sibling property\n");
            }

            if (pLinkCrl) {
                printf("Setting CRL Context Link Property\n");

                // First make sure the property is deleted
                CertSetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCRLContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCRLContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCRLContextProperty(LINK)");
                else if (!CertGetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCRLContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => CRL sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCRLContextProperty(SIBLING)");
                else if (!CertGetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCRLContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => CRL link not updated with sibling property\n");
            }

            if (pLinkCtl) {
                printf("Setting CTL Context Link Property\n");

                // First make sure the property is deleted
                CertSetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCTLContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCTLContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCTLContextProperty(LINK)");
                else if (!CertGetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCTLContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => CTL sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCTLContextProperty(SIBLING)");
                else if (!CertGetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCTLContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => CTL link not updated with sibling property\n");
            }
        }

        if (pLinkCert) {
            CertDeleteCertificateFromStore(pLinkCert);
            pLinkCert = NULL;
        }
        if (pLinkCrl) {
            CertDeleteCRLFromStore(pLinkCrl);
            pLinkCrl = NULL;
        }
        if (pLinkCtl) {
            CertDeleteCTLFromStore(pLinkCtl);
            pLinkCtl = NULL;
        }
    } else {
        PCCERT_CONTEXT pCert;

        for (i = 0; i < dwStoreCnt; i++) {
            if (NULL == rghStore[i])
                continue;
            if (!CertAddStoreToCollection(
                    hCollectionStore,
                    rghStore[i],
                    0,                      // dwUpdateFlags
                    i                       // dwPriority
                    )) {
                PrintLastError("CertAddStoreToCollection");
                goto ErrorReturn;
            }
        }
        printf("\n");
        printf("$$$$$  Collection Stores  $$$$$\n");
        DisplayStore(hCollectionStore, dwDisplayFlags);


        // Get first cert and duplicate. It should be in last store.
        // Remove the last store and the second to last store. Continue
        // the enumeration. 
        if (pCert = CertEnumCertificatesInStore(hCollectionStore, NULL)) {
            pLinkCert = CertDuplicateCertificateContext(pCert);
            if (0 < dwStoreCnt && rghStore[dwStoreCnt - 1]) {
                CertRemoveStoreFromCollection(
                    hCollectionStore,
                    rghStore[dwStoreCnt - 1]
                    );
                // Also close the last store
                CertCloseStore(rghStore[dwStoreCnt - 1], 0);
                rghStore[dwStoreCnt - 1] = NULL;
            }
            if (1 < dwStoreCnt && rghStore[dwStoreCnt - 2])
                CertRemoveStoreFromCollection(
                    hCollectionStore,
                    rghStore[dwStoreCnt - 2]
                    );

            printf("$$$$$  Collection Certificates after removing last 2 stores  $$$$$\n");
            i = 0;
            while (pCert = CertEnumCertificatesInStore(hCollectionStore,
                    pCert)) {
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
                i++;
            }
        }
    }

    status = 0;

CommonReturn:
    if (pSiblingCert)
        CertFreeCertificateContext(pSiblingCert);
    if (pLinkCert)
        CertFreeCertificateContext(pLinkCert);
    if (pLinkCrl)
        CertFreeCRLContext(pLinkCrl);
    if (pSiblingCrl)
        CertFreeCRLContext(pSiblingCrl);
    if (pLinkCtl)
        CertFreeCTLContext(pLinkCtl);
    if (pSiblingCtl)
        CertFreeCTLContext(pSiblingCtl);

    for (i = 1; i < dwStoreCnt; i++) {
        if (rghStore[i])
            CertCloseStore(rghStore[i], 0);
    }

    if (hCollectionStore) {
        if (!CertCloseStore(hCollectionStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(COLLECTION)");
    }
    if (hLinkStore) {
        if (!CertCloseStore(hLinkStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(LINK)");
    }

    if (0 < dwStoreCnt) {
        if (rghStore[0]) {
            if (!CertCloseStore(rghStore[0], CERT_CLOSE_STORE_CHECK_FLAG))
                PrintLastError("CertCloseStore(SIBLING[0])");
        }
    }

    return status;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

ErrorReturn:
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tstore3\tstore3.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore3.cpp
//
//  Contents:   Cert Store API Tests: 
//               - CertGetSubjectCertificateFromStore: serial numbers with
//                  leading 0's or 0xFF's
//               - Open two system stores. Ensure certs and CRLs are
//                   written through
//               - CertStoreSave: test SaveToMemory for serialized and PKCS7
//               - Call CertOpenSystemStoreW
//               - Get hash property for a created context
//               - Do a CertVerifySubjectCertificateContext for a
//                   certificate in a store and a certificate context.
//                   Should pass for both a store certificate and 
//                   a certificate context. The certificate context
//                   uses the default hCryptProv.
//               - Close a store with a not freed certificate context.
//                   Should get a warning at closing. 
//               - Delete and recalculate the hash property for a
//                   certificate context after the store has been closed.
//               - Delete the certificate context after the store has
//                   been closed
//               - Duplicate a certificate. Delete it from the store.
//                   Also delete its duplicate. Close the store.
//               - Check that CertCloseStore preserves last error
//               - Win95 test (Win95 has following registry limitations:
//                  Max single key value of 16K, max total value length
//                  per key of 64K)
//  
//                  - Write 8 certificates > 10k to same system store
//                  - Write same certificate to two system stores
//                  - Set large property > 16K to force certificates to
//                    be saved to a file.
//                  - Verify written properties.
//                  - Delete large property. File should be deleted and
//                    certificate stored in registry.
//                  - Rewrite large property. Delete certificate.
//               - Check CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
//
//  Functions:  main
//
//  History:    11-Jan-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SIGNATURE_ALG_OBJID     szOID_RSA_MD5RSA
#define TEST_ISSUER_NAME        "TestIssuer"
static HCRYPTPROV hCryptProv = 0;

static void PrintExpectedError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s got expected error => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

static BOOL EncodeIssuer(
    OUT BYTE **ppbIssuerEncoded,
    OUT DWORD *pcbIssuerEncoded
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    CERT_RDN_ATTR rgAttr[1];
    CERT_RDN rgRDN[1];
    CERT_NAME_INFO Name;

    Name.cRDN = 1;
    Name.rgRDN = rgRDN;
    rgRDN[0].cRDNAttr = 1;
    rgRDN[0].rgRDNAttr = rgAttr;

    rgAttr[0].pszObjId = szOID_COMMON_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) TEST_ISSUER_NAME;
    rgAttr[0].Value.cbData = strlen(TEST_ISSUER_NAME);

    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            );
    if (cbIssuerEncoded == 0) {
        PrintLastError("EncodeIssuer::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbIssuerEncoded = (BYTE *) TestAlloc(cbIssuerEncoded);
    if (pbIssuerEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbIssuerEncoded,
            &cbIssuerEncoded
            )) {
        PrintLastError("EncodeIssuer::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppbIssuerEncoded = pbIssuerEncoded;
    *pcbIssuerEncoded = cbIssuerEncoded;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pbIssuerEncoded) {
        TestFree(pbIssuerEncoded);
        pbIssuerEncoded = 0;
    }
    cbIssuerEncoded = 0;
    goto CommonReturn;
}

static BOOL GetPublicKey(
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo)
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD dwKeySpec;

    dwKeySpec = AT_SIGNATURE;
    CryptExportPublicKeyInfo(
        hCryptProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbPubKeyInfo);
    if (pPubKeyInfo == NULL) goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        TestFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
    goto CommonReturn;
}

static BOOL EncodeCert(
    IN PCRYPT_INTEGER_BLOB pSerialNumber,
    OUT BYTE **ppbCertEncoded,
    OUT DWORD *pcbCertEncoded
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    CERT_INFO Cert;
    
    if (!EncodeIssuer(&pbIssuerEncoded, &cbIssuerEncoded)) goto ErrorReturn;

    // PUBLIC KEY
    if (!GetPublicKey(&pPubKeyInfo)) goto ErrorReturn;

    // CERT
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    Cert.SerialNumber = *pSerialNumber;
    Cert.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime;
        GetSystemTime(&SystemTime);

        SystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
        SystemTime.wYear++;
        if (!SystemTimeToFileTime(&SystemTime, &Cert.NotAfter)) {
	    SystemTime.wDay = 1;	
            SystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        } 
    }

    Cert.Subject.pbData = pbIssuerEncoded;
    Cert.Subject.cbData = cbIssuerEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKeyInfo;

    CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            NULL,                       // pbEncoded
            &cbCertEncoded
            );
    if (cbCertEncoded == 0) {
        PrintLastError("CryptSignAndEncodeCertificate(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) TestAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError("CryptSignAndEncodeCertificate");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    *ppbCertEncoded = pbCertEncoded;
    *pcbCertEncoded = cbCertEncoded;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pbCertEncoded) {
        TestFree(pbCertEncoded);
        pbCertEncoded = 0;
    }
    cbCertEncoded = 0;
    goto CommonReturn;
}

static PCCERT_CONTEXT GetSubject(
    IN HCERTSTORE hStore,
    IN PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    BOOL fResult = TRUE;
    PCCERT_CONTEXT pCert;
    CERT_INFO CertInfo;

    memset(&CertInfo, 0, sizeof(CertInfo));
    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        return NULL;

    CertInfo.SerialNumber = *pSerialNumber;
    pCert = CertGetSubjectCertificateFromStore(hStore, dwCertEncodingType,
        &CertInfo);
    if (NULL == pCert)
        PrintLastError("GetSubject");
    TestFree(CertInfo.Issuer.pbData);
    return pCert;
}

static BOOL TestGetSubject(
    IN LPSTR pszMsg,
    IN HCERTSTORE hStore,
    IN DWORD cSerialNumber,
    IN CRYPT_INTEGER_BLOB rgSerialNumber[],
    IN BOOL rgfExpectedGet[]
    )
{
    BOOL fResult = TRUE;
    DWORD i;
    CERT_INFO CertInfo;
    memset(&CertInfo, 0, sizeof(CertInfo));

    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        return FALSE;

    for (i = 0; i < cSerialNumber; i++) {
        PCCERT_CONTEXT pCert;

        CertInfo.SerialNumber = rgSerialNumber[i];
        pCert = CertGetSubjectCertificateFromStore(hStore, dwCertEncodingType,
            &CertInfo);
        if (pCert) {
            if (!rgfExpectedGet[i]) {
                fResult = FALSE;
                printf("%s SerialNumber[%d] failed => expected error\n",
                    pszMsg, i);
            }
            CertFreeCertificateContext(pCert);
        } else if (rgfExpectedGet[i]) {
            DWORD dwErr = GetLastError();
            fResult = FALSE;
            printf("%s SerialNumber[%d] failed => 0x%x (%d) \n", pszMsg, i,
                dwErr, dwErr);
        }
        
    }
    TestFree(CertInfo.Issuer.pbData);
    return fResult;
}

static DWORD WINAPI VerifyCertSignThreadProc(
    LPVOID lpThreadParameter
    )
{
    PCCERT_CONTEXT pCert0 = (PCCERT_CONTEXT) lpThreadParameter;
    DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;

    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(Thread, SIGNATURE)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(Thread, SIGNATURE) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    return 0;
}

static BOOL DoTest()
{
    BOOL fResult;
    DWORD dwErr;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    CERT_INFO CertInfo;
    memset(&CertInfo, 0, sizeof(CertInfo));
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pCert0 = NULL;
    PCCERT_CONTEXT pCertDup = NULL;

    HCERTSTORE hStore1 = NULL;
    HCERTSTORE hStore2 = NULL;
    HCERTSTORE hStore3 = NULL;

    CRYPT_DATA_BLOB SerializeStore;
    memset(&SerializeStore, 0, sizeof(SerializeStore));
    HCERTSTORE hSerializeStore = NULL;

    CRYPT_DATA_BLOB PKCS7Store;
    memset(&PKCS7Store, 0, sizeof(PKCS7Store));
    HCERTSTORE hPKCS7Store = NULL;
    DWORD i;
    DWORD dwFlags;

    CRYPT_DATA_BLOB SmallStore;
#define DELTA_LESS_LENGTH    8

    BYTE rgbSerial0[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    BYTE rgbSerial1[] = {0x81, 0x82, 0x83};
    BYTE rgbSerial2[] = {0x00, 0x00, 0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    BYTE rgbSerial3[] = {0xFF, 0xFF, 0xFF, 0x81, 0x82, 0x83};
    BYTE rgbSerial4[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0x00, 0x00};
    BYTE rgbSerial5[] = {0x81, 0x82, 0x83, 0xFF, 0xFF, 0xFF};
    BYTE rgbSerial6[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0xFF};
    BYTE rgbSerial7[] = {0x81, 0x82, 0x83, 0x00};

    CRYPT_INTEGER_BLOB rgSerialNumber[] = {
        sizeof(rgbSerial0), rgbSerial0,
        sizeof(rgbSerial1), rgbSerial1,
        sizeof(rgbSerial2), rgbSerial2,
        sizeof(rgbSerial3), rgbSerial3,
        sizeof(rgbSerial4), rgbSerial4,
        sizeof(rgbSerial5), rgbSerial5,
        sizeof(rgbSerial6), rgbSerial6,
        sizeof(rgbSerial7), rgbSerial7,
    };

    BOOL rgfExpectedGet[] = {
        TRUE,
        TRUE,
        FALSE,
        FALSE,
        TRUE,
        TRUE,
        FALSE,
        FALSE
    };

    BOOL rgfDeleteExpectedGet[] = {
        TRUE,
        FALSE
    };

    BYTE rgbAux0[] = {0x00};
    BYTE rgbAux1[] = {0x11, 0x11};
    BYTE rgbAux2[] = {0x22, 0x22, 0x22};
    BYTE rgbAux[8];
    CRYPT_DATA_BLOB AuxData;

    BYTE rgbStoreHash[MAX_HASH_LEN];
    DWORD cbStoreHash;
    BYTE rgbStoreHash2[MAX_HASH_LEN];
    DWORD cbStoreHash2;
    BYTE rgbContextHash[MAX_HASH_LEN];
    DWORD cbContextHash;

    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        goto ErrorReturn;

    if (NULL == (hStore1 = CertOpenSystemStoreW(hCryptProv, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW(Test)");
        goto ErrorReturn;
    }

    // Delete all certs in the store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore1, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
        CertDeleteCertificateFromStore(pDeleteCert);
    }

    // Add two certs to the store
    for (i = 0; i < 2; i++) {
        if (!EncodeCert(&rgSerialNumber[i], &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;
        if (!CertAddEncodedCertificateToStore(
                hStore1,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                NULL)) {                // ppCertContext
            PrintLastError("CertAddEncodedCertificateToStore");
            goto ErrorReturn;
        }
        if (0 == i) {
            // Create certificate context for future use
            if (NULL == (pCert0 = CertCreateCertificateContext(
                    dwCertEncodingType,
                    pbCertEncoded,
                    cbCertEncoded))) {
                PrintLastError("CertCreateCertificateContext");
                goto ErrorReturn;
            }
        }
        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

    TestGetSubject(
        "Store1",
        hStore1,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // All the certificates should have been pushed through to the
    // registry
    if (NULL == (hStore2 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "Store2",
        hStore2,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    CertInfo.SerialNumber = rgSerialNumber[4];
    // Update different properties on the same certificate via different
    // stores
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore1, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }

    AuxData.pbData = rgbAux0;
    AuxData.cbData = sizeof(rgbAux0);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 0,
            0,                          // dwFlags
            &AuxData
            )) {
        PrintLastError("CertSetCertificateContextProperty");
        goto ErrorReturn;
    }
    CertFreeCertificateContext(pCert);
    pCert = NULL;

    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore2, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }

    AuxData.pbData = rgbAux1;
    AuxData.cbData = sizeof(rgbAux1);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 1,
            0,                          // dwFlags
            &AuxData
            )) {
        PrintLastError("CertSetCertificateContextProperty");
        goto ErrorReturn;
    }
    CertFreeCertificateContext(pCert);
    pCert = NULL;

    // Reopen store. The properties should have been pushed through
    // to the registry.
    if (NULL == (hStore3 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }

    TestGetSubject(
        "Store3",
        hStore3,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Test Store Certificates Before Delete ######\n");
    while (pCert = CertEnumCertificatesInStore(hStore3, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
        i++;
    }

    // Save certificates to in memory serialized store and in memory
    // PKCS #7 store
    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }
    if (NULL == (SerializeStore.pbData = (BYTE *) TestAlloc(
            SerializeStore.cbData)))
        goto ErrorReturn;
    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }

    // The following should fail with ERROR_MORE_DATA
    SmallStore = SerializeStore;
    SmallStore.cbData -= DELTA_LESS_LENGTH;
    if (CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SmallStore,
            0))                         // dwFlags
        PrintNoError("CertSaveStore(CERT_STORE_SAVE_AS_STORE, insufficient length)");
    else {
        DWORD dwErr = GetLastError();
        PrintExpectedError("CertSaveStore(CERT_STORE_SAVE_AS_STORE, insufficient length)");
        if (ERROR_MORE_DATA != dwErr) {
            printf("CertSaveStore(CERT_STORE_SAVE_AS_STORE) failed => ");
            printf("LastError = %d, expected = %d\n", dwErr, ERROR_MORE_DATA);
        }
    }
        
    if (SmallStore.cbData != SerializeStore.cbData) {
        printf("CertSaveStore(CERT_STORE_SAVE_AS_STORE) failed => ");
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, SerializeStore.cbData);
    } else {
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, SerializeStore.cbData);
    }
    

    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }

    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }
    if (NULL == (PKCS7Store.pbData = (BYTE *) TestAlloc(
            PKCS7Store.cbData)))
        goto ErrorReturn;
    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }

    // The following should fail with ERROR_MORE_DATA
    SmallStore = PKCS7Store;
    SmallStore.cbData -= DELTA_LESS_LENGTH;
    if (CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &SmallStore,
            0))
        PrintNoError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7, insufficient length)");
    else {
        DWORD dwErr = GetLastError();
        PrintExpectedError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7, insufficient length)");
        if (ERROR_MORE_DATA != dwErr) {
            printf("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7) failed => ");
            printf("LastError = %d, expected = %d\n", dwErr, ERROR_MORE_DATA);
        }
    }

    if (SmallStore.cbData != PKCS7Store.cbData) {
        printf("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7) failed => ");
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, PKCS7Store.cbData);
    } else {
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, PKCS7Store.cbData);
    }

    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }
    CertCloseStore(hStore3, 0);
    hStore3 = NULL;

    // Open in memory serialized store.
    if (NULL == (hSerializeStore = CertOpenStore(
            CERT_STORE_PROV_SERIALIZED,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) &SerializeStore))) {
        PrintLastError("CertOpenStore(SERIALIZED)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "SerializeStore",
        hSerializeStore,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Serialized Store Certificates ######\n");
    while (pCert = CertEnumCertificatesInStore(hSerializeStore, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Open in memory PKCS7 store.
    if (NULL == (hPKCS7Store = CertOpenStore(
            CERT_STORE_PROV_PKCS7,
            dwCertEncodingType | dwMsgEncodingType,
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) &PKCS7Store))) {
        PrintLastError("CertOpenStore(SERIALIZED)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "PKCS7Store",
        hPKCS7Store,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### PKCS7 Store Certificates ######\n");
    while (pCert = CertEnumCertificatesInStore(hPKCS7Store, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Delete the certificate in one store and update its property
    // in the other store. Should get an error.
    CertInfo.SerialNumber = rgSerialNumber[1];
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore1, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }
    if (!CertDeleteCertificateFromStore(pCert)) {
        PrintLastError("CertDeleteCertificateFromStore");
        goto ErrorReturn;
    }

    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore2, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }
    AuxData.pbData = rgbAux2;
    AuxData.cbData = sizeof(rgbAux2);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 2,
            0,                          // dwFlags
            &AuxData
            ))
        PrintExpectedError("CertSetCertificateContextProperty(deleted in other store)");
    else
        PrintNoError("CertSetCertificateContextProperty(deleted in other store)");
    CertFreeCertificateContext(pCert);
    pCert = NULL;


    // Reopen store. The certificate delete should have pushed through
    // to the registry.
    if (NULL == (hStore3 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }

    TestGetSubject(
        "After Delete Store3",
        hStore3,
        sizeof(rgfDeleteExpectedGet)/sizeof(rgfDeleteExpectedGet[0]),
        rgSerialNumber,
        rgfDeleteExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Test Store Certificates After Delete ######\n");
    while (pCert = CertEnumCertificatesInStore(hStore3, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Check that we can get the hash property for a created context.
    // Compare with the hash of the same certificate in a store.
    CertInfo.SerialNumber = rgSerialNumber[0];
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hSerializeStore, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore(SerializeStore)");
        goto ErrorReturn;
    }
    cbStoreHash = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert, CERT_SHA1_HASH_PROP_ID,
            rgbStoreHash, &cbStoreHash)) {
        PrintLastError("CertGetCertificateContextProperty(SerializeStore)");
        goto ErrorReturn;
    }

    cbContextHash = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert0, CERT_SHA1_HASH_PROP_ID,
            rgbContextHash, &cbContextHash))
        PrintLastError("CertGetCertificateContextProperty(created context)");
    else if (cbContextHash != cbStoreHash ||
        0 != memcmp(rgbContextHash, rgbStoreHash, cbContextHash)) {
        printf("CertGetCertificateContextProperty(created context) failed => ");
        printf("hash didn't compare with store's hash\n");
    }


    // Do a CertVerifySubjectCertificateContext for a
    // certificate in a store and a certificate context.
    // Should pass for both a store certificate and 
    // a certificate context. The certificate context
    // uses the default provider.
    dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert, pCert, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(in store)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(in store) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    dwFlags = CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(context, TIME_VALIDITY)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(context, TIME_VALIDITY) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(context, SIGNATURE)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(context, SIGNATURE) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }


    {
        // Install DefaultContext applicable to all threads in process.
        // Create another thread that does the verify. For testing purposes,
        // will modify the CryptVerifyCertificateSignature to sleep while
        // holding a refCount on the DefaultContext. Will do an Uninstall
        // that should cause us to wait until the Verify returns.

        HCRYPTPROV hProv = 0;

        if (!CryptAcquireContext(
                &hProv,
                NULL,               // pszContainer
                NULL,               // pszProvider,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            PrintLastError(
                "CryptAcquireContext(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)");
        } else {
            HCRYPTDEFAULTCONTEXT hDefaultContext;

            if (!CryptInstallDefaultContext(
                    hProv,
                    CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                    (const void *) szOID_RSA_MD5RSA,
                    CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG,
                    NULL,                           // pvReserved
                    &hDefaultContext
                    )) {
                PrintLastError("CryptInstallDefaultContext");
            } else {
                HANDLE hThread;
                DWORD dwThreadId;

                if (NULL == (hThread = CreateThread(
                        NULL,           // lpThreadAttributes
                        0,              // dwStackSize
                        VerifyCertSignThreadProc,
                        (void *) pCert0,
                        0,              // dwCreationFlags
                        &dwThreadId
                        )))
                    PrintLastError("CreateThread");
                else
                    CloseHandle(hThread);

                Sleep(500);
                if (!CryptUninstallDefaultContext(
                        hDefaultContext,
                        0,                  // dwFlags
                        NULL                // pvReserved
                        ))
                    PrintLastError("CryptUninstallDefaultContext");
            }
            CryptReleaseContext(hProv, 0);
        }
    }

    // Close a store with a not freed certificate context. Should get a warning
    // at closing. 
    fResult = CertCloseStore(hSerializeStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hSerializeStore = NULL;
    if (fResult)
        PrintNoError("CertCloseStore(with not freed certificate)");
    else
        PrintExpectedError("CertCloseStore(with not freed certificate)");

    // Delete and recalculate the hash property for a certificate context
    // after the store has been closed.
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            0,                          // dwFlags
            NULL                        // pvData
            ))
        PrintLastError("CertSetCertificateContextProperty(SHA1, delete after close store)");
    cbStoreHash2 = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert, CERT_SHA1_HASH_PROP_ID,
            rgbStoreHash2, &cbStoreHash2))
        PrintLastError("CertGetCertificateContextProperty(SHA1, after close store)");
    else if (cbStoreHash2 != cbStoreHash ||
        0 != memcmp(rgbStoreHash2, rgbStoreHash, cbStoreHash2)) {
        printf("CertGetCertificateContextProperty(SHA1, after close store) failed => ");
        printf("hash didn't compare with store's hash\n");
    }

    // Delete the certificate context after the store has been closed
    if (!CertDeleteCertificateFromStore(pCert))
        PrintLastError("CertDeleteCertificateFromStore(after close store)");
    pCert = NULL;

    // Duplicate a certificate. Delete it from the store. Also delete its
    // duplicate. Close the store.
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hPKCS7Store, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore(PKCS7)");
        goto ErrorReturn;
    }
    pCertDup = CertDuplicateCertificateContext(pCert);
    if (!CertDeleteCertificateFromStore(pCert))
        PrintLastError("CertDeleteCertificateFromStore(PKCS7)");
    pCert = NULL;
    if (!CertDeleteCertificateFromStore(pCertDup))
        PrintLastError("CertDeleteCertificateFromStore(PKCS7, duplicated cert)");
    pCertDup = NULL;

    // Also check that last error is preserved for no errors
#define EXPECTED_LAST_ERROR     0x11223344
    SetLastError(EXPECTED_LAST_ERROR);
    fResult = CertCloseStore(hPKCS7Store, CERT_CLOSE_STORE_CHECK_FLAG);
    hPKCS7Store = NULL;
    if (!fResult)
        PrintError("CertCloseStore(PKCS7, after two deletes)");
    else if (EXPECTED_LAST_ERROR != (dwErr = GetLastError())) {
        printf("CertCloseStore failed => globbered last error.");
        printf(" Expected 0x%x (%d), got 0x%x (%d)\n",
            EXPECTED_LAST_ERROR, EXPECTED_LAST_ERROR, dwErr, dwErr);
    }
    

    fResult = TRUE;
CommonReturn:
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (CertInfo.Issuer.pbData)
        TestFree(CertInfo.Issuer.pbData);
    if (SerializeStore.pbData)
        TestFree(SerializeStore.pbData);
    if (PKCS7Store.pbData)
        TestFree(PKCS7Store.pbData);

    if (hStore1)
        CertCloseStore(hStore1, 0);
    if (hStore2)
        CertCloseStore(hStore2, 0);
    if (hStore3)
        CertCloseStore(hStore3, 0);
    if (hSerializeStore)
        CertCloseStore(hSerializeStore, 0);
    if (hPKCS7Store)
        CertCloseStore(hPKCS7Store, 0);

    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCert0)
        CertFreeCertificateContext(pCert0);
    if (pCertDup)
        CertFreeCertificateContext(pCertDup);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DoWin95Test()
{

#define WIN95_ADD_CERT_CNT  8
#define WIN95_ADD_CB_PROP   10000

#define WIN95_STORE_CNT     2
    LPWSTR rgpwszStore[WIN95_STORE_CNT] = {
        L"Test0",
        L"Test1"
    };

#define WIN95_PROP_CNT      5
    DWORD rgcbProp[WIN95_PROP_CNT][WIN95_STORE_CNT] = {
        100,        200,            // 0
        0x5000,     0x6000,         // 1
        0x1000,     0x6300,         // 2
        0x30,       0x300,          // 3
        0x4300,     0x4200          // 4
    };
        
    DWORD dwSerialNumber;
    CRYPT_INTEGER_BLOB SerialNumber = {
        sizeof(dwSerialNumber), (BYTE *) &dwSerialNumber
    };

    BOOL fResult;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hStore = NULL;
    CRYPT_DATA_BLOB Prop;
    BYTE *pbProp = NULL;
    DWORD cbProp;
    DWORD cb;
    DWORD i, j, k;
    DWORD cAdd;

    if (NULL == (hStore = CertOpenSystemStoreW(NULL, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW");
        goto ErrorReturn;
    }
    // Delete all certs in the store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
        CertDeleteCertificateFromStore(pDeleteCert);
    }

    if (NULL == (pbProp = (BYTE *) TestAlloc(
            WIN95_ADD_CB_PROP + WIN95_ADD_CERT_CNT)))
        goto ErrorReturn;
    // Add certs each having a property of 10,000 + cAdd bytes in length
    for (cAdd = 0; cAdd < WIN95_ADD_CERT_CNT; cAdd++) {
        dwSerialNumber = cAdd;

        if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;

        // Add encoded certificate to store.
        fResult = CertAddEncodedCertificateToStore(
                hStore,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                &pCert);
        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
        if (!fResult) {
            printf("AddEncodedCertificate[%d]", cAdd);
            PrintLastError("");
            break;
        }

        Prop.pbData = pbProp;
        Prop.cbData = WIN95_ADD_CB_PROP + cAdd;
        for (k = 0; k < WIN95_ADD_CB_PROP + cAdd; k++)
            pbProp[k] = (BYTE) cAdd;
        fResult = CertSetCertificateContextProperty(
                pCert,
                CERT_FIRST_USER_PROP_ID,
                0,                          // dwFlags
                &Prop
                );
        CertFreeCertificateContext(pCert);
        pCert = NULL;

        if (!fResult) {
            printf("SetProperty for AddedCertificate[%d]", cAdd);
            PrintLastError("");
            break;
        }
    }

    CertCloseStore(hStore, 0);
    hStore = NULL;

    // Verify that we can successfully read the added certs.
    if (NULL == (hStore = CertOpenSystemStoreW(NULL, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW");
        goto ErrorReturn;
    }
    while (cAdd--) {
        dwSerialNumber = cAdd;
        pCert = GetSubject(hStore, &SerialNumber);
        if (NULL == pCert) {
            printf("GetAddedCertificate[%d]\n", cAdd);
            PrintLastError("");
        } else {
            cbProp = WIN95_ADD_CB_PROP + WIN95_ADD_CERT_CNT;
            
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    pbProp,
                    &cbProp)) {
                printf("GetProperty for AddedCertificate[%d]", cAdd);
                PrintLastError("");
            } else if (cbProp != WIN95_ADD_CB_PROP + cAdd) {
                printf("GetProperty for AddedCertificate[%d] failed => ", cAdd);
                printf("cbProp = %d, not expected = %d\n",
                    cbProp, WIN95_ADD_CB_PROP + cAdd);
            } else {
                for (k = 0; k < cbProp; k++) {
                    if (pbProp[k] != (BYTE) cAdd) {
                        printf("GetProperty for AddedCertificate[%d] failed => ", cAdd);
                        printf("not expected value\n");
                        break;
                    }
                }
            }
            CertFreeCertificateContext(pCert);
            pCert = NULL;
        }
    }

    CertCloseStore(hStore, 0);
    hStore = NULL;
    TestFree(pbProp);
    pbProp = NULL;

    dwSerialNumber = 0x12345678;
    if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
        goto ErrorReturn;

    for (j = 0; j < WIN95_STORE_CNT; j++) {
        if (NULL == (hStore = CertOpenSystemStoreW(
                NULL, rgpwszStore[j]))) {
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertOpenSystemStoreW");
            goto ErrorReturn;
        }

        // Delete all certs in the store
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
            CertDeleteCertificateFromStore(pDeleteCert);
        }

        // Add encoded certificate to store.
        if (!CertAddEncodedCertificateToStore(
                hStore,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                &pCert)) {                // ppCertContext
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertAddEncodedCertificateToStore");
            goto ErrorReturn;
        }

        cb = rgcbProp[0][j];
        if (NULL == (pbProp = (BYTE *) TestAlloc(cb)))
            goto ErrorReturn;
        Prop.pbData = pbProp;
        Prop.cbData = cb;
        for (k = 0; k < cb; k++)
            pbProp[k] = (BYTE) (j + 1);
        if (!CertSetCertificateContextProperty(
                pCert,
                CERT_FIRST_USER_PROP_ID,
                0,                          // dwFlags
                &Prop
                )) {
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertSetCertificateContextProperty");
            goto ErrorReturn;
        }

        TestFree(pbProp);
        pbProp = NULL;
        CertFreeCertificateContext(pCert);
        pCert = NULL;
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

    TestFree(pbCertEncoded);
    pbCertEncoded = NULL;

    // Loop and read previous property. compare. write new property.
    for (i = 1; i < WIN95_PROP_CNT; i++) {
        for (j = 0; j < WIN95_STORE_CNT; j++) {

            if (NULL == (hStore = CertOpenSystemStoreW(
                    NULL, rgpwszStore[j]))) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertOpenSystemStoreW");
                goto ErrorReturn;
            }

            pCert = GetSubject(hStore, &SerialNumber);
            if (NULL == pCert) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("GetSubject");
                goto ErrorReturn;
            }

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    NULL,                       // pbProp
                    &cbProp)) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertGetCertificateContextProperty");
                goto ErrorReturn;
            }

            cb = rgcbProp[i-1][j];
            if (cbProp != cb) {
                printf("Prop[%d] Store[%d] ", i, j);
                printf("GetProperty failed => ");
                printf("cbProp = %d, not expected = %d\n", cbProp, cb);
                goto ErrorReturn;
            }

            if (NULL == (pbProp = (BYTE *) TestAlloc(cbProp)))
                goto ErrorReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    pbProp,
                    &cbProp)) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertGetCertificateContextProperty");
                goto ErrorReturn;
            }
            for (k = 0; k < cbProp; k++) {
                if (pbProp[k] != (BYTE) (j + 1)) {
                    printf("Prop[%d] Store[%d] ", i, j);
                    printf("GetProperty failed => ");
                    printf("not expected value\n");
                    goto ErrorReturn;
                }
            }

            TestFree(pbProp);
            pbProp = NULL;

            cb = rgcbProp[i][j];
            if (NULL == (pbProp = (BYTE *) TestAlloc(cb)))
                goto ErrorReturn;
            Prop.pbData = pbProp;
            Prop.cbData = cb;
            for (k = 0; k < cb; k++)
                pbProp[k] = (BYTE) (j + 1);
            if (!CertSetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    0,                          // dwFlags
                    &Prop
                    )) {
                printf("Prop[%d] Store[%d] cb=%d ", i, j, cb);
                PrintLastError("CertSetCertificateContextProperty");
                goto ErrorReturn;
            }

            TestFree(pbProp);
            pbProp = NULL;
            CertFreeCertificateContext(pCert);
            pCert = NULL;
            CertCloseStore(hStore, 0);
            hStore = NULL;
        }
    }
    

    fResult = TRUE;
CommonReturn:
    TestFree(pbProp);
    TestFree(pbCertEncoded);
    if (hStore)
        CertCloseStore(hStore, 0);
    if (pCert)
        CertFreeCertificateContext(pCert);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DoDeferCloseTest() 
{
    BOOL fResult;

    BYTE rgbSerial[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    CRYPT_INTEGER_BLOB SerialNumber = {
        sizeof(rgbSerial), rgbSerial
    };

    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;


    // ---------------------------------------------------------------------
    // Do defer close with no duplicated contexts
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            NULL)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        printf("Defer close with no duplicated contexts\n");
    else
        PrintLastError("CertCloseStore(DEFER, no duplicated contexts");

    // ---------------------------------------------------------------------
    // Do defer close with duplicated contexts
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            &pCert)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        PrintExpectedError("CertCloseStore(DEFER, with duplicated certificate)");
    else
        printf("Defer close with duplicated contexts\n");

    CertFreeCertificateContext(pCert);
    pCert = NULL;

    // ---------------------------------------------------------------------
    // Do context delete after a defer close
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            &pCert)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        PrintExpectedError("CertCloseStore(DEFER, with duplicated certificate)");
    else
        printf("Defer close with context to be deleted after\n");

    CertDeleteCertificateFromStore(pCert);
    pCert = NULL;

    fResult = TRUE;
CommonReturn:
    TestFree(pbCertEncoded);
    if (hStore)
        CertCloseStore(hStore, 0);
    if (pCert)
        CertFreeCertificateContext(pCert);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


int _cdecl main(int argc, char * argv[]) 
{
    printf("command line: %s\n", GetCommandLine());

    hCryptProv = GetCryptProv();
    if (hCryptProv == 0)
        return -1;

    DoTest();
    DoWin95Test();
    DoDeferCloseTest();

    CryptReleaseContext(hCryptProv, 0);
    printf("Done.\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\turlread\turlread.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       turlread.cpp
//
//  Contents:   Read the specified URL using the wininet APIs
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    26-Feb-96   philh   created
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <wininet.h>

#ifndef MAX_CACHE_ENTRY_INFO_SIZE
#   include <winineti.h>
#endif

#include <sensapi.h>

#include "wincrypt.h"
#include "crypthlp.h"
#include "cryptnet.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <time.h>

// Fix for SP4, where ICU_BROWSER_MODE isn't defined
#ifndef ICU_BROWSER_MODE
#define ICU_BROWSER_MODE ICU_ENCODE_SPACES_ONLY
#endif

static void Usage(void)
{
    printf("Usage: turlread [options] <URL>\n");
    printf("Options are:\n");
    printf("  -d                    - Delete cached URL\n");
    printf("  -i                    - Get cached URL information\n");
    printf("  -o                    - Offline only\n");
    printf("  -w                    - Wire only\n");
    printf("  -cBrowser             - Canonicalize => Browser (default)\n");
    printf("  -cNone                - Canonicalize => None\n");
    printf("  -cSpaces              - Canonicalize => Spaces\n");
    printf("  -cAll                 - Canonicalize => All\n");
    printf("  -U                    - Unicode\n");
    printf("  -s                    - Get internet state\n");
    printf("  -n                    - Get host Name from URL\n");
    printf("  -S<number>            - SyncTime delta seconds\n");
    printf("  -h                    - This message\n");
    printf("\n");
}

static void DisplayCacheEntryInfoA(
    LPSTR pszUrl
    )
{
    BOOL fResult;

    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOA pCacheEntryInfo =
        (LPINTERNET_CACHE_ENTRY_INFOA) &rgbCachEntryInfo[0];

    DWORD dwEntryType;

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
    fResult = GetUrlCacheEntryInfoA(
        pszUrl,
        pCacheEntryInfo,
        &cbCachEntryInfo);
    if (!fResult)
        PrintLastError("GetUrlCachEntryInfo");
    else if (cbCachEntryInfo == 0)
        printf("GetUrlCachEntryInfo returned no bytes\n");
    else {
        printf("UrlCachEntryInfo (%d bytes)::\n", cbCachEntryInfo);
        printf("  StructSize: %d\n", pCacheEntryInfo->dwStructSize);
        printf("  SourceUrlName: %s\n", pCacheEntryInfo->lpszSourceUrlName);
        printf("  LocalFileName: %s\n", pCacheEntryInfo->lpszLocalFileName);
        printf("  FileExtension: %s\n", pCacheEntryInfo->lpszFileExtension);

        dwEntryType = pCacheEntryInfo->CacheEntryType;
        printf("  CacheEntryType: 0x%x", dwEntryType);
        if (dwEntryType & NORMAL_CACHE_ENTRY)
            printf(" NORMAL");
        if (dwEntryType & STICKY_CACHE_ENTRY)
            printf(" STICKY");
        if (dwEntryType & EDITED_CACHE_ENTRY)
            printf(" EDITED");
        if (dwEntryType & TRACK_OFFLINE_CACHE_ENTRY)
            printf(" TRACK_OFFLINE");
        if (dwEntryType & TRACK_ONLINE_CACHE_ENTRY)
            printf(" TRACK_ONLINE");
        if (dwEntryType & SPARSE_CACHE_ENTRY)
            printf(" SPARSE");
        if (dwEntryType & COOKIE_CACHE_ENTRY)
            printf(" COOKIE");
        if (dwEntryType & URLHISTORY_CACHE_ENTRY)
            printf(" URLHISTORY");
        printf("\n");

        printf("  UseCount: %d\n", pCacheEntryInfo->dwUseCount);
        printf("  HitRate: %d\n", pCacheEntryInfo->dwHitRate);
        printf("  FileSize: %d\n", pCacheEntryInfo->dwSizeLow);
        printf("  LastModifiedTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastModifiedTime));
        printf("  ExpireTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->ExpireTime));
        printf("  LastAccessTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastAccessTime));
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastSyncTime));
        printf("  ExemptDelta:: %d\n", pCacheEntryInfo->dwExemptDelta);

        if (pCacheEntryInfo->dwHeaderInfoSize) {
            printf("  HeaderInfo::\n");
            PrintBytes("  ", (BYTE *) pCacheEntryInfo->lpHeaderInfo,
                pCacheEntryInfo->dwHeaderInfoSize);
        }
    }
}

static void DisplayCacheEntryInfoW(
    LPWSTR pwszUrl
    )
{
    BOOL fResult;
    char szUrl[_MAX_PATH + 1];

    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOW pCacheEntryInfo =
        (LPINTERNET_CACHE_ENTRY_INFOW) &rgbCachEntryInfo[0];

    WideCharToMultiByte(
        CP_ACP,
        0,                      // dwFlags
        pwszUrl,
        -1,                     // Null terminated
        szUrl,
        sizeof(szUrl),
        NULL,                   // lpDefaultChar
        NULL                    // lpfUsedDefaultChar
        );

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
#if 0
    // BUG the signature of the following API was changed around 1804.
    // Changed from szUrl to wszUrl

    fResult = GetUrlCacheEntryInfoW(
        szUrl,
        pCacheEntryInfo,
        &cbCachEntryInfo);
#else
    fResult = FALSE;
    SetLastError((DWORD) E_NOTIMPL);
#endif
    if (!fResult)
        PrintLastError("GetUrlCachEntryInfo");
    else if (cbCachEntryInfo == 0)
        printf("GetUrlCachEntryInfo returned no bytes\n");
    else {
        printf("UrlCachEntryInfo (%d bytes)::\n", cbCachEntryInfo);
        printf("  SourceUrlName: %s\n", pCacheEntryInfo->lpszSourceUrlName);
        printf("  LocalFileName: %S\n", pCacheEntryInfo->lpszLocalFileName);
        printf("  UseCount: %d\n", pCacheEntryInfo->dwUseCount);
        printf("  HitRate: %d\n", pCacheEntryInfo->dwHitRate);
        printf("  FileSize: %d\n", pCacheEntryInfo->dwSizeLow);
        printf("  LastModifiedTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastModifiedTime));
        printf("  ExpireTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->ExpireTime));
        printf("  LastAccessTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastAccessTime));
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastSyncTime));
    }
}


static void SetSyncTime(
    LPSTR pszUrl,
    LONG lDeltaSeconds
    )
{
    DWORD dwFieldControl = CACHE_ENTRY_SYNCTIME_FC;
    INTERNET_CACHE_ENTRY_INFOA CacheEntry;
    FILETIME CurrentTime;
    BOOL fResult;

    memset(&CacheEntry, 0, sizeof(CacheEntry));
    CacheEntry.dwStructSize = sizeof(CacheEntry);

    GetSystemTimeAsFileTime(&CurrentTime);

    if (lDeltaSeconds >= 0)
        I_CryptIncrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) lDeltaSeconds,
            &CacheEntry.LastSyncTime
            );
    else
        I_CryptDecrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) -lDeltaSeconds,
            &CacheEntry.LastSyncTime
            );

    fResult = SetUrlCacheEntryInfoA( pszUrl, &CacheEntry, dwFieldControl );

    if (!fResult)
        PrintLastError("SetUrlCacheEntryInfoA");
}

#if 0
static void DisplayDestinationReachableA(
    LPSTR pszUrl
    )
{
    BOOL fResult;
    QOCINFO qocInfo;

    memset(&qocInfo, 0, sizeof(qocInfo));
    qocInfo.dwSize = sizeof(qocInfo);

    fResult = IsDestinationReachableA(pszUrl, &qocInfo);

    if (fResult) {
        printf("Url is reachable, InSpeed: %d OutSpeed: %d dwFlags: 0x%x\n",
            qocInfo.dwInSpeed, qocInfo.dwOutSpeed, qocInfo.dwFlags);
    } else
        PrintLastError("IsDestinationReachable");
}
#endif

static void ReadUrl(
    HINTERNET hInternetFile
    )
{
    BOOL fResult;
    DWORD cb;
    DWORD cbTotal;

    cb = 0;
    fResult = InternetQueryDataAvailable(
        hInternetFile,
        &cb,
        0,                  // dwFlags
        0                   // dwContext
        );
    if (!fResult)
        PrintLastError("InternetQueryDataAvailable");
    else
        printf("NumberOfBytesAvailable: %d\n", cb);

    cbTotal = 0;
    while (TRUE) {
        BYTE rgb[512];
        memset(rgb, 0, sizeof(rgb));
        DWORD cbRead = 0;

        fResult = InternetReadFile(
            hInternetFile,
            rgb,
            sizeof(rgb),
            &cbRead);

        if (cbRead) {
            cbTotal += cbRead;
            if (!fResult)
                PrintLastError("InternetReadFile(cbRead != 0)");
            printf("Bytes read from URL::\n");
            PrintBytes("  ", rgb, cbRead);
        } else {
            if (!fResult)
                PrintLastError("InternetReadFile(cbRead == 0)");

            break;
        }
    }

    printf("Total number of bytes read: %d\n", cbTotal);
}

static void OfflineUrlA(
    LPSTR pszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  OFFLINE  ****\n");
    dwFlags = INTERNET_FLAG_OFFLINE;
    hInternetSession = InternetOpenA(
        "CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpen");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlA(
        hInternetSession,
        pszUrl,
        "Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
//        INTERNET_FLAG_RELOAD, // dwFlags
        INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrl");
        goto CommonReturn;
    }

    DisplayCacheEntryInfoA(pszUrl);
    ReadUrl(hInternetFile);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

static void OfflineUrlW(
    LPWSTR pwszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  OFFLINE  ****\n");
    dwFlags = INTERNET_FLAG_OFFLINE;
    hInternetSession = InternetOpenW(
        L"CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpenW");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlW(
        hInternetSession,
        pwszUrl,
        L"Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
//        INTERNET_FLAG_RELOAD, // dwFlags
        INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrlW");
        goto CommonReturn;
    }

    DisplayCacheEntryInfoW(pwszUrl);
    ReadUrl(hInternetFile);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}


typedef struct _QUERY_INFO {
    LPSTR   pszInfo;
    DWORD   dwInfo;
} QUERY_INFO, *PQUERY_INFO;

static QUERY_INFO rgQueryInfo[] = {
#if 0
    "HTTP_QUERY_MIME_VERSION-Req",
        HTTP_QUERY_MIME_VERSION | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_TYPE-Req",
        HTTP_QUERY_CONTENT_TYPE | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_TRANSFER_ENCODING-Req",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_LENGTH-Req",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_REQUEST_HEADERS,
#endif

    "HTTP_QUERY_MIME_VERSION", HTTP_QUERY_MIME_VERSION,
    "HTTP_QUERY_CONTENT_TYPE", HTTP_QUERY_CONTENT_TYPE,
    "HTTP_QUERY_CONTENT_TRANSFER_ENCODING",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING,
    "HTTP_QUERY_CONTENT_LENGTH", HTTP_QUERY_CONTENT_LENGTH,
    "HTTP_QUERY_CONTENT_LENGTH-Num",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,

    "HTTP_QUERY_VERSION", HTTP_QUERY_VERSION, 
    "HTTP_QUERY_STATUS_CODE", HTTP_QUERY_STATUS_CODE, 
    "HTTP_QUERY_STATUS_CODE-Num",
        HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
    "HTTP_QUERY_STATUS_TEXT", HTTP_QUERY_STATUS_TEXT, 
    "HTTP_QUERY_RAW_HEADERS", HTTP_QUERY_RAW_HEADERS, 
    "HTTP_QUERY_RAW_HEADERS_CRLF", HTTP_QUERY_RAW_HEADERS_CRLF, 
    "HTTP_QUERY_CONTENT_ENCODING", HTTP_QUERY_CONTENT_ENCODING, 
    "HTTP_QUERY_LOCATION", HTTP_QUERY_LOCATION, 
    "HTTP_QUERY_ORIG_URI", HTTP_QUERY_ORIG_URI, 
    "HTTP_QUERY_REQUEST_METHOD", HTTP_QUERY_REQUEST_METHOD, 
    "HTTP_QUERY_DATE",
        HTTP_QUERY_DATE | HTTP_QUERY_FLAG_SYSTEMTIME,
    "HTTP_QUERY_EXPIRES",
        HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME,
    "HTTP_QUERY_LAST_MODIFIED",
        HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
};

#define NQUERYINFO  (sizeof(rgQueryInfo)/sizeof(rgQueryInfo[0]))

static void DisplayQueryInfo(IN HINTERNET hInternetFile, IN BOOL fUnicode)
{
    DWORD i;
    for (i = 0; i < NQUERYINFO; i++) {
        DWORD dwIndex;
        BOOL fFirst;

        fFirst = TRUE;
        dwIndex = 0;
        while (TRUE) {
            BYTE rgbBuf[4096];
            DWORD cbBuf;
            DWORD dwThisIndex = dwIndex;
            BOOL fResult;
            DWORD dwValue;
            SYSTEMTIME st;

            memset(rgbBuf, 0, sizeof(rgbBuf));
            cbBuf = sizeof(rgbBuf);
    
            if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_NUMBER) {
                dwValue = 0x183679;
                cbBuf = sizeof(dwValue);
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    &dwValue,
                    &cbBuf,
                    &dwIndex);
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_SYSTEMTIME) {
                cbBuf = sizeof(st);
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    &st,
                    &cbBuf,
                    &dwIndex);
            } else if (fUnicode)
                fResult = HttpQueryInfoW(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    rgbBuf,
                    &cbBuf,
                    &dwIndex);
            else
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    rgbBuf,
                    &cbBuf,
                    &dwIndex);
            if (!fResult) {
                DWORD dwErr = GetLastError();
                if (fFirst || ERROR_HTTP_HEADER_NOT_FOUND != dwErr)
                    printf("HttpQueryInfo(%s) failed => 0x%x (%d) \n",
                        rgQueryInfo[i].pszInfo, dwErr, dwErr);
                break;
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_NUMBER) {
                printf("%s[%d]:: 0x%x (%d)\n",
                    rgQueryInfo[i].pszInfo, dwThisIndex, dwValue, dwValue);
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_SYSTEMTIME) {
                FILETIME ft;
                if (!SystemTimeToFileTime(&st, &ft)) {
                    DWORD dwErr = GetLastError();
                    printf("SystemTimeToFileTime(%s) failed => 0x%x (%d) \n",
                        rgQueryInfo[i].pszInfo, dwErr, dwErr);
                } else
                    printf("%s[%d]:: %s\n", rgQueryInfo[i].pszInfo,
                        dwThisIndex, FileTimeText(&ft));
            } else {
                printf("%s[%d]::\n",
                    rgQueryInfo[i].pszInfo, dwThisIndex);
                PrintBytes("  ", rgbBuf, cbBuf);
            }
            fFirst = FALSE;
            if (dwThisIndex == dwIndex) {
#if 0
                printf("HttpQueryInfo(%s) dwIndex not advanced\n",
                    rgQueryInfo[i].pszInfo);
#endif
                break;
            }
        }
    }
}

static void OnlineUrlA(
    LPSTR pszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  ONLINE  ****\n");

#if 0
    DisplayDestinationReachableA(pszUrl);
#endif

    dwFlags = 0;
    hInternetSession = InternetOpenA(
        "CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpen");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlA(
        hInternetSession,
        pszUrl,
        "Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrl");
        goto CommonReturn;
    }

    DisplayQueryInfo(hInternetFile, FALSE);
    ReadUrl(hInternetFile);
    DisplayCacheEntryInfoA(pszUrl);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

static void OnlineUrlW(
    LPWSTR pwszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  ONLINE  ****\n");
    dwFlags = 0;
    hInternetSession = InternetOpenW(
        L"CRL Agent",                   // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpenW");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlW(
        hInternetSession,
        pwszUrl,
        L"Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrlW");
        goto CommonReturn;
    }

    DisplayQueryInfo(hInternetFile, TRUE);
    ReadUrl(hInternetFile);
    DisplayCacheEntryInfoW(pwszUrl);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

void DisplayInternetState()
{
    DWORD dwFlags = 0;
    BOOL fResult;

    fResult = InternetGetConnectedState(&dwFlags, 0);
    if (!fResult)
        printf("NO ");
    printf("Internet Connection, dwFlags: 0x%x", dwFlags);

    if (dwFlags & INTERNET_CONNECTION_MODEM)
        printf(" MODEM");
    if (dwFlags & INTERNET_CONNECTION_LAN)
        printf(" LAN");
    if (dwFlags & INTERNET_CONNECTION_PROXY)
        printf(" PROXY");
    if (dwFlags & INTERNET_CONNECTION_MODEM_BUSY)
        printf(" MODEM_BUSY");
    if (dwFlags & INTERNET_RAS_INSTALLED)
        printf(" RAS_INSTALLED");
    if (dwFlags & INTERNET_CONNECTION_OFFLINE)
        printf(" OFFLINE");
    if (dwFlags & INTERNET_CONNECTION_CONFIGURED)
        printf(" CONFIGURED");
    printf("\n");


    dwFlags = 0;
    fResult = IsNetworkAlive(&dwFlags);
    if (fResult) {
        printf("Network Alive, dwFlags: 0x%x", dwFlags);

        if (dwFlags & NETWORK_ALIVE_LAN)
            printf(" LAN");
        if (dwFlags & NETWORK_ALIVE_WAN)
            printf(" WAN");
        if (dwFlags & NETWORK_ALIVE_AOL)
            printf(" AOL");
        printf("\n");
    } else {
        DWORD dwErr = GetLastError();
        printf("Network disconnected, 0x%x  (%d)\n", dwErr, dwErr);
    }

}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPSTR pszUrl = NULL;
    WCHAR wszUrl[_MAX_PATH + 1];
    LPWSTR pwszUrl = NULL;
    BOOL fUnicode = FALSE;
    char szCanonicalizedUrl[_MAX_PATH + 1];
    WCHAR wszCanonicalizedUrl[_MAX_PATH + 1];
    DWORD cb;
    BOOL fDelete = FALSE;
    BOOL fCacheInfo = FALSE;
    BOOL fOfflineOnly = FALSE;
    BOOL fWireOnly = FALSE;
#define NO_CANONICALIZE     0xFFFFFFFF
    DWORD dwCanonicalizeFlags = ICU_BROWSER_MODE;

    BOOL fSyncTime = FALSE;
    LONG lSyncTimeDeltaSeconds = 0;

    BOOL fHostName = FALSE;
    WCHAR wszHostName[_MAX_PATH + 1];
    
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'U':
                fUnicode = TRUE;
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'i':
                fCacheInfo = TRUE;
                break;
            case 'o':
                fOfflineOnly = TRUE;
                break;
            case 'w':
                fWireOnly = TRUE;
                break;
            case 'c':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "None"))
                        dwCanonicalizeFlags = NO_CANONICALIZE;
                    else if (0 == _stricmp(argv[0]+2, "Spaces"))
                        dwCanonicalizeFlags = ICU_ENCODE_SPACES_ONLY;
                    else if (0 == _stricmp(argv[0]+2, "Browser"))
                        dwCanonicalizeFlags = ICU_BROWSER_MODE;
                    else if (0 == _stricmp(argv[0]+2, "All"))
                        dwCanonicalizeFlags = 0;
                    else {
                        printf("Need to specify -cNone | -cSpaces | -cBrowser | -cAll\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -cNone | -cSpaces | -cBrowser | -cAll\n");
                    goto BadUsage;
                }
                break;
            case 's':
                DisplayInternetState();
                goto CommonReturn;
            case 'n':
                fHostName = TRUE;
                break;
            case 'S':
                fSyncTime = TRUE;
                lSyncTimeDeltaSeconds = strtol(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else
            pszUrl = argv[0];
    }


    if (pszUrl == NULL) {
        printf("missing URL\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fHostName) {
        MultiByteToWideChar(
                CP_ACP,
                0,                      // dwFlags
                pszUrl,
                -1,                     // null terminated
                wszUrl,
                sizeof(wszUrl) / sizeof(wszUrl[0]));

        wszHostName[0] = L'\0';
        fResult = I_CryptNetGetHostNameFromUrl (
            wszUrl,
            sizeof(wszHostName) / sizeof(wszHostName[0]),
            wszHostName
            );
        if (!fResult)
            PrintLastError("I_CryptNetGetHostNameFromUrl");
        else
            printf("HostName :: %S\n", wszHostName);

        goto CommonReturn;
    }

    if (fUnicode) {
        MultiByteToWideChar(
                CP_ACP,
                0,                      // dwFlags
                pszUrl,
                -1,                     // null terminated
                wszUrl,
                sizeof(wszUrl) / sizeof(wszUrl[0]));

        if (NO_CANONICALIZE == dwCanonicalizeFlags) {
            pwszUrl = wszUrl;
            printf("Unicode Url:: %S\n", pwszUrl);
        } else {
            cb = sizeof(wszCanonicalizedUrl);
            fResult = InternetCanonicalizeUrlW(
                wszUrl,
                wszCanonicalizedUrl,
                &cb,
                dwCanonicalizeFlags
                );
            if (!fResult) {
                PrintLastError("InternetCanonicalizeUrlW");
                goto CommonReturn;
            } else if (cb) {
                printf("Unicode CanonicalizedUrl:: %S\n", wszCanonicalizedUrl);
                pwszUrl = wszCanonicalizedUrl;
            } else {
                printf("Unicode CanonicalizedUrl:: returned empty string\n");
                goto CommonReturn;
            }
        }

        if (fDelete) {
            printf("Unicode DeleteUrlCacheEntry not supported\n");
        } else if (fSyncTime) {
            printf("Unicode SyncTime not supported\n");
        } else if (fCacheInfo) {
            DisplayCacheEntryInfoW(pwszUrl);
        } else if (fOfflineOnly) {
            OfflineUrlW(pwszUrl);
        } else if (fWireOnly) {
            OnlineUrlW(pwszUrl);
        } else {
            OfflineUrlW(pwszUrl);
            OnlineUrlW(pwszUrl);
        }
    } else {
        if (NO_CANONICALIZE == dwCanonicalizeFlags) {
            printf("Url:: %s\n", pszUrl);
        } else {
            cb = sizeof(szCanonicalizedUrl);
            fResult = InternetCanonicalizeUrlA(
                pszUrl,
                szCanonicalizedUrl,
                &cb,
                dwCanonicalizeFlags
                );
            if (!fResult) {
                PrintLastError("InternetCanonicalizeUrlA");
                goto CommonReturn;
            } else if (cb) {
                printf("CanonicalizedUrl:: %s\n", szCanonicalizedUrl);
                pszUrl = szCanonicalizedUrl;
            } else {
                printf("CanonicalizedUrl:: returned empty string\n");
                goto CommonReturn;
            }
        }

        if (fDelete) {
            if (!DeleteUrlCacheEntry(pszUrl)) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    PrintLastError("DeleteUrlCacheEntry");
            }
        } else if (fSyncTime) {
            SetSyncTime(pszUrl, lSyncTimeDeltaSeconds);
        } else if (fCacheInfo) {
            DisplayCacheEntryInfoA(pszUrl);
        } else if (fOfflineOnly) {
            OfflineUrlA(pszUrl);
        } else if (fWireOnly) {
            OnlineUrlA(pszUrl);
        } else {
            OfflineUrlA(pszUrl);
            OnlineUrlA(pszUrl);
        }
    }

CommonReturn:
    return 0;
BadUsage:
    Usage();
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\ttrust\ttrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       ttrust.cpp
//
//  Contents:   WinVerifyTrust Chain Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    06-Feb-98   philh   created
//--------------------------------------------------------------------------

#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS        1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "wintrustp.h"
#include "softpub.h"
#include "certtest.h"
#include "crypthlp.h"
#include "unicode.h"

#include "wininet.h"
#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <winwlx.h>

extern BOOL WINAPI ChainWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo);

static void PrintStatus(
    IN LPCSTR pszMsg,
    IN LONG lStatus
    )
{
    printf("%s", pszMsg);
    switch (lStatus) {
         case CRYPT_E_MSG_ERROR:
            printf("CRYPT_E_MSG_ERROR");
            break;
         case CRYPT_E_UNKNOWN_ALGO:
            printf("CRYPT_E_UNKNOWN_ALGO");
            break;
         case CRYPT_E_OID_FORMAT:
            printf("CRYPT_E_OID_FORMAT");
            break;
         case CRYPT_E_INVALID_MSG_TYPE:
            printf("CRYPT_E_INVALID_MSG_TYPE");
            break;
         case CRYPT_E_UNEXPECTED_ENCODING:
            printf("CRYPT_E_UNEXPECTED_ENCODING");
            break;
         case CRYPT_E_AUTH_ATTR_MISSING:
            printf("CRYPT_E_AUTH_ATTR_MISSING");
            break;
         case CRYPT_E_HASH_VALUE:
            printf("CRYPT_E_HASH_VALUE");
            break;
         case CRYPT_E_INVALID_INDEX:
            printf("CRYPT_E_INVALID_INDEX");
            break;
         case CRYPT_E_ALREADY_DECRYPTED:
            printf("CRYPT_E_ALREADY_DECRYPTED");
            break;
         case CRYPT_E_NOT_DECRYPTED:
            printf("CRYPT_E_NOT_DECRYPTED");
            break;
         case CRYPT_E_RECIPIENT_NOT_FOUND:
            printf("CRYPT_E_RECIPIENT_NOT_FOUND");
            break;
         case CRYPT_E_CONTROL_TYPE:
            printf("CRYPT_E_CONTROL_TYPE");
            break;
         case CRYPT_E_ISSUER_SERIALNUMBER:
            printf("CRYPT_E_ISSUER_SERIALNUMBER");
            break;
         case CRYPT_E_SIGNER_NOT_FOUND:
            printf("CRYPT_E_SIGNER_NOT_FOUND");
            break;
         case CRYPT_E_ATTRIBUTES_MISSING:
            printf("CRYPT_E_ATTRIBUTES_MISSING");
            break;
         case CRYPT_E_STREAM_MSG_NOT_READY:
            printf("CRYPT_E_STREAM_MSG_NOT_READY");
            break;
         case CRYPT_E_STREAM_INSUFFICIENT_DATA:
            printf("CRYPT_E_STREAM_INSUFFICIENT_DATA");
            break;
         case CRYPT_E_BAD_LEN:
            printf("CRYPT_E_BAD_LEN");
            break;
         case CRYPT_E_BAD_ENCODE:
            printf("CRYPT_E_BAD_ENCODE");
            break;
         case CRYPT_E_FILE_ERROR:
            printf("CRYPT_E_FILE_ERROR");
            break;
         case CRYPT_E_NOT_FOUND:
            printf("CRYPT_E_NOT_FOUND");
            break;
         case CRYPT_E_EXISTS:
            printf("CRYPT_E_EXISTS");
            break;
         case CRYPT_E_NO_PROVIDER:
            printf("CRYPT_E_NO_PROVIDER");
            break;
         case CRYPT_E_SELF_SIGNED:
            printf("CRYPT_E_SELF_SIGNED");
            break;
         case CRYPT_E_DELETED_PREV:
            printf("CRYPT_E_DELETED_PREV");
            break;
         case CRYPT_E_NO_MATCH:
            printf("CRYPT_E_NO_MATCH");
            break;
         case CRYPT_E_UNEXPECTED_MSG_TYPE:
            printf("CRYPT_E_UNEXPECTED_MSG_TYPE");
            break;
         case CRYPT_E_NO_KEY_PROPERTY:
            printf("CRYPT_E_NO_KEY_PROPERTY");
            break;
         case CRYPT_E_NO_DECRYPT_CERT:
            printf("CRYPT_E_NO_DECRYPT_CERT");
            break;
         case CRYPT_E_BAD_MSG:
            printf("CRYPT_E_BAD_MSG");
            break;
         case CRYPT_E_NO_SIGNER:
            printf("CRYPT_E_NO_SIGNER");
            break;
         case CRYPT_E_PENDING_CLOSE:
            printf("CRYPT_E_PENDING_CLOSE");
            break;
         case CRYPT_E_REVOKED:
            printf("CRYPT_E_REVOKED");
            break;
         case CRYPT_E_NO_REVOCATION_DLL:
            printf("CRYPT_E_NO_REVOCATION_DLL");
            break;
         case CRYPT_E_NO_REVOCATION_CHECK:
            printf("CRYPT_E_NO_REVOCATION_CHECK");
            break;
         case CRYPT_E_REVOCATION_OFFLINE:
            printf("CRYPT_E_REVOCATION_OFFLINE");
            break;
         case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
            printf("CRYPT_E_NOT_IN_REVOCATION_DATABASE");
            break;
         case CRYPT_E_INVALID_NUMERIC_STRING:
            printf("CRYPT_E_INVALID_NUMERIC_STRING");
            break;
         case CRYPT_E_INVALID_PRINTABLE_STRING:
            printf("CRYPT_E_INVALID_PRINTABLE_STRING");
            break;
         case CRYPT_E_INVALID_IA5_STRING:
            printf("CRYPT_E_INVALID_IA5_STRING");
            break;
         case CRYPT_E_INVALID_X500_STRING:
            printf("CRYPT_E_INVALID_X500_STRING");
            break;
         case CRYPT_E_NOT_CHAR_STRING:
            printf("CRYPT_E_NOT_CHAR_STRING");
            break;
         case CRYPT_E_FILERESIZED:
            printf("CRYPT_E_FILERESIZED");
            break;
         case CRYPT_E_SECURITY_SETTINGS:
            printf("CRYPT_E_SECURITY_SETTINGS");
            break;
         case CRYPT_E_NO_VERIFY_USAGE_DLL:
            printf("CRYPT_E_NO_VERIFY_USAGE_DLL");
            break;
         case CRYPT_E_NO_VERIFY_USAGE_CHECK:
            printf("CRYPT_E_NO_VERIFY_USAGE_CHECK");
            break;
         case CRYPT_E_VERIFY_USAGE_OFFLINE:
            printf("CRYPT_E_VERIFY_USAGE_OFFLINE");
            break;
         case CRYPT_E_NOT_IN_CTL:
            printf("CRYPT_E_NOT_IN_CTL");
            break;
         case CRYPT_E_NO_TRUSTED_SIGNER:
            printf("CRYPT_E_NO_TRUSTED_SIGNER");
            break;
         case CERTSRV_E_BAD_REQUESTSUBJECT:
            printf("CERTSRV_E_BAD_REQUESTSUBJECT");
            break;
         case CERTSRV_E_NO_REQUEST:
            printf("CERTSRV_E_NO_REQUEST");
            break;
         case CERTSRV_E_BAD_REQUESTSTATUS:
            printf("CERTSRV_E_BAD_REQUESTSTATUS");
            break;
         case CERTSRV_E_PROPERTY_EMPTY:
            printf("CERTSRV_E_PROPERTY_EMPTY");
            break;
         case TRUST_E_SYSTEM_ERROR:
            printf("TRUST_E_SYSTEM_ERROR");
            break;
         case TRUST_E_NO_SIGNER_CERT:
            printf("TRUST_E_NO_SIGNER_CERT");
            break;
         case TRUST_E_COUNTER_SIGNER:
            printf("TRUST_E_COUNTER_SIGNER");
            break;
         case TRUST_E_CERT_SIGNATURE:
            printf("TRUST_E_CERT_SIGNATURE");
            break;
         case TRUST_E_TIME_STAMP:
            printf("TRUST_E_TIME_STAMP");
            break;
         case TRUST_E_BAD_DIGEST:
            printf("TRUST_E_BAD_DIGEST");
            break;
         case TRUST_E_BASIC_CONSTRAINTS:
            printf("TRUST_E_BASIC_CONSTRAINTS");
            break;
         case TRUST_E_FINANCIAL_CRITERIA:
            printf("TRUST_E_FINANCIAL_CRITERIA");
            break;
         case TRUST_E_PROVIDER_UNKNOWN:
            printf("TRUST_E_PROVIDER_UNKNOWN");
            break;
         case TRUST_E_ACTION_UNKNOWN:
            printf("TRUST_E_ACTION_UNKNOWN");
            break;
         case TRUST_E_SUBJECT_FORM_UNKNOWN:
            printf("TRUST_E_SUBJECT_FORM_UNKNOWN");
            break;
         case TRUST_E_SUBJECT_NOT_TRUSTED:
            printf("TRUST_E_SUBJECT_NOT_TRUSTED");
            break;
         case TRUST_E_EXPLICIT_DISTRUST:
            printf("TRUST_E_EXPLICIT_DISTRUST");
            break;
         case DIGSIG_E_ENCODE:
            printf("DIGSIG_E_ENCODE");
            break;
         case DIGSIG_E_DECODE:
            printf("DIGSIG_E_DECODE");
            break;
         case DIGSIG_E_EXTENSIBILITY:
            printf("DIGSIG_E_EXTENSIBILITY");
            break;
         case DIGSIG_E_CRYPTO:
            printf("DIGSIG_E_CRYPTO");
            break;
         case PERSIST_E_SIZEDEFINITE:
            printf("PERSIST_E_SIZEDEFINITE");
            break;
         case PERSIST_E_SIZEINDEFINITE:
            printf("PERSIST_E_SIZEINDEFINITE");
            break;
         case PERSIST_E_NOTSELFSIZING:
            printf("PERSIST_E_NOTSELFSIZING");
            break;
         case TRUST_E_NOSIGNATURE:
            printf("TRUST_E_NOSIGNATURE");
            break;
         case CERT_E_EXPIRED:
            printf("CERT_E_EXPIRED");
            break;
         case CERT_E_VALIDITYPERIODNESTING:
            printf("CERT_E_VALIDITYPERIODNESTING");
            break;
         case CERT_E_ROLE:
            printf("CERT_E_ROLE");
            break;
         case CERT_E_PATHLENCONST:
            printf("CERT_E_PATHLENCONST");
            break;
         case CERT_E_CRITICAL:
            printf("CERT_E_CRITICAL");
            break;
         case CERT_E_PURPOSE:
            printf("CERT_E_PURPOSE");
            break;
         case CERT_E_ISSUERCHAINING:
            printf("CERT_E_ISSUERCHAINING");
            break;
         case CERT_E_MALFORMED:
            printf("CERT_E_MALFORMED");
            break;
         case CERT_E_UNTRUSTEDROOT:
            printf("CERT_E_UNTRUSTEDROOT");
            break;
         case CERT_E_UNTRUSTEDCA:
            printf("CERT_E_UNTRUSTEDCA");
            break;
         case CERT_E_CHAINING:
            printf("CERT_E_CHAINING");
            break;
         case TRUST_E_FAIL:
            printf("TRUST_E_FAIL");
            break;
         case CERT_E_REVOKED:
            printf("CERT_E_REVOKED");
            break;
         case CERT_E_UNTRUSTEDTESTROOT:
            printf("CERT_E_UNTRUSTEDTESTROOT");
            break;
         case CERT_E_REVOCATION_FAILURE:
            printf("CERT_E_REVOCATION_FAILURE");
            break;
         case CERT_E_CN_NO_MATCH:
            printf("CERT_E_CN_NO_MATCH");
            break;
         case CERT_E_WRONG_USAGE:
            printf("CERT_E_WRONG_USAGE");
            break;
          default:
            break;
    }

    printf (" 0x%x (%d)\n", lStatus, lStatus);
}

static void PrintError(
    IN LPCSTR pszMsg,
    IN DWORD dwErr
    )
{
    PrintStatus(pszMsg, (LONG) dwErr);
}

static void Usage(void)
{
    printf("Usage: ttrust [options] <filename>\n");
    printf("Options are:\n");
    printf("  -Cert                 - Default\n");
    printf("  -File\n");
    printf("  -Driver\n");
    printf("  -Https\n");
    printf("  -Chain\n");
    printf("  -ChainCallback\n");
    printf("  -NTAuth\n");
    printf("  -NTAuthNameConstraint\n");
    printf("  -Safer\n");
    printf("\n");
    printf("  -UseIE4Trust\n");
    printf("  -NoIE4Chain\n");
    printf("  -NoUsage\n");
    printf("  -OrUsage\n");
    printf("  -OrPolicy\n");
    printf("  -LifetimeSigning\n");
    printf("  -MicrosoftRoot\n");
    printf("  -NotMicrosoftRoot\n");
    printf("\n");
    printf("  -DisplayKnownUsages\n");
    printf("  -LogoffNotification\n");
    printf("\n");
    printf("  -UINone               - Default\n");
    printf("  -UIAll\n");
    printf("  -UINoBad\n");
    printf("  -UINoGood\n");
    printf("\n");
    printf("  -RevokeNone           - Default\n");
    printf("  -RevokeChain\n");
    printf("\n");
    printf("  -DontOpenStores\n");
    printf("  -OpenOnlyRoot\n");
    printf("\n");
    printf("  -HttpsIgnoreRevocation\n");
    printf("  -HttpsIgnoreUnknownCa\n");
    printf("  -HttpsIgnoreWrongUsage\n");
    printf("  -HttpsIgnoreCertDateInvalid\n");
    printf("  -HttpsIgnoreCertCNInvalid\n");
    printf("\n");
    printf("  -Client               - Default\n");
    printf("  -Server\n");
    printf("\n");
    printf("  -InstallThreadDefaultContext\n");
    printf("  -InstallProcessDefaultContext\n");
    printf("  -AutoReleaseDefaultContext\n");
    printf("  -NULLDefaultContext\n");
    printf("  -MultiDefaultContext\n");
    printf("\n");
    printf("  -AuthenticodeFlags <Number>\n");
    printf("  -DeleteSaferRegKey\n");
    printf("  -EnableRootAutoUpdate\n");
    printf("  -DisableRootAutoUpdate\n");
    printf("  -EnableUntrustedRootLogging\n");
    printf("  -DisableUntrustedRootLogging\n");
    printf("  -EnablePartialChainLogging\n");
    printf("  -DisablePartialChainLogging\n");
    printf("  -EnableNTAuthRequired\n");
    printf("  -DisableNTAuthRequired\n");
    printf("  -RegistryOnlyExit\n");
    printf("\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -q[<Number>]          - Quiet, expected error\n");
    printf("  -e<Number>            - Expected trust error status\n");
    printf("  -i<Number>            - Expected trust info status\n");
    printf("  -u<OID String>        - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -p<OID String>        - Policy OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -s<SystemStore>       - Additional System Store\n");
    printf("  -S<FileSystemStore>   - Additional File System Store\n");
    printf("  -n<ServerName>        - Https ServerName\n");
    printf("  -f<Number>            - Flags\n");
    printf("  -t<Number>            - Url timeout (milliseconds)\n");
    printf("  -r<Number>            - Revocation freshness (seconds)\n");
    printf("\n");
}

static PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

static void DisplayPeterSigner(
    IN CRYPT_PROVIDER_SGNR *pProvSign,
    IN DWORD dwDisplayFlags
    )
{
    DWORD idxCert;


    printf("Verify Time: %s\n", FileTimeText(&pProvSign->sftVerifyAsOf));
    if (pProvSign->dwSignerType) {
        printf("Signer Type: 0x%x", pProvSign->dwSignerType);
        if (pProvSign->dwSignerType == SGNR_TYPE_TIMESTAMP)
            printf(" TIMESTAMP");
        printf("\n");
    }

    if (pProvSign->dwError)
        PrintError("Error: ", pProvSign->dwError);

    if (0 == pProvSign->csCertChain) {
        printf("No Certificates\n");
        return;
    }

    for (idxCert = 0; idxCert < pProvSign->csCertChain; idxCert++) {
        CRYPT_PROVIDER_CERT *pProvCert;
        printf("-----  Cert [%d]  -----\n", idxCert);

        pProvCert = WTHelperGetProvCertFromChain(pProvSign, idxCert);
        if (pProvCert) {
            if (pProvCert->dwError)
                PrintError("Error: ", pProvCert->dwError);
            if (pProvCert->dwRevokedReason)
                PrintError("RevokedReason: ", pProvCert->dwRevokedReason);
            printf("Confidence:: 0x%x ", pProvCert->dwConfidence);
            if ((pProvCert->dwConfidence & CERT_CONFIDENCE_HIGHEST) ==
                    CERT_CONFIDENCE_HIGHEST)
                printf("Highest ");
            else {
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_SIG)
                    printf("Signature ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_TIME)
                    printf("Time ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)
                    printf("TimeNest ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_AUTHIDEXT)
                    printf("AuthorityID ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_HYGIENE)
                    printf("Hygiene ");
            }
            printf("\n");
            if (pProvCert->fTrustListSignerCert)
                printf("TrustListSignerCert ");
            if (pProvCert->fCommercial)
                printf("Commercial ");
            if (pProvCert->fTrustedRoot)
                printf("TrustedRoot ");
            if (pProvCert->fSelfSigned)
                printf("SelfSigned ");
            if (pProvCert->fTestCert)
                printf("TestCert ");
            printf("\n");
            DisplayCert(pProvCert->pCert, dwDisplayFlags);

            if (pProvCert->pTrustListContext) {
                printf("-----  Outlook CTL  -----\n");
                DisplayCtl(
                    (PCCTL_CONTEXT) pProvCert->pTrustListContext,
                    dwDisplayFlags
                    );
            }

            if (pProvCert->dwCtlError)
                PrintError("Ctl Error: ", pProvCert->dwCtlError);

            if (pProvCert->pCtlContext) {
                printf("-----  CTL  -----\n");
                DisplayCtl(pProvCert->pCtlContext, dwDisplayFlags);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",             // 0x00000001
    "CERT_TRUST_IS_NOT_TIME_NESTED",            // 0x00000002
    "CERT_TRUST_IS_REVOKED",                    // 0x00000004
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",        // 0x00000008
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",        // 0x00000010
    "CERT_TRUST_IS_UNTRUSTED_ROOT",             // 0x00000020
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",     // 0x00000040
    "CERT_TRUST_IS_CYCLIC",                     // 0x00000080
    "CERT_TRUST_INVALID_EXTENSION",             // 0x00000100
    "CERT_TRUST_INVALID_POLICY_CONSTRAINTS",    // 0x00000200
    "CERT_TRUST_INVALID_BASIC_CONSTRAINTS",     // 0x00000400
    "CERT_TRUST_INVALID_NAME_CONSTRAINTS",      // 0x00000800
    "CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT", // 0x00001000
    "CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT",// 0x00002000
    "CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT", // 0x00004000
    "CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT",  // 0x00008000
    "CERT_TRUST_IS_PARTIAL_CHAIN",              // 0x00010000
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",         // 0x00020000
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",    // 0x00040000
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",    // 0x00080000
    "Unknown Error Status",                     // 0x00100000
    "Unknown Error Status",                     // 0x00200000
    "Unknown Error Status",                     // 0x00400000
    "Unknown Error Status",                     // 0x00800000
    "CERT_TRUST_IS_OFFLINE_REVOCATION",         // 0x01000000
    "CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY",      // 0x02000000
    "Unknown Error Status",                     // 0x04000000
    "Unknown Error Status",                     // 0x08000000
    "Unknown Error Status",                     // 0x10000000
    "Unknown Error Status",                     // 0x20000000
    "Unknown Error Status",                     // 0x40000000
    "Unknown Error Status"                      // 0x80000000
};

LPSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "CERT_TRUST_HAS_PREFERRED_ISSUER",  // 0x00000100
    "CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY", // 0x00000200
    "CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS",  // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "Unknown Info Status",              // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN PCERT_TRUST_STATUS pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    printf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                printf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                printf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    printf("\n");
}

void DisplayRevocationFreshnessTime(
    IN DWORD dwTime         // seconds
    )
{
    DWORD dwRemain;
    DWORD dwSec;
    DWORD dwMin;
    DWORD dwHour;
    DWORD dwDay;

    dwRemain = dwTime;
    dwSec = dwRemain % 60;
    dwRemain /= 60;             // total minutes

    dwMin = dwRemain % 60;
    dwRemain /= 60;             // total hours

    dwHour = dwRemain % 24;
    dwDay = dwRemain / 24;


    printf("Revocation Freshness Time : %d (%d day %d hour %d min %d sec)\n",
        dwTime, dwDay, dwHour, dwMin, dwSec);
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement,
    IN DWORD dwDisplayFlags
    )
{
    DisplayCert( pElement->pCertContext, dwDisplayFlags );
    printf("\n");
    if (pElement->pRevocationInfo) {
        PCERT_REVOCATION_INFO pRevocationInfo = pElement->pRevocationInfo;
        PrintError("RevocationResult: ", pRevocationInfo->dwRevocationResult);
        if (pRevocationInfo->pszRevocationOid)
            printf("RevocationOid: %s\n", pRevocationInfo->pszRevocationOid);

        if (pRevocationInfo->fHasFreshnessTime)
            DisplayRevocationFreshnessTime(
                pRevocationInfo->dwFreshnessTime);

        if (pRevocationInfo->pCrlInfo) {
            PCERT_REVOCATION_CRL_INFO pCrlInfo = pRevocationInfo->pCrlInfo;

            if (pCrlInfo->pBaseCrlContext) {
                printf("Base CRL\n");
                DisplayCrl(pCrlInfo->pBaseCrlContext, dwDisplayFlags );
            }

            if (pCrlInfo->pDeltaCrlContext) {
                printf("Delta CRL\n");
                DisplayCrl(pCrlInfo->pDeltaCrlContext, dwDisplayFlags );
            }

            if (pCrlInfo->pCrlEntry) {
                if (pCrlInfo->fDeltaCrlEntry)
                    printf("Delta ");
                else
                    printf("Base ");
                printf("CRL entry\n");
                PrintCrlEntries(1, pCrlInfo->pCrlEntry, dwDisplayFlags);
            }

        }

        printf("\n");
    }

    if (NULL == pElement->pIssuanceUsage)
        printf("Any Issuance Usages\n");
    else if (0 == pElement->pIssuanceUsage->cUsageIdentifier)
        printf("No Issuance Usages\n");
    else {
        printf("Issuance Usages\n");

        LPSTR *ppszId = pElement->pIssuanceUsage->rgpszUsageIdentifier;
        DWORD cId = pElement->pIssuanceUsage->cUsageIdentifier;
        DWORD i;

        for (i = 0; i < cId; i++, ppszId++)
            printf("    [%d] %s\n", i, *ppszId);
    }

    if (NULL == pElement->pApplicationUsage)
        printf("Any Application Usages\n");
    else if (0 == pElement->pApplicationUsage->cUsageIdentifier)
        printf("No Application Usages\n");
    else {
        printf("Application Usages\n");

        LPSTR *ppszId = pElement->pApplicationUsage->rgpszUsageIdentifier;
        DWORD cId = pElement->pApplicationUsage->cUsageIdentifier;
        DWORD i;

        for (i = 0; i < cId; i++, ppszId++)
            printf("    [%d] %s\n", i, *ppszId);
    }

    printf("\n");

    if (pElement->pwszExtendedErrorInfo) {
        printf("Extended Error Information::\n%S\n",
            pElement->pwszExtendedErrorInfo);
    }

    DisplayTrustStatus( &pElement->TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain,
    IN DWORD dwDisplayFlags = 0
    )
{
    DWORD cElement;

    if (pChain->fHasRevocationFreshnessTime)
        DisplayRevocationFreshnessTime(
            pChain->dwRevocationFreshnessTime);

    DisplayTrustStatus( &pChain->TrustStatus );
    printf("Chain Element Count = %d\n", pChain->cElement);
    for ( cElement = 0; cElement < pChain->cElement; cElement++ )
    {
        printf("Chain Element [%d]\n", cElement);
        DisplayChainElement( pChain->rgpElement[ cElement ], dwDisplayFlags );
    }
}

void DisplayKirtChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cChain;

    if (NULL == pChainContext)
        return;

    printf("Chain Context\n\n");
    if (pChainContext->fHasRevocationFreshnessTime)
        DisplayRevocationFreshnessTime(
            pChainContext->dwRevocationFreshnessTime);
    DisplayTrustStatus( (PCERT_TRUST_STATUS)&pChainContext->TrustStatus );
    printf("Simple Chain Count = %d\n\n", pChainContext->cChain );

    for ( cChain = 0; cChain < pChainContext->cChain; cChain++ )
    {
        printf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( pChainContext->rgpChain[ cChain ], dwDisplayFlags );
    }

    if (pChainContext->cLowerQualityChainContext) {
        DWORD i;

        printf("Lower Quality Chain Count = %d\n\n",
            pChainContext->cLowerQualityChainContext);
        for (i = 0; i < pChainContext->cLowerQualityChainContext; i++) {
            printf("Lower Quality Chain [%d]\n", i);
            DisplayKirtChain(pChainContext->rgpLowerQualityChainContext[i],
                dwDisplayFlags);
        }

    }
}

void DisplayChainPolicyCallbackSigner(
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner
    )
{
    if (pSigner->dwSignerType) {
        printf("Signer Type: 0x%x", pSigner->dwSignerType);
        if (pSigner->dwSignerType == SGNR_TYPE_TIMESTAMP)
            printf(" TIMESTAMP");
        printf("\n");
    }

    if (pSigner->dwError)
        PrintError("Error: ", pSigner->dwError);
    if (pSigner->pMsgSignerInfo)
        printf("pMsgSignerInfo: 0x%p\n", pSigner->pMsgSignerInfo);

    DisplayKirtChain(pSigner->pChainContext, DISPLAY_BRIEF_FLAG);
    
}

#define CHAIN_POLICY_ARG    (DWORD_PTR)0x8765beef
HRESULT
WINAPI
ChainPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    )
{
    printf(">>>>>  ChainPolicyCallback  <<<<<\n");
    if (pvPolicyArg != (void *) CHAIN_POLICY_ARG)
        printf("failed => wrong pvPolicyArg\n");

    if (dwStepError)
        PrintError("StepError: ", dwStepError);
    if (dwRegPolicySettings)
        printf("RegPolicySettings: 0x%p\n");

    if (0 == cSigner)
        printf("No Signers\n");
    else {
        DWORD idxSigner;
        for (idxSigner = 0; idxSigner < cSigner; idxSigner++) {
            DWORD idxCounterSigner;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner =
                rgpSigner[idxSigner];

            printf("======  Signer [%d]  ======\n", idxSigner);
            DisplayChainPolicyCallbackSigner(pSigner);

            for (idxCounterSigner = 0;
                    idxCounterSigner < pSigner->cCounterSigner;
                                                    idxCounterSigner++) {
                PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSigner =
                    pSigner->rgpCounterSigner[idxCounterSigner];

                printf("\n");
                printf("======  CounterSigner [%d,%d]  ======\n",
                        idxSigner, idxCounterSigner);
                DisplayChainPolicyCallbackSigner(pCounterSigner);
            }
        }
    }
    return TRUST_E_FAIL;
}


static BOOL fInstallDefaultContext = FALSE;
static DWORD dwDefaultContextFlags = 0;
static BOOL fNULLDefaultContext = FALSE;
static BOOL fMultiDefaultContext = FALSE;

static LPSTR rgpszDefaultContextOID[] = {
    // 0
    szOID_OIWSEC_sha1RSASign,
    // 1
    szOID_OIWSEC_shaRSA,
    // 2
    szOID_RSA_MD5RSA,
    // 3
    szOID_OIWSEC_md5RSA,
    // 4
    szOID_RSA_MD2RSA,
    // 5
    szOID_RSA_MD4RSA,
    // 6
    szOID_OIWSEC_md4RSA,
    // 7
    szOID_OIWSEC_md4RSA2,
    // 8
    szOID_OIWDIR_md2RSA,
    // 9
    szOID_RSA_SHA1RSA,
};

static CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA rgMultiOIDPara[] = {
     1, &rgpszDefaultContextOID[3],
     2, &rgpszDefaultContextOID[2],
    10, &rgpszDefaultContextOID[0],
     4, &rgpszDefaultContextOID[6],
     1, &rgpszDefaultContextOID[8],
};

#define NUM_MULTI_OID_PARA (sizeof(rgMultiOIDPara) / sizeof(rgMultiOIDPara[0]))
static HCRYPTDEFAULTCONTEXT rghDefaultContext[NUM_MULTI_OID_PARA];
static DWORD cDefaultContext = 0;
static HCRYPTPROV hDefaultContextProv = 0;


static void InstallDefaultContext()
{
    if (!CryptAcquireContext(
            &hDefaultContextProv,
            NULL,               // pszContainer
            NULL,               // pszProvider,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT // dwFlags
            )) {
        PrintLastError(
            "CryptAcquireContext(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)");
        hDefaultContextProv = 0;
        return;
    }

    if (fMultiDefaultContext) {
        DWORD dwFlags = dwDefaultContextFlags;
        for (cDefaultContext = 0; cDefaultContext < NUM_MULTI_OID_PARA;
                                                        cDefaultContext++) {
            if (!CryptInstallDefaultContext(
                    hDefaultContextProv,
                    CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID,
                    (const void *) &rgMultiOIDPara[cDefaultContext],
                    dwFlags,
                    NULL,                           // pvReserved
                    &rghDefaultContext[cDefaultContext]
                    )) {
                PrintLastError("CryptInstallDefaultContext");
                break;
            }

            dwFlags &= ~CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG;
        }
    } else {
        LPSTR pszOID;

        if (fNULLDefaultContext)
            pszOID = NULL;
        else
            pszOID = szOID_RSA_MD5RSA;

        if (!CryptInstallDefaultContext(
                hDefaultContextProv,
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pszOID,
                dwDefaultContextFlags,
                NULL,                           // pvReserved
                &rghDefaultContext[0]
                ))
            PrintLastError("CryptInstallDefaultContext");
        else
            cDefaultContext = 1;
    }

    if (0 == cDefaultContext) {
        CryptReleaseContext(hDefaultContextProv, 0);
        hDefaultContextProv = 0;
    }
}

static void FreeDefaultContext()
{
    if (dwDefaultContextFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
        return;

    if (0 < cDefaultContext) {
        if (!CryptUninstallDefaultContext(
                rghDefaultContext[0],
                0,                  // dwFlags
                NULL                // pvReserved
                ))
            PrintLastError("CryptUninstallDefaultContext");
        rghDefaultContext[0] = NULL;

        while (cDefaultContext-- > 0){
            if (!CryptUninstallDefaultContext(
                    rghDefaultContext[cDefaultContext],
                    0,                  // dwFlags
                    NULL                // pvReserved
                    ))
                PrintLastError("CryptUninstallDefaultContext");
        }
    }

    if (hDefaultContextProv)
        CryptReleaseContext(hDefaultContextProv, 0);
}


BOOL NTAuthVerify(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwExpectedErr
    )
{
    BOOL fResult = TRUE;
    DWORD dwErr;
    HCERTSTORE hNTAuthStore = NULL;
    PCERT_SIMPLE_CHAIN pChain;
    PCCERT_CONTEXT pCACert;             // don't free
    PCCERT_CONTEXT pAddCert = NULL;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.dwFlags = CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);


    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        goto ErrorReturn;
    }
    dwErr = PolicyStatus.dwError;

    if ((CRYPT_E_NO_REVOCATION_CHECK == dwExpectedErr ||
            CRYPT_E_REVOCATION_OFFLINE == dwExpectedErr)) {
        if (CERT_E_UNTRUSTEDCA != dwErr) {
            PrintStatus("NTAuth failed without CERT_E_UNTRUSTEDCA when revocation checking => ", (LONG) dwErr);
            fResult = FALSE;
        }
    } else if (dwExpectedErr != dwErr) {
        PrintStatus("Expected => ", (LONG) dwExpectedErr);
        PrintStatus("NTAuth failed => ", (LONG) dwErr);
        fResult = FALSE;
    }

    if (CERT_E_UNTRUSTEDCA != dwErr)
        goto CommonReturn;

    pChain = pChainContext->rgpChain[0];
    if (2 > pChain->cElement) {
        printf("NTAuth:: failed => missing CA cert\n");
        goto ErrorReturn;
    }
    pCACert = pChain->rgpElement[1]->pCertContext;

    hNTAuthStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
        0,                  // dwEncodingType
        0,                  // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
        L"NTAuth"
        );
    if (NULL == hNTAuthStore) {
        PrintLastError("CertOpenStore(NTAuth)");
        goto ErrorReturn;
    }

    if (!CertAddCertificateContextToStore(
            hNTAuthStore,
            pCACert,
            CERT_STORE_ADD_NEW,
            &pAddCert
            )) {
        PrintLastError("CertAddCertificateContextToStore(NTAuth CA)");
        goto ErrorReturn;
    }
    // Need to sleep to allow the registry notification to occur.
    Sleep(200);

    // With the CA cert added, the verify policy should succeed
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        fResult = FALSE;
    } else if (0 != PolicyStatus.dwError) {
        if ((CRYPT_E_NO_REVOCATION_CHECK == dwExpectedErr ||
                CRYPT_E_REVOCATION_OFFLINE == dwExpectedErr)
                        &&
                dwExpectedErr == PolicyStatus.dwError) {
            PrintStatus("NTAuth got expected error adding NTAuth CA = ",
                (LONG) dwExpectedErr);
        } else {
            PrintStatus("NTAuth failed after adding NTAuth CA with dwError = ",
                (LONG) PolicyStatus.dwError);
            fResult = FALSE;
        }
    }

    CertDeleteCertificateFromStore(pAddCert);
    pAddCert = NULL;
    // Need to sleep to allow the registry notification to occur.
    Sleep(200);

    // With the CA cert deleted, the verify policy should fail
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        fResult = FALSE;
    } else if (CERT_E_UNTRUSTEDCA != PolicyStatus.dwError) {
        PrintStatus("NTAuth failed without CERT_E_UNTRUSTEDCA after deleting NTAuth CA with dwError = ",
            (LONG) PolicyStatus.dwError);
        fResult = FALSE;
    }

CommonReturn:
    if (hNTAuthStore)
        CertCloseStore(hNTAuthStore, 0);
    return fResult;
ErrorReturn:
    if (pAddCert)
        CertDeleteCertificateFromStore(pAddCert);
    fResult = FALSE;
    goto CommonReturn;
}

BOOL NTAuthNameConstraintVerify(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwExpectedErr
    )
{
    BOOL fResult = FALSE;
    DWORD dwErr;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.dwFlags = CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        goto CommonReturn;
    }
    dwErr = PolicyStatus.dwError;

    if (dwExpectedErr == dwErr) {
        PrintStatus("NTAuthNameConstraint returned expected => ",
            (LONG) dwExpectedErr);
        fResult = TRUE;
    } else {
        PrintStatus("Expected => ", (LONG) dwExpectedErr);
        PrintStatus("NTAuthNameConstraint failed => ", (LONG) dwErr);
    }


CommonReturn:
    return fResult;
}

void DeleteSaferRegKey()
{
    HKEY hKey = NULL;
    LONG err;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_ALL_ACCESS,
            &hKey
            ))) {
        if (ERROR_FILE_NOT_FOUND != err)
            PrintError("RegOpenKey(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegDeleteValueU(hKey, CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME);

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetSaferRegKeyValue(
    IN LPCWSTR pwszValueName,
    IN DWORD dwValue
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            pwszValueName,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}


void SetRootAutoUpdateValue(
    IN DWORD dwValue
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(OCM Subcomponents) failed", (DWORD) err);
        goto CommonReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(RootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetAuthRootAutoUpdateFlags(
    IN DWORD dwSetValue,
    IN BOOL fEnable
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType = 0;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(AuthRootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegQueryValueExU(
        hKey,
        CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
        NULL,       // pdwReserved
        &dwType,
        (BYTE *) &dwValue,
        &cbValue
        );

    if (fEnable)
        dwValue |= dwSetValue;
    else
        dwValue &= ~dwSetValue;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(AuthRootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetProtectedRootsFlags(
    IN DWORD dwSetValue,
    IN BOOL fEnable
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType = 0;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_PROT_ROOT_FLAGS_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(ProtectedRoots) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegQueryValueExU(
        hKey,
        CERT_PROT_ROOT_FLAGS_VALUE_NAME,
        NULL,       // pdwReserved
        &dwType,
        (BYTE *) &dwValue,
        &cbValue
        );

    if (fEnable)
        dwValue |= dwSetValue;
    else
        dwValue &= ~dwSetValue;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_PROT_ROOT_FLAGS_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(ProtectedRootsFlags) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status;
    LONG lStatus;
    DWORD dwDisplayFlags = 0;
    DWORD i;

#define TRUST_TYPE_CERT     1
#define TRUST_TYPE_FILE     2
#define TRUST_TYPE_HTTPS    3
#define TRUST_TYPE_DRIVER   4
    DWORD dwTrustType = TRUST_TYPE_CERT;

    BOOL fChain = FALSE;
    BOOL fChainCallback = FALSE;
    DWORD dwFlags = 0;
    BOOL fQuiet = FALSE;
    LONG lWVTExpected = 0;

    LPSTR pszCertOrFile = NULL;         // not allocated
    LPSTR pszUsageOID = NULL;           // not allocated
    LPSTR pszSignerUsage = szOID_KP_CTL_USAGE_SIGNING;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    GUID wvtHttpsActionID = HTTPSPROV_ACTION;
    GUID wvtDriverActionID = DRIVER_ACTION_VERIFY;
    GUID wvtChainActionID = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;
    GUID *pwvtActionID;

    CRYPT_PROVIDER_DATA *pProvData;     // not allocated

    WINTRUST_FILE_INFO wvtFileInfo;
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = NULL;

#define MAX_CERT_STORE  10
    HCERTSTORE rghStore[MAX_CERT_STORE];

    WINTRUST_CERT_INFO wvtCertInfo;
    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = NULL;
    wvtCertInfo.chStores = 0;
    wvtCertInfo.pahStores = rghStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"Cert Display Name";

    HTTPSPolicyCallbackData httpsPolicyCallbackData;
    memset(&httpsPolicyCallbackData, 0, sizeof(httpsPolicyCallbackData));
    httpsPolicyCallbackData.cbStruct = sizeof(httpsPolicyCallbackData);
    httpsPolicyCallbackData.dwAuthType = AUTHTYPE_CLIENT;
    httpsPolicyCallbackData.fdwChecks = 0;

    DRIVER_VER_INFO DriverVerInfo;
    memset(&DriverVerInfo, 0, sizeof(DriverVerInfo));
    DriverVerInfo.cbStruct = sizeof(DriverVerInfo);

    CERT_CHAIN_PARA ChainPara;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

#define MAX_USAGE_CNT               16
    LPSTR rgpszUsageOID[MAX_USAGE_CNT];
    DWORD cUsageOID = 0;
    DWORD dwUsageType = USAGE_MATCH_TYPE_AND;

#define MAX_POLICY_CNT              16
    LPSTR rgpszPolicyOID[MAX_POLICY_CNT];
    DWORD cPolicyOID = 0;
    DWORD dwPolicyUsageType = USAGE_MATCH_TYPE_AND;

    WTD_GENERIC_CHAIN_POLICY_CREATE_INFO ChainInfo;
    memset(&ChainInfo, 0, sizeof(ChainInfo));
    ChainInfo.cbSize = sizeof(ChainInfo);
    ChainInfo.pChainPara = &ChainPara;

    WTD_GENERIC_CHAIN_POLICY_DATA wtdChainPolicyData;
    memset(&wtdChainPolicyData, 0, sizeof(wtdChainPolicyData));
    wtdChainPolicyData.cbSize = sizeof(wtdChainPolicyData);
    wtdChainPolicyData.pvPolicyArg = (void *) CHAIN_POLICY_ARG;


    WINTRUST_DATA wvtData;
    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = NULL;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    BOOL fDisplayKnownUsages = FALSE;
    BOOL fNTAuth = FALSE;
    BOOL fNTAuthNameConstraint = FALSE;

    BOOL fLogoffNotification = FALSE;

    BOOL fExpectedTrustErrorStatus  = FALSE;
    DWORD dwExpectedTrustErrorStatus = 0;
    BOOL fExpectedTrustInfoStatus  = FALSE;
    DWORD dwExpectedTrustInfoStatus = 0;

    DWORD dwUrlRetrievalTimeout = 0;
    BOOL fCheckRevocationFreshnessTime = FALSE;
    DWORD dwRevocationFreshnessTime;

    BOOL fSafer = FALSE;
    BOOL fMicrosoftRoot = FALSE;
    BOOL fNotMicrosoftRoot = FALSE;


    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "Cert")) {
                wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                dwTrustType = TRUST_TYPE_CERT;
            } else if (0 == _stricmp(argv[0]+1, "File")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_FILE;
            } else if (0 == _stricmp(argv[0]+1, "Driver")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_DRIVER;
            } else if (0 == _stricmp(argv[0]+1, "Https")) {
                wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                dwTrustType = TRUST_TYPE_HTTPS;

            } else if (0 == _stricmp(argv[0]+1, "Chain")) {
                fChain = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "ChainCallback")) {
                fChain = TRUE;
                fChainCallback = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NTAuth")) {
                fNTAuth = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NTAuthNameConstraint")) {
                fNTAuth = TRUE;
                fNTAuthNameConstraint = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "Safer")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_FILE;
                fSafer = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "Client")) {
                httpsPolicyCallbackData.dwAuthType = AUTHTYPE_CLIENT;
            } else if (0 == _stricmp(argv[0]+1, "Server")) {
                httpsPolicyCallbackData.dwAuthType = AUTHTYPE_SERVER;

            } else if (0 == _stricmp(argv[0]+1, "UIAll")) {
                wvtData.dwUIChoice = WTD_UI_ALL;
            } else if (0 == _stricmp(argv[0]+1, "UINone")) {
                wvtData.dwUIChoice = WTD_UI_NONE;
            } else if (0 == _stricmp(argv[0]+1, "UINoBad")) {
                wvtData.dwUIChoice = WTD_UI_NOBAD;
            } else if (0 == _stricmp(argv[0]+1, "UINoGood")) {
                wvtData.dwUIChoice = WTD_UI_NOGOOD;
            } else if (0 == _stricmp(argv[0]+1, "RevokeNone")) {
                wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
            } else if (0 == _stricmp(argv[0]+1, "RevokeChain")) {
                wvtData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;

            } else if (0 == _stricmp(argv[0]+1, "UseIE4Trust")) {
                wvtData.dwProvFlags |= WTD_USE_IE4_TRUST_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoIE4Chain")) {
                wvtData.dwProvFlags |= WTD_NO_IE4_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoUsage")) {
                wvtData.dwProvFlags |= WTD_NO_POLICY_USAGE_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "OrUsage")) {
                dwUsageType = USAGE_MATCH_TYPE_OR;
            } else if (0 == _stricmp(argv[0]+1, "OrPolicy")) {
                dwPolicyUsageType = USAGE_MATCH_TYPE_OR;
            } else if (0 == _stricmp(argv[0]+1, "LifetimeSigning")) {
                wvtData.dwProvFlags |= WTD_LIFETIME_SIGNING_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "MicrosoftRoot")) {
                fMicrosoftRoot = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NotMicrosoftRoot")) {
                fNotMicrosoftRoot = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "DisplayKnownUsages")) {
                fDisplayKnownUsages = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreRevocation")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_REVOCATION;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreUnknownCA")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_UNKNOWN_CA;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreWrongUsage")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_WRONG_USAGE;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreCertDateInvalid")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreCertCNInvalid")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_CERT_CN_INVALID;

            } else if (0 == _stricmp(argv[0]+1, "DontOpenStores")) {
                wvtCertInfo.dwFlags = WTCI_DONT_OPEN_STORES;
            } else if (0 == _stricmp(argv[0]+1, "OpenOnlyRoot")) {
                wvtCertInfo.dwFlags = WTCI_OPEN_ONLY_ROOT;

            } else if (0 == _stricmp(argv[0]+1,
                    "InstallThreadDefaultContext")) {
                fInstallDefaultContext = TRUE;
                dwDefaultContextFlags &= ~CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "InstallProcessDefaultContext")) {
                fInstallDefaultContext = TRUE;
                dwDefaultContextFlags |= CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "AutoReleaseDefaultContext")) {
                dwDefaultContextFlags |=
                    CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "NULLDefaultContext")) {
                fNULLDefaultContext = TRUE;
            } else if (0 == _stricmp(argv[0]+1,
                    "MultiDefaultContext")) {
                fMultiDefaultContext = TRUE;
            } else if (0 == _stricmp(argv[0]+1,
                    "LogoffNotification")) {
                fLogoffNotification = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AuthenticodeFlags")) {
                DWORD dwFlags;

                if (argc < 2 || argv[1][0] == '-') {
                    printf("Option (-AuthenticodeFlags) : missing number argument\n");
                    goto BadUsage;
                }
                dwFlags = strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv += 1;

                SetSaferRegKeyValue(
                    CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, dwFlags);
            } else if (0 == _stricmp(argv[0]+1, "DeleteSaferRegKey")) {
                DeleteSaferRegKey();
            } else if (0 == _stricmp(argv[0]+1, "EnableRootAutoUpdate")) {
                SetRootAutoUpdateValue(0x1);
            } else if (0 == _stricmp(argv[0]+1, "DisableRootAutoUpdate")) {
                SetRootAutoUpdateValue(0x0);
            } else if (0 == _stricmp(argv[0]+1, "EnableUntrustedRootLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisableUntrustedRootLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnablePartialChainLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisablePartialChainLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnableNTAuthRequired")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisableNTAuthRequired")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "RegistryOnlyExit")) {
                goto RegistryOnlyExit;
            } else {
                switch(argv[0][1])
                {
                case 's':
                case 'S':
                    if (wvtCertInfo.chStores >= MAX_CERT_STORE) {
                        printf("Exceed maximum number of stores %d\n",
                            MAX_CERT_STORE);
                        goto BadUsage;
                    }
                    if (NULL == (rghStore[wvtCertInfo.chStores] =
                            OpenSystemStoreOrFile(
                                argv[0][1] == 's',  // fSystemStore
                                argv[0]+2,
                                0                   // dwFlags
                                )))
                        goto BadUsage;
                    wvtCertInfo.chStores++;
                    break;

                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'u':
                    if (MAX_USAGE_CNT <= cUsageOID) {
                        printf("Too many usages\n");
                        goto BadUsage;
                    }
                    if (0 == cUsageOID)
                        pszUsageOID = argv[0]+2;
                    rgpszUsageOID[cUsageOID++] = argv[0]+2;
                    break;
                case 'p':
                    if (MAX_POLICY_CNT <= cPolicyOID) {
                        printf("Too many policies\n");
                        goto BadUsage;
                    }
                    rgpszPolicyOID[cPolicyOID++] = argv[0]+2;
                    break;
                case 'n':
                    httpsPolicyCallbackData.pwszServerName = 
                        AllocAndSzToWsz(argv[0]+2);
                    break;
                case 'f':
                    dwFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'e':
                    fExpectedTrustErrorStatus = TRUE;
                        dwExpectedTrustErrorStatus =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'i':
                    fExpectedTrustInfoStatus = TRUE;
                        dwExpectedTrustInfoStatus =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwUrlRetrievalTimeout = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'r':
                    fCheckRevocationFreshnessTime = TRUE;
                    dwRevocationFreshnessTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'q':
                    fQuiet = TRUE;
                    if (argv[0][2])
                        lWVTExpected = (LONG) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszCertOrFile) {
                printf("Multiple certs or filenames not supported\n");
                goto BadUsage;
            }
            pszCertOrFile = argv[0];
        }
    }

    if (NULL == pszCertOrFile) {
        printf("Missing cert or filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fDisplayKnownUsages) {
        PCCRYPT_OID_INFO *ppOidInfo = NULL;

        if (WTHelperGetKnownUsages(WTH_ALLOC, &ppOidInfo)) {
            for (DWORD i = 0; ppOidInfo[i]; i++)
                printf("Usage[%d]:: OID: %s Name: %S\n",
                    i, ppOidInfo[i]->pszOID, ppOidInfo[i]->pwszName);
            WTHelperGetKnownUsages(WTH_FREE, &ppOidInfo);
        }
    }

    switch (wvtData.dwUnionChoice) {
        case WTD_CHOICE_FILE:
            if (TRUST_TYPE_DRIVER == dwTrustType) {
                pwvtActionID = &wvtDriverActionID;
                wvtData.pPolicyCallbackData = (void *) &DriverVerInfo;
            } else {
                pwvtActionID = &wvtFileActionID;
            }
            wvtData.pFile = &wvtFileInfo;
            wvtFileInfo.pcwszFilePath = AllocAndSzToWsz(pszCertOrFile);
            break;
        case WTD_CHOICE_CERT:
            if (TRUST_TYPE_HTTPS == dwTrustType) {
                pwvtActionID = &wvtHttpsActionID;
                wvtData.pPolicyCallbackData =
                    (void *) &httpsPolicyCallbackData;
            } else {
                pwvtActionID = &wvtCertActionID;
                wvtData.pPolicyCallbackData = (void *) pszUsageOID;
            }
            wvtData.pCert = &wvtCertInfo;
            if (NULL == (wvtCertInfo.psCertContext =
                    (CERT_CONTEXT *) ReadCert(pszCertOrFile)))
                goto ErrorReturn;
            break;
        default:
            goto BadUsage;
    }

    if (fChain) {
        pwvtActionID = &wvtChainActionID;
        if (fChainCallback || dwFlags || cUsageOID || cPolicyOID ||
                0 != dwUrlRetrievalTimeout || fCheckRevocationFreshnessTime) {
            wvtData.pPolicyCallbackData = (void *) &wtdChainPolicyData;
            if (fChainCallback)
                wtdChainPolicyData.pfnPolicyCallback = ChainPolicyCallback;
            if (dwFlags || cUsageOID || cPolicyOID ||
                    0 != dwUrlRetrievalTimeout ||
                    fCheckRevocationFreshnessTime) {
                ChainInfo.dwFlags = dwFlags;
                wtdChainPolicyData.pSignerChainInfo = &ChainInfo;
                wtdChainPolicyData.pCounterSignerChainInfo = &ChainInfo;

                ChainPara.RequestedUsage.dwType = dwUsageType;
                ChainPara.RequestedUsage.Usage.cUsageIdentifier = cUsageOID;
                ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
                        rgpszUsageOID;

                ChainPara.RequestedIssuancePolicy.dwType = dwPolicyUsageType;
                ChainPara.RequestedIssuancePolicy.Usage.cUsageIdentifier =
                    cPolicyOID;
                ChainPara.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier =
                        rgpszPolicyOID;

                ChainPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;
                ChainPara.fCheckRevocationFreshnessTime =
                    fCheckRevocationFreshnessTime;
                ChainPara.dwRevocationFreshnessTime = dwRevocationFreshnessTime;
            }
        }

        if (0 != (dwFlags & CERT_CHAIN_CACHE_END_CERT) &&
                WTD_CHOICE_CERT == wvtData.dwUnionChoice) {
            // Do an extra verify to ensure the cache is loaded on the
            // next call
            wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
            WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

            CertFreeCertificateContext(wvtCertInfo.psCertContext);
            if (NULL == (wvtCertInfo.psCertContext =
                    (CERT_CONTEXT *) ReadCert(pszCertOrFile)))
                goto ErrorReturn;
        }
    }

    if (fExpectedTrustErrorStatus || fExpectedTrustInfoStatus)
        wvtData.dwStateAction = WTD_STATEACTION_VERIFY;
    else if (fQuiet && !fNTAuth)
        wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    else
        wvtData.dwStateAction = WTD_STATEACTION_VERIFY;

    if (fInstallDefaultContext)
        InstallDefaultContext();

    if (fSafer) {
        DWORD dwFlags;
        BOOL fHasValue;
        DWORD dwLastError;

        wvtData.dwProvFlags |= WTD_SAFER_FLAG;
        lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );
        dwLastError = GetLastError();


        fHasValue = I_CryptReadTrustedPublisherDWORDValueFromRegistry(
                CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
                &dwFlags
                );
        printf("AuthenticodeFlags: ");
        if (fHasValue)
            printf("0x%x\n", dwFlags);
        else
            printf("NONE\n");

        dwFlags = 0;
        WintrustGetRegPolicyFlags(&dwFlags);
        printf("WintrustFlags: 0x%x\n", dwFlags);

        PrintStatus("LastError: ", (LONG) dwLastError);

        if (wvtFileInfo.pcwszFilePath) {
            BYTE rgbFileHash[20];
            DWORD cbFileHash = 20;
            ALG_ID HashAlgid = 0;
            LONG lHashStatus;
            PCCRYPT_OID_INFO pOIDInfo;

            lHashStatus = WTHelperGetFileHash(
                wvtFileInfo.pcwszFilePath,
                0,              // dwFlags
                NULL,           // pvReserved
                rgbFileHash,
                &cbFileHash,
                &HashAlgid
                );

            PrintStatus("HashStatus: ", lHashStatus);
            printf("HashAlgid: 0x%x", HashAlgid);
            pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                &HashAlgid,
                CRYPT_HASH_ALG_OID_GROUP_ID
                );
            if (pOIDInfo)
                printf(" %S", pOIDInfo->pwszName);
            
            printf("\n");
            if (cbFileHash) {
                PrintBytes("File Hash:: ", rgbFileHash, cbFileHash);
            }
        }
    } else
        lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

    if (fExpectedTrustErrorStatus || fExpectedTrustInfoStatus) {
        if (NULL == (pProvData = WTHelperProvDataFromStateData(
                wvtData.hWVTStateData))) {
            printf("TrustStatus:: failed => no WVTStateData\n");
            goto ErrorReturn;
        }

        fResult = FALSE;
        if (0 == pProvData->csSigners)
            printf("TrustStatus:: failed => No Signers\n");
        else {
            CRYPT_PROVIDER_SGNR *pProvSign;

            pProvSign = WTHelperGetProvSignerFromChain(
                pProvData,
                0,              // idxSigner
                FALSE,          // fCounterSigner
                0               // idxCounterSigner
                );
            if (pProvSign) {
                const CERT_TRUST_STATUS *pTrustStatus =
                    &pProvSign->pChainContext->TrustStatus;

                fResult = TRUE;
                if (fExpectedTrustErrorStatus) {
                    if (dwExpectedTrustErrorStatus == pTrustStatus->dwErrorStatus) {
                        if (0 != dwExpectedTrustErrorStatus)
                            printf("ChainContext has Expected TrustErrorStatus => 0x%x\n",
                                dwExpectedTrustErrorStatus);
                    } else {
                        fResult = FALSE;
                        printf("Expected => 0x%x ChainContext TrustErrorStatus failed => 0x%x\n",
                            dwExpectedTrustErrorStatus,
                            pTrustStatus->dwErrorStatus
                            );
                    }
                }

                if (fExpectedTrustInfoStatus) {
                    if (dwExpectedTrustInfoStatus == pTrustStatus->dwInfoStatus) {
                        if (0 != dwExpectedTrustInfoStatus)
                            printf("ChainContext has Expected TrustInfoStatus => 0x%x\n",
                                dwExpectedTrustInfoStatus);
                    } else {
                        fResult = FALSE;
                        printf("Expected => 0x%x ChainContext TrustInfoStatus failed => 0x%x\n",
                            dwExpectedTrustInfoStatus,
                            pTrustStatus->dwInfoStatus
                            );
                    }
                }

                if (fMicrosoftRoot || fNotMicrosoftRoot) {
                    // Check if the top level certificate contains the public
                    // key for the Microsoft root.

                    CERT_CHAIN_POLICY_PARA MicrosoftRootPolicyPara;
                    CERT_CHAIN_POLICY_STATUS MicrosoftRootPolicyStatus;

                    memset(&MicrosoftRootPolicyPara, 0,
                        sizeof(MicrosoftRootPolicyPara));
                    MicrosoftRootPolicyPara.cbSize =
                        sizeof(MicrosoftRootPolicyPara);
                    memset(&MicrosoftRootPolicyStatus, 0,
                        sizeof(MicrosoftRootPolicyStatus));
                    MicrosoftRootPolicyStatus.cbSize =
                        sizeof(MicrosoftRootPolicyStatus);

                    if (!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_MICROSOFT_ROOT,
                            pProvSign->pChainContext,
                            &MicrosoftRootPolicyPara,
                            &MicrosoftRootPolicyStatus
                            )) {
                        PrintLastError("CERT_CHAIN_POLICY_MICROSOFT_ROOT");
                    } else {
                        if (fMicrosoftRoot) {
                            if (0 == MicrosoftRootPolicyStatus.dwError)
                                printf("ChainContext has Expected Microsoft Root\n");
                            else
                                printf("failed => not a Microsoft Root\n");
                        }

                        if (fNotMicrosoftRoot) {
                            if (0 != MicrosoftRootPolicyStatus.dwError)
                                printf("ChainContext has Expected Not a Microsoft Root\n");
                            else
                                printf("failed => has a Microsoft Root\n");
                        }
                    }
                }

            } else
                printf("TrustStatus:: failed => no first signer\n");
        }

        wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrust(
            NULL,               // hwnd
            pwvtActionID,
            &wvtData
            );

        if (fResult)
            goto SuccessReturn;
        else
            goto ErrorReturn;
    } else if (fQuiet) {
        if (TRUST_TYPE_DRIVER == dwTrustType) {
            if (DriverVerInfo.pcSignerCertContext) {
                CertFreeCertificateContext(DriverVerInfo.pcSignerCertContext);
            }
        }

        if (fNTAuth) {
            if (NULL == (pProvData = WTHelperProvDataFromStateData(
                    wvtData.hWVTStateData))) {
                printf("NTAuth:: failed => no WVTStateData\n");
                goto ErrorReturn;
            }

            fResult = FALSE;
            if (0 == pProvData->csSigners)
                printf("NTAuth:: failed => No Signers\n");
            else {
                CRYPT_PROVIDER_SGNR *pProvSign;

                pProvSign = WTHelperGetProvSignerFromChain(
                    pProvData,
                    0,              // idxSigner
                    FALSE,          // fCounterSigner
                    0               // idxCounterSigner
                    );
                if (pProvSign) {
                    if (fNTAuthNameConstraint)
                        fResult = NTAuthNameConstraintVerify(
                            pProvSign->pChainContext, (DWORD) lWVTExpected);
                    else
                        fResult = NTAuthVerify(pProvSign->pChainContext,
                            (DWORD) lWVTExpected);
                } else
                    printf("NTAuth:: failed => no first signer\n");
            }

            wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

            if (fResult)
                goto SuccessReturn;
            else
                goto ErrorReturn;
        } else if (lStatus == lWVTExpected) {
            if (ERROR_SUCCESS != lStatus)
                PrintStatus("WinVerifyTrust returned expected => ", lStatus);
            goto SuccessReturn;
        } else {
            PrintStatus("Expected => ", lWVTExpected);
            PrintStatus("WinVerifyTrust(Verify) failed => ", lStatus);
            goto ErrorReturn;
        }
    }

    if (ERROR_SUCCESS != lStatus) {
        PrintStatus("WinVerifyTrust(Verify) failed => ", lStatus);
    }

    if (NULL == (pProvData = WTHelperProvDataFromStateData(
            wvtData.hWVTStateData))) {
        printf("failed => no WVTStateData\n");
        goto ErrorReturn;
    }

    if (pProvData->dwError)
        PrintError("Low Level system error: ", pProvData->dwError);
    for (i = 0; i < pProvData->cdwTrustStepErrors; i++) {
        if (pProvData->padwTrustStepErrors[i]) {
            printf(">>>>>  Step Error [%d] : ", i);
            PrintError("", pProvData->padwTrustStepErrors[i]);
        }
    }

    if (TRUST_TYPE_DRIVER == dwTrustType) {
        if (DriverVerInfo.pcSignerCertContext) {
            CertFreeCertificateContext(DriverVerInfo.pcSignerCertContext);
        }
        printf("Driver version: %S signedBy: %S\n",
            DriverVerInfo.wszVersion, DriverVerInfo.wszSignedBy);
    }
    

    if (0 == pProvData->csSigners)
        printf("No Signers\n");
    else {
        DWORD idxSigner;
        for (idxSigner = 0; idxSigner < pProvData->csSigners; idxSigner++) {
            CRYPT_PROVIDER_SGNR *pProvSign;

            printf("======  Signer [%d]  ======\n", idxSigner);

            pProvSign = WTHelperGetProvSignerFromChain(
                pProvData,
                idxSigner,
                FALSE,          // fCounterSigner
                0               // idxCounterSigner
                );
            if (pProvSign) {
                DWORD idxCounterSigner;

                DisplayPeterSigner(pProvSign, dwDisplayFlags);
                DisplayKirtChain(pProvSign->pChainContext, dwDisplayFlags);
                if (fNTAuth && !fNTAuthNameConstraint)
                    NTAuthVerify(pProvSign->pChainContext, CERT_E_UNTRUSTEDCA);

                for (idxCounterSigner = 0;
                        idxCounterSigner < pProvSign->csCounterSigners;
                                                        idxCounterSigner++) {
                    CRYPT_PROVIDER_SGNR *pProvCounterSign;
                    printf("\n");
                    printf("======  CounterSigner [%d,%d]  ======\n",
                            idxSigner, idxCounterSigner);
                    pProvCounterSign = WTHelperGetProvSignerFromChain(
                        pProvData,
                        idxSigner,
                        TRUE,           // fCounterSigner
                        idxCounterSigner
                        );
                    DisplayPeterSigner(pProvCounterSign, dwDisplayFlags);
                    DisplayKirtChain(pProvCounterSign->pChainContext,
                        dwDisplayFlags);
                }
            }
        }
    }



    wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );
    if (ERROR_SUCCESS != lStatus) {
        PrintStatus("WinVerifyTrust(Close) failed => ", lStatus);
        goto ErrorReturn;
    }
                

SuccessReturn:
    printf("Passed\n");
RegistryOnlyExit:
    status = 0;

CommonReturn:
    if (fLogoffNotification) {
        int c;
        fputs("Waiting to call ChainWlxLogoffEvent ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();

        ChainWlxLogoffEvent(NULL);

        fputs("Finished call ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    if (fInstallDefaultContext)
        FreeDefaultContext();

    while(wvtCertInfo.chStores--) {
        if (!CertCloseStore(wvtCertInfo.pahStores[wvtCertInfo.chStores],
                CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }
    CertFreeCertificateContext(wvtCertInfo.psCertContext);

    TestFree((LPWSTR) wvtFileInfo.pcwszFilePath);
    TestFree(httpsPolicyCallbackData.pwszServerName);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\cryptext.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptext.cpp
//
//  Contents:   Implements
//              1) DllMain, DLLCanUnloadNow, and DLLGetClassObject
//              2) the class factory code
//
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f cryptextps.mk in the project directory.
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------


#include "stdafx.h"
#include <shlobj.h>
#include "initguid.h"
#include "cryptext.h"

#include "cryptext_i.c"

#include "private.h"
#include "CryptPKO.h"
#include "CryptSig.h"

HINSTANCE   g_hmodThisDll = NULL;	// Handle to this DLL itself.


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CryptPKO, CCryptPKO)
	OBJECT_ENTRY(CLSID_CryptSig, CCryptSig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        g_hmodThisDll=hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr=S_OK;

   	// registers object, typelib and all interfaces in typelib
	if(S_OK !=(hr= _Module.RegisterServer(TRUE)))
        return hr;

    //register the entries for the MIME handler
    return RegisterMimeHandler();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    UnregisterMimeHandler();

   	_Module.UnregisterServer();


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tx500str\tx500str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tx500str.cpp
//
//  Contents:   X500 Certificate Name String API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    18-Feb-97   philh   created
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <time.h>

#define ALL_STR_TYPES   0xFFFFFFFF
static BOOL fVerbose = FALSE;

static void FormatAndParseCertNames(
    IN LPCSTR pszCertFilename,
    IN DWORD dwStrType,
    IN BOOL fSubject
    );


static void GetCertNameFromFile(
    IN LPCSTR pszCertFilename,
    IN DWORD dwGetNameStringType,
    IN LPSTR pszAttrOID,
    IN DWORD dwStrType,
    IN BOOL fSubject,
    IN DWORD dwExpectedErr
    );


static void ParseX500Name(
    IN LPCSTR pszName,
    IN DWORD dwStrType,
    IN DWORD dwExpectedErr,
    IN int iExpectedErrOffset
    );

static void ParsePredefinedX500Names();

#define CROW 8
void PrintWords(LPCSTR pszHdr, WORD *pw, DWORD cwSize)
{
    ULONG cw, i;

    while (cwSize > 0)
    {
        printf("%s", pszHdr);
        cw = min(CROW, cwSize);
        cwSize -= cw;
        for (i = 0; i<cw; i++)
            printf(" %04X", pw[i]);
        for (i = cw; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cw; i++)
            if (pw[i] >= 0x20 && pw[i] <= 0x7f)
                printf("%C", pw[i]);
            else
                printf(".");
        pw += cw;
        printf("'\n");
    }
}

static void Usage(void)
{
    int i;

    printf("Usage: tx500str [options]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -n<X500 Name>         - For example \"CN=Joe Cool, O=Microsoft\"\n");
    printf("  -e<number>            - Expected Error\n");
    printf("  -o<number>            - Expected Error Offset\n");
    printf("  -c<Cert Filename>     - Read encoded cert file for names\n");
    printf("  -S                    - Format cert's Subject (default)\n");
    printf("  -I                    - Format cert's Issuer\n");
    printf("  -f<number>            - Name string formatting type\n");
    printf("  -fAll                 - Name string formatting (All types)\n");
    printf("  -v                    - Verbose\n");


    printf("  -g                    - CertGetNameString(SIMPLE_DISPLAY)\n");
    printf("  -g<number>            - CertGetNameString type\n");
    printf("  -a<OID>               - Attribute OID, for example, -a2.5.4.3\n");

    printf("\n");
    printf("Default: Cycle through predefined list of X500 test names\n");
}

int _cdecl main(int argc, char * argv[]) 
{
    LPSTR pszName = NULL;
    LPSTR pszCertFilename = NULL;
    DWORD dwStrType = 0;
    DWORD dwExpectedErr = 0;
    int iExpectedErrOffset = -1;
    BOOL fSubject = TRUE;

    BOOL fGetCertName = FALSE;
    DWORD dwGetNameStringType = CERT_NAME_SIMPLE_DISPLAY_TYPE;
    LPSTR pszAttrOID = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                pszCertFilename = argv[0]+2;
                if (*pszCertFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'n':
                pszName = argv[0]+2;
                if (*pszName == '\0') {
                    printf("Need to specify X500 name\n");
                    goto BadUsage;
                }
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "ALL"))
                        dwStrType = ALL_STR_TYPES;
                    else
                        dwStrType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                } else {
                    printf("Need to specify -fALL or -f<number>\n");
                    goto BadUsage;
                }
                break;
            case 'e':
                if (argv[0][2])
                    dwExpectedErr = (DWORD) strtoul(argv[0]+2, NULL, 0);
                else {
                    printf("Need to specify -e<number>\n");
                    goto BadUsage;
                }
                break;
            case 'o':
                if (argv[0][2])
                    iExpectedErrOffset = strtol(argv[0]+2, NULL, 0);
                else {
                    printf("Need to specify -o<number>\n");
                    goto BadUsage;
                }
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'S':
                fSubject = TRUE;
                break;
            case 'I':
                fSubject = FALSE;
                break;


            case 'g':
                fGetCertName = TRUE;
                if (argv[0][2])
                    dwGetNameStringType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'a':
                pszAttrOID = argv[0]+2;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else
            goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (pszName) {
        printf("Parsing ");
        ParseX500Name(
            pszName,
            dwStrType,
            dwExpectedErr,
            iExpectedErrOffset
            );
    } else if (pszCertFilename) {
        printf("Reading encoded certificate file: %s\n", pszCertFilename);

        if (fGetCertName)
            GetCertNameFromFile(
                pszCertFilename,
                dwGetNameStringType,
                pszAttrOID,
                dwStrType,
                fSubject,
                dwExpectedErr
                );
        else
            FormatAndParseCertNames(
                pszCertFilename,
                dwStrType,
                fSubject
                );
    } else {
        printf("Parsing predefined X500 test names\n", pszName);
        ParsePredefinedX500Names();
    }

CommonReturn:
    return 0;
BadUsage:
    Usage();
    goto CommonReturn;
}

static void *TestDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded
    )
{
    DWORD cbInfo;
    void *pvInfo;
    
    // Set to bogus value. pvInfo == NULL, should cause it to be ignored.
    cbInfo = 0x12345678;
    CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            NULL,                   // pvInfo
            &cbInfo
            );
    if (cbInfo == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d, pvInfo == NULL)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s, pvInfo == NULL)",
                lpszStructType);
        PrintLastError("");
        return NULL;
    }
    if (NULL == (pvInfo = TestAlloc(cbInfo)))
        return NULL;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            pvInfo,
            &cbInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        TestFree(pvInfo);
        return NULL;
    }

    return pvInfo;
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwStrType)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    CERT_NAME_BLOB Name;
    DWORD cwsz;
    LPWSTR pwsz;
    
    if (NULL == (pInfo = (PCERT_NAME_INFO) TestDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            printf("  [%d,%d] %s ValueType: %d\n",
                i, j, pszObjId, pAttr->dwValueType);
            if (pAttr->Value.cbData)
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            else
                printf("    NO Value Bytes\n");
        }
    }

    if (dwStrType == 0xFFFFFFFF)
        goto GoodReturn;
    Name.pbData = pbEncoded;
    Name.cbData = cbEncoded;
    if (0 == (dwStrType & 0xFFFF))
        dwStrType |= CERT_X500_NAME_STR;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        &Name,
        dwStrType,
        NULL,                   // pwsz
        0);                     // cwsz
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        CertNameToStrW(
            dwCertEncodingType,
            &Name,
            dwStrType,
            pwsz,
            cwsz);
        printf("  %S\n", pwsz);
        TestFree(pwsz);
    }

GoodReturn:
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void ParseUnicodeX500Name(
    IN LPCWSTR pwszName,
    IN DWORD dwStrFlags
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    CERT_NAME_BLOB Name;
    DWORD cwsz;
    LPWSTR pwsz;

    printf("Unicode name::\n");
    PrintWords("  ", (WORD *) pwszName, wcslen(pwszName));

    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszName,
        dwStrFlags | 0,             // dwStrType
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &cbEncoded,
        NULL                        // pwszError
        );
    if (!fResult) {
        PrintLastError("CertStrToNameW");
        return;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        return;
    if (!CertStrToNameW(
            dwCertEncodingType,
            pwszName,
            dwStrFlags | 0,             // dwStrType
            NULL,                       // pvReserved
            pbEncoded,
            &cbEncoded,
            NULL                        // pwszError
            ))
        PrintLastError("CertStrToNameW");
    else if (fVerbose)
        DecodeName(pbEncoded, cbEncoded, 0xFFFFFFFF);

    // Decode name to see if we come up with what was passed in
    Name.pbData = pbEncoded;
    Name.cbData = cbEncoded;
    cwsz = CertNameToStrW(
        dwCertEncodingType,
        &Name,
        dwStrFlags | CERT_X500_NAME_STR,
        NULL,                   // pwsz
        0);                     // cwsz
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            dwStrFlags | CERT_X500_NAME_STR,
            pwsz,
            cwsz);
        cwsz--;
        if (cwsz != wcslen(pwszName)) {
            printf("  failed => CertNameToStrW length of %d != %d\n",
                cwsz, wcslen(pwszName));
            PrintWords("  ", (WORD *) pwsz, cwsz);
        } else if (0 != memcmp(pwsz, pwszName, cwsz * sizeof(WCHAR))) {
            printf("  failed => CertNameToStrW didn't match input\n");
            PrintWords("  ", (WORD *) pwsz, cwsz);
        }
        TestFree(pwsz);
    }

    TestFree(pbEncoded);
}

typedef struct _X500_NAMES {
    LPCSTR      pszName;
    DWORD       dwStrType;
    DWORD       dwErr;          // 0 => expect success
    int         iErrOffset;     // -1 => expect NULL pszError
} X500_NAMES, *PX500_NAMES;

//             1         2         3         4         5         6
//   0123456789012345678901234567890123456789012345678901234567890

static const X500_NAMES rgX500Names[] = {
    "CN=Joe Cool", 0, 0, -1,
    "CN=Joe Cool;", 0, 0, -1,
    "CN=Joe Cool,", 0, 0, -1,
    "CN=Joe Cool+   ", 0, 0, -1,
    "Cn=Joe Cool+T= +   ", 0, 0, -1,
    "cn=Joe Cool+t= ,   ", 0, 0, -1,
    "cn=\"Joe Cool ,;+\"\"-#\t<>=\"", 0, 0, -1,
    "cN=Joe Cool + T = Programmer; OU= Micro  , OiD.1.2.3.4=#01 02", 0, 0, -1,
    "  1.2.3.4  =  #  0123456789abcdef 13  + SN = wow", 0, 0, -1,
    "1.2.3.4=\"# 0123456789abcdef 13 string not octet\"  + oid.1.2.3.4.1=#0123456789abcdef13 + SN = wow", 0, 0, -1,
    "oiD.1.2.3.4.5=#12\t34  \t45  \t 78;1.2.3=#45; 1.2.3.1=#87", 0, 0, -1,
    
    "C=US; L=Internet; St=Washington + Street=Microsoft Way", 0, 0, -1,
    "C=U#; L=Internet; Street=Microsoft Way", 0,
        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, 3,
    "Email=joeC@microsoft.com", 0, 0, -1,
    "Email=joe\xB0oeC@microsoft.com", 0,
        (DWORD) CRYPT_E_INVALID_IA5_STRING, 9,
    "C=US; OU=Microsoft; St=Way +  L= Internet + Email=joe\xB0oeC@microsoft.com",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 53,
    "C=US; OU=Microsoft; St=Way +  L= Internet + Email=joejoeC@microsoft.com",
        0, 0, -1,
    "Email=\"\"\"Cool\"\" Guy\xB0@microsoft.com\"",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 19,
    "C=US; OU=Microsoft; St=Way +  L= Internet +  Email=\"\"\"Cool\"\" Guy\xB0@microsoft.com\"",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 64,
    "C=US; OU=Microsoft; St=Way +  L= Internet +  Email=\"\"\"Cool\"\" Guy@microsoft.com\"",
        0, 0, -1,
    "T = Numeric ; 2.5.4.24=0123456789 0123456789", 0, 0, -1,
    "T = Bad Numeric ; 2.5.4.24=0123456789abcdef 0123456789",
        0, (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, 37,
    "  CN  =  \" Joe \"\"Cool\"\"\"    ", 0, 0, -1,
    "  CN  =  \"   Joe \"\"Cool\"\"    \"  ;T=quoted lead and trail spaces  ",
        0, 0, -1,
    "CN  =  Joe \"Cool\"   ", (DWORD) CERT_NAME_STR_NO_QUOTING_FLAG, 0, -1,
    "CN=Joe \"\"Cool\"\"   ", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 7,
    "  CN  =  \"Joe \"\"Cool\"\"   ", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 9,
    "CM=Joe Cool", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 0,
    "Cn=Joe Cool, Ox=wrong",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 13,
    "OID.1.2=#01 02 g", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 8,
    "1.2=# ; T= empty ascii hex", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 4,
    "OID.1.2=#00; OID.1..3.1=#01; T=Consecutive dots",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 13,
    "1.2=#f; T= Odd ascii hex", 0, 0, -1,
    "1.2=#12e; T= Odd ascii hex", 0, 0, -1,

    "CN = Joe, Cool ; OU = Microsoft, xyz; T=CERT_NAME_STR_SEMICOLON_FLAG",
        CERT_NAME_STR_SEMICOLON_FLAG, 0, -1,
    "CN = Joe, Cool ; OU = Microsoft, xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe; Cool , OU = Microsoft; xyz, T=CERT_NAME_STR_COMMA_FLAG",
        CERT_NAME_STR_COMMA_FLAG, 0, -1,
    "CN = Joe; Cool , OU = Microsoft; xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe, Cool ; More stuff  \n  OU = Microsoft; xyz \nT=CERT_NAME_STR_CRLF_FLAG",
        CERT_NAME_STR_CRLF_FLAG, 0, -1,
    "CN = Joe, Cool ; More stuff  \n  OU = Microsoft; xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe Cool + more cool  ; L= Wa + more local; T=CERT_NAME_STR_NO_PLUS_FLAG",
        CERT_NAME_STR_NO_PLUS_FLAG, 0, -1,
    "CN = Joe Cool + more cool  ; L= Wa + more local;",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 16,
    "CN = Joe Cool , OU = Microsoft  xyz  T=IgnoredEqualDelimiter",
        0, 0, -1,

    "CN = Joe Cool; T=CERT_SIMPLE_NAME_STR",
        CERT_SIMPLE_NAME_STR, (DWORD) E_INVALIDARG, -1,

    "CN=xyz; =; T=EmptyX500Key",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 8,
    "O", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 0,
    "", 0, 0, -1
};
#define NX500NAMES (sizeof(rgX500Names) / sizeof(rgX500Names[0]))

static void ParsePredefinedX500Names()
{
    // Note, fffe and ffff aren't valid UTF8 characters
    LPWSTR pwszUnicodeName =
        L"DC=microsoft, "
        L"DC=com, "
        L"DC=\x0001 \x0002 \x007e \x007f, "
        L"DC=\x0080 \x0081 \x07fe \x07ff, "
        L"DC=\x0800 \x0801 \xfffc \xfffd, "
        L"CN=UNICODE, "
        L"OID.1.2.3.1=\x0001 \x0002 \x007e \x007f, "
        L"OID.1.2.3.2=\x0080 \x0081 \x07fe \x07ff, "
        L"OID.1.2.3.3=\x0800 \x0801 \xfffc \xfffd"
        ;

    WCHAR rgwszUnicode[3 + 1 + 0xFFFC + 1 + 1 + 1];
    DWORD i;
    DWORD j;

    wcscpy(rgwszUnicode, L"CN=\"");
    j = 4;
    for (i = 1; i <= 0xFF; i++) {
        rgwszUnicode[j++] = (WCHAR) i;
        if ((WCHAR) i == L'\"')
            rgwszUnicode[j++] = L'\"';
    }
    for (i = 0x7E0; i <= 0x820; i++)
        rgwszUnicode[j++] = (WCHAR) i;

    for (i = 0xFFE0; i <= 0xFFFD; i++)
        rgwszUnicode[j++] = (WCHAR) i;

    rgwszUnicode[j] = L'\0';

    wcscat(rgwszUnicode, L"\"");


    for (i = 0; i < NX500NAMES; i++)
        ParseX500Name(
            rgX500Names[i].pszName,
            rgX500Names[i].dwStrType,
            rgX500Names[i].dwErr,
            rgX500Names[i].iErrOffset
            );

    for (i = 0; i < NX500NAMES; i++)
        ParseX500Name(
            rgX500Names[i].pszName,
            rgX500Names[i].dwStrType | CERT_NAME_STR_REVERSE_FLAG,
            rgX500Names[i].dwErr,
            rgX500Names[i].iErrOffset
            );

    ParseUnicodeX500Name(pwszUnicodeName, 0);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName, 
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);

    ParseUnicodeX500Name(rgwszUnicode, 0);
    ParseUnicodeX500Name(rgwszUnicode,
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
    ParseUnicodeX500Name(rgwszUnicode,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
}


static void ParseX500Name(
    IN LPCSTR pszName,
    IN DWORD dwStrType,
    IN DWORD dwExpectedErr,
    IN int iExpectedErrOffset
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    LPCSTR pszError;

    printf("<%s>\n", pszName);
    fResult = CertStrToNameA(
        dwCertEncodingType,
        pszName,
        dwStrType,
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &cbEncoded,
        &pszError
        );
    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
        if (pszError) {
            int iErrOffset = (int)(INT_PTR) (pszError - pszName);
            LPSTR pszNameErr = (LPSTR) _alloca(iErrOffset + 1 + 1);
            memcpy(pszNameErr, pszName, iErrOffset + 1);
            pszNameErr[iErrOffset + 1] = '\0';
            printf("  Error at offset %d  <%s\n", iErrOffset, pszNameErr);
            if (iExpectedErrOffset < 0)
                printf("  failed => unexpected error offset\n");
            else if (iExpectedErrOffset != iErrOffset)
                printf("  failed => expected error offset %d\n",
                    iExpectedErrOffset);
        } else if (iExpectedErrOffset >= 0)
            printf("  failed => expected error offset %d\n",
                iExpectedErrOffset);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else {
        if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
            return;
        if (!CertStrToNameA(
                dwCertEncodingType,
                pszName,
                dwStrType,
                NULL,                       // pvReserved
                pbEncoded,
                &cbEncoded,
                &pszError
                ))
            PrintLastError("CertStrToName");
        else {
            if (pszError != NULL)
                printf("  failed => expected NULL pszError\n");
            if (fVerbose)
                DecodeName(pbEncoded, cbEncoded, dwStrType);
        }
        TestFree(pbEncoded);
    }
}

static LPWSTR NameToStr(
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType
    )
{
    DWORD cwsz;
    LPWSTR pwsz;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        pName,
        dwStrType,
        NULL,                   // pwsz
        0);                     // cwsz
    if (cwsz <= 1) {
        PrintLastError("CertNameToStr");
        return NULL;
    }
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        cwsz = CertNameToStrW(
            dwCertEncodingType,
            pName,
            dwStrType,
            pwsz,
            cwsz);
    }
    return pwsz;
}

static BOOL StrToName(
    IN LPCWSTR pwszName,
    IN DWORD dwStrType,
    OUT PCERT_NAME_BLOB pName
    )
{
    BOOL fResult;
    LPCWSTR pwszError;
    memset(pName, 0, sizeof(*pName));

    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszName,
        dwStrType,
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &pName->cbData,
        &pwszError
        );
    if (!fResult) {
        PrintLastError("CertStrToNameW");

        if (pwszError) {
            int iErrOffset = (int)(INT_PTR) (pwszError - pwszName);
            LPWSTR pwszNameErr = (LPWSTR) _alloca((iErrOffset + 1 + 1) * 2);
            memcpy(pwszNameErr, pwszName, (iErrOffset + 1) * 2);
            pwszNameErr[iErrOffset + 1] = L'\0';
            printf("Error at <%S\n", pwszNameErr);
        }

        return FALSE;
    }

    if (NULL == (pName->pbData = (BYTE *) TestAlloc(pName->cbData)))
        return FALSE;
    fResult = CertStrToNameW(
            dwCertEncodingType,
            pwszName,
            dwStrType,
            NULL,                       // pvReserved
            pName->pbData,
            &pName->cbData,
            NULL                        // pwszError
            );
    if (!fResult) {
        PrintLastError("CertStrToNameW");
        TestFree(pName->pbData);
        pName->pbData = NULL;
        return FALSE;
    }

    return TRUE;
}

static void FormatAndParseName(
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType
    )
{
    LPWSTR pwszName = NULL;
    CERT_NAME_BLOB Name2;
    memset(&Name2, 0, sizeof(Name2));
    LPWSTR pwszName2 = NULL;

    pwszName = NameToStr(pName, dwStrType);
    if (NULL == pwszName)
        goto ErrorReturn;
    printf("<%S>\n", pwszName);
    if (!StrToName(pwszName, dwStrType, &Name2))
        goto ErrorReturn;

    pwszName2 = NameToStr(&Name2, dwStrType);
    if (NULL == pwszName2)
        goto ErrorReturn;
    if (wcslen(pwszName) != wcslen(pwszName2) ||
            0 != wcscmp(pwszName, pwszName2)) {
        printf("failed => re-formatted name mismatch\n");
        printf("Re-formatted::\n");
        printf("<%S>\n", pwszName2);
    }

    if (pName->cbData != Name2.cbData ||
            0 != memcmp(pName->pbData, Name2.pbData, Name2.cbData)) {
        printf("failed => re-encoded name mismatch\n");
        printf("Input::\n");
        PrintBytes("    ", pName->pbData, pName->cbData);
        DecodeName(pName->pbData, pName->cbData, 0xFFFFFFFF);
        printf("Re-encoded::\n");
        PrintBytes("    ", Name2.pbData, Name2.cbData);
        DecodeName(Name2.pbData, Name2.cbData, 0xFFFFFFFF);
    }


ErrorReturn:
    if (pwszName)
        TestFree(pwszName);
    if (pwszName2)
        TestFree(pwszName2);
    if (Name2.pbData)
        TestFree(Name2.pbData);
}


    
static void FormatAndParseCertNames(
    IN LPCSTR pszCertFilename,
    IN DWORD dwStrType,
    IN BOOL fSubject
    )
{
    CERT_BLOB Cert;
    PCCERT_CONTEXT pCertContext = NULL;
    PCERT_NAME_BLOB pName;
    static DWORD rgdwStrType[] = {
        CERT_OID_NAME_STR,
        CERT_X500_NAME_STR,
        CERT_OID_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
            CERT_NAME_STR_NO_QUOTING_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_NO_QUOTING_FLAG |
            CERT_NAME_STR_CRLF_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
            CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG,
        0
    };
    DWORD *pdwStrType;
    
    
    if (!ReadDERFromFile(pszCertFilename, &Cert.pbData, &Cert.cbData))
        return;

    if (NULL == (pCertContext = CertCreateCertificateContext(
            dwCertEncodingType, Cert.pbData, Cert.cbData))) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    if (fSubject) {
        printf("Subject::\n");
        pName = &pCertContext->pCertInfo->Subject;
    } else {
        printf("Issuer::\n");
        pName = &pCertContext->pCertInfo->Issuer;
    }

    if (fVerbose)
        DecodeName(pName->pbData, pName->cbData, 0xFFFFFFFF);

    if (dwStrType != 0xFFFFFFFF) {
        if (dwStrType == 0)
            dwStrType = CERT_X500_NAME_STR;
        FormatAndParseName(pName, dwStrType);
    } else {
        pdwStrType = rgdwStrType;
        while (dwStrType = *pdwStrType++) {
            FormatAndParseName(pName, dwStrType);
            printf("\n");
        }
    }

ErrorReturn:
    CertFreeCertificateContext(pCertContext);
    TestFree(Cert.pbData);
}

static void GetCertNameFromFile(
    IN LPCSTR pszCertFilename,
    IN DWORD dwGetNameStringType,
    IN LPSTR pszAttrOID,
    IN DWORD dwStrType,
    IN BOOL fSubject,
    IN DWORD dwExpectedErr
    )
{
    CERT_BLOB Cert;
    PCCERT_CONTEXT pCertContext = NULL;
    LPWSTR pwsz = NULL;
    LPSTR psz = NULL;
    DWORD cch;
    DWORD dwFlags;
    void *pvTypePara;

    dwFlags = dwGetNameStringType &  0xFFFF0000;
    dwGetNameStringType &= 0x0000FFFF;
    switch (dwGetNameStringType) {
        case CERT_NAME_RDN_TYPE:
            pvTypePara = &dwStrType;
            break;
        case CERT_NAME_ATTR_TYPE:
            pvTypePara = pszAttrOID;
            break;
        default:
            pvTypePara = NULL;
    }

    if (!ReadDERFromFile(pszCertFilename, &Cert.pbData, &Cert.cbData))
        return;

    if (NULL == (pCertContext = CertCreateCertificateContext(
            dwCertEncodingType, Cert.pbData, Cert.cbData))) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    if (fSubject) {
        printf("Unicode Subject::\n");
        dwFlags |= 0;
    } else {
        printf("Unicode Issuer::\n");
        dwFlags |= CERT_NAME_ISSUER_FLAG;
    }

    cch = CertGetNameStringW(
        pCertContext,
        dwGetNameStringType,
        dwFlags,
        pvTypePara,
        NULL,                   // pwsz
        0);                     // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("  CertGetNameStringW returned empty string\n");
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            dwGetNameStringType,
            dwFlags,
            pvTypePara,
            pwsz,
            cch);
        printf("  <%S>\n", pwsz);
    }

    if (!fVerbose)
        goto CommonReturn;

    if (fSubject) {
        printf("ASCII Subject::\n");
        dwFlags = 0;
    } else {
        printf("ASCII Issuer::\n");
        dwFlags = CERT_NAME_ISSUER_FLAG;
    }

    cch = CertGetNameStringA(
        pCertContext,
        dwGetNameStringType,
        dwFlags,
        pvTypePara,
        NULL,                   // psz
        0);                     // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("  CertGetNameStringA returned empty string\n");
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else if (psz = (LPSTR) TestAlloc(cch)) {
        cch = CertGetNameStringA(
            pCertContext,
            dwGetNameStringType,
            dwFlags,
            pvTypePara,
            psz,
            cch);
        printf("  <%s>\n", psz);
    }


CommonReturn:
ErrorReturn:
    CertFreeCertificateContext(pCertContext);
    TestFree(Cert.pbData);
    TestFree(pwsz);
    TestFree(psz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\passrec\passrec.c ===
//
//  keymigrt.c
//
//  Copyright (c) Microsoft Corp, 2000
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <shlobj.h>

#include <wincrypt.h>
#define SECURITY_WIN32
#include <security.h>
#include <secext.h>
#include "passrec.h"

#include <stdio.h>



extern BOOL GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid);

extern DWORD GetLocalSystemToken(HANDLE* phRet);


void Usage();


int __cdecl wmain(int cArg, wchar_t *rgszArg[])
{

    DWORD dwBehavior = 0;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HANDLE      hToken = NULL;
    int i;

    LPWSTR wszFilename = NULL;

    LPWSTR wszPassword = NULL;

    BOOL   fGenerate = FALSE;

    PSID pCurrentSid = NULL;
    DWORD cbCurrentSid = 0;

    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    WCHAR UserNameBuffer[MAX_PATH];

    PBYTE pbRecoveryPrivate = NULL;

    DWORD cbRecoveryPrivate = 0;
    HANDLE hPrivate = INVALID_HANDLE_VALUE;



    if(cArg < 2)
    {
        Usage();
    }

    // Parse command line

    for(i=1; i < cArg; i++)
    {
        LPWSTR szCurrentArg = rgszArg[i];

        if((*szCurrentArg != L'-') &&
           (*szCurrentArg != L'/'))
        {
            Usage();
            goto error;
        }
        szCurrentArg++;

        while(*szCurrentArg)
        {
        
            switch(*szCurrentArg++)
            {
                case L'n':
                case L'N':
                    if(cArg < i+2)
                    {
                        Usage();
                        goto error;
                    }
                    if(*szCurrentArg)
                    {
                        if(cArg < i+1)
                        {
                            Usage();
                            goto error;
                        }

                        wszFilename = szCurrentArg;
                    }
                    else
                    {
                        if(cArg < i+2)
                        {
                            Usage();
                            goto error;
                        }
                        i++;
                        wszFilename = rgszArg[i];
                    }
                    i++;
                    wszPassword = rgszArg[i];
                    fGenerate = TRUE;
                    break;
            
                case L'r':
                case L'R':
                    if(cArg < i+1)
                    {
                        Usage();
                        goto error;
                    }
                    if(*szCurrentArg)
                    {
                        wszFilename = szCurrentArg;
                    }
                    else
                    {
                        if(cArg < i+1)
                        {
                            Usage();
                            goto error;
                        }
                        i++;
                        wszFilename = rgszArg[i];
                    }
                    break;

                default:
                    Usage();
                    goto error;
            }

            
        }
    }

    
    if(fGenerate)
    {
    
     
        ULONG Length = MAX_PATH;


        Password.Buffer = wszPassword;
        Password.Length = wcslen(wszPassword)*sizeof(WCHAR);
        Password.MaximumLength = Password.Length + sizeof(WCHAR);

        UserName.Buffer = UserNameBuffer;
        UserName.Length = MAX_PATH;
        UserName.MaximumLength = MAX_PATH*sizeof(WCHAR);

        if(!GetUserNameW(UserNameBuffer, &Length))
        {
            dwError = GetLastError();
            printf("Could not get user name:%lx\n", dwError);
            goto error;
        }
        UserName.Length = (USHORT)Length*sizeof(WCHAR);


        if(!GetUserSid(NULL,
           &pCurrentSid,
           &cbCurrentSid))
        {
            printf("Could not get user sid:%lx\n", dwError);
            dwError = GetLastError();
            goto error;

        }
        dwError = GetLocalSystemToken(&hToken);
        if(ERROR_SUCCESS != dwError)
        {
            printf("Could not retrieve local system token:%lx\n", dwError);
            goto error;
        }

        if(!ImpersonateLoggedOnUser(hToken))
        {
            dwError = GetLastError();
            printf("Could not impersonate local system:%lx\n", dwError);
            goto error;

        }


        dwError = PRGenerateRecoveryKey(
                           pCurrentSid,
                           &UserName,
                           &Password,
                           &pbRecoveryPrivate,
                           &cbRecoveryPrivate);

        RevertToSelf();

        if(ERROR_SUCCESS != dwError)
        {
            printf("Could not generate recovery key:%lx\n", dwError);
            goto error;
        }


        hPrivate = CreateFileW(wszFilename, 
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               0,
                               NULL);
        if(INVALID_HANDLE_VALUE == hPrivate)
        {
            dwError = GetLastError();
            printf("Could not open recovery key file:%lx\n", dwError);
            goto error;
        }

        if(!WriteFile(hPrivate, pbRecoveryPrivate, cbRecoveryPrivate, &cbRecoveryPrivate, NULL))
        {
            dwError = GetLastError();
            printf("Could not write recovery key file:%lx\n", dwError);
            goto error;
        }


    }
    else
    {

        if(!ImpersonateSelf(SecurityImpersonation))
        {
            dwError = GetLastError();
            printf("Could not impersonate self:%lx\n", dwError);
            goto error;

        }

        hPrivate = CreateFileW(wszFilename, 
                               GENERIC_READ,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);
        if(INVALID_HANDLE_VALUE == hPrivate)
        {
            dwError = GetLastError();
            printf("Could not open recovery key file:%lx\n", dwError);
            goto error;
        }

        cbRecoveryPrivate = GetFileSize(hPrivate, NULL);

        if(-1 == cbRecoveryPrivate)
        {
            dwError = GetLastError();
            printf("Could not retrieve recovery key file size:%lx\n", dwError);
            goto error;

        }

        pbRecoveryPrivate = (PBYTE)LocalAlloc(LMEM_FIXED, cbRecoveryPrivate);

        if(NULL == pbRecoveryPrivate)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            printf("Memory allocation failure:%lx\n", dwError);
            goto error;
        }

        if(!ReadFile(hPrivate, pbRecoveryPrivate, cbRecoveryPrivate, &cbRecoveryPrivate, NULL))
        {
            dwError = GetLastError();
            printf("Could not read recovery key file:%lx\n", dwError);
            goto error;
        }


        dwError = PRRecoverPassword(
                                    pbRecoveryPrivate,
                                    cbRecoveryPrivate,
                                    &Password);

        if(ERROR_SUCCESS == dwError)
        {
            printf("Recovered Password: %S\n", Password.Buffer);
            ZeroMemory(Password.Buffer, Password.MaximumLength);
            LocalFree(Password.Buffer);
        }

        RevertToSelf();
    }


error:

    if(hToken)
    {
        CloseHandle(hToken);
    }

    if(hPrivate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPrivate);
    }
    if(pbRecoveryPrivate)
    {
        ZeroMemory(pbRecoveryPrivate, cbRecoveryPrivate);

        LocalFree(pbRecoveryPrivate);
    }

    if(pCurrentSid)
    {
        LocalFree(pCurrentSid);
    }



    return (ERROR_SUCCESS == dwError)?0:-1;

}


void Usage()
{
    printf("Password Recovery Utility\n");
    printf("Usage: passrec -n filename password\n");
    printf("       passrec -r filename \n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\passrec\systok.cpp ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define TERROR(msg)          LogError(__FILE__, __LINE__, msg)
#define TERRORVAL(msg, val)  LogErrorVal(__FILE__, __LINE__, msg, val)
#define TCOMMENT(msg)        LogComment(msg)
#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)
#define CHECK_NULL(s)        if (s == NULL) \
                                LogError(__FILE__, __LINE__, L"## CHECK_NULL ##")

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  Error Logging Functions  # defined as follows to include
//  Line and FILE macros:
//
//  TERROR       -   LogError()
//  TERRORVAL    -   LogErrorVal()
//
//

void
LogError(LPSTR szFile,
         int iLine,
         LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    swprintf(buffer, L"ERROR Line: %i -> %s\n", iLine, wszMsg);
    OutputDebugStringW(buffer);
    wprintf(buffer);


}

void
LogErrorVal(LPSTR  szFile,
            int    iLine,
            LPWSTR wszMsg,
            DWORD  dwVal)
{

    WCHAR buffer[256]; // this should be adequate.
    swprintf(buffer, L"%s Error:: %x", wszMsg, dwVal);
    LogError(szFile, iLine, buffer);
}

void
LogComment(LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    OutputDebugStringW(wszMsg);
    wprintf(wszMsg);
}



void 
DumpBin(CRYPT_DATA_BLOB hash)
{

    WCHAR buff[256], out[256];
    ULONG cb;

    swprintf(out, L"");
    while (hash.cbData > 0) {
        cb = min(4, hash.cbData);
        hash.cbData -= cb;
        for (; cb > 0; cb--, hash.pbData++) {
            swprintf(buff, L"%02X", *hash.pbData);
            wcscat(out, buff);
        }
        wcscat(out, L" ");
    }
    
    wcscat(out, L"\n");

    TCOMMENT(out);
}
//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) 
    {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}


//
//  DataFree()
//
//  Utility for freeing array of DATA_BLOB structs
//
void
DataFree(DATA_BLOB* arDataBlob, 
         BOOL       fCryptAlloc)
{

    if (arDataBlob == NULL) return; // not alloc'd
    
    for (DWORD i = 0; i < MAX_BLOBS;i++) {

        if (arDataBlob[i].pbData != NULL) {
            
            if (!fCryptAlloc) { 
                MyFree(arDataBlob[i].pbData);
            } else { // Data member alloc'd by DataProtect call
                LocalFree(arDataBlob[i].pbData);
            }
        }
       
    }

    MyFree(arDataBlob);
}

    


BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
extern "C" BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
extern "C" DWORD
GetLocalSystemToken(HANDLE* phRet)
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (to) failed!");
        return E_FAIL;
    }

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed!", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            *phRet = hPDupToken;
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\txenrol\txenrol.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:	txenrol.cpp
//
//  Contents:	XEnroll C++ Tests
//
//  History:	03-Nov-97	keithv	Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "xenroll.h"
#include "unicode.h"

#define SECURITY_WIN32
#include <security.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <malloc.h>

#define NO_OSS_DEBUG
#include <dbgdef.h>

//globals
char *g_pszDNName = NULL;
char *g_pszCAXchgFileName = NULL;
char *g_pszCMCFileName = NULL;
char *g_pszCMCResponseFileName = NULL;
char *g_pszKeyContainer = NULL;
DWORD g_cStress = 1;
DWORD g_dwTestID = MAXDWORD;
BOOL  g_fPause = FALSE;
BOOL  g_fVerb = FALSE;
char *g_pszPKCS7FileName = NULL;
char *g_pszPFXFileName = NULL;
char *g_pszPFXPassword = NULL;

#define TXEnrollLocalScope(ScopeName) struct ScopeName##TheLocalScope { public
#define TXEnrollEndLocalScope } local

#define HASHFROMCERT(a, b) CryptHashCertificate(NULL, 0, X509_ASN_ENCODING, (a)->pbCertEncoded, (a)->cbCertEncoded, (b)->pbData, &(b)->cbData)

#define PRINT_ERROR(Error)              \
Error##:                                 \
    printf("failed => %s, Error = %08x\n", #Error, GetLastError()); \
    goto ERROR_RETURN_LABEL;

#define PRINT_ERROR2(Error, hr)              \
Error##:                                 \
    printf("failed => %s, Error = 0x%08x\n", #Error, (hr)); \
    goto ERROR_RETURN_LABEL;

#define PRINT_ERROR_IF(Error, hr, condition) \
Error##: \
    { \
        if (condition) { \
            printf("failed => %s, Error = 0x%08x\n", #Error, (hr)); \
        } \
        goto ERROR_RETURN_LABEL; \
    }

static BOOL B64EncodeBlob(PCRYPT_DATA_BLOB pBlob, PCRYPT_DATA_BLOB pBlobB64) {

    DWORD   cchBlob     = 0;
    DWORD   err         = ERROR_SUCCESS;

    assert(pBlobB64 != NULL  &&  pBlob != NULL);
    memset(pBlobB64, 0, sizeof(CRYPT_DATA_BLOB));

    // base64 encode the cert
    if (CryptBinaryToStringW(
            pBlob->pbData,
            pBlob->cbData,
            CRYPT_STRING_BASE64,
            NULL,
            &cchBlob))
    {
        pBlobB64->pbData = (PBYTE) malloc(cchBlob * sizeof(WCHAR));
        
        if(pBlobB64->pbData == NULL)
            err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        err = GetLastError();
        assert(ERROR_SUCCESS != err);
    }

    if(err == ERROR_SUCCESS) {
        if (!CryptBinaryToStringW(
            pBlob->pbData,
            pBlob->cbData,
            CRYPT_STRING_BASE64,
            (LPWSTR) pBlobB64->pbData,
            &cchBlob))
        {
            err = GetLastError();
            assert(ERROR_SUCCESS != err);
        }
    }

    if(err != ERROR_SUCCESS) {
        SetLastError(err);
        memset(pBlobB64, 0, sizeof(CRYPT_DATA_BLOB));
        return(FALSE);
    }

    pBlobB64->cbData = cchBlob * sizeof(WCHAR);
    return(TRUE);

}

static BOOL BSTREncodeBlob(PCRYPT_DATA_BLOB pBlob, BSTR * pbstr) {

    CRYPT_DATA_BLOB blob64;
    BOOL            fRet    = TRUE;
    
    assert(pbstr != NULL);
    memset(&blob64, 0, sizeof(CRYPT_DATA_BLOB));

    if( !B64EncodeBlob(pBlob, &blob64) )
        return(FALSE);
        
    if( NULL == (*pbstr = SysAllocStringByteLen((LPCSTR) blob64.pbData, blob64.cbData)) )
        fRet = FALSE;

    if(blob64.pbData != NULL)
        free(blob64.pbData);

    return(fRet);
}


static HRESULT GetCertificateContextPropertySimple(IN  PCCERT_CONTEXT    pCertContext, 
						   IN  DWORD             dwPropID,
						   OUT PCRYPT_DATA_BLOB  dataBlob)
{
    BOOL fDone = FALSE;
    dataBlob->pbData = NULL; 
    dataBlob->cbData = 0x150; 
    
    do { 
	if (dataBlob->pbData != NULL) { LocalFree(dataBlob->pbData); } 
	
	dataBlob->pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob->cbData);
	if (dataBlob->pbData == NULL) { return E_OUTOFMEMORY; } 
	
	if (!CertGetCertificateContextProperty
	    (pCertContext, 
	     dwPropID, 
	     (LPVOID)dataBlob->pbData, 
	     &(dataBlob->cbData)))
	{
	    if (GetLastError() != ERROR_MORE_DATA)
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else 
	{
	    fDone = TRUE;
	}
    } while (!fDone); 
    
    return S_OK;
}


static HRESULT ResyncIEnrollRequestStore(IN OUT IEnroll4 **ppIEnroll4)
{
    CRYPT_DATA_BLOB  hashBlob; 
    HRESULT          hr; 

    ZeroMemory(&hashBlob,   sizeof(hashBlob)); 
 
   
    // Get the thumbprint of the created request. 
    if (S_OK != (hr = (*ppIEnroll4)->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = (*ppIEnroll4)->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
 
    (*ppIEnroll4)->Release(); 

    if (NULL == (*ppIEnroll4 = PIEnroll4GetNoCOM()))
        goto PIEnroll4GetNoCOMError;

    if (S_OK != (hr = (*ppIEnroll4)->put_ThumbPrintWStr(hashBlob)))
        goto put_ThumbPrintWStrError; 

    hr = S_OK; 
 ErrorReturn:
    return hr; 

TRACE_ERROR(get_ThumbPrintWStrError); 
SET_HRESULT(MemoryError,              E_OUTOFMEMORY); 
SET_HRESULT(PIEnroll4GetNoCOMError,   HRESULT_FROM_WIN32(GetLastError())); 
TRACE_ERROR(put_ThumbPrintWStrError); 
}

static HRESULT FindPendingRequest(IN  IEnroll4         *pIEnroll4,
				  IN  PCCERT_CONTEXT    pCertContext, 
                                  IN  HRESULT           hrExpected, 
				  OUT LONG             *plIndex)
{
    CRYPT_DATA_BLOB hashBlob; 
    CRYPT_DATA_BLOB hashBlobExpected; 
    HRESULT         hr; 
    LONG            lIndex; 

    ZeroMemory(&hashBlob,         sizeof(hashBlob)); 
    ZeroMemory(&hashBlobExpected, sizeof(hashBlobExpected)); 
    
    if (NULL == pIEnroll4 || NULL == pCertContext || NULL == plIndex)
	goto InvalidArgError; 

    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContext, 
		  CERT_HASH_PROP_ID, 
		  &hashBlobExpected))) 
        goto GetCertificateContextPropertySimpleError; 

    // Initialize the enumeration. 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL)))
        goto enumPendingRequestWStrError1; 

    for (lIndex = 0; TRUE; lIndex++)
    {
	hashBlob.pbData = NULL; 
	hashBlob.cbData = 0; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError2; 
	
	hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
	if (NULL == hashBlob.pbData)
	    goto MemoryError; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError3; 

	// We've found the request we want. 
	if ((hashBlobExpected.cbData == hashBlob.cbData) &&
	    (0                       == memcmp(hashBlobExpected.pbData, hashBlob.pbData, hashBlob.cbData)))
	    break; 
    }

    // Success:  assign the OUT param. 
    *plIndex = lIndex; 
    hr = S_OK; 

 CommonReturn:
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

PRINT_ERROR_IF(enumPendingRequestWStrError1,              hr, (hrExpected != hr));
PRINT_ERROR_IF(enumPendingRequestWStrError2,              hr, (hrExpected != hr));
PRINT_ERROR_IF(enumPendingRequestWStrError3,              hr, (hrExpected != hr));
PRINT_ERROR_IF(GetCertificateContextPropertySimpleError,  hr, (hrExpected != hr)); 
PRINT_ERROR2(InvalidArgError,                             hr = E_INVALIDARG);
PRINT_ERROR2(MemoryError,                                 hr = E_OUTOFMEMORY); 
}

static PCCERT_CONTEXT GetCertOutOfStore(PCRYPT_DATA_BLOB pBlobRequest, DWORD dwStoreFlags, LPWSTR pwszStoreName)
{

    HCERTSTORE          hStoreRequest       = NULL;
    PCERT_REQUEST_INFO  pReqInfo            = NULL;
    PCCERT_CONTEXT      pCertContextRequest = NULL;
   
    if( !CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobRequest,
                       CERT_QUERY_CONTENT_FLAG_PKCS10,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       CRYPT_DECODE_ALLOC_FLAG,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **) &pReqInfo) )
        goto ErrorCryptQueryObject;

    if( NULL == (hStoreRequest = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                dwStoreFlags | CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                pwszStoreName)) )
        goto ErrorOpenRequestStore;

    // Now get this out of the request store
    if( NULL == (pCertContextRequest = CertFindCertificateInStore(
        hStoreRequest,
        CRYPT_ASN_ENCODING,
        0,
        CERT_FIND_PUBLIC_KEY,
        (void *) &pReqInfo->SubjectPublicKeyInfo,
        NULL)) )
        goto ErrorCertGetRequestCert;

CommonReturn:

    if(hStoreRequest != NULL)
        CertCloseStore(hStoreRequest, 0);
        
    if(pReqInfo != NULL)
        LocalFree(pReqInfo);

    return(pCertContextRequest);

ErrorReturn:

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);
    pCertContextRequest = NULL;        
 
    goto CommonReturn;
    
PRINT_ERROR(ErrorCryptQueryObject);
PRINT_ERROR(ErrorOpenRequestStore);
PRINT_ERROR(ErrorCertGetRequestCert);
}

static PCCERT_CONTEXT GetCertOutOfRequestStoreMachine(PCRYPT_DATA_BLOB pBlobRequest) {
    return GetCertOutOfStore
	(pBlobRequest, 
	 CERT_SYSTEM_STORE_LOCAL_MACHINE, 
	 L"REQUEST"); 
}

static PCCERT_CONTEXT GetCertOutOfRequestStore(PCRYPT_DATA_BLOB pBlobRequest) {
    return GetCertOutOfStore
	(pBlobRequest, 
	 CERT_SYSTEM_STORE_CURRENT_USER, 
	 L"REQUEST"); 
}

// This version assumes the PKCS 10 is within a PKCS 7
static PCCERT_CONTEXT GetCertOutOfRequestStore2(
    PCRYPT_DATA_BLOB pBlob7)
{
    CRYPT_DATA_BLOB Blob10;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    PCCERT_CONTEXT pCert;

    Blob10.pbData = NULL;
    Blob10.cbData = 0;
    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara);
    VerifyPara.dwMsgAndCertEncodingType =
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if (!CryptVerifyMessageSignature(
            &VerifyPara,
            0,                  // dwSignerIndex
            pBlob7->pbData,
            pBlob7->cbData,
            Blob10.pbData,
            &Blob10.cbData,
            NULL                // ppSignerCert
            ) || 0 == Blob10.cbData)
        goto ErrorCryptVerifyMessageSignature;

    if (NULL == (Blob10.pbData = (PBYTE) _alloca(Blob10.cbData)))
        goto ErrorOutOfMemory;

    if (!CryptVerifyMessageSignature(
            &VerifyPara,
            0,                  // dwSignerIndex
            pBlob7->pbData,
            pBlob7->cbData,
            Blob10.pbData,
            &Blob10.cbData,
            NULL                // ppSignerCert
            ))
        goto ErrorCryptVerifyMessageSignature;

    pCert = GetCertOutOfRequestStore(&Blob10);

CommonReturn:
    return pCert;

ErrorReturn:
    pCert = NULL;
    goto CommonReturn;

PRINT_ERROR(ErrorCryptVerifyMessageSignature);
PRINT_ERROR(ErrorOutOfMemory);
}

static PCRYPT_DATA_BLOB MakePKCS7ResponseEx(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash,
    BOOL             fUser)
{

    HCERTSTORE          hStorePKCS7         = NULL;
    PCCERT_CONTEXT      pCertContextRequest = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    PCRYPT_KEY_PROV_INFO pKeyProvInfo       = NULL;
    DWORD               cbKeyProvInfo       = 0;
    HCRYPTPROV          hProv               = NULL;
    PCCERT_CONTEXT      pCertContextNew     = NULL;

    CRYPT_DATA_BLOB     blobPKCS7;


    if (fUser)
    {
        pCertContextRequest =  GetCertOutOfRequestStore(pBlobRequest);
    }
    else
    {
        pCertContextRequest =  GetCertOutOfRequestStoreMachine(pBlobRequest);
    }

    if( NULL == pCertContextRequest)
        goto ErrorGetCertOutOfRequestStore;

    // get the prov info off of the cert
    if(
        !CertGetCertificateContextProperty(
            pCertContextRequest,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbKeyProvInfo
            )                                                                       ||
        (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo)))   ||
        !CertGetCertificateContextProperty(
            pCertContextRequest,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo
            )  )
        goto ErrorCertGetCertificateContextProperty;

    // get and hProv off of this certificate
    if( !CryptAcquireCertificatePrivateKey(
        pCertContextRequest,
        0,
        NULL,
        &hProv,
        NULL,
        NULL
        ) )
        goto ErrorCryptAcquireCertificatePrivateKey;

    // build a self-signed cert with this key
    if( NULL == (pCertContextNew = CertCreateSelfSignCertificate(
        hProv,          
        &pCertContextRequest->pCertInfo->Subject,
        0,
        pKeyProvInfo,
        &pCertContextRequest->pCertInfo->SignatureAlgorithm,
        NULL,
        NULL,
        NULL
        )) )
        goto ErrorCertCreateSelfSignCertificate;

    // make a pkcs7
    if( NULL == (hStorePKCS7 = CertOpenStore(
                CERT_STORE_PROV_MEMORY,
                X509_ASN_ENCODING,
                NULL,
                0,
                NULL)) )
        goto ErrorOpenPKCS7Store;

    if( !CertAddCertificateContextToStore(
            hStorePKCS7,
            pCertContextNew,
            CERT_STORE_ADD_USE_EXISTING,
            NULL) ) 
        goto ErrorCertAddToPKCS7Store;  

    assert(pHash != NULL);
    if( !HASHFROMCERT(pCertContextNew, pHash))
        goto ErrorHASHFROMCERT;
        
    memset(&blobPKCS7, 0, sizeof(blobPKCS7));
    if(!CertSaveStore(
            hStorePKCS7,
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &blobPKCS7,
            0) )
            goto ErrorCreatePKCS7;

    pBlobPKCS7 = (PCRYPT_DATA_BLOB) malloc(sizeof(CRYPT_DATA_BLOB) + blobPKCS7.cbData);
    if(NULL == pBlobPKCS7) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto OutOfMemory;
    }
    *pBlobPKCS7 = blobPKCS7;
    pBlobPKCS7->pbData = ((PBYTE) pBlobPKCS7) + sizeof(CRYPT_DATA_BLOB);
   
    if( !CertSaveStore(
            hStorePKCS7,
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            pBlobPKCS7,
            0)) 
        goto ErrorCreatePKCS7;

CommonReturn:

    if(hStorePKCS7 != NULL)
        CertCloseStore(hStorePKCS7, 0);

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);
        
    if(pCertContextNew != NULL)
        CertFreeCertificateContext(pCertContextNew);

    if(hProv != NULL)
        CryptReleaseContext(hProv, 0);

    return(pBlobPKCS7);

ErrorReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);
    pBlobPKCS7 = NULL;

    goto CommonReturn;

PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorCertGetCertificateContextProperty);
PRINT_ERROR(ErrorCryptAcquireCertificatePrivateKey);
PRINT_ERROR(ErrorGetCertOutOfRequestStore);
PRINT_ERROR(ErrorOpenPKCS7Store);
PRINT_ERROR(ErrorCertAddToPKCS7Store);
PRINT_ERROR(ErrorCreatePKCS7);
PRINT_ERROR(OutOfMemory);
PRINT_ERROR(ErrorHASHFROMCERT);
}

static PCRYPT_DATA_BLOB MakePKCS7ResponseMachine(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash)
{
    return MakePKCS7ResponseEx(pBlobRequest, pHash, FALSE);
}

static PCRYPT_DATA_BLOB MakePKCS7Response(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash)
{
    return MakePKCS7ResponseEx(pBlobRequest, pHash, TRUE);
}

static PCRYPT_DATA_BLOB GetPKCS10FromPKCS7(PCRYPT_DATA_BLOB pPKCS7) {

    CRYPT_VERIFY_MESSAGE_PARA   MsgPara;
    PCCERT_CONTEXT              pCert       = NULL;
    CRYPT_DATA_BLOB             blob;
    PCRYPT_DATA_BLOB            pBlob       = NULL;

    assert(pPKCS7 != NULL);
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));

    memset(&MsgPara, 0, sizeof(CRYPT_VERIFY_MESSAGE_PARA));
    MsgPara.cbSize  = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    MsgPara.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if( !CryptVerifyMessageSignature(
        &MsgPara,
        0,
        pPKCS7->pbData,
        pPKCS7->cbData,
        NULL,
        &blob.cbData,
        NULL
        ) )
        goto ErrorCryptVerifyMessageSignature;

    if( (pBlob = (PCRYPT_DATA_BLOB) malloc(blob.cbData + sizeof(CRYPT_DATA_BLOB))) == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto OutOfMemory;
    }
    pBlob->pbData = ((BYTE *) pBlob) + sizeof(CRYPT_DATA_BLOB);
    pBlob->cbData = blob.cbData;
    
    if( !CryptVerifyMessageSignature(
        &MsgPara,
        0,
        pPKCS7->pbData,
        pPKCS7->cbData,
        pBlob->pbData,
        &blob.cbData,
        &pCert
        ) )
        goto ErrorCryptVerifyMessageSignature;

CommonReturn:

    if(pCert != NULL)
        CertFreeCertificateContext(pCert);   
    
    return(pBlob);

ErrorReturn:

    if(pBlob != NULL)
        free(pBlob);
    pBlob = NULL;

    goto CommonReturn;

PRINT_ERROR(ErrorCryptVerifyMessageSignature);
PRINT_ERROR(OutOfMemory);
}

void DeleteCertPrivateKey(PCCERT_CONTEXT pCert) {
    PCRYPT_KEY_PROV_INFO pKeyProvInfo       = NULL;
    DWORD               cbKeyProvInfo       = 0;
    HCRYPTPROV          hProv;

    BYTE                rgbKeyIdHash[20];
    CRYPT_HASH_BLOB     KeyIdentifier;


    // get the prov info off of the cert
    if(
        !CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbKeyProvInfo
            )                                                                       ||
        (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo)))   ||
        !CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo
            )  )
        goto ErrorCertGetCertificateContextProperty;

    // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined and
    // must not be released.
    if( !CryptAcquireContextU(&hProv,
         pKeyProvInfo->pwszContainerName,
         pKeyProvInfo->pwszProvName,
         pKeyProvInfo->dwProvType,
         (pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID) |
             CRYPT_DELETEKEYSET) )
        goto ErrorCryptDeleteKeySet;


    // Also delete the private key identifier

    KeyIdentifier.pbData = rgbKeyIdHash;
    KeyIdentifier.cbData = sizeof(rgbKeyIdHash);
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_IDENTIFIER_PROP_ID,
            KeyIdentifier.pbData,
            &KeyIdentifier.cbData
            ))
        goto ErrorCertGetCertificateKeyIdentifierProperty;

    if (!CryptSetKeyIdentifierProperty(
            &KeyIdentifier,
            0,                  // dwPropId
            CRYPT_KEYID_DELETE_FLAG |
                pKeyProvInfo->dwFlags & CRYPT_KEYID_MACHINE_FLAG,
            NULL,               // pwszComputerName
            NULL,               // pvReserved
            NULL                // pvData
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND != dwErr)
            goto ErrorDeleteKeyIdentifier;
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;

PRINT_ERROR(ErrorCertGetCertificateContextProperty)
PRINT_ERROR(ErrorCryptDeleteKeySet)
PRINT_ERROR(ErrorCertGetCertificateKeyIdentifierProperty)
PRINT_ERROR(ErrorDeleteKeyIdentifier)
}

BOOL RemoveCertFromStore(PCRYPT_HASH_BLOB pHash, LPCWSTR wszStore, DWORD dwStoreFlags) {

    BOOL            fRet        = TRUE;
    HCERTSTORE      hStore      =  NULL;
    DWORD           err         = GetLastError();
    PCCERT_CONTEXT  pCert       = NULL;
    
   // open the my store
    if( NULL == (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                dwStoreFlags,
                wszStore)) )
        goto ErrorOpenStore;

    // find the cert by hash
    if( NULL == (pCert = CertFindCertificateInStore(
        hStore,
        X509_ASN_ENCODING,
        0,
        CERT_FIND_HASH,
        pHash,
        NULL ) ))
        goto ErrorCertFindCertificateInStore; 

    // delete the cert's private key
    DeleteCertPrivateKey(pCert);

    //delete the cert
    if( !CertDeleteCertificateFromStore(pCert) ) {
        pCert = NULL;
        goto ErrorCertDeleteCertificateFromStore;
    }
    pCert = NULL;

CommonReturn:

    if(pCert != NULL)
        CertFreeCertificateContext(pCert);
        
    if(hStore != NULL)
        CertCloseStore(hStore, 0);
        
    SetLastError(err);
    return(fRet);

ErrorReturn:

    fRet = FALSE;
    err = GetLastError();
    goto CommonReturn;

PRINT_ERROR(ErrorOpenStore);
PRINT_ERROR(ErrorCertFindCertificateInStore);
PRINT_ERROR(ErrorCertDeleteCertificateFromStore);
}

// Define a struct which will hold the data we need to test with.  
typedef struct _PENDING_INFO { 
    DWORD     dwRequestID; 
    LPWSTR    pwszCADNS; 
    LPWSTR    pwszCAName;
    LPWSTR    pwszFriendlyName; 
    DWORD     dwStoreFlags; 
    LPWSTR    pwszStoreName; 
    HRESULT   hrExpectedResult; 
} PENDING_INFO; 

class TXEnrollPendingAPITester { 
public:
    BOOL TestMethod_enumPendingRequestWStr(IEnroll4        *pIEnroll4,
					   CRYPT_DATA_BLOB  pkcs10Request,
					   PENDING_INFO    *pPendingInfo);

    BOOL TestMethod_removePendingRequestWStr(IEnroll4 *pIEnroll4); 

    BOOL TestMethod_setPendingInfoWStr(IEnroll4         *pIEnroll4,
				       CRYPT_DATA_BLOB   pkcs10Request,
				       PENDING_INFO   *pPendingInfo);

    BOOL TestProperty_ThumbPrintWStr(IEnroll4 *pIEnroll4);

    

};

BOOL TXEnrollPendingAPITester::TestMethod_removePendingRequestWStr(IEnroll4 *pIEnroll4)
{
    BOOL            fResult; 
    CRYPT_DATA_BLOB hashBlob; 
    CRYPT_DATA_BLOB pkcs10Blob; 
    HRESULT         hr; 
    LONG            lIndex; 
    LONG            lRequestID        = 0; 
    PCCERT_CONTEXT  pCertContext      = NULL;
    WCHAR           pwszCADNS[]       = L"duncanb1.ntdev.microsoft.com";
    WCHAR           pwszCAName[]      = L"Test RPR"; 
    WCHAR           pwszFriendlyName[]= L"\0"; 
    WCHAR           wszDNName[]       = L"CN=Xenroll TestMethod_removePendingRequestWStr Test";

    ZeroMemory(&hashBlob,   sizeof(hashBlob)); 
    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 

    // 
    // Case 0)  Removal of a request in the REQUEST (normal case). 
    //

    if (S_OK != (hr = pIEnroll4->resetExtensions()))
	goto resetExtensionsError;
    
    if (S_OK != (hr = pIEnroll4->resetAttributes()))
	goto resetAttributesError;
    
    // Small key size so the test runs faster. 
    if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	goto put_GenKeyFlagsError; 
    
    // Create a request to test on. 
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName, 
                  NULL,
		  &pkcs10Blob)))
	goto createRequestWStrError;

    // Set pending info on the request, so it can be accessed via the pending API: 
    if (S_OK != (hr = pIEnroll4->setPendingRequestInfoWStr
		 (lRequestID, 
		  pwszCADNS,
		  pwszCAName,
		  pwszFriendlyName)))
	goto setPendingRequestInfoWStrError;

    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError; 

    pCertContext = GetCertOutOfRequestStore(&pkcs10Blob);
    if (NULL == pCertContext)
	goto GetCertOutOfRequestStoreError; 

    // Verify that the request is in the REQUEST store: 
    if (S_OK != (hr = FindPendingRequest
		 (pIEnroll4,
		  pCertContext, 
                  S_OK, 
		  &lIndex)))
	goto RequestNotAddedToStoreError; 

    // Get the thumbprint of the created request. 
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 

    // Remove the request from the request store: 
    if (S_OK != (hr = pIEnroll4->removePendingRequestWStr(hashBlob)))
	goto removePendingRequestWStrError; 

    // Verify that it is actually gone: 
    if (HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) != (hr = FindPendingRequest
						  (pIEnroll4, 
						   pCertContext, 
                                                   HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND), 
						   &lIndex)))
    {
        if (!FAILED(hr))
            hr = E_FAIL; 
	goto PendingRequestNotRemovedError; 
    }

    // No need to delete the request, the pending API has already done this. 
    pkcs10Blob.pbData = NULL; 

    // 
    // Case 1) invalid arg: 
    // 

    { 
	CRYPT_DATA_BLOB invalidBlob; 

	ZeroMemory(&invalidBlob, sizeof(invalidBlob));
	if (E_INVALIDARG != (hr = pIEnroll4->removePendingRequestWStr(invalidBlob)))
	    goto removePendingRequestWStrError; 
    }

    // 
    // Case 2) cert not found: 
    // 

    if (HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) != (hr = pIEnroll4->removePendingRequestWStr
						  (hashBlob)))
    {
        if (!FAILED(hr)) 
            hr = E_FAIL; 
	goto removePendingRequestWStrError; 
    }


    fResult = TRUE; 

 CommonReturn:
    if (NULL != pkcs10Blob.pbData) 
    { 
        pCertContext = GetCertOutOfRequestStore(&pkcs10Blob);
        if (NULL != pCertContext) 
        {
            CertDeleteCertificateFromStore(pCertContext);           
        }
            
        LocalFree(pkcs10Blob.pbData); 
    } 
    if (NULL != hashBlob.pbData)   { LocalFree(hashBlob.pbData); } 

    return fResult; 

 ErrorReturn:
    SetLastError(hr);
    fResult = FALSE;
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError,         hr); 
PRINT_ERROR2(get_ThumbPrintWStrError,        hr); 
PRINT_ERROR2(GetCertOutOfRequestStoreError,  hr = GetLastError());
PRINT_ERROR2(MemoryError,                    hr = E_OUTOFMEMORY);
PRINT_ERROR2(PendingRequestNotRemovedError,  hr); 
PRINT_ERROR2(put_GenKeyFlagsError,           hr); 
PRINT_ERROR2(RequestNotAddedToStoreError,    hr); 
PRINT_ERROR2(removePendingRequestWStrError,  hr); 
PRINT_ERROR2(resetExtensionsError,           hr);
PRINT_ERROR2(resetAttributesError,           hr);
PRINT_ERROR2(ResyncIEnrollRequestStoreError, hr); 
PRINT_ERROR2(setPendingRequestInfoWStrError, hr);
}

BOOL TXEnrollPendingAPITester::TestProperty_ThumbPrintWStr(IEnroll4 *pIEnroll4)
{
    DWORD const       dw_NUM_CASES = 3; 

    BOOL              fResult; 
    CRYPT_DATA_BLOB   hashBlobs         [dw_NUM_CASES]; 
    CRYPT_DATA_BLOB   hashBlobsExpected [dw_NUM_CASES]; 
    CRYPT_DATA_BLOB   pkcs10Blobs       [dw_NUM_CASES];
    DWORD             dwCase; 
    DWORD             dwRequestIDExpected; 
    HRESULT           hr                    = S_OK; 
    LONG              lIndex; 
    PCCERT_CONTEXT    pCertContexts     [dw_NUM_CASES]; 
    
    WCHAR             wszDNName[]      = L"CN=Xenroll TestProperty_ThumbPrintWStr Test";

    PENDING_INFO      pendingInfo = 
    { 100, L"duncanb.ntdev.microsoft.com", L"ThumbPrint Test", L"TT Test", 0, NULL, S_OK }; 

    ZeroMemory(&hashBlobs[0],         sizeof(hashBlobs)); 
    ZeroMemory(&hashBlobsExpected[0], sizeof(hashBlobsExpected));
    ZeroMemory(&pkcs10Blobs[0],       sizeof(pkcs10Blobs)); 
    ZeroMemory(&pCertContexts[0],     sizeof(pCertContexts)); 

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Declare locally-scoped helper functions:
    //
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    TXEnrollLocalScope(TestProperty_ThumbPrintWStrHelper):
	HRESULT GetThumbPrintAndCertContext(IN   IEnroll4        *pIEnroll4,  
					    IN   CRYPT_DATA_BLOB  pkcs10Request, 
					    OUT  PCRYPT_DATA_BLOB pThumbPrintBlob, 
					    OUT  PCCERT_CONTEXT  *ppCertContext)
	{
	    HRESULT hr; 

	    pThumbPrintBlob->pbData = NULL; 
	    *ppCertContext = NULL;

	    *ppCertContext = GetCertOutOfRequestStore(&pkcs10Request); 
	    if (NULL == *ppCertContext)
		goto GetCertOutOfRequestStoreError; 

	    // Use get_ThumbPrintWStr to get the hash of the request.
	    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(pThumbPrintBlob)))
		goto get_ThumbPrintWStrError; 
	    
	    pThumbPrintBlob->pbData = (LPBYTE)LocalAlloc(LPTR, pThumbPrintBlob->cbData); 
	    if (NULL == pThumbPrintBlob->pbData)
		goto MemoryError; 

	    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(pThumbPrintBlob)))
		goto get_ThumbPrintWStrError; 

	    hr = S_OK; 

	CommonReturn:
	    return hr; 
	    
	ErrorReturn: 
	    if (NULL != pThumbPrintBlob->pbData) { LocalFree(pThumbPrintBlob->pbData); } 
	    if (NULL != *ppCertContext)          { CertDeleteCertificateFromStore(*ppCertContext); } 

	    pThumbPrintBlob->pbData = NULL;
	    *ppCertContext          = NULL; 
	    goto CommonReturn; 

	    PRINT_ERROR2(get_ThumbPrintWStrError,       hr); 
	    PRINT_ERROR2(GetCertOutOfRequestStoreError, hr = GetLastError()); 
	    PRINT_ERROR2(MemoryError,                   hr = E_OUTOFMEMORY);
	}

    TXEnrollEndLocalScope;

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 0:  Check that thumbprint returned is the hash of the last created cert.  
    //
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase = 0; 

    if (S_OK != (hr = pIEnroll4->resetExtensions()))
	goto resetExtensionsError;
    
    if (S_OK != (hr = pIEnroll4->resetAttributes()))
	goto resetAttributesError;
    
    // Small key size so the test runs faster. 
    if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	goto put_GenKeyFlagsError; 
    
    // Create a request to test on. 
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName, 
                  NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;
    
    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    // Get a PCCERT_CONTEXT and thumbprint from the request: 
    if (S_OK != (hr = local.GetThumbPrintAndCertContext
		 (pIEnroll4, 
		  pkcs10Blobs[dwCase], 
		  &hashBlobs[dwCase], 
		  &pCertContexts[dwCase])))
	goto GetThumbPrintAndCertContextError; 

    // Manually get the HASH of the request. 
    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContexts[dwCase], 
		  CERT_HASH_PROP_ID, 
		  &hashBlobsExpected[dwCase])))
	goto GetCertificateContextPropertySimpleError; 


    if (!
	((hashBlobs[dwCase].cbData == hashBlobsExpected[dwCase].cbData) &&
	 (0                        == memcmp(hashBlobs[dwCase].pbData, hashBlobsExpected[dwCase].pbData, hashBlobs[dwCase].cbData))))
	goto get_ThumbPrintWStrError; 


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 1:  Make sure that put_ThumbPrintWStr is used as the target of setPendingInfoWStr().
    // 
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase++; 

    // Flush the first request from the pending cache.  
    //
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName,
                  NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;

    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    // Get a PCCERT_CONTEXT and thumbprint from the request: 
    if (S_OK != (hr = local.GetThumbPrintAndCertContext
		 (pIEnroll4, 
		  pkcs10Blobs[dwCase], 
		  &hashBlobs[dwCase], 
		  &pCertContexts[dwCase])))
	goto GetThumbPrintAndCertContextError; 

    // Manually specify the previous request through put_ThumbPrint: 
    if (S_OK != (hr = pIEnroll4->put_ThumbPrintWStr(hashBlobs[dwCase-1])))
	goto put_ThumbPrintWStrError; 

    if (S_OK != (hr = pIEnroll4->setPendingRequestInfoWStr
		 (pendingInfo.dwRequestID, 
		  pendingInfo.pwszCADNS,
		  pendingInfo.pwszCAName, 
		  pendingInfo.pwszFriendlyName)))
	goto setPendingRequestInfoWStrError; 

    if (S_OK != (hr = FindPendingRequest(pIEnroll4, pCertContexts[dwCase-1], S_OK, &lIndex)))
	goto FindPendingRequestError; 
    
    // Success -- if put_ThumbPrintWstr was not working correctly, it would not be possible
    // to find pending info associated with the previous cert context.  

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 2:  Make sure that put_ThumbPrintWStr is used as the target of get_ThumbPrintWStr
    // 
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase++; 

    // Flush the previous request from the pending cache.  
    //
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName,
          NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;

    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    pCertContexts[dwCase] = GetCertOutOfRequestStore(&pkcs10Blobs[dwCase]); 
    if (NULL == pCertContexts[dwCase])
	goto GetCertOutOfRequestStoreError; 

    // Manually specify a request through put_ThumbPrint: 
    //
    if (S_OK != (hr = pIEnroll4->put_ThumbPrintWStr(hashBlobs[dwCase-1])))
	goto put_ThumbPrintWStrError; 
   
    // Extract the request through get_ThumbPrintWStr: 
    //
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlobs[dwCase])))
	goto put_ThumbPrintWStrError; 

    hashBlobs[dwCase].pbData = (LPBYTE)LocalAlloc(LPTR, hashBlobs[dwCase].cbData); 
    if (NULL == hashBlobs[dwCase].pbData)
	goto MemoryError; 

    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlobs[dwCase])))
	goto put_ThumbPrintWStrError; 

    if (!
	((hashBlobs[dwCase].cbData == hashBlobs[dwCase-1].cbData) &&
	 (0                        == memcmp(hashBlobs[dwCase].pbData, hashBlobs[dwCase-1].pbData, hashBlobs[dwCase].cbData))))
	goto get_ThumbPrintWStrError; 
    

    fResult = TRUE; 

 CommonReturn:
    if (NULL != pIEnroll4) { pIEnroll4->Release(); }

    for (dwCase = 0; dwCase < dw_NUM_CASES; dwCase++)
    {
	if (NULL != pkcs10Blobs[dwCase].pbData)        { LocalFree(pkcs10Blobs[dwCase].pbData); } 
	if (NULL != hashBlobs[dwCase].pbData)          { LocalFree(hashBlobs[dwCase].pbData); } 
	if (NULL != hashBlobsExpected[dwCase].pbData)  { LocalFree(hashBlobsExpected[dwCase].pbData); } 
	if (NULL != pCertContexts[dwCase])             { CertDeleteCertificateFromStore(pCertContexts[dwCase]); }
    }

    return fResult; 

 ErrorReturn:
    fResult = FALSE;
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError, hr); 
PRINT_ERROR2(FindPendingRequestError, hr); 
PRINT_ERROR2(get_ThumbPrintWStrError, hr); 
PRINT_ERROR(GetCertOutOfRequestStoreError); 
PRINT_ERROR2(GetCertificateContextPropertySimpleError, hr);
PRINT_ERROR2(GetThumbPrintAndCertContextError, hr);
PRINT_ERROR2(MemoryError, E_OUTOFMEMORY); 
PRINT_ERROR2(put_GenKeyFlagsError, hr); 
PRINT_ERROR2(put_ThumbPrintWStrError, hr); 
PRINT_ERROR2(resetAttributesError, hr);
PRINT_ERROR2(resetExtensionsError, hr); 
PRINT_ERROR2(ResyncIEnrollRequestStoreError, hr); 
PRINT_ERROR2(setPendingRequestInfoWStrError, hr); 
}
BOOL TXEnrollPendingAPITester::TestMethod_enumPendingRequestWStr(IEnroll4        *pIEnroll4,
								 CRYPT_DATA_BLOB  pkcs10Blob, 
								 PENDING_INFO    *pPendingInfo)
{
    BOOL              fResult; 
    CRYPT_DATA_BLOB   caDNSBlob; 
    CRYPT_DATA_BLOB   caNameBlob; 
    CRYPT_DATA_BLOB   friendlyNameBlob; 
    CRYPT_DATA_BLOB   hashBlob; 
    CRYPT_DATA_BLOB   hashBlobExpected; 
    CRYPT_DATA_BLOB   v1TemplateNameBlob; 
    DWORD             dwRequestID; 
    FILETIME          ftDate; 
    FILETIME          ftDateExpected; 
    HRESULT           hr = S_OK; 
    LONG              lIndex; 
    PCCERT_CONTEXT    pCertContext = NULL; 

    // Init:
    ZeroMemory(&caDNSBlob,          sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&caNameBlob,         sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&friendlyNameBlob,   sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&hashBlob,           sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&hashBlobExpected,   sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&v1TemplateNameBlob, sizeof(CRYPT_DATA_BLOB)); 

    if (NULL == pIEnroll4 || NULL == pPendingInfo)
	goto InvalidArgError; 
    
    pCertContext = GetCertOutOfStore(&pkcs10Blob, pPendingInfo->dwStoreFlags, pPendingInfo->pwszStoreName); 
    if (NULL == pCertContext)
	goto GetCertOutOfStoreError; 
    
    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContext, 
		  CERT_HASH_PROP_ID, 
		  &hashBlobExpected)))
	goto GetCertificateContextPropertySimpleError; 
    
    // Initialize the enumeration.  
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL)))
	goto enumPendingRequestWStrError; 

    for (lIndex = 0; TRUE; lIndex++) // Find the index of the pending request in the request store: 
    {
	hashBlob.pbData = NULL; 
	hashBlob.cbData = 0; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError; 
	
	hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
	if (NULL == hashBlob.pbData)
	    goto MemoryError; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError; 
	
	// We've found the request we want. 
	if ((hashBlobExpected.cbData == hashBlob.cbData) &&
	    (0                       == memcmp(hashBlobExpected.pbData, hashBlob.pbData, hashBlob.cbData)))
	    break; 
    }
    
    // Test XEPR_REQUESTID property: 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_REQUESTID, (LPVOID)&dwRequestID)))
	goto enumPendingRequestWStrError;                     
    
    if (dwRequestID != pPendingInfo->dwRequestID)
	goto pendingInfoDoesntMatchError; 

    // Test XEPR_CANAME property: 
    caNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CANAME, (LPVOID)&caNameBlob)))
	goto enumPendingRequestWStrError;                     

    caNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, caNameBlob.cbData);
    if (NULL == caNameBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CANAME, (LPVOID)&caNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)caNameBlob.pbData, pPendingInfo->pwszCAName))
	goto enumPendingRequestWStrError;                     

    // Test XEPR_CADNS property: 
    caDNSBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CADNS, (LPVOID)&caDNSBlob)))
	goto enumPendingRequestWStrError;                     
    
    caDNSBlob.pbData = (LPBYTE)LocalAlloc(LPTR, caDNSBlob.cbData);
    if (NULL == caDNSBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CADNS, (LPVOID)&caDNSBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)caDNSBlob.pbData, pPendingInfo->pwszCADNS))
	goto enumPendingRequestWStrError;                     
    
    // Test XEPR_CAFRIENDLYNAME property: 

    // Note: it is legal to pass NULL when setting the friendly name property.  In this case, 
    //       the friendly name property is set to the empty string. 
    if (NULL == pPendingInfo->pwszFriendlyName) { pPendingInfo->pwszFriendlyName = L""; } 

    friendlyNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CAFRIENDLYNAME, (LPVOID)&friendlyNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    friendlyNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, friendlyNameBlob.cbData);
    if (NULL == friendlyNameBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CAFRIENDLYNAME, (LPVOID)&friendlyNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)friendlyNameBlob.pbData, pPendingInfo->pwszFriendlyName))
	goto enumPendingRequestWStrError;                     
    
    // Test XEPR_V1TEMPLATENAME property: 
    
#if 0
    v1TemplateNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_V1TEMPLATENAME, (LPVOID)&v1TemplateNameBlob)))
	goto enumPendingRequestWStrError;                     

    v1TemplateNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, v1TemplateNameBlob.cbData);
    if (NULL == v1TemplateNameBlob.pbData)
	goto ErrorReturn; 
	    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_V1TEMPLATENAME, (LPVOID)&v1TemplateNameBlob)))
	goto enumPendingRequestWStrError;                     

    if (0 != wcscmp(pwszV1TemplateNameExpected, (LPWSTR)v1TemplateNameBlob.pbData))
	goto enumPendingRequestWStrError;                     
#endif
    // Test XEPR_DATE property: 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_DATE, (LPVOID)&ftDate)))
	goto enumPendingRequestWStrError;                     
	    
    ftDateExpected = pCertContext->pCertInfo->NotAfter; 
    if (0 != memcmp((LPVOID)&ftDateExpected, (LPVOID)&ftDate, sizeof(FILETIME)))
	goto enumPendingRequestWStrError; 

    // Test XEPR_V2TEMPLATEOID property:

    // XEPR_V2TEMPLATEOID property not yet impl. 
    
    // Test XEPR_VERSION property: 
    
    // XEPR_VERSION property not yet impl. 
    
    fResult = TRUE; 

 CommonReturn: 
    if (NULL != caDNSBlob.pbData)           { LocalFree(caDNSBlob.pbData); } 
    if (NULL != caNameBlob.pbData)          { LocalFree(caNameBlob.pbData); } 
    if (NULL != friendlyNameBlob.pbData)    { LocalFree(friendlyNameBlob.pbData); } 
    if (NULL != hashBlob.pbData)            { LocalFree(hashBlob.pbData); } 
    if (NULL != v1TemplateNameBlob.pbData)  { LocalFree(v1TemplateNameBlob.pbData); } 
    if (NULL != pCertContext)               { CertFreeCertificateContext(pCertContext); } 
    return fResult; 

 ErrorReturn: 
    fResult = FALSE; 
    SetLastError(hr); 
    goto CommonReturn;  

PRINT_ERROR2(enumPendingRequestWStrError, hr); 
PRINT_ERROR2(GetCertificateContextPropertySimpleError, hr); 
PRINT_ERROR2(GetCertOutOfStoreError, hr = GetLastError());
PRINT_ERROR2(InvalidArgError, hr = E_INVALIDARG); 
PRINT_ERROR2(MemoryError, hr = E_OUTOFMEMORY); 
PRINT_ERROR2(pendingInfoDoesntMatchError, hr = E_FAIL);
}

BOOL TXEnrollPendingAPITester::TestMethod_setPendingInfoWStr(IEnroll4        *pIEnroll4,
							     CRYPT_DATA_BLOB  pkcs10Blob, 
							     PENDING_INFO    *pPendingInfo)
{
    BOOL             fResult; 
    CRYPT_DATA_BLOB  dataBlob; 
    DWORD            dwSize; 
    LPBYTE           pbPendingInfo; 
    HRESULT          hr = S_OK; 
    PCCERT_CONTEXT   pCertContext       = NULL;
    WCHAR            wszDNNName[]       = L"CN=Xenroll setPendingInfoWStr Test 1";

    ZeroMemory(&dataBlob, sizeof(dataBlob)); 

    if (NULL == pIEnroll4 || NULL == pPendingInfo)
	goto InvalidArgError; 
	    
    hr = pIEnroll4->setPendingRequestInfoWStr
	(pPendingInfo->dwRequestID, 
	 pPendingInfo->pwszCADNS,
	 pPendingInfo->pwszCAName, 
	 pPendingInfo->pwszFriendlyName);
    
    if (hr != pPendingInfo->hrExpectedResult)
	goto setPendingRequestInfoWStrError;

    if (hr != S_OK) 
    { 
	// This test was supposed to fail.  
	fResult = TRUE; 
	goto CommonReturn; 
    }

    pCertContext = GetCertOutOfStore(&pkcs10Blob, pPendingInfo->dwStoreFlags, pPendingInfo->pwszStoreName); 
    if (NULL == pCertContext)
	goto GetCertOutOfStoreError; 

    if (!CertGetCertificateContextProperty
	(pCertContext, 
	 CERT_ENROLLMENT_PROP_ID, 
	 NULL, 
	 &(dataBlob.cbData)))
	goto CertGetCertificateContextPropertyError; 
    
    dataBlob.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob.cbData);
    if (NULL == dataBlob.pbData)
	goto MemoryError; 
	
    if (!CertGetCertificateContextProperty
	(pCertContext, 
	 CERT_ENROLLMENT_PROP_ID, 
	 dataBlob.pbData, 
	 &(dataBlob.cbData)))
	goto CertGetCertificateContextPropertyError; 
    
    // Is request ID set correctly?
    pbPendingInfo = dataBlob.pbData; 
    if (0 != memcmp(pbPendingInfo, &pPendingInfo->dwRequestID, sizeof(DWORD))) 
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 
 
    // Is CADNS set correctly?
    dwSize = wcslen(pPendingInfo->pwszCADNS) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszCADNS, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 

    // Is CAName set correctly?
    dwSize = wcslen(pPendingInfo->pwszCAName) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszCAName, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 
    
    // Is friendly name set correctly?

    // Note: it is legal to pass NULL when setting the friendly name property.  In this case, 
    //       the friendly name property is set to the empty string. 
    if (NULL == pPendingInfo->pwszFriendlyName) { pPendingInfo->pwszFriendlyName = L""; } 

    dwSize = wcslen(pPendingInfo->pwszFriendlyName) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszFriendlyName, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 

    // Success!
    fResult = TRUE; 
 CommonReturn:
    if (NULL != dataBlob.pbData) { LocalFree(dataBlob.pbData); } 
    if (NULL != pCertContext)    { CertFreeCertificateContext(pCertContext); } 

    return fResult; 
    
 ErrorReturn: 
    fResult = FALSE; 
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(CertGetCertificateContextPropertyError, hr = GetLastError()); 
PRINT_ERROR2(GetCertOutOfStoreError, hr = GetLastError());
PRINT_ERROR2(InvalidArgError, hr = E_INVALIDARG);
PRINT_ERROR2(MemoryError, hr = E_OUTOFMEMORY);
PRINT_ERROR2(setPendingRequestInfoWStrError, hr); 
}

static BOOL WriteBlobToFile(LPCWSTR wszFile, DWORD dwFlags, PCRYPT_DATA_BLOB pBlob) {

    HANDLE      hFile   = NULL;
    BOOL        fRet    = TRUE;
    DWORD       cb      = 0;

    // open the File
    if( fRet = ((hFile = CreateFileW(
        wszFile,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) != NULL && hFile != INVALID_HANDLE_VALUE) ) {

        // write out the data
        fRet = WriteFile(
            hFile,
            pBlob->pbData,
            pBlob->cbData,
            &cb,
            NULL);

        CloseHandle(hFile);
    }

    return(fRet);
}

// Basic operation, create keys, gen request, accept cert.
BOOL Test1() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    LPWSTR              szwHashAlg = NULL;

    memset(&blobPKCS10, 0, sizeof(blobPKCS10));

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    if(S_OK != pIEnroll->get_HashAlgorithmWStr(&szwHashAlg)  ||
        wcscmp(szwHashAlg, L"1.3.14.3.2.26") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    if(S_OK != pIEnroll->put_HashAlgorithmWStr(L"MD2") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    if(S_OK != pIEnroll->get_HashAlgorithmWStr(&szwHashAlg)  ||
        wcscmp(szwHashAlg, L"1.2.840.113549.2.2") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    // enroll for a new cert
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4, 1.2.6.7", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorNoHashAlg);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test basic operation but with no EKU or no DN name
BOOL Test2() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();
	    
    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test Renewal, Create original cert, create renewal request, create renewed cert
BOOL Test3() {

    IEnroll *	        pIEnroll            = NULL;
    IEnroll *	        pIEnroll2           = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS72         = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS102        = NULL;
    PCCERT_CONTEXT      pCert1              = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    CRYPT_DATA_BLOB     blobPKCS102;
    BYTE                arSha1Hash[20];
    BYTE                arSha1Hash2[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    CRYPT_HASH_BLOB     hash2 = {sizeof(arSha1Hash2), arSha1Hash2};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }

    // get the cert just created
    if( NULL == (pCert1 = pIEnroll->getCertContextFromPKCS7(pBlobPKCS7)) ) {
        goto ErrorGetCertContextFromPKCS7;
        }

    pIEnroll2 = PIEnrollGetNoCOM();
    
    // enroll for a new cert, Really I will get a 7 back with a 10 in it.
    if( S_OK != (hr = pIEnroll2->put_RenewalCertificate(pCert1)) ) {
        SetLastError(hr);
        goto ErrorPut_RenewalCertificate;
    }

    memset(&blobPKCS102, 0, sizeof(blobPKCS102));
    if( S_OK != (hr = pIEnroll2->createPKCS10WStr(NULL, NULL, &blobPKCS102)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    // get the pkcs10 from the pkcs7  
    if( NULL == (pBlobPKCS102 = GetPKCS10FromPKCS7(&blobPKCS102)) )
        goto ErrorGetPKCS10FromPKCS7;

    // make the response
    if( NULL == (pBlobPKCS72 = MakePKCS7Response(pBlobPKCS102, &hash2)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll2->acceptPKCS7Blob(pBlobPKCS72)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash2, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pCert1 != NULL)
        CertFreeCertificateContext(pCert1);
    
    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pBlobPKCS72 != NULL)
        free(pBlobPKCS72);

    if(pBlobPKCS102 != NULL)
        free(pBlobPKCS102);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(pIEnroll2 != NULL)
	    pIEnroll2->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);
        
    if(blobPKCS102.pbData != NULL)
        LocalFree(blobPKCS102.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorGetCertContextFromPKCS7);
PRINT_ERROR(ErrorGetPKCS10FromPKCS7);
PRINT_ERROR(ErrorPut_RenewalCertificate);
}


// Basic operation, create keys, gen request, accept cert, but put the certs in HKLM
BOOL Test4() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // say I want the result in HKLM
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Release();
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    if( NULL == (pBlobPKCS7 = MakePKCS7ResponseMachine(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    //this is new xenroll instance, set to machine store
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_LOCAL_MACHINE) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

BOOL Test5() {

    #define DNNAME  L"CN=Test"

    DWORD               Err             = GetLastError();
    BOOL                fRet            = TRUE;
    HCRYPTPROV          hProv           = NULL;
    HCRYPTKEY           hKey            = NULL;
    PCCERT_CONTEXT      pCertContext    = NULL;
    DWORD               dwFlagsT        = 0;
    CERT_NAME_BLOB      nameBlob;
    CRYPT_KEY_PROV_INFO	keyProvInfo;
    GUID		guidContainerName;

    SYSTEMTIME		startTime;
    SYSTEMTIME		endTime;

    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    memset(&nameBlob, 0, sizeof(CERT_NAME_BLOB));
    memset(&guidContainerName, 0, sizeof(GUID));

    // get a container based on a guid
    UuidCreate(&guidContainerName);
    UuidToStringW(&guidContainerName, &keyProvInfo.pwszContainerName);

    keyProvInfo.pwszProvName        = L"";
    keyProvInfo.dwProvType          = PROV_RSA_FULL;
    keyProvInfo.dwFlags             = 0;
    keyProvInfo.cProvParam          = 0;
    keyProvInfo.rgProvParam         = NULL;
    keyProvInfo.dwKeySpec           = AT_SIGNATURE;

    if( !CryptAcquireContextW(&hProv,
         keyProvInfo.pwszContainerName,
         keyProvInfo.pwszProvName,
         keyProvInfo.dwProvType,
         CRYPT_NEWKEYSET) ) {
        hProv = NULL;
        goto ErrorCryptAcquireContext;
    }

    // we better not have a key here, so gen it
    if(!CryptGenKey(    hProv, 
                        keyProvInfo.dwKeySpec, 
                        0,
                        &hKey) ) 
        goto ErrorCryptGenKey;

    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            DNNAME,
            0,
            NULL,
            NULL,
            &nameBlob.cbData,
            NULL)                                               ||
        (nameBlob.pbData = (BYTE *) _alloca(nameBlob.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            DNNAME,
            0,
            NULL,
            nameBlob.pbData,
            &nameBlob.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // check that predefine dates work
    memset(&startTime, 0, sizeof(startTime));
    startTime.wYear = 1998;
    startTime.wMonth = 6;
    startTime.wDay = 20;
    startTime.wHour = 12;

    memset(&endTime, 0, sizeof(endTime));
    endTime.wYear = 1998;
    endTime.wMonth = 7;
    endTime.wDay = 10;
    endTime.wHour = 4;

    if ( NULL == (pCertContext = CertCreateSelfSignCertificate(
        hProv,          
        &nameBlob,
        0,
        NULL,
        NULL,
	&startTime,
	&endTime,
        NULL
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;

    dwFlagsT = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if( !CertVerifySubjectCertificateContext(
        pCertContext,
        pCertContext,
        &dwFlagsT
        ) )
	goto ErrorCertVerifySubjectCertificateContext;

    // check the time to see if it is correct
    if( pCertContext->pCertInfo->NotBefore.dwLowDateTime != 0xF34E2000 ||
	pCertContext->pCertInfo->NotBefore.dwHighDateTime != 0x1BD9C42 ||
	pCertContext->pCertInfo->NotAfter.dwLowDateTime != 0x356DE000 ||
	pCertContext->pCertInfo->NotAfter.dwHighDateTime != 0x1BDABB7 ) {
	SetLastError(ERROR_INVALID_TIME);
	goto ErrorDateTime;
    }


CommonReturn:
    if (hProv != NULL) {
        HCRYPTPROV hDeleteProv;

        CryptAcquireContextW(&hDeleteProv,
             keyProvInfo.pwszContainerName,
             keyProvInfo.pwszProvName,
             keyProvInfo.dwProvType,
             CRYPT_DELETEKEYSET);
    }

    if(pCertContext !=NULL)
        CertFreeCertificateContext(pCertContext);
        
    if(hKey != NULL)
        CryptDestroyKey(hKey);
    
    if(keyProvInfo.pwszContainerName != NULL)
        RpcStringFreeW(&keyProvInfo.pwszContainerName);

    if(hProv != NULL)
        CryptReleaseContext(hProv, 0);
 
    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCryptAcquireContext);
PRINT_ERROR(ErrorCertStrToNameW);
PRINT_ERROR(ErrorCryptGenKey);
PRINT_ERROR(ErrorCertVerifySubjectCertificateContext);
PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorDateTime);
}

// Basic operation, create keys, gen request, accept cert.
BOOL Test6() {

    ICEnroll *	        pEnroll             = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    BSTR                bstrRequest         = NULL;
    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    BSTR                bstrResponse        = NULL;

    if( S_OK != CoInitialize(NULL) )
        goto ErrorCoInitializeEx;

    // TEST 1 Normal usage
    if( S_OK != (hr = CoCreateInstance(CLSID_CEnroll, NULL, CLSCTX_INPROC_SERVER, IID_ICEnroll, (void **) &pEnroll)) ) {
        SetLastError(hr);
        goto ErrorCoCreateInstance;
    }

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pEnroll->createPKCS10(L"CN=XEnroll Test", L"1.2.3.4, 1.2.6.7", &bstrRequest)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    blobPKCS10.cbData = SysStringByteLen(bstrRequest);
    blobPKCS10.pbData = (PBYTE) bstrRequest;

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    if( NULL == (bstrResponse = SysAllocStringByteLen((LPCSTR) pBlobPKCS7->pbData, pBlobPKCS7->cbData)) )
        goto ErrorSysAllocStringByteLen;

    // accept the new cert
    if( S_OK != (hr = pEnroll->acceptPKCS7(bstrResponse)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pEnroll != NULL)
	    pEnroll->Release();

	if(bstrResponse != NULL)
	    SysFreeString(bstrResponse);

    CoUninitialize();

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCoInitializeEx);
PRINT_ERROR(ErrorCoCreateInstance);
PRINT_ERROR(ErrorSysAllocStringByteLen);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Basic operation, create keys, gen request, accept cert, but put the certs in HKLM
BOOL Test7() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // say I want the result in HKLM
    pIEnroll->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Release();
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    if( NULL == (pBlobPKCS7 = MakePKCS7ResponseMachine(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // say I want the result in HKLM
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_LOCAL_MACHINE) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test some alg enum stuff
BOOL Test8() {

    IEnroll2 *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    LONG                lFlags  = 0;
    DWORD               i       = 0;
    LPWSTR              wsz     = NULL;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnroll2GetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // enum the default algids
    while( (S_OK == (hr = pIEnroll->EnumAlgs(i++, ALG_CLASS_HASH, &lFlags))) ) {
        if( (S_OK == (hr = pIEnroll->GetAlgNameWStr(lFlags, &wsz))) ) {
            LocalFree(wsz);
        }
        else {
            goto ErrorGetAlgName;
        }
    }
    
    if( i == 1 ) {
        SetLastError(hr);
        goto ErrorEnumAlgs;
    }

    if(S_OK != (hr = pIEnroll->GetSupportedKeySpec(&lFlags))) {
        SetLastError(hr);
        goto ErrorGetSupportedKeySpec;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(FALSE, FALSE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(FALSE, TRUE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(TRUE, FALSE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(TRUE, TRUE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    // get the keyspec data
    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Reset();
 
    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorEnumAlgs);
PRINT_ERROR(ErrorGetKeyLen);
PRINT_ERROR(ErrorGetSupportedKeySpec);
PRINT_ERROR(ErrorGetAlgName);
}

// Test some alg enum stuff
BOOL Test9() {

    IEnroll2 *	        pIEnroll            = NULL;
    PCCERT_CONTEXT      pCertContext        = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    DWORD               i       = 0;
 
    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnroll2GetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    for(i=0; i<100; i++) {
    
        // get the keyspec data
        // enroll for a new cert
        memset(&blobPKCS10, 0, sizeof(blobPKCS10));
        if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
            SetLastError(hr);
            goto ErrorCreatePkCS10;
            }
    
        pIEnroll->Reset();

        // clean up after ourself
        if(NULL != (pCertContext =  GetCertOutOfRequestStore(&blobPKCS10)) ) {
            // delete the cert's private key
            DeleteCertPrivateKey(pCertContext);

            CertDeleteCertificateFromStore(pCertContext);
            pCertContext = NULL;
        }

        if(blobPKCS10.pbData != NULL)
            LocalFree(blobPKCS10.pbData);
    }
 
       
 CommonReturn:

    if(pIEnroll != NULL)
	    pIEnroll->Release();


    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
}


// test to see if we can build PVK and SPC files
BOOL TestUI1() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    if( S_OK != pIEnroll->put_PVKFileNameWStr(L"c:\\temp\\foo.pvk") )
        goto ErrorPVKFileNameWStr;
    
    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();
	    
    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorPVKFileNameWStr);
}

// Test Renewal, Create original cert, create renewal request, create renewed cert
BOOL Test10() {

    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // GetUserNameExW is NOT a 2 pass call, so I have to guess at the MAX
    #define             MAXUSERNAME         256
    WCHAR               wszUserName[MAXUSERNAME];
    DWORD               cchUserName         = MAXUSERNAME;
    
    IEnroll *	        pIEnrollRenew       = NULL;
    IEnroll *	        pIEnrollRA1         = NULL;
    IEnroll *	        pIEnrollRA2         = NULL;

    CRYPT_DATA_BLOB     blobRenewRequest;
    CRYPT_DATA_BLOB     blobRA1Reqest;
    CRYPT_DATA_BLOB     blobRA2Reqest;
    CRYPT_DATA_BLOB     blobT;
    
    CERT_NAME_BLOB      blobNameRA1;
    CERT_NAME_BLOB      blobNameRA2;
    CERT_NAME_BLOB      blobNameOld;
    
    PCCERT_CONTEXT      pCertRA1            = NULL;
    PCCERT_CONTEXT      pCertRA2            = NULL;
    PCCERT_CONTEXT      pCertOld            = NULL;

    CERT_EXTENSION      rgExtension[]       = {
                                                {szOID_ENHANCED_KEY_USAGE, FALSE, {0, NULL}}
                                              };
    CERT_EXTENSIONS     Extensions          = {sizeof(rgExtension)/sizeof(CERT_EXTENSION), rgExtension};
    
    LPSTR               rgszOIDUsages[]     = {szOID_ENROLLMENT_AGENT};
    CERT_ENHKEY_USAGE   eku                 = {1 ,rgszOIDUsages};

    memset(&blobRenewRequest, 0, sizeof(blobRenewRequest));
    memset(&blobRA1Reqest, 0, sizeof(blobRA1Reqest));
    memset(&blobRA2Reqest, 0, sizeof(blobRA2Reqest));
    memset(&blobNameRA1, 0, sizeof(blobNameRA1));
    memset(&blobNameRA2, 0, sizeof(blobNameRA2));
    memset(&blobNameOld, 0, sizeof(blobNameOld));

    // encode the enhanced key usage
    if( !CryptEncodeObjectEx(
            CRYPT_ASN_ENCODING, 
            X509_ENHANCED_KEY_USAGE,
            &eku,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,
            &rgExtension[0].Value.pbData,           
            &rgExtension[0].Value.cbData
            ) )
        goto ErrorCryptEncodeObjectEx;
    
    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA1",
            0,
            NULL,
            NULL,
            &blobNameRA1.cbData,
            NULL)                                               ||
        (blobNameRA1.pbData = (BYTE *) _alloca(blobNameRA1.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA1",
            0,
            NULL,
            blobNameRA1.pbData,
            &blobNameRA1.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the 1st RA
    if( NULL == (pCertRA1 = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameRA1,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            &Extensions
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
        
    blobT.cbData = pCertRA1->cbCertEncoded;
    blobT.pbData = pCertRA1->pbCertEncoded;
    WriteBlobToFile(L"RA1.cer", 0, &blobT);
        
    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA2",
            0,
            NULL,
            NULL,
            &blobNameRA2.cbData,
            NULL)                                               ||
        (blobNameRA2.pbData = (BYTE *) _alloca(blobNameRA2.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA2",
            0,
            NULL,
            blobNameRA2.pbData,
            &blobNameRA2.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the 2'nd RA
    if( NULL == (pCertRA2 = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameRA2,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            &Extensions
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
        
    blobT.cbData = pCertRA2->cbCertEncoded;
    blobT.pbData = pCertRA2->pbCertEncoded;
    WriteBlobToFile(L"RA2.cer", 0, &blobT);

    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test Cert Old",
            0,
            NULL,
            NULL,
            &blobNameOld.cbData,
            NULL)                                               ||
        (blobNameOld.pbData = (BYTE *) _alloca(blobNameOld.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test Cert Old",
            0,
            NULL,
            blobNameOld.pbData,
            &blobNameOld.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the Original cert
    if( NULL == (pCertOld = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameOld,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
    blobT.cbData = pCertOld->cbCertEncoded;
    blobT.pbData = pCertOld->pbCertEncoded;
    WriteBlobToFile(L"Original.cer", 0, &blobT);

    // Make an RA cert
    if(NULL == (pIEnrollRenew = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;
    
    // enroll for a new cert.
    if( S_OK != (hr = pIEnrollRenew->put_RenewalCertificate(pCertOld)) ) {
        SetLastError(hr);
        goto ErrorPut_RenewalCertificate;
    }

    // put in a certtype for laughs
    if( S_OK != (hr = pIEnrollRenew->AddCertTypeToRequestWStr(L"MY CERT TYPE")) ) {
        SetLastError(hr);
        goto ErrorAddCertTypeToRequest;
    }

    // get the renewal PKCS7 (in the 10 blob)
    if( S_OK != (hr = pIEnrollRenew->createPKCS10WStr(L"CN=XEnroll Test Renew", L"1.3.6.1.5.5.7.3.8", &blobRenewRequest)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
    }
    WriteBlobToFile(L"Renewal.p7s", 0, &blobRenewRequest);

    // Make an RA cert
    if(NULL == (pIEnrollRA1 = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;


    if(S_OK != pIEnrollRA1->AddNameValuePairToSignatureWStr(L"CreateUserCertificate", L"stimpy.ntdev.microsoft.com"))
        goto ErrorAddNameValuePairToSignatureWStr;


    if( !GetUserNameExW(NameSamCompatible, wszUserName, &cchUserName) ) 
        goto ErrorGetUserName;

    if(S_OK != pIEnrollRA1->AddNameValuePairToSignatureWStr(L"UserName", wszUserName))
        goto ErrorAddNameValuePairToSignatureWStr;
    
    // get the 1st RA Request
    if( S_OK != (hr = pIEnrollRA1->CreatePKCS7RequestFromRequest(
		&blobRenewRequest,
		pCertRA1,
		&blobRA1Reqest) ) )
		goto ErrorCreatePKCS7RequestFromRequest;
    WriteBlobToFile(L"RA1.p7s", 0, &blobRA1Reqest);

    // Make an RA cert
    if(NULL == (pIEnrollRA2 = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;
    
    if(S_OK != pIEnrollRA2->AddNameValuePairToSignatureWStr(L"ChangeUserCertificate", L"stimpy.redmond.microsoft.com"))
        goto ErrorAddNameValuePairToSignatureWStr;
    
    // get the 2nd RA Request
    if( S_OK != (hr = pIEnrollRA2->CreatePKCS7RequestFromRequest(
		&blobRA1Reqest,
		pCertRA2,
		&blobRA2Reqest) ) )
		goto ErrorCreatePKCS7RequestFromRequest;

    // put this out to a file for Vic
    WriteBlobToFile(L"RA2.p7s", 0, &blobRA2Reqest);
        
CommonReturn:

    if(rgExtension[0].Value.pbData != NULL)
        LocalFree(rgExtension[0].Value.pbData);

    if(blobRenewRequest.pbData != NULL) {
        // clean up after ourself
        PCCERT_CONTEXT pCertRequest;
        if(NULL != (pCertRequest =  GetCertOutOfRequestStore2(
                &blobRenewRequest)) ) {
            // delete the cert's private key
            DeleteCertPrivateKey(pCertRequest);

            CertDeleteCertificateFromStore(pCertRequest);
        }

        LocalFree(blobRenewRequest.pbData);
    }
        
    if(pIEnrollRenew != NULL)
        pIEnrollRenew->freeRequestInfoBlob(blobRenewRequest);

    if(pCertRA1 != NULL) {
        DeleteCertPrivateKey(pCertRA1);
        CertFreeCertificateContext(pCertRA1);
    }
        
    if(pCertRA2 != NULL) {
        DeleteCertPrivateKey(pCertRA2);
        CertFreeCertificateContext(pCertRA2);
    }
        
    if(pCertOld != NULL) {
        DeleteCertPrivateKey(pCertOld);
        CertFreeCertificateContext(pCertOld);
    }

    if(blobRA1Reqest.pbData != NULL)
        LocalFree(blobRA1Reqest.pbData);

    if(blobRA2Reqest.pbData != NULL)
        LocalFree(blobRA2Reqest.pbData);

    if(pIEnrollRenew != NULL)
        pIEnrollRenew->Release();

    if(pIEnrollRA1 != NULL)
        pIEnrollRA1->Release();

    if(pIEnrollRA2 != NULL)
        pIEnrollRA2->Release();

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorGetUserName);
PRINT_ERROR(ErrorAddNameValuePairToSignatureWStr);
PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCertStrToNameW);
PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorCreatePKCS7RequestFromRequest);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorPut_RenewalCertificate);
PRINT_ERROR(ErrorCryptEncodeObjectEx);
PRINT_ERROR(ErrorAddCertTypeToRequest);
}

HRESULT
myMultiByteToWideChar(
    IN  char  *psz,
    OUT WCHAR **ppwsz)
{
    HRESULT  hr;
    int cch = 0;
    WCHAR *pwsz = NULL;

    assert (NULL != psz);

    while (TRUE)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cch);
        assert((cch - 1) == (int)strlen(psz));
        if (NULL != pwsz)
        {
             break; //done
        }
        pwsz = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }
    *ppwsz = pwsz;
    pwsz = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;

PRINT_ERROR(LocalAllocError)
}


// test Enroll4 interface
BOOL Test11()
{

    BOOL  fRet = FALSE;
    HRESULT  hr;
    IEnroll4 *pIEnroll4 = NULL;
    HANDLE  hCAFile = NULL;
    CHAR    *pchCACert = NULL;
    BYTE    *pbCACert = NULL;
    DWORD   cchCACert;
    DWORD   cbCACert;
    DWORD   cbRead;
    PCCERT_CONTEXT  pCACert = NULL;
    WCHAR  *pwszDNName = NULL;
    WCHAR  *pwszCMCFileName = NULL;
    WCHAR  *pwszKeyContainer = NULL;
    CRYPT_DATA_BLOB  blobCMC;
    WCHAR  wszMyDNName[] = L"CN=Xenroll CMC Test";
    LONG   lKeySize;

    ZeroMemory(&blobCMC, sizeof(blobCMC));



    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
    {
        goto PIEnroll4GetNoCOMError;
    }

    if (NULL != g_pszKeyContainer)
    {
        hr = myMultiByteToWideChar(g_pszKeyContainer, &pwszKeyContainer);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    if (NULL != pwszKeyContainer)
    {
        hr = pIEnroll4->put_ContainerNameWStr(pwszKeyContainer);
        if (S_OK != hr)
        {
            goto put_ContainerNameWStrError;
        }
    }

    hr = pIEnroll4->resetExtensions();
    if (S_OK != hr)
    {
        goto resetExtensionsError;
    }

    hr = pIEnroll4->resetAttributes();
    if (S_OK != hr)
    {
        goto resetAttributesError;
    }

    //add some extensions

    //add some attributes
    hr = pIEnroll4->addNameValuePairToRequestWStr(
                    0,
                    L"NameValue name",
                    L"NameValue value");
    if (S_OK != hr)
    {
        goto addNameValuePairToRequestWStrError;
    }

    if (NULL != g_pszCAXchgFileName)
    {
        //get a ca cert
        hCAFile = CreateFileA(
                    g_pszCAXchgFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
        if (NULL != hCAFile)
        {
            cchCACert = GetFileSize(hCAFile, NULL);
            assert(0 < cchCACert);
            pchCACert = (CHAR*)LocalAlloc(LMEM_FIXED, cchCACert);
            if (NULL == pchCACert)
            {
                goto LocalAllocError;
            }
            if (!ReadFile(hCAFile, pchCACert, cchCACert, &cbRead, NULL))
            {
                goto ReadFileError;
            }
            assert(cbRead <= cchCACert);
    
            pbCACert = NULL;
            while (TRUE)
            {
                if (!CryptStringToBinaryA(
                            pchCACert,
                            cchCACert,
                            CRYPT_STRING_ANY,
                            pbCACert,
                            &cbCACert,
                            NULL,
                            NULL))
                {
                    goto CryptStringToBinaryAError;
                }
                if (NULL != pbCACert)
                {
                    break;
                }
                pbCACert = (BYTE*)LocalAlloc(LMEM_FIXED, cbCACert);
                if (NULL == pbCACert)
                {
                    goto LocalAllocError;
                }
            }
            pCACert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbCACert,
                            cbCACert);
            if (NULL == pCACert)
            {
                goto CertCreateCertificateContextError;
            }

            hr = pIEnroll4->SetPrivateKeyArchiveCertificate(
                        pCACert);
            if (S_OK != hr)
            {
                goto SetPrivateKeyArchiveCertificateError;
            }
        }

#if 0
        hr = pIEnroll4->put_GenKeyFlags(CRYPT_EXPORTABLE);
        if (S_OK != hr)
        {
            goto put_GenKeyFlagsError;
        }
#endif
    }

    pwszDNName = wszMyDNName;
    if (NULL != g_pszDNName)
    {
        hr = myMultiByteToWideChar(g_pszDNName, &pwszDNName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    if (NULL != g_pszCMCFileName)
    {
        hr = myMultiByteToWideChar(g_pszCMCFileName, &pwszCMCFileName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    // enroll for a new cert
    if (NULL != pwszCMCFileName)
    {
        hr = pIEnroll4->createFileRequestWStr(
                    XECR_CMC,
                    pwszDNName,
                    NULL,
                    pwszCMCFileName);
    }
    else
    {
        hr = pIEnroll4->createRequestWStr(
                    XECR_CMC,
                    pwszDNName,
                    NULL,
                    &blobCMC);
    }
    if (S_OK != hr)
    {
        goto createRequestWStrError;
    }


    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pchCACert)
    {
        LocalFree(pchCACert);
    }
    if (NULL != pbCACert)
    {
        LocalFree(pbCACert);
    }
    if (NULL != pwszCMCFileName)
    {
        LocalFree(pwszCMCFileName);
    }
    if (NULL != pwszDNName && pwszDNName != wszMyDNName)
    {
        LocalFree(pwszDNName);
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (NULL != hCAFile)
    {
        CloseHandle(hCAFile);
    }
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    if (NULL != blobCMC.pbData)
    {
        LocalFree(blobCMC.pbData);
    }

   return fRet;


PRINT_ERROR(CryptStringToBinaryAError)
#if 0
PRINT_ERROR2(put_GenKeyFlagsError, hr)
#endif
PRINT_ERROR2(SetPrivateKeyArchiveCertificateError, hr)
PRINT_ERROR(CertCreateCertificateContextError)
PRINT_ERROR(ReadFileError)
PRINT_ERROR2(createRequestWStrError, hr)
PRINT_ERROR2(addNameValuePairToRequestWStrError, hr)
PRINT_ERROR2(resetExtensionsError, hr)
PRINT_ERROR2(resetAttributesError, hr)
PRINT_ERROR(PIEnroll4GetNoCOMError)
PRINT_ERROR2(put_ContainerNameWStrError, hr)
PRINT_ERROR2(LocalAllocError, E_OUTOFMEMORY)
PRINT_ERROR2(myMultiByteToWideCharError, hr)
}

// test Enroll4 interface, accept CMC response
BOOL Test12()
{
    HRESULT  hr;
    BOOL  fRet = FALSE;
    IEnroll4 *pIEnroll4 = NULL;
    int cch;
    WCHAR  *pwszResponseFile = NULL;

    if (NULL == g_pszCMCResponseFileName)
    {
        //skip the test
        printf("Test12 is skipped\n");
        fRet = TRUE;
        goto ErrorReturn;
    }

    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
    {
        goto PIEnroll4GetNoCOMError;
    }


    hr = myMultiByteToWideChar(g_pszCMCResponseFileName, &pwszResponseFile);
    if (S_OK != hr)
    {
        goto myMultiByteToWideCharError;
    }

    hr = pIEnroll4->acceptFileResponseWStr(pwszResponseFile);
    if (S_OK != hr)
    {
        goto acceptFileResponseWStrError;
    }

    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszResponseFile)
    {
        LocalFree(pwszResponseFile);
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
   return fRet;

PRINT_ERROR(PIEnroll4GetNoCOMError)
PRINT_ERROR(acceptFileResponseWStrError)
PRINT_ERROR(myMultiByteToWideCharError)
}

// Test pending API
BOOL Test13()
{
    BOOL                        fRet; 
    CRYPT_DATA_BLOB             pkcs10Blob; 
    DWORD                       dwIndex; 
    DWORD                       dwNumTests; 
    HRESULT                     hr; 
    IEnroll4                   *pIEnroll4    = NULL; 
    PCCERT_CONTEXT              pCertContext = NULL; 
    TXEnrollPendingAPITester   *pTester      = NULL; 
    WCHAR                       wszDNName[]  = L"CN=Xenroll PendingAPI Test";


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // TEST CASES
    //
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    PENDING_INFO rgPendingTests[] = { 
	// 0) Normal inputs
	{ 
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,                              
	    NULL,
	    S_OK 
	},       
	
	// 1) Negative Req ID
	{
	    -1, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG
	}, 

	// 2) NULL CA location. 
	{
	    100, 
	    NULL,                           
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG 
	},

	// 3) NULL CA name. 
	{
	    100,
	    L"duncanb1.ntdev.microsoft.com", 
	    NULL,                        
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG 
	},

	// 4) NULL friendly name. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1",
	    NULL,         
	    0,   
	    NULL,                            
	    S_OK
	},         

	// 5) Specify USER store flags. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    CERT_SYSTEM_STORE_CURRENT_USER,  
	    NULL,
	    S_OK 
	},        

	// 6) Specify LM store flags. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    CERT_SYSTEM_STORE_LOCAL_MACHINE, 
	    NULL,
	    S_OK 
	}, 
	// 7) Long names: 
	{ 
	    100, 
	    L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.com"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.com", 

	    L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1", 

	    L"SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI", 
	    0, 
	    NULL,
	    S_OK 
	}
    };

    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
    
    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
        goto PIEnroll4GetNoCOMError;
    
    pTester = new TXEnrollPendingAPITester; 
    if (NULL == pTester)
	goto MemoryError; 

    // Test the ThumbPrintWStr property. 
    if (!pTester->TestProperty_ThumbPrintWStr(pIEnroll4))
	goto TestProperty_ThumbPrintWStrError; 

    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
        goto PIEnroll4GetNoCOMError;
    
    // Test the removePendingRequestWStr method. 
    if (!pTester->TestMethod_removePendingRequestWStr(pIEnroll4))
	goto TestMethod_removePendingRequestWStrError; 

    // Test all enumPending / setPendingInfo cases:
    dwNumTests = sizeof(rgPendingTests) / sizeof(PENDING_INFO); 
    for (dwIndex = 0; dwIndex < dwNumTests; dwIndex++)
    {
	pIEnroll4 = PIEnroll4GetNoCOM();
	if(NULL == pIEnroll4)
	    goto PIEnroll4GetNoCOMError;

	if (S_OK != (hr = pIEnroll4->resetExtensions()))
	    goto resetExtensionsError;
	
	if (S_OK != (hr = pIEnroll4->resetAttributes()))
	    goto resetAttributesError;

	// Small key size so the test runs faster. 
	if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	    goto put_GenKeyFlagsError; 

	// Default to CURRENT_USER.  
	if (0 == rgPendingTests[dwIndex].dwStoreFlags)
	    rgPendingTests[dwIndex].dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
	
	// Default to REQUEST store. 
	if (NULL == rgPendingTests[dwIndex].pwszStoreName)
	    rgPendingTests[dwIndex].pwszStoreName = L"REQUEST"; 

	if (S_OK != (hr = pIEnroll4->put_RequestStoreFlags(rgPendingTests[dwIndex].dwStoreFlags)))
	    goto put_RequestStoreFlagsError;
	    
	if (S_OK != (hr = pIEnroll4->put_RequestStoreNameWStr(rgPendingTests[dwIndex].pwszStoreName)))
	    goto put_RequestStoreNameWStrError; 

	// Create a request to test on. 
	if (S_OK != (hr = pIEnroll4->createRequestWStr
		     (XECR_PKCS10_V2_0,
		      wszDNName,
              NULL,
		      &pkcs10Blob)))
	    goto createRequestWStrError;

	if (!pTester->TestMethod_setPendingInfoWStr(pIEnroll4, pkcs10Blob, &rgPendingTests[dwIndex]))
	    goto TestMethod_setPendingInfoWStrError; 

	// only continue if we are not testing a failure case. 
	// Eventually this should be extended to test the failure cases for enumPendingRequestWStr. 
	if (S_OK == rgPendingTests[dwIndex].hrExpectedResult)
	{
	    if (!pTester->TestMethod_enumPendingRequestWStr(pIEnroll4, pkcs10Blob, &rgPendingTests[dwIndex]))
		goto TestMethod_enumPendingRequestWStrError; 

	}

	pCertContext = GetCertOutOfStore(&pkcs10Blob, rgPendingTests[dwIndex].dwStoreFlags, rgPendingTests[dwIndex].pwszStoreName); 
	if (NULL == pCertContext)
	    goto GetCertOutOfStoreError; 
	
	CertDeleteCertificateFromStore(pCertContext); 
	LocalFree(pkcs10Blob.pbData); 
	ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
	pCertContext = NULL; 
        pIEnroll4->Release(); 
    }
    
    fRet = TRUE; 

 CommonReturn:
    if (NULL != pkcs10Blob.pbData) 
    { 
	pCertContext = GetCertOutOfStore(&pkcs10Blob, rgPendingTests[dwIndex].dwStoreFlags, rgPendingTests[dwIndex].pwszStoreName); 
	if (NULL != pCertContext) { CertDeleteCertificateFromStore(pCertContext); }
	LocalFree(pkcs10Blob.pbData); 
    } 
    return fRet;
    
 ErrorReturn: 
    fRet = FALSE; 
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError,                   hr); 
PRINT_ERROR2(GetCertOutOfStoreError,                   hr = GetLastError()); 
PRINT_ERROR2(MemoryError,                              hr = E_OUTOFMEMORY); 
PRINT_ERROR2(PIEnroll4GetNoCOMError,                   hr = GetLastError()); 
PRINT_ERROR2(put_GenKeyFlagsError,                     hr); 
PRINT_ERROR2(put_RequestStoreFlagsError,               hr); 
PRINT_ERROR2(put_RequestStoreNameWStrError,            hr); 
PRINT_ERROR2(resetAttributesError,                     hr);
PRINT_ERROR2(resetExtensionsError,                     hr);
PRINT_ERROR2(TestMethod_enumPendingRequestWStrError,   hr = GetLastError()); 
PRINT_ERROR2(TestMethod_removePendingRequestWStrError, hr = GetLastError()); 
PRINT_ERROR2(TestMethod_setPendingInfoWStrError,       hr = GetLastError()); 
PRINT_ERROR2(TestProperty_ThumbPrintWStrError,         hr = GetLastError()); 
}


// test Enroll4 misc. methods
BOOL Test14()
{
    BOOL  fRet = FALSE;
    HRESULT  hr;
    ICEnroll4  *pICEnroll = NULL;
    ICEnroll4  *pICEnroll2 = NULL;
    ICEnroll4  *pICEnroll3 = NULL;
    ICEnroll4  *pICEnroll4 = NULL;
    IEnroll4 *pIEnroll = NULL;
    IEnroll4 *pIEnroll2 = NULL;
    IEnroll4 *pIEnroll4 = NULL;
    LONG   lKeySize;
    BOOL        fCoInit = FALSE;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        goto CoInitializeError;
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll,
                (void **) &pICEnroll);
    if( S_OK != hr || NULL == pICEnroll)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll2,
                (void **) &pICEnroll2);
    if( S_OK != hr || NULL == pICEnroll2)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll2) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll3,
                (void **) &pICEnroll3);
    if( S_OK != hr || NULL == pICEnroll3)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll3) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll4,
                (void **) &pICEnroll4);
    if( S_OK != hr || NULL == pICEnroll4)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll4) test passed\n");
    }


    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll,
                (void **) &pIEnroll);
    if( S_OK != hr || NULL == pIEnroll)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll2);
    if( S_OK != hr || NULL == pIEnroll2)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll2) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll4);
    if( S_OK != hr || NULL == pIEnroll4)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll4) test passed\n");
    }


    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MIN, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Minimun exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MAX, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Maximun exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_DEFAULT, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Default exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_INC, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Exchange key increment size is %d\n", lKeySize);
    }

    //signature key
    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MIN, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Minimun signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MAX, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Maximun signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_DEFAULT, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Default signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_INC, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Signature key increment size is %d\n", lKeySize);
    }

    fRet = TRUE;
ErrorReturn:
    if(NULL != pICEnroll)
    {
        pICEnroll->Release();
    }
    if(NULL != pICEnroll2)
    {
        pICEnroll2->Release();
    }
    if(NULL != pICEnroll3)
    {
        pICEnroll3->Release();
    }
    if(NULL != pICEnroll4)
    {
        pICEnroll4->Release();
    }
    if(NULL != pIEnroll)
    {
        pIEnroll->Release();
    }
    if(NULL != pIEnroll2)
    {
        pIEnroll2->Release();
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return fRet;

PRINT_ERROR2(CoCreateInstanceError, hr)
PRINT_ERROR2(CoInitializeError, hr)
PRINT_ERROR2(GetKeyLenExError, hr)
}

// test acceptPKCS7 and PFX
BOOL Test15()
{
    BOOL  fRet = FALSE;
    HRESULT  hr;
    IEnroll4 *pIEnroll4 = NULL;
    BOOL        fCoInit = FALSE;
    WCHAR    *pwszPKCS7FileName = NULL;
    WCHAR    *pwszPFXFileName = NULL;
    WCHAR    *pwszPFXPassword = NULL;
    WCHAR    wszEmptyPassword[] = L"";

    if (MAXDWORD == g_dwTestID &&
        NULL == g_pszPKCS7FileName)
    {
        printf("Test15 is skipped.\n");
        goto done;
    }

    if (NULL == g_pszPKCS7FileName)
    {
        printf("You must provide a PKCS7 file\n");
        goto MissedPKCS7FileError;
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        goto CoInitializeError;
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll4);
    if( S_OK != hr || NULL == pIEnroll4)
    {
        goto CoCreateInstanceError;
    }

    hr = myMultiByteToWideChar(g_pszPKCS7FileName, &pwszPKCS7FileName);
    if (S_OK != hr)
    {
        goto myMultiByteToWideCharError;
    }

    hr = pIEnroll4->acceptFilePKCS7WStr(pwszPKCS7FileName);
    if (S_OK != hr)
    {
        goto acceptFilePKCS7WStrError;
    }

    if (NULL != g_pszPFXFileName)
    {
        if (NULL == g_pszPFXPassword)
        {
            pwszPFXPassword = wszEmptyPassword;
            if (g_fVerb)
            {
                printf("Empty PFX password is used.\n");
            }
        }
        hr = myMultiByteToWideChar(g_pszPFXFileName, &pwszPFXFileName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
        if (NULL != g_pszPFXPassword)
        {
            hr = myMultiByteToWideChar(g_pszPFXPassword, &pwszPFXPassword);
            if (S_OK != hr)
            {
                goto myMultiByteToWideCharError;
            }
        }

        //create pfx file
        hr = pIEnroll4->createFilePFXWStr(pwszPFXPassword, pwszPFXFileName);
        if (S_OK != hr)
        {
            goto createFilePFXWStrError;
        }
    }

done:
    fRet = TRUE;
ErrorReturn:

    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL != pwszPKCS7FileName)
    {
        LocalFree(pwszPKCS7FileName);
    }
    if (NULL != pwszPFXFileName)
    {
        LocalFree(pwszPFXFileName);
    }
    if (NULL != pwszPFXPassword && pwszPFXPassword != wszEmptyPassword)
    {
        LocalFree(pwszPFXPassword);
    }
    return fRet;

PRINT_ERROR2(CoCreateInstanceError, hr)
PRINT_ERROR2(myMultiByteToWideCharError, hr)
PRINT_ERROR2(acceptFilePKCS7WStrError, hr)
PRINT_ERROR2(createFilePFXWStrError, hr)
PRINT_ERROR2(CoInitializeError, hr)
PRINT_ERROR2(MissedPKCS7FileError, E_INVALIDARG)
}

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(DWORD cTest)
{
    printf("Usage: txenrol [options]\n");
    printf(" options:\n");
    printf(" -h this help\n");
    printf(" -k [KeyContainerName]\n");
    printf(" -n [DNName]\n");
    printf(" -x [CAExchangeCertFileName]\n");
    printf(" -o [CMCRequestFileName]\n");
    printf(" -s [#] stress test count\n");
    printf(" -t [TestID] run single test. There are %d tests.\n", cTest);
    printf(" -r [CMCResponseFile]\n");
    printf(" -a [PKCS7FileName]\n");
    printf(" -f [PFXFileName], -a is required\n");
    printf(" -w [PFXPassword], -a is required. If no -p, empty password is used.\n");
    printf(" -p pause before each test\n");
    printf(" -v verbose\n");

    printf("\n");
    printf(" Test1:  basic operation, gen keys, gen request, accept cert.\n");
    printf(" Test2:  basic operation but with no EKU or no DN name.\n");
    printf(" Test3:  test renewal cert.\n");
    printf(" Test4:  basic operation but put the certs in HKLM\n");
    printf(" Test5:  test self signed certificate creation\n");
    printf(" Test6:  basic operation with attributes\n");
    printf(" Test7:  basic operation but put the certs in HKLM\n");
    printf(" Test8:  test some alg enum stuff\n");
    printf(" Test9:  test some alg enum stuff\n");
    printf(" Test10: test renewal\n");
    printf(" Test11: test CMC request generation\n");
    printf(" Test12: test CMC response. skipped except -r is passed\n");
    printf(" Test13: test pending API\n");   
    printf(" Test14: test Enroll4 misc. methods\n");   
    printf(" Test15: test acceptPKCS7 and PFX\n");   
}

BOOL
ParseOptions(int argc, char *argv[])
{
    int i;

    for (i = 1; i < argc; ++i)
    {
        if ('-' == argv[i][0])
        {
            switch (argv[i][1])
            {
                case 'n':
                case 'N':
                ++i;
                if (i < argc)
                {
                    g_pszDNName = argv[i];
                }
                else
                {
                    printf("missed DNName\n");
                    return FALSE;
                }
                break;

                case 'x':
                case 'X':
                ++i;
                if (i < argc)
                {
                    g_pszCAXchgFileName = argv[i];
                }
                else
                {
                    printf("missed CAExchangeFileName\n");
                    return FALSE;
                }
                break;

                case 'o':
                case 'O':
                ++i;
                if (i < argc)
                {
                    g_pszCMCFileName = argv[i];
                }
                else
                {
                    printf("missed CMCRequestFileName\n");
                    return FALSE;
                }
                break;

                case 'w':
                case 'W':
                ++i;
                if (i < argc)
                {
                    g_pszPFXPassword = argv[i];
                }
                else
                {
                    printf("missed PFXPassword\n");
                    return FALSE;
                }
                break;

                case 'f':
                case 'F':
                ++i;
                if (i < argc)
                {
                    g_pszPFXFileName = argv[i];
                }
                else
                {
                    printf("missed PFXFileName\n");
                    return FALSE;
                }
                break;

                case 'a':
                case 'A':
                ++i;
                if (i < argc)
                {
                    g_pszPKCS7FileName = argv[i];
                }
                else
                {
                    printf("missed PKCS7FileName\n");
                    return FALSE;
                }
                break;

                case 'r':
                case 'R':
                ++i;
                if (i < argc)
                {
                    g_pszCMCResponseFileName = argv[i];
                }
                else
                {
                    printf("missed CMCResponseFileName\n");
                    return FALSE;
                }
                break;

                case 'k':
                case 'K':
                ++i;
                if (i < argc)
                {
                    g_pszKeyContainer = argv[i];
                }
                else
                {
                    printf("missed KeyContainerName\n");
                    return FALSE;
                }
                break;

                case 's':
                case 'S':
                ++i;
                if (i < argc)
                {
                    g_cStress = atoi(argv[i]);
                }
                break;

                case 't':
                case 'T':
                ++i;
                if (i < argc)
                {
                    g_dwTestID = atoi(argv[i]);
                }
                break;

                case 'p':
                case 'P':
                    g_fPause = TRUE;
                break;

                case 'v':
                case 'V':
                    g_fVerb = TRUE;
                break;

                case 'h':
                case 'H':
                    return FALSE;

                default:
                    printf("Unrecognized options -%c\n", argv[i][1]);
                    return FALSE;
                break;
            }
        }
        else
        {
            printf("Unrecognized options %s\n", argv[i]);
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
typedef BOOL (* PFNTest)(void);
PFNTest arPfnTest[] = {Test1, Test2, Test3, Test4, Test5, Test6, Test7, Test8, Test9, Test10, Test11, Test12, Test13, Test14, Test15};
#define COUNT_TEST   sizeof(arPfnTest)/sizeof(arPfnTest[0])

int _cdecl main(int argc, char * argv[])
{
    int                 ErrReturn           = 0;
    DWORD               i;
    DWORD               n;
    DWORD               NBRTests            = sizeof(arPfnTest) / sizeof(PFNTest);
    BOOL                fPassed = TRUE;

    if (1 > argc)
    {
        Usage(COUNT_TEST);
        return( 1 );
    }

    //parse options
    if (!ParseOptions(argc, argv))
    {
        Usage(COUNT_TEST);
        return (1);
    }
    
    for (DWORD n = 0; n < g_cStress; ++n)
    {
        if (g_fPause)
        {
            char wszgets[3];
            if (MAXDWORD == g_dwTestID)
            {
                printf("press enter key to start the tests ...");
            }
            else
            {
                printf("press enter key to run Test%d ...", g_dwTestID);
            }
            gets(wszgets);
        }
        if (MAXDWORD != g_dwTestID &&
                 COUNT_TEST >= g_dwTestID)
        {
            //only do one test
            if (!arPfnTest[g_dwTestID - 1]())
            {
                printf("Test%d failed.\n", g_dwTestID);
                fPassed = FALSE;
            }
            else
            {
                printf("Test%d finished.\n", g_dwTestID);
            }
        }
        else
        {
            for(i=0; i<NBRTests; i++)
            {
                if( !arPfnTest[i]() )
                {
                    printf("Test%d failed.\n", i+1);
                    fPassed = FALSE;
                }
                else
                {
                    printf("Test%d finished.\n", i+1);
                }
            }
        }
        if (1 < g_cStress)
        {
            printf("test round %d finished\n", n+1);
        }
    }

    if (fPassed)
    {
        printf("All XEnroll tests passed.\n");
    }
    else
    {
        printf("One or more XEnroll tests didn't pass.\n");
    }
    
    return(ErrReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\cryptpko.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:      CryptPKO.cpp
//
//  content:   Implements the IContextMenu member functions necessary to support
//             the context menu portioins of this shell extension.  Context menu
//             shell extensions are called when the user right clicks on a file

//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------
#include "stdafx.h"
#include "cryptext.h"
#include "private.h"
#include "CryptPKO.h"

//QueryContextMenu is called twice by the Shell.
//we have to set the flag.
BOOL            g_fDefaultCalled=FALSE;


HRESULT I_InvokeCommand(LPWSTR  pwszFileName, UINT    idCmd, BOOL    fDefault)
{

    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    HCERTSTORE      hCertStore=NULL;
    HCRYPTMSG       hMsg=NULL;
    const void      *pvContext=NULL;
    UINT            idsFileName=0;


	HRESULT         hr = E_FAIL;

    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;
    CRYPTUI_VIEWCRL_STRUCT          CRLViewStruct;
    CRYPTUI_WIZ_IMPORT_SRC_INFO             importSubject;

    //get the content type of the file
     //we care about every file type except for the signed doc
   if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       &hCertStore,
                       &hMsg,
                       &pvContext))
    {

        I_NoticeBox(
			GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PKO_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);

       goto CLEANUP;
    }

    //make sure idCmd is the correct valud for different types
    //we are guaranteed that idCmd is 1 or 0
    if(CERT_QUERY_CONTENT_CERT != dwContentType &&
       CERT_QUERY_CONTENT_CTL  != dwContentType &&
       CERT_QUERY_CONTENT_CRL  != dwContentType && 
       CERT_QUERY_CONTENT_PKCS7_SIGNED != dwContentType)
    {
        if(1==idCmd)
        {
            hr=E_INVALIDARG;
            goto CLEANUP;
        }
    }


    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
                if(idCmd==0)
                {
                    //call the Certificate Common Dialogue
                    memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));

                    CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                    CertViewStruct.pCertContext=(PCCERT_CONTEXT)pvContext;

                    CryptUIDlgViewCertificate(&CertViewStruct, NULL);
                }
                else
                {
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                    importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
                    importSubject.pCertContext=(PCCERT_CONTEXT)pvContext;

                    CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject,
                        NULL);
                }
            break;

        case CERT_QUERY_CONTENT_CTL:
                if(idCmd==0)
                    I_ViewCTL((PCCTL_CONTEXT)pvContext);
                else
                {
                    //we do not need to install a catalog file
                    if(!IsCatalog((PCCTL_CONTEXT)pvContext))
                    {
                        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT;
                        importSubject.pCTLContext=(PCCTL_CONTEXT)pvContext;

                        CryptUIWizImport(0,
                            NULL,
                            NULL,
                            &importSubject,
                            NULL);
                    }
                }

            break;
        case CERT_QUERY_CONTENT_CRL:
                if(idCmd==0)
                {
                    //call the CRL view dialogue
                    memset(&CRLViewStruct, 0, sizeof(CRYPTUI_VIEWCRL_STRUCT));

                    CRLViewStruct.dwSize=sizeof(CRYPTUI_VIEWCRL_STRUCT);
                    CRLViewStruct.pCRLContext=(PCCRL_CONTEXT)pvContext;

                    CryptUIDlgViewCRL(&CRLViewStruct);
                }
                else
                {
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                    importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT;
                    importSubject.pCRLContext=(PCCRL_CONTEXT)pvContext;

                    CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject,
                        NULL);
                }
            break;

        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
                    idsFileName=IDS_SERIALIZED_STORE;

        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
                    if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_CERT;

        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
                     if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_STL;

       case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                    if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_CRL;

                if(!FIsWinNT5())
                {
                    I_NoticeBox(
						0,
                        0,
                        NULL, 
                        IDS_MSG_VALID_TITLE,
                        idsFileName,
                        IDS_MSG_VALID_SIGN_FILE,  
                        MB_OK|MB_ICONINFORMATION);
                }
                else
                {
                    LauchCertMgr(pwszFileName);
                }
            break;

        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
                if(idCmd==0)
                {
                    if(!FIsWinNT5())
                    {
                        I_NoticeBox(
							0,
                            0,
                            NULL, 
                            IDS_MSG_VALID_TITLE,
                            IDS_PKCS7_NAME,
                            IDS_MSG_VALID_SIGN_FILE,  
                            MB_OK|MB_ICONINFORMATION);
                    }
                    else
                    {
                        LauchCertMgr(pwszFileName);
                    }
                }
                else
                {
                    //we are doing the import
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
					importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
					importSubject.pwszFileName=pwszFileName;

                    CryptUIWizImport(0,
                                    NULL,
                                    NULL,
                                    &importSubject, 
                                    NULL);

                }
            break;


        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:

                    I_NoticeBox(
						0,
                        0,
                        NULL, 
                        IDS_MSG_VALID_TITLE,
                        IDS_SIGN_NAME,
                        IDS_MSG_VALID_SIGN_FILE,  
                        MB_OK|MB_ICONINFORMATION);

            break;

        case CERT_QUERY_CONTENT_PFX:
                memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
                importSubject.pwszFileName=pwszFileName;

                CryptUIWizImport(0,
                                NULL,
                                NULL,
                                &importSubject,
                                NULL);


            break;

        case CERT_QUERY_CONTENT_PKCS7_UNSIGNED:

                I_NoticeBox(
					0,
                    0,
                    NULL, 
                    IDS_MSG_VALID_TITLE,
                    IDS_PKCS7_UNSIGNED_NAME,
                    IDS_MSG_VALID_FILE,  
                    MB_OK|MB_ICONINFORMATION);

            break;

        case CERT_QUERY_CONTENT_PKCS10:
                I_NoticeBox(
					0,
                    0,
                    NULL, 
                    IDS_MSG_VALID_TITLE,
                    IDS_P10_NAME,
                    IDS_MSG_VALID_FILE,  
                    MB_OK|MB_ICONINFORMATION);

            break;
        default:

            break;
    }


    hr=S_OK;

CLEANUP:


    //relaset the stores and reset the local parameters
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);


    if(pvContext)
    {

        if(dwContentType == CERT_QUERY_CONTENT_CERT ||
            dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CERT)
                CertFreeCertificateContext((PCCERT_CONTEXT)pvContext);
        else
        {
            if(dwContentType == CERT_QUERY_CONTENT_CTL ||
                dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CTL)
                    CertFreeCTLContext((PCCTL_CONTEXT)pvContext);
            else
            {
                if(dwContentType == CERT_QUERY_CONTENT_CRL ||
                        dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CRL)
                            CertFreeCRLContext((PCCRL_CONTEXT)pvContext);
            }
        }
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCryptPKO

//--------------------------------------------------------------
//
//  FUNCTION: GAKPageCallback(HWND, UINT, LPPROPSHEETPAGE)
//
//  PURPOSE: Callback  procedure for the property page
//
//  PARAMETERS:
//    hWnd      - Reserved (will always be NULL)
//    uMessage  - Action flag: Are we being created or released
//    ppsp      - The page that is being created or destroyed
//
//  RETURN VALUE:
//
//    Depends on message.
//
//    For PSPCB_CREATE it's TRUE to let the page be created
//    or false to prevent it from being created.
//    For PSPCB_RELEASE the return value is ignored.
//
//  COMMENTS:
//
BOOL CALLBACK
SignPKOPageCallBack(HWND hWnd,
                UINT uMessage,
                void  *pvCallBack)
{
    switch(uMessage)
    {
        case PSPCB_CREATE:
            return TRUE;

        case PSPCB_RELEASE:
            if (pvCallBack)
            {
               ((IShellPropSheetExt *)(pvCallBack))->Release();
            }
            return TRUE;
    }
    return TRUE;
}

//--------------------------------------------------------------
//
//  Constructor
//
//--------------------------------------------------------------
CCryptPKO::CCryptPKO()
{
     m_pDataObj=NULL;
}


//--------------------------------------------------------------
//
//  Destructor
//
//--------------------------------------------------------------
CCryptPKO::~CCryptPKO()
{
    if (m_pDataObj)
        m_pDataObj->Release();
}


//--------------------------------------------------------------
//  FUNCTION: CCryptSig::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptPKO::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE  hpage;
    PROPSHEETPAGEW  *pPage=NULL;
    DWORD           dwPage=0;
    DWORD           dwIndex=0;

    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    HCRYPTMSG       hMsg=NULL;
    HRESULT         hr=E_FAIL;
    DWORD           dwExceptionCode=0;

    CRYPTUI_VIEWSIGNATURES_STRUCTW  sigView;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
    {
        ReleaseStgMedium(&stgm);
        return  NOERROR;    //  Shouldn't happen, but it's not important
    }


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
    {
        ReleaseStgMedium(&stgm);
        return NOERROR;
    }


    //get the content type of the file.  We only cares about
    //the signed document in binary format
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                       CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       &hMsg,
                       NULL))
    {
        //can not recognize the object.  Fine
        goto CLEANUP;
    }


    //add the property sheet page
    memset(&sigView, 0, sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW));
    sigView.dwSize=sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW);
    sigView.choice=hMsg_Chosen;
    sigView.u.hMsg=hMsg;
    sigView.szFileName=wszFileName;
    sigView.pPropPageCallback=SignPKOPageCallBack;
    sigView.pvCallbackData=this;

    if(!CryptUIGetViewSignaturesPagesW(
            &sigView,
            &pPage,
            &dwPage))
        goto CLEANUP;

    __try {
        for(dwIndex=0; dwIndex<dwPage; dwIndex++)
        {

            //add the callback functions to release the refcount
            //pPage[dwIndex].dwFlags |= PSP_USECALLBACK;

            //pPage[dwIndex].pfnCallback=SignPKOPageCallBack;
            //pPage[dwIndex].pcRefParent=(UINT *)this;

            hpage = CreatePropertySheetPageU(&(pPage[dwIndex]));

            ((IShellPropSheetExt *)this)->AddRef();

            if (hpage)
            {
                if (!lpfnAddPage(hpage, lParam))
                {
                    DestroyPropertySheetPage(hpage);
                    ((IShellPropSheetExt *)this)->Release();
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto CLEANUP;
    }




CLEANUP:

    ReleaseStgMedium(&stgm);

    if(pPage)
        CryptUIFreeViewSignaturesPagesW(pPage, dwPage);

    if(hMsg)
        CryptMsgClose(hMsg);


    return NOERROR;
}

//--------------------------------------------------------------

//  FUNCTION: CCryptSig::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptPKO::ReplacePage(UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                    LPARAM lParam)
{
    return E_FAIL;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//     We always return NOERROR unless when we succeeded, when
//     we have to return  HRESULT structure in which, if the method
//     is successful, the code member contains the menu identifier
//     offset of the last menu item added plus one.
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::QueryContextMenu(HMENU hMenu,
                                         UINT indexMenu,
                                         UINT idCmdFirst,
                                         UINT idCmdLast,
                                         UINT uFlags)
{
    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    WCHAR           wszOpen[MAX_COMMAND_LENGTH];
    WCHAR           wszAdd[MAX_COMMAND_LENGTH];
    WCHAR           wszViewSig[MAX_COMMAND_LENGTH];
    UINT            idCmd = idCmdFirst;
    UINT            idCmdDefault=idCmdFirst;
    MENUITEMINFOA   MenuItemInfo;
    void            *pContext=NULL;

    //init the menuInfo for setting the default menu
    memset(&MenuItemInfo, 0, sizeof(MENUITEMINFOA));
    MenuItemInfo.cbSize=sizeof(MENUITEMINFOA);
    MenuItemInfo.fMask=MIIM_STATE;
    MenuItemInfo.fState=MFS_DEFAULT;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  NOERROR;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return NOERROR;

    //if user double click on a file, we need the take the
    //default action
   /* if(uFlags & CMF_DEFAULTONLY)
    {
        //QueryContextMenu is called twice by the Shell.
        //we have to set the flag.
        if(FALSE==g_fDefaultCalled)
        {

            hr=I_InvokeCommand(pwszFileName, 0, TRUE);
            g_fDefaultCalled=TRUE;
        }
        else
            g_fDefaultCalled=FALSE;

        idCmd=idCmdFirst;

        goto CLEANUP;
    }       */

    //decide if we need to add the context menu
    if (!(
           ((uFlags & 0x000F) == CMF_NORMAL)||
           (uFlags & CMF_VERBSONLY) ||
           (uFlags & CMF_EXPLORE) ||
           (uFlags & CMF_DEFAULTONLY)
         ))
        goto CLEANUP;

    //load the string
    if(!LoadStringU(g_hmodThisDll, IDS_MENU_OPEN, wszOpen, sizeof(wszOpen)/sizeof(wszOpen[0]))||
       !LoadStringU(g_hmodThisDll, IDS_MENU_VIEWSIG, wszViewSig, sizeof(wszViewSig)/sizeof(wszViewSig[0]))
       )
        goto CLEANUP;

    //get the content type of the file
    //we care about every file type and every format type
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       NULL,
                       NULL,
                       (const void **)&pContext))
    {
                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //  if there is no default verb, set open as default
                if (GetMenuDefaultItem(hMenu, MF_BYPOSITION, 0) == -1)            
                {
                     //  use indexMenu - 1 since we incremented indexMenu in the InsertMenu
                     SetMenuDefaultItem(hMenu, indexMenu -1, MF_BYPOSITION);
                }

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
               /* SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);   */

                goto CLEANUP;
    }

    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
                //get the correct wording for the second menu item based
                // on the content
                if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_CERT, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                    goto CLEANUP;

        case CERT_QUERY_CONTENT_CTL:

                if(CERT_QUERY_CONTENT_CTL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_STL, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;
                }

        case CERT_QUERY_CONTENT_CRL:

                if(CERT_QUERY_CONTENT_CRL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_CRL, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;
                }

                //make sure we can add at least two items
                if(2 > (idCmdLast-idCmdFirst))
                    goto CLEANUP;

                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                //set the default menu item
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);


                //add the add menu
                //do not put "install" for the catalog files
                if( !((CERT_QUERY_CONTENT_CTL == dwContentType)
                    && IsCatalog((PCCTL_CONTEXT)pContext))
                  )
                {
                    if(0==InsertMenuU(hMenu,
                       indexMenu++,
                       MF_STRING|MF_BYPOSITION,
                       idCmd++,
                       wszAdd))
                        goto CLEANUP;
                }

            break;


        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
        case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);

           break;

        case  CERT_QUERY_CONTENT_PFX:
               if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_PFX, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;

                //add the install menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszAdd))
                    goto CLEANUP;

                //set the add to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);


            break;


        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:
                //signed data case is handled by the property sheet extension
        default:
            //we do not worry about CERT_QUERY_CONTENT_PKCS7_UNSIGNED or
            //CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX for now
            //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //  if there is no default verb, set open as default
                if (GetMenuDefaultItem(hMenu, MF_BYPOSITION, 0) == -1)            
                {
                     //  use indexMenu - 1 since we incremented indexMenu in the InsertMenu
                     SetMenuDefaultItem(hMenu, indexMenu -1, MF_BYPOSITION);
                }

            break;
    }


CLEANUP:

    if(idCmd-idCmdFirst)
    {
        //Must return number of menu items we added.
        hr=ResultFromShort(idCmd-idCmdFirst);
    }
    else
        //do not care if error happens.  No menu items have been added
        hr=NOERROR;

    if(pContext)
    {

        if(dwContentType == CERT_QUERY_CONTENT_CERT ||
            dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CERT)
                CertFreeCertificateContext((PCCERT_CONTEXT)pContext);
        else
        {
            if(dwContentType == CERT_QUERY_CONTENT_CTL ||
                dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CTL)
                    CertFreeCTLContext((PCCTL_CONTEXT)pContext);
            else
            {
                if(dwContentType == CERT_QUERY_CONTENT_CRL ||
                        dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CRL)
                            CertFreeCRLContext((PCCRL_CONTEXT)pContext);
            }
        }
    }


   return hr;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{


    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    UINT            idCmd=0;


    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  hr;

    //get the number of files that user clicked on
    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  E_INVALIDARG;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return E_FAIL;

    //get the offset of the command item that was selected by the user
    //If HIWORD(lpcmi->lpVerb) then we have been called programmatically
    //and lpVerb is a command that should be invoked.  Otherwise, the shell
    //has called us, and LOWORD(lpcmi->lpVerb) is the menu ID the user has
    //selected.  Actually, it's (menu ID - idCmdFirst) from QueryContextMenu().
    if (HIWORD((DWORD_PTR)lpcmi->lpVerb))
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }
    else
        idCmd = LOWORD(lpcmi->lpVerb);

    //exit if idCmd is not 0 or 1
    if(idCmd >= 2)
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    hr=I_InvokeCommand(wszFileName, idCmd, FALSE);

CLEANUP:

   return hr;
}


//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::GetCommandString
//
//--------------------------------------------------------------
void    CopyBuffer(UINT uFlags, LPSTR   pszName, UINT   cchMax, LPWSTR  wszString)
{
    UINT    cbSize=0;
    LPSTR   szString=NULL;
    LPWSTR  pwszName=NULL;

    if(uFlags == GCS_HELPTEXTW)
    {
        pwszName=(LPWSTR)pszName;

        cbSize=wcslen(wszString)+1;

        if(cbSize <= cchMax)
            wcsncpy(pwszName, wszString,cbSize);
        else
        {
            wcsncpy(pwszName, wszString, cchMax-1);
            *(pwszName+cchMax-1)=L'\0';
        } 

    }
    else
    {
       if((wszString!=NULL) && MkMBStr(NULL, 0, wszString, &szString))
       {

            cbSize=strlen(szString)+1;

            if(cbSize <= cchMax)
                strncpy(pszName, szString,cbSize);
            else
            {
                strncpy(pszName, szString, cchMax-1);
                *(pszName+cchMax-1)='\0';
            } 
       }

       if(szString)
            FreeMBStr(NULL, szString);

    }
}


//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::GetCommandString
//
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::GetCommandString(UINT_PTR idCmd,
                                         UINT uFlags,
                                         UINT FAR *reserved,
                                         LPSTR pszName,
                                         UINT cchMax)
{
    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;

    WCHAR           wszFileName[_MAX_PATH];

    WCHAR           wszOpenString[MAX_COMMAND_LENGTH];
    WCHAR           wszAddString[MAX_COMMAND_LENGTH];


    if(uFlags!=GCS_HELPTEXTA && uFlags != GCS_HELPTEXTW)
        return E_INVALIDARG;
                                
    if( 0 == cchMax)
        return E_INVALIDARG;

    //init
    if(uFlags==GCS_HELPTEXTA)
        *pszName='\0';
    else
        *((LPWSTR)pszName)=L'\0';

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  hr;

    //get the number of files that user clicked on
    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  E_INVALIDARG;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return E_FAIL;

    //exit if idCmd is not 0 or 1
    if(idCmd >= 2)
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    //load the string
    if(!LoadStringU(g_hmodThisDll, IDS_HELP_OPEN, wszOpenString, sizeof(wszOpenString)/sizeof(wszOpenString[0])))
    {
        hr=E_FAIL;
        goto CLEANUP;
    }


    //get the content type of the file
    //we care about every file type except for the signed doc
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       NULL,
                       NULL,
                       NULL))
    {
        //can not recognize the object.  Fine
        hr=E_FAIL;
        goto CLEANUP;
    }

        //make sure idCmd is the correct valud for different types
    //we are guaranteed that idCmd is 1 or 0
    if(CERT_QUERY_CONTENT_CERT != dwContentType &&
       CERT_QUERY_CONTENT_CTL  != dwContentType &&
       CERT_QUERY_CONTENT_CRL  != dwContentType &&
       CERT_QUERY_CONTENT_PKCS7_SIGNED != dwContentType)
    {
        if(1==idCmd)
        {
            hr=E_INVALIDARG;
            goto CLEANUP;
        }
    }


    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
               if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_CERT, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
               {
                   hr=E_FAIL;
                   goto CLEANUP;
               }


        case CERT_QUERY_CONTENT_CTL:

                if(CERT_QUERY_CONTENT_CTL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_STL, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                    {
                        hr=E_FAIL;
                        goto CLEANUP;
                    }
                }


        case CERT_QUERY_CONTENT_CRL:

                if(CERT_QUERY_CONTENT_CRL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_CRL, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                    {
                        hr=E_FAIL;
                        goto CLEANUP;
                    }
                }


                //helper string for Open
                if(idCmd==0)
                {
                    CopyBuffer(uFlags, pszName, cchMax, wszOpenString);
                }

                //helper string for add
                if(idCmd==1)
                {
                    CopyBuffer(uFlags, pszName, cchMax, wszAddString);
                }

            break;

        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
        case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                //helper string for Open   

                CopyBuffer(uFlags, pszName, cchMax, wszOpenString);


           break;


        case CERT_QUERY_CONTENT_PFX:
                if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_PFX, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                {
                    hr=E_FAIL;
                    goto CLEANUP;
                }

                CopyBuffer(uFlags, pszName, cchMax, wszAddString);


            break;
        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:
        default:
                CopyBuffer(uFlags, pszName, cchMax, wszOpenString);

            break;
    }

    hr=NOERROR;

CLEANUP:

   return hr;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::Initialize(LPCITEMIDLIST pIDFolder,
                                   LPDATAOBJECT pDataObj,
                                   HKEY hRegKey)
{
    // Initialize can be called more than once

  if (m_pDataObj)
    	m_pDataObj->Release();

    // duplicate the object pointer and registry handle
    if (pDataObj)
    {
    	m_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\cryptpko.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptpko.h
//
//--------------------------------------------------------------------------

// CryptPKO.h : Declaration of the CCryptPKO

#ifndef __CRYPTPKO_H_
#define __CRYPTPKO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCryptPKO
class ATL_NO_VTABLE CCryptPKO :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCryptPKO, &CLSID_CryptPKO>,
	public ICryptPKO,
    public IContextMenu,
    public IShellPropSheetExt,
    public IShellExtInit
{
protected:
	LPDATAOBJECT    m_pDataObj;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRYPTPKO)
DECLARE_NOT_AGGREGATABLE(CCryptPKO)

BEGIN_COM_MAP(CCryptPKO)
	COM_INTERFACE_ENTRY(ICryptPKO)
    COM_INTERFACE_ENTRY(IContextMenu)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

// ICryptPKO
public:

    CCryptPKO();
    ~CCryptPKO();

	//IShell members
	STDMETHODIMP			QueryContextMenu(HMENU hMenu,
	                                         UINT indexMenu,
	                                         UINT idCmdFirst,
                                             UINT idCmdLast,
                                             UINT uFlags);

	STDMETHODIMP			InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);

	STDMETHODIMP			GetCommandString(UINT_PTR idCmd,
	                                         UINT uFlags,
	                                         UINT FAR *reserved,
                                             LPSTR pszName,
                                             UINT cchMax);

    //IShellPropSheetExt methods
    STDMETHODIMP            AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    STDMETHODIMP            ReplacePage(UINT uPageID,
                                        LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                        LPARAM lParam);


	//IShellExtInit methods
	STDMETHODIMP		    Initialize(LPCITEMIDLIST pIDFolder,
	                                   LPDATAOBJECT pDataObj,
	                                   HKEY hKeyID);

};

#endif //__CRYPTPKO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\cryptsig.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:      CryptSig.cpp
//
//  content:   Implements the IContextMenu member functions necessary to support
//             the context menu portioins of this shell extension.  Context menu
//             shell extensions are called when the user right clicks on a file

//  History:    16-09-1997 xiaohs   created
//
// CryptSig.cpp : Implementation of CCryptSig
//--------------------------------------------------------------
#include "stdafx.h"
#include "cryptext.h"
#include "private.h"
#include "CryptSig.h"

//--------------------------------------------------------------
// CCryptSig
//--------------------------------------------------------------
//
//  FUNCTION: GAKPageCallback(HWND, UINT, LPPROPSHEETPAGE)
//
//  PURPOSE: Callback  procedure for the property page
//
//  PARAMETERS:
//    hWnd      - Reserved (will always be NULL)
//    uMessage  - Action flag: Are we being created or released
//    ppsp      - The page that is being created or destroyed
//
//  RETURN VALUE:
//
//    Depends on message. 
//
//    For PSPCB_CREATE it's TRUE to let the page be created
//    or false to prevent it from being created.  
//    For PSPCB_RELEASE the return value is ignored.
//
//  COMMENTS:
//
BOOL CALLBACK
SignPageCallBack(HWND hWnd,
                UINT uMessage,
                void  *pvCallBack)
{
    switch(uMessage)
    {
        case PSPCB_CREATE:
            return TRUE;

        case PSPCB_RELEASE:
            if (pvCallBack) 
            {
               ((IShellPropSheetExt *)(pvCallBack))->Release();
            }
            return TRUE; 
    }
    return TRUE;
}

//--------------------------------------------------------------
//
//  Constructor
//
//--------------------------------------------------------------
CCryptSig::CCryptSig()
{
    m_pDataObj=NULL;
}


//--------------------------------------------------------------
//
//  Destructor
//
//--------------------------------------------------------------
CCryptSig::~CCryptSig()
{
    if (m_pDataObj)
        m_pDataObj->Release();

}

//--------------------------------------------------------------
//  FUNCTION: CCryptSig::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptSig::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE  hpage;
    PROPSHEETPAGEW  *pPage=NULL;
    DWORD           dwPage=0;
    DWORD           dwIndex=0;
	DWORD			dwSignerCount=0;  
	DWORD			cbSize=0;

    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL 
        	            };
    STGMEDIUM       stgm;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    HCRYPTMSG       hMsg=NULL;
    HRESULT         hr=E_FAIL;
    DWORD           dwExceptionCode=0;
	DWORD			dwAttr=0;

    CRYPTUI_VIEWSIGNATURES_STRUCTW  sigView;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;    

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
    {
        ReleaseStgMedium(&stgm);

        return  NOERROR;    //  Shouldn't happen, but it's not important
    }


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
    {
        ReleaseStgMedium(&stgm);

        return NOERROR;
    }

	//we ignore the case when the file is off-line
	if(0xFFFFFFFF == (dwAttr=GetFileAttributesU(wszFileName)))
	{
		ReleaseStgMedium(&stgm);
		return NOERROR;
	}

	if(FILE_ATTRIBUTE_OFFLINE & dwAttr)
	{
		ReleaseStgMedium(&stgm);
		return NOERROR;
	}

    //get the content type of the file.  We only cares about
    //the signed document in binary format
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                       CERT_QUERY_FORMAT_FLAG_BINARY,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       &hMsg,
                       NULL))
    {
        //can not recognize the object.  Fine
        goto CLEANUP;
    }

	//make sure that we have at least on signer
	cbSize = sizeof(dwSignerCount);
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_COUNT_PARAM,
						0,
						&dwSignerCount,
						&cbSize))
		goto CLEANUP;

	if(0==dwSignerCount)
		goto CLEANUP;

    
    //Call Reid's function to add the property sheet page
    memset(&sigView, 0, sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW));
    sigView.dwSize=sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW);
    sigView.choice=hMsg_Chosen;
    sigView.u.hMsg=hMsg;
    sigView.szFileName=wszFileName;
    sigView.pPropPageCallback=SignPageCallBack;  
    sigView.pvCallbackData=this;    


    if(!CryptUIGetViewSignaturesPagesW(
            &sigView,
            &pPage,
            &dwPage))
        goto CLEANUP;

    __try {
        for(dwIndex=0; dwIndex<dwPage; dwIndex++)
        {
           // pPage[dwIndex].dwFlags |= PSP_USECALLBACK;

            //add the callback functions to release the refcount
            //pPage[dwIndex].pfnCallback=SignPageCallBack;
            //pPage[dwIndex].pcRefParent=(UINT *)this;

            hpage = CreatePropertySheetPageU(&(pPage[dwIndex]));
        
            ((IShellPropSheetExt *)this)->AddRef();

            if (hpage) 
            {
                if (!lpfnAddPage(hpage, lParam)) 
                {
                    DestroyPropertySheetPage(hpage);
                    ((IShellPropSheetExt *)this)->Release();
                }
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto CLEANUP;
    }




CLEANUP:

    ReleaseStgMedium(&stgm);


    if(pPage)
        CryptUIFreeViewSignaturesPagesW(pPage, dwPage);
    
    if(hMsg)
        CryptMsgClose(hMsg);


    return NOERROR;
}

//--------------------------------------------------------------

//  FUNCTION: CCryptSig::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet 
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptSig::ReplacePage(UINT uPageID, 
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                    LPARAM lParam)
{
    return E_FAIL;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptSig::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//--------------------------------------------------------------
STDMETHODIMP CCryptSig::Initialize(LPCITEMIDLIST pIDFolder,
                                   LPDATAOBJECT pDataObj,
                                   HKEY hRegKey)
{
    // Initialize can be called more than once

  if (m_pDataObj)
    	m_pDataObj->Release();

    // duplicate the object pointer and registry handle
    if (pDataObj)
    {
    	m_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }          

    return NOERROR;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptext.rc
//
#define IDS_PROJNAME                    100
#define IDR_CRYPTPKO                    101
#define IDR_CRYPTSIG                    102


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif

//The strings 
//
#define         IDS_MENU_OPEN                   6100
#define         IDS_HELP_OPEN                   6101
#define         IDS_MENU_VIEWSIG                6104
#define         IDS_HELP_VIEWSIG                6105
#define         IDS_MSG_TITLE                   6106
#define         IDS_MSG_INVALID_FILE            6107
#define         IDS_CER_NAME                    6108
#define         IDS_STL_NAME                    6109
#define         IDS_CRL_NAME                    6110
#define         IDS_SPC_NAME                    6111
#define         IDS_SST_NAME                    6112
#define         IDS_P7S_NAME                    6113
#define         IDS_P7B_NAME                    6114
#define         IDS_P7M_NAME                    6115
#define         IDS_P10_NAME                    6116
#define         IDS_PKCS7_NAME                  6117
#define         IDS_PKO_NAME                    6118
#define         IDS_ADD                         6119
#define         IDS_PKO_EXT                     6120
#define         IDS_MMC_PARAM                   6121
#define         IDS_PKCS7_UNSIGNED_NAME         6122
#define         IDS_MSG_VALID_TITLE             6123
#define         IDS_MSG_VALID_FILE              6124
#define         IDS_SIGN_EXT                    6125
#define         IDS_MENU_INSTALL_CERT           6126
#define         IDS_HELP_INSTALL_CERT           6127
#define         IDS_MENU_INSTALL_CRL            6128
#define         IDS_HELP_INSTALL_CRL            6129
#define         IDS_MENU_INSTALL_STL            6130
#define         IDS_HELP_INSTALL_STL            6131 
#define         IDS_INSTALL_CERT                6132
#define         IDS_INSTALL_STL                 6133
#define         IDS_INSTALL_CRL                 6134
#define         IDS_INVALID_INFO_FOR_PKCS10     6135
#define         IDS_INVALID_PVK_FOR_PKCS10      6136     
#define         IDS_P7R_NAME                    6140
#define         IDS_NO_XENROLL                  6141
#define         IDS_INVALID_P7R_FILE            6142
#define         IDS_INSTALL_CERT_SUCCEEDED      6143
#define         IDS_FAIL_TO_INSTALL             6144
#define         IDS_CAT_NAME                    6145
#define         IDS_MSG_VALID_SIGN_FILE         6146
#define         IDS_MENU_INSTALL_PFX            6147
#define         IDS_PFX_NAME                    6148
#define         IDS_SIGN_NAME                   6149
#define         IDS_HELP_INSTALL_PFX            6150
#define         IDS_SERIALIZED_STORE            6151
#define         IDS_SERIALIZED_CERT             6152
#define         IDS_SERIALIZED_STL              6153
#define         IDS_SERIALIZED_CRL              6154
#define         IDS_OLD_P7C_NAME                6155
#define         IDS_OLD_CTL_NAME                6156 
#define         IDS_OLD_STR_NAME                6166
#define         IDS_ACCESS_DENIED               6167
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\cryptsig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptsig.h
//
//--------------------------------------------------------------------------

// CryptSig.h : Declaration of the CCryptSig

#ifndef __CRYPTSIG_H_
#define __CRYPTSIG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCryptSig
class ATL_NO_VTABLE CCryptSig : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCryptSig, &CLSID_CryptSig>,
	public ICryptSig,
    public IShellPropSheetExt,
    public IShellExtInit
{
protected:
	LPDATAOBJECT    m_pDataObj;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRYPTSIG)
DECLARE_NOT_AGGREGATABLE(CCryptSig)

BEGIN_COM_MAP(CCryptSig)
	COM_INTERFACE_ENTRY(ICryptSig)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

// ICryptSig
public:

    CCryptSig();
	~CCryptSig();


     //IShellPropSheetExt methods
    STDMETHODIMP            AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    
    STDMETHODIMP            ReplacePage(UINT uPageID, 
                                        LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                        LPARAM lParam);

	//IShellExtInit methods
	STDMETHODIMP		    Initialize(LPCITEMIDLIST pIDFolder, 
	                                   LPDATAOBJECT pDataObj, 
	                                   HKEY hKeyID);    


};

#endif //__CRYPTSIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\exthlpr.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       exthlpr.cpp
//
//  Contents:   Helper functions for cryptext.dll
//              1. Registry Functions
//              2. String Formatting Functions
//              3. Exports for RunDll
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------

#include "cryptext.h"
#include "private.h"

#include    <ole2.h>
#include    "xenroll.h"
#include    "xenroll_i.c"
#include    "initguid.h"


//*************************************************************************************
//global data for registry entries
//************************************************************************************

    MIME_REG_ENTRY     rgRegEntry[]={
L".cer",                            L"CERFile",                                      0,
L"CERFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCER %1", 0,
L"CERFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddCER %1",  0,
L"CERFile\\shell\\add",             NULL,                                            IDS_INSTALL_CERT,
L"CERFile",                         NULL,                                            IDS_CER_NAME,
L".pfx",                            L"PFXFile",                                      0,
L"PFXFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddPFX %1",  0,
L"PFXFile\\shell\\add",             NULL,                                            IDS_MENU_INSTALL_PFX,
L"PFXFile",                         NULL,                                            IDS_PFX_NAME,
L".p12",                            L"PFXFile",                                      0,
L".cat",                            L"CATFile",                                      0,
L"CATFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCAT %1", 0,
L"CATFile",                         NULL,                                            IDS_CAT_NAME,
L".crt",                            L"CERFile",                                      0,
L".der",                            L"CERFile",                                      0,
L".stl",                            L"STLFile",                                      0,
L"STLFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCTL %1", 0,
L"STLFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddCTL %1",  0,
L"STLFile\\shell\\add",             NULL,                                            IDS_INSTALL_STL,
L"STLFile",                         NULL,                                            IDS_STL_NAME,
L".crl",                            L"CRLFile",                                      0,
L"CRLFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCRL %1", 0,
L"CRLFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddCRL %1",  0,
L"CRLFile\\shell\\add",             NULL,                                            IDS_INSTALL_CRL,
L"CRLFile",                         NULL,                                            IDS_CRL_NAME,
L".spc",                            L"SPCFile",                                      0,
L"SPCFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddSPC %1",  0,
L"SPCFile\\shell\\add",             NULL,                                            IDS_INSTALL_CERT,
L"SPCFile",                         NULL,                                            IDS_SPC_NAME,
L".p7s",                            L"P7SFile",                                      0,
L"P7SFile",                         NULL,                                            IDS_P7S_NAME,
L".p7b",                            L"SPCFile",                                      0,
L".p7m",                            L"P7MFile",                                      0,
L"P7MFile",                         NULL,                                            IDS_P7M_NAME,
L".p7r",                            L"SPCFile",                                      0,
L"P7RFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenP7R %1", 0,
L"P7RFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddP7R %1",  0,
L"P7RFile\\shell\\add",             NULL,                                            IDS_INSTALL_CERT,
L"P7RFile",                         NULL,                                            IDS_P7R_NAME,
L".sst",                            L"CertificateStoreFile",                                0,
L"CertificateStoreFile",            NULL,                                            IDS_SST_NAME,
L".p10",                            L"P10File",                                      0,
L"P10File",                         NULL,                                            IDS_P10_NAME,
L".pko",                            L"PKOFile",                                      0,
L"PKOFile\\shellex\\ContextMenuHandlers",   L"CryptoMenu",                           0,
L"PKOFile\\shellex\\PropertySheetHandlers", L"CryptoMenu",                           0,
L"PKOFile",                         NULL,                                            IDS_PKO_NAME,
    };


    //the following registry entries.
    //it uses MMC.exe to display PKCS7 and Store files.  MMC.exe
    //is only available on NT5 enviroment
    MIME_REG_ENTRY     rgWINNT5RegEntry[]={
L"SPCFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1", 0,
L"P7SFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1", 0,
L"CertificateStoreFile\\shell\\open\\command", L"rundll32.exe cryptext.dll,CryptExtOpenSTR %1", 0,
    };


WIN95_REG_ENTRY    rgWin95IconEntry[]={ 
"CERFile\\DefaultIcon",            "\\cryptui.dll,-3410", 
"PFXFile\\DefaultIcon",            "\\cryptui.dll,-3425",                                                       
"CATFile\\DefaultIcon",            "\\cryptui.dll,-3418",                              
"STLFile\\DefaultIcon",            "\\cryptui.dll,-3413",                            
"CRLFile\\DefaultIcon",            "\\cryptui.dll,-3417",                           
"P7RFile\\DefaultIcon",            "\\cryptui.dll,-3410",  
"SPCFile\\DefaultIcon",            "\\cryptui.dll,-3410",
    };

    MIME_REG_ENTRY     rgIconEntry[]={ 
L"CERFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
L"PFXFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3425",                               0,
L"CATFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3418",                               0,
L"STLFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3413",                               0,
L"CRLFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3417",                               0,
L"P7RFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
L"SPCFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
};

    

 MIME_GUID_ENTRY     rgGuidEntry[]={
&CLSID_CryptPKO,  
L"PKOFile\\shellex\\ContextMenuHandlers\\CryptoMenu",
L"PKOFile\\shellex\\PropertySheetHandlers\\CrytoMenu", 
L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 
IDS_PKO_EXT,
&CLSID_CryptSig,  
NULL,
L"*\\shellex\\PropertySheetHandlers\\CryptoSignMenu",
L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 
IDS_SIGN_EXT,
    };



    LPWSTR      rgwszDelete[] = {
L".cer", 
L"CERFile\\DefaultIcon",                           
L"CERFile\\shell\\open\\command",   
L"CERFile\\shell\\add\\command",    
L"CERFile\\shell\\open",  
L"CERFile\\shell\\add",
L"CERFile\\shell",           
L"CERFile", 
L".pfx", 
L".p12", 
L"PFXFile\\DefaultIcon",                           
L"PFXFile\\shell\\add\\command",    
L"PFXFile\\shell\\add",
L"PFXFile\\shell",           
L"PFXFile",                         
L".cat",   
L"CATFile\\DefaultIcon",                                                    
L"CATFile\\shell\\open\\command",   
L"CATFile\\shell\\open",  
L"CATFile\\shell",           
L"CATFile",                         
L".crt",  
L".der",                          
L".stl",
L"STLFile\\DefaultIcon",                                                       
L"STLFile\\shell\\open\\command",   
L"STLFile\\shell\\add\\command",    
L"STLFile\\shell\\open",             
L"STLFile\\shell\\add",             
L"STLFile\\shell",             
L"STLFile",                         
L".crl",     
L"CRLFile\\DefaultIcon",                           
L"CRLFile\\shell\\open\\command",   
L"CRLFile\\shell\\add\\command",    
L"CRLFile\\shell\\open",   
L"CRLFile\\shell\\add",             
L"CRLFile\\shell",   
L"CRLFile",                         
L".spc", 
L"SPCFile\\DefaultIcon",                                                                               
L"SPCFile\\shell\\open\\command",   
L"SPCFile\\shell\\open",
L"SPCFile\\shell\\add\\command",   
L"SPCFile\\shell\\add",   
L"SPCFile\\shell",
L"SPCFile",                         
L".p7s",                            
L"P7SFile\\shell\\open\\command",   
L"P7SFile\\shell\\open",   
L"P7SFile\\shell",   
L"P7SFile",                         
L".p7b", 
L".p7m",                            
L"P7MFile",                         
L".p7r",   
L"P7RFile\\DefaultIcon",                                                    
L"P7RFile\\shell\\open\\command",   
L"P7RFile\\shell\\add\\command",    
L"P7RFile\\shell\\open",  
L"P7RFile\\shell\\add",
L"P7RFile\\shell",           
L"P7RFile",                         
L".sst",                            
L"CertificateStoreFile\\shell\\open\\command", 
L"CertificateStoreFile\\shell\\open", 
L"CertificateStoreFile\\shell", 
L"CertificateStoreFile",                   
L".p10",                           
L"P10File",                       
L".pko",                           
L"PKOFile\\shellex\\ContextMenuHandlers",
L"PKOFile\\shellex\\PropertySheetHandlers", 
L"PKOFile\\shellex", 
L"PKOFile",                        
};

    LPWSTR  g_CLSIDDefault[]={
L"\\shellex\\MayChangeDefaultMenu",
L"\\shellex",
};


    //the following is the entries for the content type
    // For any extension, say ".foo", we need to do the following:

	//1. Under  the HEKY_CLASSES_ROOT, under ".foo" key, add an entry of name "Content Type" and value "application/xxxxxxxx".
	//2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", under which add an entry of name "Extension" and value ".foo".

    MIME_REG_ENTRY      rgContentTypeEntry[]={
L".der",            L"application/pkix-cert",                   0,
L".der",            L"application/x-x509-ca-cert",              0,
L".crt",            L"application/pkix-cert",                   0,
L".crt",            L"application/x-x509-ca-cert",              0,
L".cer",            L"application/pkix-cert",                   0,
L".cer",            L"application/x-x509-ca-cert",              0,
L".spc",            L"application/x-pkcs7-certificates",        0,
L".p7b",            L"application/x-pkcs7-certificates",        0,
L".pfx",            L"application/x-pkcs12",                    0,
L".p12",            L"application/x-pkcs12",                    0,
L".stl",            L"application/vnd.ms-pki.stl",              0,
L".crl",            L"application/pkix-crl",                    0,
L".p7r",            L"application/x-pkcs7-certreqresp",         0,
L".p10",            L"application/pkcs10",                      0,
L".sst",            L"application/vnd.ms-pki.certstore",        0,
L".cat",            L"application/vnd.ms-pki.seccat",           0,
L".p7m",            L"application/pkcs7-mime",                  0,
L".p7s",            L"application/pkcs7-signature",             0,
L".pko",            L"application/vnd.ms-pki.pko",              0,
    };

    //The following entries need to be deleted at Regsvr32 time
    //due to the following changes from NT5 B2 to B3:
    //.ctl  -> .stl
    //.str  -> .sst
    //.p7b  -> .p7c


    MIME_REG_ENTRY      rgRemoveRelatedEntry[]={
L"P7CFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1",  0,
L"P7CFile\\shell\\open",            NULL,                                               0,
L"CERTSTOREFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenSTR %1",  0,
L"CERTSTOREFile\\shell\\open",      NULL,                                               0,
L"CTLFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCTL %1",    0,
L"CTLFile\\shell\\open",            NULL,                                               0,
L"CTLFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddCTL %1",     0,
L"CTLFile\\shell\\add",             NULL,                                               0,
    };

    MIME_REG_ENTRY      rgRemoveEmptyEntry[]={
L"P7CFile\\shell",                  NULL,                                               0,
L"CTLFile\\shell",                  NULL,                                               0,
L"P7CFile",                         NULL,                                               0,
L"CTLFile",                         NULL,                                               0,
L"CERTSTOREFile\\shell",            NULL,                                               0,
L"CERTSTOREFile",                   NULL,                                               0,
};


    MIME_REG_ENTRY      rgResetChangedEntry[]={
L"P7CFile",                         NULL,                                            IDS_OLD_P7C_NAME,
L"CTLFile",                         NULL,                                            IDS_OLD_CTL_NAME,
L"CERTSTOREFile",                   NULL,                                            IDS_OLD_STR_NAME,
};


    MIME_REG_ENTRY      rgRemoveChangedEntry[]={
L".str",                            L"CERTSTOREFile",                                   0,
L".p7c",                            L"P7CFile",                                         0,
L".ctl",                            L"CTLFile",                                         0,
L"CTLFile\\DefaultIcon",            L"cryptui.dll,-3413",                               0,
L"P7CFile\\DefaultIcon",            L"cryptui.dll,-3410",                               0,
};

//
// DSIE: Starting with Whistler, the MUI system requires a new registry value named
//       "FirendlyTypeName" where the data will be loaded from a specified DLL.
//
    MIME_REG_ENTRY      rgFriendlyTypeNameEntry[]={
L"CERFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CER_NAME,
L"STLFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_STL_NAME,
L"CRLFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CRL_NAME,
L"SPCFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_SPC_NAME,
L"CertificateStoreFile",            L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_SST_NAME,
L"P7SFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7S_NAME,
L"P7MFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7M_NAME,
L"P10File",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P10_NAME,
L"PKOFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_PKO_NAME,
L"P7RFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7R_NAME,
L"CATFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CAT_NAME,
L"PFXFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_PFX_NAME,
};

#include <dbgdef.h>


//--------------------------------------------------------------------------
//
//  before anything else, we need to remove the .ctl, .str, and .p7c
//  entries.  No need to check the return values
//
//--------------------------------------------------------------------------

void    RemoveOldExtensions()
{
    DWORD               dwRegEntry=0;
    DWORD               dwRegIndex=0;
    HKEY                hKey=NULL;
    BOOL                fCorrectValue=FALSE; 
    BOOL                fPreviousValue=FALSE;
    WCHAR               wszValue[MAX_STRING_SIZE];
    DWORD               dwLastStringSize=0;
    DWORD               dwType=0;
    DWORD               cbSize=0;
    BOOL                fCTLOpen=FALSE;
    BOOL                fP7COpen=FALSE;
    FILETIME            fileTime;


    WCHAR               wszLoadString[MAX_STRING_SIZE];

    //1st, delete the rgRemoveChangedEntry about Icons
    dwRegEntry=sizeof(rgRemoveChangedEntry)/sizeof(rgRemoveChangedEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveChangedEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //get the value
            wszValue[0]=L'\0';
            cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

            if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        NULL,
                        NULL,
                        &dwType,
                        (BYTE *)wszValue,
                        &cbSize))
            {
                if(REG_SZ == dwType|| REG_EXPAND_SZ == dwType)
                {
                    dwLastStringSize=wcslen(rgRemoveChangedEntry[dwRegIndex].wszName);

                    if(((DWORD)wcslen(wszValue)) >= dwLastStringSize)
                    {
                        if(0 == _wcsicmp(
                            (LPWSTR)(wszValue+wcslen(wszValue)-dwLastStringSize),
                            rgRemoveChangedEntry[dwRegIndex].wszName))
                            fCorrectValue=TRUE;
                    }
                }
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveChangedEntry[dwRegIndex].wszKey);
        }
    }


    //2nd, reset the values to NULL of rgResetChangedEntry
    dwRegEntry=sizeof(rgResetChangedEntry)/sizeof(rgResetChangedEntry[0]);
    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        fCorrectValue=FALSE; 

        if(0!=LoadStringU(g_hmodThisDll,rgResetChangedEntry[dwRegIndex].idsName,
                        wszLoadString,MAX_STRING_SIZE))
        {

            if (ERROR_SUCCESS == RegOpenKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgResetChangedEntry[dwRegIndex].wszKey,
                            0, 
                            KEY_WRITE | KEY_READ, 
                            &hKey))
            {

                //get the value
                wszValue[0]=L'\0';
                cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

                //use try{}except here since not sure what WIN95 will behave
                //when the value is NULL
                __try{

                    if(ERROR_SUCCESS == RegQueryValueExU(
                                hKey,
                                NULL,
                                NULL,
                                &dwType,
                                (BYTE *)wszValue,
                                &cbSize))
                    {
                        if(REG_SZ == dwType || REG_EXPAND_SZ == dwType)
                        {
                            if(0 == _wcsicmp(
                                wszValue,
                                wszLoadString))
                                fCorrectValue=TRUE;
                        }
                    } 
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                }
            }
        }

        if(fCorrectValue)
        {

            //set the value to NULL
            //use try{}except here since not sure what WIN95 will behave
            //when the value is NULL
             __try{

            RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        NULL,
                        0);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }

        if(hKey)
        {
          RegCloseKey(hKey);
          hKey=NULL;
        }
    }

    //3rd, delete the related keys in rgRemoveRelatedEntry
    dwRegEntry=sizeof(rgRemoveRelatedEntry)/sizeof(rgRemoveRelatedEntry[0]);

    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex+=2)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveRelatedEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //get the value
            wszValue[0]=L'\0';
            cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

            if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        NULL,
                        NULL,
                        &dwType,
                        (BYTE *)wszValue,
                        &cbSize))
            {
                if(REG_SZ == dwType|| REG_EXPAND_SZ == dwType)
                {
                   if(0 == _wcsicmp(
                        wszValue,
                        rgRemoveRelatedEntry[dwRegIndex].wszName))
                        fCorrectValue=TRUE;
                }
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            //mark if the CTLAdd and CTLOpen were the correct values
            if(dwRegIndex == 0)
                fP7COpen=TRUE;

            if(dwRegIndex == 2)
                fCTLOpen=TRUE;

            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveRelatedEntry[dwRegIndex].wszKey);
            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveRelatedEntry[dwRegIndex+1].wszKey);
       }
    }

    //fourth, if the shell subkey is empty, we need to remove the subkeys
    dwRegEntry=sizeof(rgRemoveEmptyEntry)/sizeof(rgRemoveEmptyEntry[0]);

    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveEmptyEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //enum the subkey
            cbSize=0;

            if(ERROR_SUCCESS != RegEnumKeyExU(
                        hKey,
                        0,
                        NULL,
                        &cbSize,
                        NULL,
                        NULL,
                        NULL,
                        &fileTime))
            {
                fCorrectValue=TRUE;
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            //mark if the CTLAdd and CTLOpen were the correct values
           // if((0 == dwRegIndex && TRUE == fP7COpen) ||
           //     (1 == dwRegIndex && TRUE == fCTLOpen)
           //    )
           // {
                RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveEmptyEntry[dwRegIndex].wszKey);
           // }
       }
    }
}


//--------------------------------------------------------------------------
//
//	  RegisterMimeHandler
//
//    This function adds the following registry entries:
//
//[HKEY_CLASSES_ROOT\.cer]
//   @="CERFile"
//[HKEY_CLASSES_ROOT\CERFile]
//   @="Security Certificate"
//[HKEY_CLASSES_ROOT\CERFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCER %1"
//[HKEY_CLASSES_ROOT\CERFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\CERFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCER %1"
//
//[HKEY_CLASSES_ROOT\.crt]
//   @="CERFile"
//
//[HKEY_CLASSES_ROOT\.stl]
//   @="sTLFile"
//[HKEY_CLASSES_ROOT\sTLFile]
//   @="Trust List"
//[HKEY_sLASSES_ROOT\sTLFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCTL %1"
//[HKEY_CLASSES_ROOT\sTLFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\sTLFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCTL %1"
// 
//[HKEY_CLASSES_ROOT\.crl]
//   @="CRLFile"
//[HKEY_CLASSES_ROOT\CRLFile]
//   @="Certificate Revocation List"
//[HKEY_CLASSES_ROOT\CRLFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCRL %1"
//[HKEY_CLASSES_ROOT\CRLFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\CRLFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCRL %1"
//
//[HKEY_CLASSES_ROOT\.spc]
//   @="SPCFile"
//[HKEY_CLASSES_ROOT\SPCFile]
//   @="Software Publishing Credentials"
//[HKEY_CLASSES_ROOT\SPCFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7s]
//   @="P7SFile"
//[HKEY_CLASSES_ROOT\P7SFile]
//   @="PKCS7 Signature"
//[HKEY_CLASSES_ROOT\P7SFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7b]
//   @="P7BFile"
//[HKEY_CLASSES_ROOT\P7BFile]
//   @="PKCS7 Certificates"
//[HKEY_CLASSES_ROOT\P7BFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7m]
//   @="P7MFile"
//[HKEY_CLASSES_ROOT\P7MFile]
//   @="PKCS7 MIME"
//
//[HKEY_CLASSES_ROOT\.sst]
//   @="CertificateStoreFile"
//[HKEY_CLASSES_ROOT\CertificateStoreFile]
//   @="Certificate Store"
//[HKEY_CLASSES_ROOT\CertificateStoreFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenSTR %1"
//
//[HKEY_CLASSES_ROOT\.p10]
//   @="P10File"
//[HKEY_CLASSES_ROOT\P10File]
//   @="Certificate Request"
//
//[HKEY_CLASSES_ROOT\.pko]
//   @="PKOFile"
//[HKEY_CLASSES_ROOT\PKOFile]
//   @="Public Key Object"
//[HKEY_CLASSES_ROOT\PKOFile\shellex\ContextMenuHandlers]
//   @="CryptoMenu"
//[HKEY_CLASSES_ROOT\PKOFile\shellex\ContextMenuHandlers\CryptoMenu]
//   @="{7444C717-39BF-11D1-8CD9-00C04FC29D45}"
//
//[HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers\CryptoSignMenu]
//   @="{7444C719-39BF-11D1-8CD9-00C04FC29D45}"
//
//
//[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
//   "{7444C717-39BF-11D1-8CD9-00C04FC29D45}"="Crypto PKO Extension"
//
//[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
//   "{7444C719-39BF-11D1-8CD9-00C04FC29D45}"="Crypto Sign Extension"
//
//--------------------------------------------------------------------------
HRESULT RegisterMimeHandler()
{
    HRESULT             hr=E_FAIL;
    DWORD               dwRegEntry=0;
    DWORD               dwRegIndex=0;
    WCHAR               wszName[MAX_STRING_SIZE];
    HKEY                hKey=NULL;
    DWORD               dwDisposition=0;  
    WCHAR               wszGUID[MAX_STRING_SIZE];
    WCHAR               wszDefault[200];
    CHAR                szValue[MAX_PATH + 1];
    CHAR                szSystem[MAX_PATH + 1];
    WCHAR               wszContentType[MAX_STRING_SIZE];
    LPWSTR              pwszFriendlyTypeName = NULL;

    //before anything else, we need to remove the .ctl, .str, and .p7c
    //entries.  No need to check the return values
    RemoveOldExtensions();

    //1st, do the registry based context menu
    //get the count of the reg entries
    dwRegEntry=sizeof(rgRegEntry)/sizeof(rgRegEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRegEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;


        //set the value
        if(NULL==rgRegEntry[dwRegIndex].wszName)
        {
            //load the string
            if(0==LoadStringU(g_hmodThisDll,rgRegEntry[dwRegIndex].idsName,
                            wszName,MAX_STRING_SIZE))
                  goto LoadStringErr;

            if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *)wszName,
                        (wcslen(wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;
        }
        else
        {
            if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *)(rgRegEntry[dwRegIndex].wszName),
                        (wcslen(rgRegEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;
        }

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

    }

    //some of the registry based context menu is specific for NT5
    if(FIsWinNT5())
    {
        //get the count of the reg entries
        dwRegEntry=sizeof(rgWINNT5RegEntry)/sizeof(rgWINNT5RegEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgWINNT5RegEntry[dwRegIndex].wszKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


            //set the value
            if(NULL==rgWINNT5RegEntry[dwRegIndex].wszName)
            {
                //load the string
                if(0==LoadStringU(g_hmodThisDll,rgWINNT5RegEntry[dwRegIndex].idsName,
                                wszName,MAX_STRING_SIZE))
                      goto LoadStringErr;

                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)wszName,
                            (wcslen(wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;
            }
            else
            {
                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)(rgWINNT5RegEntry[dwRegIndex].wszName),
                            (wcslen(rgWINNT5RegEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;
            }

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }
    }

    //now, we need to register for the content type
    //1. Under  the HEKY_CLASSES_ROOT, under ".foo" key, add an entry of name 
    //   "Content Type" and value "application/xxxxxxxx".
    //2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", 
    //   under which add an entry of name "Extension" and value ".foo".
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgContentTypeEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;


        //set the value
        if(ERROR_SUCCESS !=  RegSetValueExU(
                    hKey, 
                    L"Content Type",
                    0,
                    REG_SZ,
                    (BYTE *)(rgContentTypeEntry[dwRegIndex].wszName),
                    (wcslen(rgContentTypeEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", 
    //   under which add an entry of name "Extension" and value ".foo".
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //concatenate the key L"MIME\\Database\\Content Type\\application/XXXXXXXXXX
        wszContentType[0]=L'\0';

        wcscpy(wszContentType, L"MIME\\Database\\Content Type\\");
        wcscat(wszContentType, rgContentTypeEntry[dwRegIndex].wszName);

        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        wszContentType,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;


        //set the value
        if(ERROR_SUCCESS !=  RegSetValueExU(
                    hKey, 
                    L"Extension",
                    0,
                    REG_SZ,
                    (BYTE *)(rgContentTypeEntry[dwRegIndex].wszKey),
                    (wcslen(rgContentTypeEntry[dwRegIndex].wszKey) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //2nd, do the registry based DefaultIcon
    //we do things differently based on Win95 or WinNT
    if(FIsWinNT())
    {
        dwRegEntry=sizeof(rgIconEntry)/sizeof(rgIconEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgIconEntry[dwRegIndex].wszKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_EXPAND_SZ,
                            (BYTE *)(rgIconEntry[dwRegIndex].wszName),
                            (wcslen(rgIconEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }    
    }
    else
    {
        //get the system directory
        if(!GetSystemDirectory(szSystem, MAX_PATH))
            goto GetSystemErr;

        dwRegEntry=sizeof(rgWin95IconEntry)/sizeof(rgWin95IconEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyEx(
                            HKEY_CLASSES_ROOT,
                            rgWin95IconEntry[dwRegIndex].szKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


            //concantenate the values
            strcpy(szValue, szSystem);
            strcat(szValue, (rgWin95IconEntry[dwRegIndex].szName));
                
            if(ERROR_SUCCESS !=  RegSetValueEx(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)szValue,
                            (strlen(szValue) + 1) * sizeof(CHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }    
    }


    //3rd, set the .PKO context menu handler and property sheet handler
    //set the values related to the GUIDs
    dwRegEntry=sizeof(rgGuidEntry)/sizeof(rgGuidEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        //load the string
        if(0==LoadStringU(g_hmodThisDll,rgGuidEntry[dwRegIndex].idsName,
                            wszName,MAX_STRING_SIZE))
            goto LoadStringErr;

        //get the string presentation of the CLSID 
        if(0==StringFromGUID2(*(rgGuidEntry[dwRegIndex].pGuid), wszGUID, MAX_STRING_SIZE))
            goto StringFromGUIDErr;

        //open a registry entry under HKEY_CLASSES_ROOT for the context menu handler
        if(NULL!=rgGuidEntry[dwRegIndex].wszKey1)
        {
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgGuidEntry[dwRegIndex].wszKey1,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;

            if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)wszGUID,
                            (wcslen(wszGUID) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }
        //open a registry entry under HKEY_CLASSES_ROOT for the property sheet hander
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgGuidEntry[dwRegIndex].wszKey2,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *)wszGUID,
                        (wcslen(wszGUID) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;


        //open a registry entry under HKEY_LOCAL_MACHINE
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        rgGuidEntry[dwRegIndex].wszKey3,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        wszGUID,
                        0,
                        REG_SZ,
                        (BYTE *)wszName,
                        (wcslen(wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //now, under the classID of &CLSID_CryptPKO, we need to add 
    //the registry shellex\MayChangeDefaultMenu
    dwRegEntry=sizeof(g_CLSIDDefault)/sizeof(g_CLSIDDefault[0]);

   //get the string presentation of the CLSID 
   if(0==StringFromGUID2(CLSID_CryptPKO, wszGUID, MAX_STRING_SIZE))
        goto StringFromGUIDErr;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wcscpy(wszDefault, L"CLSID\\");

        wcscat(wszDefault, wszGUID);

        wcscat(wszDefault, g_CLSIDDefault[dwRegIndex]);

        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        wszDefault,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

    }

    // Set the FriendlyTypeName value for the new MUI requirement of Whistler.
    dwRegEntry=sizeof(rgFriendlyTypeNameEntry)/sizeof(rgFriendlyTypeNameEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //format the data by inserting the IDS value.
        if (0 == FormatMessageU(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    rgFriendlyTypeNameEntry[dwRegIndex].wszName,
                    0,                  // dwMessageId
                    0,                  // dwLanguageId
                    (LPWSTR) (&pwszFriendlyTypeName),
                    0,                  // minimum size to allocate
                    (va_list *) &rgFriendlyTypeNameEntry[dwRegIndex].idsName))
            goto FormatMsgError;

        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgFriendlyTypeNameEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        //set the value
        if(ERROR_SUCCESS != RegSetValueExU(
                    hKey, 
                    L"FriendlyTypeName",
                    0,
                    REG_EXPAND_SZ,
                    (BYTE *) pwszFriendlyTypeName,
                    (wcslen(pwszFriendlyTypeName) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

        // free friendly name type string.
        LocalFree((HLOCAL) pwszFriendlyTypeName);
        pwszFriendlyTypeName = NULL;
    }

	hr=S_OK;

CommonReturn:
	
    if(hKey)
        RegCloseKey(hKey);

    if(pwszFriendlyTypeName)
        LocalFree((HLOCAL) pwszFriendlyTypeName);

	return hr;

ErrorReturn:
	hr=GetLastError();

	goto CommonReturn;


TRACE_ERROR(RegCloseKeyErr);
TRACE_ERROR(RegCreateKeyErr);
TRACE_ERROR(LoadStringErr);
TRACE_ERROR(RegSetValueErr);
TRACE_ERROR(StringFromGUIDErr);
TRACE_ERROR(GetSystemErr);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	  UnregisterMimeHandler
//
//--------------------------------------------------------------------------
HRESULT UnregisterMimeHandler()
{
                                    
    HKEY        hKey=NULL;
    DWORD       dwRegEntry=0;
    DWORD       dwRegIndex=0;
    WCHAR       wszGUID[MAX_STRING_SIZE];
    DWORD       dwDisposition=0;
    WCHAR       wszDefault[200];
    WCHAR       wszContentType[MAX_STRING_SIZE];

    //1st, delete the entries related to the GUID
    //that is, the .PKO context menu handler and property sheet handler
    dwRegEntry=sizeof(rgGuidEntry)/sizeof(rgGuidEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //get the string presentation of the CLSID
        if(0==StringFromGUID2(*(rgGuidEntry[dwRegIndex].pGuid), wszGUID, MAX_STRING_SIZE))
            continue;

        //open a registry entry under HKEY_LOCAL_MACHINE
        if (ERROR_SUCCESS == RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        rgGuidEntry[dwRegIndex].wszKey3,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
        {

            RegDeleteValueU(hKey,wszGUID);

            //close the registry key
            RegCloseKey(hKey);

            hKey=NULL;
        }

        //delete a registry entry under HKEY_CLASSES_ROOT for property sheet
        RegDeleteKeyU(HKEY_CLASSES_ROOT,
                      rgGuidEntry[dwRegIndex].wszKey2);

        //delete a registry entry under HKEY_CLASSES_ROOT for context menu
        if(NULL !=rgGuidEntry[dwRegIndex].wszKey1)
        {
            RegDeleteKeyU(HKEY_CLASSES_ROOT,
                      rgGuidEntry[dwRegIndex].wszKey1);
        }
    }
  
    //2nd, detelet all the registry based context menu and Icon
    //get the count of the reg entries
    dwRegEntry=sizeof(rgwszDelete)/sizeof(rgwszDelete[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        //delete the registry entries
        RegDeleteKeyU(HKEY_CLASSES_ROOT,rgwszDelete[dwRegIndex]);

    //now, delete anything related to the content type
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wszContentType[0]=L'\0';

        wcscpy(wszContentType, L"MIME\\Database\\Content Type\\");
        wcscat(wszContentType, rgContentTypeEntry[dwRegIndex].wszName);

        RegDeleteKeyU(HKEY_CLASSES_ROOT,wszContentType);
    }
    


    //3nd, under the classID of &CLSID_CryptPKO, we need to delete 
    //the registry shellex\MayChangeDefaultMenu
    dwRegEntry=sizeof(g_CLSIDDefault)/sizeof(g_CLSIDDefault[0]);

   //get the string presentation of the CLSID 
   if(0==StringFromGUID2(CLSID_CryptPKO, wszGUID, MAX_STRING_SIZE))
        return S_OK;


    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wcscpy(wszDefault, L"CLSID\\");

        wcscat(wszDefault, wszGUID);

        wcscat(wszDefault, g_CLSIDDefault[dwRegIndex]);

        RegDeleteKeyU(HKEY_CLASSES_ROOT,wszDefault);

    }


	return S_OK;
}

//--------------------------------------------------------------------------
//
//	  View a CTL context
//
//--------------------------------------------------------------------------
void    I_ViewCTL(PCCTL_CONTEXT pCTLContext)
{

    CRYPTUI_VIEWCTL_STRUCT     ViewCTLStruct;

    if(NULL==pCTLContext)
        return;

    //memset
    memset(&ViewCTLStruct, 0, sizeof(ViewCTLStruct));
    ViewCTLStruct.dwSize=sizeof(ViewCTLStruct);
    ViewCTLStruct.pCTLContext=pCTLContext;

    CryptUIDlgViewCTL(&ViewCTLStruct);
}

//--------------------------------------------------------------------------
//
//	  View a signer Info
//
//--------------------------------------------------------------------------
/*void    I_ViewSignerInfo(HCRYPTMSG  hMsg)
{

    CERT_VIEWSIGNERINFO_STRUCT_W    ViewSignerInfoStruct;
    PCMSG_SIGNER_INFO               pSignerInfo=NULL;
    HCERTSTORE                      hCertStore=NULL;
    DWORD                           cbData=0;

    //get the cert store from the hMsg
    hCertStore=CertOpenStore(CERT_STORE_PROV_MSG,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              NULL,
                              0,
                              hMsg);

    if(NULL==hCertStore)
        goto CLEANUP;

    //get the signer info struct
    if(!CryptMsgGetParam(hMsg, 
                         CMSG_SIGNER_INFO_PARAM,
                         0,
                         NULL,
                         &cbData))
        goto CLEANUP;

    pSignerInfo=(PCMSG_SIGNER_INFO)malloc(cbData);
    if(NULL==pSignerInfo)
        goto CLEANUP;

    if(!CryptMsgGetParam(hMsg, 
                         CMSG_SIGNER_INFO_PARAM,
                         0,
                         pSignerInfo,
                         &cbData))
        goto CLEANUP;

   //Init
    memset(&ViewSignerInfoStruct, 0, sizeof(ViewSignerInfoStruct));
    ViewSignerInfoStruct.dwSize=sizeof(ViewSignerInfoStruct);
    ViewSignerInfoStruct.pSignerInfo=pSignerInfo;
    ViewSignerInfoStruct.cStores=1;
    ViewSignerInfoStruct.rghStores=&hCertStore;

    CertViewSignerInfo_W(&ViewSignerInfoStruct);

CLEANUP:
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(pSignerInfo)
        free(pSignerInfo);
    
}    */




//---------------------------------------------------------------------------------
//
//  Check is the PKCS signed MSG has a signerInfo attached
//
//---------------------------------------------------------------------------------
BOOL    PKCS7WithSignature(HCRYPTMSG    hMsg)
{
    DWORD   dwSignerCount=0;
    DWORD   cbSignerCount=0;

    if(NULL==hMsg)
        return FALSE;

    cbSignerCount=sizeof(dwSignerCount);

    //get the Param CMSG_SIGNER_COUNT_PARAM on the message handle
    //if 0==CMSG_SIGNER_COUNT_PARAM, there is no signerInfo
    //on the message handle
    if(!CryptMsgGetParam(hMsg,
                        CMSG_SIGNER_COUNT_PARAM,
                        0,
                        &dwSignerCount,
                        &cbSignerCount))
        return FALSE;

    if(0==dwSignerCount)
        return FALSE;

    return TRUE;

}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCERW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewStruct;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CERT,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCertContext))
    {
        //call the Certificate Common Dialogue
       memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));

       CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
       CertViewStruct.pCertContext=pCertContext;
       
       CryptUIDlgViewCertificate(&CertViewStruct,NULL);

    }
    else
    {
       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CER_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCER(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HRESULT             hr=S_OK;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    hr=CryptExtOpenCERW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return hr;
}

BOOL    IsCatalog(PCCTL_CONTEXT pCTLContext)
{
    BOOL    fRet=FALSE;

    if (pCTLContext)
    {
        if (pCTLContext->pCtlInfo)
        {
            if(pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
            {
                if (pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier)
                {
                    if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                                szOID_CATALOG_LIST) == 0)
                    {
                        fRet = TRUE;
                   }
                }
            }
        }
    }

    return fRet;

}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCATW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext) &&
                       IsCatalog(pCTLContext))
    {
        I_ViewCTL(pCTLContext);    
    }
    else
    {

        
       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CAT_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCAT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCATW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .PFX File
//---------------------------------------------------------------------------------
STDAPI CryptExtAddPFXW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;   
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PFX,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL))
    {

        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
        importSubject.pwszFileName=pwszFileName;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PFX_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .PFX File
//---------------------------------------------------------------------------------
STDAPI CryptExtAddPFX(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddPFXW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCERW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;   
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;



    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CERT,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCertContext))
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
        importSubject.pCertContext=pCertContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CER_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCER(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);



    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCERW(hinst, hPrevInstance,pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCTLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext))
    {
        I_ViewCTL(pCTLContext);    
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_STL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);


    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCTL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCTLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCTLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext))
    {
         memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT;
        importSubject.pCTLContext=pCTLContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_STL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCTL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCTLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);


    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCRLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;
    PCCRL_CONTEXT           pCRLContext=NULL;
    CRYPTUI_VIEWCRL_STRUCT  CRLViewStruct;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCRLContext))
    {
        //call the CRL view dialogue
        memset(&CRLViewStruct, 0, sizeof(CRYPTUI_VIEWCRL_STRUCT));

        CRLViewStruct.dwSize=sizeof(CRYPTUI_VIEWCRL_STRUCT);
        CRLViewStruct.pCRLContext=pCRLContext;

        CryptUIDlgViewCRL(&CRLViewStruct);
    }
    else
    {
       
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CRL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
        
    }

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCRL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCRLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCRLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCRL_CONTEXT       pCRLContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCRLContext))
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT;
        importSubject.pCRLContext=pCRLContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CRL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCRL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCRLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .SPC, .P7S, .P7B, .P7M file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenPKCS7W(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HCERTSTORE          hCertStore=NULL;
    HCRYPTMSG           hMsg=NULL;

    DWORD               dwContentType=0;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  Make sure the PKCS7 is not embedded
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       NULL,
                       &hCertStore,
                       &hMsg,
                       NULL) )
    {
        LauchCertMgr(pwszFileName);    
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PKCS7_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);

    }

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .SPC, .P7S, .P7B, .P7M file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenPKCS7(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenPKCS7W(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .SPC file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddSPCW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    HCERTSTORE          hCertStore=NULL;

    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  Make sure the PKCS7 is not embedded
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hCertStore,
                       NULL,
                       NULL) )
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
        importSubject.pwszFileName=pwszFileName;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {
        I_NoticeBox(
 		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_SPC_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .SPC file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddSPC(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddSPCW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP7RW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    CRYPT_DATA_BLOB         PKCS7Blob;
    IEnroll                 *pIEnroll=NULL;
    LPWSTR                  pwszFileName=NULL;
    PCCERT_CONTEXT          pCertContext=NULL;
 
    CRYPTUI_VIEWCERTIFICATE_STRUCT  ViewCertStruct;
    UINT                            ids=IDS_INSTALL_CERT_SUCCEEDED;

    //init
    memset(&PKCS7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    
 	if(FAILED(CoInitialize(NULL)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //initialize information for xEnroll
	if(FAILED(CoCreateInstance(CLSID_CEnroll,
		NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,
		(LPVOID *)&pIEnroll)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //get the BLOB from the file
    if(S_OK != RetrieveBLOBFromFile(pwszFileName,&(PKCS7Blob.cbData),
                                    &(PKCS7Blob.pbData)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    //get the certifcate context
    if(NULL==(pCertContext=pIEnroll->getCertContextFromPKCS7(&PKCS7Blob)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    memset(&ViewCertStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
    ViewCertStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);         
    ViewCertStruct.hwndParent=NULL;     
    ViewCertStruct.dwFlags=CRYPTUI_ACCEPT_DECLINE_STYLE;        
    ViewCertStruct.pCertContext=pCertContext;   
    ViewCertStruct.cStores=0;        
    ViewCertStruct.rghStores=NULL;      

    if(!CryptUIDlgViewCertificate(&ViewCertStruct,NULL))
        goto CLEANUP;

    if(S_OK !=(pIEnroll->acceptPKCS7Blob(&PKCS7Blob)))
    {
        ids=IDS_FAIL_TO_INSTALL;
        goto CLEANUP;
    }


CLEANUP:

    I_MessageBox(
            NULL, 
            ids,
            IDS_P7R_NAME,
            NULL,  
            MB_OK|MB_APPLMODAL);


    if(PKCS7Blob.pbData)
        UnmapViewOfFile(PKCS7Blob.pbData);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(pIEnroll)
        pIEnroll->Release();

    CoUninitialize( );

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP7R(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenP7RW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtAddP7RW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    CRYPT_DATA_BLOB         PKCS7Blob;
    IEnroll                 *pIEnroll=NULL;
    LPWSTR                  pwszFileName=NULL;
    UINT                    ids=IDS_INSTALL_CERT_SUCCEEDED;

    //init
    memset(&PKCS7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

 	if(FAILED(CoInitialize(NULL)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //initialize information for xEnroll
	if(FAILED(CoCreateInstance(CLSID_CEnroll,
		NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,
		(LPVOID *)&pIEnroll)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //get the BLOB from the file
    if(S_OK != RetrieveBLOBFromFile(pwszFileName,&(PKCS7Blob.cbData),
                                    &(PKCS7Blob.pbData)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    if(S_OK !=(pIEnroll->acceptPKCS7Blob(&PKCS7Blob)))
    {
        ids=IDS_FAIL_TO_INSTALL;
        goto CLEANUP;
    }


CLEANUP:

    I_MessageBox(
            NULL, 
            ids,
            IDS_P7R_NAME,
            NULL,  
            MB_OK|MB_APPLMODAL);


    if(PKCS7Blob.pbData)
        UnmapViewOfFile(PKCS7Blob.pbData);

    if(pIEnroll)
        pIEnroll->Release();

    
    CoUninitialize( );

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtAddP7R(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddP7RW(hinst, hPrevInstance, pwszFileName, nCmdShow);

   if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .sst file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenSTRW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HCERTSTORE          hCertStore=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hCertStore,
                       NULL,
                       NULL))
    {
        LauchCertMgr(pwszFileName);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_SST_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .sst file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenSTR(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenSTRW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p10 file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP10W(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    //check the object type.  
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS10,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL))
    {
        I_NoticeBox(
        	0,
			0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_P10_NAME,
            IDS_MSG_VALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_P10_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p10 file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP10(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenP10W(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{



	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;  
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
        
    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}
    
    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,             
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
 
    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,  
		FILE_MAP_READ,     
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;


}

//-----------------------------------------------------------------------
// Private implementation of the message box
//------------------------------------------------------------------------
int     I_NoticeBox(
			DWORD		dwError,
            DWORD       dwFlags,
            HWND        hWnd, 
            UINT        idsTitle,
            UINT        idsFileName,
            UINT        idsMsgFormat,  
            UINT        uType)
{
    WCHAR   wszTitle[MAX_STRING_SIZE];
    WCHAR   wszFileName[MAX_STRING_SIZE];
    WCHAR   wszMsg[MAX_STRING_SIZE];
    WCHAR   wszMsgFormat[MAX_STRING_SIZE];

#if (0) //DSIE: Bug 160612
	if(!LoadStringU(g_hmodThisDll, idsTitle, wszTitle, sizeof(wszTitle)))
#else
	if(!LoadStringU(g_hmodThisDll, idsTitle, wszTitle, sizeof(wszTitle) / sizeof(wszTitle[0])))
#endif
		return 0;

#if (0) //DSIE: Bug 160613
    if(!LoadStringU(g_hmodThisDll, idsFileName, wszFileName, sizeof(wszFileName)))
#else
    if(!LoadStringU(g_hmodThisDll, idsFileName, wszFileName, sizeof(wszFileName) / sizeof(wszFileName[0])))
#endif
        return 0;

	if(E_ACCESSDENIED == dwError)
	{
#if (0) //DSIE: Simular bug to 160612 & 160613 not caught by Prefix tools.
		if(!LoadStringU(g_hmodThisDll, IDS_ACCESS_DENIED, wszMsgFormat, sizeof(wszMsgFormat)))
#else
		if(!LoadStringU(g_hmodThisDll, IDS_ACCESS_DENIED, wszMsgFormat, sizeof(wszMsgFormat) / sizeof(wszMsgFormat[0])))
#endif
			return 0;
	}
	else
	{
#if (0) //DSIE: Simular bug to 160612 & 160613 not caught by Prefix tools.
		if(!LoadStringU(g_hmodThisDll, idsMsgFormat, wszMsgFormat, sizeof(wszMsgFormat)))
#else
		if(!LoadStringU(g_hmodThisDll, idsMsgFormat, wszMsgFormat, sizeof(wszMsgFormat) / sizeof(wszMsgFormat[0])))
#endif
			return 0;
	}

    //make the string
    if(0 == swprintf(wszMsg, wszMsgFormat, wszFileName))
        return 0;

    return MessageBoxU(hWnd, wszMsg, wszTitle, uType);
}

//-----------------------------------------------------------------------
// Private implementation of the message box 
//------------------------------------------------------------------------
int I_MessageBox(
    HWND        hWnd, 
    UINT        idsText,
    UINT        idsCaption,
    LPCWSTR     pwszCaption,  
    UINT        uType  
)
{
    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

    //get the caption string
    if(NULL == pwszCaption)
    {
#if (0) //DSIE: Bug 160611
        if(!LoadStringU(g_hmodThisDll, idsCaption, wszCaption, sizeof(wszCaption)))
#else
        if(!LoadStringU(g_hmodThisDll, idsCaption, wszCaption, sizeof(wszCaption) / sizeof(wszCaption[0])))
#endif
             return 0;
    }

    //get the text string
#if (0) //DSIE: Bug 160610
    if(!LoadStringU(g_hmodThisDll, idsText, wszText, sizeof(wszText)))
#else
    if(!LoadStringU(g_hmodThisDll, idsText, wszText, sizeof(wszText) / sizeof(wszText[0])))
#endif
    {
        return 0;
    }

    //message box
    if( pwszCaption)
    {
        intReturn=MessageBoxU(hWnd, wszText, pwszCaption, uType);
    }
    else
        intReturn=MessageBoxU(hWnd, wszText, wszCaption, uType);

    return intReturn;

}


//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

#if (0) //DSIE: Bug 160609
    if(!LoadStringU(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat)))
#else
    if(!LoadStringU(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
#endif
        goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  LauchCertMgr()
//
//      We use W version of APIs since this call is only made on WinNT5
//
//--------------------------------------------------------------------------
void    LauchCertMgr(LPWSTR pwszFileName)
{
    LPWSTR              pwszCommandParam=NULL;
	LPWSTR				pwszRealFileName=NULL;

    WCHAR               wszMSCFileName[_MAX_PATH];
    WCHAR               wszSystemDirectory[_MAX_PATH];


	if(NULL == pwszFileName)
		return;


	pwszRealFileName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszFileName)+10));

	if(NULL == pwszRealFileName)
		return;

	//add the " around the file name
	wcscpy(pwszRealFileName, L"\"");

	wcscat(pwszRealFileName, pwszFileName);

	wcscat(pwszRealFileName, L"\"");
    
     //Open the MMC via "MMC.exe CertMgr.msc /certmgr:FileName=MyFoo.Exe"

    //get the system path
    if(GetSystemDirectoryW(wszSystemDirectory, sizeof(wszSystemDirectory)/sizeof(wszSystemDirectory[0])))
    {
        //copy the system directory
        wcscpy(wszMSCFileName, wszSystemDirectory);

        //cancatecate the string \certmgr.msc
        wcscat(wszMSCFileName, CERTMGR_MSC);

        //make the string "MMC.exe c:\winnt\system32\CertMgr.msc /certmgr:FileName=MyFoo.Exe"
        if(FormatMessageUnicode(&pwszCommandParam, IDS_MMC_PARAM,
                            wszMSCFileName, pwszRealFileName))
        {

            ShellExecuteW(NULL,
                          L"Open",
                          MMC_NAME,
                          pwszCommandParam, 
                          wszSystemDirectory,
                          SW_SHOWNORMAL);
        }

    }

    if(pwszCommandParam)
        LocalFree((HLOCAL)pwszCommandParam);

	if(pwszRealFileName)
		LocalFree((HLOCAL)pwszRealFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\catalog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catalog.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CATALOG_ENTRY_LIST,        IDH_CATALOG_ENTRY_LIST},
    {IDC_CATALOG_ENTRY_DETAIL_LIST, IDH_CATALOG_ENTRY_DETAILS},
    {IDC_CATALOG_ENTRY_DETAIL_EDIT, IDH_CATALOG_ENTRY_DETAIL_DISPLAY}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void DisplayCatalogEntryValues(HWND hWndListView, PCTL_ENTRY pctlEntry)
{
    LPWSTR                      pwszText;
    WCHAR                       szFieldText[_MAX_PATH];  // only used for calls to LoadString only
    WCHAR                       szValueText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                    lvI;
    int                         index = 0;
    BYTE                        hash[20];
    DWORD                       hashSize = ARRAYSIZE(hash);
    BOOL                        fAddRows;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData;
    DWORD                       cbIndirectData;
    CAT_NAMEVALUE               *pNameValue;
    DWORD                       cbNameValue;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.lParam = NULL;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;

    //
    // if the rows have already been added, then don't add them again, just
    // set the text in the subitem
    //
    fAddRows = ListView_GetItemCount(hWndListView) == 0;

    //
    // tag
    //
    if (NULL != (pwszText = (LPWSTR) malloc(pctlEntry->SubjectIdentifier.cbData)))
    {
#if (0) // DSIE: Bug 331214.
        wcscpy(pwszText, (LPWSTR) pctlEntry->SubjectIdentifier.pbData);
#else
        memcpy(pwszText, pctlEntry->SubjectIdentifier.pbData, pctlEntry->SubjectIdentifier.cbData);
#endif
        LoadStringU(HinstDll, IDS_TAG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.pszText = szFieldText;
        lvI.cchTextMax = wcslen(szFieldText);

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // indirect data attribute
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) != 0)
        {
            continue;
        }

        pIndirectData = NULL;
        cbIndirectData = 0;

        //
        // decode the indirect data
        //
        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    SPC_INDIRECT_DATA_CONTENT_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    NULL,
                    &cbIndirectData))
        {
            continue;
        }

        if (NULL == (pIndirectData = (SPC_INDIRECT_DATA_CONTENT *) malloc(cbIndirectData)))
        {
            continue;
        }

        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    SPC_INDIRECT_DATA_CONTENT_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    pIndirectData,
                    &cbIndirectData))
        {
            free(pIndirectData);
            continue;
        }

        //
        // thumbprint algorithm
        //
        if (MyGetOIDInfo(szValueText, ARRAYSIZE(szValueText), pIndirectData->DigestAlgorithm.pszObjId) &&
            (NULL != (pwszText = AllocAndCopyWStr(szValueText))))
        {
            LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
            lvI.pszText = szFieldText;
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.iItem = index++;

            ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
        }

        //
        // thumbprint
        //
        if (FormatMemBufToString(
                        &pwszText,
                        pIndirectData->Digest.pbData,
                        pIndirectData->Digest.cbData))
        {
            LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
            lvI.iItem = index++;
            lvI.pszText = szFieldText;
            lvI.cchTextMax = wcslen(szFieldText);

            ModifyOrInsertRow(
                        hWndListView,
                        &lvI,
                        pwszText,
                        pwszText,
                        fAddRows,
                        TRUE);
        }

        free(pIndirectData);
    }

    //
    // name/value pair attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, CAT_NAMEVALUE_OBJID) != 0)
        {
            continue;
        }

        pNameValue = NULL;
        cbNameValue = 0;

        //
        // decode the name/value
        //
        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CAT_NAMEVALUE_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    NULL,
                    &cbNameValue))
        {
            continue;
        }

        if (NULL == (pNameValue = (CAT_NAMEVALUE *) malloc(cbNameValue)))
        {
            continue;
        }

        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CAT_NAMEVALUE_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    pNameValue,
                    &cbNameValue))
        {
            free(pNameValue);
            continue;
        }

        if (NULL != (pwszText = (LPWSTR) malloc(pNameValue->Value.cbData)))
        {
#if (0) // DSIE: Bug 331214.
            wcscpy(pwszText, (LPWSTR) pNameValue->Value.pbData);
#else
            memcpy(pwszText, pNameValue->Value.pbData, pNameValue->Value.cbData);
#endif
            lvI.pszText = pNameValue->pwszTag;
            lvI.cchTextMax = wcslen(lvI.pszText);
            lvI.iItem = index++;

            ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
        }

        free(pNameValue);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddEntriesToList(HWND hWndListView, CTL_VIEW_HELPER *pviewhelp)
{
    LV_ITEMW        lvI;
    DWORD           i;
    int             index = 0;
    PCCTL_CONTEXT   pctl;

    pctl = pviewhelp->pcvctl->pCTLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;

    //
    // loop for each entry and add it to the list
    //
    for (i=0; i<pctl->pCtlInfo->cCTLEntry; i++)
    {
        lvI.iItem = index++;
#if (0) // DSIE: Bug 331214.
        lvI.pszText = (LPWSTR) pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData;
        lvI.cchTextMax = pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData - sizeof(WCHAR);
        ListView_InsertItemU(hWndListView, &lvI);
#else
        // Need to align data because this can generate alignment fault under ia64.
        WCHAR * pwszText = (WCHAR *) malloc(pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData);
        if (pwszText)
        {
            memcpy(pwszText, 
                   pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                   pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData);
            lvI.pszText = pwszText;
            lvI.cchTextMax = pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData - sizeof(WCHAR);
            ListView_InsertItemU(hWndListView, &lvI);
            free(pwszText);
        }
#endif
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCatalogEntries(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[1024];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    PCCERT_CONTEXT      pCertContext;
    LPWSTR              pwszText;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT, L"");

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        //
		// Add the columns. They are loaded from a string table.
		//
        lvC.iSubItem = 0;
        lvC.cx = 345;
        LoadStringU(HinstDll, IDS_TAG, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST), 1, &lvC) == -1)
        {
            return FALSE;
        }

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CATALOG_ENTRY_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CATALOG_ENTRY_DETAIL_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // add all the certificates to the certificate list box
        //
        AddEntriesToList(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST), pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_HELP:

            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CATALOG_ENTRY_DETAIL_LIST:

                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    pviewhelp->currentSelection = pnmv->iItem;

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            hwndDlg,
                            IDC_CATALOG_ENTRY_DETAIL_EDIT,
                            pnmv->iItem);
                }

                break;

            case IDC_CATALOG_ENTRY_LIST:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST);

                    DisplayCatalogEntryValues(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            &(pctl->pCtlInfo->rgCTLEntry[pnmv->iItem]));
                    //
                    // clear the text in the detail edit box
                    //
                    CryptUISetRicheditTextW(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT, L"");

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            hwndDlg,
                            IDC_CATALOG_ENTRY_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;
            }

            return TRUE;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CATALOG_ENTRY_LIST:

                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CATALOG_ENTRY_DETAIL_LIST:

                ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                DisplayHelperTextInEdit(
                        GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                        hwndDlg,
                        IDC_CATALOG_ENTRY_DETAIL_EDIT,
                        pviewhelp->currentSelection);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CATALOG_ENTRY_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CATALOG_ENTRY_DETAIL_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE;
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            }
            
            break;


        }

        break;

    case WM_DESTROY:
            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }
            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST))           &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST))    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED_)
#define AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptext\private.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       private.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef PRIVATE_H
#define PRIVATE_H

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <string.h>
#include <winreg.h>
#include <objbase.h>
#include "stdio.h"


#include "wincrypt.h"
#include "wintrust.h"
#include "sipbase.h"
#include "mssip.h"
#include "unicode.h" 
#include "crtem.h"
#include "cryptui.h"
#include "mscat.h"


#include "resource.h"


//Macro to convert a short to a HRESULT
#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))

//global data
extern HINSTANCE g_hmodThisDll;

#define MAX_STRING_SIZE             256
#define MAX_COMMAND_LENGTH          40
#define MAX_TITLE_LENGTH            60
#define MAX_FILE_NAME_LENGTH        60


#define MMC_NAME                    L"mmc.exe"
#define CERTMGR_MSC                 L"\\certmgr.msc"



//function prototypes
HRESULT UnregisterMimeHandler();
HRESULT RegisterMimeHandler();
BOOL    PKCS7WithSignature(HCRYPTMSG    hMsg);
void    I_ViewCTL(PCCTL_CONTEXT pCTLContext);
//void    I_ViewSignerInfo(HCRYPTMSG  hMsg);
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb);  
int     I_MessageBox(
            HWND        hWnd, 
            UINT        idsText,
            UINT        idsCaption,
            LPCWSTR     pwszCaption,  
            UINT        uType);

int     I_NoticeBox(
			DWORD		dwError,
            DWORD       dwFlags,
            HWND        hWnd, 
            UINT        idsTitle,
            UINT        idsFileName,
            UINT        idsMsgFormat,  
            UINT        uType);


BOOL    IsCatalog(PCCTL_CONTEXT pCTLContext);

void    LauchCertMgr(LPWSTR pwszFileName);


//typpe define
typedef  struct _MIME_REG_ENTRY{
    LPWSTR  wszKey;
    LPWSTR  wszName;
    UINT    idsName;
}MIME_REG_ENTRY;

typedef  struct _WIN95_REG_ENTRY{
    LPSTR  szKey;
    LPSTR  szName;
}WIN95_REG_ENTRY;



typedef struct _MIME_GUID_ENTRY{
    const CLSID   *pGuid;
    LPWSTR  wszKey1;
    LPWSTR  wszKey2;
    LPWSTR  wszKey3;
    UINT    idsName;
}MIME_GUID_ENTRY;


#endif  //PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\ccertbmp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ccertbmp.h
//
//--------------------------------------------------------------------------

#ifndef _CCERTBMP_H
#define _CCERTBMP_H

#include        "global.hxx"
#include        <dbgdef.h>

/////////////////////////////////////////////////////////////////////////////
// CCertificateBmp window


class CCertificateBmp
	{
    HWND                m_hWnd;
    HINSTANCE           m_hInst;
	BOOL				m_fInitialized;

    BOOL                m_fRevoked;
	
    HPALETTE			m_hpal;		        // palette of the license background
	HBITMAP				m_hbmpMiniCertOK;	        // the logo bitmap
    HBITMAP				m_hbmpMiniCertNotOK;	    // the logo bitmap
    HBITMAP             m_hbmbMiniCertExclamation;
    HBITMAP             m_hbmbPKey;
    
    POINT               m_ptCoordinates;

    PCCERT_CONTEXT      m_pCertContext;
    BOOL                m_fHasPrivateKey;

    HCURSOR             m_hPrevCursor;
    
    DWORD               m_dwChainError;
    BOOL                m_fTrueError;
    BOOL                m_fNoUsages;

    HBRUSH              m_hWindowTextColorBrush;
    HBRUSH              m_hWindowColorBrush;
    HBRUSH              m_h3DLight;
    HBRUSH              m_h3DHighLight;
    HBRUSH              m_h3DLightShadow;
    HBRUSH              m_h3DDarkShadow;

public:
	                    CCertificateBmp();
	virtual             ~CCertificateBmp();

    void                SetWindow(HWND hWnd);
    HWND                GetMyWindow();
    void                SetRevoked(BOOL);
    BOOL                GetRevoked();
    HINSTANCE           Hinst();
	void                SetHinst(HINSTANCE);
    void                SetCertContext(PCCERT_CONTEXT, BOOL);
    PCCERT_CONTEXT      GetCertContext();
    void                DoSubclass();
    void                DoUnSubclass();  
    void                SetChainError(DWORD dwError, BOOL fTrueError, BOOL fNoUsages);


public:
	void OnPaint();
    int  OnQueryNewPalette();
    WNDPROC m_prevProc;
private:
	void Initialize();
	void InitializeBmp();
    void InitializeToolTip();
//    BOOL IsTrueErrorString(DWORD dwError);
public:
    
};


/////////////////////////////////////////////////////////////////////////////
#endif //_CCERTBMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\ccertbmp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ccertbmp.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#define SELPALMODE  TRUE


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
CCertificateBmp::CCertificateBmp()
{
	m_fInitialized = FALSE;
	m_hpal = NULL;
    m_hbmpMiniCertOK = NULL;
    m_hbmpMiniCertNotOK = NULL;
    m_hbmbMiniCertExclamation = NULL;
    m_hbmbPKey = NULL;
    m_hWnd = NULL;
    m_hInst = NULL;
    m_pCertContext = NULL;
    m_dwChainError = 0;
    m_hWindowTextColorBrush = NULL;
    m_hWindowColorBrush = NULL;
    m_h3DLight = NULL;
    m_h3DHighLight = NULL;
    m_h3DLightShadow = NULL;
    m_h3DDarkShadow = NULL;
    m_fNoUsages = FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
CCertificateBmp::~CCertificateBmp()
{
	if (m_hpal != NULL)
	{
		::DeleteObject(m_hpal);
	}

    if (m_hbmpMiniCertOK != NULL)
    {
        ::DeleteObject(m_hbmpMiniCertOK);
    }

    if (m_hbmpMiniCertNotOK != NULL)
    {
        ::DeleteObject(m_hbmpMiniCertNotOK);
    }

    if (m_hbmbMiniCertExclamation != NULL)
    {
        ::DeleteObject(m_hbmbMiniCertExclamation);
    }

    if (m_hbmbPKey != NULL)
    {
        ::DeleteObject(m_hbmbPKey);
    }
}   


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
/*BOOL CCertificateBmp::IsTrueErrorString(DWORD dwError)
{
    BOOL fRet;

    switch (dwError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
        fRet = FALSE;
        break;

    default:
        fRet = TRUE;
        break;
    }
    
    return fRet;
}*/


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetChainError(DWORD dwError, BOOL fTrueError, BOOL fNoUsages)
{
    m_dwChainError = dwError;
    m_fTrueError = fTrueError; //IsTrueErrorString(dwError);
    m_fNoUsages = fNoUsages;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetHinst(HINSTANCE hInst)
{
    m_hInst = hInst;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
HINSTANCE CCertificateBmp::Hinst()
{
    return m_hInst;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetWindow(HWND hWnd)
{
    m_hWnd = hWnd;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
HWND CCertificateBmp::GetMyWindow()
{
    return m_hWnd;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY CCertificateBmpProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{ 
    CCertificateBmp* This = (CCertificateBmp*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_PAINT:
        CallWindowProc((WNDPROC)(This->m_prevProc), hwnd, uMsg, wParam, lParam);
        This->OnPaint();
        break;

    default:
        return CallWindowProc((WNDPROC)(This->m_prevProc), hwnd, uMsg, wParam, lParam); 
    }
    
    return 0;
} 


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::DoSubclass()
{
    SetWindowLongPtr(GetMyWindow(), GWLP_USERDATA, (LONG_PTR)this);

    //
    // hook the window proc so we can get first stab at the messages
    //
    m_prevProc = (WNDPROC)SetWindowLongPtr(GetMyWindow(), GWLP_WNDPROC, (LONG_PTR)CCertificateBmpProc);
    
    //
    // Set 'no class cursor' so that SetCursor will work.
    //
    m_hPrevCursor = (HCURSOR)SetClassLongPtr(GetMyWindow(), GCLP_HCURSOR, NULL);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::DoUnSubclass()
{
    if (m_prevProc)
    {
        SetWindowLongPtr(GetMyWindow(), GWLP_WNDPROC, (LONG_PTR)m_prevProc);
        SetWindowLongPtr(GetMyWindow(), GCLP_HCURSOR, (LONG_PTR)m_hPrevCursor);
        m_prevProc = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetRevoked(BOOL fRevoked)
{
    m_fRevoked = fRevoked;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////    
BOOL CCertificateBmp::GetRevoked()
{
    return m_fRevoked;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetCertContext(PCCERT_CONTEXT pCertContext, BOOL fHasPrivateKey)
{
    m_pCertContext = pCertContext;
    m_fHasPrivateKey = fHasPrivateKey;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT CCertificateBmp::GetCertContext()
{
    return m_pCertContext;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::InitializeBmp()
{
    m_hbmpMiniCertNotOK = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_REVOKED_MINICERT), NULL);
    m_hbmpMiniCertOK = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_MINICERT), NULL);
    m_hbmbMiniCertExclamation = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_EXCLAMATION_MINICERT), NULL);
    m_hbmbPKey = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_PRIVATEKEY), NULL);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::Initialize()
{
	if (!m_fInitialized)
	{
        WCHAR szDisplayText[CRYPTUI_MAX_STRING_SIZE];
        WCHAR szURLText[CRYPTUI_MAX_STRING_SIZE];

        InitCommonControls();
		InitializeBmp();
        
        m_fInitialized = TRUE;

        m_hWindowTextColorBrush = GetSysColorBrush(COLOR_WINDOWTEXT);
        m_hWindowColorBrush = GetSysColorBrush(COLOR_WINDOW);
        m_h3DLight= GetSysColorBrush(COLOR_3DLIGHT);
        m_h3DHighLight = GetSysColorBrush(COLOR_3DHILIGHT);
        m_h3DLightShadow = GetSysColorBrush(COLOR_3DSHADOW);
        m_h3DDarkShadow = GetSysColorBrush(COLOR_3DDKSHADOW); 
	}
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
/*
int CCertificateBmp::OnQueryNewPalette()
{
    HDC hDC          = GetDC(GetMyWindow());

    HPALETTE hOldPal = SelectPalette(hDC, m_hpal, SELPALMODE);
    int iTemp = RealizePalette(hDC);         // Realize drawing palette.

    SelectPalette(hDC, hOldPal, TRUE);
    RealizePalette(hDC);

    ReleaseDC(GetMyWindow(), hDC);

    //
    // Did the realization change?
    //
    if (iTemp)
    {
        InvalidateRect(GetMyWindow(), NULL, FALSE);
    }
    return(iTemp);
}
*/

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::OnPaint() 
{
    Initialize();

    BITMAP      bmMiniCert;
	BITMAP      bmPKey;
	
    LONG        miniCertXY;
    RECT        rect;
    RECT        disclaimerButtonRect;
    RECT        frameRect;
    RECT        mainWindowRect;
    RECT        borderRect;
    RECT        goodForRect;
    LONG        borderSpacing;

    //PAINTSTRUCT ps;
    HDC         hdc         = GetDC(GetMyWindow());//BeginPaint(GetMyWindow(), &ps);
    if (hdc == NULL)
    {
        return;
    }

    //
    // get the mini bitmap first thing so it can be used to do sizing
    //
    memset(&bmMiniCert, 0, sizeof(bmMiniCert));
    if ((m_dwChainError != 0) && m_fTrueError)
    {
        ::GetObject(m_hbmpMiniCertNotOK, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }
    else if ((m_dwChainError != 0) || m_fNoUsages)
    {
        ::GetObject(m_hbmbMiniCertExclamation, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }
    else
    {
        ::GetObject(m_hbmpMiniCertOK, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }


    //
    // calculate where the minicert bmp should be and where the lines should
    // be based on where other controls are
    //
    GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    miniCertXY = rect.bottom - bmMiniCert.bmHeight;

    GetWindowRect(m_hWnd, &mainWindowRect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &mainWindowRect, 2);

    GetWindowRect(GetDlgItem(m_hWnd, IDC_DISCLAIMER_BUTTON), &disclaimerButtonRect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &disclaimerButtonRect, 2);

    //borderSpacing = mainWindowRect.right - disclaimerButtonRect.right;
    
    if ((mainWindowRect.right - disclaimerButtonRect.right) < (miniCertXY - 7))
    {
        borderSpacing = mainWindowRect.right - disclaimerButtonRect.right;
    }
    else
    {
        borderSpacing = miniCertXY - 7;
    }

    //
    // draw the background by drawing four rectangels.  these rectangels
    // border the "what this cert is good for" edit control or the error edit
    // control if there is an error.
    // we have to do this due to a bug in richedit where if you
    // invalidate the entire rect of the control sometimes the scroll
    // bars do not get redrawn.
    //
    if ((m_dwChainError != 0) || m_fNoUsages)
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ERROR_EDIT), &goodForRect);
    }
    else
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_GOODFOR_EDIT), &goodForRect);
    }
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &goodForRect, 2);
    rect.left = mainWindowRect.left + borderSpacing;
    rect.right = mainWindowRect.right - borderSpacing;
    rect.bottom = goodForRect.top;  
    rect.top = mainWindowRect.top + borderSpacing;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    rect.bottom = disclaimerButtonRect.top - borderSpacing;  
    rect.top = goodForRect.bottom;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    rect.top = goodForRect.top; 
    rect.bottom = goodForRect.bottom; 
    rect.left = mainWindowRect.left + borderSpacing;
    rect.right = goodForRect.left;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);

    rect.left = goodForRect.right;
    rect.right = mainWindowRect.right - borderSpacing;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    //
    // draw the frame
    //
    frameRect.left = mainWindowRect.left + borderSpacing;
    frameRect.right = mainWindowRect.right - borderSpacing;
    frameRect.bottom = disclaimerButtonRect.top - borderSpacing;  
    frameRect.top = mainWindowRect.top + borderSpacing;
    
    borderRect.left = frameRect.left;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.top + 1;
    ::FillRect(hdc, &borderRect, m_h3DLightShadow);
    borderRect.left = frameRect.left;
    borderRect.right = frameRect.left + 1;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLightShadow);

    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.right - 2;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.top + 2;
    ::FillRect(hdc, &borderRect, m_h3DDarkShadow);
    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.left + 2;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.bottom - 2;
    ::FillRect(hdc, &borderRect, m_h3DDarkShadow);

    borderRect.left = frameRect.left;
    borderRect.right = frameRect.right;
    borderRect.top = frameRect.bottom - 1;
    borderRect.bottom = frameRect.bottom;
    ::FillRect(hdc, &borderRect, m_h3DHighLight);
    borderRect.left = frameRect.right - 1;
    borderRect.right = frameRect.right;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.bottom;
    ::FillRect(hdc, &borderRect, m_h3DHighLight);

    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.bottom - 2;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLight);
    borderRect.left = frameRect.right - 2;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLight);
    
    //
    // draw the lines with the proper foreground color
    //
    GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    rect.left = mainWindowRect.left + miniCertXY;
    rect.right = mainWindowRect.right - miniCertXY;
    rect.top = rect.bottom + 6;
    rect.bottom = rect.top + 1;
    ::FillRect(hdc, &rect, m_hWindowTextColorBrush);

    GetWindowRect(GetDlgItem(m_hWnd, IDC_SUBJECT_EDIT), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    rect.left = mainWindowRect.left + miniCertXY;
    rect.right = mainWindowRect.right - miniCertXY;
    rect.top -= 10;
    rect.bottom = rect.top + 1;
    ::FillRect(hdc, &rect, m_hWindowTextColorBrush);
	
    //   
	// Draw the mini cert bitmap
    //
    if ((m_dwChainError != 0) && m_fTrueError)
    {
        MaskBlt(m_hbmpMiniCertNotOK, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }
    else if ((m_dwChainError != 0) || m_fNoUsages)
    {
        MaskBlt(m_hbmbMiniCertExclamation, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }
    else
    {
        MaskBlt(m_hbmpMiniCertOK, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }

    //
    // if there is a private key then draw the bitmap
    //
    if (m_fHasPrivateKey)
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_PRIVATE_KEY_EDIT), &rect);
        MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);

        memset(&bmPKey, 0, sizeof(bmPKey));
        ::GetObject(m_hbmbPKey, sizeof(BITMAP), (LPSTR)&bmPKey);
        MaskBlt(m_hbmbPKey, 
                m_hpal, 
                hdc, 
                rect.left - bmPKey.bmWidth - 4, 
                rect.top - 2, 
                bmPKey.bmWidth, 
                bmPKey.bmHeight);
    }

    ReleaseDC(GetMyWindow(), hdc);//::EndPaint(GetMyWindow(), &ps);
    
    InvalidateRect(GetDlgItem(m_hWnd, IDC_SUBJECT_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_ISSUER_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_GOODFOR_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ISSUEDTO_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ISSUEDBY_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_VALID_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ERROR_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_ISSUER_WARNING_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_PRIVATE_KEY_EDIT), NULL, TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\cryptuiapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptuiapi.cpp
//
//  Contents:   Public Cryptographic UI APIs
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include <cryptuiapi.h>


//+-------------------------------------------------------------------------
//  Dialog viewer of a certificate, CTL or CRL context.
//
//  dwContextType and associated pvContext's
//      CERT_STORE_CERTIFICATE_CONTEXT  PCCERT_CONTEXT
//      CERT_STORE_CRL_CONTEXT          PCCRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT          PCCTL_CONTEXT
//
//  dwFlags currently isn't used and should be set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgViewContext(
    IN DWORD dwContextType,
    IN const void *pvContext,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,      // Defaults to the context type title
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCertContext = (PCCERT_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCertificateW(
                    &ViewInfo,
                    NULL            // pfPropertiesChanged
                    );
            }
            break;

        case CERT_STORE_CRL_CONTEXT:
            {
                CRYPTUI_VIEWCRL_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCRLContext = (PCCRL_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCRLW(
                    &ViewInfo
                    );
            }
            break;

        case CERT_STORE_CTL_CONTEXT:
            {
                CRYPTUI_VIEWCTL_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCTLContext = (PCCTL_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCTLW(
                    &ViewInfo
                    );
            }
            break;

        default:
            fResult = FALSE;
            SetLastError(E_INVALIDARG);
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  Dialog to select a certificate from the specified store.
//
//  Returns the selected certificate context. If no certificate was
//  selected, NULL is returned.
//
//  pwszTitle is either NULL or the title to be used for the dialog.
//  If NULL, the default title is used.  The default title is
//  "Select Certificate".
//
//  pwszDisplayString is either NULL or the text statement in the selection
//  dialog.  If NULL, the default phrase
//  "Select a certificate you wish to use" is used in the dialog.
//
//  dwDontUseColumn can be set to exclude columns from the selection
//  dialog. See the CRYPTDLG_SELECTCERT_*_COLUMN definitions below.
//
//  dwFlags currently isn't used and should be set to 0.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,
    IN OPTIONAL LPCWSTR pwszDisplayString,
    IN DWORD dwDontUseColumn,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW SelectInfo;

    if (NULL == hCertStore) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    memset(&SelectInfo, 0, sizeof(SelectInfo));
    SelectInfo.dwSize = sizeof(SelectInfo);

    SelectInfo.hwndParent = hwnd;
    SelectInfo.szTitle = pwszTitle;
    SelectInfo.szDisplayString = pwszDisplayString;
    SelectInfo.dwDontUseColumn = dwDontUseColumn;
    SelectInfo.cDisplayStores = 1;
    SelectInfo.rghDisplayStores = &hCertStore;

    return CryptUIDlgSelectCertificateW(&SelectInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\crlgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crlgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CRL_GENERAL_ITEM_LIST,     IDH_CRLVIEW_GENERAL_ITEM_LIST},
    {IDC_CRL_GENERAL_DETAIL_EDIT,   IDH_CRLVIEW_GENERAL_ITEM_EDIT}
};


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCRL_INFO pCrlInfo, DWORD *index)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW    lvI;
    char        szVersion[32];
    LPWSTR      pszVersion;
    FILETIME    tempFileTime;

     //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCrlInfo->dwVersion+1);
    if (NULL != (pszVersion = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pszVersion, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pszVersion);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCrlInfo->Issuer.pbData, pCrlInfo->Issuer.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCrlInfo->Issuer.pbData, pCrlInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // Effective Data
    //
    if (FormatDateString(&pwszText, pCrlInfo->ThisUpdate, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_THISUPDATE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Next Update
    //
    memset(&tempFileTime, 0, sizeof(FILETIME));
    if (memcmp(&tempFileTime, &(pCrlInfo->NextUpdate), sizeof(FILETIME)) != 0)
    {
        if (FormatDateString(&pwszText, pCrlInfo->NextUpdate, TRUE, TRUE, hWndListView))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_NEXTUPDATE, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // signature algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCrlInfo->SignatureAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SIG_ALG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


INT_PTR APIENTRY ViewPageCRLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCRL_CONTEXT       pcrl;
    CRL_VIEW_HELPER     *pviewhelp;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCRL_INFO           pCrlInfo;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    CHARFORMAT          chFormat;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CRL_VIEW_HELPER *) (ps->lParam);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_GENERAL_DETAIL_EDIT, L"");

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);  
        }
        
        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 130;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 190;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pcrl->pCrlInfo, &i);
        DisplayExtensions(hWndListView, pcrl->pCrlInfo->cExtension, pcrl->pCrlInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pcrl->pCrlInfo->cExtension, pcrl->pCrlInfo->rgExtension, TRUE, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // load the header icon and fill in the header text and set styles for the header edit control
        //
        pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOCATIONLIST));

        LoadStringU(HinstDll, IDS_CRL_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT, szText);

        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT));

        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);


        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CRL_GENERAL_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CRL_GENERAL_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;


        case NM_CLICK:

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CRL_GENERAL_ITEM_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_PAINT:
        RECT        rect;
        PAINTSTRUCT paintstruct;
        HDC         hdc;
        COLORREF    colorRef;

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (GetUpdateRect(hwndDlg, &rect, FALSE))
        {
            hdc = BeginPaint(hwndDlg, &paintstruct);
            if (hdc == NULL)
            {
                EndPaint(hwndDlg, &paintstruct);
                break;
            }

            colorRef = GetBkColor(hdc);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT), EM_SETBKGNDCOLOR, 0, (LPARAM) colorRef);

            if (pviewhelp->hIcon != NULL)
            {
                DrawIcon(
                    hdc,
                    ICON_X_POS,
                    ICON_Y_POS,
                    pviewhelp->hIcon);
            }

            EndPaint(hwndDlg, &paintstruct);
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }

        if (pviewhelp->hIcon != NULL)
        {
            DeleteObject(pviewhelp->hIcon);
            pviewhelp->hIcon = NULL;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_GENERAL_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\convutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       convutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPSTR CertUIMkMBStr(LPCWSTR pwsz)
{
    int     cb;
    LPSTR   psz;

    if (pwsz == NULL)
    {
        return NULL;
    }
    
    cb = WideCharToMultiByte(
                    0,
                    0,
                    pwsz,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
    if (NULL == (psz = (LPSTR) malloc(cb)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }

    WideCharToMultiByte(
                0,
                0,
                pwsz,
                -1,
                psz,
                cb,
                NULL,
                NULL);

    return(psz);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR CertUIMkWStr(LPCSTR psz)
{
    int     cWChars;
    LPWSTR   pwsz;

    if (psz == NULL)
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    NULL,
                    0);
            
    if (NULL == (pwsz = (LPWSTR) malloc(cWChars * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }

    MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    pwsz,
                    cWChars);

    return(pwsz);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPSTR AllocAndCopyMBStr(LPCSTR psz)
{
    LPSTR   pszReturn;

    if (NULL == (pszReturn = (LPSTR) malloc(strlen(psz)+1)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }
    strcpy(pszReturn, psz);

    return(pszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndCopyWStr(LPCWSTR pwsz)
{
    LPWSTR   pwszReturn;

    if (NULL == (pwszReturn = (LPWSTR) malloc((wcslen(pwsz)+1) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }
    wcscpy(pwszReturn, pwsz);

    return(pwszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPPROPSHEETPAGEA ConvertToPropPageA(LPCPROPSHEETPAGEW ppage, DWORD cPages)
{
    PROPSHEETPAGEA *ppageA;
    DWORD i;
    
    if (NULL == (ppageA = (PROPSHEETPAGEA *) malloc(sizeof(PROPSHEETPAGEA) * cPages)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    };

    memcpy(ppageA, ppage, sizeof(PROPSHEETPAGEA) * cPages);

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            ppageA[i].pszTitle = CertUIMkMBStr(ppage[i].pszTitle);
        }
    }

    return(ppageA);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FreePropSheetPagesA(LPPROPSHEETPAGEA ppage, DWORD cPages)
{
    DWORD i;

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            free((void *)ppage[i].pszTitle);
        }
    }

    free(ppage);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL ConvertToPropPageW(LPCPROPSHEETPAGEA ppage, DWORD cPages, LPCPROPSHEETPAGEW *pppageW)
{
    PROPSHEETPAGEW *ppageW;
    DWORD i;

    if (cPages == 0)
    {
        *pppageW = NULL;
        return TRUE;
    }
    
    if (NULL == (ppageW = (PROPSHEETPAGEW *) malloc(sizeof(PROPSHEETPAGEW) * cPages)))
    {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    memcpy(ppageW, ppage, sizeof(PROPSHEETPAGEW) * cPages);

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            ppageW[i].pszTitle = CertUIMkWStr(ppage[i].pszTitle);
        }
    }

    *((LPPROPSHEETPAGEW *) pppageW) = ppageW;
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FreePropSheetPagesW(LPPROPSHEETPAGEW ppage, DWORD cPages)
{
    DWORD i;

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            free((void *)ppage[i].pszTitle);
        }
    }

    free(ppage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\crlrlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crlrlist.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES,   IDH_CRLVIEW_REVOCATIONLIST_REVOCATION_LIST},
    {IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST,   IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY},
    {IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,            IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY_DETAIL}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayCRLEntryValues(HWND hWndListView, PCCRL_CONTEXT pcrl, int entryIndex)
{
    LPWSTR      pwszText;
    WCHAR       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    DWORD       index = 0;

    ShowWindow(hWndListView, SW_HIDE);

    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvI.mask = LVIF_PARAM;
    while (lvI.iItem >= 0)
    {
        if (ListView_GetItemU(hWndListView, &lvI))
        {
            FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
        }
        lvI.iItem--;
    }

    ListView_DeleteAllItems(hWndListView);

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pcrl->pCrlInfo->rgCRLEntry[entryIndex].SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szText, ARRAYSIZE(szText));
        lvI.iItem = index;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, index, 1, pwszText);
        index++;
    }

    //
    // revocation date
    //
    if (FormatDateString(&pwszText, pcrl->pCrlInfo->rgCRLEntry[entryIndex].RevocationDate, TRUE, TRUE, hWndListView))
    {
        LoadStringU(HinstDll, IDS_REVOCATION_DATE, szText, ARRAYSIZE(szText));
        lvI.iItem = index;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, index, 1, pwszText);
        index++;
    }

    //
    // add all the extensions
    //
    DisplayExtensions(
            hWndListView,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].cExtension,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].rgExtension,
            FALSE,
            &index);
    DisplayExtensions(
            hWndListView,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].cExtension,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].rgExtension,
            TRUE,
            &index);

    ShowWindow(hWndListView, SW_SHOW);
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertificatesToList(HWND hWndListView, CRL_VIEW_HELPER *pviewhelp)
{
    LPWSTR          pwszText;
    LV_ITEMW        lvI;
    DWORD           i;
    PCCRL_CONTEXT   pcrl;
    int             index = 0;

    pcrl = pviewhelp->pcvcrl->pCRLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;

    //
    // loop for each cert
    //
    for (i=0; i<pcrl->pCrlInfo->cCRLEntry; i++)
    {
        if (FormatSerialNoString(&(lvI.pszText), &(pcrl->pCrlInfo->rgCRLEntry[i].SerialNumber)))
        {
            lvI.cchTextMax = wcslen(lvI.pszText);
            lvI.iItem = index++;
            ListView_InsertItemU(hWndListView, &lvI);
            free(lvI.pszText);
            lvI.pszText = NULL;

            FormatDateString(&pwszText, pcrl->pCrlInfo->rgCRLEntry[i].RevocationDate, TRUE, TRUE, hWndListView);
            ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
            free(pwszText);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCRLRevocationList(HWND hwndDlg, UINT msg, WPARAM wParam,
                                    LPARAM lParam)
{
    PROPSHEETPAGE       *ps;
    PCCRL_CONTEXT       pcrl;
    CRL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    PCRL_INFO           pCrlInfo;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CRL_VIEW_HELPER *) (ps->lParam);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT, L"");

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 140;
        LoadStringU(HinstDll, IDS_REVOCATION_DATE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), 1, &lvC) == -1)
        {
            // error
        }

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST), 1, &lvC) == -1)
        {
            // error
        }

        //
        // add all the certificates to the certificate list box
        //
        AddCertificatesToList(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), pviewhelp);

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // initialize the current selection
        //
        pviewhelp->currentSelection = -1;

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:

                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                            hwndDlg,
                            IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,
                            pnmv->iItem);
                }

                break;

            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    memcpy(&nmv, pnmv, sizeof(nmv));
                    nmv.hdr.code = NM_CLICK;
                    SendMessage(hwndDlg, WM_NOTIFY, 0, (LPARAM) &nmv);
                }

                break;
            }

            return TRUE;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:

                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES);

                if ((pnmv->iItem == -1) || (pviewhelp->currentSelection == pnmv->iItem))
                {
                    break;
                }

                //
                // clear the text in the detail edit box
                //
                CryptUISetRicheditTextW(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT, L"");

                DisplayCRLEntryValues(
                        GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                        pcrl,
                        pnmv->iItem);

                pviewhelp->currentSelection = pnmv->iItem;

                break;
                // do the fall through when the update code is written properly
                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:

                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                    hwndDlg,
                    IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,
                    pnmv->iItem);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }

            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\ctlgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP CTLHelpmap[] = {
    {IDC_CTL_GENERAL_ITEM_LIST,     IDH_CTLVIEW_GENERAL_ITEM_LIST},
    {IDC_CTL_GENERAL_DETAIL_EDIT,   IDH_CTLVIEW_GENERAL_ITEM_EDIT},
    {IDC_CTL_GENERAL_VIEW_BUTTON,   IDH_CTLVIEW_GENERAL_VIEWSIGNATURE_BUTTON}
};

static const HELPMAP CatHelpmap[] = {
    {IDC_CTL_GENERAL_ITEM_LIST,     IDH_CATALOGVIEW_GENERAL_ITEM_LIST},
    {IDC_CTL_GENERAL_DETAIL_EDIT,   IDH_CATALOGVIEW_GENERAL_ITEM_EDIT},
    {IDC_CTL_GENERAL_VIEW_BUTTON,   IDH_CATALOGVIEW_GENERAL_VIEWSIGNATURE_BUTTON}
};

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

#define SELPALMODE  TRUE

//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCTL_INFO pCtlInfo, DWORD *index)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW    lvI;
    DWORD       i;
    int         sequenceNumIndex;
    FILETIME    tempFileTime;
    char        szVersion[32];
	DWORD		dwNumSpaces;
	DWORD		dwNumCharsInserted;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCtlInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Subject Usage
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_SUBJECTUSAGE, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (NULL != (pwszText = FormatCTLSubjectUsage(&(pCtlInfo->SubjectUsage), TRUE)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (NULL != (pwszText = FormatCTLSubjectUsage(&(pCtlInfo->SubjectUsage), FALSE)))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // list identifier
    //
    if (pCtlInfo->ListIdentifier.cbData != 0)
    {
        if(FormatMemBufToString(&pwszText, pCtlInfo->ListIdentifier.pbData, pCtlInfo->ListIdentifier.cbData))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_LISTIDENTIFIER, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // sequence number
    //
    if (pCtlInfo->SequenceNumber.cbData != 0)
    {
        dwNumSpaces = (pCtlInfo->SequenceNumber.cbData * 2) / 4;
		pwszText = (LPWSTR) malloc(((pCtlInfo->SequenceNumber.cbData * 2) + dwNumSpaces + 1) * sizeof(WCHAR));
        if (pwszText != NULL)
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_SEQUENCENUMBER, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);

            sequenceNumIndex = pCtlInfo->SequenceNumber.cbData - 1;
            i = 0;
			dwNumCharsInserted = 0;
            while (sequenceNumIndex >= 0)
            {
                //
				// insert a space if needed
				//
				if (dwNumCharsInserted == 4)
				{
					pwszText[i++] = L' ';
					dwNumCharsInserted = 0;
				}

				pwszText[i++] = RgwchHex[(pCtlInfo->SequenceNumber.pbData[sequenceNumIndex] & 0xf0) >> 4];
                pwszText[i++] = RgwchHex[pCtlInfo->SequenceNumber.pbData[sequenceNumIndex] & 0x0f];
                sequenceNumIndex--;
				dwNumCharsInserted += 2;
            }
            pwszText[i] = 0;
            lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // Effective Data
    //
    if (FormatDateString(&pwszText, pCtlInfo->ThisUpdate, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_THISUPDATE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Next Update
    //
    memset(&tempFileTime, 0, sizeof(FILETIME));
    if (memcmp(&tempFileTime, &(pCtlInfo->NextUpdate), sizeof(FILETIME)) != 0)
    {
        if (FormatDateString(&pwszText, pCtlInfo->NextUpdate, TRUE, TRUE, hWndListView))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_NEXTUPDATE, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // subject algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCtlInfo->SubjectAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SUBJECTALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a pointer to a cert contexxt and
// display all the properties tagged to the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayProperties(HWND hWndListView, PCCTL_CONTEXT pctl, DWORD *index)
{
    DWORD               i;
    WCHAR               szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LPWSTR              pwszText;
    LV_ITEMW            lvI;
    BYTE                hash[20];
    DWORD               hashSize = ARRAYSIZE(hash);
    DWORD               cbText;
    PCCRYPT_OID_INFO    pThumbprintAlgorithm;
    DWORD               dwAlgID = CALG_SHA1;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_PROPERTY;

    //
    // thumbprint algorithm
    //
    if (NULL != (pThumbprintAlgorithm = CryptFindOIDInfo(
                                            CRYPT_OID_INFO_ALGID_KEY,
                                            &dwAlgID,
                                            CRYPT_HASH_ALG_OID_GROUP_ID)) &&
        (NULL != (pwszText = AllocAndCopyWStr(pThumbprintAlgorithm->pwszName))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // thumbprint
    //
    CertGetCTLContextProperty(
            pctl,
            CERT_SHA1_HASH_PROP_ID,
            hash,
            &hashSize);
    if (FormatMemBufToString(&pwszText, hash, ARRAYSIZE(hash)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  friendly name
    //
    cbText = 0;
    if (CertGetCTLContextProperty(  pctl,
                                    CERT_FRIENDLY_NAME_PROP_ID,
                                    NULL,
                                    &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_CTL_NAME, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCTLContextProperty(  pctl,
                                    CERT_FRIENDLY_NAME_PROP_ID,
                                    pwszText,
                                    &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  description
    //
    cbText = 0;
    if (CertGetCTLContextProperty(  pctl,
                                    CERT_DESCRIPTION_PROP_ID,
                                    NULL,
                                    &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_DESCRIPTION, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCTLContextProperty(  pctl,
                                    CERT_DESCRIPTION_PROP_ID,
                                    pwszText,
                                    &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void GetSignerInfo(CTL_VIEW_HELPER *pviewhelp)
{
    HCRYPTMSG           hMsg;
    DWORD               cbEncodedSigner = 0;
    BYTE                *pbEncodedSigner = NULL;
    DWORD               cbCertInfo = 0;
    CERT_INFO           *pCertInfo = NULL;
    DWORD               chStores = 0;
    HCERTSTORE          *rghStores = NULL;
    CRYPT_PROVIDER_SGNR *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT *pProvCert = NULL;

    
    if (!(pviewhelp->hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      0,
                                      0,
                                      0,
                                      NULL,
                                      NULL)))
    {
        return;
    }

    if (!CryptMsgUpdate(pviewhelp->hMsg,
                        pviewhelp->pcvctl->pCTLContext->pbCtlEncoded,
                        pviewhelp->pcvctl->pCTLContext->cbCtlEncoded,
                        TRUE))                    // fFinal
    {
        CryptMsgClose(pviewhelp->hMsg);
        pviewhelp->hMsg = NULL;
        return;
    }

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_ENCODED_SIGNER,
                     0,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        pviewhelp->fNoSignature = TRUE;
        return;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        return;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_ENCODED_SIGNER,
                          0,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        free(pbEncodedSigner);
        return;
    }

    pviewhelp->fNoSignature = FALSE;

    //
    // decode the EncodedSigner info
    //
    pviewhelp->cbSignerInfo = 0;
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    NULL,
					    &pviewhelp->cbSignerInfo))
    {
        free(pbEncodedSigner);
        return;
    }
	

    if (NULL == (pviewhelp->pbSignerInfo = (PCMSG_SIGNER_INFO) malloc(pviewhelp->cbSignerInfo)))
    {
        free(pbEncodedSigner);
        return;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    pviewhelp->pbSignerInfo,
					    &pviewhelp->cbSignerInfo))
    {
        free(pbEncodedSigner);
        free(pviewhelp->pbSignerInfo);
        pviewhelp->pbSignerInfo = NULL;
        return;
    }

    free(pbEncodedSigner);

    //
    // get the signers cert
    //
    pviewhelp->pSignerCert = GetSignersCert(
                                pviewhelp->pbSignerInfo,
                                pviewhelp->hExtraStore,
                                pviewhelp->pcvctl->cStores,
                                pviewhelp->pcvctl->rghStores);

}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL VerifyCounterSignature(CTL_VIEW_HELPER *pviewhelp, FILETIME *pft, BOOL *pfCertValid, BOOL *pfCounterSignerCertFound)
{
    CRYPT_ATTRIBUTE     *pAttr = NULL;
    PCMSG_ATTR          pMsgAttr = NULL;
    DWORD               cbMsgAttr = 0;
    HCRYPTMSG           hMsg = NULL;
    BOOL                fRet = TRUE;
    PCMSG_SIGNER_INFO   pbCounterSignerInfo = NULL;
    DWORD               cbCounterSignerInfo = 0;
    BYTE                *pbEncodedSigner = NULL;
    DWORD               cbEncodedSigner = 0;
    CERT_INFO           CertInfo;
    PCCERT_CONTEXT      pCertContext=NULL;

    *pfCounterSignerCertFound = FALSE;
    *pfCertValid = FALSE;

    //
    // get the unauthenticated attributes because that is where the counter signer is
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                     0,
                     NULL,
                     &cbMsgAttr);

    if (cbMsgAttr == 0)
    {
        return TRUE;
    }

    if (NULL == (pMsgAttr = (CMSG_ATTR *) malloc(cbMsgAttr)))
    {
        goto ErrorCleanup;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                          0,
                          (void *) pMsgAttr,
                          &cbMsgAttr))
    {
        goto ErrorCleanup;
    }

    //
    // search for the counter signer in the unauthenticated attributes
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pMsgAttr->cAttr,
                                   pMsgAttr->rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        goto Cleanup;
    }

    //
    // decode the encoded counter signer info
    //
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pAttr->rgValue[0].pbData,
					    pAttr->rgValue[0].cbData,
					    0,
					    NULL,
					    &cbCounterSignerInfo))
    {
        goto ErrorCleanup;
    }
	

    if (NULL == (pbCounterSignerInfo = (PCMSG_SIGNER_INFO) malloc(cbCounterSignerInfo)))
    {
        goto ErrorCleanup;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pAttr->rgValue[0].pbData,
					    pAttr->rgValue[0].cbData,
					    0,
					    pbCounterSignerInfo,
					    &cbCounterSignerInfo))
    {
        goto ErrorCleanup;
    }

    pCertContext = GetSignersCert(
                        pbCounterSignerInfo,
                        pviewhelp->hExtraStore,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores);

    //
    // if the cert was not found, then set the boolean and return FALSE
    // for verifying the signature
    //
    if (pCertContext == NULL)
    {
        *pfCounterSignerCertFound = FALSE;
        goto ErrorCleanup;
    }
    else
    {
        *pfCounterSignerCertFound = TRUE;
    }

    //
    // validate the cert for usage
    //
    *pfCertValid = ValidateCertForUsage(
                        pCertContext,
                        pft,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores,
                        pviewhelp->hExtraStore,
                        szOID_PKIX_KP_TIMESTAMP_SIGNING); // currently the only type of counter signing permitted

    if (!(*pfCertValid))
    {
        goto ErrorCleanup;
    }

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_ENCODED_SIGNER,
                     0,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        goto ErrorCleanup;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        goto ErrorCleanup;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_ENCODED_SIGNER,
                          0,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        goto ErrorCleanup;
    }

    //
    // verify the counter signature
    //
    fRet = CryptMsgVerifyCountersignatureEncoded(
                            NULL,   //HCRYPTPROV
                            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                            pbEncodedSigner,
                            cbEncodedSigner,
                            pAttr->rgValue[0].pbData,
                            pAttr->rgValue[0].cbData,
                            pCertContext->pCertInfo
                            );

Cleanup:
    if (pMsgAttr)
        free(pMsgAttr);

    if (pbCounterSignerInfo)
        free(pbCounterSignerInfo);

    if (pbEncodedSigner)
        free(pbEncodedSigner);

    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    return fRet;

ErrorCleanup:
    fRet = FALSE;
    goto Cleanup;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    CHARFORMAT          chFormat;
    FILETIME            *pft;
    BOOL                fCatFile;
    BOOL                fCounterSignerCertFound;
    BOOL                fCertValid;

#ifdef CMS_PKCS7
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;
#endif  // CMS_PKCS7


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_DETAIL_EDIT, L"");

        //
        // check to see if this is a CAT file or CTL file
        //
        pviewhelp->fCatFile = fCatFile = fIsCatalogFile(&(pctl->pCtlInfo->SubjectUsage));

        //
        // Get the CTL signer info
        //
        pviewhelp->hMsg = NULL;
        GetSignerInfo(pviewhelp);

        //
        // enable/disable the "View CTL Signature" button based on whether the signing
        // cert was passed in or not
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VIEW_BUTTON),
                     (pviewhelp->pbSignerInfo != NULL));

        //
        // if there is a signer info, then get the sign time
        //
        if (pviewhelp->pbSignerInfo != NULL)
        {
            AllocAndReturnTimeStampersTimes(pviewhelp->pbSignerInfo, &pft);
        }

#ifdef CMS_PKCS7

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =

        // Assume the CTL only has 1 signer
        CtrlPara.dwSignerIndex = 0;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pviewhelp->pSignerCert;
#endif  // CMS_PKCS7

        //
        // set the valid/invalid bitmap and the validity text based on whether the signature of
        // CTL verifies or not
        //
        if (pviewhelp->fNoSignature == TRUE)
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_NO_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_NO_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = CRYPT_E_NO_SIGNER;
        }
        else if (pviewhelp->pSignerCert == NULL)
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = TRUST_E_NO_SIGNER_CERT;
        }
        else if (!ValidateCertForUsage(
                        pviewhelp->pSignerCert,
                        pft,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores,
                        pviewhelp->hExtraStore,
                        fCatFile ? szOID_PKIX_KP_CODE_SIGNING : szOID_KP_CTL_USAGE_SIGNING))
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_INVALID_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_INVALID_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
            }
        }
#ifdef CMS_PKCS7
        // NOTE!!! the above ValidateCertForUsage() calls WinVerifyTrust().
        // As a result, for a DSS signer it would have inherited its public key
        // algorithm parameters.
        //
        // NOTE!!! also assumes dwSignerIndex == 0.
        else if (!CryptMsgControl(
                     pviewhelp->pcvctl->pCTLContext->hCryptMsg,
                     0,                                     // dwFlags
                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                     &CtrlPara
                     ))
#else
        else if (!CryptMsgControl(
                     pviewhelp->pcvctl->pCTLContext->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE,
                     pviewhelp->pSignerCert->pCertInfo
                     ))
#endif  // CMS_PKCS7
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = TRUST_E_BAD_DIGEST;
        }
        else if (!VerifyCounterSignature(pviewhelp, pft, &fCertValid, &fCounterSignerCertFound))
        {
            if (fCatFile)
            {
                if (!fCounterSignerCertFound)
                {
                    LoadStringU(HinstDll, IDS_CAT_COUNTER_SIGNER_CERT_UNAVAILABLE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
                }
                else if (!fCertValid)
                {
                    LoadStringU(HinstDll, IDS_CAT_INVALID_COUNTER_SIGNER_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_CAT_INVALID_COUNTER_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
                }
            }
            else
            {
                if (!fCounterSignerCertFound)
                {
                    LoadStringU(HinstDll, IDS_CTL_COUNTER_SIGNER_CERT_UNAVAILABLE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
                }
                else if (!fCertValid)
                {
                    LoadStringU(HinstDll, IDS_CTL_INVALID_COUNTER_SIGNER_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_CTL_INVALID_COUNTER_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
                }
            }
            pviewhelp->dwInheritableError = TRUST_E_COUNTER_SIGNER;
        }
        else
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_VALID, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_VALID, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_TRUSTLIST));
            }
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT, szText);

        if (pviewhelp->pbSignerInfo != NULL)
        {
            free(pft);
        }

        //
        // set the header text and subclass the edit controls so they display an
        // arrow cursor in their window
        //
        if (fCatFile)
        {
            LoadStringU(HinstDll, IDS_CAT_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        }
        else
        {
            LoadStringU(HinstDll, IDS_CTL_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT, szText);
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT));

        //
        // set the font for the CTL header information
        //
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 130;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }


        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pctl->pCtlInfo, &i);
        DisplayExtensions(hWndListView, pctl->pCtlInfo->cExtension, pctl->pCtlInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pctl->pCtlInfo->cExtension, pctl->pCtlInfo->rgExtension, TRUE, &i);
        DisplayProperties(hWndListView, pctl, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CTL_GENERAL_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CTL_GENERAL_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CTL_GENERAL_ITEM_LIST)
            {
                break;
            }

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CTL_GENERAL_DETAIL_EDIT,
                    -1);

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CTL_GENERAL_ITEM_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (LOWORD(wParam))
        {
        case IDC_CTL_GENERAL_VIEW_BUTTON:
            {
                CRYPTUI_VIEWSIGNERINFO_STRUCTW cvsi;

                memset(&cvsi, 0, sizeof(cvsi));
                cvsi.dwSize = sizeof(cvsi);
                cvsi.hwndParent = hwndDlg;
                cvsi.pSignerInfo = pviewhelp->pbSignerInfo;
                cvsi.hMsg = pviewhelp->hMsg;
                cvsi.pszOID = fIsCatalogFile(&(pCtlInfo->SubjectUsage)) ? szOID_PKIX_KP_CODE_SIGNING : szOID_KP_CTL_USAGE_SIGNING;
                cvsi.cStores = 1;
                cvsi.rghStores = &(pviewhelp->hExtraStore);

                if (pviewhelp->dwInheritableError != 0)
                {
                    cvsi.dwReserved = pviewhelp->dwInheritableError;
                    cvsi.dwFlags |= CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE;
                }

                CryptUIDlgViewSignerInfoW(&cvsi);

            }
            break;
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                 //        pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_PAINT:
        RECT        rect;
        PAINTSTRUCT paintstruct;
        HDC         hdc;
        COLORREF    colorRef;

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (GetUpdateRect(hwndDlg, &rect, FALSE))
        {
            hdc = BeginPaint(hwndDlg, &paintstruct);
            if (hdc == NULL)
            {
                EndPaint(hwndDlg, &paintstruct);
                break;
            }

            colorRef = GetBkColor(hdc);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT), EM_SETBKGNDCOLOR , 0, (LPARAM) colorRef);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT), EM_SETBKGNDCOLOR, 0, (LPARAM) colorRef);

            if (pviewhelp->hIcon != NULL)
            {
                DrawIcon(
                    hdc,
                    ICON_X_POS,
                    ICON_Y_POS,
                    pviewhelp->hIcon);
            }

            EndPaint(hwndDlg, &paintstruct);
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (pviewhelp->hIcon != NULL)
        {
            DeleteObject(pviewhelp->hIcon);
            pviewhelp->hIcon = NULL;
        }
        if (pviewhelp->pSignerCert != NULL)
        {
            CertFreeCertificateContext(pviewhelp->pSignerCert);
            pviewhelp->pSignerCert = NULL;
        }
        if (pviewhelp->pbSignerInfo)
        {
            free(pviewhelp->pbSignerInfo);
            pviewhelp->pbSignerInfo = NULL;
        }

        if (pviewhelp->hMsg != NULL)
        {
            CryptMsgClose(pviewhelp->hMsg);
            
        }
        pviewhelp->hMsg = NULL;

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST))    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_DETAIL_EDIT))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VIEW_BUTTON)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            if (pviewhelp->fCatFile)
            {
                return OnContextHelp(hwndDlg, msg, wParam, lParam, CatHelpmap);
            }
            else
            {
                return OnContextHelp(hwndDlg, msg, wParam, lParam, CTLHelpmap);
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\cps.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cps.cpp
//
//--------------------------------------------------------------------------

//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE       HinstDll;
extern HMODULE         HmodRichEdit;

typedef struct _CPS_STATE_STRUCT {
    LPWSTR  pwszURL;
    LPWSTR  pwszDisplayText;
    DWORD   dwChainError;
    BOOL    fNoCOM;
} CPS_STATE_STRUCT, *PCPS_STATE_STRUCT;


INT_PTR CALLBACK CPSDlgProc(HWND hwndDlg, UINT msg,
                               WPARAM wParam, LPARAM lParam)
{

    BOOL                f;
    CPS_STATE_STRUCT    *pcpsStateStruct;

    switch (msg) {
    case WM_INITDIALOG:

        pcpsStateStruct = (CPS_STATE_STRUCT *) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pcpsStateStruct);

        // set the text for the CPS
        CryptUISetRicheditTextW(hwndDlg, IDC_CPS_TEXT, pcpsStateStruct->pwszDisplayText);

        // if there is no URL then hide the more info button,
        //
        // DSIE: Bug 364742, also hide if the URL is not safe to be execute.
        if (!pcpsStateStruct->pwszURL || 
            !IsOKToFormatAsLinkW(pcpsStateStruct->pwszURL, pcpsStateStruct->dwChainError))
        {
            EnableWindow(GetDlgItem(hwndDlg, ID_MORE_INFO), FALSE);
        }
        break;

    case WM_NOTIFY:
        //if (((NMHDR FAR *) lParam)->code == EN_LINK)

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_MORE_INFO:

            if (HIWORD(wParam) == BN_CLICKED)
            {
                DWORD   numBytes = 0;
                LPSTR   pszURL = NULL;

                pcpsStateStruct = (CPS_STATE_STRUCT *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                pszURL = CertUIMkMBStr(pcpsStateStruct->pwszURL);

                if (pszURL == NULL)
                {
                    return TRUE;
                }

                CryptuiGoLink(hwndDlg, pszURL, pcpsStateStruct->fNoCOM);
                free(pszURL);
                return TRUE;
            }
            break;

        case IDOK:
        case IDCANCEL:
        case IDOK_CPS:
        case IDCANCEL_CPS:
            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        break;

        //
        //  Use the default handler -- we don't do anything for it
        //

    default:
        return FALSE;
    }

    return FALSE;
}


DWORD GetCPSInfo(PCCERT_CONTEXT pCertContext, LPWSTR * ppwszUrlString, LPWSTR * ppwszDisplayText)
{
    DWORD                               dwRetCode = 0;
    PCERT_EXTENSION                     pExt = NULL;
    DWORD                               i,j,k;
    DWORD                               cbCertPolicyInfo = 0;
    CERT_POLICIES_INFO                * pCertPolicyInfo = NULL;
    CERT_NAME_VALUE                   * pCertName = NULL;
    DWORD                               cbCertName = 0;
    CERT_POLICY_QUALIFIER_USER_NOTICE * pUserNotice = NULL;
    DWORD                               cbUserNotice = 0;
    PSPC_SP_AGENCY_INFO                 pInfo = NULL;
    DWORD                               cbInfo = 0;
    CERT_POLICY95_QUALIFIER1          * pCertPolicy95Qualifier = NULL;
    DWORD                               cbCertPolicy95Qualifier = 0;

    //
    // Check parameters and intialize return values.
    //
    if (NULL == pCertContext || NULL == ppwszUrlString || NULL == ppwszDisplayText)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppwszUrlString = *ppwszDisplayText = NULL;

    //
    // first look for the PKIX policy extension and see if it has an URL
    //
    if ((pExt = CertFindExtension(szOID_CERT_POLICIES, 
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension)))
    {
        //
        // decode the policy extension
        //
        CryptDecodeObject(X509_ASN_ENCODING, 
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbCertPolicyInfo);

        if (!(pCertPolicyInfo = (CERT_POLICIES_INFO *) malloc(cbCertPolicyInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                szOID_CERT_POLICIES,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pCertPolicyInfo,
                                &cbCertPolicyInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        //
        // look for display text and/or and URL in the extension
        //
        for (i = 0; i < pCertPolicyInfo->cPolicyInfo ; i++)
        {
            for (j = 0; j < pCertPolicyInfo->rgPolicyInfo[i].cPolicyQualifier; j++)
            {
                // check to see what type of qualifier it is
                if (0 == strcmp(szOID_PKIX_POLICY_QUALIFIER_CPS,
                                pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    // decode as an anystring
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      X509_UNICODE_ANY_STRING,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbCertName);

                    if (!(pCertName = (CERT_NAME_VALUE *) malloc(cbCertName)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pCertName,
                                            &cbCertName)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    if (pCertName->Value.cbData && NULL == *ppwszUrlString)
                    {
                        if (!(*ppwszUrlString = (LPWSTR) malloc(pCertName->Value.cbData + sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszUrlString, (LPWSTR) pCertName->Value.pbData);
                    }

                    free(pCertName);
                    pCertName = NULL;
                }
                else if (0 == strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                     pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    // decode as user notice
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbUserNotice);

                    if (!(pUserNotice = (CERT_POLICY_QUALIFIER_USER_NOTICE *) malloc(cbUserNotice)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pUserNotice,
                                            &cbUserNotice)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    // NOTE: pUserNotice->pszDisplayText may be NULL
                    if (pUserNotice->pszDisplayText && NULL == *ppwszDisplayText)
                    {
                        if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pUserNotice->pszDisplayText) + 1) * sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszDisplayText, pUserNotice->pszDisplayText);
                    }

                    free(pUserNotice);
                    pUserNotice = NULL;
                }
            }
        }
    }
    //
    // next look for display information in the SPC Agency Info
    //

    else if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, 
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, 
                          SPC_SP_AGENCY_INFO_STRUCT,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbInfo);

        if (!(pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                SPC_SP_AGENCY_INFO_STRUCT,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pInfo,
                                &cbInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        if (!(pInfo->pPolicyInformation))
        {
            dwRetCode = CRYPT_E_NOT_FOUND;
            goto ErrorExit;
        }

        if (pInfo->pwszPolicyDisplayText)
        {
            if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pInfo->pwszPolicyDisplayText) + 1) * sizeof(WCHAR))))
            {
                dwRetCode = ERROR_OUTOFMEMORY;
                goto ErrorExit;
            }

            wcscpy(*ppwszDisplayText, pInfo->pwszPolicyDisplayText);
        }

        switch (pInfo->pPolicyInformation->dwLinkChoice)
        {
            case SPC_URL_LINK_CHOICE:
            {
                if (pInfo->pPolicyInformation->pwszUrl)
                {
                    if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pInfo->pPolicyInformation->pwszUrl) + 1) * sizeof(WCHAR))))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    wcscpy(*ppwszUrlString, pInfo->pPolicyInformation->pwszUrl);
                }

                break;
            }

            case SPC_FILE_LINK_CHOICE:
            {
                if (pInfo->pPolicyInformation->pwszFile)
                {
                    if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pInfo->pPolicyInformation->pwszFile) + 1) * sizeof(WCHAR))))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    wcscpy(*ppwszUrlString, pInfo->pPolicyInformation->pwszFile);
                }

                break;
            }
        }
    }

    //
    // finally, look for info in the 2.5.29.3 extension
    //

    else if ((pExt = CertFindExtension(szOID_CERT_POLICIES_95, 
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, 
                          szOID_CERT_POLICIES_95,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbCertPolicyInfo);

        if (!(pCertPolicyInfo = (CERT_POLICIES_INFO *) malloc(cbCertPolicyInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                szOID_CERT_POLICIES_95,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pCertPolicyInfo,
                                &cbCertPolicyInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        // now decode the qualifiers
        for (i = 0; i < pCertPolicyInfo->cPolicyInfo; i++)
        {
            for (j = 0; j < pCertPolicyInfo->rgPolicyInfo[i].cPolicyQualifier; j++)
            {
                if (0 == strcmp(szOID_CERT_POLICIES_95_QUALIFIER1,
                                pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_CERT_POLICIES_95_QUALIFIER1,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbCertPolicy95Qualifier);

                    if (!(pCertPolicy95Qualifier = (CERT_POLICY95_QUALIFIER1 *) malloc(cbCertPolicy95Qualifier)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            szOID_CERT_POLICIES_95_QUALIFIER1,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pCertPolicy95Qualifier,
                                            &cbCertPolicy95Qualifier)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    // check to see what is available
                    if ((NULL != pCertPolicy95Qualifier->pszPracticesReference) && (NULL == *ppwszDisplayText))
                    {
                        if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pCertPolicy95Qualifier->pszPracticesReference) + 1) * sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszDisplayText, pCertPolicy95Qualifier->pszPracticesReference);
                    }

                    for (k = 0; k < pCertPolicy95Qualifier->cCPSURLs; k++)
                    {
                        if ((NULL != pCertPolicy95Qualifier->rgCPSURLs[k].pszURL) && (NULL == *ppwszUrlString))
                        {
                            if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pCertPolicy95Qualifier->rgCPSURLs[k].pszURL) + 1) * sizeof(WCHAR))))
                            {
                                dwRetCode = ERROR_OUTOFMEMORY;
                                goto ErrorExit;
                            }

                            wcscpy(*ppwszUrlString, pCertPolicy95Qualifier->rgCPSURLs[k].pszURL);
                        }
                    }

                    free(pCertPolicy95Qualifier);
                    pCertPolicy95Qualifier = NULL;
                }
            }
        }
    }

    //
    // If there is neither display text nor an URL, then return CRYPT_E_NOT_FOUND.
    //
    if ((NULL == *ppwszUrlString) && (NULL == *ppwszDisplayText))
    {
        dwRetCode = CRYPT_E_NOT_FOUND;
    }

CommonExit:

    if (pInfo)
        free(pInfo);

    if (pCertPolicyInfo)
        free(pCertPolicyInfo);

    if (pUserNotice)
        free(pUserNotice);

    if (pCertName)
        free(pCertName);

    if (pCertPolicy95Qualifier)
        free(pCertPolicy95Qualifier);

    return dwRetCode;

ErrorExit:
    if (*ppwszUrlString)
    {
        free(*ppwszUrlString);
        *ppwszUrlString = NULL;
    }

    if (*ppwszDisplayText)
    {
        free(*ppwszDisplayText);
        *ppwszDisplayText = NULL;
    }

    goto CommonExit;
}


BOOL IsOKToDisplayCPS(PCCERT_CONTEXT pCertContext, DWORD dwChainError)
{
    BOOL   fResult = FALSE;
    LPWSTR pwszUrlString = NULL;
    LPWSTR pwszDisplayText = NULL;

    //
    // Check parameters and initialize.
    //
    if (NULL == pCertContext)
    {
        goto CommonExit;
    }

    //
    // Get CPS info.
    //
    if ((0 == GetCPSInfo(pCertContext, &pwszUrlString, &pwszDisplayText)) &&
        (pwszDisplayText || IsOKToFormatAsLinkW(pwszUrlString, dwChainError)))
    {
        fResult = TRUE;
    }

CommonExit:

    if (pwszUrlString)
    {
        free(pwszUrlString);
    }

    if (pwszDisplayText)
    {
        free(pwszDisplayText);
    }

    return fResult;
}


BOOL DisplayCPS(HWND hwnd, PCCERT_CONTEXT pCertContext, DWORD dwChainError, BOOL fNoCOM)
{
    BOOL              fRet = FALSE;
    DWORD             dwRetCode = 0;
    CPS_STATE_STRUCT  cpsStateStruct;

    //
    // Initialize and check parameters.
    //
    memset(&cpsStateStruct, 0, sizeof(cpsStateStruct));

    if (NULL == pCertContext)
    {
        goto Return;
    }

    //
    // Get CPS info.
    //
    if (0 != (dwRetCode = GetCPSInfo(pCertContext, &cpsStateStruct.pwszURL, &cpsStateStruct.pwszDisplayText)))
    {
        goto Return;
    }

    // NOW, set up for, and launch that dialog
    if ((HmodRichEdit == NULL) && (NULL == (HmodRichEdit = LoadLibraryA("RichEd20.dll"))))
    {
        goto Return;
    }

    //
    // If there is an URL but no text then just invoke the browser and don't bring
    // up the dialog
    //
    if ((cpsStateStruct.pwszDisplayText == NULL) && (cpsStateStruct.pwszURL != NULL))
    {
        DWORD   numBytes = 0;
        LPSTR   pszURL = NULL;

        pszURL = CertUIMkMBStr(cpsStateStruct.pwszURL);
        if (pszURL == NULL)
        {
            goto Return;
        }

        CryptuiGoLink(hwnd, pszURL, fNoCOM);
        free(pszURL);
    }
    else
    {
        cpsStateStruct.fNoCOM = fNoCOM;
        cpsStateStruct.dwChainError = dwChainError;
        DialogBoxParamU(HinstDll, (LPWSTR) MAKEINTRESOURCE(IDD_CPS_DIALOG), hwnd, CPSDlgProc, (LPARAM) &cpsStateStruct);
    }

    fRet = TRUE;

Return:

    if (cpsStateStruct.pwszURL)
        free(cpsStateStruct.pwszURL);

    if (cpsStateStruct.pwszDisplayText)
        free(cpsStateStruct.pwszDisplayText);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\ctltlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctltlist.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CTL_TRUSTLIST_CERTIFICATE_LIST,    IDH_CTLVIEW_TRUSTLIST_CERTIFICATE_LIST},
    {IDC_CTL_TRUSTLIST_CERTVALUE_LIST,      IDH_CTLVIEW_TRUSTLIST_CERTVALUE_LIST},
    {IDC_CTL_TRUSTLIST_DETAIL_EDIT,         IDH_CTLVIEW_TRUSTLIST_VALUE_DETAIL_EDIT},
    {IDC_CTL_TRUSTLIST_VIEW_BUTTON,         IDH_CTLVIEW_TRUSTLIST_VIEWCERT_BUTTON}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void DisplayCertificateValues(HWND hWndListView, PCCERT_CONTEXT pCertContext, PCTL_ENTRY pctlEntry)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    WCHAR       szValueText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    LV_ITEMW    lvIDelete;
    int         index = 0;
    PCERT_INFO  pCertInfo;
    BYTE        hash[20];
    DWORD       hashSize = ARRAYSIZE(hash);
    BOOL        fAddRows;
    DWORD       cChars;
    DWORD       cbFormatedAttribute;
    BYTE        *pbFormatedAttribute;
    DWORD       i;


    if (pCertContext == NULL)
    {
        while(ListView_DeleteItem(hWndListView, 0));
        return;
    }

    pCertInfo = pCertContext->pCertInfo;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.lParam = NULL;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;

    //
    // if the rows have already been added, then don't add them again, just
    // set the text in the subitem
    //
    fAddRows = ListView_GetItemCount(hWndListView) == 0;

    //
    // subject
    //
    cChars = CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                NULL,
                0);
    if ((cChars != 1) && (NULL != (pwszText = (LPWSTR) malloc(cChars * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                pwszText,
                cChars);

        LoadStringU(HinstDll, IDS_ADV_ISSUEDTO, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // issuer
    //
    cChars = CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                NULL,
                0);
    if ((cChars != 1) && (NULL != (pwszText = (LPWSTR) malloc(cChars * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                pwszText,
                cChars);

        LoadStringU(HinstDll, IDS_ADV_ISSUEDFROM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pCertInfo->SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    TRUE);
    }

    //
    // not after
    //
    if (FormatDateString(&pwszText, pCertInfo->NotAfter, TRUE, TRUE, hWndListView))
    {
        LoadStringU(HinstDll, IDS_ADV_NOTAFTER, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // thumbprint
    //
    if (FormatMemBufToString(
                    &pwszText,
                    pctlEntry->SubjectIdentifier.pbData,
                    pctlEntry->SubjectIdentifier.cbData))
    {
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_PROPERTY;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    TRUE);
    }

    //
    // Attributes
    //

    //
    // delete any existing attributes
    //
    memset(&lvIDelete, 0, sizeof(lvIDelete));
    lvIDelete.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvIDelete.mask = LVIF_PARAM;
    while (lvIDelete.iItem >= index)
    {
        if (ListView_GetItemU(hWndListView, &lvIDelete))
        {
            FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvIDelete.lParam);
        }
        ListView_DeleteItem(hWndListView, lvIDelete.iItem);
        lvIDelete.iItem--;
    }

    if (pctlEntry->cAttribute > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_ADDITIONAL_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iItem = index++;
        ListView_InsertItemU(hWndListView, &lvI);

        //
        // display each attribute
        //
        for (i=0; i<pctlEntry->cAttribute; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pctlEntry->rgAttribute[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pctlEntry->rgAttribute[i].pszObjId,
                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                        pctlEntry->rgAttribute[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pctlEntry->rgAttribute[i].pszObjId,
                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                        pctlEntry->rgAttribute[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = index++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM)  MakeListDisplayHelperForExtension(
                                                        pctlEntry->rgAttribute[i].pszObjId,
                                                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                                                        pctlEntry->rgAttribute[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        index-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PCCERT_CONTEXT FindCertContextInStores(
                                PCTL_ENTRY  pCtlEntry,
                                DWORD       chStores1,
                                HCERTSTORE  *rghStores1,
                                DWORD       chStores2,
                                HCERTSTORE  *rghStores2,
                                HCERTSTORE  hExtraStore,
                                DWORD       dwFindType)
{
    DWORD           i;
    PCCERT_CONTEXT  pCertContext = NULL;

    if (dwFindType == 0)
    {
        return NULL;
    }

    i = 0;
    while ((i<chStores1) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores1[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    i = 0;
    while ((i<chStores2) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores2[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    if (pCertContext == NULL)
    {
        pCertContext = CertFindCertificateInStore(
                                hExtraStore,
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    return pCertContext;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertificatesToList(HWND hWndListView, CTL_VIEW_HELPER *pviewhelp)
{
    LPWSTR          pwszText;
    WCHAR           szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW        lvI;
    DWORD           i;
    PCCTL_CONTEXT   pctl;
    DWORD           dwFindType;
    ALG_ID          algID;
    PCCRYPT_OID_INFO pOIDInfo;
    PCCERT_CONTEXT  pCertContext;
    int             index = 0;
    BOOL            fDisplayed;
    HCERTSTORE      hExtraStore;

    pctl = pviewhelp->pcvctl->pCTLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;

    //
    // determine what type of hash the CTL uses, if it isn't anything
    // we know about then dont try to find any certs
    //
    pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pctl->pCtlInfo->SubjectAlgorithm.pszObjId,
                    CRYPT_HASH_ALG_OID_GROUP_ID);

    if ((pOIDInfo != NULL) && (pOIDInfo->Algid == CALG_SHA1))
    {
        dwFindType = CERT_FIND_SHA1_HASH;
    }
    else if ((pOIDInfo != NULL) && (pOIDInfo->Algid == CALG_MD5))
    {
        dwFindType = CERT_FIND_MD5_HASH;
    }
    else
    {
        dwFindType = 0;
    }

    //
    // loop for each cert and try to find it
    //
    for (i=0; i<pctl->pCtlInfo->cCTLEntry; i++)
    {
        fDisplayed = FALSE;

        if (dwFindType != 0)
        {
            pCertContext = FindCertContextInStores(
                                &(pctl->pCtlInfo->rgCTLEntry[i]),
                                pviewhelp->chStores,
                                pviewhelp->phStores,
                                pviewhelp->pcvctl->cCertSearchStores,
                                pviewhelp->pcvctl->rghCertSearchStores,
                                pviewhelp->hExtraStore,
                                dwFindType);
        }
        else
        {
            pCertContext = NULL;
        }

        //
        // if we found a cert to go with the hash, then get a display name for it
        // and display that along with the hash
        //
        if (pCertContext != NULL)
        {
            //
            // subject algorithm
            //
            if (CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText)))
            {
                if (FormatMemBufToString(
                            &pwszText,
                            pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                            pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData))
                {
                    lvI.lParam = (LPARAM) pCertContext;
                    lvI.iItem = index++;
                    lvI.cchTextMax = wcslen(szText);
                    ListView_InsertItemU(hWndListView, &lvI);
                    ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
                    free(pwszText);
                    fDisplayed = TRUE;
                }
            }
        }

        //
        // if the cert hasn't been displayed, that means no cert could be found based
        // on the hash, or a simple name could not be acquired, in any case, just
        // display the hash without a name
        //
        if (!fDisplayed)
        {
            if (FormatMemBufToString(
                        &pwszText,
                        pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                        pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData))
            {
                lvI.lParam = (LPARAM) pCertContext;
                lvI.iItem = index++;
                LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
                lvI.cchTextMax = wcslen(szText);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
                free(pwszText);
                fDisplayed = TRUE;
            }
        }

        //
        // if for some strange reason we have not displayed the cert and we have
        // a context for it, then free it so there is no memory leak
        //
        if ((fDisplayed == FALSE) && (pCertContext != NULL))
        {
            CertFreeCertificateContext(pCertContext);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLTrustList(HWND hwndDlg, UINT msg, WPARAM wParam,
                                    LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    PCCERT_CONTEXT      pCertContext;
    LPWSTR              pwszText;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // open the know stores that we will be extracting the cert contexts from
        //
        if (!AllocAndOpenKnownStores(&(pviewhelp->chStores), &(pviewhelp->phStores)))
        {
            pviewhelp->chStores = 0;
            pviewhelp->phStores = NULL;
        }

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT, L"");

        //
        // since there is no cert selected initially disable the "view cert button"
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), FALSE);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 115;
        LoadStringU(HinstDll, IDS_ISSUEDTO2, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 230;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), 1, &lvC) == -1)
        {
            // error
        }

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST), 1, &lvC) == -1)
        {
            // error
        }

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CTL_TRUSTLIST_CERTIFICATE_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CTL_TRUSTLIST_CERTVALUE_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // add all the certificates to the certificate list box
        //
        AddCertificatesToList(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:

            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:

                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

                //
                // if this item is being de-selected, then save it's index incase we need to
                // re-select it
                if ((pnmv->uOldState & LVIS_SELECTED) || (pnmv->uOldState & LVIS_FOCUSED))
                {
                    pviewhelp->previousSelection = pnmv->iItem;
                }

                //
                //
                // if the new item selected is the "Additional Attributes" header, then
                // don't allow it to be selected
                //
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.iItem = pnmv->iItem;
                    lvI.mask = LVIF_TEXT;
                    lvI.pszText = szText;
                    lvI.cchTextMax = ARRAYSIZE(szText);
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        return FALSE;
                    }

                    LoadStringU(HinstDll, IDS_ADDITIONAL_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                    if (wcscmp(szCompareText, szText) == 0)
                    {
                        if (pnmv->iItem == pviewhelp->previousSelection-1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                        }
                        else if (pnmv->iItem == pviewhelp->previousSelection+1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                        }
                        else
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection;
                        }

                        ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                    }
                    else
                    {
                        pviewhelp->currentSelection = pnmv->iItem;
                    }

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            hwndDlg,
                            IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;

            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    //memcpy(&nmv, pnmv, sizeof(nmv));
                    //nmv.hdr.code = NM_CLICK;
                    //SendMessage(hwndDlg, WM_NOTIFY, 0, (LPARAM) &nmv);

                    hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                    //
                    // get the selected item and its corresponding cert context
                    //
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.iItem = pnmv->iItem;
                    lvI.mask = LVIF_PARAM;
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        return FALSE;
                    }
                    DisplayCertificateValues(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            (PCCERT_CONTEXT) lvI.lParam,
                            &(pctl->pCtlInfo->rgCTLEntry[pnmv->iItem]));
                    //
                    // clear the text in the detail edit box
                    //
                    CryptUISetRicheditTextW(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT, L"");

                    //
                    // enable the "view cert button" based on whether the cert is available or not
                    //
                    if (((PCCERT_CONTEXT) lvI.lParam) == NULL)
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), FALSE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), TRUE);
                    }

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            hwndDlg,
                            IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;
            }

            return TRUE;

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON)))
                {
                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_CTL_GENERAL_VIEW_BUTTON, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON));
                }
                break;
            }

            break;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:

                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:

                ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                DisplayHelperTextInEdit(
                        GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                        hwndDlg,
                        IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                        pviewhelp->currentSelection);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE;
                    lvI.iItem = 0;
                    lvI.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            }
            
            break;

        }

        break;

    case WM_COMMAND:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (LOWORD(wParam))
        {
        case IDC_CTL_GENERAL_VIEW_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW cvps;

                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                //
                // get the selected item and its corresponding cert context
                //
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) lvI.lParam;
                cvps.cStores = pviewhelp->pcvctl->cStores;
                cvps.rghStores = pviewhelp->pcvctl->rghStores;
                //cvps.dwFlags = CRYPTUI_IGNORE_UNTRUSTED_ROOT;
                CryptUIDlgViewCertificateW(&cvps, NULL);
            }
            break;
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                 //        HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
            pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if (pviewhelp->chStores != 0)
            {
                FreeAndCloseKnownStores(pviewhelp->chStores, pviewhelp->phStores);
            }

            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }
            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT))        &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\cvdetail.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvdetail.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SHOW_DETAILS_COMBO,        IDH_CERTVIEW_DETAILS_SHOW_COMBO},
    {IDC_SAVE_CERTIFICATE_BUTTON,   IDH_CERTVIEW_DETAILS_SAVECERT_BUTTON},
    {IDC_ITEM_LIST,                 IDH_CERTVIEW_DETAILS_ITEM_LIST},
    {IDC_EDIT_PROPERTIES_BUTTON,    IDH_CERTVIEW_GENERAL_EDITPROPERTIES_BUTTON},
    {IDC_DETAIL_EDIT,               IDH_CERTVIEW_DETAILS_ITEM_EDIT}
};


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCERT_INFO pCertInfo, DWORD *index)
{
    LPWSTR      pwszText;
    LPWSTR      pwszPubKey;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    WCHAR       szKeySize[32];
    LV_ITEMW    lvI;
    DWORD       dwKeySize;
    char        szVersion[32];
    void        *pTemp;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCertInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pCertInfo->SerialNumber)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // signature algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCertInfo->SignatureAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SIG_ALG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // not before
    //
    if (FormatDateString(&pwszText, pCertInfo->NotBefore, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_NOTBEFORE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }


    //
    // not after
    //
    if (FormatDateString(&pwszText, pCertInfo->NotAfter, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_NOTAFTER, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }


    //
    // subject
    //
    LoadStringU(HinstDll, IDS_ADV_SUBJECT, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // public key
    //
    if (FormatAlgorithmString(&pwszText, &(pCertInfo->SubjectPublicKeyInfo.Algorithm)))
    {
        WCHAR temp[32];

        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_PUBKEY, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);

        dwKeySize = CertGetPublicKeyLength(X509_ASN_ENCODING, &(pCertInfo->SubjectPublicKeyInfo));
        _itow(dwKeySize, szKeySize, 10);
        wcscpy(temp, L" (");
        wcscat(temp, szKeySize);
        wcscat(temp, L" Bits)");
        pTemp = realloc(pwszText, ((wcslen(pwszText) + wcslen(temp) + 1 ) * sizeof(WCHAR)));
        if (pTemp == NULL)
        {
            free(pwszText);
            return;
        }
        pwszText = (LPWSTR) pTemp;
        wcscat(pwszText, temp);

        FormatMemBufToString(
                &pwszPubKey,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszPubKey, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        free(pwszText);
    }
}



//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a pointer to a cert contexxt and
// display all the properties tagged to the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayProperties(HWND hWndListView, PCCERT_CONTEXT pCertContext, DWORD *index)
{
    DWORD               i;
    WCHAR               szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LPWSTR              pwszText;
    LV_ITEMW            lvI;
    BYTE                hash[20];
    DWORD               hashSize = ARRAYSIZE(hash);
    DWORD               cbText;
    CRYPT_KEY_PROV_INFO *pKeyInfo = NULL;
    DWORD               cbKeyInfo = 0;
    HCRYPTPROV          hCryptProv;
    HCRYPTKEY           hCryptKey;
    DWORD               dwTemp;
    PCCRYPT_OID_INFO    pThumbprintAlgorithm;
    DWORD               dwAlgID = CALG_SHA1;


    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_PROPERTY;

    //
    // thumbprint algorithm
    //
    if (NULL != (pThumbprintAlgorithm = CryptFindOIDInfo(
                                            CRYPT_OID_INFO_ALGID_KEY,
                                            &dwAlgID,
                                            CRYPT_HASH_ALG_OID_GROUP_ID)) &&
        (NULL != (pwszText = AllocAndCopyWStr(pThumbprintAlgorithm->pwszName))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // thumbprint
    //
    CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            hash,
            &hashSize);
    if (FormatMemBufToString(&pwszText, hash, ARRAYSIZE(hash)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  friendly name
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_FRIENDLY_NAME_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_CERTIFICATE_NAME, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCertificateContextProperty(  pCertContext,
                                            CERT_FRIENDLY_NAME_PROP_ID,
                                            pwszText,
                                            &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  description
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_DESCRIPTION_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_DESCRIPTION, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCertificateContextProperty(  pCertContext,
                                            CERT_DESCRIPTION_PROP_ID,
                                            pwszText,
                                            &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  enhanced key usage
    //
    if (FormatEnhancedKeyUsageString(&pwszText, pCertContext, TRUE, TRUE))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ENHANCED_KEY_USAGE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        FormatEnhancedKeyUsageString(&pwszText, pCertContext, TRUE, FALSE);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        free(pwszText);
    }

    //
    //  extended error information
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (cbText / sizeof(WCHAR) > 1)                                     &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText * 2))))
    {
        DWORD cchText = cbText / sizeof(WCHAR);

        if (!CertGetCertificateContextProperty(  pCertContext,
                                            CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                            pwszText,
                                            &cbText)                    ||
            (cchText != cbText / sizeof(WCHAR))                         ||
            (pwszText[cchText - 1] != L'\0'))
        {
            free(pwszText);
        }
        else
        {
            // Force an extra L'\n' between lines by converting L'\r' to L'\n'
            //
            // Create a duplicate version of the error information where L'\r'
            // is converted to L' ' and L'\n' is converted to L','.

            LPWSTR pwszSingleLineText = pwszText + cchText;

            for (i = 0; i < cchText; i++)
            {
                if (pwszText[i] == L'\r')
                {
                    pwszText[i] = L'\n';
                    pwszSingleLineText[i] = L' ';
                }
                else if (pwszText[i] == L'\n')
                {
                    if (pwszText[i+1] == L'\0')
                    {
                        pwszSingleLineText[i] = L'\0';
                        break;
                    }
                    else
                    {
                        pwszSingleLineText[i] = L',';
                    }
                }
                else
                {
                    pwszSingleLineText[i] = pwszText[i];
                }
            }

            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_EXTENDED_ERROR_INFO, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1,
                pwszSingleLineText);
        }
    }

    //
    // private key
    //
    /*if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_KEY_PROV_INFO_PROP_ID,
                                            NULL,
                                            &cbKeyInfo))
    {
        if (NULL == (pKeyInfo = (CRYPT_KEY_PROV_INFO *) malloc(cbKeyInfo)))
        {
            return;
        }
        if (!CertGetCertificateContextProperty( pCertContext,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                pKeyInfo,
                                                &cbKeyInfo))
        {
            return;
        }

        if (CryptAcquireContextU(
                    &hCryptProv,
                    pKeyInfo->pwszContainerName,
                    pKeyInfo->pwszProvName,
                    pKeyInfo->dwProvType,
                    pKeyInfo->dwFlags))
        {
            if (CryptGetUserKey(hCryptProv, pKeyInfo->dwKeySpec, &hCryptKey))
            {

            }
        }

        free(pKeyInfo);
    }*/

}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam,
                               LPARAM lParam)
{
    DWORD                   i;
    PROPSHEETPAGE           *ps;
    PCCERT_CONTEXT          pccert;
    CERT_VIEW_HELPER        *pviewhelp;
    WCHAR                   rgwch[CRYPTUI_MAX_STRING_SIZE];
    HIMAGELIST              hIml;
    HWND                    hWndListView;
    HWND                    hwnd;
    LV_COLUMNW              lvC;
    WCHAR                   szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                lvI;
    LPNMLISTVIEW            pnmv;
    CRYPTUI_WIZ_EXPORT_INFO ExportInfo;
    DWORD                   dwCertAccessProperty;
    DWORD                   cb;
    WCHAR                   errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                   errorTitle[CRYPTUI_MAX_STRING_SIZE];

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndDetailPage = hwndDlg;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_DETAIL_EDIT, L"");
        
        //
        // initialize the combo box with it's strings
        //

        LoadStringU(HinstDll, IDS_ALL_FIELDS, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 0, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_V1_FIELDS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 1, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_EXTENSIONS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 2, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_CRITICAL_EXTENSIONS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 3, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_PROPERTIES_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 4, (LPARAM) szText);
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_SETCURSEL, 0, (LPARAM) NULL);

        //
        // get the handle of the list view control
        //

        hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);
        }

        //
        // initialize the columns in the list view
        //

        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.cx = 171;            // Width of the column, in pixels.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        for (i = 0; i <= 1; i++)
        {
            lvC.iSubItem = i;
            LoadStringU(HinstDll, IDS_FIELD + i, szText, ARRAYSIZE(szText));

            if (ListView_InsertColumnU(hWndListView, i, &lvC) == -1)
            {
                // error
            }
        }

        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
        DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
        DisplayProperties(hWndListView, pccert, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // for the "Edit Properties" button, get the CERT_ACCESS_STATE_PROP_ID
        // and check it
        //
        cb = sizeof(DWORD);
        CertGetCertificateContextProperty(
                pccert,
                CERT_ACCESS_STATE_PROP_ID,
                (void *) &dwCertAccessProperty,
                &cb);

        if (pviewhelp->pcvp->dwFlags & CRYPTUI_ENABLE_EDITPROPERTIES)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON), TRUE);
        }
        else if (pviewhelp->pcvp->dwFlags & CRYPTUI_DISABLE_EDITPROPERTIES)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON), FALSE);
        }
        else
        {
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON),
                (dwCertAccessProperty & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG));
        }

        return TRUE;

    case WM_MY_REINITIALIZE:

        //
        // send a message to the combo box that selection has chaged, it will then
        // update everything for us
        //
        SendMessage(
                hwndDlg,
                WM_COMMAND,
                (WPARAM) MAKELONG(IDC_SHOW_DETAILS_COMBO, LBN_SELCHANGE),
                (LPARAM) GetDlgItem(hwndDlg, IDC_SHOW_DETAILS_COMBO));

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pccert = pviewhelp->pcvp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                    //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_ITEM_LIST),
                    hwndDlg,
                    IDC_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_ITEM_LIST)
            {
                break;
            }

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_ITEM_LIST),
                    hwndDlg,
                    IDC_DETAIL_EDIT,
                    -1);

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_ITEM_LIST:
                if (NULL == (hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST)))
                    break;

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED | LVIS_SELECTED;
                    lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pccert = pviewhelp->pcvp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDC_SAVE_CERTIFICATE_BUTTON:

            memset(&ExportInfo, 0, sizeof(ExportInfo));
            ExportInfo.dwSize = sizeof(ExportInfo);
            ExportInfo.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
            ExportInfo.pCertContext = pviewhelp->pcvp->pCertContext;
            CryptUIWizExport(0, hwndDlg, NULL, &ExportInfo, NULL);

            break;

        case IDC_EDIT_PROPERTIES_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT csp;
                BOOL                                     fPropertiesChanged;

                memset(&csp, 0, sizeof(csp));
                csp.dwSize = sizeof(csp);
                csp.hwndParent = hwndDlg;
                csp.dwFlags = 0;
                csp.pCertContext = pviewhelp->pcvp->pCertContext;
                csp.cStores = pviewhelp->pcvp->cStores;
                csp.rghStores = pviewhelp->pcvp->rghStores;
                csp.cPropSheetPages = 0;
                csp.rgPropSheetPages = NULL;

                CryptUIDlgViewCertificateProperties(&csp, &fPropertiesChanged);

                //
                // if properties were actually changed, then set the flag
                // to our caller, and refresh our state
                //
                if (fPropertiesChanged)
                {
                    //
                    // if the WinVerifyTrust state was passed in, then the view
                    // cannot be refreshed, so alert the user
                    //
                    if (pviewhelp->pcvp->pCryptProviderData != NULL)
                    {
                        LoadStringU(HinstDll, IDS_NO_REFRESH, errorString, ARRAYSIZE(errorString));
                        if (pviewhelp->pcvp->szTitle != NULL)
                        {
                            MessageBoxU(hwndDlg, errorString, pviewhelp->pcvp->szTitle, MB_OK | MB_ICONWARNING);
                        }
                        else
                        {
                            LoadStringU(HinstDll, IDS_VIEW_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                            MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                        }
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }

                    //
                    // since the editing of properties changed major stuff, we need
                    // to redo the trust work and then reset the display
                    //
                    BuildChain(pviewhelp, NULL);

                    SendMessage(hwndDlg, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    if (pviewhelp->hwndGeneralPage != NULL)
                    {
                        SendMessage(pviewhelp->hwndGeneralPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                    if (pviewhelp->hwndHierarchyPage != NULL)
                    {
                        SendMessage(pviewhelp->hwndHierarchyPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                }
                return TRUE;
            }
            break;

        case IDC_SHOW_DETAILS_COMBO:
            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                DWORD curSel = (DWORD)SendDlgItemMessageA(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_GETCURSEL, 0, (LPARAM) NULL);
                hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

                //
                // get all the items in the list view and free the lParam
                // associated with each of them (lParam is the helper sruct)
                //
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
                lvI.mask = LVIF_PARAM;
                while (lvI.iItem >= 0)
                {
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                    }
                    lvI.iItem--;
                }
                ListView_DeleteAllItems(hWndListView);

                CryptUISetRicheditTextW(hwndDlg, IDC_DETAIL_EDIT, L"");

                i = 0;

                switch (curSel)
                {
                case 0:
                    DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    DisplayProperties(hWndListView, pccert, &i);
                    break;
                case 1:
                    DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
                    break;
                case 2:
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    break;
                case 3:
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    break;
                case 4:
                    DisplayProperties(hWndListView, pccert, &i);
                    break;
                }

                return TRUE;
            }
            break;

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }

        break;
    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SHOW_DETAILS_COMBO))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SAVE_CERTIFICATE_BUTTON))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ITEM_LIST))                &&
            (hwnd != GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\disputil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       disputil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view, OID, and an extension in a bufffer,
// it will then format and display the extension in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayExtension(HWND hWndListView, LPSTR pszObjId, LPBYTE pbData, DWORD cbData, DWORD index)
{
    BYTE    *pbFormatedExtension = NULL;
    DWORD   cbFormatedExtension = 0;

    //
    // format the extension using the installable formatting function
    //
    CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            0,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            NULL,
                &cbFormatedExtension
                );

    if (NULL == (pbFormatedExtension = (BYTE *) malloc(cbFormatedExtension)))
    {
        return;
    }

    if (CryptFormatObject(
            X509_ASN_ENCODING,
            0,
	        0,
	        NULL,
            pszObjId,
            pbData,
            cbData,
	        pbFormatedExtension,
            &cbFormatedExtension
            ))
    {
        ListView_SetItemTextU(
                hWndListView,
                index ,
                1,
                (LPWSTR)pbFormatedExtension);
    }

    free (pbFormatedExtension);
}


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view, an array of extensions and display
// all the extensions  in the list view.  It will either display the extensions that
// are critical or non-critical (based on the parameter fCritical)
//////////////////////////////////////////////////////////////////////////////////////
void DisplayExtensions(HWND hWndListView, DWORD cExtension, PCERT_EXTENSION rgExtension, BOOL fCritical, DWORD *index)
{
    DWORD       i;
    WCHAR       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    WCHAR       pwszText;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    if (fCritical)
        lvI.iImage = IMAGE_CRITICAL_EXTENSION;
    else
        lvI.iImage = IMAGE_EXTENSION;
    lvI.lParam = (LPARAM)NULL;

    //
    //  loop for each extension
    //
    for (i=0; i<cExtension; i++)
    {
        // display only critical or non-critical extensions based on fCritical
        if (rgExtension[i].fCritical != fCritical)
        {
            continue;
        }

        // add the field to the field column of the list view
        if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), rgExtension[i].pszObjId))
        {
            return;
        }

        pwszText =
        lvI.iItem = (*index)++;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelperForExtension(
                                        rgExtension[i].pszObjId,
                                        rgExtension[i].Value.pbData,
                                        rgExtension[i].Value.cbData);
        ListView_InsertItemU(hWndListView, &lvI);

        DisplayExtension(
                hWndListView,
                rgExtension[i].pszObjId,
                rgExtension[i].Value.pbData,
                rgExtension[i].Value.cbData,
                (*index)-1);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PLIST_DISPLAY_HELPER MakeListDisplayHelper(BOOL fHexText, LPWSTR pwszDisplayText, BYTE *pbData, DWORD cbData)
{
    PLIST_DISPLAY_HELPER pDisplayHelper;

    if (NULL == (pDisplayHelper = (PLIST_DISPLAY_HELPER) malloc(sizeof(LIST_DISPLAY_HELPER))))
    {
        return NULL;
    }

    pDisplayHelper->fHexText = fHexText;
    pDisplayHelper->pwszDisplayText = pwszDisplayText;
    pDisplayHelper->pbData = pbData;
    pDisplayHelper->cbData = cbData;

    return pDisplayHelper;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void FreeListDisplayHelper(PLIST_DISPLAY_HELPER pDisplayHelper)
{
    if (pDisplayHelper == NULL)
    {
        return;
    }

    if (pDisplayHelper->pwszDisplayText)
        free(pDisplayHelper->pwszDisplayText);
    if (pDisplayHelper->pbData)
        free(pDisplayHelper->pbData);

    free(pDisplayHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PLIST_DISPLAY_HELPER MakeListDisplayHelperForExtension(LPSTR pszObjId, BYTE *pbData, DWORD cbData)
{
    BYTE    *pbFormatedExtension = NULL;
    DWORD   cbFormatedExtension = 0;

    //
    // format the extension using the installable formatting function if possible,
    // otherwise set up the helper with a pointer to plain old bytes
    //
    if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            NULL,
                &cbFormatedExtension
                ))
    {

        if (NULL == (pbFormatedExtension = (BYTE *) malloc(cbFormatedExtension)))
        {
            return NULL;
        }

        if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            pbFormatedExtension,
                &cbFormatedExtension
                ))
        {
            return MakeListDisplayHelper(FALSE, (LPWSTR) pbFormatedExtension, NULL, 0);
        }
    }
    else
    {
        if (NULL != (pbFormatedExtension = (BYTE *) malloc(cbData)))
        {
            memcpy(pbFormatedExtension, pbData, cbData);
        }
        return MakeListDisplayHelper(TRUE, NULL, pbFormatedExtension, cbData);
    }

    return NULL;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void DisplayHelperTextInEdit(HWND hWndListView, HWND hwndDlg, int nIDEdit, int index)
{
    int                 listIndex;
    LVITEMW             lvI;
    LIST_DISPLAY_HELPER *pDisplayHelper;
    HWND                hWndEdit;

    hWndEdit = GetDlgItem(hwndDlg, nIDEdit);

    //
    // get the selected item if the index was not passed in
    //
    if (index == -1)
    {
        listIndex = ListView_GetNextItem(
                        hWndListView, 		
                        -1, 		
                        LVNI_SELECTED		
                        );	
    }
    else
    {
        listIndex = index;
    }

    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = listIndex;
    lvI.mask = LVIF_PARAM;
    if ((lvI.iItem == -1) || !ListView_GetItemU(hWndListView, &lvI))
    {
        return;
    }

    pDisplayHelper = (PLIST_DISPLAY_HELPER) lvI.lParam;

    if (pDisplayHelper == NULL)
    {
        return;
    }

    if (pDisplayHelper->fHexText)
    {
        SetTextFormatHex(hWndEdit);
    }
    else
    {
        SetTextFormatInitial(hWndEdit);
    }

    if ((pDisplayHelper->fHexText) && (pDisplayHelper->pbData != NULL))
    {
        FormatMemBufToWindow(
                hWndEdit,
                pDisplayHelper->pbData,
                pDisplayHelper->cbData);
    }
    else if (pDisplayHelper->pwszDisplayText != NULL)
    {
        //SetDlgItemTextU(hwndDlg, nIDEdit, pDisplayHelper->pwszDisplayText);
        CryptUISetRicheditTextW(hwndDlg, nIDEdit, pDisplayHelper->pwszDisplayText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
//
// these two functions handle modifying the text font in the field view text box
// on the details tab.
//
static BOOL gfInitialFaceNameSet = FALSE;
static char g_szInitialFaceName[LF_FACESIZE];
static char g_szMonoSpaceFaceName[LF_FACESIZE];

void SetTextFormatInitial(HWND hWnd)
{
    CHARFORMAT  chFormat;

    //
    // initialize the global string variables that hold the face name for the details text box
    //
    if (!gfInitialFaceNameSet)
    {
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_FACE;

        SendMessageA(hWnd, EM_GETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        strcpy(g_szInitialFaceName, chFormat.szFaceName);

        LoadStringA(HinstDll, IDS_FIELD_TEXT_BOX_FONT, g_szMonoSpaceFaceName, ARRAYSIZE(g_szMonoSpaceFaceName));
        gfInitialFaceNameSet = TRUE;
    }

    memset(&chFormat, 0, sizeof(chFormat));
    chFormat.cbSize = sizeof(chFormat);
    chFormat.dwMask = CFM_FACE;
    strcpy(chFormat.szFaceName, g_szInitialFaceName);

    SendMessageA(hWnd, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
}

void SetTextFormatHex(HWND hWnd)
{
    CHARFORMAT  chFormat;

    //
    // initialize the global string variables that hold the face name for the details text box
    //
    if (!gfInitialFaceNameSet)
    {
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_FACE;

        SendMessageA(hWnd, EM_GETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        strcpy(g_szInitialFaceName, chFormat.szFaceName);

        LoadStringA(HinstDll, IDS_FIELD_TEXT_BOX_FONT, g_szMonoSpaceFaceName, ARRAYSIZE(g_szMonoSpaceFaceName));
        gfInitialFaceNameSet = TRUE;
    }

    memset(&chFormat, 0, sizeof(chFormat));
    chFormat.cbSize = sizeof(chFormat);
    chFormat.dwMask = CFM_FACE;
    strcpy(chFormat.szFaceName, g_szMonoSpaceFaceName);

    SendMessageA(hWnd, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetUnknownErrorString(LPWSTR *ppwszErrorString, DWORD dwError)
{
    LPVOID  pwsz;
    DWORD   ret = 0;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];

    ret = FormatMessageU (
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwError,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPWSTR) &pwsz,
            0,
            NULL);

    if (ret != 0)
    {
        *ppwszErrorString = AllocAndCopyWStr((LPWSTR) pwsz);
        LocalFree(pwsz);
    }
    else
    {
        LoadStringU(HinstDll, IDS_UNKNOWN_ERROR, szText, ARRAYSIZE(szText));
        *ppwszErrorString = AllocAndCopyWStr(szText);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetCertErrorString(LPWSTR *ppwszErrorString, PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];

    //
    // if this is true then the cert is OK
    //
    if ((pCryptProviderCert->dwError == 0)                              &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG)        &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME)       &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (!pCryptProviderCert->fIsCyclic)                                &&
        !CertHasEmptyEKUProp(pCryptProviderCert->pCert))
    {
        return FALSE;
    }

    *ppwszErrorString = NULL;

    if ((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT) ||
        (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))
    {
        LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOKED)
    {
        LoadStringU(HinstDll, IDS_CERTREVOKED_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG) ||
             (pCryptProviderCert->dwError == TRUST_E_CERT_SIGNATURE))
    {
        LoadStringU(HinstDll, IDS_CERTBADSIGNATURE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME) ||
             (pCryptProviderCert->dwError == CERT_E_EXPIRED))
    {
        LoadStringU(HinstDll, IDS_CERTEXPIRED_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST) ||
             (pCryptProviderCert->dwError == CERT_E_VALIDITYPERIODNESTING))
    {
        LoadStringU(HinstDll, IDS_TIMENESTING_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_WRONG_USAGE)
    {
        //
        // if state was passed in, then the usage should be there
        //
       /* if (pviewhelp->pcvp->pCryptProviderData != NULL)
        {
            pviewhelp->pcvp->pCryptProviderData->pszUsageOID;
        }
        else
        {
            //
            // otherwise get the usage out of the built up state
            //
            pviewhelp->sWTD.pPolicyCallbackData = pszUsage;
        }*/



        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == TRUST_E_BASIC_CONSTRAINTS)
    {
        LoadStringU(HinstDll, IDS_BASIC_CONSTRAINTS_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_PURPOSE)
    {
        LoadStringU(HinstDll, IDS_PURPOSE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOCATION_FAILURE)
    {
        LoadStringU(HinstDll, IDS_REVOCATION_FAILURE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_CHAINING)
    {
        LoadStringU(HinstDll, IDS_CANTBUILDCHAIN_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == TRUST_E_EXPLICIT_DISTRUST)
    {
        LoadStringU(HinstDll, IDS_EXPLICITDISTRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if ((pCryptProviderCert->dwError == 0) && CertHasEmptyEKUProp(pCryptProviderCert->pCert))
    {
        LoadStringU(HinstDll, IDS_NO_USAGES_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->fIsCyclic)
    {
        LoadStringU(HinstDll, IDS_CYCLE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else
    {
        //
        // this is not an error we know about, so call the general
        // error string function
        //
        GetUnknownErrorString(ppwszErrorString, pCryptProviderCert->dwError);
    }

    if (*ppwszErrorString == NULL)
    {
        if (NULL == (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            return FALSE;
        }
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    PAINTSTRUCT ps;
    BOOL        fReleaseDC = FALSE;

    if (hdc == NULL)
    {
        hdc = GetDC(hwnd);
        if (hdc == NULL)
        {
            return;
        }

        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK ArrowCursorSubclassProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    HDC         hdc;
    WNDPROC     wndproc;
    PAINTSTRUCT ps;
    HWND        hWndSubject;
    HWND        hWndIssuer;
    HWND        hWndNext;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ' )
        {
            break;
        }

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    //case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    //case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

        break;

    case EM_SETSEL:

        return( TRUE );

        break;

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

        break;

    case WM_SETFOCUS:

        hWndSubject = GetDlgItem(GetParent(hwnd), IDC_SUBJECT_EDIT);
        hWndIssuer = GetDlgItem(GetParent(hwnd), IDC_ISSUER_EDIT);

        //if ((hwnd == hWndSubject) || (hwnd == hWndIssuer))
        {
            hWndNext = GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE);

            if ((hWndNext == hWndSubject) && (hwnd == hWndIssuer))
            {
                SetFocus(GetDlgItem(GetParent(GetParent(hwnd)), IDOK));
            }
            else
            {
                SetFocus(hWndNext);
            }
            return( TRUE );
        }
        /*else
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return( TRUE );
        }
*/
        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        return( TRUE );

    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK LinkSubclassProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    DWORD               cpszURLString = 0;
    LPSTR               pszURLString = NULL;
    PLINK_SUBCLASS_DATA plsd;

    plsd = (PLINK_SUBCLASS_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        // if the mouse hasn't been captured yet, then capture it and set the flag
        if (!plsd->fMouseCaptured)
        {
            SetCapture(hwnd);
            plsd->fMouseCaptured = TRUE;
        }

        if (plsd->fUseArrowInsteadOfHand)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
        else
        {
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_MYHAND)));
        }
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ')
        {
            if ( wParam == 0x1b )
            {
                SendMessage(GetParent(GetParent(hwnd)), WM_CLOSE, 0, 0);
                return TRUE;
            }
            break;
        }

        // fall through to wm_lbuttondown....

    case WM_LBUTTONDOWN:

        if (plsd->fUseArrowInsteadOfHand)
        {
            return TRUE;
        }

        SetFocus(hwnd);

        switch(plsd->uId)
        {
            case IDC_SUBJECT_EDIT:
            case IDC_ISSUER_EDIT:
                CryptuiGoLink(GetParent(plsd->hwndParent), plsd->pszURL, plsd->fNoCOM);
                break;
        }

        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    //case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    //case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_PAINT:

        CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_SETFOCUS:

        if ((hwnd == GetDlgItem(GetParent(hwnd), IDC_CERT_PRIVATE_KEY_EDIT)) &&
            (plsd->fUseArrowInsteadOfHand))
        {
            SetFocus(GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE));
            return( TRUE );
        }

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(GetParent(hwnd), NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_MYHAND)));
            return( TRUE );
        }
        break;

    case WM_KILLFOCUS:

        InvalidateRect(GetParent(hwnd), NULL, FALSE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        return( TRUE );

    case WM_MOUSEMOVE:

        MSG                 msg;
        DWORD               dwCharLine;
        RECT                rect;
        int                 xPos, yPos;

        memset(&msg, 0, sizeof(MSG));
        msg.hwnd    = hwnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        SendMessage(plsd->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            plsd->fMouseCaptured = FALSE;
        }

        return( TRUE );
    }

    return(CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam));
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void CertSubclassEditControlForArrowCursor (HWND hwndEdit)
{
    LONG_PTR PrevWndProc;

    PrevWndProc = GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, PrevWndProc);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)ArrowCursorSubclassProc);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void CertSubclassEditControlForLink (
                 HWND                hwndDlg,
                 HWND                hwndEdit,
                 PLINK_SUBCLASS_DATA plsd
                 )
{
    HWND hwndTip;

    plsd->hwndTip = CreateWindowA(
                          TOOLTIPS_CLASSA,
                          (LPSTR)NULL,
                          WS_POPUP | TTS_ALWAYSTIP,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          hwndDlg,
                          (HMENU)NULL,
                          HinstDll,
                          NULL
                          );

    if ( plsd->hwndTip != NULL )
    {
        TOOLINFOA tia;

        memset(&tia, 0, sizeof(TOOLINFOA));
        tia.cbSize = sizeof(TOOLINFOA);
        tia.hwnd = hwndEdit;
        tia.uId = 1;
        tia.hinst = HinstDll;
        //GetClientRect(hwndEdit, &tia.rect);
        SendMessageA(hwndEdit, EM_GETRECT, 0, (LPARAM)&tia.rect);
        tia.lpszText = plsd->pszURL;

        SendMessageA(plsd->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&tia);
    }

    plsd->fMouseCaptured = FALSE;
    plsd->wpPrev = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)plsd);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)LinkSubclassProc);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void * GetStoreName(HCERTSTORE hCertStore, BOOL fWideChar)
{
    DWORD    cbName = 0;
    LPWSTR   pwszName = NULL;
    LPSTR    pszName = NULL;

    if (!CertGetStoreProperty(
                hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                NULL,
                &cbName))
    {
        return NULL;
    }

    if (NULL == (pwszName = (LPWSTR) malloc(cbName)))
    {
        return NULL;
    }

    if (!CertGetStoreProperty(
                hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                pwszName,
                &cbName))
    {
        free(pwszName);
        return NULL;
    }

    if (fWideChar)
    {
        return pwszName;
    }
    else
    {
        pszName = CertUIMkMBStr(pwszName);
        free(pwszName);
        return pszName;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ValidateItemText(HWND hWndListView, LPWSTR pszText, int index)
{
    LVITEMW lvItem;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];

    memset(&lvItem, 0, sizeof(lvItem));
    lvItem.iItem = index;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = szText;
    lvItem.cchTextMax = ARRAYSIZE(szText);
    if (!ListView_GetItemU(hWndListView, &lvItem))
    {
        return FALSE;
    }

    return (wcscmp(szText, pszText) == 0);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void ModifyOrInsertRow(
                    HWND        hWndListView,
                    LV_ITEMW    *plvI,
                    LPWSTR      pwszValueText,
                    LPWSTR      pwszText,
                    BOOL        fAddRows,
                    BOOL        fHex)
{
    LV_ITEMW    lvIParam;

    memset(&lvIParam, 0, sizeof(lvIParam));
    lvIParam.mask = LVIF_PARAM;
    lvIParam.iItem = plvI->iItem;	

    if (fAddRows)
    {
        ListView_InsertItemU(hWndListView, plvI);
    }
    else
    {
        //
        // delete the helper that is already there
        //
        ListView_GetItemU(hWndListView, &lvIParam);
        FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvIParam.lParam);

        if (!ValidateItemText(hWndListView, plvI->pszText, plvI->iItem))
        {
            ListView_DeleteItem(hWndListView, plvI->iItem);
            ListView_InsertItemU(hWndListView, plvI);
        }
    }

    ListView_SetItemTextU(hWndListView, plvI->iItem, 1, pwszValueText);

    lvIParam.lParam = (LPARAM) MakeListDisplayHelper(fHex, pwszText, NULL, 0);
    ListView_SetItem(hWndListView, &lvIParam);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
int CALLBACK HidePropSheetCancelButtonCallback(
                HWND    hwndDlg,
                UINT    uMsg,
                LPARAM  lParam)
{
    RECT rc, parentRect;
    int  xExtra, yExtra;

    if (uMsg == PSCB_INITIALIZED)
    {
        HWND hwndOk = GetDlgItem(hwndDlg, IDOK);
        HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);

        GetWindowRect(hwndCancel, &rc);
        MapWindowPoints(HWND_DESKTOP, hwndDlg, (LPPOINT) &rc, 2);
        ShowWindow(hwndCancel, SW_HIDE);
        MoveWindow(
                hwndOk,
                rc.left,
                rc.top,
                rc.right - rc.left,
                rc.bottom - rc.top,
                FALSE);
    }

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI CryptUIPropertySheetA(LPCPROPSHEETHEADERA pHdr)
{
    PROPSHEETHEADERA    hdr;
    PROPSHEETPAGEA      *pPropSheetPage;
    INT_PTR             ret;
    UINT                i;

    memcpy(&hdr, pHdr, sizeof(PROPSHEETHEADERA));
    hdr.dwSize = PROPSHEETHEADERA_V1_SIZE;

    hdr.ppsp = (PROPSHEETPAGEA *) malloc(pHdr->nPages * PROPSHEETPAGEA_V1_SIZE);
    if (hdr.ppsp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return -1;
    }

    pPropSheetPage = (PROPSHEETPAGEA *) hdr.ppsp;
    for (i=0; i<pHdr->nPages; i++)
    {
        memcpy(pPropSheetPage, &(pHdr->ppsp[i]), PROPSHEETPAGEA_V1_SIZE);
        pPropSheetPage->dwSize = PROPSHEETPAGEA_V1_SIZE;
        pPropSheetPage = (PROPSHEETPAGEA *) (((LPBYTE) pPropSheetPage) + PROPSHEETPAGEA_V1_SIZE);
    }

    ret = PropertySheetA(&hdr);
    free((void *)hdr.ppsp);
    return ret;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI CryptUIPropertySheetW(LPCPROPSHEETHEADERW pHdr)
{
    PROPSHEETHEADERW    hdr;
    PROPSHEETPAGEW      *pPropSheetPage;
    INT_PTR             ret;
    UINT                i;

    memcpy(&hdr, pHdr, sizeof(PROPSHEETHEADERW));
    hdr.dwSize = PROPSHEETHEADERW_V1_SIZE;

    hdr.ppsp = (PROPSHEETPAGEW *) malloc(pHdr->nPages * PROPSHEETPAGEW_V1_SIZE);
    if (hdr.ppsp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return -1;
    }

    pPropSheetPage = (PROPSHEETPAGEW *) hdr.ppsp;
    for (i=0; i<pHdr->nPages; i++)
    {
        memcpy(pPropSheetPage, &(pHdr->ppsp[i]), PROPSHEETPAGEW_V1_SIZE);
        pPropSheetPage->dwSize = PROPSHEETPAGEW_V1_SIZE;
        pPropSheetPage = (PROPSHEETPAGEW *) (((LPBYTE) pPropSheetPage) + PROPSHEETPAGEW_V1_SIZE);
    }

    ret = PropertySheetW(&hdr);
    free((void *)hdr.ppsp);
    return ret;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL IsTrueErrorString(CERT_VIEW_HELPER *pviewhelp)
{
    BOOL fRet;

    if ( ( ((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) ||
            (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT))  &&
         (pviewhelp->fWarnUntrustedRoot)                             &&
         (pviewhelp->fRootInRemoteStore)) ||
          pviewhelp->fWarnRemoteTrust )
    {
        return FALSE;
    }

    switch (pviewhelp->dwChainError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
        fRet = FALSE;
        break;

    case CERT_E_INVALID_NAME:
        if (pviewhelp->pcvp->idxCert == 0)
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }

        break;

    default:
        fRet = TRUE;
        break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\cvgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SUBJECT_EDIT,                  IDH_CERTVIEW_GENERAL_SUBJECT_EDIT},
    {IDC_CERT_GENERAL_ISSUEDTO_HEADER,  IDH_CERTVIEW_GENERAL_SUBJECT_EDIT},
    {IDC_ISSUER_EDIT,                   IDH_CERTVIEW_GENERAL_ISSUER_EDIT},
    {IDC_CERT_GENERAL_ISSUEDBY_HEADER,  IDH_CERTVIEW_GENERAL_ISSUER_EDIT},
    {IDC_ADD_TO_STORE_BUTTON,           IDH_CERTVIEW_GENERAL_INSTALLCERT_BUTTON},
    {IDC_DISCLAIMER_BUTTON,             IDH_CERTVIEW_GENERAL_DISCLAIMER_BUTTON},
    {IDC_ACCEPT_BUTTON,                 IDH_CERTVIEW_GENERAL_ACCEPT_BUTTON},
    {IDC_DECLINE_BUTTON,                IDH_CERTVIEW_GENERAL_DECLINE_BUTTON},
    {IDC_GOODFOR_EDIT,                  IDH_CERTVIEW_GENERAL_GOODFOR_EDIT},
    {IDC_CERT_GENERAL_GOODFOR_HEADER,   IDH_CERTVIEW_GENERAL_GOODFOR_EDIT},
    {IDC_CERT_GENERAL_VALID_EDIT,       IDH_CERTVIEW_GENERAL_VALID_EDIT},
    {IDC_CERT_PRIVATE_KEY_EDIT,         IDH_CERTVIEW_GENERAL_PRIVATE_KEY_INFO}
};

typedef struct {
    void *  pszString;
    int     offset;
    BOOL    fUnicode;
} STREAMIN_HELP_STRUCT;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK MyEditStreamCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    BYTE                    *pByte;
    DWORD                   cbResource;
    STREAMIN_HELP_STRUCT    *pHelpStruct;

    pHelpStruct = (STREAMIN_HELP_STRUCT *) dwCookie;

    pByte = (BYTE *)pHelpStruct->pszString;
    if (pHelpStruct->fUnicode)
    {
        cbResource = wcslen((LPWSTR) pHelpStruct->pszString) * sizeof(WCHAR);
    }
    else
    {
        cbResource = strlen((LPSTR) pHelpStruct->pszString);
    }

    if (pHelpStruct->offset == (int) cbResource)
    {
        *pcb = 0;
    }
    else if ((cb >= (int) cbResource) && (pHelpStruct->offset == 0))
    {
        memcpy(pbBuff, pByte, cbResource);
        *pcb = cbResource;
        pHelpStruct->offset = cbResource;
    }
    else if (cb >= (((int)cbResource) - pHelpStruct->offset))
    {
        memcpy(pbBuff, pByte + pHelpStruct->offset, cbResource - pHelpStruct->offset);
        *pcb = cbResource - pHelpStruct->offset;
    }
    else
    {
        memcpy(pbBuff, pByte  + pHelpStruct->offset, cb);
        *pcb = cb;
        pHelpStruct->offset += cb;
    }

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LRESULT StreamInWrapper(HWND hwndEdit, void * pszString, BOOL fUnicode)
{
    EDITSTREAM              editStream;
    char                    szBuffer[2048];
    STREAMIN_HELP_STRUCT    helpStruct;
    LRESULT                 ret;
    BOOL                    fOKToUseRichEdit20 = fRichedit20Usable(hwndEdit);

    memset(&editStream, 0, sizeof(EDITSTREAM));
    editStream.pfnCallback = MyEditStreamCallback;
    editStream.dwCookie = (DWORD_PTR) &helpStruct;

    SendMessageA(hwndEdit, EM_SETSEL, 0, -1);
    SendMessageA(hwndEdit, EM_SETSEL, -1, 0);

    if (fUnicode && fRichedit20Exists && fOKToUseRichEdit20)
    {
        helpStruct.pszString = pszString;
        helpStruct.offset = 0;
        helpStruct.fUnicode = TRUE;
        
        return (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION | SF_UNICODE, (LPARAM) &editStream));
    }
    else if (fUnicode)
    {
        LPSTR psz = CertUIMkMBStr((LPWSTR) pszString);

        helpStruct.pszString = psz;
        helpStruct.offset = 0;
        helpStruct.fUnicode = FALSE;

        ret = (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION, (LPARAM) &editStream));
        free(psz);

        return (ret);
    }
    else
    {
        helpStruct.pszString = pszString;
        helpStruct.offset = 0;
        helpStruct.fUnicode = FALSE;

        return (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION, (LPARAM) &editStream));
    }
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void LoadAndDisplayString(HWND hWndEditGoodFor, UINT nId, BOOL *pfFirst)
{
    WCHAR   rgwch[CRYPTUI_MAX_STRING_SIZE];
    
    LoadStringU(HinstDll, nId, rgwch, ARRAYSIZE(rgwch));
    
    if (*pfFirst)
    {
        *pfFirst = FALSE;
    }
    else
    {
        StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
    }
    StreamInWrapper(hWndEditGoodFor, rgwch, TRUE);
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddUsagesToEditBox(HWND hWndEditGoodFor, CERT_VIEW_HELPER *pviewhelp)
{
    BOOL                fIndividualCodeSigning = FALSE;
    BOOL                fCommercialCodeSigning = FALSE;
    BOOL                fVirusString = FALSE;
    BOOL                fTimeStamping = FALSE;
    BOOL                fSGC = FALSE;
    BOOL                fIPSec = FALSE;
    int                 goodForIndex = 0;
    DWORD               i;
    BOOL                *rgfOIDProcessed;
    PARAFORMAT          paraFormat;
    PCCRYPT_OID_INFO    pOIDInfo;
    BOOL                fFirst = TRUE;

    if (NULL == (rgfOIDProcessed = (BOOL *) malloc(pviewhelp->cUsages * sizeof(BOOL))))
    {
        return;
    }

    for (i=0; i<pviewhelp->cUsages; i++)
    {
        rgfOIDProcessed[i] = FALSE;
    }

    //
    // clear the window
    //
    SetWindowTextU(hWndEditGoodFor, NULL);

    //
    // go through all the oids that this certificate was validated for and
    // add usage bullets to the list boxes, OR, if it was not validated for any
    // usages then put up the nousages string
    //
    for (i=0; i<pviewhelp->cUsages; i++)
    {
        if ((strcmp(szOID_SERVER_GATED_CRYPTO, pviewhelp->rgUsages[i]) == 0) ||
            (strcmp(szOID_SGC_NETSCAPE, pviewhelp->rgUsages[i]) == 0))
        {
            if (!fSGC)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_SGC, &fFirst);
                fSGC = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
        else if ((strcmp(szOID_PKIX_KP_TIMESTAMP_SIGNING, pviewhelp->rgUsages[i]) == 0) ||
                 (strcmp(szOID_KP_TIME_STAMP_SIGNING, pviewhelp->rgUsages[i]) == 0))
        {
            if (!fTimeStamping)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_TIMESTAMP, &fFirst);
                fTimeStamping = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_KP_CTL_USAGE_SIGNING, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CTLSIGN, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp("1.3.6.1.4.1.311.10.3.4", pviewhelp->rgUsages[i]) == 0) // EFS
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EFS, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_SERVER_AUTH, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_SERVERAUTH, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_CLIENT_AUTH, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CLIENTAUTH, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_EMAIL_PROTECTION, pviewhelp->rgUsages[i]) == 0)
        {
            //LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL3, &fFirst);
            //LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL2, &fFirst);
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL1, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if ((strcmp(szOID_PKIX_KP_CODE_SIGNING, pviewhelp->rgUsages[i]) == 0) ||
                 (strcmp("1.3.6.1.4.1.311.2.1.22", pviewhelp->rgUsages[i]) == 0))
        {
            if (!fCommercialCodeSigning)
            {
                if (strcmp(szOID_PKIX_KP_CODE_SIGNING, pviewhelp->rgUsages[i]) == 0)
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_COMMERCIAL_PKIX, &fFirst);
                }
                else
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_COMMERCIAL, &fFirst);
                }

                if (!fIndividualCodeSigning)
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_GENERAL, &fFirst);
                }
                fCommercialCodeSigning = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp("1.3.6.1.4.1.311.2.1.21", pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_INDIVIDUAL, &fFirst);

            if (!fCommercialCodeSigning)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_GENERAL, &fFirst);
            }
            fIndividualCodeSigning = TRUE;
            rgfOIDProcessed[i] = TRUE;
        }
        else if ((strcmp(szOID_PKIX_KP_IPSEC_END_SYSTEM, pviewhelp->rgUsages[i]) == 0)  ||
                 (strcmp(szOID_PKIX_KP_IPSEC_TUNNEL, pviewhelp->rgUsages[i]) == 0)      ||
                 (strcmp(szOID_PKIX_KP_IPSEC_USER, pviewhelp->rgUsages[i]) == 0)        ||
                 (strcmp("1.3.6.1.5.5.8.2.2", pviewhelp->rgUsages[i]) == 0))
        {
            if (!fIPSec)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_IPSEC, &fFirst);
                fIPSec = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
    }


    //
    // re walk the oids to add the ones that were not processed,
    // if they weren't processed that means we don't have a pre-defined
    // string for them, so just add the oid
    //
    for (i=0; i<pviewhelp->cUsages; i++)
    {
        if (!rgfOIDProcessed[i])
        {
            pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pviewhelp->rgUsages[i], 0);

            if (pOIDInfo != NULL)
            {
                if (fFirst)
                {
                    fFirst = FALSE;
                }
                else
                {
                    StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
                }
                StreamInWrapper(hWndEditGoodFor, (void *) pOIDInfo->pwszName, TRUE);
            }
            else
            {
                if (fFirst)
                {
                    fFirst = FALSE;
                }
                else
                {
                    StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
                }
                StreamInWrapper(hWndEditGoodFor, pviewhelp->rgUsages[i], FALSE);
            }
        }
    }

    free(rgfOIDProcessed);

    memset(&paraFormat, 0, sizeof(paraFormat));
    paraFormat.cbSize= sizeof(paraFormat);
    paraFormat.dwMask = PFM_NUMBERING;
    paraFormat.wNumbering = PFN_BULLET;
    SendMessage(hWndEditGoodFor, EM_SETSEL, 0, -1);
    SendMessage(hWndEditGoodFor, EM_SETPARAFORMAT, 0, (LPARAM) &paraFormat);
    SendMessage(hWndEditGoodFor, EM_SETSEL, -1, 0);
    SendMessage(hWndEditGoodFor, EM_HIDESELECTION, (WPARAM) TRUE, (LPARAM) FALSE);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline)
{
    int        index;
    int        line;
    int        charwidth;
    int        maxwidth = 0;
    CHAR       szMaxBuffer[1024];
    WCHAR      wsz[1024];
    TEXTRANGEA tr;
    SIZE       size;

    tr.lpstrText = szMaxBuffer;

    for ( line = 0; line < cline; line++ )
    {
        index = (int)SendMessageA(hwndEdit, EM_LINEINDEX, (WPARAM)line, 0);
        charwidth = (int)SendMessageA(hwndEdit, EM_LINELENGTH, (WPARAM)index, 0);

        tr.chrg.cpMin = index;
        tr.chrg.cpMax = index + charwidth;
        SendMessageA(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&tr);

        wsz[0] = NULL;

        MultiByteToWideChar(0, 0, (const char *)tr.lpstrText, -1, &wsz[0], 1024);

        if (wsz[0])
        {
            GetTextExtentPoint32W(hdc, &wsz[0], charwidth, &size);

            if ( (size.cx+2) > maxwidth )
            {
                maxwidth = size.cx+2;
            }
        }
    }

    return( maxwidth );
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void ResizeEditControl(HWND  hwndDlg, HWND  hwnd, BOOL fResizeHeight, BOOL fResizeWidth, RECT originalRect)
{
    RECT        rect;
    TEXTMETRIC  tm;
    HDC         hdc;
    int         cline;
    int         currentHeight;
    int         newHeight;
    int         newWidth;
    int         totalRowHeight;
    POINT       pointInFirstRow;
    POINT       pointInSecondRow;
    int         secondLineCharIndex;
    int         i;

    SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

    hdc = GetDC(hwnd);
    if ((hdc == NULL) && fResizeWidth)
    {
        return;
    }

    //
    // HACK ALERT, believe it or not there is no way to get the height of the current
    // font in the edit control, so get the position a character in the first row and the position
    // of a character in the second row, and do the subtraction to get the
    // height of the font
    //
    SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInFirstRow, (LPARAM) 0);

    //
    // HACK ON TOP OF HACK ALERT,
    // since there may not be a second row in the edit box, keep reducing the width
    // by half until the first row falls over into the second row, then get the position
    // of the first char in the second row and finally reset the edit box size back to
    // it's original size
    //
    secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
    if (secondLineCharIndex == -1)
    {
        for (i=0; i<20; i++)
        {
            GetWindowRect(hwnd, &rect);
            SetWindowPos(   hwnd,
                            NULL,
                            0,
                            0,
                            (rect.right-rect.left)/2,
                            rect.bottom-rect.top,
                            SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
            secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
            if (secondLineCharIndex != -1)
            {
                break;
            }
        }

        if (secondLineCharIndex == -1)
        {
            // if we failed after twenty tries just reset the control to its original size
            // and get the heck outa here!!
            SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            if (hdc != NULL)
            {
                ReleaseDC(hwnd, hdc);
            }

            return;
        }

        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);

        SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
    else
    {
        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);
    }

    //
    // if we need to resize the height then do it
    //
    if (fResizeHeight)
    {
        //
        // Calculate the new height needed
        //
        totalRowHeight = pointInSecondRow.y - pointInFirstRow.y;
        cline = (int)SendMessageA(hwnd, EM_GETLINECOUNT, 0, 0);
        currentHeight = originalRect.bottom - originalRect.top;

        // if the height required is greater than the previous height
        // then resize to an integral line height less than current height
        if ((cline * totalRowHeight) > currentHeight)
        {
            newHeight = (currentHeight / totalRowHeight) * totalRowHeight;
        }
        else
        {
            newHeight = cline * totalRowHeight;
        }
    }
    else
    {
        newHeight = rect.bottom - rect.top;
    }

    if (fResizeWidth)
    {
        newWidth = GetEditControlMaxLineWidth(hwnd, hdc, cline);
        if (newWidth > (originalRect.right - originalRect.left))
        {
            newWidth = originalRect.right - originalRect.left;
        }
    }
    else
    {
        newWidth = originalRect.right - originalRect.left;
    }

    SetWindowPos(hwnd, NULL, 0, 0, newWidth, newHeight, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    
    if (hdc != NULL)
    {
        ReleaseDC(hwnd, hdc);
    }
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL CertificateHasPrivateKey(PCCERT_CONTEXT pccert)
{
    DWORD cb = 0;

    return (CertGetCertificateContextProperty(pccert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb));
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    ENLINK *            penlink;
    PROPSHEETPAGE *     ps;
    CERT_VIEW_HELPER *  pviewhelp;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    DWORD               cb;
    HWND                hWndListView;
    HWND                hwnd;
    HWND                hWndEdit;
    LPNMLISTVIEW        pnmv;
    LPSTR               pszSubjectURL=NULL;
    LPSTR               pszIssuerURL=NULL;
    CHARFORMAT          chFormat;
    HWND                hWndIssuerEdit;
    HWND                hWndSubjectEdit;
    HWND                hWndGoodForEdit;
    PLINK_SUBCLASS_DATA plsd;
    HANDLE              hIcon;
    RECT                tempRect;
    DWORD               dwCertAccessProperty;
    int                 buttonPos = 1;
    LPWSTR              pwszDateString;
    WCHAR               szFindText[CRYPTUI_MAX_STRING_SIZE];
    FINDTEXTEX          findText;
    WCHAR               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    BOOL                fPrivateKeyExists;
    LPHELPINFO          lpHelpInfo;
    HELPINFO            helpInfo;

    LPWSTR              pwszIssuerNameString = NULL;
    LPWSTR              pwszSubjectNameString = NULL;

    
    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndGeneralPage = hwndDlg;

        //
        // check to see if this certificate has a private key with it
        //
        if (CertificateHasPrivateKey(pccert))
        {
            LoadStringU(HinstDll, IDS_PRIVATE_KEY_EXISTS, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT, rgwch);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(plsd));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_CERT_PRIVATE_KEY_EDIT;

                LoadStringU(HinstDll, IDS_PRIVATE_KEY_EXISTS_TOOLTIP, rgwch, ARRAYSIZE(rgwch));
                plsd->pszURL = CertUIMkMBStr(rgwch);
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = TRUE;

                CertSubclassEditControlForLink(hwndDlg, GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), plsd);
            }
            fPrivateKeyExists = TRUE;
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), SW_HIDE);
            fPrivateKeyExists = FALSE;
        }

        //
        // Initialize the CCertificateBmp
        //
        pviewhelp->pCCertBmp->SetWindow(hwndDlg);
        pviewhelp->pCCertBmp->SetHinst(HinstDll);
        pviewhelp->pCCertBmp->SetRevoked(pviewhelp->cUsages == 0);
        pviewhelp->pCCertBmp->SetCertContext(pccert, fPrivateKeyExists);
        pviewhelp->pCCertBmp->DoSubclass();

        //
        // deal with button states and placements
        //
        if (!(CRYPTUI_ACCEPT_DECLINE_STYLE & pviewhelp->pcvp->dwFlags))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON), SW_HIDE);

            //
            // check to see if there is a disclaimer in the cert
            //
            // DSIE: Bug 364742
            if (!IsOKToDisplayCPS(pccert, pviewhelp->dwChainError))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), FALSE);
                pviewhelp->fCPSDisplayed = FALSE;
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), TRUE);
                pviewhelp->fCPSDisplayed = TRUE;
            }

            //
            // for the "Install Certificate" button, get the CERT_ACCESS_STATE_PROP_ID
            // and check it
            //
            cb = sizeof(DWORD);
            CertGetCertificateContextProperty(
                    pccert,
                    CERT_ACCESS_STATE_PROP_ID,
                    (void *) &dwCertAccessProperty,
                    &cb);

            if (pviewhelp->pcvp->dwFlags & CRYPTUI_ENABLE_ADDTOSTORE)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_SHOW);
            }
            else if(pviewhelp->pcvp->dwFlags & CRYPTUI_DISABLE_ADDTOSTORE)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_HIDE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON),
                    (dwCertAccessProperty & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG) ? FALSE : TRUE);
                ShowWindow(
                    GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON),
                    (dwCertAccessProperty & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG) ? SW_HIDE : SW_SHOW);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_HIDE);

            pviewhelp->fAccept = FALSE;
        }

        hWndGoodForEdit = GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT);

        //
        // set the original rect fields of the usage edits in the viewhelp struct
        // so that they can be used any time a resize is needed
        //
        GetWindowRect(hWndGoodForEdit, &pviewhelp->goodForOriginalRect);

        //
        // fill in the "This certificate is intended to" bullet list
        //

        AddUsagesToEditBox(
                hWndGoodForEdit,
                pviewhelp);

        //
        // resize the edit controls so that they are an integral number of lines
        //
        ResizeEditControl(hwndDlg, hWndGoodForEdit, TRUE, FALSE, pviewhelp->goodForOriginalRect);

        //
        // do the arrow subclass on the usage edit boxes
        //
       // CertSubclassEditControlForArrowCursor(hWndGoodForEdit);

        //
        // if there are no valid usages or we couldn't validate because there wasn't
        // enough information, then hide the usage edit controls so we can
        // display more text, and tell the CCertBmp
        //
        if (pviewhelp->pwszErrorString != NULL)
        {
            EnableWindow(hWndGoodForEdit, FALSE);
            ShowWindow(hWndGoodForEdit, SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
            pviewhelp->pCCertBmp->SetChainError(pviewhelp->dwChainError, IsTrueErrorString(pviewhelp),
                                                (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT, pviewhelp->pwszErrorString);
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_HIDE);
            if (pviewhelp->fCPSDisplayed)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_SHOW);
            }
            else
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
            }
        }

        hWndIssuerEdit = GetDlgItem(hwndDlg, IDC_ISSUER_EDIT);
        hWndSubjectEdit = GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT);

#if (0) //DISE: Bug 383855
        //
        // set the subject and issuer name
        //
        CertGetNameStringW(
                pccert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                rgwch,
                ARRAYSIZE(rgwch));

        CryptUISetRicheditTextW(hwndDlg, IDC_SUBJECT_EDIT, rgwch);
#else
        pwszSubjectNameString = GetDisplayNameString(pccert, 0);

        CryptUISetRicheditTextW(hwndDlg, IDC_SUBJECT_EDIT, pwszSubjectNameString);

        if (NULL != pwszSubjectNameString)
        {
            free(pwszSubjectNameString);
        }
#endif

#if (0) //DISE: Bug 383855
        CertGetNameStringW(
                pccert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                rgwch,
                ARRAYSIZE(rgwch));

        CryptUISetRicheditTextW(hwndDlg, IDC_ISSUER_EDIT, rgwch);
#else
        pwszIssuerNameString = GetDisplayNameString(pccert, CERT_NAME_ISSUER_FLAG);

        CryptUISetRicheditTextW(hwndDlg, IDC_ISSUER_EDIT, pwszIssuerNameString);

        if (NULL != pwszIssuerNameString)
        {
            free(pwszIssuerNameString);
        }
#endif

        //
        // resize the name edit controls so that they just encapsulate the names
        //
        GetWindowRect(hWndSubjectEdit, &tempRect);
        ResizeEditControl(hwndDlg, hWndSubjectEdit, TRUE, FALSE, tempRect);
        GetWindowRect(hWndIssuerEdit, &tempRect);
        ResizeEditControl(hwndDlg, hWndIssuerEdit, TRUE, FALSE, tempRect);

        //
        // check if this should look like a link or not, if so, then set color and underline
        //
        // DSIE: Bug 367720.
        if (AllocAndGetSubjectURL(&pszSubjectURL, pccert) &&
            IsOKToFormatAsLinkA(pszSubjectURL, pviewhelp->dwChainError))
        {
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINE | CFM_COLOR;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.crTextColor = RGB(0,0,255);
            SendMessageA(hWndSubjectEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(plsd));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_SUBJECT_EDIT;
                plsd->pszURL = pszSubjectURL;
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = FALSE;

                CertSubclassEditControlForLink(hwndDlg, hWndSubjectEdit, plsd);

                pviewhelp->fSubjectDisplayedAsLink = TRUE;
            }
            else
            {
                free(pszSubjectURL);
                
                CertSubclassEditControlForArrowCursor(hWndSubjectEdit);
            }
        }
        else
        {
            if (pszSubjectURL)
            {
                free(pszSubjectURL);
            }

            CertSubclassEditControlForArrowCursor(hWndSubjectEdit);
        }

        //
        // check if this should look like a link or not, if so, then set color and underline
        //
        // DSIE: Bug 367720.
        if (AllocAndGetIssuerURL(&pszIssuerURL, pccert) &&
            IsOKToFormatAsLinkA(pszIssuerURL, pviewhelp->dwChainError))
        {
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINE | CFM_COLOR;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.crTextColor = RGB(0,0,255);
            SendMessageA(hWndIssuerEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(plsd));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_ISSUER_EDIT;
                plsd->pszURL = pszIssuerURL;
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = FALSE;

                CertSubclassEditControlForLink(hwndDlg, hWndIssuerEdit, plsd);

                pviewhelp->fIssuerDisplayedAsLink = TRUE;
            }
            else
            {
                free(pszIssuerURL);
            
                CertSubclassEditControlForArrowCursor(hWndIssuerEdit);
            }
        }
        else
        {
            if (pszIssuerURL)
            {
                free(pszIssuerURL);
            }
            
            CertSubclassEditControlForArrowCursor(hWndIssuerEdit);
        }

        //
        // set the text in all the header edit boxes
        //
        LoadStringU(HinstDll, IDS_CERTIFICATEINFORMATION, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_FORUSEWITH, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUEDTO, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUEDBY, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUER_WARNING, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT, rgwch);

        //
        // set the font for all the header edit boxes
        //
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

        //
        // subclass the header edit controls so they display an arrow cursor in their window
        //
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT));

        //
        // set the validty string
        //
        if (FormatValidityString(&pwszDateString, pccert, GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT)))
        {
            //
            // insert the string and the the font style/color
            //
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT, pwszDateString);
            free(pwszDateString);

            //
            // set the header parts of the validity string to bold
            //
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;
            chFormat.dwEffects = CFE_BOLD;

            findText.chrg.cpMin = findText.chrgText.cpMin = 0;
            findText.chrg.cpMax = findText.chrgText.cpMax = -1;

            LoadStringU(HinstDll, IDS_VALIDFROM, szFindText, ARRAYSIZE(szFindText));
            findText.lpstrText = CertUIMkMBStr(szFindText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_FINDTEXTEX,
                        FR_DOWN,
                        (LPARAM) &findText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        findText.chrgText.cpMin,
                        (LPARAM) findText.chrgText.cpMax);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETCHARFORMAT,
                        SCF_SELECTION,
                        (LPARAM) &chFormat);
            free((void *)findText.lpstrText);

            LoadStringU(HinstDll, IDS_VALIDTO, szFindText, ARRAYSIZE(szFindText));
            findText.lpstrText = CertUIMkMBStr(szFindText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_FINDTEXTEX,
                        FR_DOWN,
                        (LPARAM) &findText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        findText.chrgText.cpMin,
                        (LPARAM) findText.chrgText.cpMax);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETCHARFORMAT,
                        SCF_SELECTION,
                        (LPARAM) &chFormat);
            free((void *)findText.lpstrText);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        -1,
                        0);
        }
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT));

        return TRUE;

    case WM_MY_REINITIALIZE:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            hWndGoodForEdit = GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT);

            ShowWindow(hWndGoodForEdit, SW_HIDE);

            //
            // re-add the usages
            //
            AddUsagesToEditBox(
                hWndGoodForEdit,
                pviewhelp);

            //
            // resize the edit controls so that they are an integral number of lines
            //
            ResizeEditControl(hwndDlg, hWndGoodForEdit, TRUE, FALSE, pviewhelp->goodForOriginalRect);

            //
            // if there are no valid usages or we couldn't validate because there wasn't
            // enough information, then keep the usage edit windows hidden so we can
            // display more text,
            //
            if (pviewhelp->pwszErrorString == NULL)
            {
                EnableWindow(hWndGoodForEdit, TRUE);
                ShowWindow(hWndGoodForEdit, SW_SHOW);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_SHOW);
                if (pviewhelp->fCPSDisplayed)
                {
                    ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_SHOW);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), FALSE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
                }
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_HIDE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_HIDE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_SHOW);
            }

            //
            // if there is an untrusted root error, and we are ignoring untrusted root,
            // then set the error to 0
            //
            if (((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) || (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT)) &&
                (pviewhelp->fIgnoreUntrustedRoot))
            {
                pviewhelp->pCCertBmp->SetChainError(0, TRUE, (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            }
            else
            {
                pviewhelp->pCCertBmp->SetChainError(pviewhelp->dwChainError,  IsTrueErrorString(pviewhelp),
                                                    (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            }
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT, pviewhelp->pwszErrorString);

            return TRUE;

    case WM_NOTIFY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (((NMHDR FAR *) lParam)->code) {
        case EN_LINK:
            penlink = (ENLINK *) lParam;
            if (penlink->msg == WM_LBUTTONUP) {
                break;
            }
            break;

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //nHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //nHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //     pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }

            return TRUE;

        case NM_DBLCLK:

            return TRUE;

        }
        break;

    case WM_COMMAND:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95)
            {
                //nHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else
            {
                //nHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //     pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case IDC_ACCEPT_BUTTON:
            pviewhelp->fAccept = TRUE;
            SendMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, PSBTN_OK, (LPARAM) 0);
            break;

        case IDC_DECLINE_BUTTON:
            pviewhelp->fAccept = FALSE;
            SendMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, PSBTN_OK, (LPARAM) 0);
            break;

        case IDC_DISCLAIMER_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                pccert = pviewhelp->pcvp->pCertContext;
                DisplayCPS(hwndDlg, pccert, pviewhelp->dwChainError, pviewhelp->fNoCOM);
                return TRUE;
            }
            break;

        case IDC_ADD_TO_STORE_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_WIZ_IMPORT_SRC_INFO importInfo;

                memset(&importInfo, 0, sizeof(importInfo));
                importInfo.dwSize = sizeof(importInfo);
                importInfo.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
                importInfo.pCertContext = pviewhelp->pcvp->pCertContext;

                CryptUIWizImport(0, hwndDlg, NULL, &importInfo, NULL);
                return TRUE;
            }
            break;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // if DWL_USER is NULL then we weren't initialized, so don't cleanup
        //
        if (pviewhelp == NULL)
        {
            return FALSE;
        }

        pccert = pviewhelp->pcvp->pCertContext;

        SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT), GWLP_USERDATA));

        //
        // cleanup the private key edit box subclass
        //
        if (CertificateHasPrivateKey(pccert))
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }

        //
        // use this call to AllocAndGetIssuerURL to see if the issuer has an active link, and then
        // do the proper unsubclass and/or free
        //
        if (pviewhelp->fIssuerDisplayedAsLink)
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }
        else
        {
            SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_ISSUER_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_USERDATA));
        }

        //
        // use this call to AllocAndGetSubjectURL to see if the subject has an active link, and then
        // do the proper unsubclass and/or free
        //
        if (pviewhelp->fSubjectDisplayedAsLink)
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }
        else
        {
            SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_USERDATA));
        }

        /*DeleteObject((HGDIOBJ)SendMessage(GetDlgItem(hwndDlg, IDC_INFO_BUTTON),
                                    BM_GETIMAGE,
                                    (WPARAM) IMAGE_ICON,
                                    (LPARAM) 0));*/

        return FALSE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        lpHelpInfo = (LPHELPINFO)lParam;
        
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, lpHelpInfo->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ISSUER_EDIT))                      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON))              &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON))                &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON))                    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON))                   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER))      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT))            &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, (WPARAM) hwnd, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\demand.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.h
//
//--------------------------------------------------------------------------

/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __DEMAND_H
#define __DEMAND_H

#ifndef MAC
//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE MAKING A MISTAKE.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           if (!DemandLoad##dll()) return err;          \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           if (!DemandLoad##dll()) return;              \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;
#if 0
// my 1st attempt
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
    BOOL DemandLoad##fnsuffix()                     \
    {                                               \
        BOOL                fRet = TRUE;            \
                                                    \
        Assert(fInit);                              \
        EnterCriticalSection(&cs);                  \
                                                    \
        if (0 == handle)                            \
            {                                       \
            handle = LoadLibrary(#dllname);         \
                                                    \
            if (0 == handle)                        \
                fRet = FALSE;                       \
            else                                    \
                {                                   \
                procaddrlist                        \
                }                                   \
            }                                       \
                                                    \
        LeaveCriticalSection(&cs);                  \
        return fRet;                                \
    }
#endif

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#if 0
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
        BOOL DemandLoad##fnsuffix(void);
#endif

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv,
     DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CryptFormatObject,
    (DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType,
     void * pFormatStruct, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, void * pbFormat, DWORD * pcbFormat),
    (dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct,
     lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat),
    FALSE, Crypt32)
#define CryptFormatObject VAR_CryptFormatObject

LOADER_FUNCTION( DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrW VAR_CertNameToStrW

LOADER_FUNCTION( DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrA VAR_CertNameToStrA

LOADER_FUNCTION( BOOL, CertStrToNameA,
    (DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved,
     BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved,
     pbEncoded, pcbEncoded, ppszError),
     FALSE, Crypt32)
#define CertStrToNameA VAR_CertStrToNameA

LOADER_FUNCTION( DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz),
    0, Crypt32)
#define CertRDNValueToStrW VAR_CertRDNValueToStrW

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    FALSE, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, CryptUnregisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID),
    (dwEncodingType, pszFuncName, pszOID),
    FALSE, Crypt32)
#define CryptUnregisterOIDFunction VAR_CryptUnregisterOIDFunction

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void * pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    FALSE, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifyCTLUsage,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCTL_USAGE pSubjectUsage, DWORD dwFlags,
     PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
     PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus),
    (dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags,
     pVerifyUsagePara, pVerifyUsageStatus),
    0, Crypt32)
#define CertVerifyCTLUsage VAR_CertVerifyCTLUsage

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext,
     PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertFreeCTLContext,
    (PCCTL_CONTEXT pCtlContext),
    (pCtlContext),
    FALSE, Crypt32)
#define CertFreeCTLContext VAR_CertFreeCTLContext

LOADER_FUNCTION( BOOL, CertAddEncodedCTLToStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded,
     DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded,
     dwAddDisposition, ppCtlContext),
    FALSE, Crypt32)
#define CertAddEncodedCTLToStore VAR_CertAddEncodedCTLToStore

LOADER_FUNCTION( BOOL, CryptMsgEncodeAndSignCTL,
    (DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo,
     DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptMsgEncodeAndSignCTL VAR_CryptMsgEncodeAndSignCTL

LOADER_FUNCTION( PCCTL_CONTEXT, CertFindCTLInStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags,
     DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, dwFindFlags,
     dwFindType, pvFindPara, pPrevCtlContext),
    NULL, Crypt32)
#define CertFindCTLInStore VAR_CertFindCTLInStore

LOADER_FUNCTION( PCCTL_CONTEXT, CryptSignAndEncodeCertificate,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     LPCSTR lpszStructType, const void *pvStructInfo,
     PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
     const void *pvHashAuxInfo, PBYTE pbEncoded, DWORD *pcbEncoded),
    (hCryptProv, dwKeySpec, dwCertEncodingType, lpszStructType,
     pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded,
     pcbEncoded),
    NULL, Crypt32)
#define CryptSignAndEncodeCertificate VAR_CryptSignAndEncodeCertificate

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo,
     BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded,pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptExportPublicKeyInfo,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo),
    (hCryptProv, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo),
    FALSE, Crypt32)
#define CryptExportPublicKeyInfo VAR_CryptExportPublicKeyInfo

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    +1, Crypt32)                // Return AFTER by default
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( PCTL_ENTRY, CertFindSubjectInCTL,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCCTL_CONTEXT pCtlContext, DWORD dwFlags),
    (dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags),
    NULL, Crypt32)
#define CertFindSubjectInCTL VAR_CertFindSubjectInCTL

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#if 0
LOADER_FUNCTION( BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags),
    (hProv, dwParam, pbData, pdwDataLen, dwFlags),
    FALSE, AdvApi32)
#define CryptGetProvParam VAR_CryptGetProvParam

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptGenKey,
    (HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey),
    (hProv, Algid, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptGenKey VAR_CryptGenKey

LOADER_FUNCTION( BOOL, CryptDestroyKey,
    (HCRYPTKEY hKey),
    (hKey),
    FALSE, AdvApi32)
#define CryptDestroyKey VAR_CryptDestroyKey
#endif // 0


#ifndef WIN16

/////////////////////////////////////
// USER32.DLL

BOOL DemandLoadUser32();

LOADER_FUNCTION( LRESULT, SendDlgItemMessageW,
    (HWND hwnd, int idCtl, UINT msg, WPARAM wparam, LPARAM lparam),
    (hwnd, idCtl, msg, wparam, lparam),
    -1, User32)
#define SendDlgItemMessageW VAR_SendDlgItemMessageW

LOADER_FUNCTION( BOOL, SetDlgItemTextW,
    (HWND hwnd, int idCtl, LPCWSTR psz),
    (hwnd, idCtl, psz),
    FALSE, User32)
#define SetDlgItemTextW VAR_SetDlgItemTextW

LOADER_FUNCTION( UINT, GetDlgItemTextW,
    (HWND hwnd, int idCtl, LPWSTR psz, int nMax),
    (hwnd, idCtl, psz, nMax),
    FALSE, User32)
#define GetDlgItemTextW VAR_GetDlgItemTextW

LOADER_FUNCTION( int, LoadStringW,
    (HINSTANCE hinst, UINT idStr, LPWSTR rgwch, int cwch),
    (hinst, idStr, rgwch, cwch),
    0, User32)
#define LoadStringW VAR_LoadStringW

LOADER_FUNCTION( DWORD, FormatMessageW,
    (DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
     DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize, va_list * args),
    (dwFlags, pbSource, dwMessageId, dwLangId, lpBuffer, nSize, args),
    0, User32)
#define FormatMessageW VAR_FormatMessageW

LOADER_FUNCTION( BOOL, WinHelpW,
    (HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData),
    (hWndMain, szHelp, uCommand, dwData),
    FALSE, User32)
#define WinHelpW VAR_WinHelpW

#endif // !WIN16

#else   // MAC
#define SendDlgItemMessageW MySendDlgItemMessageW
#define SetDlgItemTextW     MySetDlgItemTextW
#define GetDlgItemTextW     MyGetDlgItemTextW
#define LoadStringW         MyLoadStringW
#define FormatMessageW      MyFormatMessageW
#define WinHelpW            MyWinHelpW
#define SendMessageW        SendMessageA
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // !MAC
#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\cvhrchy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvhrchy.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//  Fix a Win95 problem
/*#undef TVM_SETITEM
#define TVM_SETITEM TVM_SETITEMA
#undef TVM_GETITEM
#define TVM_GETITEM TVM_GETITEMA*/

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

#define MY_TREE_IMAGE_STATE_VALIDCERT           0
#define MY_TREE_IMAGE_STATE_INVALIDCERT         1
#define MY_TREE_IMAGE_STATE_VALIDCTL            2
#define MY_TREE_IMAGE_STATE_INVALIDCTL          3
#define MY_TREE_IMAGE_STATE_EXCLAMATION_CERT    4

static const HELPMAP helpmap[] = {
    {IDC_TRUST_TREE,        IDH_CERTVIEW_HIERARCHY_TRUST_TREE},
    {IDC_TRUST_VIEW,        IDH_CERTVIEW_HIERARCHY_SHOW_DETAILS_BUTTON},
    {IDC_HIERARCHY_EDIT,    IDH_CERTVIEW_HIERARCHY_ERROR_EDIT}
};

typedef struct {
    PCCERT_CONTEXT  pCert;
    PCCTL_CONTEXT   pCTL;
    LPWSTR          pwszErrorString;
} TREEVIEW_HELPER, *PTREEVIEW_HELPER;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PTREEVIEW_HELPER MakeHelperStruct(void *pVoid, LPWSTR pwszErrorString, BOOL fCTL)
{
    PTREEVIEW_HELPER pHelper;

    if (NULL == (pHelper = (PTREEVIEW_HELPER) malloc(sizeof(TREEVIEW_HELPER))))
    {
        return NULL;
    }
    memset(pHelper, 0, sizeof(TREEVIEW_HELPER));

    if (fCTL)
    {
        pHelper->pCTL = (PCCTL_CONTEXT) pVoid;
    }
    else
    {
        pHelper->pCert = (PCCERT_CONTEXT) pVoid;
    }
    pHelper->pwszErrorString = pwszErrorString;

    return(pHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeHelperStruct(PTREEVIEW_HELPER pHelper)
{
    free(pHelper->pwszErrorString);
    free(pHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL GetTreeCTLErrorString(
                    DWORD   dwError,
                    LPWSTR  *ppwszErrorString)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    BOOL    fRet = FALSE;

    *ppwszErrorString = NULL;

    if (dwError == TRUST_E_CERT_SIGNATURE)
    {
        LoadStringU(HinstDll, IDS_SIGNATURE_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }
    else if (dwError == CERT_E_EXPIRED)
    {
        LoadStringU(HinstDll, IDS_EXPIRED_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }
    else if (dwError == CERT_E_WRONG_USAGE)
    {
        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }

    //
    // if there wasn't an error string set, then hand back the "CTL is OK" string
    //
    if (*ppwszErrorString == NULL)
    {
        LoadStringU(HinstDll, IDS_CTLOK, szErrorString, ARRAYSIZE(szErrorString));
        *ppwszErrorString = AllocAndCopyWStr(szErrorString);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int GetErrorIcon(PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    int iRet;

    switch (pCryptProviderCert->dwError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
    case CERT_E_REVOCATION_FAILURE:
    case CERT_E_INVALID_NAME:

        iRet =  MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
        break;

    default:

        if ((pCryptProviderCert->dwError == 0) && CertHasEmptyEKUProp(pCryptProviderCert->pCert))
        {
            iRet = MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
        }
        else
        {
            iRet = MY_TREE_IMAGE_STATE_INVALIDCERT;
        }
        break;
    }

    return iRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL GetTreeCertErrorStringAndImage(
                    PCRYPT_PROVIDER_CERT    pCryptProviderCert,
                    LPWSTR                  *ppwszErrorString,
                    int                     *piImage,
                    BOOL                    fWarnUntrustedRoot,
                    BOOL                    fRootInRemoteStore,
                    BOOL                    fLeafCert,
                    BOOL                    fAllUsagesFailed)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    BOOL    fRet = FALSE;
    BOOL    fAllUsagesFailedAndLeafCert = fAllUsagesFailed && fLeafCert;

    *ppwszErrorString = NULL;

    //
    // if this is a self signed cert
    //
    if ((pCryptProviderCert->fSelfSigned))
    {
        //
        // if it is in a trust list, AND there is no error, then it is OK
        //
        if ((pCryptProviderCert->pCtlContext != NULL) && (pCryptProviderCert->dwError == 0) && !CertHasEmptyEKUProp(pCryptProviderCert->pCert))
        {
            *ppwszErrorString = NULL;
        }
        //
        // else, if is not marked as a trusted root, and we in fWarnUntrustedRoot mode and
        // the root cert is in the root store of the remote machine, then give warning
        //
        else if (((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT) ||
                        (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))  &&
                 fWarnUntrustedRoot                                                 &&
                 fRootInRemoteStore)
        {
            //
            // this is a special case where there is an error, but it is the untrusted
            // root error and we were told to by the caller to just warn the user
            //
            LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT, szErrorString, ARRAYSIZE(szErrorString));
            if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
            {
                fRet = TRUE;
                *piImage = MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
            }
        }
        //
        // else, if it is not marked as a trusted root it is an untrusted root error
        //
        else if ((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT)
                    || (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))
        {
            LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR, szErrorString, ARRAYSIZE(szErrorString));
            if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
            {
                fRet = TRUE;
                *piImage = MY_TREE_IMAGE_STATE_INVALIDCERT;
            }
        }
        else if (GetCertErrorString(ppwszErrorString, pCryptProviderCert))
        {
            fRet = TRUE;
            *piImage = GetErrorIcon(pCryptProviderCert);
        }
    }
    else
    {
        if (GetCertErrorString(ppwszErrorString, pCryptProviderCert))
        {
            fRet = TRUE;
            *piImage = GetErrorIcon(pCryptProviderCert);
        }
    }

    //
    // if there wasn't an error string set, then hand back the "cert is OK" string
    //
    if (*ppwszErrorString == NULL)
    {
        LoadStringU(HinstDll, IDS_CERTIFICATEOK_TREE, szErrorString, ARRAYSIZE(szErrorString));
        *ppwszErrorString = AllocAndCopyWStr(szErrorString);
        *piImage = MY_TREE_IMAGE_STATE_VALIDCERT;
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DeleteChainViewItems(HWND hwndDlg,  PCERT_VIEW_HELPER pviewhelp)
{
    HTREEITEM   hItem;
    TV_ITEM     tvi;
    HWND        hWndTreeView = GetDlgItem(hwndDlg, IDC_TRUST_TREE);

    hItem = TreeView_GetNextItem(
                    hWndTreeView,
                    NULL,
                    TVGN_ROOT);

    tvi.mask = TVIF_HANDLE | TVIF_PARAM;

    while (hItem != NULL)
    {
        tvi.hItem = hItem;
        TreeView_GetItem(hWndTreeView, &tvi);
        FreeHelperStruct((PTREEVIEW_HELPER) tvi.lParam);

        hItem =  TreeView_GetNextItem(
                    hWndTreeView,
                    hItem,
                    TVGN_CHILD);
    }

    pviewhelp->fDeletingChain = TRUE;
    TreeView_DeleteAllItems(hWndTreeView);
    pviewhelp->fDeletingChain = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void PopulateChainView(HWND hwndDlg, PCERT_VIEW_HELPER pviewhelp)
{
    HTREEITEM           hItem;
    int                 i;
    TV_ITEM             tvi;
    TVINSERTSTRUCTW     tvins;
    LPSTR               psz;
    LPWSTR              pwszErrorString;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];

    //
    // if there is an old tree in the view then clean it up
    //
    DeleteChainViewItems(hwndDlg, pviewhelp);

    //
    //  loop for each cert and add it to the chain view
    //
    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    hItem = TVI_ROOT;
    pviewhelp->fAddingToChain = TRUE;

    for (i=pviewhelp->cpCryptProviderCerts-1; i>= 0; i--) {

        tvins.hParent = hItem;
        tvins.hInsertAfter = TVI_FIRST;

        //
        // if this cert has a CTL context on it, then display that as the
        // parent of this cert
        //
        if (pviewhelp->rgpCryptProviderCerts[i]->pCtlContext != NULL)
        {
            LoadStringU(HinstDll, IDS_CTLVIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            psz = CertUIMkMBStr(rgwch);
            tvins.item.pszText = rgwch;
            tvins.item.cchTextMax = wcslen(rgwch);

            //
            // display the proper image based on whether there is a CTL error or not
            //
            if (GetTreeCTLErrorString(
                    pviewhelp->rgpCryptProviderCerts[i]->dwCtlError,
                    &pwszErrorString))
            {
                tvins.item.iImage = MY_TREE_IMAGE_STATE_INVALIDCTL;
            }
            else
            {
                tvins.item.iImage = MY_TREE_IMAGE_STATE_VALIDCTL;
            }

            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (LPARAM) MakeHelperStruct(
                                            (void *)pviewhelp->rgpCryptProviderCerts[i]->pCtlContext,
                                            pwszErrorString,
                                            TRUE);

            hItem = (HTREEITEM) SendMessage(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVM_INSERTITEMW, 0, (LPARAM) &tvins);

            if (i != (int) (pviewhelp->cpCryptProviderCerts-1))
            {
                TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                                tvins.hParent, TVE_EXPAND);
            }

            //
            // set up the parent to insert the cert
            //
            tvins.hParent = hItem;

            free(psz);
        }

        //
        // get the display string for the tree view item
        //
        tvins.item.pszText = PrettySubject(pviewhelp->rgpCryptProviderCerts[i]->pCert);
        if (tvins.item.pszText == NULL)
        {
            LPWSTR pwszNone = NULL;

            if (NULL == (pwszNone = (LPWSTR) malloc((MAX_TITLE_LENGTH + 1) * sizeof(WCHAR))))
            {
                break;
            }

            // load the string for NONE
            if(!LoadStringU(g_hmodThisDll, IDS_NONE, pwszNone, MAX_TITLE_LENGTH))
            {
                free(pwszNone);
                break;
            }
            
            tvins.item.pszText = pwszNone;
        }
        tvins.item.cchTextMax = wcslen(tvins.item.pszText);
        
        //
        // check if the cert is trusted by trying to get an error string for the cert,
        // set the the tree view image for the cert based on that
        //
        GetTreeCertErrorStringAndImage(
                    pviewhelp->rgpCryptProviderCerts[i],
                    &pwszErrorString,
                    &(tvins.item.iImage),
                    pviewhelp->fWarnUntrustedRoot,
                    pviewhelp->fRootInRemoteStore,
                    (i == 0),
                    (pviewhelp->cUsages == 0));

        tvins.item.iSelectedImage = tvins.item.iImage;
        tvins.item.lParam = (LPARAM) MakeHelperStruct(
                                        (void *)pviewhelp->rgpCryptProviderCerts[i]->pCert,
                                        pwszErrorString,
                                        FALSE);
        
        hItem = (HTREEITEM) SendMessage(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVM_INSERTITEMW, 0, (LPARAM) &tvins);
        
        if ((i != (int) (pviewhelp->cpCryptProviderCerts-1)) ||
            (pviewhelp->rgpCryptProviderCerts[i]->pCtlContext != NULL))
        {
            TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                            tvins.hParent, TVE_EXPAND);
        }

        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem);

        free(tvins.item.pszText);
        tvins.item.pszText = NULL;
    }

    pviewhelp->fAddingToChain = FALSE;
    pviewhelp->hItem = hItem;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageHierarchy(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    HIMAGELIST          hIml;
    HTREEITEM           hItem;
    int                 i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    CERT_VIEW_HELPER    *pviewhelp;
    LPWSTR              pwsz;
    TV_ITEM             tvi;
    LPNMTREEVIEW        pnmtv;
    LPWSTR              pwszErrorString;
    HWND                hwnd;
    WCHAR               szViewButton[CRYPTUI_MAX_STRING_SIZE];
    LPNMHDR             pnm;

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndHierarchyPage = hwndDlg;

        //
        //  Build up the image list for the control
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_TRUSTTREE_BITMAP), 16, 5, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hIml, TVSIL_NORMAL);
        }

        //
        //  Populate the tree control
        //
        PopulateChainView(hwndDlg, pviewhelp);
        EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW), FALSE);

        // Init of state var
        pviewhelp->fDblClk = FALSE;

        return TRUE;

    case WM_MY_REINITIALIZE:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        //  Re-Populate the tree control
        //
        PopulateChainView(hwndDlg, pviewhelp);

        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), NULL);
        EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW), FALSE);

        //
        // clear out the error detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_HIERARCHY_EDIT, L"");

        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if ((!pviewhelp->fDeletingChain)    &&
                (((NM_TREEVIEW *) lParam)->itemNew.hItem != NULL))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW),
                           ((NM_TREEVIEW *) lParam)->itemNew.hItem != pviewhelp->hItem);

                tvi.mask = TVIF_HANDLE | TVIF_PARAM;
                tvi.hItem = ((NM_TREEVIEW *) lParam)->itemNew.hItem;
                TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                CryptUISetRicheditTextW(hwndDlg, IDC_HIERARCHY_EDIT, ((PTREEVIEW_HELPER) tvi.lParam)->pwszErrorString);

                //
                // set the text on the button based on whether a cert or CTL is selected
                //
                if (((PTREEVIEW_HELPER) tvi.lParam)->pCTL == NULL)
                {
                    LoadStringU(HinstDll, IDS_VIEW_CERTIFICATE, szViewButton, ARRAYSIZE(szViewButton));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_VIEW_CTL, szViewButton, ARRAYSIZE(szViewButton));
                }
                SetDlgItemTextU(hwndDlg, IDC_TRUST_VIEW, szViewButton);

            }
            break;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:

            pnmtv = (LPNMTREEVIEW) lParam;

            if (!pviewhelp->fAddingToChain)
            {
                if (pnmtv->action == TVE_COLLAPSE)
                {
                    HTREEITEM hParentItem = TreeView_GetParent(GetDlgItem(hwndDlg, IDC_TRUST_TREE), pnmtv->itemNew.hItem);
                    if ((hParentItem != NULL) && (!pviewhelp->fDblClk))
                    {
                        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hParentItem);
                    }
                    else
                    {
                        pviewhelp->fDblClk = FALSE;
                    }
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            return TRUE;

        case NM_DBLCLK:

            pnm = (LPNMHDR) lParam;
            hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));

            if (TreeView_GetChild(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem) != NULL)
            {
                SendMessage(hwndDlg, WM_COMMAND, MAKELONG(IDC_TRUST_VIEW, BN_CLICKED), (LPARAM) GetDlgItem(hwndDlg, IDC_TRUST_VIEW));
            }

            if (hItem != pviewhelp->hItem)
            {
                pviewhelp->fDblClk = TRUE;
            }
            break;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDC_TRUST_VIEW:

            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW  cvps;
                CRYPTUI_VIEWCTL_STRUCTW          cvctl;
                BOOL                             fPropertiesChanged;
                PTREEVIEW_HELPER                 pTreeViewHelper;

                pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));
                tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN;
                tvi.hItem = hItem;
                TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                pTreeViewHelper = (PTREEVIEW_HELPER) tvi.lParam;

                //
                // check to see if we are viewing a cert or a ctl
                //
                if (pTreeViewHelper->pCTL != NULL)
                {
                    memset(&cvctl, 0, sizeof(CRYPTUI_VIEWCTL_STRUCTW));
                    cvctl.dwSize = sizeof(CRYPTUI_VIEWCTL_STRUCTW);
                    cvctl.hwndParent = hwndDlg;
                    cvctl.pCTLContext = pTreeViewHelper->pCTL;
                    cvctl.cCertSearchStores = pviewhelp->pcvp->cStores;
                    cvctl.rghCertSearchStores = pviewhelp->pcvp->rghStores;
                    cvctl.cStores = pviewhelp->pcvp->cStores;
                    cvctl.rghStores = pviewhelp->pcvp->rghStores;

                    CryptUIDlgViewCTLW(&cvctl);
                }
                else
                {

                    memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                    cvps.hwndParent = hwndDlg;
                    cvps.pCertContext = pTreeViewHelper->pCert;

                    // Set this flag to inhibit the deletion of the
                    // CERT_EXTENDED_ERROR_INFO_PROP_ID property which is
                    // set on the CA certs when building the original chain
                    // for the end certificate.
                    //
                    cvps.dwFlags |= CRYPTUI_TREEVIEW_PAGE_FLAG;

#if (0) // DSIE: Do not carry the state over. People get so confused when the state is carried
        //       over. So, always rebuild the state, and treat it as new context. Beside, by
        //       carrying the state over, it will have problem showing when there is more
        //       than one policy OID, as WinVerifyTrust can only handle one policy OID to be 
        //       passed in.
                    //
                    // Use the proper WinVerifyTrust state... either the one passed
                    // in or the one built internally if one was not passed in
                    //
                    if (pviewhelp->pcvp->hWVTStateData == NULL)
                    {
                        cvps.hWVTStateData = pviewhelp->sWTD.hWVTStateData;
                    }
#endif
                    //
                    // see where this item is in the chain
                    //
                    while (NULL != (hItem = TreeView_GetChild(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem)))
                    {
                        //
                        // get the TreeViewHelper and make sure this item is a cert,
                        // if it is, then increase the count, otherwise if it is a CTL
                        // don't count it because CTL's hang off the CryptProviderCert 
                        // structure, so they don't take up an index themselves
                        //
                        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN;
                        tvi.hItem = hItem;
                        TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                        pTreeViewHelper = (PTREEVIEW_HELPER) tvi.lParam;
                        if (pTreeViewHelper->pCert != NULL)
                        {
                            cvps.idxCert++;
                        }
                    }

                    //cvps.pCryptProviderData = NULL;

                    i = CryptUIDlgViewCertificateW(&cvps, &fPropertiesChanged);

                    //
                    // if properties changed whiled editing the parent, then
                    // we need to let our caller know, and we need to refresh
                    //
                    if (fPropertiesChanged)
                    {
                        if (pviewhelp->pfPropertiesChanged != NULL)
                        {
                            *(pviewhelp->pfPropertiesChanged) = TRUE;
                        }

                        //
                        // since the properties of one of our parents changed, we need
                        // to redo the trust work and then reset the display
                        //
                        BuildChain(pviewhelp, NULL);

                        if (pviewhelp->hwndGeneralPage != NULL)
                        {
                            SendMessage(pviewhelp->hwndGeneralPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                        }

                        SendMessage(hwndDlg, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                }
            }

            return TRUE;

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        DeleteChainViewItems(hwndDlg, pviewhelp);

        ImageList_Destroy(TreeView_GetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVSIL_NORMAL));

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_TRUST_TREE))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_TRUST_VIEW))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_HIERARCHY_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\frmtutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       frmtutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;

///////////////////////////////////////////////////////

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

const CHAR      RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                             '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatAlgorithmString(LPWSTR *ppString, CRYPT_ALGORITHM_IDENTIFIER const *pAlgorithm)
{
    PCCRYPT_OID_INFO pOIDInfo;
    
    pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pAlgorithm->pszObjId,
                    0);

    if (pOIDInfo != NULL)
    {
        if (NULL == (*ppString = AllocAndCopyWStr((LPWSTR) pOIDInfo->pwszName)))
        {
            return FALSE;

        }
    }
    else
    {
        if (NULL == (*ppString = CertUIMkWStr(pAlgorithm->pszObjId)))
        {
            return FALSE;

        }
    }
        
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat, HWND hwnd)
{
    int                 cch;
    int                 cch2;
    LPWSTR              psz;
    SYSTEMTIME          st;
    FILETIME            localTime;
    DWORD               locale;
    BOOL                bRTLLocale;
    DWORD               dwFlags = fLongFormat ? DATE_LONGDATE : 0;

    //  See if the user locale id is RTL (Arabic, Urdu, Farsi or Hebrew).
    locale     = GetUserDefaultLCID();
    bRTLLocale = (	(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
   			        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_URDU)   ||
   			        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_FARSI)  ||
                	(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW)
		         );
    locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

    if (bRTLLocale && (hwnd != NULL))
    {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
       } else {
           dwFlags |= DATE_LTRREADING;
       }
    }

    if (!FileTimeToLocalFileTime(&ft, &localTime))
    {
        return FALSE;
    }
    
    if (!FileTimeToSystemTime(&localTime, &st)) 
    {
        //
        // if the conversion to local time failed, then just use the original time
        //
        if (!FileTimeToSystemTime(&ft, &st)) 
        {
            return FALSE;
        }
        
    }

    cch = (GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormatU(locale, dwFlags, &st, NULL, NULL, 0) + 5);

    if (NULL == (psz = (LPWSTR) malloc((cch+5) * sizeof(WCHAR))))
    {
        return FALSE;
    }
    
    cch2 = GetDateFormatU(locale, dwFlags, &st, NULL, psz, cch);

    if (fIncludeTime)
    {
        psz[cch2-1] = ' ';
        GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, 
                       &psz[cch2], cch-cch2);
    }
    
    *ppString = psz;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatValidityString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, HWND hwnd)
{
    WCHAR   szText[256];
    LPWSTR  pwszReturnText;
    LPWSTR  pwszText;
    void    *pTemp;

    *ppString = NULL;
    
    LoadStringU(HinstDll, IDS_VALIDFROM, szText, ARRAYSIZE(szText));

    if (NULL == (pwszReturnText = AllocAndCopyWStr(szText)))
    {
        return FALSE;
    }
    
    if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotBefore, FALSE, FALSE, hwnd))
    {
        free(pwszReturnText);
        return FALSE;
    }

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(pwszText)+3) * sizeof(WCHAR))))
    {
        free(pwszText);
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, pwszText);
    free(pwszText);
    pwszText = NULL;

    LoadStringU(HinstDll, IDS_VALIDTO, szText, ARRAYSIZE(szText));

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(szText)+3) * sizeof(WCHAR))))
    {
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, szText);

    if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotAfter, FALSE, FALSE, hwnd))
    {
        free(pwszReturnText);
        return FALSE;
    }

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(pwszText)+3) * sizeof(WCHAR))))
    {
        free(pwszText);
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, pwszText);
    free(pwszText);

    *ppString = pwszReturnText;
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob)
{
    DWORD                 i = 0;
    LPBYTE                pb;

    //DSIE: Bug 54159.
    //      To solve the problem, we need to put the Left-To-Right marker (0x200e),
    //      if complex script is supported, at the beginning of the Unicode string, 
    //      so that it will always be displayed as US string (left-to-right).
#if (0)
    if (NULL == (*ppString = (LPWSTR) malloc((pblob->cbData * 3) * sizeof(WCHAR))))
    {
        return FALSE;
    }

    // fill the buffer
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb--;                    
    }
    (*ppString)[--i] = 0;
#else
    HMODULE hModule  = NULL;
    DWORD   dwLength = pblob->cbData * 3;

    // See if complex script is supported.
    if (hModule = GetModuleHandle("LPK.DLL"))
    {
        dwLength++;
    }

    if (NULL == (*ppString = (LPWSTR) malloc(dwLength * sizeof(WCHAR))))
    {
        return FALSE;
    }

    // The marker will be changed back to NULL if no data to format.
    if (hModule)
    {
        (*ppString)[i++] = (WCHAR) 0x200e;
    }

    // fill the buffer
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb--;                    
    }
    (*ppString)[--i] = 0;
#endif
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
#define NUM_HEXBYTES_PERLINE    8
#define NUM_CHARS_PERLINE       ((NUM_HEXBYTES_PERLINE*2) + (NUM_HEXBYTES_PERLINE-1) + 3 + NUM_HEXBYTES_PERLINE + 2)
//                              (two hex digits per byte) + (space between each byte)+ (3 spaces) + (an ascci char per byte) + \n

BOOL FormatMemBufToWindow(HWND hWnd, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    LPSTR   pszBuffer;
    DWORD   cbBuffer;
    char    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE];
    DWORD   dwHexTextIndex = 0;
    char    szASCIIText[NUM_HEXBYTES_PERLINE+1];
    DWORD   dwASCIITextIndex = 0;
    BYTE    *pbBuffer;

    cbBuffer = ((cbData+NUM_HEXBYTES_PERLINE-1) / NUM_HEXBYTES_PERLINE) * NUM_CHARS_PERLINE + 1;
    if (NULL == (pszBuffer = (LPSTR) malloc(cbBuffer)))
    {
        return FALSE;
    }

    pszBuffer[0] = 0;
    pbBuffer = (BYTE *) &pszBuffer[0];

    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
    szASCIIText[NUM_HEXBYTES_PERLINE] = 0;

#if (1) //DSIE: bug 262252
	if (cbData && pbData)
	{
	    pb = pbData;
	    while (pb <= &(pbData[cbData-1]))
	    {   
	        // if we have a full line, then add the ascii characters
	        if (((pb - pbData) % NUM_HEXBYTES_PERLINE == 0) && (pb != pbData))
	        {
	            szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
	            
	            //
	            // for some reason strcat is dying when the string gets REALLY long, so just do
	            // the string cat stuff manually with memcpy.
	            //
	            memcpy(pbBuffer, (BYTE *) szHexText, strlen(szHexText));        pbBuffer += strlen(szHexText);//strcat(pszBuffer, szHexText);
	            memcpy(pbBuffer, (BYTE *) "   ", strlen("   "));                pbBuffer += strlen("   ");//strcat(pszBuffer, "   ");
	            memcpy(pbBuffer, (BYTE *) szASCIIText, strlen(szASCIIText));    pbBuffer += strlen(szASCIIText);//strcat(pszBuffer, szASCIIText);
	            memcpy(pbBuffer, (BYTE *) "\n", strlen("\n"));                  pbBuffer += strlen("\n");//strcat(pszBuffer, "\n");
	            dwHexTextIndex = 0;
	            dwASCIITextIndex = 0;
	        }

	        szHexText[dwHexTextIndex++] = RgchHex[(*pb & 0xf0) >> 4];
	        szHexText[dwHexTextIndex++] = RgchHex[*pb & 0x0f];
	        // this will overwrite the null character when it is the last iteration,
	        // so just reset the null characert before doing the strcat
	        szHexText[dwHexTextIndex++] = ' ';  
	        szASCIIText[dwASCIITextIndex++] = (*pb >= 0x20 && *pb <= 0x7f) ? (char)*pb : '.';
	        pb++;
	    }

	    //
	    // print out the last line
	    //

	    // fill in with spaces if needed
	    for (i=dwHexTextIndex; i<((NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1); i++)
	    {
	        szHexText[i] = ' ';
	    }
	    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
	    
	    // add the null character to the proper place in the ascii buffer
	    szASCIIText[dwASCIITextIndex] = 0;

	    //
	    // for some reason strcat is dying when the string gets REALLY long, so just do
	    // the string cat stuff manually with memcpy.
	    //
	    memcpy(pbBuffer, (BYTE *) szHexText, strlen(szHexText));        pbBuffer += strlen(szHexText);//strcat(pszBuffer, szHexText);
	    memcpy(pbBuffer, (BYTE *) "   ", strlen("   "));                pbBuffer += strlen("   ");//strcat(pszBuffer, "   ");
	    memcpy(pbBuffer, (BYTE *) szASCIIText, strlen(szASCIIText));    pbBuffer += strlen(szASCIIText);//strcat(pszBuffer, szASCIIText);
	    *pbBuffer = 0; 
	}
#endif
    SendMessageA(hWnd, WM_SETTEXT, 0, (LPARAM) pszBuffer);
    free(pszBuffer);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    
    if (NULL == (*ppString = (LPWSTR) malloc((cbData * 3) * sizeof(WCHAR))))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb++;         
    }
    (*ppString)[--i] = 0;
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
#define STRING_ALLOCATION_SIZE 128
BOOL FormatDNNameString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData, BOOL fMultiline)
{
    CERT_NAME_INFO  *pNameInfo;
    DWORD           cbNameInfo;
    WCHAR           szText[256];
    LPWSTR          pwszText;
    int             i,j;
    DWORD           numChars = 1; // 1 for the terminating 0
    DWORD           numAllocations = 1;
    void            *pTemp;

    //
    // decode the dnname into a CERT_NAME_INFO struct
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbData,
                cbData,
                0,
                NULL,
                &cbNameInfo))
    {
        return FALSE;
    }
    if (NULL == (pNameInfo = (CERT_NAME_INFO *) malloc(cbNameInfo)))
    {
        return FALSE;
    }
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbData,
                cbData,
                0,
                pNameInfo,
                &cbNameInfo))
    {
        free (pNameInfo);
        return FALSE;
    }

    //
    // allocate an initial buffer for the DN name string, then if it grows larger
    // than the initial amount just grow as needed
    //
    *ppString = (LPWSTR) malloc(STRING_ALLOCATION_SIZE * sizeof(WCHAR));
    if (*ppString == NULL)
    {
        free (pNameInfo);
        return FALSE;
    }

    (*ppString)[0] = 0;


    //
    // loop for each rdn and add it to the string
    //
    for (i=pNameInfo->cRDN-1; i>=0; i--)
    {
        // if this is not the first iteration, then add a eol or a ", "
        if (i != (int)pNameInfo->cRDN-1)
        {
            if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }
            
            if (fMultiline)
                wcscat(*ppString, L"\n");
            else
                wcscat(*ppString, L", ");

            numChars += 2;
        }

        for (j=pNameInfo->rgRDN[i].cRDNAttr-1; j>=0; j--)
        {
            // if this is not the first iteration, then add a eol or a ", "
            if (j != (int)pNameInfo->rgRDN[i].cRDNAttr-1)
            {
                if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }
                
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");

                numChars += 2;  
            }
            
            //
            // add the field name to the string if it is Multiline display
            //

            if (fMultiline)
            {
                if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId))
                {
                    free (pNameInfo);
                    return FALSE;
                }

                if ((numChars + wcslen(szText) + 3) >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + wcslen(szText) + 3) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                numChars += wcslen(szText) + 3;
                wcscat(*ppString, szText);
                wcscat(*ppString, L" = ");  // delimiter
            }

            //
            // add the value to the string
            //
            if (CERT_RDN_ENCODED_BLOB == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType ||
                        CERT_RDN_OCTET_STRING == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType)
            {
                // translate the buffer to a text string and display it that way
                if (FormatMemBufToString(
                        &pwszText, 
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData,
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData))
                {
                    if ((numChars + wcslen(pwszText)) >= (numAllocations * STRING_ALLOCATION_SIZE))
                    {
                        // increment the number of allocation blocks until it is large enough
                        while ((numChars + wcslen(pwszText)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                        pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                        if (pTemp == NULL)
                        {
                            free (pwszText);
                            free (pNameInfo);
                            free (*ppString);
                            return FALSE;
                        }
                        *ppString = (LPWSTR) pTemp;
                    }
                    
                    wcscat(*ppString, pwszText);
                    numChars += wcslen(pwszText);
                    
                    free (pwszText);
                }
            }
            else 
            {
                // buffer is already a string so just copy it
                
                if ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                        >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                            >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                wcscat(*ppString, (LPWSTR) pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData);
                numChars += (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR));
            }
        }
    }
    free (pNameInfo);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline)
{
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
    DWORD               cbKeyUsage = 0;
    DWORD               numChars = 1;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    DWORD               i;

    //
    // Try to get the enhanced key usage property
    //

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    NULL,
                                    &cbKeyUsage))
    {
        return FALSE;
    }

    if (NULL == (pKeyUsage = (CERT_ENHKEY_USAGE *) malloc(cbKeyUsage)))
    {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    pKeyUsage,
                                    &cbKeyUsage))
    {
        free(pKeyUsage);
        return FALSE;
    }

    if (pKeyUsage->cUsageIdentifier == 0)
    {
        free (pKeyUsage);
        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            LoadStringU(HinstDll, IDS_ALL_FIELDS, szText, ARRAYSIZE(szText));
            if (NULL == (*ppString = AllocAndCopyWStr(szText)))
            {
                return FALSE; 
            }
            else
            {
                return TRUE;   
            }
        }
        else
        {
            LoadStringU(HinstDll, IDS_NO_USAGES, szText, ARRAYSIZE(szText));
            if (NULL == (*ppString = AllocAndCopyWStr(szText)))
            {
                return FALSE; 
            }
            else
            {
                return TRUE;   
            }
        }
    }

    //
    // calculate size
    //

    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                numChars += 2;
            }

            numChars += wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc((numChars+1) * sizeof(WCHAR))))
    {
        free (pKeyUsage);
        return FALSE; 
    }

    //
    // copy to buffer
    //
    (*ppString)[0] = 0;
    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");
                    
                numChars += 2;
            }

            //  add the enhanced key usage string
            wcscat(*ppString, szText);
            numChars += wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    free (pKeyUsage);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndReturnSignTime(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd)
{
    DWORD       i;
    BOOL        fFound = FALSE;
    FILETIME    *pFileTime = NULL;
    DWORD       cbFileTime = 0;
    LPWSTR      pszReturn = NULL;

    if (ppSignTime != NULL)
    {
        *ppSignTime = NULL;
    }

    //
    // loop for each authenticated attribute
    //
    i=0;
    while ((!fFound) && (i<pSignerInfo->AuthAttrs.cAttr))
    {
        if (!(strcmp(pSignerInfo->AuthAttrs.rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0))
        {
            i++;
            continue;
        }

        assert(pSignerInfo->AuthAttrs.rgAttr[i].cValue == 1);
        
        fFound = TRUE;

        //decode the EncodedSigner info
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS_UTC_TIME,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							NULL,
							&cbFileTime))
        {
            return NULL;
        }

        if (NULL == (pFileTime = (FILETIME *) malloc(cbFileTime)))
        {
            return NULL;
        }

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS_UTC_TIME,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							pFileTime,
							&cbFileTime))
        {
            return NULL;
        }

        //
        // return the sign time if the caller wants it, otherwise format the string and return it
        //
        if (ppSignTime)
        {
            if (NULL != (*ppSignTime = (FILETIME *) malloc(sizeof(FILETIME))))
            {
                memcpy(*ppSignTime, pFileTime, sizeof(FILETIME));
            }
        }
        else if (!FormatDateString(&pszReturn, *pFileTime, TRUE, TRUE, hwnd))
        {
            free(pFileTime);
            return NULL;
        }
    }

    if (pFileTime != NULL)
    {
        free(pFileTime);
    }

    return(pszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndReturnTimeStampersTimes(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd)
{
    PCMSG_SIGNER_INFO   pCounterSignerInfo;
    DWORD               cbCounterSignerInfo;
    DWORD               i;
    LPWSTR              pszReturnText = NULL;
    LPWSTR              pszTimeText = NULL;
    void                *pTemp;

    if (ppSignTime != NULL)
    {
        *ppSignTime = NULL;
    }

    for (i=0; i<pSignerInfo->UnauthAttrs.cAttr; i++)
    {
        if (!(strcmp(pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId, szOID_RSA_counterSign) == 0))
        {
            continue;
        }

        assert(pSignerInfo->UnauthAttrs.rgAttr[i].cValue == 1);

        //decode the EncodedSigner info
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							NULL,
							&cbCounterSignerInfo))
        {
			return NULL;
        }

        if (NULL == (pCounterSignerInfo = (PCMSG_SIGNER_INFO)malloc(cbCounterSignerInfo)))
        {
            return NULL;
        }

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							pCounterSignerInfo,
							&cbCounterSignerInfo))
        {
            free(pCounterSignerInfo);
            return NULL;
        }

        if (ppSignTime != NULL)
        {
            //
            // break after this which means we just get the first time stamp time,
            // but reallistically there should only be one anyway.
            //
            AllocAndReturnSignTime(pCounterSignerInfo, ppSignTime, hwnd);
            free(pCounterSignerInfo);
            break;
        }
        else
        {
            pszTimeText = AllocAndReturnSignTime(pCounterSignerInfo, NULL, hwnd);
            
            if (pszReturnText == NULL)
            {
                pszReturnText = pszTimeText;
            }
            else if (pszTimeText != NULL)
            {
                pTemp = realloc(pszReturnText, 
                                (wcslen(pszReturnText) + wcslen(pszTimeText) + wcslen(L", ") + 1) * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free(pszTimeText);
                    free(pszReturnText);
                    return NULL;
                }
                pszReturnText = (LPWSTR) pTemp;
                wcscat(pszReturnText, L", ");
                wcscat(pszReturnText, pszTimeText);
                free(pszTimeText);
            }
        }

        free(pCounterSignerInfo);
    }

    //
    // if there were no counter signers, then use the time in the original signer info
    // 
    if ((pszReturnText == NULL) && (ppSignTime == NULL))
    {
        pszReturnText = AllocAndReturnSignTime(pSignerInfo, NULL, hwnd);
    }

    return(pszReturnText);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR FormatCTLSubjectUsage(CTL_USAGE *pSubjectUsage, BOOL fMultiline)
{
    DWORD   i;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];
    LPWSTR  pwszText = NULL;
    void    *pTemp;

    for (i=0; i<pSubjectUsage->cUsageIdentifier; i++)
    {
        if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pSubjectUsage->rgpszUsageIdentifier[i]))
        {
            continue;
        }

        if (pwszText == NULL)
        {
            pwszText = AllocAndCopyWStr(szText);
        }
        else
        {
            pTemp = realloc(pwszText, (wcslen(szText) + wcslen(pwszText) + 3) * sizeof(WCHAR));
            if (pTemp != NULL)
            {
                pwszText = (LPWSTR) pTemp;

                if (fMultiline)
                {
                    wcscat(pwszText, L"\n"); 
                }
                else
                {
                    wcscat(pwszText, L", "); 
                }
                wcscat(pwszText, szText); 
            }
            else
            {
                free(pwszText);
                return NULL;
            }
        }
    }
    return pwszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\demand.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.cpp
//
//--------------------------------------------------------------------------

/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include        "global.hxx"
#include        <dbgdef.h>

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

#ifndef MAC
////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn" failed to load");    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##fn != NULL);

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##varname != NULL);

////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hShell32 = 0;
#if 0 // JLS
static HMODULE          s_hShLWAPI = 0;
static HMODULE          s_hURLMon = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hWinINET = 0;
static HMODULE          s_hComctl32 = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hMAPI = 0;
static HMODULE          s_hWSOCK = 0;
static HMODULE          s_hOLEAUT = 0;
static HMODULE          s_hKernel = 0;
#endif // 0 // JLS

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hShell32)
        FreeLibrary(s_hShell32);
#if 0 //JLS
    if (s_hShLWAPI)
        FreeLibrary(s_hShLWAPI);
    if (s_hURLMon)
        FreeLibrary(s_hURLMon);
    if (s_hOLEAUT)
        FreeLibrary(s_hOLEAUT);
    if (s_hMAPI)
        FreeLibrary(s_hMAPI);
    if (s_hWSOCK)
        FreeLibrary(s_hWSOCK);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hKernel)
        FreeLibrary(s_hKernel);
#endif // JLS
#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

#if 0 // JLS
////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/
#endif // 0

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt) {
        s_hCrypt = LoadLibraryA("CRYPT32.DLL");
        // AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CryptFormatObject)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrW)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrA)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameA)
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrW)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CryptUnregisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertVerifyCTLUsage)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCTLContext)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCTLToStore)
            GET_PROC_ADDR(s_hCrypt, CryptMsgEncodeAndSignCTL)
            GET_PROC_ADDR(s_hCrypt, CertFindCTLInStore)
            GET_PROC_ADDR(s_hCrypt, CryptSignAndEncodeCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptExportPublicKeyInfo)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore);
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity);
            GET_PROC_ADDR(s_hCrypt, CertFindSubjectInCTL);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibraryA("ADVAPI32.DLL");
        //  AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else {
            if (FIsWin95) {
                VAR_CryptAcquireContextW = MyCryptAcquireContextW;
            }
            else {
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW);
            }
#if 0
            GET_PROC_ADDR(s_hAdvApi, CryptGetProvParam)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            GET_PROC_ADDR(s_hAdvApi, CryptGenKey)
            GET_PROC_ADDR(s_hAdvApi, CryptDestroyKey)
#endif // 0
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#ifndef WIN16

BOOL DemandLoadUser32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
#undef SendDlgitemMessageW
#undef SetDlgItemTextW
#undef GetDlgItemTextW
#undef LoadStringW
#undef FormatMessageW

    if (0 == s_hShell32) {
        if (FIsWin95) {
            VAR_SendDlgItemMessageW = MySendDlgItemMessageW;
            VAR_SetDlgItemTextW = MySetDlgItemTextW;
            VAR_GetDlgItemTextW = MyGetDlgItemTextW;
            VAR_LoadStringW = MyLoadStringW;
            VAR_FormatMessageW = MyFormatMessageW;
            VAR_WinHelpW = MyWinHelpW;
        }
        else {
            s_hShell32 = LoadLibraryA("kernel32.dll");
            GET_PROC_ADDR(s_hShell32, FormatMessageW);
            FreeLibrary(s_hShell32);
            
            s_hShell32 = LoadLibraryA("USER32.DLL");
            GET_PROC_ADDR(s_hShell32, SendDlgItemMessageW);
            GET_PROC_ADDR(s_hShell32, SetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, GetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, LoadStringW);
            GET_PROC_ADDR(s_hShell32, WinHelpW);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#endif // !WIN16

#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\gettrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gettrst.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include "wintrustp.h"
#include "crypthlp.h"

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static BOOL IsUntrustedRootProblem(WINTRUST_DATA *pWTD)
{
    CRYPT_PROVIDER_DATA     *pProvData = NULL;
    CRYPT_PROVIDER_SGNR     *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT     *pCryptProviderCert;
    DWORD                   i;
    
    pProvData = WTHelperProvDataFromStateData(pWTD->hWVTStateData);
    pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
        
    if (pProvSigner)
    {
        // get all certs in the chain
        for (i=0; i<pProvSigner->csCertChain; i++)
        {
            pCryptProviderCert = WTHelperGetProvCertFromChain(pProvSigner, i);
            if (pCryptProviderCert != NULL)
            {
                if (pCryptProviderCert->dwError != ERROR_SUCCESS)
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static DWORD GetFinalErrorFromChain(PCERT_VIEW_HELPER pviewhelp)
{
    int   i;
    DWORD   dwErr = 0;

    for (i=((int)pviewhelp->cpCryptProviderCerts)-1; i>= 0; i--) 
    {
        dwErr = pviewhelp->rgpCryptProviderCerts[i]->dwError;
        
        if (((dwErr == CERT_E_UNTRUSTEDROOT) || (dwErr == CERT_E_UNTRUSTEDTESTROOT)) && 
            (pviewhelp->fIgnoreUntrustedRoot))
        {
            dwErr = 0;
        }
        else if (dwErr != 0)
        {
            break;
        }
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static void GetCertChainErrorString(PCERT_VIEW_HELPER pviewhelp)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    DWORD   i;
    DWORD   dwChainError;
    
    //
    // free the error string if one already exists
    //
    if (pviewhelp->pwszErrorString != NULL)
    {
        free(pviewhelp->pwszErrorString);
        pviewhelp->pwszErrorString = NULL;
    }


    // If they ask to be warned about local/remote differences, 
    // always display this warning
    if (pviewhelp->fWarnRemoteTrust)
    {
        LoadStringU(HinstDll, IDS_WARNREMOTETRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
        goto StringLoaded;
    } 
    
    //
    // if there was no over all chain error, then the only problem,
    // is if there are no usages
    //
    if (pviewhelp->dwChainError == 0)
    {
        if (pviewhelp->cUsages == NULL)
        {
            LoadStringU(HinstDll, IDS_NOVALIDUSAGES_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
        }
        else
        {
            return;
        }
    }

    if ((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) ||
        (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT))
    {
        //
        // if we are ignoring untrusted roots, then just return
        //
        if (pviewhelp->fIgnoreUntrustedRoot)
        {
            return;
        }

        //
        // if we are just warning the user about untrusted root AND the root
        // cert is in the remote root store then load that string
        //
        if (pviewhelp->fWarnUntrustedRoot && pviewhelp->fRootInRemoteStore)
        {
            //
            // if this is a root cert then show the error for a root
            //
            if (pviewhelp->cpCryptProviderCerts == 1 && (pviewhelp->rgpCryptProviderCerts[0])->fSelfSigned)
            {
                LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT, szErrorString, ARRAYSIZE(szErrorString));
            }
            else
            {
                LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR, szErrorString, ARRAYSIZE(szErrorString));
            }
        }
        else
        {
            //
            // if this is a root cert then show the error for a root
            //
            if (pviewhelp->cpCryptProviderCerts == 1 && (pviewhelp->rgpCryptProviderCerts[0])->fSelfSigned)
            {
                LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ROOTCERT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
            }
            else
            {
                LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
            }
        }
    }
    else if (pviewhelp->dwChainError == CERT_E_REVOKED)
    {
        LoadStringU(HinstDll, IDS_CERTREVOKED_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_CERT_SIGNATURE)
    {
        LoadStringU(HinstDll, IDS_CERTBADSIGNATURE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_EXPIRED)
    {
        LoadStringU(HinstDll, IDS_CERTEXPIRED_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_VALIDITYPERIODNESTING)
    {
        LoadStringU(HinstDll, IDS_TIMENESTING_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_WRONG_USAGE)
    {
        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_BASIC_CONSTRAINTS)
    {
        LoadStringU(HinstDll, IDS_BASIC_CONSTRAINTS_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_PURPOSE)
    {
        LoadStringU(HinstDll, IDS_PURPOSE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_REVOCATION_FAILURE)
    {
        LoadStringU(HinstDll, IDS_REVOCATION_FAILURE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_CHAINING)
    {
        LoadStringU(HinstDll, IDS_CANTBUILDCHAIN_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_EXPLICIT_DISTRUST)
    {
        LoadStringU(HinstDll, IDS_EXPLICITDISTRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError != 0)
    {
        //
        // this is not an error we know about, so call the general
        // error string function
        //
        GetUnknownErrorString(&(pviewhelp->pwszErrorString), pviewhelp->dwChainError);
    }

StringLoaded:
    
    if (pviewhelp->pwszErrorString == NULL)
    {
        pviewhelp->pwszErrorString = AllocAndCopyWStr(szErrorString);
    }
}

// Returned string must be freed via LocalFree()
LPWSTR
FormatRevocationStatus(
    IN PCERT_CHAIN_ELEMENT pElement
    )
{
    LPWSTR pwszRevStatus = NULL;
    UINT ids = IDS_REV_STATUS_UNKNOWN_ERROR;
    static const WCHAR wszNoTime[] = L"...";
    LPWSTR pwszArg1 = (LPWSTR) wszNoTime;
    LPWSTR pwszArg2 = (LPWSTR) wszNoTime;
    LPWSTR pwszTime1 = NULL;
    LPWSTR pwszTime2 = NULL;
    LPWSTR pwszErrStr = NULL;
    DWORD dwRevResult;
    PCERT_REVOCATION_INFO pRevInfo;
    PCERT_REVOCATION_CRL_INFO pCrlInfo;

    pRevInfo = pElement->pRevocationInfo;
    if (NULL == pRevInfo)
        return NULL;

    dwRevResult = pRevInfo->dwRevocationResult;
    pCrlInfo = pRevInfo->pCrlInfo;

    switch (dwRevResult) {
        case ERROR_SUCCESS:
            ids = IDS_REV_STATUS_OK;
            // Fall through
        case CRYPT_E_REVOCATION_OFFLINE:
            if (pCrlInfo) {
                PCCRL_CONTEXT pCrl;

                pCrl = pCrlInfo->pDeltaCrlContext;
                if (NULL == pCrl)
                    pCrl = pCrlInfo->pBaseCrlContext;
                if (pCrl) {
                    BOOL fFormatDate;

                    fFormatDate = FormatDateString(
                        &pwszTime1, 
                        pCrl->pCrlInfo->ThisUpdate,
                        TRUE,               // fIncludeTime
                        TRUE,               // fLongFormat
                        NULL                // hwnd
                        );
                    if (fFormatDate) {
                        pwszArg1 = pwszTime1;

                        if (I_CryptIsZeroFileTime(&pCrl->pCrlInfo->NextUpdate))
                            pwszArg2 = (LPWSTR) wszNoTime;
                        else {
                            fFormatDate = FormatDateString(
                                &pwszTime2, 
                                pCrl->pCrlInfo->NextUpdate,
                                TRUE,               // fIncludeTime
                                TRUE,               // fLongFormat
                                NULL                // hwnd
                                );
                            if (fFormatDate)
                                pwszArg2 = pwszTime2;
                        }
                    }

                    if (fFormatDate) {
                        switch (dwRevResult) {
                            case ERROR_SUCCESS:
                                ids = IDS_REV_STATUS_OK_WITH_CRL;
                                break;
                            case CRYPT_E_REVOCATION_OFFLINE:
                                ids = IDS_REV_STATUS_OFFLINE_WITH_CRL;
                                break;
                        }
                    }
                }
            }
            break;

        case CRYPT_E_REVOKED:
            if (pCrlInfo && pCrlInfo->pCrlEntry) {
                if (FormatDateString(
                        &pwszTime1, 
                        pCrlInfo->pCrlEntry->RevocationDate,
                        TRUE,               // fIncludeTime
                        TRUE,               // fLongFormat
                        NULL                // hwnd
                        )) {
                    ids = IDS_REV_STATUS_REVOKED_ON;
                    pwszArg1 = pwszTime1;
                }
            }
            break;

        default:
            break;
    }

    if (IDS_REV_STATUS_UNKNOWN_ERROR == ids) {
        GetUnknownErrorString(&pwszErrStr, dwRevResult);
        if (NULL == pwszErrStr)
            goto CommonReturn;
        pwszArg1 = pwszErrStr;
    }

    pwszRevStatus = FormatMessageUnicodeIds(ids, pwszArg1, pwszArg2);
CommonReturn:
    if (pwszTime1)
        free(pwszTime1);
    if (pwszTime2)
        free(pwszTime2);
    if (pwszErrStr)
        free(pwszErrStr);

    return pwszRevStatus;
}



//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL BuildChain(
        PCERT_VIEW_HELPER   pviewhelp, 
        LPSTR               pszUsage)
{
    CRYPT_PROVIDER_DATA const *         pProvData = NULL;
    CRYPT_PROVIDER_SGNR       *         pProvSigner = NULL;
    DWORD                               i;
    GUID                                defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    HRESULT                             hr = ERROR_SUCCESS;
    BOOL                                fInternalError = FALSE;
    DWORD                               dwStartIndex;
    BOOL                                fRet = TRUE;
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp = pviewhelp->pcvp;
    WCHAR                               szErrorString[CRYPTUI_MAX_STRING_SIZE];

    //
    // if there was previous chain state then free that before building
    // the new chain
    //
    if (pviewhelp->fFreeWTD)
    {
        pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));
    }

    pviewhelp->cpCryptProviderCerts = 0;
    pviewhelp->fFreeWTD = FALSE;

    //
    // initialize structs that are used with WinVerifyTrust()
    //
    memset(&(pviewhelp->sWTD), 0x00, sizeof(WINTRUST_DATA));
    pviewhelp->sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    pviewhelp->sWTD.dwUIChoice     = WTD_UI_NONE;
    pviewhelp->sWTD.dwUnionChoice  = WTD_CHOICE_CERT;
    pviewhelp->sWTD.pCert          = &(pviewhelp->sWTCI);
    pviewhelp->sWTD.dwProvFlags    = (pszUsage == NULL) ? WTD_NO_POLICY_USAGE_FLAG : 0;
    if ((pcvp->dwFlags & CRYPTUI_ENABLE_REVOCATION_CHECKING) == 0)
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_NONE;
    }
    else
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_CHAIN;
    }

    memset(&(pviewhelp->sWTCI), 0x00, sizeof(WINTRUST_CERT_INFO));
    pviewhelp->sWTCI.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    pviewhelp->sWTCI.pcwszDisplayName  = L"CryptUI";
    pviewhelp->sWTCI.psCertContext     = (CERT_CONTEXT *)pcvp->pCertContext;  
    pviewhelp->sWTCI.chStores          = pcvp->cStores;
    pviewhelp->sWTCI.pahStores         = pcvp->rghStores;
    pviewhelp->sWTCI.dwFlags           |= (pcvp->dwFlags & CRYPTUI_DONT_OPEN_STORES) ? WTCI_DONT_OPEN_STORES : 0;
    pviewhelp->sWTCI.dwFlags           |= (pcvp->dwFlags & CRYPTUI_ONLY_OPEN_ROOT_STORE) ? WTCI_OPEN_ONLY_ROOT : 0;

    //
    // if a provider was passed in, then use it to build the chain,
    // otherwise use the default provider to build the chain
    //
    if (pcvp->pCryptProviderData != NULL)
    {
        pProvData = pcvp->pCryptProviderData; 
        
    }
    else
    {
        pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_VERIFY;
        
        //
        // the default default provider requires the policycallback data to point
        // to the usage oid you are validating for, so set it to the usage passed in
        //
        pviewhelp->sWTD.pPolicyCallbackData = pszUsage;
        pviewhelp->sWTD.pSIPClientData = NULL;
        hr = WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));

        pProvData = WTHelperProvDataFromStateData(pviewhelp->sWTD.hWVTStateData);
        if (WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0) != NULL)
        {
            pviewhelp->fFreeWTD = TRUE;
            fInternalError = FALSE;
        }
        else
        {
            pviewhelp->fFreeWTD = FALSE;
            pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));
            fInternalError = TRUE;
        }
    }

    if (pProvData && !fInternalError)
    {
        //
        // set the chain error in the helper struct
        //
        pviewhelp->dwChainError = pProvData->dwFinalError;
        
        //
        // This is to catch internal WinVerifyTrust errors 
        //
        if ((pviewhelp->dwChainError == 0) && (FAILED(hr)))
        {
            pviewhelp->dwChainError = (DWORD) hr;
        }

        //
        // if the WinTrust state was passed into the certUI then use that for 
        // the chain, else, get it from the state that was just built
        //
        if (pcvp->pCryptProviderData != NULL)
        {
            pProvSigner = WTHelperGetProvSignerFromChain(
                                    (PCRYPT_PROVIDER_DATA) pProvData, 
                                    pcvp->idxSigner, 
                                    pcvp->fCounterSigner, 
                                    pcvp->idxCounterSigner);
            
            dwStartIndex = pcvp->idxCert;
        }
        else
        {
            pProvSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0);
            dwStartIndex = 0;
        }
    
        if (pProvSigner)
        {
            //
            // get all certs in the chain
            //
            for (i=dwStartIndex; i<pProvSigner->csCertChain && (i<dwStartIndex+MAX_CERT_CHAIN_LENGTH); i++)
            {
                pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts] = WTHelperGetProvCertFromChain(pProvSigner, i);
                if (pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts] != NULL)
                {
                    // Note, only modify this property when creating the
                    // chain for the original end cert. Subsequent CA
                    // chains won't have the ExtendedErrorInfo.

                    if ((pcvp->dwFlags & CRYPTUI_TREEVIEW_PAGE_FLAG) == 0)
                    {
                        // Either delete or set the
                        // CERT_EXTENDED_ERROR_INFO_PROP_ID

                        // This is used in cvdetail.cpp when displaying
                        // property details

                        PCRYPT_PROVIDER_CERT pProvCert =
                            pviewhelp->rgpCryptProviderCerts[
                                pviewhelp->cpCryptProviderCerts];

                        LPWSTR pwszExtErrorInfo = NULL; // not allocated
                        LPWSTR pwszRevStatus = NULL;    // LocalAlloc()'ed

                        if (pProvCert->cbStruct >
                                offsetof(CRYPT_PROVIDER_CERT, pChainElement)
                                        &&
                                NULL != pProvCert->pChainElement)
                        {
                            pwszExtErrorInfo = (LPWSTR)
                                pProvCert->pChainElement->pwszExtendedErrorInfo;
                            pwszRevStatus = FormatRevocationStatus(
                                pProvCert->pChainElement);

                            if (NULL == pwszExtErrorInfo)
                            {
                                pwszExtErrorInfo = pwszRevStatus;
                            }
                            else if (pwszRevStatus)
                            {
                                LPWSTR pwszReAlloc;
                                DWORD cchRevStatus;
                                DWORD cchExtErrorInfo;

                                cchRevStatus = wcslen(pwszRevStatus);
                                cchExtErrorInfo = wcslen(pwszExtErrorInfo);
                                pwszReAlloc = (LPWSTR) LocalReAlloc(
                                    pwszRevStatus,
                                    (cchRevStatus + cchExtErrorInfo + 1) *
                                        sizeof(WCHAR),
                                    LMEM_MOVEABLE);
                                if (pwszReAlloc)
                                {
                                    memcpy(&pwszReAlloc[cchRevStatus],
                                        pwszExtErrorInfo,
                                        (cchExtErrorInfo + 1) * sizeof(WCHAR));
                                    pwszExtErrorInfo = pwszRevStatus =
                                        pwszReAlloc;
                                }
                            }
                        }
                
                        if (pwszExtErrorInfo)
                        {
                            CRYPT_DATA_BLOB ExtErrorInfoBlob;

                            ExtErrorInfoBlob.pbData = (BYTE *) pwszExtErrorInfo;
                            ExtErrorInfoBlob.cbData =
                                (wcslen(pwszExtErrorInfo) + 1) * sizeof(WCHAR);

                            CertSetCertificateContextProperty(
                                pProvCert->pCert,
                                CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                &ExtErrorInfoBlob
                                );
                        }
                        else
                        {
                            CertSetCertificateContextProperty(
                                pProvCert->pCert,
                                CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                NULL            // pvData, NULL implies delete
                                );
                        }

                        if (pwszRevStatus)
                            LocalFree(pwszRevStatus);
                    }


                    pviewhelp->cpCryptProviderCerts++;
                }
            }
        }
    }
    
    CalculateUsages(pviewhelp);

    //
    // if the cert we are looking at is not the leaf cert, then we can't just take the
    // dwFinalError as the overall chain error, so find the over all chain error by
    // walking the chain and looking at the errors
    //
    if ((pcvp->pCryptProviderData != NULL) && (pcvp->idxCert != 0))
    {
        pviewhelp->dwChainError = GetFinalErrorFromChain(pviewhelp);  
    }

    //
    // if we are in the fWarnUntrustedRoot then check to see if the root cert is in the
    // remote machine's root store
    //
    if (pviewhelp->fWarnUntrustedRoot)
    {
        PCCERT_CONTEXT  pCertContext = NULL;
        CRYPT_HASH_BLOB cryptHashBlob;
        BYTE            hash[20];
        DWORD           cb = 20;

        pviewhelp->fRootInRemoteStore = FALSE;

        cryptHashBlob.cbData = 20;
        cryptHashBlob.pbData = &(hash[0]);

        if (CertGetCertificateContextProperty(
                pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts-1]->pCert,
                CERT_SHA1_HASH_PROP_ID,
                &(hash[0]),
                &cb))
        {

        
            pCertContext = CertFindCertificateInStore(
                                pviewhelp->pcvp->rghStores[0],
                                X509_ASN_ENCODING || PKCS_7_ASN_ENCODING,
                                0,
                                CERT_FIND_SHA1_HASH,
                                &cryptHashBlob,
                                NULL);

            if (pCertContext != NULL)
            {
                CertFreeCertificateContext(pCertContext);
                pviewhelp->fRootInRemoteStore = TRUE;
            }
        }
    }

    //
    // get the error string for the whole cert chain
    //
    if (!fInternalError)
    {
        GetCertChainErrorString(pviewhelp);
    }
    else
    {
        LoadStringU(HinstDll, IDS_INTERNAL_ERROR, szErrorString, ARRAYSIZE(szErrorString));
        pviewhelp->pwszErrorString = AllocAndCopyWStr(szErrorString);
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL CalculateUsages(PCERT_VIEW_HELPER pviewhelp)
{
    DWORD                               cLocalArrayOfUsages = 0;
    LPSTR                     *         localArrayOfUsages = NULL;
    BOOL                                fLocalUsagesAllocated = FALSE;
    DWORD                               i;
    HRESULT                             hr;
    BOOL                                fRet = TRUE;
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp = pviewhelp->pcvp;
    void                                *pTemp;

    //
    // if there are already usages, then clean them up before recalculating them, 
    // or just return if state was passed into CertUI
    //
    if (pviewhelp->cUsages != 0)
    {
        //
        // state was passed into the CertUI, so just return
        //
        if (pcvp->pCryptProviderData != NULL)
        {
            return TRUE;
        }

        //
        // cleanup usages that were generated prior to this call
        //
        for (i=0; i<pviewhelp->cUsages; i++)
        {
            free(pviewhelp->rgUsages[i]);
        }

        free(pviewhelp->rgUsages);   
    }

    //
    // initialize usage variables
    //
    pviewhelp->cUsages = 0;
    pviewhelp->rgUsages = NULL;
    
    //
    // if a provider was passed in, then we just look at it for the usage and structure
    // passed in for the trust of that usage,
    // otherwise we need to look at each usage and validate trust for all of them
    //
    if (pcvp->pCryptProviderData != NULL)
    {
        //
        // allocate an array of 1 LPSTR
        //
        if (NULL == (pviewhelp->rgUsages = (LPSTR *) malloc(sizeof(LPSTR))))
        {
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }

        //
        // copy either the 1 purpose that was passed in, or the purpose out of WinTrust state
        //
        if (pcvp->cPurposes == 1)
        {
            if (NULL == (pviewhelp->rgUsages[0] = (LPSTR) malloc(strlen(pcvp->rgszPurposes[0])+1)))
            {
                SetLastError(E_OUTOFMEMORY);
                return FALSE;
            }
            strcpy(pviewhelp->rgUsages[0], pcvp->rgszPurposes[0]);
        }
        else
        {
            if (NULL == (pviewhelp->rgUsages[0] = (LPSTR) malloc(strlen(pcvp->pCryptProviderData->pszUsageOID)+1)))
            {
                SetLastError(E_OUTOFMEMORY);
                return FALSE;
            }
            strcpy(pviewhelp->rgUsages[0], pcvp->pCryptProviderData->pszUsageOID);
        }

        pviewhelp->cUsages = 1;
    }
    else
    {
        //
        // check to see if usages where passed in, if so, then intersect those with 
        // available usages in the cert, otherwise, get the available usages in the cert
        // and use them as is 
        //
        if (pcvp->cPurposes != 0)
        {
            //
            // get the array of possible usages for the cert chain
            //

            // DSIE: Switch over to using pChainElement from philh's new chain building code.
            AllocAndReturnKeyUsageList(pviewhelp->rgpCryptProviderCerts[0], &localArrayOfUsages, &cLocalArrayOfUsages);  

            if (cLocalArrayOfUsages != 0)
                fLocalUsagesAllocated = TRUE;

            //
            // for each usage that was passed in check to see if it is in the list of possible usages
            //
            for (i=0; i<pcvp->cPurposes; i++)
            {   
                if (OIDinArray(pcvp->rgszPurposes[i], localArrayOfUsages, cLocalArrayOfUsages))
                {
                    //
                    // if an array hasn't yet been allocated, then allocate space for an array of
                    // 1 LPSTR, otherwise use realloc to add one more element
                    //
                    if (pviewhelp->rgUsages == NULL)
                    {
                        pviewhelp->rgUsages = (LPSTR *) malloc(sizeof(LPSTR));
                    }
                    else
                    {
                        pTemp = realloc(pviewhelp->rgUsages, sizeof(LPSTR) * (pviewhelp->cUsages+1));
                        if (pTemp == NULL)
                        {
                            free(pviewhelp->rgUsages);
                            pviewhelp->rgUsages = NULL;
                        }
                        else
                        {
                            pviewhelp->rgUsages = (LPSTR *) pTemp;
                        }
                    }

                    if (pviewhelp->rgUsages == NULL)
                    {
                        goto ErrorCleanUp;
                    }

                    //
                    // allocate space for the usage string, then copy it, and increment number of usages
                    //
                    if (NULL == (pviewhelp->rgUsages[pviewhelp->cUsages] = (LPSTR) malloc(strlen(pcvp->rgszPurposes[i])+1)))
                    {       
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorCleanUp;
                    }       
                    strcpy(pviewhelp->rgUsages[pviewhelp->cUsages], pcvp->rgszPurposes[i]);
                    pviewhelp->cUsages++;
                }
            }
        }
        else
        {
            AllocAndReturnKeyUsageList(pviewhelp->rgpCryptProviderCerts[0], &(pviewhelp->rgUsages), &(pviewhelp->cUsages));  
        }
    }

CleanUp:

    
    if (fLocalUsagesAllocated)
    {
        i = 0;
        while ((i < cLocalArrayOfUsages) && (localArrayOfUsages[i] != NULL))
        {
            free(localArrayOfUsages[i]);
            i++;
        }

        free(localArrayOfUsages);
    }

    return fRet;

ErrorCleanUp:

    if (pviewhelp->rgUsages != NULL)
    {
        i = 0;
        while ((i < pviewhelp->cUsages) && (pviewhelp->rgUsages[i] != NULL))
        {
            free(pviewhelp->rgUsages[i]);
            i++;
        }

        free(pviewhelp->rgUsages); 
    }

    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL BuildWinVTrustState(
                    LPCWSTR                         szFileName, 
                    CMSG_SIGNER_INFO const          *pSignerInfo,
                    DWORD                           cStores, 
                    HCERTSTORE                      *rghStores, 
                    LPCSTR                          pszOID,
                    PCERT_VIEWSIGNERINFO_PRIVATE    pcvsiPrivate, 
                    CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
                    WINTRUST_DATA                   *pWTD)
{
    WINTRUST_FILE_INFO      WTFI;
    WINTRUST_SGNR_INFO      WTSI;
    HRESULT                 hr;
    GUID                    defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    //
    // initialize structs that are used locally with WinVerifyTrust()
    //
    memset(pWTD, 0x00, sizeof(WINTRUST_DATA));
    pWTD->cbStruct       = sizeof(WINTRUST_DATA);
    pWTD->dwUIChoice     = WTD_UI_NONE;

    //
    // if the szFileName parameter is non NULL then this for a file,
    // otherwise it is for a signer info
    //
    if (szFileName != NULL)
    {
        pWTD->dwUnionChoice         = WTD_CHOICE_FILE;
        pWTD->pFile                 = &WTFI;
        pWTD->pPolicyCallbackData   = (void *) pszOID;

        memset(&WTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
        WTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
        WTFI.pcwszFilePath     = szFileName;
    }
    else
    {
        pWTD->dwUnionChoice         = WTD_CHOICE_SIGNER;
        pWTD->pSgnr                 = &WTSI;
        pWTD->pPolicyCallbackData   = (void *) pszOID;
        
        memset(&WTSI, 0x00, sizeof(WINTRUST_SGNR_INFO));
        WTSI.cbStruct          = sizeof(WINTRUST_SGNR_INFO);
        WTSI.pcwszDisplayName  = L"CryptUI";
        WTSI.psSignerInfo      = (CMSG_SIGNER_INFO *) pSignerInfo;  
        WTSI.chStores          = cStores;
        WTSI.pahStores         = rghStores;
        //WTSI.pszOID            = pszOID;
    }
    
    pWTD->pSIPClientData = NULL;
    pWTD->dwStateAction = WTD_STATEACTION_VERIFY;
    hr = WinVerifyTrustEx(NULL, &defaultProviderGUID, pWTD);
    if (hr == ERROR_SUCCESS)
    {
        pcvsiPrivate->fpCryptProviderDataTrustedUsage = TRUE;   
    }
    else
    {
        pcvsiPrivate->fpCryptProviderDataTrustedUsage = FALSE;   
    }
    
    pcvsiPrivate->pCryptProviderData = WTHelperProvDataFromStateData(pWTD->hWVTStateData);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL FreeWinVTrustState(
                    LPCWSTR                         szFileName, 
                    CMSG_SIGNER_INFO const          *pSignerInfo,
                    DWORD                           cStores, 
                    HCERTSTORE                      *rghStores, 
                    LPCSTR                          pszOID,
                    CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
                    WINTRUST_DATA                   *pWTD)//,
                    //BOOL                            *pfUseDefaultProvider)
{
    WINTRUST_FILE_INFO      WTFI;
    WINTRUST_SGNR_INFO      WTSI;
    HRESULT                 hr;
    GUID                    defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    // initialize structs that are used locally with WinVerifyTrust()
    memset(pWTD, 0x00, sizeof(WINTRUST_DATA));
    pWTD->cbStruct       = sizeof(WINTRUST_DATA);
    pWTD->dwUIChoice     = WTD_UI_NONE;
    
    //
    // if the szFileName parameter is non NULL then this for a file,
    // otherwise it is for a signer info
    //
    if (szFileName != NULL)
    {
        pWTD->dwUnionChoice  = WTD_CHOICE_FILE;
        pWTD->pFile          = &WTFI;

        memset(&WTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
        WTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
        WTFI.pcwszFilePath     = szFileName;
    }
    else
    {
        pWTD->dwUnionChoice  = WTD_CHOICE_SIGNER;
        pWTD->pSgnr          = &WTSI;

        memset(&WTSI, 0x00, sizeof(WINTRUST_SGNR_INFO));
        WTSI.cbStruct          = sizeof(WINTRUST_SGNR_INFO);
        WTSI.psSignerInfo      = (CMSG_SIGNER_INFO *) pSignerInfo;
        WTSI.chStores          = cStores;
        WTSI.pahStores         = rghStores;
    }

    /*if (*pfUseDefaultProvider)
    {
        pWTD->dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &defaultProviderGUID, pWTD);
    }
    else
    {*/
        pWTD->dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &(pCryptProviderDefUsage->gActionID), pWTD);
        WintrustGetDefaultForUsage(DWACTION_FREE, pszOID, pCryptProviderDefUsage);
    //}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\pwdui.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    pwdui.c

Abstract:

    This module contains routines for displaying Data Protection API
    related UI, originating from client process address space.

    For the future, there is support planned for causing UI to originate
    from the secure desktop, via Secure Authentication Sequence (SAS).

Author:

    Scott Field (sfield)    12-May-99

--*/

#define UNICODE
#define _UNICODE


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <sha.h>
#include <unicode5.h>

#include "resource.h"

#include "pwdui.h"


typedef struct {
    DATA_BLOB *pDataIn;                         // input DATA_BLOB* to CryptProtect or CryptUnprotect
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;   // PromptStruct describing UI operations to perform
    LPWSTR szDataDescription;                   // Application supplied data descr
    PBYTE rgbPasswordHash;                      // resultant passwordhash for strong security
    BOOL fCachedPassword;                       // did we find password in cache?
    BOOL fProtect;                              // protect or unprotect?
    BOOL fValidPassword;                        // does rgbPasswordHash contain a valid value?
} DIALOGARGS, *PDIALOGARGS, *LPDIALOGARGS;


typedef struct {
    LIST_ENTRY Next;
    LUID LogonId;
    FILETIME ftLastAccess;
    BYTE rgbDataInHash[A_SHA_DIGEST_LEN];
    BYTE rgbPasswordHash[A_SHA_DIGEST_LEN];
} PASSWORD_CACHE_ENTRY, *PPASSWORD_CACHE_ENTRY, *LPPASSWORD_CACHE_ENTRY;



DWORD
ProtectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    );

DWORD
UnprotectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    );

BOOL
ChooseSecurityLevel(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    );

VOID
AdvancedSecurityDetails(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    );

//
// dialog box handling routines.
//

INT_PTR
CALLBACK
DialogConfirmProtect(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogConfirmAccess(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevel(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevelMedium(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevelHigh(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogAdvancedSecurityDetails(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );


//
// helper routines.
//

#ifndef SSAlloc
#define SSAlloc(x) LocalAlloc(LMEM_FIXED, x)
#endif

#ifndef SSFree
#define SSFree(x) LocalFree(x)
#endif

VOID
ComputePasswordHash(
    IN      PVOID pvPassword,
    IN      DWORD cbPassword,
    IN OUT  BYTE rgbPasswordHash[A_SHA_DIGEST_LEN]
    );

BOOL
GetEffectiveLogonId(
    IN OUT  LUID *pLogonId
    );

BOOL
InitializeDetailGlobals(
    VOID
    );


//
// password cache related routines.
//

BOOL
InitializeProtectPasswordCache(
    VOID
    );

VOID
DeleteProtectPasswordCache(
    VOID
    );

BOOL
AddProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN      BYTE rgbPassword[A_SHA_DIGEST_LEN]
    );

BOOL
SearchProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN OUT  BYTE rgbPassword[A_SHA_DIGEST_LEN],
    IN      BOOL fDeleteFoundEntry
    );

VOID
PurgeProtectPasswordCache(
    VOID
    );

BOOL
IsCachePWAllowed(
    VOID
    );



//
// global variables.
//

HINSTANCE g_hInstProtectUI;
CRITICAL_SECTION g_csProtectPasswordCache;
LIST_ENTRY g_ProtectPasswordCache;

#define ALLOW_CACHE_UNKNOWN 0
#define ALLOW_CACHE_NO 1
#define ALLOW_CACHE_YES 2

DWORD g_dwAllowCachePW = 0;
WCHAR g_szGooPassword[] = L"(*&#$(^(#%^))(*&(^(*{}_SAF^^%";

BOOL g_fDetailGlobalsInitialized = FALSE;
LPWSTR g_szDetailApplicationName = NULL;
LPWSTR g_szDetailApplicationPath = NULL;


BOOL
WINAPI
ProtectUI_DllMain(
    HINSTANCE hinstDLL, // handle to DLL module
    DWORD fdwReason,    // reason for calling function
    LPVOID lpvReserved  // reserved
    )
{
    BOOL fRet = TRUE;

    if( fdwReason == DLL_PROCESS_ATTACH ) {
        g_hInstProtectUI = hinstDLL;
        fRet = InitializeProtectPasswordCache();
    } else if ( fdwReason == DLL_PROCESS_DETACH ) {
        DeleteProtectPasswordCache();
    }

    return fRet;
}

DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    )
{
    DIALOGARGS DialogArgs;
    DWORD dwLastError = ERROR_SUCCESS;

    DATA_BLOB* pDataIn = (DATA_BLOB*)pvReserved1;
    CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct = (CRYPTPROTECT_PROMPTSTRUCT*)pvReserved2;
    DWORD dwFlags = (DWORD)dwReserved3;
    LPCWSTR szDescription = (LPCWSTR)*pvReserved4;
    BOOL fProtectOperation = (BOOL)fReserved5;
    PBYTE rgbPasswordHash = (PBYTE)pvReserved6;
    BOOL fEmptyDescription;


    //
    // for protect:
    // szDescription, if NULL or empty, get from user
    // if PROMPT_STRONG is set, grey out medium security.
    //
    // for unprotect:
    // szDescription, get from datablob.
    // pPromptStruct->dwPromptFlags from datablob.
    // if PROMPT_STRONG is set, enable password field and
    //

    if( pPromptStruct == NULL )
        return ERROR_INVALID_PARAMETER;

    if( pPromptStruct->cbSize != sizeof( CRYPTPROTECT_PROMPTSTRUCT) )
        return ERROR_INVALID_PARAMETER;

    if( fProtectOperation ) {

        //
        // if unprotect was specified, protect is implicitly specified.
        // vice-versa is true, too.
        //

        if ( ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT) == 0) &&
             ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) == 0)
             )
        {
            //
            // nothing to do, bail out.
            //

            return ERROR_SUCCESS;
        }

        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_ON_PROTECT;
        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_ON_UNPROTECT;

    }


    if ( dwFlags & CRYPTPROTECT_UI_FORBIDDEN ) {
        return ERROR_PASSWORD_RESTRICTION;
    }



    //
    // build dialog box arguments block.
    //

    DialogArgs.pDataIn = pDataIn;

    DialogArgs.pPromptStruct = pPromptStruct;

    if( szDescription != NULL && szDescription[0] != L'\0' ) {
        DialogArgs.szDataDescription = (LPWSTR)szDescription;
        fEmptyDescription = FALSE;
    } else {
        DialogArgs.szDataDescription = NULL;
        fEmptyDescription = TRUE;
    }


    DialogArgs.rgbPasswordHash = rgbPasswordHash;
    DialogArgs.fCachedPassword = FALSE;
    DialogArgs.fProtect = fProtectOperation;
    DialogArgs.fValidPassword = FALSE;


    if( fProtectOperation ) {

        //
        // now, throw the UI for the protect operation.
        //

        dwLastError = ProtectUIConfirm( &DialogArgs );

        if( dwLastError == ERROR_SUCCESS && fEmptyDescription &&
            DialogArgs.szDataDescription ) {

            //
            // output modified data description to caller.
            //

            *pvReserved4 = DialogArgs.szDataDescription;
        }
    } else {

        //
        // now, throw the UI for the unprotect operation.
        //
        dwLastError = UnprotectUIConfirm( &DialogArgs );
    }

    if( fEmptyDescription && dwLastError != ERROR_SUCCESS &&
        DialogArgs.szDataDescription ) {

        SSFree( DialogArgs.szDataDescription );
    }

    return dwLastError;
}


DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3)
{
    CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct = (CRYPTPROTECT_PROMPTSTRUCT*)pvReserved1;
    DWORD dwFlags = (DWORD)dwReserved2;
    LPCWSTR szDescription = (LPCWSTR)*pvReserved3;
    WCHAR szTitle[512];
    WCHAR szText[512];

    if((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) == 0)
    {
        return ERROR_SUCCESS;
    }

    if(dwFlags & CRYPTPROTECT_UI_FORBIDDEN)
    {
        return ERROR_PASSWORD_RESTRICTION;
    }

    LoadStringU(g_hInstProtectUI, IDS_PROTECT_DECRYPTION_ERROR, szTitle, sizeof(szTitle)/sizeof(WCHAR));
    LoadStringU(g_hInstProtectUI, IDS_PROTECT_CANNOT_DECRYPT, szText, sizeof(szText)/sizeof(WCHAR));
    MessageBoxU(pPromptStruct->hwndApp, szText, szTitle, MB_OK | MB_ICONWARNING);

    return ERROR_SUCCESS;
}


DWORD
ProtectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    )
{
    INT_PTR iRet;

    iRet = DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_CONFIRM_PROTECT),
                    pDialogArgs->pPromptStruct->hwndApp,
                    DialogConfirmProtect,
                    (LPARAM)pDialogArgs
                    );



    return (DWORD)iRet;

}


DWORD
UnprotectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    )
{
    INT_PTR iRet;

    iRet = DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_CONFIRM_SECURITY),
                    pDialogArgs->pPromptStruct->hwndApp,
                    DialogConfirmAccess,
                    (LPARAM)pDialogArgs
                    );

    return (DWORD)iRet;
}

INT_PTR
CALLBACK
DialogConfirmProtect(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    DIALOGARGS *pDialogArgs;
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

    switch (message)
    {
        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, GetLastError());
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS *
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            //
            // set the dialog title
            //

            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            //
            // display dynamic stuff.
            //

            SendMessage( hDlg, WM_COMMAND, IDC_PROTECT_UPDATE_DYNAMIC, 0 );

            return FALSE; // don't default the Focus..
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    EndDialog(hDlg, ERROR_SUCCESS);
                    return TRUE;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, ERROR_CANCELLED);
                    return TRUE;
                }

                case IDC_PROTECT_ADVANCED:
                {

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    //
                    // show details dialog.
                    //

                    AdvancedSecurityDetails(
                            hDlg,
                            pDialogArgs
                            );

                    return FALSE;
                }

                case IDC_PROTECT_UPDATE_DYNAMIC:
                {
                    WCHAR szResource[ 256 ];
                    int cchResource = sizeof(szResource) / sizeof(WCHAR);
                    UINT ResourceId;

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out


                    pPromptStruct = pDialogArgs->pPromptStruct;

                    //
                    // description.
                    //

                    SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_LABEL_EDIT1), pDialogArgs->szDataDescription);

                    // Disable the OK button if we're defaulting to strong protection,
                    // unless a password has already been set.
                    if((pPromptStruct->dwPromptFlags & (CRYPTPROTECT_PROMPT_STRONG |
                                                        CRYPTPROTECT_PROMPT_REQUIRE_STRONG)) &&
                       (pDialogArgs->fValidPassword == FALSE))
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
                        SendMessage(hDlg, DM_SETDEFID, IDC_PROTECT_CHANGE_SECURITY, 0);
                        SetFocus(GetDlgItem(hDlg, IDC_PROTECT_CHANGE_SECURITY));
                    }
                    else
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                        SendMessage(hDlg, DM_SETDEFID, IDOK,0);
                        SetFocus(GetDlgItem(hDlg, IDOK));
                    }

                    //
                    // security level.
                    //

                    if( pPromptStruct->dwPromptFlags & (CRYPTPROTECT_PROMPT_STRONG | 
                                                        CRYPTPROTECT_PROMPT_REQUIRE_STRONG))
                    {
                        ResourceId = IDS_PROTECT_SECURITY_LEVEL_SET_HIGH;
                    } else {
                        ResourceId = IDS_PROTECT_SECURITY_LEVEL_SET_MEDIUM;
                    }

                    cchResource = LoadStringU(g_hInstProtectUI,
                                            ResourceId,
                                            szResource,
                                            cchResource
                                            );

                    SetWindowTextU( GetDlgItem(hDlg,IDC_PROTECT_SECURITY_LEVEL),
                                    szResource
                                    );

                    return FALSE;
                }

                case IDC_PROTECT_CHANGE_SECURITY:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out


                    //
                    // spawn child dialog to handle prompting for security level.
                    //

                    if(!ChooseSecurityLevel( hDlg, pDialogArgs )) {
                        EndDialog(hDlg, ERROR_CANCELLED);
                        return TRUE;
                    }

                    //
                    // display dynamic stuff that may have changed.
                    //

                    SendMessage( hDlg, WM_COMMAND, IDC_PROTECT_UPDATE_DYNAMIC, 0 );
                    break;
                }

                default:
                {
                    return FALSE;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogConfirmAccess(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    DIALOGARGS *pDialogArgs;
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

    switch (message)
    {
        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, GetLastError());
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS *
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            //
            // set the dialog title
            //

            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            //
            // description.
            //

            SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_LABEL_EDIT1), pDialogArgs->szDataDescription);


            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {

                //
                // If policy doesn't allow, disable caching of password.
                //
                // Otherwise, search password cache to see if user cached password
                // for this item.
                //

                if( g_dwAllowCachePW == ALLOW_CACHE_UNKNOWN )
                {
                    if(!IsCachePWAllowed()) {
                        g_dwAllowCachePW = ALLOW_CACHE_NO;
                    } else {
                        g_dwAllowCachePW = ALLOW_CACHE_YES;
                    }
                }

                if((g_dwAllowCachePW == ALLOW_CACHE_NO) || 
                   (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG))
                {
                    ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), SW_HIDE );
                    EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), FALSE );

                } else if(SearchProtectPasswordCache( pDialogArgs->pDataIn, pDialogArgs->rgbPasswordHash, FALSE ))
                {
                    //
                    // enable checkbox for cached password, fill edit control
                    // with password.
                    //

                    SetWindowTextU(GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                   g_szGooPassword
                                   );

                    SendMessage(GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), BM_SETCHECK, BST_CHECKED, 0);
                    pDialogArgs->fCachedPassword = TRUE;
                    pDialogArgs->fValidPassword = TRUE;

                }
            } else {

                //
                // disable irrelevant fields in dialog.
                //

                ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), SW_HIDE );
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), FALSE );

                ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_PASSWORD1), SW_HIDE );
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_PASSWORD1), FALSE );
            }

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
                    {
                        WCHAR szPassword[ 256 ];
                        int cchPassword = sizeof(szPassword) / sizeof(WCHAR);

                        BOOL fCachePassword;

                        //
                        // check if remember password is checked.
                        // if so, check if password is untypable goo.
                        //

                        if( g_dwAllowCachePW != ALLOW_CACHE_NO &&
                            (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), BM_GETCHECK, 0, 0))
                            )
                        {
                            fCachePassword = TRUE;
                        } else {
                            fCachePassword = FALSE;
                        }


                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                        szPassword,
                                        cchPassword
                                        );

                        if( !fCachePassword && pDialogArgs->fCachedPassword ) {

                            //
                            // user un-checked cachePW button, and item was cached.
                            // remove it from cache.
                            //

                            SearchProtectPasswordCache(
                                            pDialogArgs->pDataIn,
                                            pDialogArgs->rgbPasswordHash,
                                            TRUE
                                            );
                        }

                        if(
                            pDialogArgs->fCachedPassword &&
                            (cchPassword*sizeof(WCHAR) == sizeof(g_szGooPassword)-sizeof(WCHAR)) &&
                            (memcmp(szPassword, g_szGooPassword, cchPassword*sizeof(WCHAR)) == 0)
                            )
                        {
                            //
                            // nothing to do, rgbPasswordHash was updated by
                            // cache search...
                            //


                        } else {

                            ComputePasswordHash(
                                        szPassword,
                                        (DWORD)(cchPassword * sizeof(WCHAR)),
                                        pDialogArgs->rgbPasswordHash
                                        );
                            pDialogArgs->fValidPassword = TRUE;

                            //
                            // if user chose to cache password, add it.
                            //

                            if( fCachePassword )
                            {
                                AddProtectPasswordCache(
                                            pDialogArgs->pDataIn,
                                            pDialogArgs->rgbPasswordHash
                                            );
                            }
                        }
                    }

                    EndDialog(hDlg, ERROR_SUCCESS);
                    return TRUE;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, ERROR_CANCELLED);
                    return TRUE;
                }

                case IDC_PROTECT_ADVANCED:
                {

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    //
                    // show details dialog.
                    //

                    AdvancedSecurityDetails(
                            hDlg,
                            pDialogArgs
                            );

                    return FALSE;
                }

                default:
                {
                    return FALSE;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}


//
// security level chooser routines.
//

BOOL
ChooseSecurityLevel(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    )
{
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;
    DWORD dwOriginalPromptFlags;
    BOOL fEmptyDescription;
    INT_PTR iRet;


    pPromptStruct = pDialogArgs->pPromptStruct;
    dwOriginalPromptFlags = pPromptStruct->dwPromptFlags;
    fEmptyDescription = (pDialogArgs->szDataDescription == NULL);


Step1:

    if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG)
    {
        //
        // Force strong protection.
        //

        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_STRONG;
    }
    else
    {
        // 
        // The "require strong" flag is not set, so allow the user to select
        // between medium and strong protection.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY),
                        hWndParent,
                        DialogChooseSecurityLevel,
                        (LPARAM)pDialogArgs
                        );
    
        // if user decides not to choose, bail
    
        if( iRet == IDCANCEL )
            return TRUE;
    
        if( iRet != IDOK )
            return FALSE;
    }

    if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {

        //
        // display dialog 'page' confirming high security.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY_H),
                        hWndParent,
                        DialogChooseSecurityLevelHigh,
                        (LPARAM)pDialogArgs
                        );

    } else {

        //
        // display dialog 'page' confirming medium security.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY_M),
                        hWndParent,
                        DialogChooseSecurityLevelMedium,
                        (LPARAM)pDialogArgs
                        );
    }

    if( iRet == IDC_PROTECT_BACK ) {

        //
        // put original prompt flags back so we don't end up with undefined
        // pwd at high-security level.
        // free allocated description if that happened, too.
        //

        pPromptStruct->dwPromptFlags = dwOriginalPromptFlags;
        if( fEmptyDescription && pDialogArgs->szDataDescription ) {
            SSFree( pDialogArgs->szDataDescription );
            pDialogArgs->szDataDescription = NULL;
        }

        goto Step1;
    }

    if( iRet != IDOK )
        return FALSE;

    return TRUE;
}




INT_PTR
CALLBACK
DialogChooseSecurityLevel(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;
        DIALOGARGS *pDialogArgs;

        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*

            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {
                SendDlgItemMessage(hDlg, IDC_PROTECT_RADIO_HIGH, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_PROTECT_RADIO_HIGH, 0);
            } else {
                SendDlgItemMessage(hDlg, IDC_PROTECT_RADIO_MEDIUM, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_PROTECT_RADIO_MEDIUM, 0);
            }

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {

            switch (LOWORD(wParam))
            {
                case IDC_PROTECT_NEXT:
                case IDOK:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    if (BST_CHECKED == SendDlgItemMessageW(
                                                    hDlg,
                                                    IDC_PROTECT_RADIO_HIGH,
                                                    BM_GETCHECK,
                                                    0,
                                                    0
                                                    ))
                    {
                        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_STRONG;
                    } else {
                        pPromptStruct->dwPromptFlags &= ~(CRYPTPROTECT_PROMPT_STRONG);
                    }

                    break;
                }

                default:
                {
                    break;
                }
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_PROTECT_NEXT)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogChooseSecurityLevelMedium(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            DIALOGARGS *pDialogArgs;
            CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_PROTECT_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogChooseSecurityLevelHigh(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        DIALOGARGS *pDialogArgs;
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            // Disable <Back and Finished buttons
            if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG)
            {
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_BACK), FALSE );
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
            }

            //
            // description.
            //

            if( pDialogArgs->szDataDescription ) {

                HWND hwndProtectEdit1 = GetDlgItem( hDlg, IDC_PROTECT_PASSWORD1 );

                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_PW_NEWNAME), pDialogArgs->szDataDescription);

                //
                // set focus to Password entry box.
                //

                EnableWindow(hwndProtectEdit1, TRUE);
                SetFocus(hwndProtectEdit1);

                //
                // default dialog template disabled input.
                //

            } else {

                HWND hwndProtectPWNew = GetDlgItem( hDlg, IDC_PROTECT_PW_NEWNAME );

                //
                // enable edit box entry.
                //

                EnableWindow(hwndProtectPWNew, TRUE);

                //
                // set focus to description box
                //

                SetFocus(hwndProtectPWNew);
            }

            return FALSE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    WCHAR szPassword[ 256 ];
                    int cchPassword;
                    BYTE rgbPasswordHashConfirm[A_SHA_DIGEST_LEN];
                    BOOL fPasswordsMatch = TRUE; // assume passwords match.

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    //
                    // nothing more to do if not STRONG
                    //

                    if( (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG) == 0 ) {
                        EndDialog( hDlg, IDOK );
                    }


                    cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                    cchPassword = GetWindowTextU(
                                    GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                    szPassword,
                                    cchPassword
                                    );

                    ComputePasswordHash(
                                    szPassword,
                                    cchPassword * sizeof(WCHAR),
                                    pDialogArgs->rgbPasswordHash
                                    );

                    ZeroMemory( szPassword, cchPassword*sizeof(WCHAR) );

                    cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                    cchPassword = GetWindowTextU(
                                    GetDlgItem(hDlg,IDC_PROTECT_EDIT2),
                                    szPassword,
                                    cchPassword
                                    );

                    ComputePasswordHash(
                                    szPassword,
                                    cchPassword * sizeof(WCHAR),
                                    rgbPasswordHashConfirm
                                    );

                    ZeroMemory( szPassword, cchPassword*sizeof(WCHAR) );


                    //
                    // check if both passwords entered by user match.
                    //

                    if( memcmp(rgbPasswordHashConfirm, pDialogArgs->rgbPasswordHash, sizeof(rgbPasswordHashConfirm)) != 0 )
                    {
                        fPasswordsMatch = FALSE;
                    }

                    ZeroMemory( rgbPasswordHashConfirm, sizeof(rgbPasswordHashConfirm) );

                    if( !fPasswordsMatch )
                    {
                        WCHAR szText[256];
                        WCHAR szCaption[256];

                        //
                        // passwords must match: tell user.
                        //

                        LoadStringU(g_hInstProtectUI,
                                    IDS_PROTECT_PASSWORD_NOMATCH,
                                    szText,
                                    sizeof(szText) / sizeof(WCHAR)
                                    );

                        LoadStringU(g_hInstProtectUI,
                                    IDS_PROTECT_PASSWORD_ERROR_DLGTITLE,
                                    szCaption,
                                    sizeof(szCaption) / sizeof(WCHAR)
                                    );

                        MessageBoxW(hDlg,
                                    szText,
                                    szCaption,
                                    MB_OK | MB_ICONEXCLAMATION
                                    );

                        return FALSE;
                    }

                    //
                    // if no description provided, make sure user entered one,
                    // and grab it..
                    //

                    if( pDialogArgs->szDataDescription == NULL ) {
                        cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PW_NEWNAME),
                                        szPassword,
                                        cchPassword
                                        );

                        if( cchPassword == 0 ) {

                            WCHAR szText[256];
                            WCHAR szCaption[256];

                            //
                            // password must be named: tell user.
                            //

                            LoadStringU(g_hInstProtectUI,
                                        IDS_PROTECT_PASSWORD_MUSTNAME,
                                        szText,
                                        sizeof(szText) / sizeof(WCHAR)
                                        );

                            LoadStringU(g_hInstProtectUI,
                                        IDS_PROTECT_PASSWORD_ERROR_DLGTITLE,
                                        szCaption,
                                        sizeof(szCaption) / sizeof(WCHAR)
                                        );

                            MessageBoxW(hDlg,
                                        szText,
                                        szCaption,
                                        MB_OK | MB_ICONEXCLAMATION
                                        );

                            return FALSE;
                        }

                        pDialogArgs->szDataDescription = (LPWSTR)SSAlloc( (cchPassword+1) * sizeof(WCHAR) );
                        if( pDialogArgs->szDataDescription == NULL )
                            return FALSE;

                        CopyMemory( pDialogArgs->szDataDescription, szPassword, cchPassword*sizeof(WCHAR) );
                        (pDialogArgs->szDataDescription)[cchPassword] = L'\0';
                    }

                    pDialogArgs->fValidPassword = TRUE;

                    EndDialog(hDlg, IDOK);
                    return TRUE;
                }

                case IDC_PROTECT_PASSWORD1:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out
    
                    pPromptStruct = pDialogArgs->pPromptStruct;
    
                    if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG) 
                    {
                        WCHAR szPassword[ 256 ];
                        int cchPassword;
    
                        //
                        // Disable the Finish button until a password has been entered.
                        //
    
                        cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                        szPassword,
                                        cchPassword
                                        );
                        if(cchPassword)
                        {
                            ZeroMemory(szPassword, cchPassword * sizeof(WCHAR));
                            EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                        }
                    }
                    break;
                }


                case IDC_PROTECT_BACK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                }

                default:
                {
                    break;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}



VOID
AdvancedSecurityDetails(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    )
{
    DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_SECURITY_DETAILS),
                    hWndParent,
                    DialogAdvancedSecurityDetails,
                    (LPARAM)pDialogArgs
                    );
}


INT_PTR
CALLBACK
DialogAdvancedSecurityDetails(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
   switch (message) {

        DIALOGARGS *pDialogArgs;
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

        case WM_INITDIALOG:
        {
            WCHAR szResource[ 256 ];
            UINT ResourceId;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            InitializeDetailGlobals();

            if(g_szDetailApplicationPath)
            {
                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_APP_PATH), g_szDetailApplicationPath);
            }

            if( pDialogArgs->fProtect ) {
                ResourceId = IDS_PROTECT_OPERATION_PROTECT;
            } else {
                ResourceId = IDS_PROTECT_OPERATION_UNPROTECT;
            }

            LoadStringU(g_hInstProtectUI,
                        ResourceId,
                        szResource,
                        sizeof(szResource) / sizeof(WCHAR)
                        );

            SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_OPERATION_TYPE), szResource);



            if( pDialogArgs->szDataDescription ) {
                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_APP_DESCRIPTION), pDialogArgs->szDataDescription);
            }
            return FALSE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                }

                default:
                {
                    break;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }

    } // switch

    return FALSE;
}

VOID
ComputePasswordHash(
    IN      PVOID pvPassword,
    IN      DWORD cbPassword,
    IN OUT  BYTE rgbPasswordHash[A_SHA_DIGEST_LEN]
    )
/*++

    Compute SHA-1 hash of supplied pvPassword of size cbPassword, returning
    resultant hash in rgbPasswordHash buffer.

--*/
{
    A_SHA_CTX shaCtx;

    if( pvPassword == NULL )
        return;

    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pvPassword, (unsigned int)cbPassword );
    A_SHAFinal( &shaCtx, rgbPasswordHash );

    ZeroMemory( &shaCtx, sizeof(shaCtx) );

    return;
}

BOOL
GetEffectiveLogonId(
    IN OUT  LUID *pLogonId
    )
{
    HANDLE hToken;
    TOKEN_STATISTICS TokenInformation;
    DWORD cbTokenInformation;
    BOOL fSuccess;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {
        if(GetLastError() != ERROR_NO_TOKEN)
            return FALSE;

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            return FALSE;
    }


    fSuccess = GetTokenInformation(
                    hToken,
                    TokenStatistics,
                    &TokenInformation,
                    sizeof(TokenInformation),
                    &cbTokenInformation
                    );

    CloseHandle( hToken );

    if( fSuccess ) {
        CopyMemory( pLogonId, &TokenInformation.AuthenticationId, sizeof(*pLogonId) );
    }

    return fSuccess;
}


BOOL
InitializeDetailGlobals(
    VOID
    )
{
    WCHAR szStackBuffer[ 256 ];
    DWORD cchStackBuffer;

    LPWSTR szDetailApplicationName = NULL;
    LPWSTR szDetailApplicationPath = NULL;

    if( g_fDetailGlobalsInitialized )
        return TRUE;

    cchStackBuffer = sizeof(szStackBuffer) / sizeof(WCHAR);
    cchStackBuffer = GetModuleFileNameU( NULL, szStackBuffer, cchStackBuffer );

    if( cchStackBuffer ) {

        cchStackBuffer++; // include terminal NULL.

        szDetailApplicationPath = (LPWSTR)SSAlloc( cchStackBuffer * sizeof(WCHAR) );

        if( szDetailApplicationPath ) {
            CopyMemory( szDetailApplicationPath, szStackBuffer, cchStackBuffer*sizeof(WCHAR) );
        }
    }

    EnterCriticalSection( &g_csProtectPasswordCache );

    if( !g_fDetailGlobalsInitialized ) {

        g_szDetailApplicationName = szDetailApplicationName;
        g_szDetailApplicationPath = szDetailApplicationPath;
        g_fDetailGlobalsInitialized = TRUE;

        szDetailApplicationName = NULL;
        szDetailApplicationPath = NULL;
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    if( szDetailApplicationName )
        SSFree( szDetailApplicationName );

    if( szDetailApplicationPath )
        SSFree( szDetailApplicationPath );

    return TRUE;
}


BOOL
InitializeProtectPasswordCache(
    VOID
    )
{
    __try
    {
        InitializeCriticalSection( &g_csProtectPasswordCache );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        memset(&g_csProtectPasswordCache, 0, sizeof(g_csProtectPasswordCache));
        SetLastError(GetExceptionCode());
        return FALSE;
    }

    InitializeListHead( &g_ProtectPasswordCache );

    g_fDetailGlobalsInitialized = FALSE;
    g_szDetailApplicationName = NULL;
    g_szDetailApplicationPath = NULL;

    return TRUE;
}

VOID
DeleteProtectPasswordCache(
    VOID
    )
{

    if( g_szDetailApplicationName )
    {
        SSFree(g_szDetailApplicationName);
        g_szDetailApplicationName = NULL;
    }

    if( g_szDetailApplicationPath )
    {
        SSFree(g_szDetailApplicationPath);
        g_szDetailApplicationPath = NULL;
    }

    g_fDetailGlobalsInitialized = FALSE;

    EnterCriticalSection( &g_csProtectPasswordCache );

    while ( !IsListEmpty( &g_ProtectPasswordCache ) ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;

        pCacheEntry = CONTAINING_RECORD(
                                g_ProtectPasswordCache.Flink,
                                PASSWORD_CACHE_ENTRY,
                                Next
                                );

        RemoveEntryList( &pCacheEntry->Next );

        ZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
        SSFree( pCacheEntry );
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    DeleteCriticalSection( &g_csProtectPasswordCache );
}

BOOL
AddProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN      BYTE rgbPassword[A_SHA_DIGEST_LEN]
    )
{
    PPASSWORD_CACHE_ENTRY pCacheEntry = NULL;
    A_SHA_CTX shaCtx;


    pCacheEntry = (PPASSWORD_CACHE_ENTRY)SSAlloc( sizeof(PASSWORD_CACHE_ENTRY) );
    if( pCacheEntry == NULL )
        return FALSE;

    GetEffectiveLogonId( &pCacheEntry->LogonId );
    GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pDataIn->pbData, pDataIn->cbData );
    A_SHAFinal( &shaCtx, pCacheEntry->rgbDataInHash );
    ZeroMemory( &shaCtx, sizeof(shaCtx) );

    CopyMemory( pCacheEntry->rgbPasswordHash, rgbPassword, A_SHA_DIGEST_LEN );


    EnterCriticalSection( &g_csProtectPasswordCache );

    InsertHeadList( &g_ProtectPasswordCache, &pCacheEntry->Next );

    LeaveCriticalSection( &g_csProtectPasswordCache );

    return TRUE;
}

BOOL
SearchProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN OUT  BYTE rgbPassword[A_SHA_DIGEST_LEN],
    IN      BOOL fDeleteFoundEntry
    )
{

    A_SHA_CTX shaCtx;
    BYTE rgbDataInHashCandidate[A_SHA_DIGEST_LEN];
    LUID LogonIdCandidate;

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    BOOL fFoundMatch = FALSE;

    if(!GetEffectiveLogonId( &LogonIdCandidate ))
        return FALSE;


    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pDataIn->pbData, pDataIn->cbData );
    A_SHAFinal( &shaCtx, rgbDataInHashCandidate );


    EnterCriticalSection( &g_csProtectPasswordCache );

    ListHead = &g_ProtectPasswordCache;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, PASSWORD_CACHE_ENTRY, Next );

        //
        // search by hash, then LogonId
        // note that most usage scenarios, all cache entries will correspond
        // to same LogonId.
        //

        comparator = memcmp( rgbDataInHashCandidate, pCacheEntry->rgbDataInHash, sizeof(rgbDataInHashCandidate) );

        if( comparator != 0 )
            continue;


        comparator = memcmp(&LogonIdCandidate, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator != 0 )
            continue;


        //
        // match found.
        //

        fFoundMatch = TRUE;

        if( fDeleteFoundEntry ) {
            RemoveEntryList( &pCacheEntry->Next );
            ZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
            SSFree( pCacheEntry );
        } else {


            CopyMemory( rgbPassword, pCacheEntry->rgbPasswordHash, A_SHA_DIGEST_LEN );

            //
            // update last access time.
            //

            GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );
        }

        break;
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    PurgeProtectPasswordCache();

    return fFoundMatch;
}

VOID
PurgeProtectPasswordCache(
    VOID
    )
/*++

    This routine purges entries in the password cache that are greater than
    1 hour in age, via the ftLastAccess time.

--*/
{
//    static FILETIME ftLastPurge = {0xffffffff,0xffffffff};
    static FILETIME ftLastPurge;
    FILETIME ftStaleEntry;

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    unsigned __int64 ui64;

    //
    // get current time, and subtract an hour off it.
    //

    GetSystemTimeAsFileTime( &ftStaleEntry );


    ui64 = ftStaleEntry.dwHighDateTime;
    ui64 <<= 32;
    ui64 |= ftStaleEntry.dwLowDateTime;

//    ui64 -= (600000000*60);
    ui64 -= 0x861c46800;

    ftStaleEntry.dwLowDateTime = (DWORD)(ui64 & 0xffffffff);
    ftStaleEntry.dwHighDateTime = (DWORD)(ui64 >> 32);



    //
    // only purge list once per hour.
    //

    if( CompareFileTime( &ftStaleEntry, &ftLastPurge ) < 0 ) {
        return;
    }


    //
    // update last purge time.
    //

    GetSystemTimeAsFileTime( &ftLastPurge );

    EnterCriticalSection( &g_csProtectPasswordCache );

    ListHead = &g_ProtectPasswordCache;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, PASSWORD_CACHE_ENTRY, Next );

        if( CompareFileTime( &ftStaleEntry, &pCacheEntry->ftLastAccess ) > 0 )
        {
            ListEntry = ListEntry->Blink;

            RemoveEntryList( &pCacheEntry->Next );
            ZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
            SSFree( pCacheEntry );
        }
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    return;
}

BOOL
IsCachePWAllowed(
    VOID
    )
{
    HKEY hKeyProtect;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue;
    LONG lRet;

    lRet = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Policies\\Microsoft\\Cryptography\\Protect",
            0,
            KEY_QUERY_VALUE,
            &hKeyProtect
            );

    if( lRet != ERROR_SUCCESS )
        return TRUE;

    cbValue = sizeof(dwValue);

    lRet = RegQueryValueExU(
                    hKeyProtect,
                    L"AllowCachePW",
                    NULL,
                    &dwType,
                    (PBYTE)&dwValue,
                    &cbValue
                    );


    RegCloseKey( hKeyProtect );

    if( lRet == ERROR_SUCCESS && dwType == REG_DWORD && dwValue == 0 ) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\internal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       internal.h
//
//--------------------------------------------------------------------------

#ifndef _INTERNAL_H
#define _INTERNAL_H

#include "richedit.h"
#include "ccertbmp.h"


#define CRYPTUI_MAX_STRING_SIZE 768

///////////////////////////////////////////////////////////////////////////////
// macro for getting the number of bytes in an array
///////////////////////////////////////////////////////////////////////////////
#define  ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define ICON_X_POS 21
#define ICON_Y_POS 10

#define IMAGE_PROPERTY           0
#define IMAGE_EXTENSION          1
#define IMAGE_CRITICAL_EXTENSION 2
#define IMAGE_V1                 3

///////////////////////////////////////////////////////////////////////////////
// this structure is used to subclass an edit control and give it a link look
// and feel
///////////////////////////////////////////////////////////////////////////////
typedef struct _LIST_DISPLAY_HELPER {
    BOOL    fHexText;
    LPWSTR  pwszDisplayText;
    BYTE    *pbData;
    DWORD   cbData;
} LIST_DISPLAY_HELPER, *PLIST_DISPLAY_HELPER;

///////////////////////////////////////////////////////////////////////////////
// this structure is used to subclass an edit control and give it a link look
// and feel
///////////////////////////////////////////////////////////////////////////////
typedef struct _LINK_SUBCLASS_DATA {

    HWND    hwndParent;
    WNDPROC wpPrev;
    DWORD   uId;
    HWND    hwndTip;
    LPSTR   pszURL;
    BOOL    fMouseCaptured;
    BOOL    fNoCOM;
    BOOL    fUseArrowInsteadOfHand;
} LINK_SUBCLASS_DATA, *PLINK_SUBCLASS_DATA;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCert api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
#define MAX_CERT_CHAIN_LENGTH 40
typedef struct {
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp;
    DWORD                               cpCryptProviderCerts;
    PCRYPT_PROVIDER_CERT                rgpCryptProviderCerts[MAX_CERT_CHAIN_LENGTH];
    DWORD                               dwChainError;
    DWORD                               cUsages;
    LPSTR                               *rgUsages;
    HTREEITEM                           hItem;      // Leaf item in trust view
    BOOL                                fDblClk;
    CCertificateBmp                     *pCCertBmp;
    HWND                                hwndGeneralPage;
    HWND                                hwndDetailPage;
    HWND                                hwndHierarchyPage;
    RECT                                goodForOriginalRect;
    WINTRUST_DATA                       sWTD;
    WINTRUST_CERT_INFO                  sWTCI;
    BOOL                                fFreeWTD;
    BOOL                                fAddingToChain;
    BOOL                                fDeletingChain;
    LPWSTR                              pwszErrorString;
    BOOL                                fAccept;
    BOOL                                fNoCOM;
    BOOL                                *pfPropertiesChanged;
    BOOL                                fCPSDisplayed;
    BOOL                                fIgnoreUntrustedRoot;
    BOOL                                fWarnUntrustedRoot;
    BOOL                                fRootInRemoteStore;
    HICON                               hIcon;
    BOOL                                fCancelled;
    BOOL				fIssuerDisplayedAsLink;
    BOOL                                fSubjectDisplayedAsLink;
    BOOL                                fWarnRemoteTrust;
} CERT_VIEW_HELPER, *PCERT_VIEW_HELPER;

#define WM_MY_REINITIALIZE  (WM_USER+20)

///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCTL api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCTL_STRUCTW       pcvctl;
    DWORD                           chStores;
    HCERTSTORE                      *phStores;
    HCERTSTORE                      hExtraStore;
    PCCERT_CONTEXT                  pSignerCert;
    PCMSG_SIGNER_INFO               pbSignerInfo;
    DWORD                           cbSignerInfo;
    HICON                           hIcon;
    HCRYPTMSG                       hMsg;
    int                             previousSelection;
    int                             currentSelection;
    BOOL                            fNoSignature;
    BOOL                            fCancelled;
    DWORD                           dwInheritableError;
    BOOL                            fCatFile;
} CTL_VIEW_HELPER, *PCTL_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCRL api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCRL_STRUCTW   pcvcrl;
    int                         currentSelection;
    HICON                       hIcon;
    BOOL                        fCancelled;
} CRL_VIEW_HELPER, *PCRL_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertSetProperties api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp;
    LPWSTR                                      pwszInitialCertName;
    LPWSTR                                      pwszInitialDescription;
    BOOL                                        fSelfCleanup;
    BOOL                                        fInserting;
    BOOL                                        *pfPropertiesChanged;
    BOOL                                        fPropertiesChanged;
    BOOL                                        fGetPagesCalled;
    LPSTR                                       *rgszValidChainUsages;
    int                                         cszValidUsages;
    DWORD                                       EKUPropertyState;
	BOOL										fAddPurposeCanBeEnabled;
    BOOL                                        fCancelled;
    DWORD                                       dwRadioButtonState;
    BOOL                                        fMMCCallbackMade;
    BOOL                                        InWMInit;
} CERT_SETPROPERTIES_HELPER, *PCERT_SETPROPERTIES_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignerInfo api 
///////////////////////////////////////////////////////////////////////////////
#define CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE 0x80000000
#define CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE         0x40000000
typedef struct {
    PCRYPT_PROVIDER_DATA    pCryptProviderData;
    BOOL                    fpCryptProviderDataTrustedUsage;
    DWORD                   idxSigner;
    BOOL                    fCounterSigner;
    DWORD                   idxCounterSigner;
    DWORD                   dwInheritedError;
} CERT_VIEWSIGNERINFO_PRIVATE, *PCERT_VIEWSIGNERINFO_PRIVATE;

///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignerInfo api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWSIGNERINFO_STRUCTW    pcvsi;
    PCCERT_CONTEXT                      pSignersCert;
    int                                 previousSelection;
    int                                 currentSelection;
    HICON                               hIcon;
    HCERTSTORE                          hExtraStore;
    PCERT_VIEWSIGNERINFO_PRIVATE        pPrivate;
    BOOL                                fPrivateAllocated;
    CRYPT_PROVIDER_DEFUSAGE             CryptProviderDefUsage;
    WINTRUST_DATA                       WTD;
    BOOL                                fUseDefaultProvider;
    BOOL                                fCancelled;
    DWORD                               dwInheritedError;
} SIGNER_VIEW_HELPER, *PSIGNER_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignatures api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCRYPTUI_VIEWSIGNATURES_STRUCTW     pcvs;
    BOOL                                fSelfCleanup;
    HCERTSTORE                          hExtraStore;
} CERT_VIEWSIGNATURES_HELPER, *PCERT_VIEWSIGNATURES_HELPER;


///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCert API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageHierarchy(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCTL API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCTLTrustList(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCatalogEntries(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCRL API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCRLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCRLRevocationList(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewSignerInfo API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSignerGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageSignerAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);


///////////////////////////////////////////////////////////////////////////////
// used for obvious purposes
///////////////////////////////////////////////////////////////////////////////
BOOL IsWin95(void);
extern BOOL FIsWin95;
BOOL CheckRichedit20Exists(void);
extern BOOL fRichedit20Exists;
BOOL fRichedit20Usable(HWND hwndEdit);


#undef SetWindowLong
#define SetWindowLong SetWindowLongA
#undef GetWindowLong
#define GetWindowLong GetWindowLongA
#undef SendMessage
#define SendMessage SendMessageA


//
//  frmtutil.cpp
//
BOOL FormatAlgorithmString(LPWSTR *ppString, CRYPT_ALGORITHM_IDENTIFIER const *pAlgorithm);
BOOL FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob);
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData);
BOOL FormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat, HWND hwnd = NULL);
BOOL FormatValidityString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, HWND hwnd = NULL);
BOOL FormatDNNameString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData, BOOL fMultiline);
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline);
BOOL FormatMemBufToWindow(HWND hWnd, LPBYTE pbData, DWORD cbData);
LPWSTR AllocAndReturnSignTime(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd = NULL);
LPWSTR AllocAndReturnTimeStampersTimes(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd = NULL);
LPWSTR FormatCTLSubjectUsage(CTL_USAGE *pSubjectUsage, BOOL fMultiline);

//
// usagutil.cpp
//
BOOL OIDinArray(LPCSTR pszOID, LPSTR *rgszOIDArray, DWORD cOIDs);
BOOL AllocAndReturnKeyUsageList(PCRYPT_PROVIDER_CERT pCryptProviderCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs);
BOOL AllocAndReturnEKUList(PCCERT_CONTEXT pCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs);
void FreeEKUList(LPSTR *pKeyUsageOIDs, DWORD numOIDs);
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId);
BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID);
BOOL fPropertiesDisabled(PCERT_ENHKEY_USAGE pPropertyUsage);
BOOL CertHasEmptyEKUProp(PCCERT_CONTEXT pCertContext);
BOOL ValidateCertForUsage(
                    PCCERT_CONTEXT  pCertContext,
                    FILETIME        *psftVerifyAsOf,
                    DWORD           cStores,
                    HCERTSTORE *    rghStores,
                    HCERTSTORE      hExtraStore,
                    LPCSTR          pszOID);

//
// linkutil.cpp
//
void CryptuiGoLink(HWND hwndParent, char *pszWhere, BOOL fNoCOM);
BOOL AllocAndGetIssuerURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext);
BOOL AllocAndGetSubjectURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext);

//
// cps.cpp
//
DWORD GetCPSInfo(PCCERT_CONTEXT pCertContext, LPWSTR * ppwszUrlString, LPWSTR * ppwszDisplayText);
BOOL IsOKToDisplayCPS(PCCERT_CONTEXT pCertContext, DWORD dwChainError);
BOOL DisplayCPS(HWND hwnd, PCCERT_CONTEXT pCertContext, DWORD dwChainError, BOOL fNoCOM);

//
// disputil.cpp
//
void DisplayExtensions(HWND hWndListView, DWORD cExtension, PCERT_EXTENSION rgExtension, BOOL fCritical, DWORD *index);
PLIST_DISPLAY_HELPER MakeListDisplayHelper(BOOL fHexText, LPWSTR pwszDisplayText, BYTE *pbData, DWORD cbData);
PLIST_DISPLAY_HELPER MakeListDisplayHelperForExtension(LPSTR pszObjId, BYTE *pbData, DWORD cbData);
void FreeListDisplayHelper(PLIST_DISPLAY_HELPER pDisplayHelper);
void DisplayHelperTextInEdit(HWND hWndListView, HWND hwndDlg, int nIDEdit, int index);
void SetTextFormatInitial(HWND hWnd);
void SetTextFormatHex(HWND hWnd);

BOOL GetUnknownErrorString(LPWSTR *ppwszErrorString, DWORD dwError);
BOOL GetCertErrorString(LPWSTR *ppwszErrorString, PCRYPT_PROVIDER_CERT pCryptProviderCert);
void CertSubclassEditControlForArrowCursor (HWND hwndEdit);
void CertSubclassEditControlForLink (HWND hwndDlg, HWND hwndEdit, PLINK_SUBCLASS_DATA plsd);
void * GetStoreName(HCERTSTORE hCertStore, BOOL fWideChar);
void ModifyOrInsertRow(
                    HWND        hWndListView,
                    LV_ITEMW    *plvI,
                    LPWSTR      pwszValueText,
                    LPWSTR      pwszText,
                    BOOL        fAddRows,
                    BOOL        fHex);
int CALLBACK HidePropSheetCancelButtonCallback(
                    HWND    hwndDlg,
                    UINT    uMsg,
                    LPARAM  lParam);

INT_PTR WINAPI CryptUIPropertySheetA(LPCPROPSHEETHEADERA pHdr);
INT_PTR WINAPI CryptUIPropertySheetW(LPCPROPSHEETHEADERW pHdr);

BOOL IsTrueErrorString(CERT_VIEW_HELPER *pviewhelp);

//
// convutil.cpp
//
LPSTR CertUIMkMBStr(LPCWSTR pwsz);
LPWSTR CertUIMkWStr(LPCSTR psz);
LPSTR AllocAndCopyMBStr(LPCSTR psz);
LPWSTR AllocAndCopyWStr(LPCWSTR pwsz);
LPPROPSHEETPAGEA ConvertToPropPageA(LPCPROPSHEETPAGEW ppage, DWORD cPages);
void FreePropSheetPagesA(LPPROPSHEETPAGEA ppage, DWORD cPages);
BOOL ConvertToPropPageW(LPCPROPSHEETPAGEA ppage, DWORD cPages, LPCPROPSHEETPAGEW *pppageW);
void FreePropSheetPagesW(LPPROPSHEETPAGEW ppage, DWORD cPages);



//
// gettrst.cpp
//
BOOL CalculateUsages(PCERT_VIEW_HELPER pviewhelp);

BOOL BuildChain(PCERT_VIEW_HELPER pviewhelp, LPSTR pszUsage);

BOOL BuildWinVTrustState(
            LPCWSTR                         szFileName,
            CMSG_SIGNER_INFO const          *pSignerInfo,
            DWORD                           cStores,
            HCERTSTORE                      *rghStores,
            LPCSTR                          pszOID,
            PCERT_VIEWSIGNERINFO_PRIVATE    pcvsiPrivate,
            CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
            WINTRUST_DATA                   *pWTD);

BOOL FreeWinVTrustState(
            LPCWSTR                         szFileName,
            CMSG_SIGNER_INFO const          *pSignerInfo,
            DWORD                           cStores,
            HCERTSTORE                      *rghStores,
            LPCSTR                          pszOID,
            CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
            WINTRUST_DATA                   *pWTD);

//
// other stuff (util.cpp)
//
BOOL CommonInit();
BOOL FreeAndCloseKnownStores(DWORD chStores, HCERTSTORE *phStores);
BOOL AllocAndOpenKnownStores(DWORD *chStores, HCERTSTORE  **pphStores);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPSTR lpString, HPALETTE* lphPalette);
void MaskBlt
(
    HBITMAP& hbmImage,
    HPALETTE hpal,
    HDC& hdc, int xDst, int yDst, int dx, int dy
);
PCCERT_CONTEXT GetSignersCert(CMSG_SIGNER_INFO const *pSignerInfo, HCERTSTORE hExtraStore, DWORD cStores, HCERTSTORE *rghStores);
BOOL fIsCatalogFile(CTL_USAGE *pSubjectUsage);
DWORD CryptUISetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz);
void SetRicheditIMFOption(HWND hWndRichEdit);

/*BOOL CryptUISetupFonts(HFONT *pBoldFont);
void CryptUIDestroyFonts(HFONT hBoldFont);
void CryptUISetControlFont(HFONT hFont, HWND hwnd, INT nId);
*/

//
//  These routines extract and pretty print fields in the certs.  The
//      routines use crt to allocate and return a buffer
//

LPWSTR PrettySubject(PCCERT_CONTEXT pccert);

typedef struct {
    DWORD       dw1;
    DWORD       dw2;
} HELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap);

//--------------------------------------------------------------------------
//
//	 IsValidURL
//
//--------------------------------------------------------------------------
BOOL IsValidURL (LPWSTR pwszURL);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeIds
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeIds (UINT ids, ...);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeString
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeString (LPWSTR pwszFormat, ...);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicode (LPWSTR pwszFormat, va_list * pArgList);

#endif //_INTERNAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

//#include <wchar.h>


HMODULE         HmodRichEdit = NULL;
HINSTANCE       HinstDll;
BOOL            FIsWin95 = TRUE;
BOOL            fRichedit20Exists = FALSE;


//
//  Generic DLL Main function,  we need to get our own hinstance handle.
//
//  We don't need to get thread attaches however.

extern "C" BOOL WINAPI TrustUIDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved);

extern "C" BOOL WINAPI Wizard_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulReason, LPVOID)
{
    BOOL    fResult=FALSE;

    switch( ulReason ) {
    case DLL_PROCESS_ATTACH:
        HinstDll = (HINSTANCE) hInst;
        
        //  Kill all thread attach and detach messages
        DisableThreadLibraryCalls(HinstDll);

        //  Are we running in Win95 or something equally bad
        FIsWin95 = IsWin95();

        // check for richedit 2.0's existence
        fRichedit20Exists =  CheckRichedit20Exists();

        break;

    case DLL_PROCESS_DETACH:
        
        //  If the rich edit dll was loaded, then unload it now
        if (HmodRichEdit != NULL) {
            FreeLibrary(HmodRichEdit);
        }
        break;
    }

    fResult=TrustUIDllMain((HINSTANCE)hInst, ulReason, NULL);

    fResult=fResult && (Wizard_DllMain((HINSTANCE)hInst, ulReason, NULL));

    fResult=fResult && (ProtectUI_DllMain((HINSTANCE)hInst, ulReason, NULL));

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\property.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       property.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include <wininet.h>
#include <crypthlp.h>           //DSIE:  For XCERT_MIN_SYNC_DELTA_TIME and 
                                //       XCERT_MIN_SYNC_DELTA_TIME

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmapGeneral[] = {
    {IDC_CERTIFICATE_NAME,		IDH_CERTPROPERTIES_CERTIFICATENAME},
    {IDC_DESCRIPTION,			IDH_CERTPROPERTIES_DESCRIPTION},
    {IDC_KEY_USAGE_LIST,		IDH_CERTPROPERTIES_USAGE_LIST},
    {IDC_PROPERTY_NEWOID,		IDH_CERTPROPERTIES_ADDPURPOSE_BUTTON},
	{IDC_ENABLE_ALL_RADIO,		IDH_CERTPROPERTIES_ENABLE_ALL_RADIO},
	{IDC_DISABLE_ALL_RADIO,		IDH_CERTPROPERTIES_DISABLE_ALL_RADIO},
	{IDC_ENABLE_SELECT_RADIO,	IDH_CERTPROPERTIES_ENABLE_CUSTOM_RADIO}
};

static const HELPMAP helpmapCrossCert[] = {
    {IDC_CHECKFORNEWCERTS_CHECK, IDH_CHECKFORNEWCERTS_CHECK},
    {IDC_NUMBEROFUNITS_EDIT,	 IDH_NUMBEROFUNITS_EDIT},
    {IDC_UNITS_COMBO,		     IDH_UNITS_COMBO},
    {IDC_USE_DEFAULT_BUTTON,	 IDH_USE_DEFAULT_BUTTON},
    {IDC_ADDURL_BUTTON,		     IDH_ADDURL_BUTTON},
    {IDC_NEWURL_EDIT,		     IDH_NEWURL_EDIT},
    {IDC_URL_LIST,               IDH_URL_LIST},
	{IDC_REMOVEURL_BUTTON,	     IDH_REMOVEURL_BUTTON}
};

#define MY_CHECK_STATE_CHECKED            (INDEXTOSTATEIMAGEMASK(1))
#define MY_CHECK_STATE_UNCHECKED          (INDEXTOSTATEIMAGEMASK(2))
#define MY_CHECK_STATE_CHECKED_GRAYED     (INDEXTOSTATEIMAGEMASK(3))
#define MY_CHECK_STATE_UNCHECKED_GRAYED   (INDEXTOSTATEIMAGEMASK(4))

#define PROPERTY_STATE_ALL_ENABLED      1
#define PROPERTY_STATE_ALL_DISABLED     2
#define PROPERTY_STATE_SELECT           3

typedef struct {
    LPSTR   pszOID;
    DWORD   initialState;
} SETPROPERTIES_HELPER_STRUCT, *PSETPROPERTIES_HELPER_STRUCT;

//DSIE: Bug 154609
#define XCERT_DEFAULT_DELTA_HOURS     (XCERT_DEFAULT_SYNC_DELTA_TIME / (60 * 60)) // Default interval is 8 hours.

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY NewOIDDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   i;
    char    szText[256];
    WCHAR   errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR   errorTitle[CRYPTUI_MAX_STRING_SIZE];
    LPSTR   pszText = NULL;

    switch ( msg ) {

    case WM_INITDIALOG:

        SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_EXLIMITTEXT, 0, (LPARAM) 255);
        SetDlgItemTextU(hwndDlg, IDC_EDIT1, L"");
        SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {

        case IDOK:
            if (GetDlgItemTextA(
                        hwndDlg,
                        IDC_EDIT1,
                        szText,
                        ARRAYSIZE(szText)))
            {
                BOOL                fError = FALSE;
                CERT_ENHKEY_USAGE   KeyUsage;
                DWORD               cbData = 0;
                LPSTR               pszCheckOID;

                //
                // make sure there are not weird characters
                //
                for (i=0; i<(DWORD)strlen(szText); i++)
                {
                    if (((szText[i] < '0') || (szText[i] > '9')) && (szText[i] != '.'))
                    {
                        fError = TRUE;
                        break;
                    }
                }

                //
                // check the first and last chars, and for the empty string
                //
                if (!fError)
                {
                    if ((szText[0] == '.') || (szText[strlen(szText)-1] == '.') || (strcmp(szText, "") == 0))
                    {
                        fError = TRUE;
                    }
                }

                //
                // finally, make sure that it encodes properly
                //
                if (!fError)
                {
                    pszCheckOID = szText;
                    KeyUsage.rgpszUsageIdentifier = &pszCheckOID;
                    KeyUsage.cUsageIdentifier = 1;

                    if (!CryptEncodeObject(
                              X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              &KeyUsage,
                              NULL,
                              &cbData))
                    {
                        fError = TRUE;
                    }
                }


                //
                // if an error has occurred then display error
                //
                if (fError)
                {
                    LoadStringU(HinstDll, IDS_ERRORINOID, errorString, ARRAYSIZE(errorString));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONERROR);
                    SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
                    return FALSE;
                }

                //
                // allocate space for the string and pass the string back
                //
                pszText = (LPSTR) malloc(strlen(szText)+1);
                if (pszText != NULL)
                {
                    strcpy(pszText, szText);
                }
            }

            EndDialog(hwndDlg, (INT_PTR)pszText);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            break;
        }

        break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
DWORD MyGetCheckState(HWND hWndListView, int listIndex)
{
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE;
    lvI.iItem = listIndex;
    lvI.state = 0;
    lvI.stateMask = LVIS_STATEIMAGEMASK;

    ListView_GetItem(hWndListView, &lvI);

    return (lvI.state);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void MySetCheckState(HWND hWndListView, int listIndex, DWORD dwImage)
{
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE;
    lvI.stateMask = LVIS_STATEIMAGEMASK;
    lvI.iItem = listIndex;
    lvI.state = dwImage;

    SendMessage(hWndListView, LVM_SETITEM, (WPARAM) 0, (LPARAM) &lvI);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void SetEnableStateForChecks(PCERT_SETPROPERTIES_HELPER pviewhelp, HWND hWndListView, BOOL fEnabled)
{
	int		i;
	DWORD	dwState;

	pviewhelp->fInserting = TRUE;

	for (i=0; i<ListView_GetItemCount(hWndListView); i++)
	{
		dwState = MyGetCheckState(hWndListView, i);

		if ((dwState == MY_CHECK_STATE_CHECKED_GRAYED) ||
			(dwState == MY_CHECK_STATE_UNCHECKED_GRAYED))
		{
			if (fEnabled)
			{
				MySetCheckState(
						hWndListView,
						i,
						(dwState == MY_CHECK_STATE_CHECKED_GRAYED) ? MY_CHECK_STATE_CHECKED : MY_CHECK_STATE_UNCHECKED);
			}
		}
		else
		{
			if (!fEnabled)
			{
				MySetCheckState(
						hWndListView,
						i,
						(dwState == MY_CHECK_STATE_CHECKED) ? MY_CHECK_STATE_CHECKED_GRAYED : MY_CHECK_STATE_UNCHECKED_GRAYED);
			}
		}
	}

	pviewhelp->fInserting = FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddUsageToList(
                    HWND            hWndListView,
                    LPSTR           pszOID,
                    DWORD           dwImage,
                    BOOL            fDirty)
{
    WCHAR                       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                    lvI;
    SETPROPERTIES_HELPER_STRUCT *pHelperStruct;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;
    lvI.iItem = ListView_GetItemCount(hWndListView);

    // get the display string for the usage
    if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pszOID))
    {
        return;
    }
    lvI.cchTextMax = wcslen(szText);

    // set the lParam field the helper struct so that we always have access the oid and
    // the initial check state
    pHelperStruct = NULL;
    pHelperStruct =
        (SETPROPERTIES_HELPER_STRUCT *) malloc(sizeof(SETPROPERTIES_HELPER_STRUCT) + (strlen(pszOID)+1));

    if (pHelperStruct != NULL)
    {
        pHelperStruct->pszOID = (LPSTR) (((LPBYTE)pHelperStruct) + sizeof(SETPROPERTIES_HELPER_STRUCT));
        lvI.lParam = (LPARAM) pHelperStruct;
        strcpy(pHelperStruct->pszOID, pszOID);

        //
        // if the dirty flag was passed in, then set the initial image to iImage+1
        // so that when we are checking to see if anything has changed on shutdown
        // we know this is a usage that was added after the dialog was brought up.
        //
        if (fDirty)
        {
            pHelperStruct->initialState = dwImage+1;
        }
        else
        {
            pHelperStruct->initialState = dwImage;
        }
    }
    else
    {
        return;
    }

    ListView_InsertItemU(hWndListView, &lvI);

    //
    // for some reason you can't set the state image when inserting the
    // item, so set the state image after it has been inserted
    //
    MySetCheckState(hWndListView, lvI.iItem, dwImage);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayKeyUsages(
                    HWND                        hWndListView,
                    PCERT_SETPROPERTIES_HELPER  pviewhelp)
{
    DWORD               i;
    LPSTR               *pszOIDs = NULL;
    DWORD               numOIDs = 0;
    DWORD               cbPropertyUsage = 0;
    PCERT_ENHKEY_USAGE  pPropertyUsage = NULL;
    DWORD               cbEKUExtensionUsage = 0;
    PCERT_ENHKEY_USAGE  pEKUExtensionUsage = NULL;
    DWORD               dwImage;
    DWORD               displayState;
    int                 j;
    PCCERT_CONTEXT      pCertContext = pviewhelp->pcsp->pCertContext;
    LVITEMW             lvI;

    //
    // get the property usages that are currently tagged to this cert
    //
    if(!CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbPropertyUsage
                )                                                               ||
        (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(cbPropertyUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pPropertyUsage,
                &cbPropertyUsage
                ) )
    {

        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            if (pPropertyUsage != NULL)
                free(pPropertyUsage);
            pPropertyUsage = NULL;
        }
        else
        {
            goto CleanUp;
        }
    }

    //
    // get the EKU usages that are in the cert
    //
    if(!CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbEKUExtensionUsage
                )                                                               ||
        (pEKUExtensionUsage = (PCERT_ENHKEY_USAGE) malloc(cbEKUExtensionUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                pEKUExtensionUsage,
                &cbEKUExtensionUsage
                ) )
    {

        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            if (pEKUExtensionUsage != NULL)
                free(pEKUExtensionUsage);
            pEKUExtensionUsage = NULL;
        }
        else
        {
            goto CleanUp;
        }
    }

    //
    // set the property state so the INIT_DIALOG can set the correct state
    //
    if (pPropertyUsage == NULL)
    {
         pviewhelp->EKUPropertyState = PROPERTY_STATE_ALL_ENABLED;
    }
    else if (fPropertiesDisabled(pPropertyUsage))
    {
        pviewhelp->EKUPropertyState = PROPERTY_STATE_ALL_DISABLED;
    }
    else
    {
        pviewhelp->EKUPropertyState = PROPERTY_STATE_SELECT;
    }

    //
    // there are four different cases that the cert can be in
    // 1) cert has property EKU only
    // 2) cert has neither
    // 3) cert has extension EKU only
    // 4) cert has both property EKU and extension EKU
    //

    if (pEKUExtensionUsage == NULL)
    {
        //
        // if we are in case 1 or 2, then all the usage that are valid
        // for the chain are entered into the list view, unless the chain
        // is good for everything, in which case the current certs valid
        // usages are entered
        //
        if (pviewhelp->cszValidUsages != -1)
        {
            for (i=0; i<(DWORD)pviewhelp->cszValidUsages; i++)
            {
                if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pviewhelp->rgszValidChainUsages[i]))
                {
                    dwImage = MY_CHECK_STATE_CHECKED;
                }
                else
                {
                    dwImage = MY_CHECK_STATE_UNCHECKED;
                }
                AddUsageToList(hWndListView, pviewhelp->rgszValidChainUsages[i], dwImage, FALSE);
            }
        }
        else
        {
            AllocAndReturnEKUList(pCertContext, &pszOIDs, &numOIDs);

            for (i=0; i<numOIDs; i++)
            {
                //
                // if there are no property usages, or if this usage is in the list of
                // property usages, then set the state to checked
                //
                if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pszOIDs[i]))
                {
                    dwImage = MY_CHECK_STATE_CHECKED;

                }
                else
                {
                    dwImage = MY_CHECK_STATE_UNCHECKED;
                }

                AddUsageToList(hWndListView, pszOIDs[i], dwImage, FALSE);
            }

            FreeEKUList(pszOIDs, numOIDs);
        }
    }
    else
    {
        //
        // for cases 3 and 4, the list view is populated with only the EKU extension,
        // and is further restricted that the EKU must be in the chain valid usages
        //
        for (i=0; i<pEKUExtensionUsage->cUsageIdentifier; i++)
        {
            //
            // if the EKU is not valid up the chain then skip the display
            //
            if ((pviewhelp->cszValidUsages != -1)   &&
                !OIDinArray(pEKUExtensionUsage->rgpszUsageIdentifier[i],
                            pviewhelp->rgszValidChainUsages,
                            pviewhelp->cszValidUsages))
            {
                continue;
            }

            //
            // if there are no properties or the usage is in the properties then
            // the usage should be checked
            //
            if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pEKUExtensionUsage->rgpszUsageIdentifier[i]))
            {
                dwImage = MY_CHECK_STATE_CHECKED;
            }
            else
            {
                dwImage = MY_CHECK_STATE_UNCHECKED;
            }
            AddUsageToList(hWndListView, pEKUExtensionUsage->rgpszUsageIdentifier[i], dwImage, FALSE);
        }
    }

CleanUp:

    if (pPropertyUsage != NULL)
        free(pPropertyUsage);

    if (pEKUExtensionUsage != NULL)
        free(pEKUExtensionUsage);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL StateChanged(HWND hWndListView)
{
    int     listIndex;
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE | LVIF_PARAM;
    lvI.stateMask = LVIS_STATEIMAGEMASK;

    listIndex = ListView_GetItemCount(hWndListView) - 1;	

    while (listIndex >= 0)
    {
        lvI.iItem = listIndex--;
        lvI.state = 0;
        lvI.lParam = 0;

        ListView_GetItem(hWndListView, &lvI);

        if (lvI.state != ((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->initialState)
        {
            return TRUE;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static
PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
AllocAndCopySetPropertiesStruct(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp)
{
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pStruct;
    DWORD i;

    if (NULL == (pStruct = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW)
                            malloc(sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW))))
    {
        return NULL;
    }
    memcpy(pStruct, pcsp, sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW));

    if (NULL == (pStruct->rghStores = (HCERTSTORE *) malloc(sizeof(HCERTSTORE)*pcsp->cStores)))
    {
        free(pStruct);
        return NULL;
    }

    pStruct->cPropSheetPages = 0;
    pStruct->rgPropSheetPages = NULL;
    pStruct->pCertContext = CertDuplicateCertificateContext(pcsp->pCertContext);

    for (i=0; i<pcsp->cStores; i++)
    {
        pStruct->rghStores[i] = CertDuplicateStore(pcsp->rghStores[i]);
    }

    return pStruct;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeSetPropertiesStruct(PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp)
{
    DWORD i;

    CertFreeCertificateContext(pcsp->pCertContext);

    for (i=0; i<pcsp->cStores; i++)
    {
        CertCloseStore(pcsp->rghStores[i], 0);
    }

    free(pcsp->rghStores);
    free(pcsp);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDAlreadyExist(LPSTR pszNewOID, HWND hWndListView)
{
    LVITEMW                         lvI;
    PSETPROPERTIES_HELPER_STRUCT    pHelperStruct;

    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvI.mask = LVIF_PARAM;
    while (lvI.iItem >= 0)
    {
        if (ListView_GetItemU(hWndListView, &lvI))
        {
            pHelperStruct = (PSETPROPERTIES_HELPER_STRUCT) lvI.lParam;
            if (strcmp(pHelperStruct->pszOID, pszNewOID) == 0)
            {
                return TRUE;
            }
        }
        lvI.iItem--;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL CertHasEKU(PCCERT_CONTEXT pccert)
{
    DWORD i;

    i = 0;
    while (i < pccert->pCertInfo->cExtension)
    {
        if (strcmp(pccert->pCertInfo->rgExtension[i].pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
        {
            return TRUE;
        }
        i++;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL BuildChainEKUList(PCERT_SETPROPERTIES_HELPER pviewhelp)
{
    WINTRUST_DATA                       WTD;
    WINTRUST_CERT_INFO                  WTCI;
    CRYPT_PROVIDER_DATA const *         pProvData = NULL;
    CRYPT_PROVIDER_SGNR       *         pProvSigner = NULL;
    PCRYPT_PROVIDER_CERT                pProvCert = NULL;
    PCCERT_CONTEXT                      *rgpCertContext = NULL;
    DWORD                               i;
    BOOL                                fRet = TRUE;
    DWORD                               cbOIDs = 0;
    DWORD                               dwCertsForUsageCheck = 0;
    GUID                                defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    pviewhelp->cszValidUsages = 0;

    //
    // initialize structs that are used with WinVerifyTrust()
    //
    memset(&WTD, 0x00, sizeof(WINTRUST_DATA));
    WTD.cbStruct       = sizeof(WINTRUST_DATA);
    WTD.dwUIChoice     = WTD_UI_NONE;
    WTD.dwUnionChoice  = WTD_CHOICE_CERT;
    WTD.pCert          = &WTCI;
    WTD.dwProvFlags    = WTD_NO_POLICY_USAGE_FLAG | WTD_REVOCATION_CHECK_NONE;

    memset(&WTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    WTCI.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    WTCI.pcwszDisplayName  = L"CryptUI";
    WTCI.psCertContext     = (CERT_CONTEXT *)pviewhelp->pcsp->pCertContext;
    WTCI.chStores          = pviewhelp->pcsp->cStores;
    WTCI.pahStores         = pviewhelp->pcsp->rghStores;
    WTCI.dwFlags           = 0;

    WTD.dwStateAction = WTD_STATEACTION_VERIFY;

    //
    // the default default provider requires the policycallback data to point
    // to the usage oid you are validating for, so set it to the usage passed in
    //
    WinVerifyTrustEx(NULL, &defaultProviderGUID, &WTD);

    pProvData = WTHelperProvDataFromStateData(WTD.hWVTStateData);
    pProvSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0);
    if (pProvSigner == NULL)
    {
        goto Error;
    }

    //
    // build up the array of PCCERT_CONTEXTs
    //
    rgpCertContext = (PCCERT_CONTEXT *) malloc((pProvSigner->csCertChain-1) * sizeof(PCCERT_CONTEXT));
    if (rgpCertContext == NULL)
    {
        goto Error;
    }

    for (i=1; i<pProvSigner->csCertChain; i++)
    {
        pProvCert = WTHelperGetProvCertFromChain(pProvSigner, i);
        rgpCertContext[i-1] = pProvCert->pCert;
        dwCertsForUsageCheck++;

        //
        // if there is a CTL context that contains this cert, then the usage
        // changes for certs above the CTL in the chain, so stop with this         
        // cert when calculating valid usages
        //
        if (pProvCert->pCtlContext != NULL)
        {
            break;
        }
    }

    //
    // now, get the usages array
    //
    if (!CertGetValidUsages(dwCertsForUsageCheck, rgpCertContext, &(pviewhelp->cszValidUsages), NULL, &cbOIDs))
    {
        goto Error;
    }

    if (NULL == (pviewhelp->rgszValidChainUsages = (LPSTR *) malloc(cbOIDs)))
    {
        goto Error;
    }

    if (!CertGetValidUsages(dwCertsForUsageCheck, rgpCertContext, &(pviewhelp->cszValidUsages), pviewhelp->rgszValidChainUsages, &cbOIDs))
    {
        free(pviewhelp->rgszValidChainUsages);
        pviewhelp->rgszValidChainUsages = NULL;
        goto Error;
    }

CleanUp:

    WTD.dwStateAction = WTD_STATEACTION_CLOSE;
    WinVerifyTrustEx(NULL, &defaultProviderGUID, &WTD);
    if (rgpCertContext != NULL)
    {
        free(rgpCertContext);
    }

    return fRet;

Error:
    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddExistingPropertiesToUsage(
                                            PCCERT_CONTEXT pccert,
                                            PCERT_ENHKEY_USAGE pPropertyUsage,
                                            HWND hWndListView)
{
    PCERT_ENHKEY_USAGE  pExistingPropUsage = NULL;
    DWORD               cbExistingPropUsage = 0;
    DWORD               i;
    BOOL                fSkip = FALSE;
    LVITEMW             lvI;
    DWORD               state;
    void                *pTemp;

    //
    // get the property usages that are currently tagged to this cert
    //
    if(!CertGetEnhancedKeyUsage (
                pccert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbExistingPropUsage
                )                                                               ||
        (pExistingPropUsage = (PCERT_ENHKEY_USAGE) malloc(cbExistingPropUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pccert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pExistingPropUsage,
                &cbExistingPropUsage
                ) )
    {
        if (pExistingPropUsage != NULL)
        {
            free(pExistingPropUsage);
        }

        return;
    }

    //
    // loop for each usage, and add it if it does not already exist in the list,
    // AND it is not already in the list view unchecked
    //
    for (i=0; i<pExistingPropUsage->cUsageIdentifier; i++)
    {
        if (!OIDInUsages(pPropertyUsage, pExistingPropUsage->rgpszUsageIdentifier[i]))
        {
            fSkip = FALSE;

            //
            // if the property is unchecked in the list view then skip it
            //
            memset(&lvI, 0, sizeof(lvI));
            lvI.mask = LVIF_PARAM;
            lvI.lParam = (LPARAM)NULL;
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;
            lvI.iSubItem = 0;

            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    if (strcmp(((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->pszOID,
                        pExistingPropUsage->rgpszUsageIdentifier[i]) == 0)
                    {
                        state = MyGetCheckState(hWndListView, lvI.iItem);

                        if ((state == MY_CHECK_STATE_UNCHECKED) || (state == MY_CHECK_STATE_UNCHECKED_GRAYED))
                        {
                            fSkip = TRUE;
                            break;
                        }
                    }
                }
                lvI.iItem--;
            }

            if (fSkip)
            {
                continue;
            }

            //
            // allocate space for a pointer to the usage OID string
            //
            if (pPropertyUsage->cUsageIdentifier++ == 0)
            {
                pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) malloc (sizeof(LPSTR));
            }
            else
            {
                pTemp = realloc (pPropertyUsage->rgpszUsageIdentifier,
                                       sizeof(LPSTR) * pPropertyUsage->cUsageIdentifier);
                if (pTemp == NULL)
                {
                    free(pPropertyUsage->rgpszUsageIdentifier);
                    pPropertyUsage->rgpszUsageIdentifier = NULL;
                }
                else
                {
                    pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) pTemp;
                }
            }

            if (pPropertyUsage->rgpszUsageIdentifier == NULL)
            {
                pPropertyUsage->cUsageIdentifier = 0;
                return;
            }

            pPropertyUsage->rgpszUsageIdentifier[pPropertyUsage->cUsageIdentifier-1] =
                AllocAndCopyMBStr(pExistingPropUsage->rgpszUsageIdentifier[i]);
        }
    }

    if (pExistingPropUsage != NULL)
    {
        free(pExistingPropUsage);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSetPropertiesGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                f;
    DWORD               cch;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    LPWSTR              pwsz;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    CRYPT_DATA_BLOB     CryptDataBlob;
    DWORD               cbpwsz;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    DWORD               state;
    LPSTR               pszNewOID;
    WCHAR               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    int                 j;
    DWORD               i;
    void                *pTemp;
    PCERT_SETPROPERTIES_HELPER pviewhelp;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp = NULL;

    switch ( msg ) {
    case WM_INITDIALOG:

        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) ps->lParam;
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT));
        ShowWindow(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT), SW_HIDE);
        
        //
        // Set the Certificate Name (friendly name) and Description fields in the dialog box
        //
        cbpwsz = 0;
        if (CertGetCertificateContextProperty(  pccert,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                NULL,
                                                &cbpwsz))
        {
            //
            // The Certificate Name (friendly name) property exists, so display it
            //
            pviewhelp->pwszInitialCertName = (LPWSTR) malloc(cbpwsz);
            if (pviewhelp->pwszInitialCertName != NULL)
            {
                CertGetCertificateContextProperty(  pccert,
                                                    CERT_FRIENDLY_NAME_PROP_ID,
                                                    pviewhelp->pwszInitialCertName,
                                                    &cbpwsz);
                CryptUISetRicheditTextW(hwndDlg, IDC_CERTIFICATE_NAME, pviewhelp->pwszInitialCertName);
            }
        }
        else
        {
            //
            // The Certificate Name (friendly name) property did not exist, so display the default
            //
            //LoadStringU(HinstDll, IDS_DEFAULT_CERTIFICATE_NAME, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERTIFICATE_NAME, L"");
            pviewhelp->pwszInitialCertName = AllocAndCopyWStr(L"");
        }

        // DSIE: IE 6 bug #13676.
        SendDlgItemMessage(hwndDlg, IDC_CERTIFICATE_NAME, EM_EXLIMITTEXT, 0, (LPARAM) 40);

        cbpwsz = 0;
        if (CertGetCertificateContextProperty(  pccert,
                                                CERT_DESCRIPTION_PROP_ID,
                                                NULL,
                                                &cbpwsz))
        {
            //
            // The Description property exists, so display it
            //
            pviewhelp->pwszInitialDescription = (LPWSTR) malloc(cbpwsz);
            if (pviewhelp->pwszInitialDescription != NULL)
            {
                CertGetCertificateContextProperty(  pccert,
                                                    CERT_DESCRIPTION_PROP_ID,
                                                    pviewhelp->pwszInitialDescription,
                                                    &cbpwsz);
                CryptUISetRicheditTextW(hwndDlg, IDC_DESCRIPTION, pviewhelp->pwszInitialDescription);
            }
        }
        else
        {
            //
            // The Description property did not exist, so display the default
            //
            //LoadStringU(HinstDll, IDS_DEFAULT_DESCRIPTION, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_DESCRIPTION, L"");
            pviewhelp->pwszInitialDescription = AllocAndCopyWStr(L"");
        }

        // DSIE: IE 6 bug #13676.
        SendDlgItemMessage(hwndDlg, IDC_DESCRIPTION, EM_EXLIMITTEXT, 0, (LPARAM) 255);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_CHECKBOXES);
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_CHECKLIST), 0, 4, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_STATE);
        }        

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.cx = 330;            // Width of the column, in pixels.
        lvC.pszText = L"";   // The text for the column.
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
                // error
        }

        BuildChainEKUList(pviewhelp);

        pviewhelp->fInserting = TRUE;
        DisplayKeyUsages(hWndListView, pviewhelp);
        pviewhelp->fInserting = FALSE;

        //
        // set the flag noting whether the add purposes button can be
		// enabled based on wether there are EKU's in the cert, and if
		// the chain is NOT valid for all usages
        //
        if (CertHasEKU(pccert) || (pviewhelp->cszValidUsages != -1))
        {
            pviewhelp->fAddPurposeCanBeEnabled = FALSE;
		}
        else
        {
            pviewhelp->fAddPurposeCanBeEnabled = TRUE;
		}

        //
        // set the state of the property editing controls based on the
        // state of the eku PROPERTY
        //
        if (pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_ENABLED)
        {
            SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
            pviewhelp->dwRadioButtonState = IDC_ENABLE_ALL_RADIO;
		}
        else if (pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_DISABLED)
        {
            SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
            pviewhelp->dwRadioButtonState = IDC_DISABLE_ALL_RADIO;
		}
        else if (pviewhelp->EKUPropertyState == PROPERTY_STATE_SELECT)
        {
            SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
			SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
			if (pviewhelp->fAddPurposeCanBeEnabled)
			{
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), TRUE);
			}
			else
			{
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
			}
            pviewhelp->dwRadioButtonState = IDC_ENABLE_SELECT_RADIO;
        }

        //
        // make sure we get change notifications from the richedit controls
        //
        SendDlgItemMessageA(hwndDlg, IDC_CERTIFICATE_NAME, EM_SETEVENTMASK, 0, (LPARAM) ENM_CHANGE);
        SendDlgItemMessageA(hwndDlg, IDC_DESCRIPTION, EM_SETEVENTMASK, 0, (LPARAM) ENM_CHANGE);

        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            {
            BOOL                fAllItemsChecked = TRUE;
            DWORD               cbPropertyUsage = 0;
            PCERT_ENHKEY_USAGE  pPropertyUsage = NULL;
            GETTEXTEX           GetTextStruct;

            memset(&GetTextStruct, 0, sizeof(GetTextStruct));
            GetTextStruct.flags = GT_DEFAULT;
            GetTextStruct.codepage = 1200; //UNICODE

            //
            //  Write back the Friendly name
            //  and description if they have changed
            //

            //
            // Friendly Name
            //

            cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_CERTIFICATE_NAME,
                                     WM_GETTEXTLENGTH, 0, 0);
            pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (pwsz != NULL)
            {
                memset(pwsz, 0, (cch+1)*sizeof(WCHAR));
                if (fRichedit20Exists && fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT)))
                {
                    GetTextStruct.cb = (cch+1)*sizeof(WCHAR);
                    SendDlgItemMessageA(
                            hwndDlg, 
                            IDC_CERTIFICATE_NAME, 
                            EM_GETTEXTEX, 
                            (WPARAM) &GetTextStruct,
                            (LPARAM) pwsz);
                }
                else
                {
                    GetDlgItemTextU(hwndDlg, IDC_CERTIFICATE_NAME, pwsz, cch+1);
                }

                //
                // check for change
                //
                if (wcscmp(pviewhelp->pwszInitialCertName, pwsz) != 0)
                {
                    if (wcscmp(pwsz, L"") == 0)
                    {
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              NULL);
                    }
                    else
                    {
                        CryptDataBlob.pbData = (LPBYTE) pwsz;
                        CryptDataBlob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              &CryptDataBlob);
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }
                    pviewhelp->fPropertiesChanged = TRUE;
                }
                free(pwsz);
            }

            //
            // Description
            //

            cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_DESCRIPTION,
                                     WM_GETTEXTLENGTH, 0, 0);
            pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (pwsz != NULL)
            {
                memset(pwsz, 0, (cch+1)*sizeof(WCHAR));
                if (fRichedit20Exists && fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT)))
                {
                    GetTextStruct.cb = (cch+1)*sizeof(WCHAR);
                    SendDlgItemMessageA(
                            hwndDlg, 
                            IDC_DESCRIPTION, 
                            EM_GETTEXTEX, 
                            (WPARAM) &GetTextStruct,
                            (LPARAM) pwsz);
                }
                else
                {
                    GetDlgItemTextU(hwndDlg, IDC_DESCRIPTION, pwsz, cch+1);
                }

                //
                // check for change
                //
                if (wcscmp(pviewhelp->pwszInitialDescription, pwsz) != 0)
                {
                    if (wcscmp(pwsz, L"") == 0)
                    {
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_DESCRIPTION_PROP_ID, 0,
                                                              NULL);
                    }
                    else
                    {
                        CryptDataBlob.pbData = (LPBYTE) pwsz;
                        CryptDataBlob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_DESCRIPTION_PROP_ID, 0,
                                                              &CryptDataBlob);
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }
                    pviewhelp->fPropertiesChanged = TRUE;
                }
                free(pwsz);
            }

            hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

            //
            // check the radio buttons and the  usages to see if any have changed,
            // if so, then set the fPropertiesFlag in the CERT_VIEWCERT_STRUCT so the
            // caller knows that something has changed
            //
            if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_ENABLED) &&
                (SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_DISABLED) &&
                (SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_SELECT) &&
                     (SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     (!StateChanged(hWndListView)))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else
            {
                pviewhelp->fPropertiesChanged = TRUE;
            }

            if (pviewhelp->pfPropertiesChanged != NULL)
            {
                *(pviewhelp->pfPropertiesChanged) |= pviewhelp->fPropertiesChanged;
            }

            if ((SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                pviewhelp->fPropertiesChanged)
            {
                CertSetEnhancedKeyUsage(pccert, NULL);
            }
            else if ((SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     pviewhelp->fPropertiesChanged)
            {
                CERT_ENHKEY_USAGE eku;

                eku.cUsageIdentifier = 0;
                eku.rgpszUsageIdentifier = NULL;

                CertSetEnhancedKeyUsage(pccert, &eku);
            }
            else if ((SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     pviewhelp->fPropertiesChanged)
            {
                if (NULL == (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(sizeof(CERT_ENHKEY_USAGE))))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
                    return FALSE;
                }
                pPropertyUsage->cUsageIdentifier = 0;
                pPropertyUsage->rgpszUsageIdentifier = NULL;

                //
                // enumerate through all the items and add to the properties
                // if checked
                //
                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_PARAM;
                lvI.lParam = (LPARAM)NULL;
                lvI.iItem = ListView_GetItemCount(hWndListView) - 1;
                lvI.iSubItem = 0;

                while (lvI.iItem >= 0)
                {
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        lvI.iItem--;
                        continue;
                    }

                    state = MyGetCheckState(hWndListView, lvI.iItem);

                    if ((state == MY_CHECK_STATE_CHECKED) || (state == MY_CHECK_STATE_CHECKED_GRAYED))
                    {
                        //
                        // allocate space for a pointer to the usage OID string
                        //
                        if (pPropertyUsage->cUsageIdentifier++ == 0)
                        {
                            pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) malloc (sizeof(LPSTR));
                        }
                        else
                        {
                            pTemp = realloc (pPropertyUsage->rgpszUsageIdentifier,
                                                   sizeof(LPSTR) * pPropertyUsage->cUsageIdentifier);
                            if (pTemp == NULL)
                            {
                                free(pPropertyUsage->rgpszUsageIdentifier);
                                pPropertyUsage->rgpszUsageIdentifier = NULL;
                            }
                            else
                            {
                                pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) pTemp;
                            }
                        }

                        if (pPropertyUsage->rgpszUsageIdentifier == NULL)
                        {
                            free(pPropertyUsage);
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
                            return FALSE;
                        }

                        pPropertyUsage->rgpszUsageIdentifier[pPropertyUsage->cUsageIdentifier-1] =
                            AllocAndCopyMBStr(((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->pszOID);
                    }

                    lvI.iItem--;
                }

                AddExistingPropertiesToUsage(pccert, pPropertyUsage, hWndListView);

                CertSetEnhancedKeyUsage(pccert, pPropertyUsage);

                for (i=0; i<pPropertyUsage->cUsageIdentifier; i++)
                {
                    free(pPropertyUsage->rgpszUsageIdentifier[i]);
                }
                if (pPropertyUsage->rgpszUsageIdentifier)
                    free(pPropertyUsage->rgpszUsageIdentifier);
            }

            if (pPropertyUsage != NULL)
                free(pPropertyUsage);

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;
            }
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else {
               // WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                 //        pcsp->dwHelpId);
            }
            return TRUE;
        case LVN_ITEMCHANGING:

            if (pviewhelp->fInserting)
            {
                return TRUE;
            }

            pnmv = (LPNMLISTVIEW) lParam;
            hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

            state = LVIS_STATEIMAGEMASK & pnmv->uOldState;

            if ((state == MY_CHECK_STATE_CHECKED_GRAYED) || (state == MY_CHECK_STATE_UNCHECKED_GRAYED))
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            else if ((state == MY_CHECK_STATE_CHECKED) || (state == MY_CHECK_STATE_UNCHECKED))
            {
                pviewhelp->fInserting = TRUE;
                if (state == MY_CHECK_STATE_CHECKED)
                {
                    MySetCheckState(hWndListView, pnmv->iItem, MY_CHECK_STATE_UNCHECKED);
                }
                else
                {
                    MySetCheckState(hWndListView, pnmv->iItem, MY_CHECK_STATE_CHECKED);
                }
                pviewhelp->fInserting = FALSE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_KEY_USAGE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED | LVIS_SELECTED;
                    lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95)
            {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else
            {
                //WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                  //     pcsp->dwHelpId);
            }
            return TRUE;

        case IDC_CERTIFICATE_NAME:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_CERTIFICATE_NAME, EM_SETSEL,
                            0, -1);
                return TRUE;
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_DESCRIPTION:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_DESCRIPTION, EM_SETSEL,
                            0, -1);
                return TRUE;
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_ENABLE_ALL_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
                if (pviewhelp->dwRadioButtonState != IDC_ENABLE_ALL_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_ENABLE_ALL_RADIO;
                }
            }
            break;

        case IDC_DISABLE_ALL_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
                if (pviewhelp->dwRadioButtonState != IDC_DISABLE_ALL_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_DISABLE_ALL_RADIO;
                }
            }
            break;

        case IDC_ENABLE_SELECT_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
				SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
				if (pviewhelp->fAddPurposeCanBeEnabled)
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), TRUE);
				}
				else
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
				}

                if (pviewhelp->dwRadioButtonState != IDC_ENABLE_SELECT_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_ENABLE_SELECT_RADIO;
                }
            }
            break;

        case IDC_PROPERTY_NEWOID:
            pszNewOID = (LPSTR) DialogBoxU(
                                    HinstDll,
                                    (LPWSTR) MAKEINTRESOURCE(IDD_USER_PURPOSE),
                                    hwndDlg,
                                    NewOIDDialogProc);

            if (pszNewOID != NULL)
            {
                DWORD       chStores = 0;
                HCERTSTORE  *phStores = NULL;

                //
                // if the OID already existis then put up a message box and return
                //
                if (OIDAlreadyExist(pszNewOID, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST)))
                {
                    WCHAR   errorString2[CRYPTUI_MAX_STRING_SIZE];
                    WCHAR   errorTitle2[CRYPTUI_MAX_STRING_SIZE];

                    LoadStringU(HinstDll, IDS_OID_ALREADY_EXISTS_MESSAGE, errorString2, ARRAYSIZE(errorString2));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle2, ARRAYSIZE(errorTitle2));
                    MessageBoxU(hwndDlg, errorString2, errorTitle2, MB_OK | MB_ICONWARNING);
                    return FALSE;
                }

                //
                // if the usage doesn't exist in the chain usages, then put up an error
                //
                /*if ((pviewhelp->cszValidUsages != -1)   && //pviewhelp->cszValidUsages == -1 means all usages are ok
                    !OIDinArray(pszNewOID, pviewhelp->rgszValidChainUsages, pviewhelp->cszValidUsages))
                {
                    LoadStringU(HinstDll, IDS_ERROR_INVALIDOID_CERT, errorString2, ARRAYSIZE(errorString2));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle2, ARRAYSIZE(errorTitle2));
                    MessageBoxU(hwndDlg, errorString2, errorTitle2, MB_OK | MB_ICONERROR);
                    return FALSE;
                } */

                pviewhelp->fInserting = TRUE;
                AddUsageToList(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), pszNewOID, MY_CHECK_STATE_CHECKED, TRUE);
                pviewhelp->fInserting = FALSE;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                free(pszNewOID);
            }
            break;
        }
        break;

    case WM_DESTROY:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                free((void *) lvI.lParam);
            }
            lvI.iItem--;
        }

        //
        // free the name and description if they exist
        //
        if (pviewhelp->pwszInitialCertName)
        {
            free (pviewhelp->pwszInitialCertName);
        }
        if (pviewhelp->pwszInitialDescription)
        {
            free (pviewhelp->pwszInitialDescription);
        }

        //
        // free the usage array
        //
        if (pviewhelp->rgszValidChainUsages)
        {
            free(pviewhelp->rgszValidChainUsages);
        }

        //
        // if the properties have changed, and there is a pMMCCallback
        // then make the callback to MMC
        //
        if (pviewhelp->fPropertiesChanged               &&
            pviewhelp->fGetPagesCalled                  &&
            (pviewhelp->pcsp->pMMCCallback != NULL)     &&
            (pviewhelp->fMMCCallbackMade != TRUE))
        {
            pviewhelp->fMMCCallbackMade = TRUE;

            (*(pviewhelp->pcsp->pMMCCallback->pfnCallback))(
                        pviewhelp->pcsp->pMMCCallback->lNotifyHandle,
                        pviewhelp->pcsp->pMMCCallback->param);
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CERTIFICATE_NAME))		&&
            (hwnd != GetDlgItem(hwndDlg, IDC_DESCRIPTION))			&&
            (hwnd != GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST))		&&
			(hwnd != GetDlgItem(hwndDlg, IDC_ENABLE_ALL_RADIO))		&&
			(hwnd != GetDlgItem(hwndDlg, IDC_DISABLE_ALL_RADIO))	&&
			(hwnd != GetDlgItem(hwndDlg, IDC_ENABLE_SELECT_RADIO))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmapGeneral);
        }

        break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define MAX_DWORD_SIZE  ((DWORD) 0xffffffff)


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSetPropertiesCrossCerts(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                        f;
    DWORD                       cch;
    PCCERT_CONTEXT              pccert;
    PROPSHEETPAGE *             ps;
    LPWSTR                      pwsz;
    WCHAR                       rgwch[CRYPTUI_MAX_STRING_SIZE];
    CRYPT_DATA_BLOB             CryptDataBlob;
    HWND                        hWndListView;
    HWND                        hwnd;
    LVITEMW                     lvI;
    LV_COLUMNW                  lvC;
    LPNMLISTVIEW                pnmv;
    WCHAR                       errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                       errorTitle[CRYPTUI_MAX_STRING_SIZE];
    DWORD                       dw;
    int                         i;
    void                        *pTemp;
    PCERT_SETPROPERTIES_HELPER pviewhelp;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp = NULL;
    DWORD                       cb = 0;
    BYTE                        *pb = NULL;
    CROSS_CERT_DIST_POINTS_INFO *pCrossCertInfo = NULL;
    CROSS_CERT_DIST_POINTS_INFO CrossCertInfo;
    DWORD                       cbCrossCertInfo = 0;
    LPWSTR                      pwszStringToAdd = NULL;
    PCERT_ALT_NAME_INFO         pAltNameInfo = NULL;
    BOOL                        fChecked;
    WCHAR                       wszText[CRYPTUI_MAX_STRING_SIZE];
    DWORD                       dwNumUnits = 0;
    LPWSTR                      pwszURL = NULL;
    DWORD                       dwLength;
    BOOL                        fTranslated;                      
    PCERT_ALT_NAME_ENTRY        rgAltEntry;
    LONG_PTR                    PrevWndProc;
    DWORD                       dwSecsPerUnit    = 1;
    HWND                        hwndControl=NULL;
    int                         listIndex=0;

    switch ( msg ) {
    case WM_INITDIALOG:

        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) ps->lParam;
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        pviewhelp->InWMInit = TRUE;

        hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

        SendDlgItemMessage(hwndDlg, IDC_NUMBEROFUNITS_EDIT, EM_LIMITTEXT, (WPARAM) 7, (LPARAM) 0);
        SendDlgItemMessage(hwndDlg, IDC_NEWURL_EDIT, EM_LIMITTEXT, (WPARAM) 512, (LPARAM) 0);

        //
        // Initialize the combo box fields
        //
        LoadStringU(HinstDll, IDS_HOURS, wszText, ARRAYSIZE(wszText));
        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_INSERTSTRING, 0, (LPARAM) wszText);

        LoadStringU(HinstDll, IDS_DAYS, wszText, ARRAYSIZE(wszText));
        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_INSERTSTRING, 1, (LPARAM) wszText);

        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_SETCURSEL, 0, (LPARAM) NULL);
        SetDlgItemTextU(hwndDlg, IDC_NUMBEROFUNITS_EDIT, L"0");

        //
        // Initialize the list view control
        //
        memset(&lvC, 0, sizeof(LV_COLUMNW));
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;
        lvC.cx = 150;
        lvC.pszText = L"";
        lvC.iSubItem=0;
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_URL_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        //
        // try to get the CERT_CROSS_CERT_DIST_POINTS_PROP_ID property for this cert
        //
        if (!CertGetCertificateContextProperty(
                    pccert, 
                    CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                    NULL, 
                    &cb))
        {
            //
            // The property doesn't exist
            //
            SendDlgItemMessage(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), FALSE);
            EnableWindow(hWndListView, FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);

            pviewhelp->InWMInit = FALSE;
            return TRUE;
        }
        else
        {
            SendDlgItemMessage(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK, BM_SETCHECK, BST_CHECKED, 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), TRUE);
            EnableWindow(hWndListView, TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);
        }

        if (NULL == (pb = (BYTE *) malloc(cb)))
        {
            return FALSE;
        }

        if (!CertGetCertificateContextProperty(
                pccert, 
                CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                pb, 
                &cb))
        {
            free(pb);
            return FALSE;
        }

        if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                X509_CROSS_CERT_DIST_POINTS,
                pb,
                cb,
                0,
                NULL,
                &cbCrossCertInfo))
        {
            free(pb);
            return FALSE;
        }

        if (NULL == (pCrossCertInfo = 
                        (CROSS_CERT_DIST_POINTS_INFO *) malloc(cbCrossCertInfo)))
        {
            free(pb);
            return FALSE;
        }

        if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                X509_CROSS_CERT_DIST_POINTS,
                pb,
                cb,
                0,
                pCrossCertInfo,
                &cbCrossCertInfo))
        {
            free(pb);
            return FALSE;
        }

        free(pb);

        //
        // Initialize the sync time controls
        //
        if (pCrossCertInfo->dwSyncDeltaTime == 0)
        {
            pCrossCertInfo->dwSyncDeltaTime = XCERT_DEFAULT_SYNC_DELTA_TIME;    
        }
        
        if ((pCrossCertInfo->dwSyncDeltaTime % 86400) == 0)   
        {
            //
            // Days
            //
            dwNumUnits = pCrossCertInfo->dwSyncDeltaTime / 86400;
            SendDlgItemMessageU(
                    hwndDlg, 
                    IDC_UNITS_COMBO, 
                    CB_SETCURSEL, 
                    1, 
                    (LPARAM) NULL);
        }
        else
        {
            //
            // Hours
            //
            dwNumUnits = pCrossCertInfo->dwSyncDeltaTime / 3600;

            //
            // Force to 1 if exisiting value is less than 1 hour.
            //
            if (0 == dwNumUnits)
            {
                dwNumUnits = 1;
            }

            SendDlgItemMessageU(
                    hwndDlg, 
                    IDC_UNITS_COMBO, 
                    CB_SETCURSEL, 
                    0, 
                    (LPARAM) NULL);
        }   

        SetDlgItemInt(
                hwndDlg,
                IDC_NUMBEROFUNITS_EDIT,
                dwNumUnits,
                FALSE);

        //
        // Add each dist point to the list view
        //
        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_TEXT | LVIF_PARAM;

        for (lvI.iItem=0; lvI.iItem< (int)pCrossCertInfo->cDistPoint; lvI.iItem++)
        {
            pAltNameInfo = &(pCrossCertInfo->rgDistPoint[lvI.iItem]);

            if ((pAltNameInfo->cAltEntry == 0) ||
                (pAltNameInfo->rgAltEntry[0].dwAltNameChoice != 7))
            {
                continue;
            }

            pwszURL = (LPWSTR) 
                malloc( (wcslen(pAltNameInfo->rgAltEntry[0].pwszURL) + 1) * 
                        sizeof(WCHAR));
            if (pwszURL == NULL)
            {
                continue;
            }
            wcscpy(pwszURL, pAltNameInfo->rgAltEntry[0].pwszURL);
    
            lvI.pszText = pwszURL;
            lvI.lParam = (LPARAM) pwszURL;

            ListView_InsertItemU(hWndListView, &lvI);        
        }

        ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
        ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);

        free(pCrossCertInfo);
        
        pviewhelp->InWMInit = FALSE;
    
        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);
               
            if (BST_CHECKED != SendDlgItemMessage(
                                                hwndDlg, 
                                                IDC_CHECKFORNEWCERTS_CHECK, 
                                                BM_GETCHECK, 
                                                0, 
                                                0))
            {
                CertSetCertificateContextProperty(
                        pccert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                        0,
                        NULL);
            }
            else
            {
                //
                // Set the sync time
                //
                memset(&CrossCertInfo, 0, sizeof(CrossCertInfo));

                dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                {
                    dwSecsPerUnit = 3600;
                }
                else
                {
                    dwSecsPerUnit = 86400;
                }
                
                CrossCertInfo.dwSyncDeltaTime = dwNumUnits * dwSecsPerUnit;

                //
                // Set the dist points
                //
                CrossCertInfo.cDistPoint = ListView_GetItemCount(hWndListView);
                CrossCertInfo.rgDistPoint = (CERT_ALT_NAME_INFO *)
                                malloc( CrossCertInfo.cDistPoint * 
                                        sizeof(CERT_ALT_NAME_INFO));
                if (CrossCertInfo.rgDistPoint == NULL)
                {
                    break;
                }

                // one AltEntry per DistPoint
                rgAltEntry = (CERT_ALT_NAME_ENTRY *) 
                    malloc(CrossCertInfo.cDistPoint * sizeof(CERT_ALT_NAME_ENTRY));
                if (rgAltEntry == NULL)
                {
                    free(CrossCertInfo.rgDistPoint);
                    break;
                }

                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_PARAM;
                for (dw=0; dw<CrossCertInfo.cDistPoint; dw++)
                {
                    lvI.iItem = dw;
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        CrossCertInfo.rgDistPoint[dw].cAltEntry = 1;
                        CrossCertInfo.rgDistPoint[dw].rgAltEntry = &(rgAltEntry[dw]);
                        rgAltEntry[dw].dwAltNameChoice = 7;
                        rgAltEntry[dw].pwszURL = (LPWSTR) lvI.lParam;
                    }
                } 
                
                //
                // Now encode 
                //
                CryptDataBlob.cbData = 0;
                CryptDataBlob.pbData = NULL;
                if (CryptEncodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        X509_CROSS_CERT_DIST_POINTS,
                        &CrossCertInfo,
                        NULL,
                        &CryptDataBlob.cbData))
                {
                    if (NULL != (CryptDataBlob.pbData = (BYTE *) 
                                        malloc(CryptDataBlob.cbData)))
                    {
                        if (CryptEncodeObject(
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                X509_CROSS_CERT_DIST_POINTS,
                                &CrossCertInfo,
                                CryptDataBlob.pbData,
                                &CryptDataBlob.cbData))
                        {
                            CertSetCertificateContextProperty(
                                pccert,
                                CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                                0,
                                &CryptDataBlob);
                        }

                        free(CryptDataBlob.pbData);
                    }
                }

                free(rgAltEntry);
                free(CrossCertInfo.rgDistPoint);
            } 

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            //
            // DSIE: Bug 124468. Per PM JohnLa, we don't make any check until user applies.
            //
            if (BST_CHECKED == SendDlgItemMessage(hwndDlg, 
                                                  IDC_CHECKFORNEWCERTS_CHECK, 
                                                  BM_GETCHECK, 
                                                  0, 
                                                  0))
            {
                //
                // Check the sync time
                //
                dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                {
                    dwSecsPerUnit = 3600;
                }
                else
                {
                    dwSecsPerUnit = 86400;
                }

                if (!fTranslated || 0 == dwNumUnits || dwNumUnits > (MAX_DWORD_SIZE / dwSecsPerUnit))
                {
                    WCHAR * pwszMessage = NULL;
                    DWORD dwMaxInterval = MAX_DWORD_SIZE / dwSecsPerUnit;
 
                    if (pwszMessage = FormatMessageUnicodeIds(IDS_INVALID_XCERT_INTERVAL, dwMaxInterval))
                    {
                        WCHAR wszTitle[CRYPTUI_MAX_STRING_SIZE] = L"";

                        LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, wszTitle, ARRAYSIZE(wszTitle));

                        MessageBoxU(hwndDlg, pwszMessage, wszTitle, MB_OK | MB_ICONWARNING);
                        LocalFree((HLOCAL) pwszMessage);
                    }

                    SetFocus(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT));

                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT) TRUE);
                    return TRUE;
                }
            }

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else {
               // WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                 //        pcsp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGED:
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), 
                (ListView_GetSelectedCount(
                    GetDlgItem(hwndDlg,IDC_URL_LIST)) == 0) ? FALSE : TRUE);
            return TRUE;

#if (1) //DSIE: bug 283659.
        case NM_SETFOCUS:
            //get the window handle of the url list view
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_URL_LIST)))
                   break;

            //get the selected cert
            listIndex = ListView_GetNextItem(
                            hwndControl, 		
                            -1, 		
                            LVNI_FOCUSED		
                            );

           //select first item to show hilite.
           if (listIndex == -1)
                ListView_SetItemState(hwndControl,
                                      0,
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
            return TRUE;
#endif
        }

        break;

    case WM_COMMAND:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            
            return TRUE;

        case IDC_CHECKFORNEWCERTS_CHECK:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                //
                // Get current state of check, then enable/disable all 
                // controls accordingly
                //
                fChecked = (BST_CHECKED == SendDlgItemMessage(
                                                hwndDlg, 
                                                IDC_CHECKFORNEWCERTS_CHECK, 
                                                BM_GETCHECK, 
                                                0, 
                                                0));

                EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_URL_LIST), fChecked);
                if (fChecked)
                {
                    //
                    // DSIE: Bug 124669.
                    //
                    dwNumUnits = GetDlgItemInt(
                                        hwndDlg,
                                        IDC_NUMBEROFUNITS_EDIT,
                                        &fTranslated,
                                        FALSE);
                    if (0 == dwNumUnits)
                    {
                        SendDlgItemMessageU(
                                hwndDlg, 
                                IDC_UNITS_COMBO, 
                                CB_SETCURSEL, 
                                0, 
                                (LPARAM) NULL);

                        SetDlgItemInt(
                                hwndDlg,
                                IDC_NUMBEROFUNITS_EDIT,
                                XCERT_DEFAULT_DELTA_HOURS,
                                FALSE);
                    }

                    EnableWindow(
                        GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), 
                        (ListView_GetSelectedCount(
                            GetDlgItem(hwndDlg,IDC_URL_LIST)) == 0) ? FALSE : TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);
                }

                if (pviewhelp->pfPropertiesChanged != NULL)
                {
                    *(pviewhelp->pfPropertiesChanged) = TRUE;
                }
                pviewhelp->fPropertiesChanged = TRUE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;

        case IDC_USE_DEFAULT_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                //
                // Reset to default interval.
                //
                SendDlgItemMessageU(
                        hwndDlg, 
                        IDC_UNITS_COMBO, 
                        CB_SETCURSEL, 
                        0, 
                        (LPARAM) NULL);

                SetDlgItemInt(
                        hwndDlg,
                        IDC_NUMBEROFUNITS_EDIT,
                        XCERT_DEFAULT_DELTA_HOURS,
                        FALSE);
            }
            break;

        case IDC_ADDURL_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

                dwLength = (DWORD) SendDlgItemMessage(
                                        hwndDlg, 
                                        IDC_NEWURL_EDIT, 
                                        WM_GETTEXTLENGTH, 
                                        0, 
                                        NULL);

                if (dwLength == 0)
                {
                    break;
                }

                pwszURL = (LPWSTR) malloc((dwLength + 1) * sizeof(WCHAR));
                if (pwszURL == NULL)
                {
                    break;
                }
                GetDlgItemTextU(
                                hwndDlg, 
                                IDC_NEWURL_EDIT, 
                                pwszURL,
                                dwLength + 1);
                pwszURL[dwLength] = '\0';

                if (!IsValidURL(pwszURL))
                {
                    free(pwszURL);
                    LoadStringU(HinstDll, IDS_INVALID_URL_ERROR, errorString, ARRAYSIZE(errorString));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                    break;
                }

                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_TEXT | LVIF_PARAM;
                lvI.iItem = ListView_GetItemCount(hWndListView);
                lvI.pszText = pwszURL;
                lvI.lParam = (LPARAM) pwszURL;

                ListView_InsertItemU(hWndListView, &lvI); 
                ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);

                SetDlgItemTextU(hwndDlg, IDC_NEWURL_EDIT, L""); 

                if (pviewhelp->pfPropertiesChanged != NULL)
                {
                    *(pviewhelp->pfPropertiesChanged) = TRUE;
                }
                pviewhelp->fPropertiesChanged = TRUE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_REMOVEURL_BUTTON:

            hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.mask = LVIF_STATE | LVIF_PARAM;
            lvI.stateMask = LVIS_SELECTED;

            for (i=(ListView_GetItemCount(hWndListView) - 1); i >=0; i--)
            {
                lvI.iItem = i;
                
                if (ListView_GetItemU(hWndListView, &lvI) &&
                    (lvI.state & LVIS_SELECTED))
                {
                    free((void *) lvI.lParam);
                    ListView_DeleteItem(hWndListView, i);
                }
            }

            ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
            ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);

            if (pviewhelp->pfPropertiesChanged != NULL)
            {
                *(pviewhelp->pfPropertiesChanged) = TRUE;
            }
            pviewhelp->fPropertiesChanged = TRUE;
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

#if (1) //DSIE: bug 313918.
            if (0 == ListView_GetItemCount(hWndListView))
            {
                SetFocus(GetDlgItem(GetParent(hwndDlg), IDOK));
            }
            else
            {
                //get the selected cert
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_FOCUSED		
                                );

                //select first item to show hilite.
                if (listIndex == -1)
                    listIndex = 0;

                ListView_SetItemState(hWndListView,
                                      listIndex,
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
            }
#endif
            break;

        case IDC_UNITS_COMBO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                if (!pviewhelp->InWMInit)
                {
                    dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                    if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                    {
                        dwSecsPerUnit = 3600;
                    }
                    else
                    {
                        dwSecsPerUnit = 86400;                
                    }

                    if (dwNumUnits > (MAX_DWORD_SIZE / dwSecsPerUnit))
                    {
                        SetDlgItemInt(
                                hwndDlg,
                                IDC_NUMBEROFUNITS_EDIT,
                                (DWORD) (MAX_DWORD_SIZE / dwSecsPerUnit),
                                FALSE);  
                    }

                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                }
                
            }
            
            break;

        case IDC_NUMBEROFUNITS_EDIT:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                if (!pviewhelp->InWMInit)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                }                
            }

            break;
        }
        break;
        
    case WM_DESTROY:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_PARAM;
        
        for (i=(ListView_GetItemCount(hWndListView) - 1); i >=0; i--)
        {
            lvI.iItem = i;
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                free((void *) lvI.lParam);            
            }
        }

        //
        // if the properties have changed, and there is a pMMCCallback
        // then make the callback to MMC
        //
        if (pviewhelp->fPropertiesChanged               &&
            pviewhelp->fGetPagesCalled                  &&
            (pviewhelp->pcsp->pMMCCallback != NULL)     &&
            (pviewhelp->fMMCCallbackMade != TRUE))
        {
            pviewhelp->fMMCCallbackMade = TRUE;

            (*(pviewhelp->pcsp->pMMCCallback->pfnCallback))(
                        pviewhelp->pcsp->pMMCCallback->lNotifyHandle,
                        pviewhelp->pcsp->pMMCCallback->param);
        }
        

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK))	&&
            (hwnd != GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT))	    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_UNITS_COMBO))		   	    &&
			(hwnd != GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON))	    &&
			(hwnd != GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON))		   	&&
			(hwnd != GetDlgItem(hwndDlg, IDC_NEWURL_EDIT))		        &&
			(hwnd != GetDlgItem(hwndDlg, IDC_URL_LIST))		            &&
            (hwnd != GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON)))	   
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmapCrossCert);
        }

        break;
    }

    return FALSE;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetRegisteredClientPages(PROPSHEETPAGEW **ppClientPages, DWORD *pcClientPages, PCCERT_CONTEXT pCertContext)
{
    HCRYPTOIDFUNCSET    hCertPropPagesFuncSet;
    void *              pvFuncAddr = NULL;
    HCRYPTOIDFUNCADDR   hFuncAddr = NULL;
    PROPSHEETPAGEW      callbackPages[MAX_CLIENT_PAGES];
    DWORD               cCallbackPages = MAX_CLIENT_PAGES;
    DWORD               cChars = 0;
    LPWSTR              pwszDllNames = NULL;
    BOOL                fRet = TRUE;
    LPWSTR              pwszCurrentDll;
    DWORD               i;
    void                *pTemp;

    //
    // initialize incoming variables
    //
    *ppClientPages = NULL;
    *pcClientPages = 0;

    //
    // get a handle to the function table
    //
    if (NULL == (hCertPropPagesFuncSet = CryptInitOIDFunctionSet(
            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK, 0)))
    {
        goto ErrorReturn;
    }

    //
    // get the list of dlls that contain the callback functions
    //
    if (!CryptGetDefaultOIDDllList(
                hCertPropPagesFuncSet,
                0,
                NULL,
                &cChars))
    {
        goto ErrorReturn;
    }

    if (NULL == (pwszDllNames = (LPWSTR) malloc(cChars * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

    if (!CryptGetDefaultOIDDllList(
                hCertPropPagesFuncSet,
                0,
                pwszDllNames,
                &cChars))
    {
        goto ErrorReturn;
    }

    //
    // loop for each dll and call it to see if it has property pages for this cert
    //
    pwszCurrentDll = pwszDllNames;
    while (pwszCurrentDll[0] != L'\0')
    {
        //
        // try to get the function pointer
        //
        if (!CryptGetDefaultOIDFunctionAddress(
                    hCertPropPagesFuncSet,
                    0,
                    pwszCurrentDll,
                    0,
                    &pvFuncAddr,
                    &hFuncAddr))
        {
            DWORD dwErr = GetLastError();
            pwszCurrentDll += wcslen(pwszCurrentDll) + 1;
            continue;
        }

        //
        // call the client to get the their pages
        //
        cCallbackPages = MAX_CLIENT_PAGES;
        memset(callbackPages, 0, sizeof(callbackPages));
        if (((PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK) pvFuncAddr)(pCertContext, callbackPages, &cCallbackPages))
        {
            //
            // if they handed back pages then add them to the array
            //
            if (cCallbackPages >= 1)
            {
                if (*ppClientPages == NULL)
                {
                    if (NULL == (*ppClientPages = (PROPSHEETPAGEW *) malloc(cCallbackPages * sizeof(PROPSHEETPAGEW))))
                    {
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorReturn;
                    }
                }
                else
                {
                    if (NULL == (pTemp = realloc(*ppClientPages, (cCallbackPages + (*pcClientPages)) * sizeof(PROPSHEETPAGEW))))
                    {
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorReturn;
                    }
                    *ppClientPages = (PROPSHEETPAGEW *) pTemp;
                }

                memcpy(&((*ppClientPages)[(*pcClientPages)]), &(callbackPages[0]), cCallbackPages * sizeof(PROPSHEETPAGEW));
                *pcClientPages += cCallbackPages;
            }
        }

        //
        // free the function that was just called, and move on to the next one in the string
        //
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        hFuncAddr = NULL;
        pwszCurrentDll += wcslen(pwszCurrentDll) + 1;
    }

CleanUp:
    if (pwszDllNames != NULL)
    {
        free(pwszDllNames);
    }

    if (hFuncAddr != NULL)
    {
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    }
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//  CertSetCertificateProperties
//
//  Description:
//      This routine will display and allow the user to edit certain properties of
//		a certificate
//
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIDlgViewCertificatePropertiesW(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
                                                 BOOL                                        *pfPropertiesChanged)
{
    int                         cPages = 2;
    BOOL                        fRetValue = FALSE;
    HRESULT                     hr;
    PROPSHEETPAGEW *            ppage = NULL;
    PROPSHEETPAGEW *            pClientPages = NULL;
    DWORD                       cClientPages = 0;
    INT_PTR                     ret;
    WCHAR                       rgwch[256];
    char                        rgch[256];
    CERT_SETPROPERTIES_HELPER   viewhelper;

    if (pcsp->dwSize != sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    if (!CommonInit())
    {
        return FALSE;
    }

    //
    // initialize the helper struct
    //
    memset (&viewhelper, 0, sizeof(viewhelper));
    viewhelper.pcsp = pcsp;
    viewhelper.fSelfCleanup = FALSE;
    viewhelper.pfPropertiesChanged = pfPropertiesChanged;
    viewhelper.fGetPagesCalled = FALSE;
    viewhelper.fMMCCallbackMade = FALSE;

    //
    // set the properties changed flag to FALSE initially, it will be set
    // to TRUE if when the dialog exits anything has been changed
    //
    viewhelper.fPropertiesChanged = FALSE;
    if (viewhelper.pfPropertiesChanged != NULL)
    {
        *(viewhelper.pfPropertiesChanged) = FALSE;
    }

    //
    // get all the pages from registered clients
    //
    if (!GetRegisteredClientPages(&pClientPages, &cClientPages, pcsp->pCertContext))
    {
        return FALSE;
    }

    //
    //  Build up the list of pages we are going to use in the dialog
    //
    ppage = (PROPSHEETPAGEW *) malloc((cPages + pcsp->cPropSheetPages + cClientPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        goto Exit;
    }

    memset(ppage, 0, (cPages + pcsp->cPropSheetPages + cClientPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_DIALOG);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageSetPropertiesGeneral;
    ppage[0].lParam = (LPARAM) &viewhelper;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    
    ppage[1].dwSize = sizeof(ppage[0]);
    ppage[1].dwFlags = 0;
    ppage[1].hInstance = HinstDll;
    ppage[1].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG);
    ppage[1].hIcon = 0;
    ppage[1].pszTitle = NULL;
    ppage[1].pfnDlgProc = ViewPageSetPropertiesCrossCerts;
    ppage[1].lParam = (LPARAM) &viewhelper;
    ppage[1].pfnCallback = 0;
    ppage[1].pcRefParent = NULL;

    //
    //  copy over the users pages
    //
    memcpy(&ppage[cPages], pcsp->rgPropSheetPages, pcsp->cPropSheetPages * sizeof(PROPSHEETPAGEW));
    cPages += pcsp->cPropSheetPages;

    //
    // copy over the registered client's pages
    //
    memcpy(&ppage[cPages], pClientPages, cClientPages * sizeof(PROPSHEETPAGEW));
    cPages += cClientPages;

    if (FIsWin95) {

        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_PROPSHEETPAGE;// | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcsp->hwndParent != NULL) ? pcsp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcsp->szTitle != NULL)
        {
            hdr.pszCaption = CertUIMkMBStr(pcsp->szTitle);
        }
        else
        {
            LoadStringA(HinstDll, IDS_CERTIFICATE_PROPERTIES, (LPSTR) rgch, sizeof(rgch));
            hdr.pszCaption = (LPSTR) rgch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcsp->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }

        hdr.pfnCallback = NULL;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcsp->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *)hdr.ppsp, cPages);
   }
   else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_PROPSHEETPAGE;// | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcsp->hwndParent != NULL) ? pcsp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcsp->szTitle)
        {
            hdr.pszCaption = pcsp->szTitle;
        }
        else
        {
            LoadStringW(HinstDll, IDS_CERTIFICATE_PROPERTIES, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }

        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = NULL;

        ret = CryptUIPropertySheetW(&hdr);
    }

    if (viewhelper.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);

Exit:
    if (pClientPages)
        free(pClientPages);

    if (ppage)
        free(ppage);
    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIDlgViewCertificatePropertiesA(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA    pcsp,
                                                 BOOL                                           *pfPropertiesChanged)
{
    BOOL                                        fRet;
    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW   cspW;

    memcpy(&cspW, pcsp, sizeof(cspW));    
    if (!ConvertToPropPageW(
                    pcsp->rgPropSheetPages,
                    pcsp->cPropSheetPages,
                    &(cspW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cspW.szTitle = CertUIMkWStr(pcsp->szTitle);

    fRet = CryptUIDlgViewCertificatePropertiesW(&cspW, pfPropertiesChanged);

    if (cspW.szTitle)
        free((void *)cspW.szTitle);

    //DSIE: Prefix bug 428038.
    if (cspW.rgPropSheetPages)
    {
        FreePropSheetPagesW((LPPROPSHEETPAGEW) cspW.rgPropSheetPages, cspW.cPropSheetPages);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
UINT
CALLBACK
GetCertificatePropertiesPagesPropPageCallback(
                HWND                hWnd,
                UINT                uMsg,
                LPPROPSHEETPAGEW    ppsp)
{
    CERT_SETPROPERTIES_HELPER *pviewhelp = (CERT_SETPROPERTIES_HELPER *) ppsp->lParam;

    if (pviewhelp->pcsp->pPropPageCallback != NULL)
    {
        (*(pviewhelp->pcsp->pPropPageCallback))(hWnd, uMsg, pviewhelp->pcsp->pvCallbackData);
    }

    if (uMsg == PSPCB_RELEASE)
    {
        if (pviewhelp->fSelfCleanup)
        {
            FreeSetPropertiesStruct((PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp);
            free(pviewhelp);
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIGetCertificatePropertiesPagesW(
                    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW     pcsp,
                    BOOL                                            *pfPropertiesChanged,
                    PROPSHEETPAGEW                                  **prghPropPages,
                    DWORD                                           *pcPropPages
                    )
{
    BOOL                                        fRetValue = TRUE;
    HRESULT                                     hr;
    WCHAR                                       rgwch[CRYPTUI_MAX_STRING_SIZE];
    char                                        rgch[CRYPTUI_MAX_STRING_SIZE];
    CERT_SETPROPERTIES_HELPER                   *pviewhelp = NULL;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW  pNewcsp;
    PROPSHEETPAGEW *                            pClientPages = NULL;
    DWORD                                       cClientPages = 0;

    *prghPropPages = NULL;
    *pcPropPages = 0;

    if (NULL == (pNewcsp = AllocAndCopySetPropertiesStruct(pcsp)))
    {
        goto ErrorReturn;
    }

    if (NULL == (pviewhelp = (CERT_SETPROPERTIES_HELPER *) malloc(sizeof(CERT_SETPROPERTIES_HELPER))))
    {
        goto ErrorReturn;
    }

    *pcPropPages = 2;

    if (!CommonInit())
    {
        goto ErrorReturn;
    }

    //
    // initialize the helper struct
    //
    memset (pviewhelp, 0, sizeof(CERT_SETPROPERTIES_HELPER));
    pviewhelp->pcsp = pNewcsp;
    pviewhelp->fSelfCleanup = TRUE;
    pviewhelp->pfPropertiesChanged = pfPropertiesChanged;
    pviewhelp->fGetPagesCalled = TRUE;
    pviewhelp->fMMCCallbackMade = FALSE;

    //
    // set the properties changed flag to FALSE initially, it will be set
    // to TRUE if when the dialog exits anything has been changed
    //
    pviewhelp->fPropertiesChanged = FALSE;
    if (pviewhelp->pfPropertiesChanged != NULL)
    {
        *(pviewhelp->pfPropertiesChanged) = FALSE;
    }

    //
    // get all the pages from registered clients
    //
    if (!GetRegisteredClientPages(&pClientPages, &cClientPages, pcsp->pCertContext))
    {
        goto ErrorReturn;
    }

    //
    //  Build up the list of pages we are going to use in the dialog
    //
    *prghPropPages = (PROPSHEETPAGEW *) malloc(((*pcPropPages) + cClientPages) * sizeof(PROPSHEETPAGEW));
    if (*prghPropPages == NULL) {
        goto ErrorReturn;
    }

    memset(*prghPropPages, 0, (*pcPropPages) * sizeof(PROPSHEETPAGEW));

    (*prghPropPages)[0].dwSize = sizeof((*prghPropPages)[0]);
    (*prghPropPages)[0].dwFlags = PSP_USECALLBACK;
    (*prghPropPages)[0].hInstance = HinstDll;
    (*prghPropPages)[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_DIALOG);
    (*prghPropPages)[0].hIcon = 0;
    (*prghPropPages)[0].pszTitle = NULL;
    (*prghPropPages)[0].pfnDlgProc = ViewPageSetPropertiesGeneral;
    (*prghPropPages)[0].lParam = (LPARAM) pviewhelp;
    (*prghPropPages)[0].pfnCallback = GetCertificatePropertiesPagesPropPageCallback;
    (*prghPropPages)[0].pcRefParent = NULL;
    
    (*prghPropPages)[1].dwSize = sizeof((*prghPropPages)[0]);
    (*prghPropPages)[1].dwFlags = PSP_USECALLBACK;
    (*prghPropPages)[1].hInstance = HinstDll;
    (*prghPropPages)[1].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG);
    (*prghPropPages)[1].hIcon = 0;
    (*prghPropPages)[1].pszTitle = NULL;
    (*prghPropPages)[1].pfnDlgProc = ViewPageSetPropertiesCrossCerts;
    (*prghPropPages)[1].lParam = (LPARAM) pviewhelp;
    (*prghPropPages)[1].pfnCallback = NULL;
    (*prghPropPages)[1].pcRefParent = NULL;

    //
    // copy over the registered client's pages
    //
    memcpy(&((*prghPropPages)[*pcPropPages]), pClientPages, cClientPages * sizeof(PROPSHEETPAGEW));
    (*pcPropPages) += cClientPages;

CommonReturn:

    if (pClientPages != NULL)
    {
        free(pClientPages);
    }

    return fRetValue;

ErrorReturn:

    if (pNewcsp != NULL)
    {
        free(pNewcsp);
    }

    if (pviewhelp != NULL)
    {
        free(pviewhelp);
    }

    if (*prghPropPages != NULL)
    {
        free(*prghPropPages);
        *prghPropPages = NULL;
    }

    fRetValue = FALSE;
    goto CommonReturn;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIGetCertificatePropertiesPagesA(
                    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA     pcsp,
                    BOOL                                            *pfPropertiesChanged,
                    PROPSHEETPAGEA                                  **prghPropPages,
                    DWORD                                           *pcPropPages
                    )
{
    return (CryptUIGetCertificatePropertiesPagesW(
                    (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pcsp,
                    pfPropertiesChanged,
                    (PROPSHEETPAGEW**) prghPropPages,
                    pcPropPages));
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIFreeCertificatePropertiesPagesW(
                PROPSHEETPAGEW                  *rghPropPages,
                DWORD                           cPropPages
                )
{
    free(rghPropPages);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIFreeCertificatePropertiesPagesA(
                PROPSHEETPAGEA                  *rghPropPages,
                DWORD                           cPropPages
                )
{
    return (CryptUIFreeCertificatePropertiesPagesW((PROPSHEETPAGEW *) rghPropPages, cPropPages));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptui.rc
//

// For dialogs, the range of numbers you should use
// are from 130 through 149.
#define IDD_CERTPROP_GENERAL            130
#define IDD_CERTPROP_DETAILS            131
#define IDD_CERTPROP_HIERARCHY          132
#define IDD_TRUST                       135
#define IDD_CPS_DIALOG                  136
#define IDD_CERTIFICATE_PROPERTIES_DIALOG 137
#define IDD_CTL_GENERAL                 138
#define IDD_CTL_TRUSTLIST               139
#define IDD_USER_PURPOSE                140
#define IDD_SIGNER_GENERAL_DIALOG       141
#define IDD_SIGNER_ADVANCED_DIALOG      142
#define IDD_CRL_GENERAL                 143
#define IDD_CRL_REVOCATIONLIST          144
#define IDD_SIGNATURES_GENERAL_DIALOG   145
#define IDD_SELECT_STORE_DIALOG         146
#define IDD_SELECTCERT_DIALOG           147
#define IDD_SELECTCERT_DIALOG_WITH_DSPICKER  148
#define IDD_CATALOGFILE                 149

#define IDD_PROTECT_CHOOSE_SECURITY     150
#define IDD_PROTECT_CONFIRM_PROTECT     151
#define IDD_PROTECT_CONFIRM_SECURITY    152
#define IDD_PROTECT_CHOOSE_SECURITY_H   153
#define IDD_PROTECT_CHOOSE_SECURITY_M   154
#define IDD_PROTECT_SECURITY_DETAILS    155

#define IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG 156

//NOTE: cryptwzr.lib reserve the range from 180 to 230 for IDD_  resources
// NOTE: pki\activex\xaddroot\resource reserve the range from 270 to 279
// for IDD_  dialogs


// For bitmaps, the range of numbers you should use
// are from 300 through 319.
#define IDB_MINICERT                    302
#define IDB_REVOKED_MINICERT            303
#define IDB_EXCLAMATION_MINICERT        304
#define IDB_TRUSTTREE_BITMAP            305
#define IDB_FOLDER                      306
#define IDB_CERT                        307
#define IDB_PROPLIST                    308
#define IDB_CHECKLIST                   309
#define IDB_PRIVATEKEY                  310
#define IDB_CA                          311
#define IDB_WIZARD_CERT_HEADER          312
#define IDB_WIZARD_SIGN_HEADER          313
#define IDB_WIZARD_CTL_HEADER           314
#define IDB_PROTECT_USER                315
#define IDB_PROTECT_LOCKKEY             316

// For strings, the range of numbers you should use
// are from 3184 through 3503.
#define IDS_TRUST_DESC                  3213
#define IDS_GENERAL_DESC                3214
#define IDS_VIEW_TITLE                  3215
#define IDS_DEFAULT_DESCRIPTION         3216
#define IDS_DEFAULT_CERTIFICATE_NAME    3217
#define IDS_FIELD                       3218
#define IDS_VALUE                       3219
#define IDS_ALL_FIELDS                  3220
#define IDS_V1_FIELDS_ONLY              3221
#define IDS_EXTENSIONS_ONLY             3222
#define IDS_CRITICAL_EXTENSIONS_ONLY    3223
#define IDS_PROPERTIES_ONLY             3224
#define IDS_THUMBPRINT_ALGORITHM        3225
#define IDS_THUMBPRINT                  3226
#define IDS_CERTIFICATE_NAME            3227
#define IDS_DESCRIPTION                 3228
#define IDS_ENHANCED_KEY_USAGE          3229
#define IDS_CERTIFICATEINFORMATION      3230
#define IDS_FORUSEWITH                  3231
#define IDS_ISSUEDBY                    3232
#define IDS_ISSUEDTO                    3234
#define IDS_VALIDFROM                   3235
#define IDS_VALIDTO                     3236
#define IDS_FIELD_TEXT_BOX_FONT         3237
#define IDS_LISTUSAGE_CODESIGN1         3238
#define IDS_LISTUSAGE_CODESIGN2         3239
#define IDS_LISTUSAGE_VIRUS             3240
#define IDS_LISTUSAGE_ERRORFREE         3241
#define IDS_LISTUSAGE_SRVRAUTHGOOD      3242
#define IDS_LISTUSAGE_SRVRAUTHNOTGOOD   3243
#define IDS_LISTUSAGE_SGC               3244
#define IDS_LISTUSAGE_EMAIL1            3245
#define IDS_LISTUSAGE_EMAIL2            3246
#define IDS_LISTUSAGE_EMAIL3            3247
#define IDS_LISTUSAGE_TIMESTAMP         3248
#define IDS_LISTUSAGE_CTLSIGN           3249
#define IDS_LISTUSAGE_EFS               3250
#define IDS_CTLVIEW_TITLE               3251
#define IDS_ADV_VERSION                 3252
#define IDS_ADV_SER_NUM                 3253
#define IDS_ADV_SIG_ALG                 3254
#define IDS_ADV_ISSUER                  3255
#define IDS_ADV_NOTBEFORE               3256
#define IDS_ADV_NOTAFTER                3257
#define IDS_ADV_SUBJECT                 3258
#define IDS_ADV_PUBKEY                  3259
#define IDS_ADV_SUBJECTUSAGE            3260
#define IDS_ADV_LISTIDENTIFIER          3261
#define IDS_ADV_SEQUENCENUMBER          3262
#define IDS_ADV_THISUPDATE              3263
#define IDS_ADV_NEXTUPDATE              3264
#define IDS_ADV_SUBJECTALGORITHM        3265
#define IDS_CTL_NAME                    3266    
#define IDS_ADV_ISSUEDTO                3267
#define IDS_ADV_ISSUEDFROM              3268
#define IDS_NOTAVAILABLE                3269
#define IDS_HASHVALUE                   3270
#define IDS_CTL_INVALID_SIGNATURE       3271
#define IDS_CTL_VALID                   3272
#define IDS_ERRORINOID                  3273
#define IDS_ERROR_INVALIDOID_CERT       3274
#define IDS_SIGNERVIEW_TITLE            3275
#define IDS_NAME                        3276
#define IDS_EMAIL                       3277
#define IDS_SIGNING_TIME                3278
#define IDS_DIGEST_ALGORITHM            3279
#define IDS_DIGEST_ENCRYPTION_ALGORITHM 3280
#define IDS_AUTHENTICATED_ATTRIBUTES    3281
#define IDS_UNAUTHENTICATED_ATTRIBUTES  3282
#define IDS_TIMESTAMP_TIME              3283
#define IDS_CRL_VALID                   3284
#define IDS_CRL_INVALID                 3285
#define IDS_CRLVIEW_TITLE               3286
#define IDS_REVOCATION_DATE             3287
#define IDS_ADDITIONAL_ATTRIBUTES       3288
#define IDS_OID_ALREADY_EXISTS_MESSAGE  3289
#define IDS_CERTIFICATE_PROPERTIES      3290
#define IDS_CERTREVOKED_ERROR           3291
#define IDS_CERTEXPIRED_ERROR           3292
#define IDS_CERTBADSIGNATURE_ERROR      3293
#define IDS_CANTBUILDCHAIN_ERROR        3294
#define IDS_TIMENESTING_ERROR           3295
#define IDS_UNTRUSTEDROOT_ERROR         3296
#define IDS_NOVALIDUSAGES_ERROR_TREE    3297   
#define IDS_UNTRUSTEDROOT_ERROR_TREE    3298
#define IDS_CERTIFICATEOK_TREE          3299
#define IDS_CERTREVOKED_ERROR_TREE      3300
#define IDS_CERTEXPIRED_ERROR_TREE      3301
#define IDS_CERTBADSIGNATURE_ERROR_TREE 3302
#define IDS_TIMENESTING_ERROR_TREE      3303
#define IDS_CTLOK                       3304
#define IDS_INTERNAL_ERROR              3305
#define IDS_ISSUEDTO2                   3306
#define IDS_CTL_INFORMATION             3307
#define IDS_CTL_INVALID_CERT            3308
#define IDS_CTL_UNAVAILABLE_CERT        3309
#define IDS_CRL_INFORMATION             3310
#define IDS_SELECT_STORE_DEFAULT        3311
#define IDS_SELECT_CERT_DEFAULT         3312
#define IDS_ISSUEDBY2                   3313
#define IDS_INTENDED_PURPOSE            3314
#define IDS_LOCATION                    3315
#define IDS_FRIENDLYNAME_NONE           3316
#define IDS_SIGNER_INFORMATION          3317
#define IDS_SIGNER_VALID                3318
#define IDS_SIGNER_INVALID_SIGNATURE    3319
#define IDS_SIGNER_UNAVAILABLE_CERT     3320
#define IDS_SELECT_CERT_ERROR           3321
#define IDS_SELECT_CERTIFICATE_TITLE    3322
#define IDS_NO_REFRESH                  3323
#define IDS_TAG                         3324
#define IDS_CATALOG_TITLE               3325
#define IDS_CAT_INVALID_SIGNATURE       3326
#define IDS_CAT_INVALID_CERT            3327
#define IDS_CAT_UNAVAILABLE_CERT        3328
#define IDS_CAT_VALID                   3329
#define IDS_CAT_INFORMATION             3330
#define IDS_UNTRUSTEDROOT_ROOTCERT_ERROR_TREE 3331
#define IDS_SELECT_STORE_TITLE          3332
#define IDS_SELECT_STORE_ERROR          3333
#define IDS_ISSUER_WARNING              3334
#define IDS_PRIVATE_KEY_EXISTS          3335
#define IDS_CAT_NO_SIGNATURE            3336
#define IDS_CTL_NO_SIGNATURE            3337
#define IDS_WRONG_USAGE_ERROR           3338
#define IDS_BASIC_CONSTRAINTS_ERROR     3339
#define IDS_PURPOSE_ERROR               3340
#define IDS_REVOCATION_FAILURE_ERROR    3341
#define IDS_WRONG_USAGE_ERROR_TREE      3342
#define IDS_BASIC_CONSTRAINTS_ERROR_TREE 3343
#define IDS_PURPOSE_ERROR_TREE          3344
#define IDS_REVOCATION_FAILURE_ERROR_TREE 3345
#define IDS_SIGNATURE_ERROR_CTL         3346
#define IDS_EXPIRED_ERROR_CTL           3347
#define IDS_WRONG_USAGE_ERROR_CTL       3348
#define IDS_VIEW_CERTIFICATE            3349
#define IDS_VIEW_CTL                    3350
#define IDS_EXPIRATION_DATE             3352
#define IDS_CANTBUILDCHAIN_ERROR_TREE   3353
#define IDS_CYCLE_ERROR                 3354
#define IDS_PRIVATE_KEY_EXISTS_TOOLTIP  3355
#define IDS_CAT_INVALID_COUNTER_SIGNATURE 3356
#define IDS_CTL_INVALID_COUNTER_SIGNATURE 3357
#define IDS_CAT_COUNTER_SIGNER_CERT_UNAVAILABLE 3358
#define IDS_CTL_COUNTER_SIGNER_CERT_UNAVAILABLE 3359
#define IDS_CAT_INVALID_COUNTER_SIGNER_CERT 3360
#define IDS_CTL_INVALID_COUNTER_SIGNER_CERT 3361
#define IDS_COUNTER_SIGNER_INVALID      3362
#define IDS_BAD_SIGNER_CERT_SIGNATURE   3363
#define IDS_SIGNER_INVALID              3364
#define IDS_NOSGCOID                    3365
#define IDS_UKNOWN_ERROR                3366
#define IDS_NO_USAGES_ERROR             3367
#define IDS_SIGNER_CERT_NO_VERIFY       3368
#define ID_RTF_CODESIGN_GENERAL         3369
#define ID_RTF_CODESIGN_COMMERCIAL      3370
#define ID_RTF_CODESIGN_INDIVIDUAL      3371
#define ID_RTF_SERVERAUTH               3372
#define ID_RTF_CLIENTAUTH               3373
#define ID_RTF_SGC                      3374
#define ID_RTF_EMAIL1                   3375
#define ID_RTF_EMAIL2                   3376
#define ID_RTF_EMAIL3                   3377
#define ID_RTF_TIMESTAMP                3378
#define ID_RTF_CTLSIGN                  3379
#define ID_RTF_EFS                      3380
#define ID_RTF_IPSEC                    3381
#define IDS_EXPLICITDISTRUST_ERROR      3382
#define IDS_UNKNOWN_ERROR               3383
#define IDS_WARNUNTRUSTEDROOT_ERROR     3384
#define IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT 3385
#define ID_RTF_CODESIGN_COMMERCIAL_PKIX 3386
#define IDS_UNABLE_TO_OPEN_STORE        3387
#define IDS_SELECT_MULTIPLE_CERT_DEFAULT 3388
#define IDS_NO_USAGES                   3389

#define IDS_PROTECT_SECURITY_LEVEL_SET_HIGH 3390
#define IDS_PROTECT_SECURITY_LEVEL_SET_MEDIUM 3391
#define IDS_PROTECT_PASSWORD_MUSTNAME   3392
#define IDS_PROTECT_PASSWORD_ERROR_DLGTITLE 3393
#define IDS_PROTECT_PASSWORD_NOMATCH    3394
#define IDS_PROTECT_OPERATION_PROTECT   3395
#define IDS_PROTECT_OPERATION_UNPROTECT 3396
#define IDS_SELECT_CERT_NO_CERT_ERROR   3397
#define IDS_SECONDS                     3398
#define IDS_MINUTES                     3399
#define IDS_HOURS                       3400
#define IDS_DAYS                        3401
#define IDS_INVALID_URL_ERROR           3402
#define IDS_INVALID_XCERT_INTERVAL      3403
#define IDS_EXTENDED_ERROR_INFO         3404
#define IDS_PROTECT_DECRYPTION_ERROR    3405
#define IDS_PROTECT_CANNOT_DECRYPT      3406

// Following resources are used to "Revocation Status" Extended Error Info
#define IDS_REV_STATUS_OK               3407
#define IDS_REV_STATUS_REVOKED_ON       3408
#define IDS_REV_STATUS_OK_WITH_CRL      3409
#define IDS_REV_STATUS_OFFLINE_WITH_CRL 3410
#define IDS_REV_STATUS_UNKNOWN_ERROR    3411

// New strings 5/15/2001.
#define IDS_WARNREMOTETRUST_ERROR       3412


// NOTE: pki\activex\xaddroot\resource reserve the range from 7000 to 7099
// for strings


// icons
#define IDI_INFO                        3409  
#define IDI_OK_CERT                     3410
#define IDI_REVOKED_CERT                3411
#define IDI_EXCLAMATION_CERT            3412
#define IDI_TRUSTLIST                   3413
#define IDI_REVOKED_TRUSTLIST           3414
#define IDI_EXCLAMATION_TRUSTLIST       3416
#define IDI_REVOCATIONLIST              3417
#define IDI_CATLIST                     3418
#define IDI_REVOKED_CATLIST             3419
#define IDI_EXCLAMATION_CATLIST         3420
#define IDI_SIGN                        3421
#define IDI_REVOKED_SIGN                3422
#define IDI_EXCLAMATION_SIGN            3423
#define IDI_CA                          3424
#define IDI_PFX                         3425
#define IDI_CERTMGR                     3426


// NOTE: pki\activex\xaddroot\cactl2.h reserve the range from 3490 to 3499
// for icons

// for dacui resources                  4000-6000  


//NOTE:  cryptwzr.lib reserve 6000-8000 range for resources      


//  Select Certificate control ids
#define IDC_CS_PROPERTIES               100
#define IDC_CS_FINEPRINT                101
#define IDC_CS_CERTLIST                 102

#define IDC_CS_INFO                     103
#define IDC_CS_VALIDITY                 104
#define IDC_CS_ALGORITHM                105
#define IDC_CS_SERIAL_NUMBER            106
#define IDC_CS_THUMBPRINT               107
 


//  Certificate View General Page
#define IDC_ADD_TO_STORE_BUTTON         101
#define IDC_DISCLAIMER_BUTTON           102
#define IDC_GOODFOR_EDIT                103
#define IDC_SUBJECT_EDIT                105
#define IDC_ISSUER_EDIT                 106
#define IDC_ACCEPT_BUTTON               108
#define IDC_DECLINE_BUTTON              109
#define IDC_CERT_GENERAL_HEADER         110
#define IDC_CERT_GENERAL_GOODFOR_HEADER 111
#define IDC_CERT_GENERAL_ISSUEDTO_HEADER 113
#define IDC_CERT_GENERAL_ISSUEDBY_HEADER 114
#define IDC_CERT_GENERAL_VALID_EDIT     115
#define IDC_CERT_GENERAL_ERROR_EDIT     116
#define IDC_CERT_ISSUER_WARNING_EDIT    117
#define IDC_CERT_PRIVATE_KEY_EDIT       118

// Certificate view details page
#define IDC_SHOW_DETAILS_COMBO          100
#define IDC_ITEM_LIST                   101
#define IDC_DETAIL_EDIT                 102
#define IDC_SAVE_CERTIFICATE_BUTTON     103  
#define IDC_MYHAND                      104 
#define IDC_EDIT_PROPERTIES_BUTTON      105

//  Certificate View Hierarchy Page
#define IDC_TRUST_VIEW                  100
#define IDC_TRUST_TREE                  101
#define IDC_HIERARCHY_EDIT              102
#define IDC_USAGE_COMBO                 103
#define IDC_CERTIFICATE_PURPOSE_STATIC  104
#define IDC_NOTE2_STATIC                 105


// CTL General Page
#define IDC_CTL_GENERAL_ITEM_LIST       100
#define IDC_CTL_GENERAL_DETAIL_EDIT     101
#define IDC_CTL_GENERAL_VIEW_BUTTON     102
#define IDC_CTL_GENERAL_VALIDITY_EDIT   103
#define IDC_CTL_GENERAL_HEADER_EDIT     104

// CTL Trust List Page
#define IDC_CTL_TRUSTLIST_CERTIFICATE_LIST  100
#define IDC_CTL_TRUSTLIST_DETAIL_EDIT       101
#define IDC_CTL_TRUSTLIST_VIEW_BUTTON       102
#define IDC_CTL_TRUSTLIST_CERTVALUE_LIST    103

// Catalog File Page
#define IDC_CATALOG_ENTRY_LIST          100
#define IDC_CATALOG_ENTRY_DETAIL_LIST   101
#define IDC_CATALOG_ENTRY_DETAIL_EDIT   102

// CRL General Page
#define IDC_CRL_GENERAL_ITEM_LIST       100
#define IDC_CRL_GENERAL_DETAIL_EDIT     101
#define IDC_CRL_GENERAL_HEADER_EDIT     102

// CRL Revocation List Page
#define IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES 100
#define IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST 101
#define IDC_CRL_REVOCATIONLIST_DETAIL_EDIT          102

// for CPS dialog
#define IDOK_CPS                        100
#define IDCANCEL_CPS                    101
#define IDC_CPS_TEXT                    102
#define ID_MORE_INFO                    103

// properties dialog
#define IDC_KEY_USAGE_LIST              100
#define IDC_DESCRIPTION                 101
#define IDC_CERTIFICATE_NAME            102
#define IDC_PROPERTY_NEWOID             103
#define IDC_ENABLE_ALL_RADIO            104
#define IDC_DISABLE_ALL_RADIO           105
#define IDC_ENABLE_SELECT_RADIO         106
#define IDC_HIDDEN_RICHEDIT             107

// cross cert properties dialog
#define IDC_CHECKFORNEWCERTS_CHECK      100
#define IDC_NUMBEROFUNITS_EDIT          101
#define IDC_UNITS_COMBO                 102
#define IDC_ADDURL_BUTTON               103
#define IDC_USE_DEFAULT_BUTTON          104
#define IDC_NEWURL_EDIT                 105
#define IDC_URL_LIST                    106
#define IDC_REMOVEURL_BUTTON            107

// signer info general page
#define IDC_SIGNER_GENERAL_SIGNER_NAME  100
#define IDC_SIGNER_GENERAL_EMAIL        101
#define IDC_SIGNER_GENERAL_SIGNING_TIME 102
#define IDC_SIGNER_GENERAL_VIEW_CERTIFICATE 103
#define IDC_SIGNER_GENERAL_COUNTER_SIGS 104
#define IDC_SIGNER_GENERAL_DETAILS      105
#define IDC_SIGNER_GENERAL_HEADER_EDIT  106
#define IDC_SIGNER_GENERAL_VALIDITY_EDIT 107

// signer info advanced page
#define IDC_SIGNER_ADVANCED_DETAILS     100
#define IDC_SIGNER_ADVANCED_VALUE       101

// signatures dialog
#define IDC_SIGNATURES_DETAILS_BUTTON   100
#define IDC_SIGNATURES_SIG_LIST         101

// select store
#define IDC_SHOWPHYSICALSTORES_CHECK    100
#define IDC_SELECTSTORE_TREE            101
#define IDC_SELECTSTORE_DISPLAYSTRING   102

// select cert
#define IDC_SELECTCERT_CERTLIST         100
#define IDC_SELECTCERT_DISPLAYSTRING    101
#define IDC_SELECTCERT_VIEWCERT_BUTTON  102
#define IDC_SELECTCERT_ADDFROMDS_BUTTON 103



#define IDC_LIST1                       1014
#define IDC_EDIT1                       1016

#define IDC_STATIC                      -1


//
// Data Protection API control values.
//


#define IDC_PROTECT_PASSWORD1                   1020
#define IDC_PROTECT_EDIT2                       1021
#define IDC_PROTECT_BUTTON3                     1022
#define IDC_PROTECT_MESSAGE                     1023
#define IDC_PROTECT_APP_MSG                     1024
#define IDC_PROTECT_DEFINENEW                   1025
#define IDC_PROTECT_RADIO_LOW                   1026
#define IDC_PROTECT_RADIO_MEDIUM                1027
#define IDC_PROTECT_RADIO_HIGH                  1028
#define IDC_PROTECT_ADVANCED                    1029

#define IDC_PROTECT_CACHEPW                     1030
#define IDC_PROTECT_CHANGE_SECURITY             1031
#define IDC_PROTECT_BACK                        1032
#define IDC_PROTECT_NEXT                        1033
#define IDC_PROTECT_PW_NEWNAME                  1034
#define IDC_PROTECT_LABEL_EDIT1                 1035
#define IDC_PROTECT_MAIN_CAPTION                1036
#define IDC_PROTECT_STATIC1                     1037
#define IDC_PROTECT_STATIC2                     1038
#define IDC_PROTECT_STATIC3                     1039

#define IDC_PROTECT_STATIC4                     1040
#define IDC_PROTECT_STATIC5                     1041
#define IDC_PROTECT_STATIC6                     1042
#define IDC_PROTECT_STATIC7                     1043
#define IDC_PROTECT_STATIC8                     1044
#define IDC_PROTECT_SECURITY_LEVEL              1045
#define IDC_PROTECT_UPDATE_DYNAMIC              1046

#define IDC_PROTECT_DESCRIPTION                 1047
#define IDC_PROTECT_PATH                        1048
#define IDC_PROTECT_ACCESSTYPE                  1049

#define IDC_PROTECT_APP_DESCRIPTION             1050
#define IDC_PROTECT_APP_PATH                    1051
#define IDC_PROTECT_OPERATION_TYPE              1052
     
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        3217
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1090
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define IDH_CS_CERTLIST                 (1000+IDC_CS_CERTLIST)
#define IDH_CS_PROPERTIES               (1000+IDC_CS_CERTLIST)
#define IDH_CS_ALGORITHM                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_STATUS                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_FINEPRINT                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_TEXT                (1000+IDC_CS_CERTLIST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\pwdui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       pwdui.h
//
//--------------------------------------------------------------------------


#ifndef _PWDUI_H_
#define _PWDUI_H_

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
ProtectUI_DllMain(
    HINSTANCE hinstDLL, // handle to DLL module
    DWORD fdwReason,    // reason for calling function
    LPVOID lpvReserved  // reserved
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _PWDUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\linkutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       linkutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CryptuiGoLink(HWND hwndParent, char *pszWhere, BOOL fNoCOM)
{
    HCURSOR hcursPrev = NULL;
    HMODULE hURLMon = NULL;
    BOOL    fCallCoUnInit = FALSE;
    
    //
    //  since we're a model dialog box, we want to go behind IE once it comes up!!!
    //
    SetWindowPos(hwndParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

    hcursPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    __try
    {

    hURLMon = (HMODULE)LoadLibraryU(L"urlmon.dll");

    if (!(hURLMon) || fNoCOM)
    {
        //
        // The hyperlink module is unavailable, go to fallback plan
        //
        //
        // This works in test cases, but causes deadlock problems when used from withing
        // the Internet Explorer itself. The dialog box is up (that is, IE is in a modal
        // dialog loop) and in comes this DDE request...).
        //
        ShellExecute(hwndParent, "open", pszWhere, NULL, NULL, SW_SHOWNORMAL);
    } 
    else 
    {
        //
        // The hyperlink module is there. Use it
        //
        if (SUCCEEDED(CoInitialize(NULL)))       // Init OLE if no one else has
        {
            fCallCoUnInit = TRUE;

            //
            //  allow com to fully init...
            //
            MSG     msg;

            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE); // peek but not remove

            typedef void (WINAPI *pfnHlinkSimpleNavigateToString)(LPCWSTR, LPCWSTR, LPCWSTR, IUnknown *,
                                                                  IBindCtx *, IBindStatusCallback *,
                                                                  DWORD, DWORD);

            pfnHlinkSimpleNavigateToString      pProcAddr;

            pProcAddr = (pfnHlinkSimpleNavigateToString)GetProcAddress(hURLMon, TEXT("HlinkSimpleNavigateToString"));

            if (pProcAddr)
            {
                WCHAR       *pwszWhere;
                IBindCtx    *pbc;  

                pwszWhere = new WCHAR[strlen(pszWhere) + 1];
                if (pwszWhere == NULL)
                {
                    return;
                }

                MultiByteToWideChar(0, 0, (const char *)pszWhere, -1, pwszWhere, strlen(pszWhere) + 1);

                pbc = NULL;

                CreateBindCtx( 0, &pbc ); 
                
                (*pProcAddr)(pwszWhere, NULL, NULL, NULL, pbc, NULL, HLNF_OPENINNEWWINDOW, NULL);

                if (pbc)
                {
                    pbc->Release();
                }

                delete [] pwszWhere;
            }
        
            CoUninitialize();
        }

        FreeLibrary(hURLMon);
    }

    SetCursor(hcursPrev);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (hURLMon != NULL)
        {
            FreeLibrary(hURLMon);   
        }

        if (fCallCoUnInit)
        {
            CoUninitialize();
        }

        if (hcursPrev != NULL)
        {
            SetCursor(hcursPrev);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndGetIssuerURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION     pExt = NULL;
    PSPC_SP_AGENCY_INFO pInfo = NULL;
    DWORD               cbInfo = 0;
    PCERT_ALT_NAME_ENTRY pAltName = NULL;
    DWORD               cbAltName = 0;

    *ppURLString = NULL;

    //
    // first look for the Agency Info extension and see if it has an URL 
    //
    if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbInfo);

        if (!(pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pInfo,
                                &cbInfo)))
        {
            free(pInfo);
            return FALSE;
        } 

        if (!(pInfo->pPolicyInformation))
        {
            free(pInfo);
            return FALSE;
        }

        switch (pInfo->pPolicyInformation->dwLinkChoice)
        {
            case SPC_URL_LINK_CHOICE:
                if (NULL != (*ppURLString = 
                    (LPSTR) malloc(wcslen(pInfo->pPolicyInformation->pwszUrl)+1)))
                {
                    WideCharToMultiByte(
                            0,
                            0,
                            pInfo->pPolicyInformation->pwszUrl,
                            -1,
                            *ppURLString,
                            wcslen(pInfo->pPolicyInformation->pwszUrl)+1,
                            NULL,
                            NULL);
                    
                    free(pInfo);
                    return TRUE;
                }
                else
                {
                    free(pInfo);
                    return FALSE;   
                }
                break;
            case SPC_FILE_LINK_CHOICE:
                if (NULL != (*ppURLString = 
                    (LPSTR) malloc(wcslen(pInfo->pPolicyInformation->pwszFile)+1)))
                {
                    WideCharToMultiByte(
                            0,
                            0,
                            pInfo->pPolicyInformation->pwszFile,
                            -1,
                            *ppURLString,
                            wcslen(pInfo->pPolicyInformation->pwszFile)+1,
                            NULL,
                            NULL);

                    return TRUE;
                }
                else
                {
                    free(pInfo);
                    return FALSE;
                }
                break;
        }
        free(pInfo);
    }

    //
    // if there was no Agency Info extension or it didn't contain an URL,
    // look for the Authority Info Access Syntax extension
    //
    /*if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        FIX FIX
    }*/

    //
    // finally, if there was no Agency Info and no Authority Info Access Syntax
    // check to see if there is an Alternate Name extension
    //
    if ((pExt = CertFindExtension(szOID_ISSUER_ALT_NAME, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, szOID_ISSUER_ALT_NAME,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbAltName);

        if (!(pAltName = (PCERT_ALT_NAME_ENTRY) malloc(cbAltName)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, szOID_ISSUER_ALT_NAME,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pAltName,
                                &cbAltName)))
        {
            free(pAltName);
            return FALSE;
        }   
        
        if (pAltName->dwAltNameChoice == CERT_ALT_NAME_URL)
        {
            if (NULL != (*ppURLString = (LPSTR) malloc(wcslen(pAltName->pwszURL)+1)))
            {
                WideCharToMultiByte(
                            0,
                            0,
                            pAltName->pwszURL,
                            -1,
                            *ppURLString,
                            wcslen(pAltName->pwszURL)+1,
                            NULL,
                            NULL);

                free(pAltName);
                return TRUE;
            }
        }
        free(pAltName);
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndGetSubjectURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION     pExt = NULL;
    PCERT_ALT_NAME_ENTRY pAltName = NULL;
    DWORD               cbAltName = 0;
    
    *ppURLString = NULL;
    
    //
    // check to see if there is an Alternate Name extension
    //
    if ((pExt = CertFindExtension(szOID_SUBJECT_ALT_NAME, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, szOID_SUBJECT_ALT_NAME,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbAltName);

        if (!(pAltName = (PCERT_ALT_NAME_ENTRY) malloc(cbAltName)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, szOID_SUBJECT_ALT_NAME,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pAltName,
                                &cbAltName)))
        {
            free(pAltName);
            return FALSE;
        }   
        
        if (pAltName->dwAltNameChoice == CERT_ALT_NAME_URL)
        {
            if (NULL != (*ppURLString = (LPSTR) malloc(wcslen(pAltName->pwszURL)+1)))
            {
                WideCharToMultiByte(
                            0,
                            0,
                            pAltName->pwszURL,
                            -1,
                            *ppURLString,
                            wcslen(pAltName->pwszURL)+1,
                            NULL,
                            NULL);

                free(pAltName);
                return TRUE;
            }
        }
        free(pAltName);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\selcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       selcert.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

#define MAX_SIZE_OF_COLUMNS 400

static const HELPMAP helpmap[] = {
    {IDC_SELECTCERT_VIEWCERT_BUTTON,IDH_SELECTCERTIFICATE_VIEWCERT_BUTTON},
    {IDC_SELECTCERT_CERTLIST,       IDH_SELECTCERTIFICATE_CERTIFICATE_LIST}
};


class CertContextList { 
public: 
    CertContextList() : m_head(NULL) { }
    ~CertContextList(); 

    HRESULT Add(IN  PCCERT_CONTEXT pCertContext, 
		OUT BOOL           *pfReplacedExisting) ;

    HRESULT SyncWithStore(HCERTSTORE hStore, DWORD dwFlags); 

private:
    typedef struct _CertContextListEle { 
	PCCERT_CONTEXT               pCertContext; 
	struct _CertContextListEle * pNext; 
    } CertContextListEle; 

    CertContextListEle * m_head; 
};

typedef struct _CERT_SELECT_HELPER
{
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    PCCERT_CONTEXT                      pSelectedCert;
    DWORD                               rgdwSortParam[6];
    BOOL                                fCertListDblClick;
    CertContextList                    *pCertsFromDS; 
} CERT_SELECT_HELPER, *PCERT_SELECT_HELPER;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////

static void AddCertToList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp, PCCERT_CONTEXT pCertContext, int itemIndex)
{
    LPWSTR                                  pwszText;
    DWORD                                   cbText;
    WCHAR                                   szText[CRYPTUI_MAX_STRING_SIZE];
    int                                     subItemIndex;
    LV_ITEMW                                lvI;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW     pcsc;

    pcsc = pviewhelp->pcsc;

    //
    // set up the fields in the list view item
    //
    lvI.mask = LVIF_PARAM | LVIF_STATE | LVIF_IMAGE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 0;
    lvI.lParam = (LPARAM) CertDuplicateCertificateContext(pCertContext);
    lvI.iItem = itemIndex;
    ListView_InsertItemU(hWndListView, &lvI);

    subItemIndex = 0;

    //
    // issued to
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText));
        ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
    }

    //
    // issued by
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText));
        ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
    }

    //
    // intended use
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
    {
        if (FormatEnhancedKeyUsageString(&pwszText, pCertContext, FALSE, FALSE))
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex, pwszText);
            free(pwszText);
        }
        subItemIndex++;
    }

    //
    // friendly name
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
    {
        cbText = 0;
        if (CertGetCertificateContextProperty(  pCertContext,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                NULL,
                                                &cbText)                    &&
           (NULL != (pwszText = (LPWSTR) malloc(cbText))))
        {
            CertGetCertificateContextProperty(  pCertContext,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                pwszText,
                                                &cbText);
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
        else
        {
            LoadStringU(HinstDll, IDS_FRIENDLYNAME_NONE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
    }

    //
    // expiration
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
    {
        if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotAfter, FALSE, FALSE, hWndListView))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
        else
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
    }

    //
    // location
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
    {
        pwszText = (LPWSTR) GetStoreName(pCertContext->hCertStore, TRUE);
        if (pwszText == NULL)
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
        else
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
    }
}


static int ReplaceCertInList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp, PCCERT_CONTEXT pCertContext)
{
    int     nIndex = -1; 
    LV_ITEM lvitem; 

    while (-1 != (nIndex = ListView_GetNextItem(hWndListView, nIndex, LVNI_ALL)))
    {
        //DSIE: Bug 420717
        memset(&lvitem, 0, sizeof(lvitem));

        lvitem.iItem = nIndex; 
        lvitem.mask  = LVIF_PARAM; 
        if (ListView_GetItem(hWndListView, &lvitem))
        {
            PCCERT_CONTEXT pCurrent = (PCCERT_CONTEXT)lvitem.lParam; 
            if (pCurrent->dwCertEncodingType == pCertContext->dwCertEncodingType)
            {
                if (CertCompareCertificate(pCertContext->dwCertEncodingType, 
                                           pCertContext->pCertInfo, 
                                           pCurrent->pCertInfo))
                {
                    // Found a match, replace the certificate. 
                    CertFreeCertificateContext(pCurrent); 
                    ListView_DeleteItem(hWndListView, nIndex); 
                    // Now, add our new certificate at this index. 
                    AddCertToList(hWndListView, pviewhelp, pCertContext, nIndex);
                    goto CommonReturn; 
                }
            }
        }
    }
		    
    // No match, nothing to replace, just append to the list. 
    AddCertToList(hWndListView, pviewhelp, pCertContext, ListView_GetItemCount(hWndListView)); 
    
CommonReturn: 
    return nIndex; 
}


// DSIE: Bug 207106
BOOL SupportEncryptedFileSystem(PCCERT_CONTEXT pCertContext)
{
    BOOL                fSuccess = FALSE;
    DWORD               cbUsage  = 0;
    PCERT_ENHKEY_USAGE  pUsage   = NULL;

    if (!pCertContext)
        return FALSE;

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &cbUsage))
        goto CleanUp;

    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) malloc(cbUsage)))
        goto CleanUp;

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &cbUsage))
        goto CleanUp;

    if (0 == pUsage->cUsageIdentifier)
    {
        if (CRYPT_E_NOT_FOUND == GetLastError())
        {
            fSuccess = TRUE;
        }
    }
    else
    {
        for (DWORD i = 0; i < pUsage->cUsageIdentifier; i++)
        {
            if (0 == strcmp(szOID_ENHANCED_KEY_USAGE, pUsage->rgpszUsageIdentifier[i]))
            {
                fSuccess = TRUE;
                goto CleanUp;
            }
        }
    }

CleanUp:
    if (pUsage)
        free(pUsage);

    return fSuccess;
}


//DSIE: Bug 314005. Major change to switch over to use Object Picker.
HRESULT AddFromDS(HWND hwndDlg, PCERT_SELECT_HELPER pviewhelp)
{
    static const int     SCOPE_INIT_COUNT = 1;
    IDsObjectPicker    * pDsObjectPicker  = NULL;
    IDataObject        * pdo              = NULL;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
    DSOP_INIT_INFO       InitInfo;
    UINT                 cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    HWND                 hWndListView     = NULL; 

    BOOL                 fGotStgMedium    = FALSE;
    PDS_SELECTION_LIST   pDsSelList       = NULL;
    STGMEDIUM            stgmedium        = {TYMED_HGLOBAL, NULL, NULL};
    FORMATETC            formatetc        = {(CLIPFORMAT) cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT              hr;
    HCERTSTORE           hDSCertStore     = NULL; 

    PCCERT_CONTEXT       pCertContext     = NULL; 
    PCCERT_CONTEXT       pCertContextPrev = NULL;     
    CertContextList    * pCertContextList = NULL; 

    WCHAR                errorString[512]; 
    WCHAR                errorTitle[512]; 
    BOOL                 fInitialSelectedCert = FALSE;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW  pcsc = NULL;

    // Input validation: 
    if (NULL == hwndDlg         || 
	    NULL == pviewhelp       || 
	    NULL == pviewhelp->pcsc || 
	    NULL == pviewhelp->pCertsFromDS)
	return E_INVALIDARG; 

    // Init: 
    pcsc             = pviewhelp->pcsc; 
    pCertContextList = pviewhelp->pCertsFromDS; 
    hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

    CoInitialize(NULL);
    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);
    if (FAILED(hr) || NULL == pDsObjectPicker)
	    goto ComError; 
 
    // Initialize the DSOP_SCOPE_INIT_INFO array.
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
 
    // Combine multiple scope types in a single array entry.
    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                         | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
 
    // Set uplevel and downlevel filters to include only computer objects.
    // Uplevel filters apply to both mixed and native modes.
    // Notice that the uplevel and downlevel flags are different.
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
 
    // Initialize the DSOP_INIT_INFO structure.
    ZeroMemory(&InitInfo, sizeof(InitInfo));
    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // Target is the local computer.
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    //InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
 
    // You can call Initialize multiple times; last call wins.
    // Note that object picker makes its own copy of InitInfo.
    hr = pDsObjectPicker->Initialize(&InitInfo);
    if (FAILED(hr))
        goto ComError;

    // Invoke the modal dialog.
    hr = pDsObjectPicker->InvokeDialog(hwndDlg, &pdo);
    if (FAILED(hr)) 
        goto ComError;

    // User pressed Cancel.
    if (hr == S_FALSE)
    {
        hr = E_ABORT;
        goto cleanup;
    }
 
    // Get the global memory block containing the user's selections.
    hr = pdo->GetData(&formatetc, &stgmedium);
    if (FAILED(hr)) 
        goto ComError;
    
    fGotStgMedium = TRUE;
 
    // Retrieve pointer to DS_SELECTION_LIST structure.
    pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
    if (!pDsSelList) 
        goto ComError;
 
    // Loop through DS_SELECTION array of selected objects.
    for (ULONG i = 0; i < pDsSelList->cItems; i++) 
    {
	    WCHAR  pwszLdapUrl[2048]; 
        LPWSTR pTemp = pDsSelList->aDsSelection[i].pwzADsPath;
	    
	    BOOL   fReplacedExisting; 
	    BOOL   fHasEFSCerts = FALSE; 

        // Now is the time to get the certificate
	    LPCWSTR szCertAttr = L"?userCertificate"; 
	    
	    // Check if our buffer is too small to hold the query.  
	    if (wcslen(pTemp) + wcslen(szCertAttr) + 1 > (sizeof(pwszLdapUrl) / sizeof(pwszLdapUrl[0])))
		    goto UnexpectedErr; 

	    wcscpy(pwszLdapUrl, pTemp);
	    wcscat(pwszLdapUrl, szCertAttr);
	    
        // Now open the DS store using LDAP provider.
	    hDSCertStore = CertOpenStore(sz_CERT_STORE_PROV_LDAP,
		                             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		                             NULL,
		                             CERT_STORE_READONLY_FLAG,
		                             (void*) pwszLdapUrl);
	    if (NULL == hDSCertStore)
		    goto CertCliError; 
    
	    // We get the certificate store
	    pCertContext     = NULL; 
	    pCertContextPrev = NULL; 
	    int            nItemIndex;

	    while (NULL != (pCertContext = CertEnumCertificatesInStore(hDSCertStore, pCertContextPrev)))
	    {
		    // Apply our filter callback function to see if we should display this certificate. 
	        BOOL fAllowCert = FALSE;
            
            if (pcsc->pFilterCallback)
                fAllowCert = (*(pcsc->pFilterCallback))(pCertContext, &fInitialSelectedCert, pcsc->pvCallbackData);

            fAllowCert |= SupportEncryptedFileSystem(pCertContext); 

		    if (fAllowCert) 
            {
		        fHasEFSCerts = TRUE; 

		        if (S_OK != (hr = pCertContextList->Add(pCertContext, &fReplacedExisting)))
			        goto ErrorReturn; 

		        nItemIndex = ReplaceCertInList(hWndListView, pviewhelp, pCertContext); 

		        // if the select cert dialog caller said that this should be the initially
		        // selected cert then make it so.
		        if (fInitialSelectedCert)
			        ListView_SetItemState(hWndListView, nItemIndex, LVIS_SELECTED, LVIS_SELECTED);
		    }
		    
		    pCertContextPrev = pCertContext; 
	    }

	    // We didn't reach the end of the enumeration.  This is an error. 
	    if (GetLastError() != CRYPT_E_NOT_FOUND)
		    goto CertCliError; 

	    // We didn't find any EFS certs: display an error message and pop up the window again. 
	    if (!fHasEFSCerts)
		    goto NoEfsError; 
    }
 
    hr = S_OK;

 cleanup: 
    if (hDSCertStore)        
    { 
        CertCloseStore(hDSCertStore, 0); 
    } 

    if (NULL != pCertContext)        
    { 
        CertFreeCertificateContext(pCertContext); 
    } 

    if (pDsSelList)
    {
        GlobalUnlock(stgmedium.hGlobal);
    }

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium); 
    }

    if (pdo)
    {
        pdo->Release();
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }

    CoUninitialize();

    return hr;

 ErrorReturn: 
    { 
        WCHAR wszText[MAX_STRING_SIZE]; 
        WCHAR errorTitle2[MAX_STRING_SIZE]; 
        LPWSTR pwszErrorMsg = NULL; 

        //get the text string
        if(LoadStringU(HinstDll, IDS_INTERNAL_ERROR, wszText, sizeof(wszText) / sizeof(wszText[0])))
        {
            if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               hr,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               (LPWSTR) &pwszErrorMsg,
                               0,
                               NULL))
            {
                if (LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle2, ARRAYSIZE(errorTitle2))) { 
                        MessageBoxU(hwndDlg, pwszErrorMsg, errorTitle2, MB_ICONERROR|MB_OK|MB_APPLMODAL);
                }
            }
        }
        
        if (NULL != pwszErrorMsg) { LocalFree(pwszErrorMsg); } 
    }
    goto cleanup; 

 CertCliError: 
    hr = HRESULT_FROM_WIN32(GetLastError()); 
    goto ErrorReturn; 

 ComError:
    goto ErrorReturn; 

 NoEfsError:
    LoadStringU(HinstDll, IDS_SELECT_CERT_NO_CERT_ERROR, errorString, ARRAYSIZE(errorString));
    if (pcsc->szTitle != NULL)
    {
	    MessageBoxU(hwndDlg, errorString, pcsc->szTitle, MB_OK | MB_ICONWARNING);
    }
    else
    {
	    LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
	    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
    }
    hr = AddFromDS(hwndDlg, pviewhelp); 
    goto cleanup; 

 UnexpectedErr:
    hr = E_UNEXPECTED; 
    goto ErrorReturn; 
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertsToList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp)
{
    DWORD                               i;
    PCCERT_CONTEXT                      pCertContext;
    int                                 itemIndex = 0;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    BOOL                                fInitialSelectedCert = FALSE;

    pcsc = pviewhelp->pcsc;

    //
    // loop for each store and display the certs in each store
    //
    for (i=0; i<pcsc->cDisplayStores; i++)
    {
        //
        // loop for each cert in the store
        //
        pCertContext = NULL;
        while (NULL != (pCertContext = CertEnumCertificatesInStore(pcsc->rghDisplayStores[i], pCertContext)))
        {
            fInitialSelectedCert = FALSE;

            if ((pcsc->pFilterCallback == NULL) ||
                ((*(pcsc->pFilterCallback))(pCertContext, &fInitialSelectedCert, pcsc->pvCallbackData) == TRUE))
            {
                AddCertToList(hWndListView, pviewhelp, pCertContext, itemIndex);

                //
                // if the select cert dialog caller said that this should be the initially
                // selected cert then make it so.
                //
                if (fInitialSelectedCert)
                {
                    ListView_SetItemState(hWndListView, itemIndex, LVIS_SELECTED, LVIS_SELECTED);
                }

                itemIndex++;
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int CalculateColumnWidth(DWORD dwDontUseColumn)
{
    int numColumns = 0;

    if (!(dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
    {
        numColumns++;
    }

    if (numColumns >= 2)
    {
        return (MAX_SIZE_OF_COLUMNS / numColumns);
    }
    else
    {
        return MAX_SIZE_OF_COLUMNS;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY SelectCertDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WCHAR                               szText[CRYPTUI_MAX_STRING_SIZE];
    HWND                                hWndListView;
    LV_COLUMNW                          lvC;
    int                                 iCol = 0;
    LV_ITEMW                            lvI;
    int                                 listIndex;
    LPNMLISTVIEW                        pnmv;
    PCERT_SELECT_HELPER                 pviewhelp;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    WCHAR                               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    HWND                                hwnd;
    HIMAGELIST                          hIml;
    DWORD                               dwSortParam;
    int                                 SortParamIndex;

    switch ( msg ) {

    case WM_INITDIALOG:
        pviewhelp = (PCERT_SELECT_HELPER) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pcsc = pviewhelp->pcsc;

        //
        // set the dialog title and the display string
        //
        if (pcsc->szTitle != NULL)
        {
            SetWindowTextU(hwndDlg, pcsc->szTitle);
        }

        if (pcsc->szDisplayString != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_SELECTCERT_DISPLAYSTRING, pcsc->szDisplayString);
        }
        else
        {
            if (pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT)
            {
                LoadStringU(HinstDll, IDS_SELECT_MULTIPLE_CERT_DEFAULT, szText, ARRAYSIZE(szText));
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_CERT_DEFAULT, szText, ARRAYSIZE(szText));
            }
            SetDlgItemTextU(hwndDlg, IDC_SELECTCERT_DISPLAYSTRING, szText);
        }

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        //
        // initialize the image list for the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_CERT), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);
        ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);

        //
        // add the colums to the list view
        //

        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;// | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.
        lvC.cx = CalculateColumnWidth(pviewhelp->pcsc->dwDontUseColumn);

        memset(&(pviewhelp->rgdwSortParam[0]), 0, ARRAYSIZE(pviewhelp->rgdwSortParam));
        SortParamIndex = 0;

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
        {
            LoadStringU(HinstDll, IDS_ISSUEDTO2, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_SUBJECT | SORT_COLUMN_ASCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
        {
            LoadStringU(HinstDll, IDS_ISSUEDBY2, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_ISSUER | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
        {
            LoadStringU(HinstDll, IDS_INTENDED_PURPOSE, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] =SORT_COLUMN_PURPOSE | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
        {
            LoadStringU(HinstDll, IDS_CERTIFICATE_NAME, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
        {
            LoadStringU(HinstDll, IDS_EXPIRATION_DATE, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_EXPIRATION | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
        {
            LoadStringU(HinstDll, IDS_LOCATION, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_LOCATION | SORT_COLUMN_DESCEND; 
        }

        AddCertsToList(hWndListView, pviewhelp);

        //
        // if there is no cert selected initially disable the "view cert button"
        //
        if (ListView_GetSelectedCount(hWndListView) == 0)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), FALSE);
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

#if (1) // DSIE: bug 338852.
        HWND hwndFindUser;

        if (hwndFindUser = GetDlgItem(hwndDlg, IDC_SELECTCERT_ADDFROMDS_BUTTON))
        {
            LPBYTE pDCName = NULL;

            DWORD dwError = NetGetDCName(NULL, NULL, &pDCName);

            if (NERR_Success == dwError)
            {
                NetApiBufferFree(pDCName);
            }
            else
            {
                EnableWindow(hwndFindUser, FALSE);
            }
        }
#endif
        
        ListView_SetItemState(hWndListView,
                              0,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
        SetFocus(hWndListView); 

        break;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsc = pviewhelp->pcsc;

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        switch (((NMHDR FAR *) lParam)->code)
        {

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON)))
                {
                    pviewhelp->fCertListDblClick = TRUE;

                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_SELECTCERT_VIEWCERT_BUTTON, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON));
                }
                break;
            }

            break;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (!(pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT))
                {
                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        ListView_SetItemState(
                            hWndListView,
                            ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED),
                            ~LVIS_SELECTED,
                            LVIS_SELECTED);
                    
                        EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), TRUE);
                    }
                }

                break;
            }

            break;

        case LVN_ITEMCHANGED:
    
            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (ListView_GetSelectedCount(hWndListView) == 1)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), FALSE);
                }                
            }
                
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SELECTCERT_CERTLIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;

        case LVN_COLUMNCLICK:

            pnmv = (NM_LISTVIEW FAR *) lParam;

            //
            // get the column number
            //
            dwSortParam = 0;

            switch (pnmv->iSubItem)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                        dwSortParam = pviewhelp->rgdwSortParam[pnmv->iSubItem];
                    break;
                default:
                        dwSortParam = 0;
                    break;
            }

            if (0 != dwSortParam)
            {
                //
                // flip the ascend ording
                //
                if (dwSortParam & SORT_COLUMN_ASCEND)
                {
                    dwSortParam &= 0x0000FFFF;
                    dwSortParam |= SORT_COLUMN_DESCEND;
                }
                else
                {
                    if (dwSortParam & SORT_COLUMN_DESCEND)
                    {
                        dwSortParam &= 0x0000FFFF;
                        dwSortParam |= SORT_COLUMN_ASCEND;
                    }
                }

                //
                // sort the column
                //
                SendDlgItemMessage(hwndDlg,
                    IDC_SELECTCERT_CERTLIST,
                    LVM_SORTITEMS,
                    (WPARAM) (LPARAM) dwSortParam,
                    (LPARAM) (PFNLVCOMPARE)CompareCertificate);

                pviewhelp->rgdwSortParam[pnmv->iSubItem] = dwSortParam;
            }

            break;

        }

        break;

    case WM_COMMAND:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsc = pviewhelp->pcsc;

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        switch (LOWORD(wParam))
        {

	case IDC_SELECTCERT_ADDFROMDS_BUTTON:
	    { 
		HRESULT hr = AddFromDS(hwndDlg, pviewhelp); 
		if (FAILED(hr))
		{
		    // Error
		}
		break; 
	    }

        case IDC_SELECTCERT_VIEWCERT_BUTTON:
            CRYPTUI_VIEWCERTIFICATE_STRUCTW cvps;
            BOOL                            fPropertiesChanged;

            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

            if (listIndex != -1)
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    //
                    // if the caller handed in a callback call them to see if they
                    // want to handle the display of the cert, otherwise display the cert
                    //
                    if ((pcsc->pDisplayCallback != NULL) &&
                        ((*(pcsc->pDisplayCallback))((PCCERT_CONTEXT) lvI.lParam, hwndDlg, pcsc->pvCallbackData) == TRUE))
                    {
                        //
                        // set the fPropertiesChanged bool to true so that the cert will
                        // get refreshed in the display.  this doesn't hurt anything even
                        // if the cert didn't change
                        //
                        fPropertiesChanged = TRUE;
                    }
                    else
                    {
                        memset(&cvps, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
                        cvps.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW);
                        cvps.hwndParent = hwndDlg;
                        cvps.pCertContext = (PCCERT_CONTEXT) lvI.lParam;
                        cvps.cStores = pviewhelp->pcsc->cStores;
                        cvps.rghStores = pviewhelp->pcsc->rghStores;
                        cvps.cPropSheetPages = pviewhelp->pcsc->cPropSheetPages;
                        cvps.rgPropSheetPages = pviewhelp->pcsc->rgPropSheetPages;
                        CryptUIDlgViewCertificateW(&cvps, &fPropertiesChanged);
                    }

                    //
                    // if the properties changed then refresh the cert in the list
                    //
                    if (fPropertiesChanged)
                    {
                        ListView_DeleteItem(hWndListView, listIndex);
                        AddCertToList(hWndListView, pviewhelp, (PCCERT_CONTEXT) lvI.lParam, listIndex);
                        ListView_SetItemState(hWndListView, listIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    }

                    if (!pviewhelp->fCertListDblClick)
                    {
                        SetFocus(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON));
                    }

                    pviewhelp->fCertListDblClick = FALSE;
                }
            }

            break;

        case IDOK:
            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

            if (listIndex != -1)
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                
                if (!(pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT))
		{
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        pviewhelp->pSelectedCert = CertDuplicateCertificateContext((PCCERT_CONTEXT) lvI.lParam);
                    }
                }
                else 
                {
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        CertAddCertificateContextToStore(
                                pcsc->hSelectedCertStore,
                                (PCCERT_CONTEXT) lvI.lParam,
                                CERT_STORE_ADD_ALWAYS,
                                NULL);
                    }

                    while (-1 != (listIndex = ListView_GetNextItem(
                                                    hWndListView, 		
                                                    listIndex, 		
                                                    LVNI_SELECTED		
                                                    )))
                    {
                        lvI.iItem = listIndex;
                        if (ListView_GetItemU(hWndListView, &lvI))
                        {
                            CertAddCertificateContextToStore(
                                    pcsc->hSelectedCertStore,
                                    (PCCERT_CONTEXT) lvI.lParam,
                                    CERT_STORE_ADD_ALWAYS,
                                    NULL);
                        }
                    }
                }
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_CERT_ERROR, errorString, ARRAYSIZE(errorString));
                if (pcsc->szTitle != NULL)
                {
                    MessageBoxU(hwndDlg, errorString, pcsc->szTitle, MB_OK | MB_ICONWARNING);
                }
                else
                {
                    LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                return TRUE;
            }

            EndDialog(hwndDlg, NULL);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }

        break;

    case WM_DESTROY:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                CertFreeCertificateContext((PCCERT_CONTEXT) lvI.lParam);
            }
            lvI.iItem--;
        }
        
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDOK))                             &&
            (hwnd != GetDlgItem(hwndDlg, IDCANCEL))                         &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            )
{
    CERT_SELECT_HELPER viewhelper;
    WORD               wDialogID; 

    if (CommonInit() == FALSE)
    {
        return NULL;
    }

    if ((pcsc->dwSize != sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCTW)) &&
        (pcsc->dwSize != offsetof(CRYPTUI_SELECTCERTIFICATE_STRUCTW, hSelectedCertStore))) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }
    
    wDialogID = 
      pcsc->dwFlags & CRYPTUI_SELECTCERT_ADDFROMDS ? 
      IDD_SELECTCERT_DIALOG_WITH_DSPICKER          : 
      IDD_SELECTCERT_DIALOG; 

    viewhelper.pcsc              = pcsc;
    viewhelper.pSelectedCert     = NULL;
    viewhelper.fCertListDblClick = FALSE;
    viewhelper.pCertsFromDS      = new CertContextList; 
    if (NULL == viewhelper.pCertsFromDS)
    {
	SetLastError(E_OUTOFMEMORY); 
	return FALSE;
    }

    if (DialogBoxParamU(
                HinstDll,
                (LPWSTR) MAKEINTRESOURCE(wDialogID),
                (pcsc->hwndParent != NULL) ? pcsc->hwndParent : GetDesktopWindow(),
                SelectCertDialogProc,
                (LPARAM) &viewhelper) != -1)
    {
        SetLastError(0);
    }

    delete viewhelper.pCertsFromDS; 

    if (pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT)
    {
        return NULL;
    }
    else
    {
        return(viewhelper.pSelectedCert);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            )
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW   cscW;
    PCCERT_CONTEXT                      pReturnCert = NULL;

    memcpy(&cscW, pcsc, sizeof(cscW));
    
    if (!ConvertToPropPageW(
                pcsc->rgPropSheetPages,
                pcsc->cPropSheetPages,
                &(cscW.rgPropSheetPages)))
    {
        return NULL;
    }

    if (pcsc->szTitle)
    {
        cscW.szTitle = CertUIMkWStr(pcsc->szTitle);
    }

    if (pcsc->szDisplayString)
    {
        cscW.szDisplayString = CertUIMkWStr(pcsc->szDisplayString);
    }

    pReturnCert = CryptUIDlgSelectCertificateW(&cscW);

    FreePropSheetPagesW((LPPROPSHEETPAGEW) cscW.rgPropSheetPages, cscW.cPropSheetPages);

    if (cscW.szTitle)
    {
        free((void *) cscW.szTitle);
    }

    if (cscW.szDisplayString)
    {
        free((void *) cscW.szDisplayString);
    }

    return(pReturnCert);
}

////////////////////////////////////////////////////////////
//
// Implementation of utility class:  CertContextList
//
////////////////////////////////////////////////////////////

CertContextList::~CertContextList()
{
    CertContextListEle  *pListEle;
    CertContextListEle  *pListEleNext;

    for (pListEle = m_head; pListEle != NULL; pListEle = pListEleNext)
    {
	pListEleNext = pListEle->pNext; 
	if (pListEle->pCertContext != NULL) { CertFreeCertificateContext(pListEle->pCertContext); } 
	delete pListEle; 
    }
}
    
HRESULT CertContextList::Add(IN  PCCERT_CONTEXT pCertContext, 
			     OUT BOOL           *pfReplacedExisting) 
{ 
    HRESULT               hr = S_OK; 
    CertContextListEle   *pListEle = NULL; 
    CertContextListEle   *pListElePrev = NULL; 

    if (pCertContext == NULL || pfReplacedExisting == NULL) 
	return E_INVALIDARG; 
    
    for (pListEle = m_head; pListEle != NULL; pListEle = pListEle->pNext)
    {
	PCCERT_CONTEXT pCurrent = pListEle->pCertContext; 

	if (pCurrent->dwCertEncodingType == pCertContext->dwCertEncodingType)
	{
	    if (CertCompareCertificate
		(pCertContext->dwCertEncodingType, 
		 pCertContext->pCertInfo,
		 pCurrent->pCertInfo))
	    {
		// We're replacing an existing element.  
		*pfReplacedExisting = TRUE; 
		CertFreeCertificateContext(pListEle->pCertContext); 
		pListEle->pCertContext = CertDuplicateCertificateContext(pCertContext); 
		goto CommonReturn; 
	    }
	}

	pListElePrev = pListEle;
    }
    
    // Didn't find the cert in the list, append it.
    if (pListElePrev == NULL)
    {
	// Special case: this is the first cert we've added.  
	pListElePrev = new CertContextListEle; 
	if (pListElePrev == NULL)
	    goto MemoryErr; 
	pListEle = pListElePrev; 
	m_head = pListEle; 
    }
    else
    {
	pListElePrev->pNext = new CertContextListEle; 
	if (pListElePrev->pNext == NULL)
	    goto MemoryErr; 
	pListEle = pListElePrev->pNext; 
    }

    pListEle->pCertContext = CertDuplicateCertificateContext(pCertContext); 
    pListEle->pNext        = NULL; 

 CommonReturn: 
    return hr; 

 MemoryErr: 
    hr = E_OUTOFMEMORY; 
    goto CommonReturn;
}

HRESULT CertContextList::SyncWithStore(HCERTSTORE hStore, DWORD dwFlags)
{
    CertContextListEle * pListEle; 

    for (pListEle = m_head; pListEle != NULL; pListEle = pListEle->pNext)
    {
	if (!CertAddCertificateContextToStore
	    (hStore, 
	     pListEle->pCertContext, 
	     dwFlags, 
	     NULL))
	    return HRESULT_FROM_WIN32(GetLastError()); 
    }

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\selstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       selstore.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SELECTSTORE_TREE,          IDH_SELECTSTORE_STORE_TREE},
    {IDC_SHOWPHYSICALSTORES_CHECK,  IDH_SELECTSTORE_SHOWPHYSICAL_CHECK}
};

typedef struct _STORE_SELECT_HELPER
{
    PCCRYPTUI_SELECTSTORE_STRUCTW   pcss;
    HCERTSTORE                      hSelectedStore;
    HWND                            hwndTreeView;
    DWORD                           dwExtraOpenStoreFlag;
    HTREEITEM                       hParentItem;
    BOOL                            fCollapseMode;
    int                             CurrentSysEnumIndex;
    int                             CurrentPhysEnumIndex;
} STORE_SELECT_HELPER, *PSTORE_SELECT_HELPER;

typedef struct _OPEN_STORE_STRUCT
{
    BOOL                        fStoreHandle;
    HCERTSTORE                  hCertStore;
    DWORD                       dwFlags;
    LPCSTR                      ProviderType;
    LPWSTR                      pwszStoreName;
    PCERT_PHYSICAL_STORE_INFO   pStoreInfo;
    int                         EnumerationStructIndex;
} OPEN_STORE_STRUCT, *POPEN_STORE_STRUCT;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static POPEN_STORE_STRUCT AllocAndReturnOpenStoreStruct(
                                        BOOL                        fStoreHandle,
                                        HCERTSTORE                  hCertStore,
                                        DWORD                       dwFlags,
                                        LPCSTR                      ProviderType,
                                        LPWSTR                      pwszStoreName,
                                        PCERT_PHYSICAL_STORE_INFO   pStoreInfo,
                                        int                         EnumerationStructIndex)
{
    POPEN_STORE_STRUCT pOpenStoreStruct;

    if (NULL == (pOpenStoreStruct = (POPEN_STORE_STRUCT) malloc(sizeof(OPEN_STORE_STRUCT))))
    {
        return FALSE;
    }

    pOpenStoreStruct->fStoreHandle = fStoreHandle;

    if (fStoreHandle)
    {
        pOpenStoreStruct->hCertStore = hCertStore;
    }
    else
    {
        if (NULL == (pOpenStoreStruct->pwszStoreName = AllocAndCopyWStr(pwszStoreName)))
        {
            free(pOpenStoreStruct);
            return NULL;
        }

        pOpenStoreStruct->dwFlags = dwFlags;
        pOpenStoreStruct->ProviderType = ProviderType;
        pOpenStoreStruct->pStoreInfo = NULL;
    }

    pOpenStoreStruct->EnumerationStructIndex = EnumerationStructIndex;

    return pOpenStoreStruct;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeOpenStoreStruct(POPEN_STORE_STRUCT pOpenStoreStruct)
{
    if (!(pOpenStoreStruct->fStoreHandle))
    {
        free(pOpenStoreStruct->pwszStoreName);
    }

    free(pOpenStoreStruct);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumPhyCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PSTORE_SELECT_HELPER    pviewhelp = (PSTORE_SELECT_HELPER) pvArg;
    TVINSERTSTRUCTW         tvins;
    LPWSTR                  pwszFullStoreName;
    HCERTSTORE              hTestStore = NULL;
    DWORD                   dwAccess;
    DWORD                   cbdwAccess = sizeof(DWORD);
    LPCWSTR                 pszLocalizedName;


    //
    // if the store that is passed back cannot be opened, OR,
    // if the caller specified to display writable stores only, and
    // the current store being enumerated is read only, then that store
    // will not be displayed
    //
    if ((pStoreInfo->dwFlags & (CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG | CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)) ||
        ((pviewhelp->pcss->dwFlags & CRYPTUI_DISPLAY_WRITE_ONLY_STORES) &&
        (pStoreInfo->dwOpenFlags & CERT_STORE_READONLY_FLAG)))
    {
        return TRUE;
    }

    if (NULL == (pwszFullStoreName = (LPWSTR) malloc((wcslen((LPWSTR)pvSystemStore)+wcslen(L"\\")+wcslen(pwszStoreName)+1) * sizeof(WCHAR))))
    {
        return FALSE;
    }
    wcscpy(pwszFullStoreName, (LPWSTR)pvSystemStore);
    wcscat(pwszFullStoreName, L"\\");
    wcscat(pwszFullStoreName, pwszStoreName);

    //
    // now, if the caller passed in the CRYPTUI_VALIDATE_STORES_AS_WRITABLE flag,
    // we need to verify that the store can actually be opened with writable rights
    //
    if (pviewhelp->pcss->dwFlags & CRYPTUI_VALIDATE_STORES_AS_WRITABLE)
    {
         hTestStore = CertOpenStore(
                                    CERT_STORE_PROV_PHYSICAL,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    (dwFlags & CERT_SYSTEM_STORE_MASK)      |
                                        pviewhelp->dwExtraOpenStoreFlag     |
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG  |
                                        (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentPhysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                    pwszFullStoreName);

         if (hTestStore == NULL)
         {
            free(pwszFullStoreName);
            return TRUE;
         }

         //
         // make call to get the store property to see if it is writable
         //
         CertGetStoreProperty(hTestStore, CERT_ACCESS_STATE_PROP_ID, &dwAccess, &cbdwAccess);

         CertCloseStore(hTestStore, 0);

         //
         // if the store can't be written to, then simply return
         //
         if (!(dwAccess & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG))
         {
            return TRUE;
         }
    }

    pszLocalizedName = CryptFindLocalizedName(pwszStoreName);

    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvins.hParent = pviewhelp->hParentItem;
    tvins.hInsertAfter = TVI_LAST;
    tvins.item.pszText = (pszLocalizedName != NULL) ?   (LPWSTR) pszLocalizedName : (LPWSTR) pwszStoreName;
    tvins.item.cchTextMax = wcslen(tvins.item.pszText);
    tvins.item.iImage = 0;
    tvins.item.iSelectedImage = tvins.item.iImage;
    tvins.item.lParam = (LPARAM) AllocAndReturnOpenStoreStruct(
                                            FALSE,
                                            0,
                                            (dwFlags & CERT_SYSTEM_STORE_MASK) |
                                                (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentPhysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                            CERT_STORE_PROV_PHYSICAL,
                                            (LPWSTR) pwszFullStoreName,
                                            pStoreInfo,
                                            -1);

    SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
    free(pwszFullStoreName);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PSTORE_SELECT_HELPER    pviewhelp = (PSTORE_SELECT_HELPER) pvArg;
    TVINSERTSTRUCTW         tvins;
    HTREEITEM               hItem;
    LPCWSTR                 pszLocalizedName;
    HCERTSTORE              hTestStore = NULL;
    DWORD                   dwAccess;
    DWORD                   cbdwAccess = sizeof(DWORD);

    if ((_wcsicmp((LPWSTR)pwszSystemStore, L"acrs") == 0) ||
        (_wcsicmp((LPWSTR)pwszSystemStore, L"request") == 0))
    {
        return TRUE;
    }

    //
    // now, if the caller passed in the CRYPTUI_VALIDATE_STORES_AS_WRITABLE flag,
    // we need to verify that the store can actually be opened with writable rights
    //
    if (pviewhelp->pcss->dwFlags & CRYPTUI_VALIDATE_STORES_AS_WRITABLE)
    {
         hTestStore = CertOpenStore(
                                    CERT_STORE_PROV_SYSTEM,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    (dwFlags & CERT_SYSTEM_STORE_MASK)      |
                                        pviewhelp->dwExtraOpenStoreFlag     |
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG  |
                                        (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentSysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                    pwszSystemStore);

         if (hTestStore == NULL)
         {
            return TRUE;
         }

         //
         // make call to get the store property to see if it is writable
         //
         CertGetStoreProperty(hTestStore, CERT_ACCESS_STATE_PROP_ID, &dwAccess, &cbdwAccess);

         CertCloseStore(hTestStore, 0);

         //
         // if the store can't be written to, then simply return
         //
         if (!(dwAccess & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG))
         {
            return TRUE;
         }
    }

    pszLocalizedName = CryptFindLocalizedName((LPWSTR)pwszSystemStore);

    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvins.hParent = TVI_ROOT;
    tvins.hInsertAfter = TVI_LAST;
    tvins.item.pszText = (pszLocalizedName != NULL) ?   (LPWSTR) pszLocalizedName : (LPWSTR) pwszSystemStore;
    tvins.item.cchTextMax = wcslen(tvins.item.pszText);
    tvins.item.iImage = 0;
    tvins.item.iSelectedImage = tvins.item.iImage;
    tvins.item.lParam = (LPARAM) AllocAndReturnOpenStoreStruct(
                                            FALSE,
                                            0,
                                            dwFlags & CERT_SYSTEM_STORE_MASK |
                                                (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentSysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                            CERT_STORE_PROV_SYSTEM,
                                            (LPWSTR) pwszSystemStore,
                                            NULL,
                                            pviewhelp->CurrentSysEnumIndex);
    pviewhelp->hParentItem = (HTREEITEM) SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY SelectStoreDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PSTORE_SELECT_HELPER            pviewhelp;
    HIMAGELIST                      hIml;
    PCCRYPTUI_SELECTSTORE_STRUCTW   pcss;
    TV_ITEM                         tvi;
    TVINSERTSTRUCTW                 tvins;
    DWORD                           i;
    LPNMTREEVIEW                    pnmtv;
    HTREEITEM                       hParentItem, hChildItem;
    HWND                            hwndTreeView;
    POPEN_STORE_STRUCT              pOpenStoreStruct;
    WCHAR                           szText[CRYPTUI_MAX_STRING_SIZE];
    HWND                            hwnd;
    WCHAR                           errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                           errorTitle[CRYPTUI_MAX_STRING_SIZE];

    switch ( msg ) {

    case WM_INITDIALOG:
        pviewhelp = (PSTORE_SELECT_HELPER) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pcss = pviewhelp->pcss;

        pviewhelp->hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);
        pviewhelp->fCollapseMode = FALSE;

        //
        // set the dialog title and the display string
        //
        if (pcss->szTitle != NULL)
        {
            SetWindowTextU(hwndDlg, pcss->szTitle);
        }

        if (pcss->szDisplayString != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_SELECTSTORE_DISPLAYSTRING, pcss->szDisplayString);
        }
        else
        {
            LoadStringU(HinstDll, IDS_SELECT_STORE_DEFAULT, szText, ARRAYSIZE(szText));
            SetDlgItemTextU(hwndDlg, IDC_SELECTSTORE_DISPLAYSTRING, szText);
        }

        //
        // enable/disable the show physical stores check box
        //
        if (pcss->dwFlags & CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW)
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), SW_HIDE);
        }

        //
        //  Build up the image list for the control
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_FOLDER), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE), hIml, TVSIL_NORMAL);
        }

        //
        // add all of the stores from the enumeration to the tree view
        //
        i = 0;
        while (i < pcss->pStoresForSelection->cEnumerationStructs)
        {
            pviewhelp->CurrentSysEnumIndex = (int) i;
            if (!CertEnumSystemStore(
                        pcss->pStoresForSelection->rgEnumerationStructs[i].dwFlags,
                        pcss->pStoresForSelection->rgEnumerationStructs[i].pvSystemStoreLocationPara,
                        pviewhelp,
                        EnumSysCallback))
            {
                // ERROR
            }
            i++;
        }


        //
        // add all of the stores from the enumeration to the tree view
        //
        i = 0;
        while (i < pcss->pStoresForSelection->cStores)
        {
            tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvins.hParent = TVI_ROOT;
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = (LPWSTR) GetStoreName(pcss->pStoresForSelection->rghStores[i], TRUE);

            //
            // if we didn't get a name then just continue on to the next store
            //
            if (tvins.item.pszText == NULL)
            {
                i++;
                continue;
            }
            tvins.item.cchTextMax = wcslen(tvins.item.pszText);
            tvins.item.iImage = 0;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam =
                (LPARAM) AllocAndReturnOpenStoreStruct(TRUE, pcss->pStoresForSelection->rghStores[i], 0, NULL, NULL, NULL, -1);
            SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
            free(tvins.item.pszText);
            i++;
        }

#if (1) // DSIE: bug 317469.
        TreeView_SetItemState(pviewhelp->hwndTreeView,
                              0,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
#endif

        break;

    case WM_NOTIFY:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        pcss = pviewhelp->pcss;

        switch (((NMHDR FAR *) lParam)->code) {

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:

            pnmtv = (LPNMTREEVIEW) lParam;

            //
            // if in collapse mode the just return
            //
            if (pviewhelp->fCollapseMode)
            {
                return TRUE;
            }

            //
            // don't allow expansion if physical stores are not allowed to be viewed
            //
            if (!((pcss->dwFlags & CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW) &&
                 ((SendMessage(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), BM_GETSTATE, 0, 0) & BST_CHECKED) == BST_CHECKED)))
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            return TRUE;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        pcss = pviewhelp->pcss;

        switch (LOWORD(wParam))
        {

        case IDC_SHOWPHYSICALSTORES_CHECK:

            LRESULT checkState;

            if (HIWORD(wParam) != BN_CLICKED)
            {
                return TRUE;
            }

            hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

            memset(&tvi, 0, sizeof(tvi));
            tvi.mask = TVIF_PARAM | TVIF_HANDLE;

            checkState = SendMessage(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), BM_GETSTATE, 0, 0);
            if ((checkState & BST_CHECKED) == BST_CHECKED)
            {
                ShowWindow(hwndTreeView, SW_HIDE);
                //
                // add all the physical stores under each system store
                //
                pviewhelp->hParentItem = TreeView_GetRoot(hwndTreeView);
                while (NULL != pviewhelp->hParentItem)
                {
                    tvi.hItem = pviewhelp->hParentItem;
                    TreeView_GetItem(hwndTreeView, &tvi);
                    pOpenStoreStruct = (POPEN_STORE_STRUCT) tvi.lParam;

                    if (!(pOpenStoreStruct->fStoreHandle))
                    {
                        pviewhelp->CurrentPhysEnumIndex = (int) pOpenStoreStruct->EnumerationStructIndex;
                        CertEnumPhysicalStore(
                                (LPWSTR) pOpenStoreStruct->pwszStoreName, //pwszSystemStore,
                                pcss->pStoresForSelection->rgEnumerationStructs[pOpenStoreStruct->EnumerationStructIndex].dwFlags,
                                pviewhelp,
                                EnumPhyCallback);

                        TreeView_Expand(hwndTreeView, pviewhelp->hParentItem, TVE_EXPAND);
                        TreeView_Expand(hwndTreeView, pviewhelp->hParentItem, TVE_COLLAPSE);
                    }

                    pviewhelp->hParentItem = TreeView_GetNextItem(hwndTreeView, pviewhelp->hParentItem, TVGN_NEXT);
                }

                ShowWindow(hwndTreeView, SW_SHOW);
            }
            else
            {
                //
                // delete all of the physical stores under each system store
                //
                pviewhelp->fCollapseMode = TRUE;
                hParentItem = TreeView_GetRoot(hwndTreeView);
                while (NULL != hParentItem)
                {
                    while (NULL != (hChildItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_CHILD)))
                    {
                        tvi.hItem = hChildItem;
                        TreeView_GetItem(hwndTreeView, &tvi);

                        FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
                        TreeView_DeleteItem(hwndTreeView, hChildItem);
                    }
                    hParentItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_NEXT);
                }
                pviewhelp->fCollapseMode = FALSE;
            }
            break;

        case IDOK:
            hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

            hParentItem = TreeView_GetSelection(hwndTreeView);
            if (hParentItem != NULL)
            {
                memset(&tvi, 0, sizeof(tvi));
                tvi.mask = TVIF_PARAM | TVIF_HANDLE;
                tvi.hItem = hParentItem;
                TreeView_GetItem(hwndTreeView, &tvi);

                pOpenStoreStruct = (POPEN_STORE_STRUCT) tvi.lParam;

                if (pOpenStoreStruct->fStoreHandle)
                {
                    pviewhelp->hSelectedStore = CertDuplicateStore(pOpenStoreStruct->hCertStore);
                }
                else
                {
                    pviewhelp->hSelectedStore = CertOpenStore(
                                                    pOpenStoreStruct->ProviderType,
                                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                    NULL,
                                                    pOpenStoreStruct->dwFlags               |
                                                        pviewhelp->dwExtraOpenStoreFlag     |
                                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                                                    pOpenStoreStruct->pwszStoreName);

                    //
                    // check to make sure the store got opened correctly,
                    // if not, then notify the user
                    //
                    if (pviewhelp->hSelectedStore == NULL)
                    {
                        LoadStringU(HinstDll, IDS_UNABLE_TO_OPEN_STORE, errorString, ARRAYSIZE(errorString));
                        if (pcss->szTitle != NULL)
                        {
                            MessageBoxU(hwndDlg, errorString, pcss->szTitle, MB_OK | MB_ICONWARNING);
                        }
                        else
                        {
                            LoadStringU(HinstDll, IDS_SELECT_STORE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                            MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                        }
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                        return TRUE;
                    }
                }

                //
                // if a validation callback was passed in then do the validation
                //
                if ((pcss->pValidateStoreCallback) &&
                    ((*(pcss->pValidateStoreCallback))(pviewhelp->hSelectedStore, hwndDlg, pcss->pvCallbackData) != TRUE))
                {
                    CertCloseStore(pviewhelp->hSelectedStore, 0);

                    pviewhelp->hSelectedStore = NULL;
                    return TRUE;
                }
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_STORE_ERROR, errorString, ARRAYSIZE(errorString));
                if (pcss->szTitle != NULL)
                {
                    MessageBoxU(hwndDlg, errorString, pcss->szTitle, MB_OK | MB_ICONWARNING);
                }
                else
                {
                    LoadStringU(HinstDll, IDS_SELECT_STORE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                return TRUE;
            }

            EndDialog(hwndDlg, NULL);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }

        break;

    case WM_DESTROY:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

        //
        // free up all the store open helper structs if we are in enum mode
        //
        memset(&tvi, 0, sizeof(tvi));
        tvi.mask = TVIF_PARAM | TVIF_HANDLE;

        while (NULL != (hParentItem = TreeView_GetRoot(hwndTreeView)))
        {
            while (NULL != (hChildItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_CHILD)))
            {
                tvi.hItem = hChildItem;
                TreeView_GetItem(hwndTreeView, &tvi);

                FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
                TreeView_DeleteItem(hwndTreeView, hChildItem);
            }

            tvi.hItem = hParentItem;
            TreeView_GetItem(hwndTreeView, &tvi);

            FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
            TreeView_DeleteItem(hwndTreeView, hParentItem);
        }

        ImageList_Destroy(TreeView_GetImageList(GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE), TVSIL_NORMAL));

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDOK))                         &&
            (hwnd != GetDlgItem(hwndDlg, IDCANCEL))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE))         &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            )
{
    STORE_SELECT_HELPER viewhelper;

    if (CommonInit() == FALSE)
    {
        return NULL;
    }

    if (pcss->dwSize != sizeof(CRYPTUI_SELECTSTORE_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    viewhelper.pcss = pcss;
    viewhelper.hSelectedStore = NULL;
    viewhelper.dwExtraOpenStoreFlag = (pcss->dwFlags & CRYPTUI_RETURN_READ_ONLY_STORE) ? CERT_STORE_READONLY_FLAG : 0;

    DialogBoxParamU(
            HinstDll,
            (LPWSTR) MAKEINTRESOURCE(IDD_SELECT_STORE_DIALOG),
            (pcss->hwndParent != NULL) ? pcss->hwndParent : GetDesktopWindow(),
            SelectStoreDialogProc,
            (LPARAM) &viewhelper);

    return(viewhelper.hSelectedStore);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            )
{
    CRYPTUI_SELECTSTORE_STRUCTW cssW;
    HCERTSTORE                  hReturnStore = NULL;

    memcpy(&cssW, pcss, sizeof(cssW));

    if (pcss->szTitle)
    {
        cssW.szTitle = CertUIMkWStr(pcss->szTitle);
    }

    if (pcss->szDisplayString)
    {
        cssW.szDisplayString = CertUIMkWStr(pcss->szDisplayString);
    }

    hReturnStore = CryptUIDlgSelectStoreW(&cssW);

    if (cssW.szTitle)
    {
        free((void *) cssW.szTitle);
    }

    if (cssW.szDisplayString)
    {
        free((void *) cssW.szDisplayString);
    }

    return(hReturnStore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\signadv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signadv.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SIGNER_ADVANCED_DETAILS,   IDH_SIGNERINFO_ADVANCED_DETAIL_LIST},
    {IDC_SIGNER_ADVANCED_VALUE,     IDH_SIGNERINFO_ADVANCED_DETAIL_EDIT}
};


#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void AddSignerInfoToList(HWND hWndListView, SIGNER_VIEW_HELPER *pviewhelp)
{
    CMSG_SIGNER_INFO const *pSignerInfo;
    PCMSG_SIGNER_INFO       pCounterSignerInfo;
    DWORD                   cbCounterSignerInfo;
    PCCERT_CONTEXT          pCertContext = NULL;
    DWORD                   i;
    WCHAR                   szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW                lvI;
    int                     itemIndex = 0;
    LPWSTR                  pwszText;
    DWORD                   cbFormatedAttribute;
    BYTE                   *pbFormatedAttribute;
    char                    szVersion[32];

    pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.pszText = szFieldText;

    //
    // version
    //
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    wsprintfA(szVersion, "V%d", pSignerInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);

    if (FormatDNNameString(&pwszText, pSignerInfo->Issuer.pbData, pSignerInfo->Issuer.cbData, TRUE))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pSignerInfo->Issuer.pbData, pSignerInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pSignerInfo->SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // hash algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pSignerInfo->HashAlgorithm)))
    {
        LoadStringU(HinstDll, IDS_DIGEST_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // hash encryption algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pSignerInfo->HashEncryptionAlgorithm)))
    {
        LoadStringU(HinstDll, IDS_DIGEST_ENCRYPTION_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // Authenticated Attributes
    //
    if (pSignerInfo->AuthAttrs.cAttr > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_AUTHENTICATED_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) NULL;
        lvI.iItem = itemIndex++;
        lvI.iIndent = 0;
        ListView_InsertItemU(hWndListView, &lvI);

        lvI.iIndent = 2;

        //
        // display each unauthenticated attribute
        //
        for (i=0; i<pSignerInfo->AuthAttrs.cAttr; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = itemIndex++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM)  MakeListDisplayHelperForExtension(
                                                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                                                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        itemIndex-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }

    //
    // Unauthenticated Attributes
    //
    if (pSignerInfo->UnauthAttrs.cAttr > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_UNAUTHENTICATED_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) NULL;
        lvI.iItem = itemIndex++;
        lvI.iIndent = 0;
        ListView_InsertItemU(hWndListView, &lvI);

        lvI.iIndent = 2;

        //
        // display each unauthenticated attribute
        //
        for (i=0; i<pSignerInfo->UnauthAttrs.cAttr; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = itemIndex++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM) MakeListDisplayHelperForExtension(
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        itemIndex-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }
}


INT_PTR APIENTRY ViewPageSignerAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD                   i;
    PROPSHEETPAGE          *ps;
    SIGNER_VIEW_HELPER     *pviewhelp;
    HWND                    hWndListView;
    LV_COLUMNW              lvC;
    WCHAR                   szText[CRYPTUI_MAX_STRING_SIZE];
    CMSG_SIGNER_INFO const *pSignerInfo;
    LVITEMW                 lvI;
    LPNMLISTVIEW            pnmv;
    WCHAR                   szCompareText[CRYPTUI_MAX_STRING_SIZE];
    HWND                    hwnd;
    BOOL                    fCallSetWindowLong;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (SIGNER_VIEW_HELPER *) (ps->lParam);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_ADVANCED_VALUE, L"");

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 140;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 218;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // add all of the signer information to the list box
        //
        AddSignerInfoToList(hWndListView, pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;
            fCallSetWindowLong = FALSE;

            hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

            //
            // if this item is being de-selected, then save it's index incase we need to
            // re-select it
            if ((pnmv->uOldState & LVIS_SELECTED) || (pnmv->uOldState & LVIS_FOCUSED))
            {
                pviewhelp->previousSelection = pnmv->iItem;
            }

            //
            // if the new item selected is the "Authenticated Attributes" header, or
            // the "Unauthenticated Attributes" header then don't allow it to be
            // selected
            //
            if ((pnmv->uNewState & LVIS_SELECTED) || (pnmv->uNewState & LVIS_FOCUSED))
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = pnmv->iItem;
                lvI.mask = LVIF_TEXT;
                lvI.pszText = szText;
                lvI.cchTextMax = ARRAYSIZE(szText);
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                LoadStringU(HinstDll, IDS_AUTHENTICATED_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                if (wcscmp(szCompareText, szText) == 0)
                {
                    if (pnmv->iItem == pviewhelp->previousSelection-1)
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                    }
                    else if (pnmv->iItem == pviewhelp->previousSelection+1)
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                    }
                    else
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection;
                    }

                    ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                    fCallSetWindowLong = TRUE;
                }
                else
                {
                    LoadStringU(HinstDll, IDS_UNAUTHENTICATED_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                    if (wcscmp(szCompareText, szText) == 0)
                    {
                        if (pnmv->iItem == pviewhelp->previousSelection-1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                        }
                        else if (pnmv->iItem == pviewhelp->previousSelection+1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                        }
                        else
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection;
                        }

                        ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                        fCallSetWindowLong = TRUE;
                    }
                    else
                    {
                        pviewhelp->currentSelection = pnmv->iItem;
                    }
                }

                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                    hwndDlg,
                    IDC_SIGNER_ADVANCED_VALUE,
                    pviewhelp->currentSelection);

                if (fCallSetWindowLong)
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                }
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNER_ADVANCED_DETAILS)
            {
                break;
            }

            ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                    hwndDlg,
                    IDC_SIGNER_ADVANCED_VALUE,
                    -1);
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SIGNER_ADVANCED_DETAILS:
                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;

        }
        break;

    case WM_COMMAND:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }


        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_VALUE)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\ui\cryptui\signgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SIGNER_GENERAL_SIGNER_NAME,        IDH_SIGNERINFO_GENERAL_SIGNERNAME},
    {IDC_SIGNER_GENERAL_EMAIL,              IDH_SIGNERINFO_GENERAL_SIGNEREMAIL},
    {IDC_SIGNER_GENERAL_SIGNING_TIME,       IDH_SIGNERINFO_GENERAL_SIGNETIME},
    {IDC_SIGNER_GENERAL_VIEW_CERTIFICATE,   IDH_SIGNERINFO_GENERAL_VIEW_CERTIFICATE},
    {IDC_SIGNER_GENERAL_COUNTER_SIGS,       IDH_SIGNERINFO_GENERAL_COUNTERSIG_LIST},
    {IDC_SIGNER_GENERAL_DETAILS,            IDH_SIGNERINFO_GENERAL_COUNTERSIG_DETAILS}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCounterSignersToList(HWND hWndListView, SIGNER_VIEW_HELPER *pviewhelp)
{
    CMSG_SIGNER_INFO const *pSignerInfo;
    PCMSG_SIGNER_INFO       pCounterSignerInfo;
    DWORD                   cbCounterSignerInfo;
    PCCERT_CONTEXT          pCertContext = NULL;
    DWORD                   i;
    WCHAR                   szNameText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                   szEmailText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                lvI;
    int                     itemIndex = 0;
    LPWSTR                  pszTimeText;

    pSignerInfo = pviewhelp->pc