e location for this srid
/**/
ERR ErrNDSeekItem( FUCB *pfucb, SRID srid )
	{
	SRID UNALIGNED 	*psrid;
	INT				csrid;
	SRID UNALIGNED 	*rgsrid;
	INT				isridLeft;
	INT				isridRight;
	INT				isridT;

	#ifdef DEBUG
		{
		SSIB 			*pssib = &pfucb->ssib;
		SRID UNALIGNED 	*psrid;
		SRID UNALIGNED 	*psridMost;
		INT				csrid;
		LONG			l;

		AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( pfucb->lineData.cb >= sizeof( SRID ) );

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (SRID UNALIGNED *)PbNDData( pssib->line.pb );
		Assert( (BYTE *)psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *)psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMost = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMost; psrid++ )
			{
			l = LSridCmp( *(SRID UNALIGNED *)psrid, *(SRID UNALIGNED *)(psrid + 1) );
			Assert( l < 0 );
			}
		}
	#endif

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	/* get data
	/**/
	psrid = (SRID UNALIGNED *)pfucb->lineData.pb;
	csrid = pfucb->lineData.cb / sizeof( SRID );

	isridLeft = 0;
	isridRight = csrid - 1;
	rgsrid = psrid;

	/* binary search to locate the proper position of the given srid
	/**/
	while ( isridRight > isridLeft )
		{
		isridT = ( isridLeft + isridRight ) / 2;
		if ( BmNDOfItem( rgsrid[ isridT ] ) < srid )
			isridLeft = isridT + 1;
		else
			isridRight = isridT;
		}

	/*	check for srid greater than all srid in srid list
	/**/
	if ( BmNDOfItem( rgsrid[isridRight] ) < srid && isridRight == csrid - 1 )
		{
		PcsrCurrent( pfucb )->isrid = (SHORT)csrid;
		return ErrERRCheck( errNDGreaterThanAllItems );
		}

	PcsrCurrent( pfucb )->isrid = (SHORT)isridRight;
	Assert( PcsrCurrent( pfucb )->isrid < csrid );

	return ( BmNDOfItem( rgsrid[isridRight] ) == srid ) ?
		ErrERRCheck( wrnNDDuplicateItem ) : JET_errSuccess;
	}


INT CitemNDThere( FUCB *pfucb, BYTE fNDCitem, INT isrid )
	{
	CSR				*pcsr = PcsrCurrent( pfucb );
	SRID UNALIGNED 	*psrid;
	SRID UNALIGNED 	*psridMax;
	INT				csrid;
	INT				csridThere = 0;
	NS				ns;
	INT				isridSav = PcsrCurrent( pfucb )->isrid;

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

	psrid = (SRID UNALIGNED *)pfucb->lineData.pb;
	csrid = pfucb->lineData.cb/sizeof( SRID );

	switch( fNDCitem )
		{
		default:
			Assert( fNDCitem == fNDCitemAll );
			psridMax = psrid + csrid;
			PcsrCurrent( pfucb )->isrid = 0;
			break;
		case fNDCitemFromIsrid:
			Assert( isrid >= 0 );
			Assert( isrid < csrid );
			psridMax = psrid + csrid;
			psrid += isrid;			// Start counting from this isrid.
			PcsrCurrent( pfucb )->isrid = (SHORT)isrid;
			break;
		case fNDCitemToIsrid:
			Assert( isrid >= 0 );
			Assert( isrid < csrid );
			psridMax = psrid + isrid + 1;	// Only count until this srid.
			PcsrCurrent( pfucb )->isrid = 0;
			break;
		}
	
	for ( ; psrid < psridMax; psrid++, PcsrCurrent( pfucb )->isrid++ )
		{
		if ( FNDItemVersion( *psrid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NDICheckItemBookmark( pfucb, pcsr->bm );
			pcsr->item = BmNDOfItem( *psrid );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVerInDB ||
				( ns == nsDatabase && !FNDItemDelete( *psrid ) ) )
				csridThere++;
			}
		else
			{
			if ( !( FNDItemDelete( *psrid ) ) )
				csridThere++;
			}
		}
		
	Assert( csridThere <= csrid );

	/*	restore isrid
	/**/
	PcsrCurrent( pfucb )->isrid = (SHORT)isridSav;

	return csridThere;
	}


/*	Insert item list inserts a new item list node.  Since the item
/*	list is new, the node inserted is both the first and last
/*	item list node.  A version is created for the only item.
/**/
ERR ErrNDInsertItemList( FUCB *pfucb, KEY *pkey, SRID srid, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;
	INT		itag;
	SRID   	bm;
	LINE   	rgline[4];
	LINE   	*plineData;
	INT		cline = 0;
	INT		bHeader;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	query next itag to be used for insert
	/**/
	itag = ItagPMQueryNextItag( pssib );

	/*	set bm from node just inserted since it is the first item
	/*	list node for this item list.
	/**/
	bm = SridOfPgnoItag( pcsr->pgno, itag );

	/*	set item in CSR for version
	/**/
	pcsr->item = srid;

	/*	create version for inserted item.  Note that there is no
	/*	version for item list node.
	/**/
	if ( ( fFlags & fDIRVersion )  &&  !FDBIDVersioningOff( pfucb->dbid ) )
		{
		Call( ErrVERInsertItem( pfucb, bm ) );
		/*	set item version bit
		/**/
		ITEMSetVersion( srid );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	set node header to first last item node
	/**/
	bHeader = fNDFirstItem | fNDLastItem;
	rgline[cline].pb = (BYTE *)&bHeader;
	rgline[cline++].cb = 1;

	/*	key length
	/**/
	rgline[cline].pb = ( BYTE * ) &pkey->cb;
	rgline[cline++].cb = 1;

	/*	key information
	/**/
	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	plineData = &rgline[cline];
  	rgline[cline].pb = (BYTE *)&srid;
  	rgline[cline++].cb = sizeof(srid);

	/*	insert son for item list node in father son table
	/**/
	pssib->itag = itag;
	NDInsertSon( pfucb, pcsr );

	/* insert item list node and set CSR itag to inserted item list node
	/**/
	CallS( ErrPMInsert( pssib, rgline, cline ) );
	Assert( pssib->itag == itag );
	pcsr->itag = (SHORT)itag;
	Assert( bm == SridOfPgnoItag( pcsr->pgno, itag ) );
	pcsr->bm = bm;

	// Verify that we picked the correct insertion point.
	Assert( pssib == &pfucb->ssib );
	NDCheckPage( pssib );

	AssertNDGet( pfucb, pcsr->itag );

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGInsertItemList( pfucb, bHeader, pkey, plineData, fFlags );
		NDLGCheckPage( pfucb );
		}

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

HandleError:
	return err;
	}


ERR ErrNDInsertItem( FUCB *pfucb, ITEM item, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;
	LINE   	rgline[3];
	BYTE   	*pb;
	INT		cbCopied;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	set CSR item for version creation
	/**/
	pcsr->item = item;

	/*	create version for inserted item
	/**/
	if ( ( fFlags & fDIRVersion )  &&  !FDBIDVersioningOff( pfucb->dbid ) )
		{
		NDICheckItemBookmark( pfucb, pcsr->bm );
		Call( ErrVERInsertItem( pfucb, pcsr->bm ) );
		ITEMSetVersion( item );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGetNode( pfucb, pcsr->itag );

	/* insert the srid into position indicated by pfucb->pcsr->isrid
	/**/
	pb = PbNDData( pssib->line.pb );
	Assert( pb < pssib->line.pb + pssib->line.cb );
	Assert( pb > pssib->line.pb );
	pb += pcsr->isrid * sizeof( SRID );

	/* copy out the current node, shift the srid list,
	/*	insert it into the srid list.
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb =
		cbCopied = (INT)(pb - pssib->line.pb);

	rgline[1].pb = (BYTE *)&item;
	rgline[1].cb = sizeof(item);

	rgline[2].pb = pb;
	rgline[2].cb = pssib->line.cb - cbCopied;

	/* now update the current node
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 3 ) );

	#ifdef DEBUG
		{
		SRID UNALIGNED 	*psrid;
		SRID UNALIGNED 	*psridMax;
		INT				csrid;
		LONG 			l;

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (SRID UNALIGNED *)PbNDData( pssib->line.pb );
		Assert( (BYTE *) psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *) psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMax = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMax; psrid++ )
			{
			l = LSridCmp( * (SRID UNALIGNED *) psrid, * (SRID UNALIGNED *) (psrid + 1) );
			Assert( l < 0 );
			}
		}
	#endif

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGInsertItem( pfucb, fFlags );
		NDLGCheckPage( pfucb );
		}
	
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

HandleError:
	return err;
	}


ERR ErrNDInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	LINE  	rgline[2];

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGetNode( pfucb, pcsr->itag );

	/* copy out the current node, shift the srid list, insert it into
	/* the srid list.
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = pssib->line.cb;

	rgline[1].pb = (BYTE *)rgitem;
	rgline[1].cb = citem * sizeof(SRID);

	/* now update the current node
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 2 ) );

	#ifdef DEBUG
		{
		SRID UNALIGNED 	*psrid;
		SRID UNALIGNED 	*psridMax;
		INT				csrid;
		LONG			l;

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (SRID UNALIGNED *)PbNDData( pssib->line.pb );
		Assert( (BYTE *) psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *) psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMax = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMax; psrid++ )
			{
			l = LSridCmp( * (SRID UNALIGNED *) psrid, * (SRID UNALIGNED *) (psrid + 1) );
			Assert( l < 0 );
			}
		}
	#endif

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGInsertItems( pfucb, rgitem, citem );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return err;
	}


/*	reset delete bit on delete item to show it as inserted.
/**/
ERR ErrNDFlagInsertItem( FUCB *pfucb )
	{
	ERR		err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	SRID  	srid;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}
	
	AssertNDGetNode( pfucb, pcsr->itag );

	/*	create version for deleted item
	/**/
	Assert( pcsr->isrid >= 0 );
	pcsr->item =
		srid = BmNDOfItem( *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid ) );
	NDICheckItemBookmark( pfucb, pcsr->bm );

	//	UNDONE:	check for write conflict

	// UNDONE: Possible bug here.  NDFlagInsertItem() assumes
	// versioning is enabled.  Call me if this assert fires. -- JL
	Assert( !FDBIDVersioningOff( pfucb->dbid ) );

	Call( ErrVERFlagInsertItem( pfucb, pcsr->bm ) );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	set item version
	/**/
	ITEMSetVersion( srid );
	Assert( !FNDItemDelete( srid ) );

	/*	overwrite deleted item with delete bit reset and version bit set
	/**/
	//	UNDONE:	call page operation
	Assert( pcsr->isrid >= 0 );
	memcpy( &( (SRID UNALIGNED *)PbNDData( pssib->line.pb ) )[pcsr->isrid], &srid, sizeof(srid) );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGFlagInsertItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

HandleError:
	return err;
	}


ERR ErrNDDeleteItem( FUCB *pfucb )
	{
	ERR   	err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	INT		itag = pfucb->ssib.itag;
	LINE  	rgline[2];
	BYTE  	*pb;
	INT		cbCopied;

	/* make current node addressible
	/**/
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
	Assert( !FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );
		
	AssertNDGetNode( pfucb, pcsr->itag );

	/* delete the srid indicated by pfucb->pcsr->isrid
	/* skip key
	/**/
	pb = PbNDData( pssib->line.pb );
	Assert( pb < pssib->line.pb + pssib->line.cb );
	Assert( pb > pssib->line.pb );

	pb += pcsr->isrid * sizeof( SRID );

	/*	assert that the item is flag deleted
	/**/
#ifdef DEBUG
	{
	SRID	*psridT = (SRID *) pb;

	Assert( FNDItemDelete( * (SRID UNALIGNED *) psridT ) );
	}
#endif

	/* use the old node in page buffer, shift the srid list
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = cbCopied = (INT)(pb - pssib->line.pb);

	rgline[1].pb = pb + sizeof( SRID );
	rgline[1].cb = pssib->line.cb - cbCopied - sizeof( SRID );

	/*	replace node with item list without deleted item
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 2 ) );

	err = ErrLGDeleteItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return err;
	}


ERR ErrNDFlagDeleteItem( FUCB *pfucb, BOOL fNoMPLRegister )
	{
	ERR		err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	SRID  	srid;

	AssertFBFWriteAccessPage( pfucb, pcsr->pgno );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}
	
	AssertNDGetNode( pfucb, pcsr->itag );

	srid = *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid );

	/*	create version for deleted item
	/**/
	Assert( pcsr->isrid >= 0 );
	Assert( pcsr->item == BmNDOfItem( srid ) );
	NDICheckItemBookmark( pfucb, pcsr->bm );
	
	/*	if item is flag deleted then access item and
	/*	return JET_errRecordDeleted if not there.
	/**/
	if ( FNDItemDelete( srid ) )
		{
		NS		ns;

		ns = NsVERAccessItem( pfucb, pcsr->bm );
		err = ErrERRCheck( ns == nsDatabase ? JET_errRecordDeleted : JET_errWriteConflict );
		return err;
		}

	// UNDONE: Possible bug here.  NDFlagDeleteItem() assumes
	// versioning is enabled.  Call me if this assert fires. -- JL
	Assert( !FDBIDVersioningOff( pfucb->dbid ) );

	Call( ErrVERFlagDeleteItem( pfucb, pcsr->bm ) );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGet( pfucb, pcsr->itag );

	/*	flag node as deleted
	/**/
	srid = pcsr->item;
	ITEMSetVersion( srid );
	ITEMSetDelete( srid );

	/*	set delete bit on item
	/**/
	//	UNDONE:	use page operation
	Assert( pcsr->isrid >= 0 );
	memcpy( &( (SRID UNALIGNED *)PbNDData( pssib->line.pb ) )[pcsr->isrid],
		&srid,
		sizeof(SRID) );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGFlagDeleteItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, pcsr->pgno );

	if ( !fRecovering && !fNoMPLRegister )
		{
		Assert( pfucb->u.pfcb->pfcbTable != pfcbNil );
#ifdef OLC_DEBUG
		Assert( pfucb->sridFather != sridNull &&
				pfucb->sridFather != sridNullLink );
#endif

		MPLRegister( pfucb->u.pfcb,
			pssib,
			PnOfDbidPgno( pfucb->dbid,
			pcsr->pgno ),
			pfucb->sridFather );
		}

HandleError:
	return err;
	}


ERR ErrNDSplitItemListNode( FUCB *pfucb, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	INT		citem;
	BYTE  	rgbL[cbItemNodeMost];
	BYTE  	rgbR[cbHalfItemNodeMost];
	INT		iSplitItem;
	INT		cbLeft;
	INT		cb1;
	INT		cb2;
	INT		itagToSplit;
	LINE  	line;
	KEY		key;
	PIB		*ppib = pfucb->ppib;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	AssertNDGetNode( pfucb, pcsr->itag );

	/*	efficiency variables
	/**/
	citem = pfucb->lineData.cb / sizeof( SRID );
	Assert( citem > 1 );
	iSplitItem = ( fFlags & fDIRAppendItem ) ? citem - 1 : citem / 2;

	/* no logging for this particular function
	/**/

	/*	no versioning is need for item list node.
	/**/
	itagToSplit = pcsr->itag;
	NDGet( pfucb, itagToSplit );

	/*	create left son with iSplitItem srids
	/**/
	cbLeft = 1 + 1 + CbNDKey( pssib->line.pb );
	cbLeft += ( FNDBackLink( *pssib->line.pb ) ? sizeof( SRID ) : 0 );
	cbLeft += iSplitItem * sizeof( SRID );
	memcpy( rgbL, pssib->line.pb, cbLeft );
	Assert( !FNDDeleted( *rgbL ) );
	Assert( !FNDVersion( *rgbL ) );
	Assert( !FNDSon( *rgbL ) );
	Assert( cbLeft <= cbItemNodeMost );

	/*	create right son, by first copying header and key.  Then
	/*	copy those srids that will be in right son.  Remember to
	/*	reset back link bit in right son header.
	/**/
	cb1 = 1 + 1 + CbNDKey( pssib->line.pb );
	memcpy( rgbR, rgbL, cb1 );
	NDResetBackLink( *rgbR );
	cb2 = ( citem - iSplitItem ) * sizeof( SRID );
	memcpy( rgbR + cb1,
		PbNDData( pssib->line.pb ) + ( iSplitItem * sizeof( SRID ) ),
		cb2 );
	Assert( !FNDVersion( *rgbR ) );
	Assert( !FNDDeleted( *rgbR ) );
	Assert( !FNDSon( *rgbR ) );
	Assert( !FNDBackLink( *rgbR ) );
	Assert( cb1 + cb2 <= cbHalfItemNodeMost );

	/* maintain the fLastItemListNode/fFirstItemListNode
	/**/
	NDResetLastItem( rgbL[0] );
	NDResetFirstItem( rgbR[0] );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/* update the old son, this should cause no split
	/**/
	line.pb = rgbL;
	line.cb = cbLeft;
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, &line, 1 ) );

	/*	insert right item list
	/**/
	pcsr->ibSon++;

	key.pb = PbNDKey( rgbR );
	key.cb = CbNDKey( rgbR );
	line.pb = PbNDData( rgbR );
	line.cb = cb2;
	CallS( ErrNDInsertNode( pfucb, &key, &line, *rgbR, fDIRNoLog ) );
	AssertNDGet( pfucb, pcsr->itag );

#ifdef DEBUG
	Assert( !FNDFirstItem( *pfucb->ssib.line.pb ) );
#endif

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* log the item node split, no versioning
		/**/
		err = ErrLGSplitItemListNode(
				pfucb,
				citem,
				pcsr->itagFather,
				pcsr->ibSon - 1, 	/* it was incremented in this function */
				itagToSplit,
				fFlags );
		NDLGCheckPage( pfucb );
		}

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	return err;
	}


/* called by bm to expunge back link, only redo it. No undo it.
/**/
ERR ErrNDExpungeBackLink( FUCB *pfucb )
	{
	ERR		err;
	SSIB 	*pssib = &pfucb->ssib;
	LINE 	rgline[3];
	INT		cline;
	BYTE 	*pbNode;
	INT		cbNode;
	BYTE 	*pbData;
	BYTE 	*pbBackLink;
	BYTE 	bFlag;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	efficiency variables
	/**/
	cline = 0;
	pbNode = pssib->line.pb;
	cbNode = pssib->line.cb;
	pbData = PbNDData( pssib->line.pb );
	pbBackLink = PbNDBackLink( pssib->line.pb );
	bFlag = *pbNode;

	NDResetBackLink( bFlag );

	/* node header
	/**/
	rgline[cline].pb = &bFlag;
	rgline[cline++].cb = sizeof( bFlag );

	/* copy up to back link, including key and son table
	/**/
	rgline[cline].pb = pbNode + sizeof( bFlag );
	rgline[cline++].cb = (ULONG)(pbBackLink - pbNode -sizeof( bFlag ));

	/* skip back link, continue copying data
	/**/
	rgline[cline].pb = pbData;
	rgline[cline++].cb = cbNode - (ULONG)( pbData - pbNode );

	pssib->itag = PcsrCurrent( pfucb )->itag;

	err = ErrPMReplace( pssib, rgline, cline );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	
	return err;
	}


/*	called by bookmark clean up to remove back link from node,
/*	free tag redirector, and to log operation for redo only.
/**/
ERR ErrNDExpungeLinkCommit( FUCB *pfucb, FUCB *pfucbSrc )
	{
	ERR		err;
	SSIB  	*pssib = &pfucb->ssib;
	SSIB  	*pssibSrc = &pfucbSrc->ssib;
	SRID  	sridSrc;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertFBFWriteAccessPage( pfucbSrc, PcsrCurrent( pfucbSrc )->pgno );

	if (  FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	/*	remove back link from node
	/**/
	CallR( ErrNDExpungeBackLink( pfucb ) )

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( pssibSrc );

	/*	remove redirector
	/**/
	pssibSrc->itag = PcsrCurrent( pfucbSrc )->itag;
	PMExpungeLink( pssibSrc );

	/* reset time tamp while page latched.
	/* The statement must before LGExpungeLinkCommit so that
	/* it stays in critJet and rgfmp[dbid].ulDBTime will not be changed.
	/**/
//	PMSetUlDBTime( pssib, rgfmp[pfucb->dbid].ulDBTime );
//	PMSetUlDBTime( pssibSrc, rgfmp[pfucb->dbid].ulDBTime );

	/* if log fail return to caller, system should crash by the caller
	/**/
	sridSrc	= SridOfPgnoItag( PcsrCurrent(pfucbSrc)->pgno, PcsrCurrent(pfucbSrc)->itag );
	err = ErrLGExpungeLinkCommit( pfucb, pssibSrc, sridSrc );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	return err;
	}


/* used by OLC to remove page pointer that points to an empty page
/* that is about to be retrieved
/**/
ERR ErrNDDeleteInvisibleSon(
	FUCB  	*pfucb,
	RMPAGE	*prmpage,
	BOOL  	fCheckRemoveParentOnly,
	BOOL  	*pfRmParent )
	{
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fFatherFOP = ( prmpage->itagFather == itagFOP );
	LONG	cbSibling;

	AssertFBFWriteAccessPage( pfucb, prmpage->pgnoFather );

	/*	initialize pfRmParent
	/**/
	*pfRmParent = fFalse;

	/*	set currency to page pointer, to fool NDDeleteSon
	/**/
	PcsrCurrent( pfucb )->pgno = prmpage->pgnoFather;
	PcsrCurrent( pfucb )->itag = (SHORT)prmpage->itagPgptr;
	PcsrCurrent( pfucb )->itagFather = (SHORT)prmpage->itagFather;
	PcsrCurrent( pfucb )->ibSon = (SHORT)prmpage->ibSon;

	/*	get page pointer node
	/**/
	NDGet( pfucb, prmpage->itagFather );
	Assert( !FNDNullSon( *pssib->line.pb ) );
	cbSibling = CbNDSon( pssib->line.pb ) - 1;
	Assert( cbSibling >= 0 );

	if ( fCheckRemoveParentOnly )
		{
		*pfRmParent = ( cbSibling == 0 &&
			fFatherFOP &&
			FPMLastNode( pssib ) );

		if ( !( *pfRmParent ) )
			{
			if ( prmpage->ibSon == cbSibling && cbSibling != 0	)
				{
				// Either it's an intrinsic page pointer (ie. itag == itagNil )
				// or it's the largest key.
				Assert( PcsrCurrent( pfucb )->itag == itagNil  ||
					FNDMaxKeyInPage( pfucb ) );
				return errBMMaxKeyInPage;
				}
			Assert( PcsrCurrent( pfucb )->itag == itagNil  ||
					!FNDMaxKeyInPage( pfucb ) );	// Since ibSon != cbSibling
			}
		}
	else
		{
		/*	write latch page from dirty until log completion
		/**/
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		/*	dirty page buffer
		/**/
		PMDirty( pssib );

		NDDeleteSon( pfucb );

		/*	delete page pointer [if it is not intrinsic son of nonFOP].
		/*	Currency is maintained by the caller
		/**/
		if ( cbSibling == 0 && !fFatherFOP )
			{
			/* intrinsic page pointer
			/**/
			Assert( prmpage->itagPgptr == itagNil );
			}
		else
			{
			pssib->itag = prmpage->itagPgptr;
			PMDelete( pssib );
			}

		/*	set *pfRmParent
		/**/
		*pfRmParent = ( cbSibling == 0 &&
			fFatherFOP &&
			FPMEmptyPage( pssib ) );
				
		/*	if only one remaining son then convert to intrinsic
		/*	page pointer node.
		/**/
		if ( cbSibling == 1 && !fFatherFOP )
			{
			/*	make other sibling intrinsic page pointer node
			/**/
			Assert( prmpage->itagFather != itagFOP );
			PcsrCurrent( pfucb )->itag = (SHORT)prmpage->itagFather;
			NDMakeSonIntrinsic( pfucb );
			}

		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		}

	return JET_errSuccess;
	}


/*	delete node is called by bookmark clean up to delete *visible* nodes
/*	that have been flagged as deleted.  This operation is logged
/*	for redo only.
/**/
ERR ErrNDDeleteNode( FUCB *pfucb )
	{
	ERR 	err;
	CSR 	*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	NDDeleteSon( pfucb );

	/*	delete the son node
	/**/
	pssib->itag = pcsr->itag;
#ifdef DEBUG
	NDGet( pfucb, pcsr->itag );
	Assert( fRecovering || FNDDeleted( *pssib->line.pb ) );
#endif
	PMDelete( pssib );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGDelete( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	return err;
	}


ERR ErrNDReplaceWithLink( FUCB *pfucb, SRID sridLink )
	{
	ERR 	err = JET_errSuccess;
	CSR 	*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	PMReplaceWithLink( pssib, sridLink );

	NDDeleteSon( pfucb );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	return err;
	}


VOID NDResetItemVersion( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

 	/*	dirty page buffer. but no increment ulDBTime since not logged and
	/*	not affect directory cursor timestamp check.
	/**/
	ITEMResetVersion( *( (SRID UNALIGNED *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	}


VOID NDSetItemDelete( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );

	ITEMSetDelete( *( (SRID UNALIGNED *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	return;
	}


VOID NDResetItemDelete( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );

	ITEMResetDelete( *( (SRID UNALIGNED *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	return;
	}


ERR ErrNDInsertWithBackLink(
	FUCB		*pfucb,
	BYTE 		bFlags,
	KEY 		const *pkey,
	LINE	 	*plineSonTable,
	SRID	 	sridBackLink,
	LINE 		*plineData )
	{
	ERR		err;
	SSIB   	*pssib = &pfucb->ssib;
	LINE   	rgline[6];
	INT		cline = 0;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	Assert( PgnoOfSrid( sridBackLink ) != pgnoNull );
	Assert( ItagOfSrid( sridBackLink ) != 0 );

	/* set node header
	/**/
	NDSetBackLink( bFlags );
	rgline[cline].pb = &bFlags;

	/* set key length
	/**/
	rgline[cline++].cb = 1;
	rgline[cline].pb = ( BYTE * ) &pkey->cb;
	rgline[cline++].cb = 1;

	/* set key
	/**/
	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	Assert( !FLineNull( plineSonTable ) || FNDNullSon( bFlags ) );

	/* set son table
	/**/
	if ( !FLineNull( plineSonTable ) )
		{
		Assert( FNDSon( bFlags ) );
		rgline[cline].pb = plineSonTable->pb;
		rgline[cline++].cb = plineSonTable->cb;
		}

	/* set back link */
	rgline[cline].pb = ( BYTE * )&sridBackLink;
	rgline[cline++].cb = sizeof( sridBackLink );

	/* set data
	/**/
	if ( !FLineNull( plineData ) )
		{
		rgline[cline++] = *plineData;
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	err = ErrPMInsert( pssib, rgline, cline );
	PcsrCurrent( pfucb )->itag = (SHORT)pssib->itag;

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return err;
	}


VOID NDGetBackLink( FUCB *pfucb, PGNO *ppgno, INT *pitag )
	{
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( FNDBackLink( *pfucb->ssib.line.pb ) );

	*ppgno = PgnoOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pfucb->ssib.line.pb ) );
	*pitag = ItagOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pfucb->ssib.line.pb ) );
	}


/* given a itag, find its corresponding itagFather and ibSon
 */
VOID NDGetItagFatherIbSon(
	INT *pitagFather,
	INT *pibSon,
	PAGE *ppage,
	INT itag )
	{
	INT itagFather;
	INT ibSon;
	
	/* current node is not FOP - scan all lines to find its father */
	Assert( itag != itagFOP );
	
	for ( itagFather = 0; ; itagFather++ )
		{
		TAG tag;
		BYTE *pbNode;
		BYTE *pbSonTable;
		INT cbSonTable;
		BYTE *pitagSon;
		
		Assert( itagFather < ppage->ctagMac );
		
		if ( TsPMTagstatus( ppage, itagFather ) != tsLine )
			continue;

		tag = ppage->rgtag[ itagFather ];
		Assert( tag.cb != 0 );
		pbNode = (BYTE *)ppage + tag.ib;
		
		if ( FNDNullSon( *pbNode )  ||
			( itagFather != 0  &&  FNDIntrinsicSons( pbNode ) ) )
			continue;

//		if ( FNDDeleted(*pbNode) )
//			continue;
		
		/* scan son table looking for current node	*/
		/* ptr to son table */
		pbSonTable = PbNDSonTable( pbNode );
		cbSonTable = CbNDSonTable( pbSonTable );
		pitagSon = pbSonTable + 1;
		for ( ibSon = 0; ibSon < cbSonTable; ibSon++, pitagSon++ )
			if ( *pitagSon == itag )
				{
				*pitagFather = itagFather;
				*pibSon = ibSon;
				return;
				}
		}
		
	*pitagFather = itagNil;
	*pibSon = ibSonNull;
	}


#ifdef DEBUG
// Verifies key integrity of in-page tree rooted at itagFather.  For subtrees in
// the page, this function will recursively call itself.
VOID NDCheckTreeInPage( PAGE *ppage, INT itagFather )
	{
	TAG		*rgbtag;
	BYTE  	*pbNode;
	BYTE  	*pitagStart;
	BYTE  	*pitagMax;
	BYTE  	*pitagCurr;
	KEY		keyPrev;
	BOOL	fVisibleSons;

	AssertCriticalSection( critJet );

	Assert( itagFather >= itagFOP );
	Assert( itagFather <= ItagPMMost( ppage ) );

	/*	initialize variables
	/**/
	rgbtag = (TAG *)ppage->rgtag;
	pbNode = (BYTE *)ppage + rgbtag[itagFather].ib;
	pitagStart = PbNDSon( pbNode );
	pitagMax = pitagStart + CbNDSon( pbNode );
	Assert( pitagMax >= pitagStart );
	Assert( !FNDReserved( *pbNode ) );	// Verify unusable bit is not being used.

	fVisibleSons = FNDVisibleSons( *pbNode );
	if ( !fVisibleSons )
		{
		/*	invisible sons may have last page pointer key NULL (since it is
		/*	never compared), so we have to compensate.
		/**/
		pitagMax--;
		}

	if ( pitagMax > pitagStart )		// Only do the check if there are sons.
		{
		pbNode = (BYTE *)ppage + rgbtag[*pitagStart].ib;
		Assert( !FNDReserved( *pbNode ) );	// Verify unusable bit is not being used.
		if ( fVisibleSons  &&  !FNDNullSon( *pbNode ) )
			{
			// If this is the father of a subtree, check the subtree as well.
			NDCheckTreeInPage( ppage, *pitagStart );
			}

		// Ensure key length doesn't exceed node length.
		Assert( CbNDKey( pbNode ) < (ULONG)rgbtag[*pitagStart].cb );

		keyPrev.pb = PbNDKey( pbNode );
		keyPrev.cb = CbNDKey( pbNode );

		/*	validate key order
		/**/
		for ( pitagCurr = pitagStart + 1; pitagCurr < pitagMax; pitagCurr++ )
			{
			pbNode = (BYTE *)ppage + rgbtag[*pitagCurr].ib;
			Assert( !FNDReserved( *pbNode ) );	// Verify unusable bit is not being used.
			if ( fVisibleSons  &&  !FNDNullSon( *pbNode ) )
				{
				// If this is the father of a subtree, check the subtree as well.
				NDCheckTreeInPage( ppage, *pitagCurr );
				}

			// Ensure key length doesn't exceed node length.
			Assert( CbNDKey( pbNode ) < (ULONG)rgbtag[*pitagCurr].cb );

			// Ensure current key is greater than or equal to previous key.
			Assert( CmpStKey( StNDKey( pbNode ), &keyPrev ) >= 0 );

			keyPrev.pb = PbNDKey( pbNode );
			keyPrev.cb = CbNDKey( pbNode );
			}
		}

	return;
	}
#endif	// DEBUG


// UNDONE: This is currently very inefficient, because we ALWAYS update
// cbUncommittedFreed.  To make it more efficient, we should rewrite all
// callers of this function to call FNDFreePageSpace(), since
// that function only updates cbUncommittedFreed if necessary.
INT CbNDFreePageSpace( BF *pbf )
 	{
	PAGE 	*ppage;
	INT		cbFree;

	SgEnterCriticalSection( critPage );

	ppage = pbf->ppage;

	// The amount of space freed but possibly uncommitted should be a subset of
	// the total amount of free space for this page.
	Assert( ppage->cbUncommittedFreed >= 0 );
	Assert( ppage->cbFree >= ppage->cbUncommittedFreed );

	cbFree = ppage->cbFree;

	// If there's any possible uncommitted freed space outstanding, check the
	// version store to see if that space is indeed still uncommitted.
	if ( ppage->cbUncommittedFreed > 0 )
		{
		ppage->cbUncommittedFreed = (SHORT)CbVERUncommittedFreed( pbf );

		// The amount of space freed but possibly uncommitted should be a subset of
		// the total amount of free space for this page.
		Assert( ppage->cbUncommittedFreed >= 0 );
		Assert( ppage->cbFree >= ppage->cbUncommittedFreed );

		cbFree -= ppage->cbUncommittedFreed;
		Assert( cbFree >= 0 );
		}

	SgLeaveCriticalSection( critPage );

	return cbFree;
	}


// Determines if the current node is the last logical node in the page.
BOOL FNDMaxKeyInPage( FUCB *pfucb )
	{
	BYTE	*pbNode;
	INT		itag = PcsrCurrent( pfucb )->itag;
	INT		itagFather;
	INT		ibSon;
	INT		ibSonLast;

	/*	assert line currency.
	/**/
	Assert( itag != itagNil );
	Assert( itag != itagFOP );
	Assert( itag > 0 );
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	// CONSIDER:  Obtain itagFather from csr instead, or pass it in as a parameter.
	NDGetItagFatherIbSon(
		&itagFather,
		&ibSon,
		pfucb->ssib.pbf->ppage,
		itag );
	Assert( itagFather != itagNil  &&  ibSon != ibSonNull );
	Assert( PbNDSon( (BYTE*)pfucb->ssib.pbf->ppage +
		pfucb->ssib.pbf->ppage->rgtag[itagFather].ib )[ ibSon ] == itag );

	NDGet( pfucb, itagFather );
	NDCheckPage( &pfucb->ssib );

	pbNode = pfucb->ssib.line.pb;
	Assert( PbNDSon( pbNode )[ ibSon ] == itag );

	Assert( !FNDNullSon( *pbNode ) );	// Father must have at least one son.

	ibSonLast = CbNDSon( pbNode ) - 1;
	Assert( ibSonLast >= 0 );

	NDGet( pfucb, itag );

	return ( ibSon == ibSonLast );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\perfdata.c ===
/*  Machine generated data file "perfdata.c" from "edbperf.dat"  */


#include "std.h"

#include "version.h"

#include <stddef.h>

#include "winperf.h"

#include "edbperf.h"

#define SIZEOF_INST_NAME DWORD_MULTIPLE(32)

#pragma pack(4)

char szPERFVersion[] = szVerName " Performance  " __DATE__ "  " __TIME__;


typedef struct _PERF_DATA_TEMPLATE {
	PERF_OBJECT_TYPE potEDB;
	PERF_COUNTER_DEFINITION pcdOpenTableCacheHits;
	PERF_COUNTER_DEFINITION pcdOpenTableCacheRequests;
	PERF_COUNTER_DEFINITION pcdLGBytesWrittenPerSec;
	PERF_COUNTER_DEFINITION pcdLGUsersWaiting;
	PERF_COUNTER_DEFINITION pcdLGCheckpointDepth;
	PERF_COUNTER_DEFINITION pcdBFSyncReadsPerSec;
	PERF_COUNTER_DEFINITION pcdBFAsyncReadsPerSec;
	PERF_COUNTER_DEFINITION pcdBFBytesReadPerSec;
	PERF_COUNTER_DEFINITION pcdBFSyncWritesPerSec;
	PERF_COUNTER_DEFINITION pcdBFAsyncWritesPerSec;
	PERF_COUNTER_DEFINITION pcdBFBytesWrittenPerSec;
	PERF_COUNTER_DEFINITION pcdBFIOQueueLength;
	PERF_COUNTER_DEFINITION pcdBFCacheHits;
	PERF_COUNTER_DEFINITION pcdBFCacheRequests;
	PERF_COUNTER_DEFINITION pcdBFPctClean;
	PERF_COUNTER_DEFINITION pcdBFTotalBuffers2;
	PERF_COUNTER_DEFINITION pcdBFPctAvail;
	PERF_COUNTER_DEFINITION pcdBFTotalBuffers3;
	PERF_INSTANCE_DEFINITION pidEDB0;
	wchar_t wszEDBInstName0[SIZEOF_INST_NAME];
	DWORD EndStruct;
} PERF_DATA_TEMPLATE;

PERF_DATA_TEMPLATE PerfDataTemplate = {
	{  //  PERF_OBJECT_TYPE potEDB;
		offsetof(PERF_DATA_TEMPLATE,EndStruct)-offsetof(PERF_DATA_TEMPLATE,potEDB),
		offsetof(PERF_DATA_TEMPLATE,pidEDB0)-offsetof(PERF_DATA_TEMPLATE,potEDB),
		offsetof(PERF_DATA_TEMPLATE,pcdOpenTableCacheHits)-offsetof(PERF_DATA_TEMPLATE,potEDB),
		0,
		0,
		0,
		0,
		0,
		18,
		0,
		0,
		0,
		0,
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdOpenTableCacheHits;
		offsetof(PERF_DATA_TEMPLATE,pcdOpenTableCacheRequests)-offsetof(PERF_DATA_TEMPLATE,pcdOpenTableCacheHits),
		2,
		0,
		2,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_SAMPLE_FRACTION,
		CntrSize(PERF_SAMPLE_FRACTION,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdOpenTableCacheRequests;
		offsetof(PERF_DATA_TEMPLATE,pcdLGBytesWrittenPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdOpenTableCacheRequests),
		4,
		0,
		4,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_SAMPLE_BASE,
		CntrSize(PERF_SAMPLE_BASE,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdLGBytesWrittenPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdLGUsersWaiting)-offsetof(PERF_DATA_TEMPLATE,pcdLGBytesWrittenPerSec),
		6,
		0,
		6,
		0,
		-5,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdLGUsersWaiting;
		offsetof(PERF_DATA_TEMPLATE,pcdLGCheckpointDepth)-offsetof(PERF_DATA_TEMPLATE,pcdLGUsersWaiting),
		8,
		0,
		8,
		0,
		1,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_RAWCOUNT,
		CntrSize(PERF_COUNTER_RAWCOUNT,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdLGCheckpointDepth;
		offsetof(PERF_DATA_TEMPLATE,pcdBFSyncReadsPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdLGCheckpointDepth),
		10,
		0,
		10,
		0,
		-5,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_RAWCOUNT,
		CntrSize(PERF_COUNTER_RAWCOUNT,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFSyncReadsPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFAsyncReadsPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdBFSyncReadsPerSec),
		12,
		0,
		12,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFAsyncReadsPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFBytesReadPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdBFAsyncReadsPerSec),
		14,
		0,
		14,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFBytesReadPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFSyncWritesPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdBFBytesReadPerSec),
		16,
		0,
		16,
		0,
		-5,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFSyncWritesPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFAsyncWritesPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdBFSyncWritesPerSec),
		18,
		0,
		18,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFAsyncWritesPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFBytesWrittenPerSec)-offsetof(PERF_DATA_TEMPLATE,pcdBFAsyncWritesPerSec),
		20,
		0,
		20,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFBytesWrittenPerSec;
		offsetof(PERF_DATA_TEMPLATE,pcdBFIOQueueLength)-offsetof(PERF_DATA_TEMPLATE,pcdBFBytesWrittenPerSec),
		22,
		0,
		22,
		0,
		-5,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_COUNTER,
		CntrSize(PERF_COUNTER_COUNTER,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFIOQueueLength;
		offsetof(PERF_DATA_TEMPLATE,pcdBFCacheHits)-offsetof(PERF_DATA_TEMPLATE,pcdBFIOQueueLength),
		24,
		0,
		24,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_COUNTER_RAWCOUNT,
		CntrSize(PERF_COUNTER_RAWCOUNT,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFCacheHits;
		offsetof(PERF_DATA_TEMPLATE,pcdBFCacheRequests)-offsetof(PERF_DATA_TEMPLATE,pcdBFCacheHits),
		26,
		0,
		26,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_SAMPLE_FRACTION,
		CntrSize(PERF_SAMPLE_FRACTION,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFCacheRequests;
		offsetof(PERF_DATA_TEMPLATE,pcdBFPctClean)-offsetof(PERF_DATA_TEMPLATE,pcdBFCacheRequests),
		28,
		0,
		28,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_SAMPLE_BASE,
		CntrSize(PERF_SAMPLE_BASE,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFPctClean;
		offsetof(PERF_DATA_TEMPLATE,pcdBFTotalBuffers2)-offsetof(PERF_DATA_TEMPLATE,pcdBFPctClean),
		30,
		0,
		30,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_RAW_FRACTION,
		CntrSize(PERF_RAW_FRACTION,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFTotalBuffers2;
		offsetof(PERF_DATA_TEMPLATE,pcdBFPctAvail)-offsetof(PERF_DATA_TEMPLATE,pcdBFTotalBuffers2),
		32,
		0,
		32,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_RAW_BASE,
		CntrSize(PERF_RAW_BASE,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFPctAvail;
		offsetof(PERF_DATA_TEMPLATE,pcdBFTotalBuffers3)-offsetof(PERF_DATA_TEMPLATE,pcdBFPctAvail),
		34,
		0,
		34,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_RAW_FRACTION,
		CntrSize(PERF_RAW_FRACTION,0),
		0,
	},
	{  //  PERF_COUNTER_DEFINITION pcdBFTotalBuffers3;
		offsetof(PERF_DATA_TEMPLATE,pidEDB0)-offsetof(PERF_DATA_TEMPLATE,pcdBFTotalBuffers3),
		36,
		0,
		36,
		0,
		0,
		PERF_DETAIL_DEFAULT,
		PERF_RAW_BASE,
		CntrSize(PERF_RAW_BASE,0),
		0,
	},
	{  //  PERF_INSTANCE_DEFINITION pidEDB0;
		offsetof(PERF_DATA_TEMPLATE,EndStruct)-offsetof(PERF_DATA_TEMPLATE,pidEDB0),
		0,
		0,
		0,
		offsetof(PERF_DATA_TEMPLATE,wszEDBInstName0)-offsetof(PERF_DATA_TEMPLATE,pidEDB0),
		0,
	},
	L"",  //  wchar_t wszEDBInstName0[];
	0,  //  DWORD EndStruct;
};

void * const pvPERFDataTemplate = (void *)&PerfDataTemplate;


const DWORD dwPERFNumObjects = 1;

long rglPERFNumInstances[1];
wchar_t *rgwszPERFInstanceList[1];

const DWORD dwPERFNumCounters = 18;

const DWORD dwPERFMaxIndex = 36;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\lv.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */

//#define XACT_REQUIRED

ERR ErrRECSetColumn( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );

LOCAL ERR ErrRECISetLid( FUCB *pfucb, FID fid, ULONG itagSequence, LID lid );

//+api
//	ErrRECSetLongField
//	========================================================================
//	ErrRECSetLongField
//
//	Description.
//
//	PARAMETERS	pfucb
//	 			fid
//	 			itagSequence
//	 			plineField
//	 			grbit
//
//	RETURNS		Error code, one of:
//	 			JET_errSuccess
//
//-
ERR ErrRECSetLongField(
	FUCB 			*pfucb,
	FID 			fid,
	ULONG			itagSequence,
	LINE			*plineField,
	JET_GRBIT		grbit,
	LONG			ibLongValue,
	ULONG			ulMax )
	{
	ERR				err = JET_errSuccess;
	LINE			line;
	ULONG	  		cb;
	BYTE			fSLong;
	LID				lid;
	BOOL			fTransactionStarted = fFalse;
	
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( cbChunkMost == JET_cbColumnLVChunkMost );

	grbit &= ( JET_bitSetAppendLV |
		JET_bitSetOverwriteLV |
		JET_bitSetSizeLV |
		JET_bitSetZeroLength |
		JET_bitSetSeparateLV |
		JET_bitSetNoVersion );

#if 0
	/*	UNDONE: disable the tight checking for now. Rewrite the assert
	 *	UNDONE: after 406 where compressed log is checked in.
	 */
	{
	JET_GRBIT	grbitT = grbit&~JET_bitSetNoVersion;
	Assert( grbitT == 0 ||
		grbitT == JET_bitSetAppendLV ||
		grbitT == JET_bitSetOverwriteLV ||
		grbitT == JET_bitSetOverwriteLV ||
		grbitT == JET_bitSetSizeLV ||
		grbitT == JET_bitSetZeroLength ||
		grbitT == ( JET_bitSetSizeLV | JET_bitSetZeroLength ) ||
		grbitT == ( JET_bitSetOverwriteLV | JET_bitSetSizeLV ) ||
		( grbitT & JET_bitSetSeparateLV ) );
	}
#endif

	/*	sequence == 0 means that new field instance is to be set.
	/**/
	if ( itagSequence == 0 )
		{
		line.cb = 0;
		}
	else
		{
		Call( ErrRECIRetrieveColumn( (FDB *)pfucb->u.pfcb->pfdb,
			&pfucb->lineWorkBuf,
			&fid,
			pNil,
			itagSequence,
			&line,
			0 ) );
		}

//	UNDONE:	find better solution to the problem of visible
//			long value changes before update at level 0.

	/*	if grbit is new field or set size to 0
	/*	then we're setting NULL field.
	/**/
	if ( ( ( grbit &
		(JET_bitSetAppendLV|JET_bitSetOverwriteLV|JET_bitSetSizeLV) )
		 == 0 ) ||
		( ( grbit & JET_bitSetSizeLV ) && plineField->cb == 0 ) )
		{
		
	 	/*	if new length is zero and setting to NULL (ie. not zero length), set
		/* column to NULL and return.
		/**/
		if ( plineField->cb == 0 && ( grbit & JET_bitSetZeroLength ) == 0 )
			{
			return ErrRECSetColumn( pfucb, fid, itagSequence, NULL );
			}

		line.cb = 0;
	 	line.pb = NULL;
		}
	
	/*	if intrinsic long field exists, if combined size exceeds
	/*	intrinsic long field maximum, separate long field and call
	/*	ErrRECSetSeparateLV
	/*	else call ErrRECSetIntrinsicLV
	/**/

	/*	set size requirement for existing long field
	/*	note that if fSLong is true then cb is length
	/*	of LV
	/**/
	if ( line.cb == 0 )
		{
		fSLong = fFalse;
		cb = offsetof(LV, rgb);
		}
	else
		{
		Assert( line.cb > 0 );
		fSLong = FFieldIsSLong( line.pb );
		cb = line.cb;
		}

	/*	long field flag included in length thereby limiting
	/*	intrinsic long field to cbLVIntrinsicMost - sizeof(BYTE)
	/**/
	if ( fSLong )
		{
		Assert( line.cb == sizeof(LV) );
		Assert( ((LV *)line.pb)->fSeparated );

#ifdef XACT_REQUIRED
	if ( pfucb->ppib->level == 0 )
		return ErrERRCheck( JET_errNotInTransaction );
#endif

		CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
		fTransactionStarted = fTrue;
		
		/*	flag cursor as having updated a separate LV
		/**/
		FUCBSetUpdateSeparateLV( pfucb );

		lid = LidOfLV( line.pb );
		Call( ErrRECAOSeparateLV( pfucb, &lid, plineField, grbit, ibLongValue, ulMax ) );
		if ( err == JET_wrnCopyLongValue )
			{
			Call( ErrRECISetLid( pfucb, fid, itagSequence, lid ) );
			}

		Call( ErrDIRCommitTransaction( pfucb->ppib, 0 ) );
		}


	else
		{
		BOOL fInitSeparate = fFalse;

		if ( ( !( grbit & JET_bitSetOverwriteLV ) && ( cb + plineField->cb > cbLVIntrinsicMost ) )  ||
			( ( grbit & JET_bitSetOverwriteLV ) && ( offsetof(LV, rgb) + ibLongValue + plineField->cb > cbLVIntrinsicMost ) )  ||
//	UNDONE:	remove JET_bitSetSeparateLV when record log compression implemented
			( grbit & JET_bitSetSeparateLV ) )
			{
			fInitSeparate = fTrue;
			}

		else
			{
			err = ErrRECAOIntrinsicLV( pfucb, fid, itagSequence, &line, plineField, grbit, ibLongValue );

			if ( err == JET_errRecordTooBig )
				{
				fInitSeparate = fTrue;
				}
			else
				{
				Call( err );
				}
			}

		if ( fInitSeparate )
			{
			CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
			fTransactionStarted = fTrue;

			if ( line.cb > 0 )
				{
				Assert( !( FFieldIsSLong( line.pb ) ) );
				line.pb += offsetof(LV, rgb);
				line.cb -= offsetof(LV, rgb);
				}
		
			/*	flag cursor as having updated a separate LV
			/**/
			FUCBSetUpdateSeparateLV( pfucb );

			Call( ErrRECSeparateLV( pfucb, &line, &lid, NULL ) );
			Assert( err == JET_wrnCopyLongValue );
			Call( ErrRECAOSeparateLV( pfucb, &lid, plineField, grbit, ibLongValue, ulMax ) );
			Call( ErrRECISetLid( pfucb, fid, itagSequence, lid ) );
			Assert( err != JET_wrnCopyLongValue );

			Call( ErrDIRCommitTransaction( pfucb->ppib, 0 ) );
			}
		}

HandleError:
	/*	if operation failed then rollback changes
	/**/
	if ( err < 0 && fTransactionStarted )
		{
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	return err;
	}


LOCAL INLINE ERR ErrRECISetLid( FUCB *pfucb, FID fid, ULONG itagSequence, LID lid )
	{
	ERR		err;
	LV		lv;
	LINE	line;

	/*	set field to separated long field id
	/**/
	lv.fSeparated = fSeparate;
	lv.lid = lid;
	line.pb = (BYTE *)&lv;
	line.cb = sizeof(LV);
	err = ErrRECSetColumn( pfucb, fid, itagSequence, &line );
	return err;
	}


LOCAL ERR ErrRECIBurstSeparateLV( FUCB *pfucbTable, FUCB *pfucbSrc, LID *plid )
	{
	ERR		err;
	FUCB   	*pfucb = pfucbNil;
	KEY		key;
	BYTE   	rgbKey[sizeof(ULONG)];
	DIB		dib;
	LID		lid;
	LONG   	lOffset;
	LVROOT	lvroot;
	BF		*pbf = pbfNil;
	BYTE	*rgb;
	LINE   	line;

	Call( ErrBFAllocTempBuffer( &pbf ) );
	rgb = (BYTE *)pbf->ppage;

	/*	initialize key buffer
	/**/
	key.pb = rgbKey;
	dib.fFlags = fDIRNull;

	/*	get long value length
	/**/
	Call( ErrDIRGet( pfucbSrc ) );
	Assert( pfucbSrc->lineData.cb == sizeof(lvroot) );
	memcpy( &lvroot, pfucbSrc->lineData.pb, sizeof(lvroot) );

	/*	move source cursor to first chunk
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posFirst;
	Call( ErrDIRDown( pfucbSrc, &dib ) );
	Assert( err == JET_errSuccess );

	/*	make separate long value root, and insert first chunk
	/**/
	Call( ErrDIRGet( pfucbSrc ) );

	/*	remember length of first chunk.
	/**/
	lOffset = pfucbSrc->lineData.cb;

	line.pb = rgb;
	line.cb = pfucbSrc->lineData.cb;
	memcpy( line.pb, pfucbSrc->lineData.pb, line.cb );
	Call( ErrRECSeparateLV( pfucbTable, &line, &lid, &pfucb ) );

	/*	check for additional long value chunks
	/**/
	err = ErrDIRNext( pfucbSrc, &dib );
	if ( err >= 0 )
		{
		/*	initial key variable
		/**/
		key.pb = rgbKey;
		key.cb = sizeof(ULONG);

		/*	copy remaining chunks of long value.
		/**/
		do
			{
			Call( ErrDIRGet( pfucbSrc ) );
			line.pb = rgb;
			line.cb = pfucbSrc->lineData.cb;
			Assert( lOffset + line.cb <= lvroot.ulSize );
			memcpy( line.pb, pfucbSrc->lineData.pb, line.cb );
			KeyFromLong( rgbKey, lOffset );
			/*	keys should be equivalent
			/**/
			Assert( rgbKey[0] == pfucbSrc->keyNode.pb[0] );
			Assert( rgbKey[1] == pfucbSrc->keyNode.pb[1] );
			Assert( rgbKey[2] == pfucbSrc->keyNode.pb[2] );
			Assert( rgbKey[3] == pfucbSrc->keyNode.pb[3] );
			err = ErrDIRInsert( pfucb, &line, &key, fDIRVersion | fDIRBackToFather );
			lOffset += (LONG)pfucbSrc->lineData.cb;
			Assert( err != JET_errKeyDuplicate );
			Call( err );
			err = ErrDIRNext( pfucbSrc, &dib );
			}
		while ( err >= 0 );
		}
		
	if ( err != JET_errNoCurrentRecord )
		goto HandleError;

	Assert( err == JET_errNoCurrentRecord );
	Assert( lOffset == (long)lvroot.ulSize );
					
	/*	move cursor to new long value
	/**/
	DIRUp( pfucbSrc, 2 );
	key.pb = (BYTE *)&lid;
	key.cb = sizeof(LID);
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	dib.pkey = &key;
	Call( ErrDIRDown( pfucbSrc, &dib ) );
	Assert( err == JET_errSuccess );

	/*	update lvroot.ulSize to correct long value size.
	/**/
	line.cb = sizeof(LVROOT);
	line.pb = (BYTE *)&lvroot;
	Assert( lvroot.ulReference >= 1 );
	lvroot.ulReference = 1;
	Call( ErrDIRGet( pfucbSrc ) );
	Assert( pfucbSrc->lineData.cb == sizeof(lvroot) );
	Call( ErrDIRReplace( pfucbSrc, &line, fDIRVersion ) );
	Call( ErrDIRGet( pfucbSrc ) );

	/*	set warning and new long value id for return.
	/**/
	err = ErrERRCheck( JET_wrnCopyLongValue );
	*plid = lid;
HandleError:
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	if ( pbf != pbfNil )
		BFSFree( pbf );
	return err;
	}

						
//+api
//	ErrRECAOSeparateLV
//	========================================================================
//	ErrRECAOSeparateLV
//
//	Appends, overwrites and sets length of separate long value data.
//
//	PARAMETERS		pfucb
// 					pline
// 					plineField	
//
//	RETURNS		Error code, one of:
//					JET_errSuccess
//
//	SEE ALSO		
//-
ERR ErrRECAOSeparateLV( FUCB *pfucb, LID *plid, LINE *plineField, JET_GRBIT grbit, LONG ibLongValue, ULONG ulMax )
	{
	ERR			err = JET_errSuccess;
	ERR			wrn = JET_errSuccess;
	FUCB	   	*pfucbT;
	DIB			dib;
	KEY			key;
	BYTE	   	rgbKey[sizeof(ULONG)];
	BYTE	   	*pbMax;
	BYTE	   	*pb;
	LINE	   	line;
	LONG	   	lOffset;
	LONG	   	lOffsetChunk;
	ULONG	   	ulSize;
	ULONG	   	ulNewSize;
	BF		   	*pbf = pbfNil;
	LVROOT		lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );
	Assert( ( grbit & JET_bitSetSizeLV ) ||
		plineField->cb == 0 ||
		plineField->pb != NULL );

	dib.fFlags = fDIRNull;
	
	/*	open cursor on LONG directory
	/*	seek to this field instance
	/*	find current field size
	/*	add new field segment in chunks no larger than max chunk size
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	move to long field instance
	/**/
	key.pb = (BYTE *)plid;
	key.cb = sizeof(LID);
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	switch( err )
		{
		case JET_errRecordNotFound:
		case wrnNDFoundGreater:
		case wrnNDFoundLess:
			// The only time we should get here is if another thread has removed the
			// LV tree, but the removal of the LID from the record has not yet been
			// committed.  Another thread could get into this window (via a SetColumn
			// at trx level 0) and obtain the LID, but not be able to find the LV in
			// the tree.
			// Hence, we polymorph these errors/warnings to WriteConflict.
			err = ErrERRCheck( JET_errWriteConflict );
		default:
			Call( err );
		}
	Assert( err == JET_errSuccess );

	/*	burst long value if other references.
	/*	NOTE: MUST ENSURE that no I/O occurs between this operation
	/*	and the operation to write lock the node if the
	/*	reference count is 1.
	/**/
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
	memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
	Assert( lvroot.ulReference > 0 );

	/*	get offset of last byte from long value size
	/**/
	ulSize = lvroot.ulSize;

	if ( ibLongValue < 0 ||
		( ( grbit & JET_bitSetOverwriteLV ) && (ULONG)ibLongValue > ulSize ) )
		{
		err = ErrERRCheck( JET_errColumnNoChunk );
		goto HandleError;
		}
	
	if ( lvroot.ulReference > 1 || FDIRDelta( pfucbT, BmOfPfucb( pfucbT ) ) )
		{
		Call( ErrRECIBurstSeparateLV( pfucb, pfucbT, plid ) );
		Assert( err == JET_wrnCopyLongValue );
		wrn = err;
		Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
		memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
		}

	Assert( ulSize == lvroot.ulSize );
	Assert( lvroot.ulReference == 1 );

	/*	determine new long field size
	/**/
	/*	determine new long field size
	/**/
	if ( (grbit & (JET_bitSetSizeLV|JET_bitSetOverwriteLV) ) == 0 )
		{
		/*	append existing or new long value
		/**/
		ulNewSize = ulSize + plineField->cb;
		}
	else
		{
		/*	overwrite, resize or both
		/**/
		if ( !( grbit & JET_bitSetSizeLV ) )
			{
			ulNewSize = max( (ULONG)ibLongValue + plineField->cb, ulSize );
			}
		else if ( !( grbit & JET_bitSetOverwriteLV ) )
			{
			ulNewSize = (ULONG)plineField->cb;
			}
		else
			{
			Assert( (grbit & (JET_bitSetSizeLV|JET_bitSetOverwriteLV)) ==
				(JET_bitSetSizeLV|JET_bitSetOverwriteLV) );
			ulNewSize = (ULONG)plineField->cb + (ULONG)ibLongValue;
			}
		}

	/*	check for field too long
	/**/
	if ( ulMax > 0 && ulNewSize > ulMax )
		{
		err = ErrERRCheck( JET_errColumnTooBig );
		goto HandleError;
		}

	/*	replace long value size with new size
	/**/
	Assert( lvroot.ulReference > 0 );
	if ( lvroot.ulSize != ulNewSize )
		{
		lvroot.ulSize = ulNewSize;
		line.cb = sizeof(LVROOT);
		line.pb = (BYTE *)&lvroot;
		Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );
		}

	/*	allocate buffer for partial overwrite caching.
	/**/
	Call( ErrBFAllocTempBuffer( &pbf ) );

	/*	SET SIZE
	/**/
	/*	if truncating long value then delete chunks.  If truncation
	/*	lands in chunk, then save retained information for subsequent
	/*	append.
	/*
	/*	If replacing long value, then set new size.
	/**/
	if ( ( grbit & JET_bitSetSizeLV ) )
		{

		/*	TRUNCATE long value
		/**/
		if ( ulNewSize < ulSize )
			{
			/*	seek to offset to begin deleting
			/**/
			lOffset = (LONG)plineField->cb;
			KeyFromLong( rgbKey, lOffset );
			key.pb = rgbKey;
			key.cb = sizeof(LONG);
			Assert( dib.fFlags == fDIRNull );
			Assert( dib.pos == posDown );
			dib.pkey = &key;
			err = ErrDIRDown( pfucbT, &dib );
			Assert( err != JET_errRecordNotFound );
			Call( err );
			Assert( err == JET_errSuccess ||
				err == wrnNDFoundLess ||
				err == wrnNDFoundGreater );
			if ( err != JET_errSuccess )
				Call( ErrDIRPrev( pfucbT, &dib ) );
			Call( ErrDIRGet( pfucbT ) );
			
			/*	get offset of last byte in current chunk
			/**/
			LongFromKey( &lOffsetChunk, pfucbT->keyNode.pb );

			/*	replace current chunk with remaining data, or delete if
			/*	no remaining data.
			/**/
			Assert( lOffset >= lOffsetChunk );
			line.cb = lOffset - lOffsetChunk;
			if ( line.cb > 0 )
				{
				line.pb = (BYTE *)pbf->ppage;
				memcpy( line.pb, pfucbT->lineData.pb, line.cb );
				Call( ErrDIRReplace( pfucbT, &line, fDIRVersion | fDIRLogChunkDiffs ) );
				}
			else
				{
				Call( ErrDIRDelete( pfucbT, fDIRVersion ) );
				}

			/*	delete forward chunks
			/**/
			forever
				{
				err = ErrDIRNext( pfucbT, &dib );
				if ( err < 0 )
					{
					if ( err == JET_errNoCurrentRecord )
						break;
					goto HandleError;
					}
				Call( ErrDIRDelete( pfucbT, fDIRVersion ) );
				}

			/*	move to long value root for subsequent append
			/**/
			DIRUp( pfucbT, 1 );
			}

		else if ( ulNewSize > ulSize  &&
			!( grbit & JET_bitSetOverwriteLV ) )
			{
			/*	EXTEND long value with chunks of 0s, but only if we're not
			/* overwriting as well (overwrite is handled in the Overwrite/Append
			/* code below).
			/**/
			memset( (BYTE *)pbf->ppage, '\0', cbChunkMost );

			/*	try to extend last chunk.
			/**/
			Assert( dib.fFlags == fDIRNull );
			dib.pos = posLast;

			/*	long value chunk tree may be empty
			/**/
			err = ErrDIRDown( pfucbT, &dib );
			if ( err < 0 && err != JET_errRecordNotFound )
				goto HandleError;
			if ( err != JET_errRecordNotFound )
				{
				Call( ErrDIRGet( pfucbT ) );

				if ( pfucbT->lineData.cb < cbChunkMost )
					{
					line.cb = min( (LONG)plineField->cb - ulSize,
								(ULONG)cbChunkMost - (ULONG)pfucbT->lineData.cb );
					memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, pfucbT->lineData.cb );
					memset( (BYTE *)pbf->ppage +  pfucbT->lineData.cb, '\0', line.cb );
		
					ulSize += line.cb;

					line.cb += pfucbT->lineData.cb;
					line.pb = (BYTE *)pbf->ppage;
					Call( ErrDIRReplace( pfucbT, &line, fDIRVersion | fDIRLogChunkDiffs ) );
					}

				DIRUp( pfucbT, 1 );
				}

			/*	extend long value with chunks of 0s
			/**/
			memset( (BYTE *)pbf->ppage, '\0', cbChunkMost );

			/*	set lOffset to offset of next chunk
			/**/
			lOffset = (LONG)ulSize;

			/*	insert chunks to append lOffset - plineField + 1 bytes.
			/**/
			while( (LONG)plineField->cb > lOffset )
				{
				KeyFromLong( rgbKey, lOffset );
				key.pb = rgbKey;
				key.cb = sizeof(ULONG);
				line.cb = min( (LONG)plineField->cb - lOffset, cbChunkMost );
				(BYTE const *)line.pb = (BYTE *)pbf->ppage;
				err = ErrDIRInsert( pfucbT, &line, &key, fDIRVersion | fDIRBackToFather );
				Assert( err != JET_errKeyDuplicate );
				Call( err );

				lOffset += line.cb;
				}
			}

/*
		// This clause not needed (automatically filtered out by the if..else if
		// above).
		// The cases we ignore are when the new size to set is already equivalent
		// to the current size, or when the new size is greater than the current
		// size and we are also doing an overwrite.  In the latter case, the LV
		// growth is handled in the Overwrite/Append code below.
		else
			{
			Assert( ulNewSize == ulSize  ||
				( ulNewSize > ulSize  &&  ( grbit & JET_bitSetOverwriteLV ) ) );
			}
*/

		if ( ( grbit & JET_bitSetOverwriteLV ) == 0 )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		}

	/*	OVERWRITE, APPEND
	/**/

	/*	prepare for overwrite and append
	/**/
	pbMax = plineField->pb + plineField->cb;
	pb = plineField->pb;
	
	/*	if overwriting byte range or replacing long value,
	/*	then overwrite bytes.
	/**/
	if ( ( grbit & JET_bitSetOverwriteLV ) && ( (ULONG)ibLongValue < ulSize ) )
		{
		/*	seek to offset to begin overwritting
		/**/
		KeyFromLong( rgbKey, ibLongValue );
		key.pb = rgbKey;
		key.cb = sizeof(LONG);
		Assert( dib.fFlags == fDIRNull );
		dib.pos = posDown;
		dib.pkey = &key;
		err = ErrDIRDown( pfucbT, &dib );
		Assert( err != JET_errRecordNotFound );
		Call( err );
		Assert( err == JET_errSuccess ||
			err == wrnNDFoundLess ||
			err == wrnNDFoundGreater );
		if ( err != JET_errSuccess )
			Call( ErrDIRPrev( pfucbT, &dib ) );
		Call( ErrDIRGet( pfucbT ) );

		LongFromKey( &lOffsetChunk, pfucbT->keyNode.pb );
		Assert( ibLongValue <= lOffsetChunk + (LONG)pfucbT->lineData.cb );

		/*	overwrite portions of and complete chunks to effect overwrite
		/**/
		while( err != JET_errNoCurrentRecord && pb < pbMax )
			{
			LONG	cbChunk;
			LONG	ibChunk;
			LONG	cb;
			LONG	ib;

			Call( ErrDIRGet( pfucbT ) );

			/*	get size and offset of current chunk.
			/**/
			cbChunk = (LONG)pfucbT->lineData.cb;
			LongFromKey( &ibChunk, pfucbT->keyNode.pb );
	
			Assert( ibLongValue >= ibChunk && ibLongValue < ibChunk + cbChunk );
			ib = ibLongValue - ibChunk;
			cb = min( cbChunk - ib, (LONG)(pbMax - pb) );

			/*	special case overwrite of whole chunk
			/**/
			if ( cb == cbChunk )
				{
				line.cb = cb;
				line.pb = pb;
				Call( ErrDIRReplace( pfucbT, &line, ( ( grbit & JET_bitSetNoVersion ) ? fDIRNoVersion : fDIRVersion ) | fDIRLogChunkDiffs ) );
				}
			else
				{
				/*	copy chunk into copy buffer.  Overwrite and replace
				/*	node with copy buffer.
				/**/
				memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, cbChunk );
				memcpy( (BYTE *)pbf->ppage + ib, pb, cb );
				line.cb = cbChunk;
				line.pb = (BYTE *)pbf->ppage;
				Call( ErrDIRReplace( pfucbT, &line, fDIRVersion | fDIRLogChunkDiffs ) );
				}

			pb += cb;
			ibLongValue += cb;
			err = ErrDIRNext( pfucbT, &dib );
			if ( err < 0 && err != JET_errNoCurrentRecord )
				goto HandleError;
			}

		/*	move to long value root for subsequent append
		/**/
		DIRUp( pfucbT, 1 );
		}

	/*	coallesce new long value data with existing.
	/**/
	if ( pb < pbMax )
		{
		Assert( dib.fFlags == fDIRNull );
		dib.pos = posLast;
		/*	long value chunk tree may be empty.
		/**/
		err = ErrDIRDown( pfucbT, &dib );
		if ( err < 0 && err != JET_errRecordNotFound )
			goto HandleError;
		if ( err != JET_errRecordNotFound )
			{
			Call( ErrDIRGet( pfucbT ) );

			if ( pfucbT->lineData.cb < cbChunkMost )
				{
				line.cb = (ULONG)min( (ULONG_PTR)pbMax - (ULONG_PTR)pb, (ULONG_PTR)cbChunkMost - (ULONG_PTR)pfucbT->lineData.cb );
				memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, pfucbT->lineData.cb );
				memcpy( (BYTE *)pbf->ppage + pfucbT->lineData.cb, pb, line.cb );
			
				pb += line.cb;
				ulSize += line.cb;

				line.cb += pfucbT->lineData.cb;
				line.pb = (BYTE *)pbf->ppage;
				Call( ErrDIRReplace( pfucbT, &line, fDIRVersion | fDIRLogChunkDiffs ) );
				}

			DIRUp( pfucbT, 1 );
			}

		/*	append remaining long value data
		/**/
		while( pb < pbMax )
			{
			KeyFromLong( rgbKey, ulSize );
			key.pb = rgbKey;
			key.cb = sizeof( ULONG );
			line.cb = min( (ULONG)(pbMax - pb), cbChunkMost );
			(BYTE const *)line.pb = pb;
	 		err = ErrDIRInsert( pfucbT, &line, &key, fDIRVersion | fDIRBackToFather );
	 		Assert( err != JET_errKeyDuplicate );
			Call( err );
	
			ulSize += line.cb;
			pb += line.cb;
			}
		}

	/*	err may be negative from called routine.
	/**/
	err = JET_errSuccess;

HandleError:
	if ( pbf != pbfNil )
		{
		BFSFree( pbf );
		}
	/* discard temporary FUCB
	/**/
	DIRClose( pfucbT );

	/*	return warning if no failure
	/**/
	err = err < 0 ? err : wrn;
	return err;
	}


//+api
//	ErrRECAOIntrinsicLV
//	========================================================================
//	ErrRECAOIntrinsicLV(
//
//	Description.
//
//	PARAMETERS	pfucb	
//				fid
//				itagSequence
//				plineColumn
//				plineAOS
//				ibLongValue			if 0, then flags append.  If > 0
//									then overwrite at offset given.
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//
//-
ERR ErrRECAOIntrinsicLV(
	FUCB		*pfucb,
	FID	  		fid,
	ULONG		itagSequence,
	LINE		*plineColumn,
	LINE		*plineAOS,
	JET_GRBIT	grbit,
	LONG		ibLongValue )
	{
	ERR	 		err = JET_errSuccess;
	BYTE 		*rgb;
	LINE 		line;
	BYTE 		fFlag;
	LINE 		lineColumn;

	Assert( pfucb != pfucbNil );
	Assert( plineColumn );
	Assert( plineAOS );

	/*	allocate working buffer
	/**/
	rgb = SAlloc( cbLVIntrinsicMost );
	if ( rgb == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	/*	if field NULL, prepend fFlag
	/**/
	if ( plineColumn->cb == 0 )
		{
		fFlag = fIntrinsic;
		lineColumn.pb = (BYTE *)&fFlag,
		lineColumn.cb = sizeof(fFlag);
		}
	else
		{
		lineColumn.pb = plineColumn->pb;
		lineColumn.cb = plineColumn->cb;
		}

	/*	append new data to previous data and intrinsic long field flag
	/**/
	Assert( ( !( grbit & JET_bitSetOverwriteLV ) && lineColumn.cb + plineAOS->cb <= cbLVIntrinsicMost ) ||
		( ( grbit & JET_bitSetOverwriteLV ) && ibLongValue + plineAOS->cb <= cbLVIntrinsicMost ) );
	Assert( lineColumn.cb > 0 && lineColumn.pb != NULL );
	
	line.pb = rgb;

	/*	effect overwrite, set size or append
	/**/
	if ( grbit & JET_bitSetOverwriteLV )
		{
		/*	copy intrinsic long value into buffer, and set line to default
		/**/	
		memcpy( rgb, lineColumn.pb, lineColumn.cb );

		/*	adjust offset to be relative to LV structure data start
		/**/
		ibLongValue += offsetof(LV, rgb);
		/*	return error if overwriting byte not present in, or adjacent to,
		/*	field.
		/**/
		if ( ibLongValue > (LONG)lineColumn.cb )
			{
			err = ErrERRCheck( JET_errColumnNoChunk );
			goto HandleError;
			}
		Assert( ibLongValue + plineAOS->cb <= cbLVIntrinsicMost );
		Assert( plineAOS->cb == 0 || plineAOS->pb != NULL );
		memcpy( rgb + ibLongValue, plineAOS->pb, plineAOS->cb );
		if ( grbit & JET_bitSetSizeLV )
			{
			line.cb = ibLongValue + plineAOS->cb;
			}
		else
			{
			line.cb = max( lineColumn.cb, ibLongValue + plineAOS->cb );
			}
		}
	else if ( grbit & JET_bitSetSizeLV )
		{
		/*	overwrite truncate handled in ovewrite case
		/**/
		Assert( ( grbit & JET_bitSetOverwriteLV ) == 0 );

		/*	copy intrinsic long value into buffer, and set line to default
		/**/	
		memcpy( rgb, lineColumn.pb, lineColumn.cb );

		/*	if extending then set 0 in extended area
		/*	else truncate long value.
		/**/
		memcpy( rgb, lineColumn.pb, lineColumn.cb );
		plineAOS->cb += offsetof(LV, rgb);
		if ( plineAOS->cb > lineColumn.cb )
			{
	  		memset( rgb + lineColumn.cb, '\0', plineAOS->cb - lineColumn.cb );
			}
		line.cb = plineAOS->cb;
		}
	else
		{
		/*	copy intrinsic long value into buffer, and set line to default
		/**/	
		memcpy( rgb, lineColumn.pb, lineColumn.cb );

		/*	appending to a field or resetting a field and setting new data.
		/*	Be sure to handle case where long value is being NULLed.
		/**/
		memcpy( rgb + lineColumn.cb, plineAOS->pb, plineAOS->cb );
		line.cb = lineColumn.cb + plineAOS->cb;
		}

	Call( ErrRECSetColumn( pfucb, fid, itagSequence, &line ) );

HandleError:
	SFree( rgb );
	return err;
	}


//+api
//	ErrRECRetrieveSLongField
//	========================================================================
//	ErrRECRetrieveSLongField(
//
//	Description.
//
//	PARAMETERS	pfucb
//				pline
//				ibGraphic
//				plineField
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//
//-
ERR ErrRECRetrieveSLongField(
	FUCB	*pfucb,
	LID		lid,
	ULONG	ibGraphic,
	BYTE	*pb,
	ULONG	cbMax,
	ULONG	*pcbActual )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbT = pfucbNil;
	BOOL	fBeginTransaction;
	DIB		dib;
	BYTE	*pbMax;
	KEY		key;
	BYTE	rgbKey[sizeof(ULONG)];
	ULONG	cb;
	ULONG	ulRetrieved;
	ULONG	ulActual;
	ULONG	lOffset;
	ULONG	ib;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	/*	begin transaction for read consistency
	/**/
	if ( pfucb->ppib->level == 0 )
		{
		CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
		fBeginTransaction = fTrue;
		}
	else
		{
		fBeginTransaction = fFalse;
		}

	dib.fFlags = fDIRNull;

	/*	open cursor on LONG, seek to long field instance
	/*	seek to ibGraphic
	/*	copy data from long field instance segments as
	/*	necessary
	/**/
	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	//	PREREAD
	//	if our table is open in sequential mode open the long value table in sequential mode as well
	//	compact opens all its tables in sequential mode
	if ( FFUCBSequential( pfucb ) )
		{
		FUCBSetSequential( pfucbT );
		}

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	move to long field instance
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	key.pb = (BYTE *)&lid;
	key.cb = sizeof( ULONG );
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	switch( err )
		{
		case JET_errRecordNotFound:
		case wrnNDFoundGreater:
		case wrnNDFoundLess:
			// The only time we should get here is if another thread has removed the
			// LV tree, but the removal of the LID from the record has not yet been
			// committed.  Another thread could get into this window (via a SetColumn
			// at trx level 0) and obtain the LID, but not be able to find the LV in
			// the tree.
			// Hence, we polymorph these errors/warnings to WriteConflict.
			err = ErrERRCheck( JET_errWriteConflict );
		default:
			Call( err );
		}
	Assert( err == JET_errSuccess );

	/*	get cbActual
	/**/
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
	ulActual = ( (LVROOT *)pfucbT->lineData.pb )->ulSize;

	/*	set return value cbActual
	/**/
	if ( ibGraphic >= ulActual )
		{
		*pcbActual = 0;
		err = JET_errSuccess;
		goto HandleError;
		}
	else
		{
		*pcbActual = ulActual - ibGraphic;
		}

	/*	move to ibGraphic in long field
	/**/
	KeyFromLong( rgbKey, ibGraphic );
	key.pb = rgbKey;
	key.cb = sizeof( ULONG );
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	/*	if long value has no data, then return JET_errSuccess
	/*	with no data retrieved.
	/**/
	if ( err == JET_errRecordNotFound )
		{
		*pcbActual = 0;
		err = JET_errSuccess;
		goto HandleError;
		}
	Assert( err != JET_errRecordNotFound );
	Call( err );
	Assert( err == JET_errSuccess ||
		err == wrnNDFoundLess ||
		err == wrnNDFoundGreater );
	if ( err != JET_errSuccess )
		Call( ErrDIRPrev( pfucbT, &dib ) );
	Call( ErrDIRGet( pfucbT ) );

	LongFromKey( &lOffset, pfucbT->keyNode.pb );
	Assert( lOffset + pfucbT->lineData.cb - ibGraphic <= cbChunkMost );
	cb =  min( lOffset + pfucbT->lineData.cb - ibGraphic, cbMax );

	/*	set pbMax
	/**/
	pbMax = pb + cbMax;

	/*	offset in chunk
	/**/
	ib = ibGraphic - lOffset;
	memcpy( pb, pfucbT->lineData.pb + ib, cb );
	pb += cb;
	ulRetrieved = cb;

	while ( pb < pbMax )
		{
		err = ErrDIRNext( pfucbT, &dib );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				break;
			goto HandleError;
			}
		Call( ErrDIRGet( pfucbT ) );
  		cb = pfucbT->lineData.cb;
		if ( pb + cb > pbMax )
			{
			Assert( pbMax - pb <= cbChunkMost );
			cb = (ULONG)(pbMax - pb);
			}
	
		memcpy( pb, pfucbT->lineData.pb, cb );
		pb += cb;
		ulRetrieved = cb;
		}

	/*	set return value
	/**/
	err = JET_errSuccess;

HandleError:
	/*	discard temporary FUCB
	/**/
	if ( pfucbT != pfucbNil )
		{
		DIRClose( pfucbT );
		}

	/*	commit no updates must succeed
	/**/
	if ( fBeginTransaction )
		{
		CallS( ErrDIRCommitTransaction( pfucb->ppib, 0 ) );
		}
	return err;
	}


//+api	
//	ErrRECSeparateLV
//	========================================================================
//	ErrRECSeparateLV
//
//	Converts intrinsic long field into separated long field.
//	Intrinsic long field constraint of length less than cbLVIntrinsicMost bytes
//	means that breakup is unnecessary.  Long field may also be
//	null.
//
//	PARAMETERS	pfucb
//				fid
//				itagSequence
//				plineField
//				pul
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//-
ERR ErrRECSeparateLV( FUCB *pfucb, LINE *plineField, LID *plid, FUCB **ppfucb )
	{
	ERR		err = JET_errSuccess;
	FUCB 	*pfucbT;
	ULONG 	ulLongId;
	BYTE  	rgbKey[sizeof(ULONG)];
	KEY		key;
	LINE  	line;
	LVROOT	lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );

	/*	add long field node in long field directory
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );
	Assert( pfucb->u.pfcb == pfucbT->u.pfcb );
	
	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	SgEnterCriticalSection( pfucbT->u.pfcb->critLV );

	// Lid's are numbered starting at 1.  An lidMax of 0 indicates that we must
	// first retrieve the lidMax.  In the pathological case where there are
	// currently no lid's, we'll go through here anyway, but only the first
	// time (since there will be lid's after that).
	if ( pfucbT->u.pfcb->ulLongIdMax == 0 )
		{
		DIB		dib;
		BYTE	*pb;

		dib.fFlags = fDIRNull;
		dib.pos = posLast;
		err = ErrDIRDown( pfucbT, &dib );
		Assert( err != JET_errNoCurrentRecord );
		switch( err )
			{
			case JET_errSuccess:
				pb = pfucbT->keyNode.pb;
				ulLongId = ( pb[0] << 24 ) + ( pb[1] << 16 ) + ( pb[2] << 8 ) + pb[3];
				Assert( ulLongId > 0 );		// lid's start numbering at 1.
				DIRUp( pfucbT, 1 );			// Back to LONG.
				break;

			case JET_errRecordNotFound:
				ulLongId = 0;
				break;

			default:
				DIRClose( pfucbT );
				return err;
			}

		// While retrieving the lidMax, someone else may have been doing the same
		// thing and beaten us to it.  When this happens, cede to the other guy.
		// UNDONE:  This logic relies on critJet.  When we move to sg crit. sect.,
		// we should rewrite this.
		if ( pfucbT->u.pfcb->ulLongIdMax != 0 )
			{
			ulLongId = ++pfucbT->u.pfcb->ulLongIdMax;
			}
		else
			{
			// ulLongId contains the last set lid.  Increment by 1 (for our insertion),
			// then update lidMax.
			pfucbT->u.pfcb->ulLongIdMax = ++ulLongId;
			}
		}
	else
		ulLongId = ++pfucbT->u.pfcb->ulLongIdMax;

	Assert( ulLongId > 0 );
	Assert( ulLongId == pfucbT->u.pfcb->ulLongIdMax );


	SgLeaveCriticalSection( pfucbT->u.pfcb->critLV );

	/*	convert long column id to long column key.  Set return
	/*	long id since buffer will be overwritten.
	/**/
	KeyFromLong( rgbKey, ulLongId );
	*plid = *((LID *)rgbKey);

	/*	add long field id with long value size
	/**/
	lvroot.ulReference = 1;
	lvroot.ulSize = plineField->cb;
	line.pb = (BYTE *)&lvroot;
	line.cb = sizeof(LVROOT);
	key.pb = (BYTE *)rgbKey;
	key.cb = sizeof(LID);
	err = ErrDIRInsert( pfucbT, &line, &key, fDIRVersion );
	Assert( err != JET_errKeyDuplicate );
	Call( err );

	/*	if lineField is non NULL, add lineField
	/**/
	if ( plineField->cb > 0 )
		{
		Assert( plineField->pb != NULL );
		KeyFromLong( rgbKey, 0 );
		Assert( key.pb == (BYTE *)rgbKey );
		Assert( key.cb == sizeof(LID) );
		err = ErrDIRInsert( pfucbT, plineField, &key, fDIRVersion | fDIRBackToFather );
		Assert( err != JET_errKeyDuplicate );
		Call( err );
		}

	err = ErrERRCheck( JET_wrnCopyLongValue );

HandleError:
	/* discard temporary FUCB, or return to caller if ppfucb is not NULL.
	/**/
	if ( err < 0 || ppfucb == NULL )
		{
		DIRClose( pfucbT );
		}
	else
		{
		*ppfucb = pfucbT;
		}
	return err;
	}


//+api
//	ErrRECAffectSeparateLV
//	========================================================================
//	ErrRECAffectSeparateLV( FUCB *pfucb, ULONG *plid, ULONG fLV )
//
//	Affect long value.
//
//	PARAMETERS		pfucb			Cursor
//		  			lid				Long field id
//		  			fLVAjust  		flag indicating action to be taken
//
//	RETURNS		Error code, one of:
//		  		JET_errSuccess
//-
ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLV )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbT;
	DIB		dib;
	KEY		key;
	LVROOT	lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );
 	
	dib.fFlags = fDIRNull;

	/*	open cursor on LONG directory
	/*	seek to this field instance
	/*	find current field size
	/*	add new field segment in chunks no larger than max chunk size
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );
	
	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );
 	
	/*	move to long field instance
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	key.pb = (BYTE *)plid;
	key.cb = sizeof(LID);
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	switch( err )
		{
		case JET_errRecordNotFound:
		case wrnNDFoundGreater:
		case wrnNDFoundLess:
			// The only time we should get here is if another thread has removed the
			// LV tree, but the removal of the LID from the record has not yet been
			// committed.  Another thread could get into this window (via a SetColumn
			// at trx level 0) and obtain the LID, but not be able to find the LV in
			// the tree.
			// Hence, we polymorph these errors/warnings to WriteConflict.
			err = ErrERRCheck( JET_errWriteConflict );
		default:
			Call( err );
		}
	Assert( err == JET_errSuccess );

	switch ( fLV )
		{
		case fLVDereference:
			{
			Call( ErrDIRGet( pfucbT ) );
			Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
			memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
			Assert( lvroot.ulReference > 0 );
			if ( lvroot.ulReference <= 1 && !FDIRDelta( pfucbT, BmOfPfucb( pfucbT ) ) )
				{
				/*	delete long field tree
				/**/
				err = ErrDIRDelete( pfucbT, fDIRVersion );
				}
			else
				{
				/*	decrement long value reference count.
				/**/
				Call( ErrDIRDelta( pfucbT, -1, fDIRVersion ) );
				}
			break;
			}
		default:
			{
			Assert( fLV == fLVReference );
			Call( ErrDIRGet( pfucbT ) );
			Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
			memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
			Assert( lvroot.ulReference > 0 );

			/*	long value may already be in the process of being
			/*	modified for a specific record.  This can only
			/*	occur if the long value reference is 1.  If the reference
			/*	is 1, then check the root for any version, committed
			/*	or uncommitted.  If version found, then burst copy of
			/*	old version for caller record.
			/**/
			if ( lvroot.ulReference == 1 )
				{
				if ( !( FDIRMostRecent( pfucbT ) ) )
					{
Burst:
					Call( ErrRECIBurstSeparateLV( pfucb, pfucbT, plid ) );
					break;
					}
				}
			/*	increment long value reference count.
			/**/
			err = ErrDIRDelta( pfucbT, 1, fDIRVersion );
			if ( err == JET_errWriteConflict )
				{
				goto Burst;
				}
			Call( err );
			break;
			}
		}
HandleError:
	/* discard temporary FUCB
	/**/
	DIRClose( pfucbT );
	return err;
	}


//+api
//	ErrRECAffectLongFields
//	========================================================================
//	ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fFlag )
//
//	Affect all long fields in a record.
//
//	PARAMETERS	pfucb		  	cursor on record being deleted
//				plineRecord		copy or line record buffer
//				fFlag		  	operation to perform
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//-

/*	return fTrue if lid found in record
/**/
INLINE BOOL FLVFoundInRecord( FUCB *pfucb, LINE *pline, LID lid )
	{
	ERR		err;
	FID		fid;
	ULONG  	itag;
	ULONG  	itagT;
	LINE   	lineField;
	LID		lidT;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	/*	walk record tagged columns.  Operate on any column is of type
	/*	long text or long binary.
	/**/
	itag = 1;
	forever
		{
		fid = 0;
		err = ErrRECIRetrieveColumn( (FDB *)pfucb->u.pfcb->pfdb,
			pline,
			&fid,
			&itagT,
			itag,
			&lineField,
			JET_bitRetrieveIgnoreDefault );		// Default values are never separated.
		Assert( err >= 0 );
		if ( err == JET_wrnColumnNull )
			break;
		if ( err == wrnRECLongField )
			{
			Assert( FTaggedFid( fid ) );
			Assert(	FRECLongValue( PfieldFDBTagged( pfucb->u.pfcb->pfdb )[fid-fidTaggedLeast].coltyp ) );

			Assert( lineField.cb > 0 );
			if ( FFieldIsSLong( lineField.pb ) )
				{
				Assert( lineField.cb == sizeof(LV) );
				lidT = LidOfLV( lineField.pb );
				if ( lidT == lid )
					return fTrue;
				}
			}

		itag++;
		}

	return fFalse;
	}


ERR ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fFlag )
	{
	ERR		err;
	FID		fid;
	ULONG  	itagSequenceFound;
	ULONG  	itagSequence;
	LINE   	lineField;
	LID		lid;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

#ifdef XACT_REQUIRED
	if ( pfucb->ppib->level == 0 )
		return ErrERRCheck( JET_errNotInTransaction );
#endif
	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );

	/*	walk record tagged columns.  Operate on any column is of type
	/*	long text or long binary.
	/**/
	itagSequence = 1;
	forever
		{
		fid = 0;
		if ( plineRecord != NULL )
			{
			err = ErrRECIRetrieveColumn( (FDB *)pfucb->u.pfcb->pfdb,
				plineRecord,
				&fid,
				&itagSequenceFound,
				itagSequence,
				&lineField,
				JET_bitRetrieveIgnoreDefault );		// Default values aren't really in the record, so ignore them.
			}
		else
			{
			Call( ErrDIRGet( pfucb ) );
			err = ErrRECIRetrieveColumn( (FDB *)pfucb->u.pfcb->pfdb,
				&pfucb->lineData,
				&fid,
				&itagSequenceFound,
				itagSequence,
				&lineField,
				JET_bitRetrieveIgnoreDefault );
			}
		Assert( err >= 0 );
		if ( err == JET_wrnColumnNull )
			break;
		if ( err == wrnRECLongField )
			{
			Assert( FTaggedFid( fid ) );
			Assert(	FRECLongValue( PfieldFDBTagged( pfucb->u.pfcb->pfdb )[fid  - fidTaggedLeast].coltyp ) );

			/*	flag cursor as having updated a separate LV
			/**/
			FUCBSetUpdateSeparateLV( pfucb );

			switch ( fFlag )
				{
				case fSeparateAll:
					{
					/*	note that we do not separate those long values that are so
					/*	short that they take even less space in a record than a full
					/*	LV structure for separated long value would.
					/**/
 	  				if ( lineField.cb > sizeof(LV) )
						{
						Assert( !( FFieldIsSLong( lineField.pb ) ) );
	 					lineField.pb += offsetof(LV, rgb);
	  					lineField.cb -= offsetof(LV, rgb);
  						Call( ErrRECSeparateLV( pfucb, &lineField, &lid, NULL ) );
						Assert( err == JET_wrnCopyLongValue );
						Call( ErrRECISetLid( pfucb, fid, itagSequenceFound, lid ) );
						}
					break;
					}
				case fReference:
					{
					Assert( lineField.cb > 0 );
	  				if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Call( ErrRECAffectSeparateLV( pfucb, &lid, fLVReference ) );
						/*	if called operation has caused new long value
						/*	to be created, then record new long value id
						/*	in record.
						/**/
						if ( err == JET_wrnCopyLongValue )
							{
							Call( ErrRECISetLid( pfucb, fid, itagSequenceFound, lid ) );
							}
						}
					break;
					}
				case fDereference:
					{
	  				if ( FFieldIsSLong( lineField.pb ) )
						{
			 			Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Call( ErrRECAffectSeparateLV( pfucb, &lid, fLVDereference ) );
						Assert( err != JET_wrnCopyLongValue );
						}
					break;
					}
				case fDereferenceRemoved:
					{
					/*	find all long vales in record that were
					/*	removed when new long value set over
					/*	long value.  Note that we a new long value
					/*	is set over another long value, the long
					/*	value is not deleted, since the update may
					/*	be cancelled.  Instead, the long value is
					/*	deleted at update.  Since inserts cannot have
					/*	set over long values, there is no need to
					/*	call this function for insert operations.
					/**/
					if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Assert( FFUCBReplacePrepared( pfucb ) );
						/*	plineRecord must be NULL, representing current row
						/*	since the comparison is copy buffer.
						/**/
						Assert( plineRecord == NULL );
						if ( !FLVFoundInRecord( pfucb, &pfucb->lineWorkBuf, lid ) )
							{
							/*	if long value in record not found in
							/*	copy buffer then it must be set over
							/*	and it is dereference.
							/**/
							Call( ErrRECAffectSeparateLV( pfucb, &lid, fLVDereference ) );
							Assert( err != JET_wrnCopyLongValue );
							}
						}
					break;
					}
				default:
					{
					Assert( fFlag == fDereferenceAdded );

					/*	find all long vales created in copy buffer
					/*	and not in record and delete them.
					/**/
					if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Assert( FFUCBInsertPrepared( pfucb ) ||
							FFUCBReplacePrepared( pfucb ) );
						if ( FFUCBInsertPrepared( pfucb ) ||
							!FLVFoundInRecord( pfucb, &pfucb->lineData, lid ) )
							{
							/*	if insert prepared then all found long
							/*	values are new, else if long value is new,
							/*	if it exists in copy buffer only.
							/**/
							Call( ErrRECAffectSeparateLV( pfucb, &lid, fLVDereference ) );
							Assert( err != JET_wrnCopyLongValue );
							}
						}
					break;
					}

				Assert( err != JET_wrnCopyLongValue );
  				}
			}
		itagSequence++;
		}
	Call( ErrDIRCommitTransaction( pfucb->ppib, 0 ) );
	return JET_errSuccess;

HandleError:
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	return err;
	}


/***********************************************************
/*****	following functions only used by COMPACT
/***********************************************************


/*	links tagged columid to already existing long value whose id is lid
/*	and increments reference count of long value in a transaction.
/**/
ERR ErrREClinkLid( FUCB *pfucb, FID fid, LONG lid, ULONG itagSequence )
	{
	ERR		err;
	LINE	lineT;
	LV		lvT;

	Assert( itagSequence > 0 );
	lvT.fSeparated = fTrue;
	lvT.lid = lid;	
	lineT.pb = (BYTE *)&lvT;
	lineT.cb = sizeof(LV);

	/*	use it to modify field
	/**/
	CallR( ErrRECSetColumn( pfucb, fid, itagSequence, &lineT ) );

	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
	Call( ErrRECAffectSeparateLV( pfucb, &lid, fLVReference ) );
	Call( ErrDIRCommitTransaction( pfucb->ppib, 0 ) );
	
HandleError:
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\page.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */

LOCAL VOID PMIInsertReorganize( SSIB *pssib, LINE *rgline, INT cline );
LOCAL ERR ErrPMIReplaceReorganize( SSIB *pssib, LINE *rgline, INT cline, INT cbDif );


#ifdef DEBUG
VOID CheckPgno( PAGE *ppage, PN pn )
	{
	ULONG ulPgno;

	LFromThreeBytes( &ulPgno, &(ppage)->pgnoThisPage );
	Assert( ulPgno == PgnoOfPn(pn));
	Assert( ulPgno != 0 );
	}
#endif


#ifdef DEBUG
VOID CheckPage( PAGE *ppage )
	{
	Assert( (ppage)->cbFree >= 0 );
	Assert( (ppage)->cbFree < cbPage );
	Assert( (ppage)->cbUncommittedFreed >= 0 );
	Assert(	(ppage)->cbUncommittedFreed <= (ppage)->cbFree );
	Assert( (ppage)->ibMic >=
		( (INT)sizeof(PGHDR) + (ppage)->ctagMac * (INT)sizeof(TAG) ) );
	Assert( (ppage)->ibMic <= cbPage - (INT)sizeof(PGTRLR) );
	Assert( (ppage)->ctagMac >= 0 );
	Assert( (ppage)->ctagMac <= 256 );
	Assert( (ppage)->itagFree == itagNil ||
		(ppage)->itagFree < (ppage)->ctagMac );
	}
#else
#define CheckPage( ppage )
#endif


//+api---------------------------------------------------------------------
//
//	PMInitPage
//	========================================================================
//
//	PMInitPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
//
//	PMInitPage takes a buffer and initializes it for use by other
//	page manager functions.
//
//	PARAMETERS	ppage 		pointer to buffer to be initialized
//				pgno  		pgno of page (ppage->pgnoThisPage)
//
//-------------------------------------------------------------------------

VOID PMInitPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
	{
	#ifdef DEBUG
		memset( ppage, '_', sizeof(PAGE) );
	#endif
	memset( ppage, 0, sizeof(PGHDR) );
	ppage->ibMic = cbPage - sizeof(PGTRLR);

	Assert( ppage->cbUncommittedFreed == 0 );
	ppage->cbFree	= CbLastFreeSpace(ppage);
	Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
	Assert( ppage->ctagMac == 0 );
	ppage->itagFree = itagNil;

	/*	reset "last-flushed" counter
	/**/
	PMPageResetModified( ppage );
	PMSetDBTime( ppage, 0 );

	SetPgno( ppage, pgno );
	PMSetPageType( ppage, pgtyp );
	PMSetPgnoFDP( ppage, pgnoFDP );
	}



//+api---------------------------------------------------------------------
//
//	ErrPMInsert
//	===========================================================================
//
//	ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline )
//
//	ErrPMInsert concatenates the buffers (pointed to by rgline) and inserts
//	them into the page indicated by pssib.  ErrPMInsert is guaranteed to work
//	if a tag can be allocated, and there is enough free room in page.  If page
//	is too fragmented to insert new lines, it will be reorganized.  NB: this
//	implies that real pointers into a page may be invalid across calls to
//	ErrPMInsert (the same is true for ErrPMUpdate).
//
//	PARAMETERS  pssib->ppage		points to page to insert into
//			   	rgline				LINES (buffers) to be inserted into page
//			   	cline  				number of LINES in rgline
//
//	RETURNS
//		JET_errSuccess;
//		errPMOutOfPageSpace			not enough free space in page
//		errPMTagsUsedUp				no free tags
//									  	
//-------------------------------------------------------------------------

INT ItagPMQueryNextItag( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );

	if ( ppage->itagFree == itagNil )
		{
#ifdef DEBUG
		if ( ppage->ctagMac == ctagMax )
			return itagNil;
#endif
		Assert( ppage->ctagMac < ctagMax );
		return ppage->ctagMac;
		}
	else
		{
		return ppage->itagFree;
		}
	}


ERR ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	LINE	*pline;
	LINE	*plineMax;
	BYTE	*pb;
	INT		ib;
	INT		cb;
	INT		itag;

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( cline > 0 );
	Assert( !( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) ) );

	/*	calculate size of line
	/**/
	cb = 0;
	plineMax = rgline + cline;
	for ( pline = rgline; pline < plineMax; pline++ )
		cb += pline->cb;
	Assert( cb != 0 );

	if ( ppage->itagFree == itagNil )
		{
		if ( ppage->ctagMac == ctagMax )
			return ErrERRCheck( errPMTagsUsedUp );

		Assert( pssib->pbf->ppage == ppage );
		if ( CbPMFreeSpace( pssib ) < ( cb + (INT)sizeof(TAG) ) )
			{
			return ErrERRCheck( errPMOutOfPageSpace );
			}
			

		/*	allocate tag from end of tag array
		/*	if new tag overlaps data then reorganize
		/**/
		pssib->itag = itag = ppage->ctagMac;
		if ( (INT) sizeof(PGHDR) + (INT) sizeof(TAG) * ( itag + 1 ) + cb > ppage->ibMic )
			{
			PMIInsertReorganize( pssib, rgline, cline );
			goto Succeed;
			}

		++ppage->ctagMac;
		ppage->cbFree -= (SHORT)( cb + sizeof(TAG) );
		Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
		Assert( ppage->cbUncommittedFreed >= 0  &&
			ppage->cbUncommittedFreed <= ppage->cbFree );
		}
	else
		{
		Assert( pssib->pbf->ppage == ppage );
		if ( CbPMFreeSpace( pssib ) < cb )
			{
			return ErrERRCheck( errPMOutOfPageSpace );
			}

		pssib->itag =
		itag = ppage->itagFree;
		Assert( itag < ppage->ctagMac );
		ppage->itagFree = ppage->rgtag[ itag ].ib;

		if ( (INT) CbLastFreeSpace(ppage) < cb )
			{
			PMIInsertReorganize( pssib, rgline, cline );
			goto Succeed;
			}

		ppage->cbFree -= (SHORT)cb;
		Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
		Assert( ppage->cbUncommittedFreed >= 0  &&
			ppage->cbUncommittedFreed <= ppage->cbFree );
		}

	ppage->ibMic -= (SHORT)cb;
	ib = ppage->ibMic;

	Assert( (UINT) ib < (UINT) sizeof( PAGE ) );
	Assert( (UINT) sizeof(PGHDR) + ppage->ctagMac * (SHORT) sizeof(TAG)
		<= (UINT) ib );

	Assert( itag < ppage->ctagMac );
	Assert( (SHORT) sizeof(PGHDR) + ppage->ctagMac * (SHORT) sizeof(TAG)
		<= ppage->ibMic );

	/*	add line
	/**/
	pssib->line.pb = pb = (BYTE *)ppage + ib;
	for ( pline = rgline; pline < plineMax; pline++ )
		{
		Assert( pline->cb < cbPage );
		memcpy( pb, pline->pb, pline->cb );
		Assert( (UINT) ib < (UINT) sizeof( PAGE ) );
		pb += pline->cb;
		}

	PtagFromIbCb( &ppage->rgtag[itag], ib, cb);
	Assert( (UINT) ib < (UINT) sizeof( PAGE ) );

	/*	set return values
	/**/
	Assert( pssib->itag == itag );
	pssib->line.cb = cb;
	Assert( pssib->line.pb == (BYTE *)ppage + ib );

	Assert( pssib->itag < ctagMax );
	
Succeed:
	AssertBTFOP(pssib);
	CheckPage( ppage );
	return JET_errSuccess;
	}



//+api------------------------------------------------------------------------
//
//	ErrPMReplace
//	===========================================================================
//
//	ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline )
//
//	ErrPMReplace will replace the contents of line pssib->itag with the
//	contents of the buffers indicated by rgline.
//
//	SEE ALSO ErrPMInsert
//
//----------------------------------------------------------------------------
ERR ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline )
	{
	ERR		err;
	PAGE	*ppage = pssib->pbf->ppage;
	INT		cbLine;
	INT		cbDif;
	INT		ibReplace;
	INT		cbReplace;
	LINE	*pline;
	LINE	*plineMax = rgline + cline;

	#ifdef DEBUG
		INT	itag = pssib->itag;
		Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	#endif

	#ifdef DEBUG
		{
		BYTE	bT = *rgline[0].pb;
		BOOL	fSon = (bT & 0x08);
		BOOL	fVis = (bT & 0x04);
//		Assert( pssib->itag != 0 || fVis || fSon );
		}
	#endif

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( cline > 0 );
	Assert( pssib->itag < ppage->ctagMac );
	Assert( !( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) ) );

	cbLine = 0;
	for ( pline = rgline; pline < plineMax; pline++ )
		{
		cbLine += pline->cb;
		}

	IbCbFromPtag( ibReplace, cbReplace, &ppage->rgtag[pssib->itag] );

	/*	tag should not be of deleted line
	/**/
	Assert( cbReplace > 0 );

	cbDif = cbLine - cbReplace;

	/*	if new line is same size or smaller then update in place
	/*	dont reclaim space at end of line if new line is smaller
	/**/
	if ( cbDif == 0 )
		{
		BYTE	*pb = pssib->line.pb = (BYTE *)ppage + ibReplace;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}
		pssib->line.cb = cbLine;
		goto Succeed;
		}

	if ( cbDif < 0 )
		{
		BYTE	*pb = pssib->line.pb = (BYTE *)ppage + ibReplace;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}
		pssib->line.cb = cbLine;
		PtagFromIbCb( &ppage->rgtag[pssib->itag], ibReplace, cbLine );
		ppage->cbFree -= (SHORT)cbDif;
		Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
		Assert( ppage->cbUncommittedFreed >= 0  &&
			ppage->cbUncommittedFreed <= ppage->cbFree );
		goto Succeed;
		}

	/*	if line is ibMic then try to copy/overwrite line.
	/*	Note that this can only be done when buffer is not write
	/*	latched, since overwrite will modify data that pointer may
	/*	be cached on.
	/*
	/*	Note that we must check cbFree since some space may be
	/*	reserved for rollback.
	/**/
	Assert( pssib->pbf->ppage == ppage );
	if ( ibReplace == ppage->ibMic &&
		(INT) CbLastFreeSpace(ppage) >= cbDif &&
		CbPMFreeSpace( pssib ) >= cbDif )
		{
		BYTE	*pb;

		Assert( (SHORT) sizeof(PGHDR) + ppage->ctagMac * (SHORT) sizeof(TAG) <= ppage->ibMic );
		Assert( cbDif > 0 );
		pssib->line.pb = pb = (BYTE *)ppage + ibReplace - cbDif;
		ppage->ibMic -= (SHORT)cbDif;
		ppage->cbFree -= (SHORT)cbDif;
		Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
		Assert( ppage->cbUncommittedFreed >= 0  &&
			ppage->cbUncommittedFreed <= ppage->cbFree );

		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}

		/*	set return values
		/**/
		pssib->line.cb = cbLine;
		PtagFromIbCb( &ppage->rgtag[pssib->itag], ibReplace - cbDif, cbLine );
		goto Succeed;
		}

	/*	try to move line to ibMic
	/**/
	Assert( pssib->pbf->ppage == ppage );
	if ( (INT) CbLastFreeSpace(ppage) >= cbLine && CbPMFreeSpace( pssib ) >= cbLine )
		{
		INT	ib;
		BYTE	*pb;

		Assert( cbDif > 0 );
		ppage->cbFree -= (SHORT)cbDif;
		Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
		Assert( ppage->cbUncommittedFreed >= 0  &&
			ppage->cbUncommittedFreed <= ppage->cbFree );
		ppage->ibMic -= (SHORT)cbLine;
		ib = ppage->ibMic;
		Assert( (SHORT) sizeof(PGHDR) + ppage->ctagMac * (SHORT) sizeof(TAG) <= ppage->ibMic );

		/*	insert line
		/**/
		pssib->line.pb = pb = (BYTE *)ppage + ib;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}

		PtagFromIbCb( &ppage->rgtag[pssib->itag], ib, cbLine );

		/*	set return values
		/**/
		pssib->line.cb = cbLine;
		Assert( pssib->line.pb == (BYTE *)ppage + ib );
		goto Succeed;
		}

	/*	if insufficient space return error
	/**/
	Assert( cbDif > 0 );
	if ( CbPMFreeSpace( pssib ) < cbDif )
		{
		return ErrERRCheck( errPMOutOfPageSpace );
		}

	/*	replace line while reorganizing page
	/**/
	err = ErrPMIReplaceReorganize( pssib, rgline, cline, cbDif );
	CheckPage( ppage );
	return err;
	
Succeed:
	AssertBTFOP(pssib);
	CheckPage( ppage );
	return JET_errSuccess;
	}



//+api------------------------------------------------------------------------
//
//	PMDelete
//	===========================================================================
//
//	PMDelete( PAGE *ppage, INT itag )
//
//	PMDelete will free up space allocated to a line of data in a PAGE.
//
//----------------------------------------------------------------------------

VOID PMDelete( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	INT		itag = pssib->itag;
	INT		ib;
	INT		cb;

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( itag < ppage->ctagMac );
	Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	IbCbFromPtag( ib, cb, &ppage->rgtag[itag] );
	Assert( cb );

	//	FREE DATA
	if ( ib == ppage->ibMic )
		{
		ppage->ibMic += (SHORT)cb;
		}
	ppage->cbFree += (SHORT)cb;
	Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
	Assert( ppage->cbUncommittedFreed >= 0  &&
		ppage->cbUncommittedFreed <= ppage->cbFree );

	//	FREE TAG
	cb = 0;
	ib = ppage->itagFree;
	PtagFromIbCb( &ppage->rgtag[itag], ib, cb );
	ppage->itagFree = (SHORT)itag;
	Assert( ppage->itagFree < ppage->ctagMac );

	CheckPage( ppage );
	return;
	}


//+api------------------------------------------------------------------------
//	ErrPMGet
//	===========================================================================
//
//	ErrPMGet( SSIB *pssib, INT itag )
//
//	ErrPMGet will calculate and return a real pointer to a given line within
//	the page.
//
//	PARAMETERS		pssib->pbf->ppage		ppage to read line from
//						itag						itag of line
//
//----------------------------------------------------------------------------
ERR ErrPMGet( SSIB *pssib, INT itag )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	INT		ib;
	INT		cb;

#ifdef DEBUG
	PGNO pgnoP;
	PGNO pgnoN;
	LFromThreeBytes( &pgnoP, &pssib->pbf->ppage->pgnoPrev );
	Assert(pgnoP != PgnoOfPn(pssib->pbf->pn));
	LFromThreeBytes( &pgnoN, &pssib->pbf->ppage->pgnoNext );
	Assert(pgnoN != PgnoOfPn(pssib->pbf->pn));
	Assert(pgnoN == 0 || pgnoN != pgnoP);
#endif

	CheckSSIB( pssib );
	CheckPage( ppage );
	if ( itag >= ppage->ctagMac )
		{
		return ErrERRCheck( errPMItagTooBig );
		}
	IbCbFromPtag( ib, cb, &ppage->rgtag[itag] );
	if ( !cb )
		{
		return ErrERRCheck( errPMRecDeleted );
		}
	/*	return error code for unused tag for bookmark clean up
	/**/
	if ( TsPMTagstatus( ppage, itag ) != tsLine )
		{
		return ErrERRCheck( errPMRecDeleted );
		}
	Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	pssib->line.cb = cb;
	pssib->line.pb = (BYTE *)ppage + ib;
	return JET_errSuccess;
	}


//======Local Routines ====================================================

static CRIT	critPMReorganize;
static BYTE	rgbCopy[ cbPage - sizeof(PGTRLR) ];


LOCAL VOID PMIInsertReorganize( SSIB *pssib, LINE *rgline, INT cline )
	{
	UINT 	ibT = sizeof( rgbCopy );
	PAGE 	*ppage = pssib->pbf->ppage;
	TAG		*ptag;
	TAG		*ptagMax;
	INT		ibAdd;
	INT		cbAdd;
	LINE  	*pline;

	/*	ulDBTime of the page maybe not effective any more,
	/*	lets reset it again
	/**/
	BFDirty( pssib->pbf );

	SgEnterCriticalSection( critPMReorganize );

	/*	add line
	/**/
	cbAdd = 0;
	for ( pline = rgline + cline - 1; pline >= rgline; pline-- )
		{
		ibT -= pline->cb;
		Assert( ibT <= sizeof(rgbCopy) );
		Assert( pline->cb < cbPage );
		memcpy( rgbCopy + ibT, pline->pb, pline->cb );
		cbAdd += pline->cb;
		}
	ibAdd = ibT;

	/*	copy and compact existing page lines
	/**/
	ptag = ppage->rgtag;
	ptagMax = ptag + ppage->ctagMac;
	for ( ; ptag < ptagMax; ptag++ )
		{
		INT		ib;
		INT		cb;

		IbCbFromPtag( ib, cb, ptag );
		if ( ( *(LONG *)ptag & bitLink ) == 0 && cb > 0 )
			{
			ibT -= cb;
			Assert( ibT <= sizeof(rgbCopy) );
			Assert( cb >= 0 && cb < cbPage );
			memcpy( rgbCopy + ibT, (BYTE *)ppage + ib, cb );
			ib = ibT;
			PtagFromIbCb( ptag, ib, cb );
			}
		}

	Assert( ibT <= sizeof(rgbCopy) );
	memcpy( (BYTE *)ppage + ibT, rgbCopy + ibT, sizeof(rgbCopy) - ibT );

	SgLeaveCriticalSection( critPMReorganize );

	PtagFromIbCb( &ppage->rgtag[pssib->itag], ibAdd, cbAdd );

	/* set page header
	/**/
	ppage->ibMic = (SHORT)ibT;
	if ( pssib->itag == ppage->ctagMac )
		{
		ppage->ctagMac++;
		ppage->cbFree -= (SHORT)( cbAdd + sizeof(TAG) );
		}
	else
		{
		ppage->cbFree -= (SHORT)cbAdd;
		}
	Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
	Assert( ppage->cbUncommittedFreed >= 0  &&
		ppage->cbUncommittedFreed <= ppage->cbFree );
	Assert( (ppage)->ibMic >=
		( (INT)sizeof(PGHDR) + (ppage)->ctagMac * (INT)sizeof(TAG) ) );

	/*	set return values
	/**/
	pssib->line.cb = cbAdd;
	pssib->line.pb = (BYTE *) ppage + ibAdd;

	return;
	}


LOCAL ERR ErrPMIReplaceReorganize( SSIB *pssib, LINE *rgline, INT cline, INT cbDif )
	{
	UINT  	ibT				= sizeof( rgbCopy );
	PAGE  	*ppage			= pssib->pbf->ppage;
	TAG		*ptagReplace	= &ppage->rgtag[pssib->itag];
	TAG		*ptag;
	TAG		*ptagMax;
	INT		ibReplace;
	INT		cbReplace;
	LINE  	*pline;

	/*	ulDBTime of the page maybe not effective any more,
	/*	lets reset it again
	/**/
	BFDirty( pssib->pbf );

	SgEnterCriticalSection( critPMReorganize );

	/*	insert replace line in reorganize buffer
	/**/
	cbReplace = 0;
	for ( pline = rgline + cline - 1; pline >= rgline; pline-- )
		{
		ibT -= pline->cb;
		Assert( ibT <= sizeof(rgbCopy) );
		Assert( pline->cb < cbPage );
		memcpy( rgbCopy + ibT, pline->pb, pline->cb );
		cbReplace += pline->cb;
		}
	ibReplace = ibT;

	/*	copy and compact existing page lines, but not the line being
	/*	replaced since it has already been copied.
	/**/
	ptag = ppage->rgtag;
	ptagMax = ptag + ppage->ctagMac;
	for ( ; ptag < ptagMax; ptag++ )
		{
		INT ib, cb;

		if ( ptag == ptagReplace )
			{
			PtagFromIbCb( ptag, ibReplace, cbReplace );
			continue;
			}

		IbCbFromPtag( ib, cb, ptag );
		if ( ( *(LONG *)ptag & bitLink ) == 0 && cb > 0 )
			{
			ibT -= cb;
			Assert( ibT <= sizeof(rgbCopy) );
			memcpy( rgbCopy + ibT, (BYTE *)ppage + ib, cb );
			ib = ibT;
			PtagFromIbCb( ptag, ib, cb );
			}
		}

	Assert( ibT <= sizeof(rgbCopy) );
	memcpy( (BYTE *)ppage + ibT, rgbCopy + ibT, sizeof(rgbCopy) - ibT );

	SgLeaveCriticalSection( critPMReorganize );

	/* set page header
	/**/
	ppage->ibMic = (SHORT)ibT;
	ppage->cbFree -= (SHORT)cbDif;
	Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
	Assert( ppage->cbUncommittedFreed >= 0  &&
		ppage->cbUncommittedFreed <= ppage->cbFree );

	/*	set return values
	/**/
	pssib->line.cb = cbReplace;
	pssib->line.pb = (BYTE *) ppage + ibReplace;

	return JET_errSuccess;
	}


TS TsPMTagstatus( PAGE *ppage, INT itag )
	{
	TAG	tag;

	Assert( itag < ppage->ctagMac );
	tag = ppage->rgtag[itag];
	if ( *(LONG *)&tag & bitLink )
		{
		return tsLink;
		}
	if ( tag.cb == 0 )
		return tsVacant;
	return tsLine;
	}


#ifdef DEBUG
VOID PMSetModified( SSIB *pssib )
	{
	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	PMPageSetModified( pssib->pbf->ppage );
	CheckPgno( pssib->pbf->ppage, pssib->pbf->pn );
	}


VOID PMResetModified( SSIB *pssib )
	{
	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
//	AssertBFDirty( pssib->pbf );
	PMPageResetModified( pssib->pbf->ppage );
	CheckPgno( pssib->pbf->ppage, pssib->pbf->pn );
	}
#endif


VOID PMGetLink( SSIB *pssib, INT itag, LINK *plink )
	{
	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	*plink = *(LINK *)&(pssib->pbf->ppage->rgtag[itag]);
	Assert( *(LONG *)plink & bitLink );
	*(LONG *)plink &= ~bitLink;
	}


VOID PMReplaceWithLink( SSIB *pssib, SRID srid )
	{
	PAGE  	*ppage = pssib->pbf->ppage;
	INT		ib;
	INT		cb;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( pssib->itag != 0 );
	Assert( pssib->itag < ppage->ctagMac );
	IbCbFromPtag( ib, cb, &ppage->rgtag[pssib->itag] );
	Assert( cb > 0 );

	/*	free data space
	/**/
	if ( ib == ppage->ibMic )
		{
		ppage->ibMic += (SHORT)cb;
		}
	ppage->cbFree += (SHORT)cb;
	Assert( ppage->cbFree >= 0 && ppage->cbFree < cbPage );
	Assert( ppage->cbUncommittedFreed >= 0  &&
		ppage->cbUncommittedFreed <= ppage->cbFree );

	/*	convert tag to link
	/**/
	Assert( ( *(LONG *)&srid & bitLink ) == 0 );
	*(SRID *)&ppage->rgtag[pssib->itag] = srid | bitLink;
	}


VOID PMReplaceLink( SSIB *pssib, SRID srid )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( pssib->itag != 0 );
	Assert( pssib->itag < ppage->ctagMac );
	Assert( ( *(LONG *)&srid & bitLink ) == 0 );
	Assert( ( *(LONG *)&ppage->rgtag[pssib->itag] & bitLink ) != 0 );
	*(SRID *)&ppage->rgtag[pssib->itag] = srid | bitLink;
	}


VOID PMExpungeLink( SSIB *pssib )
	{
	PAGE  	*ppage = pssib->pbf->ppage;
	TAG		*ptag;
	INT		itag = pssib->itag;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( itag != 0 );
	Assert( itag < ppage->ctagMac );

	/*	free tag
	/**/
	ptag = &ppage->rgtag[itag];
	ptag->cb = 0;
	ptag->ib = ppage->itagFree;
	ppage->itagFree = (SHORT)itag;
	Assert( ppage->itagFree < ppage->ctagMac );
	}

/* checks if current node is the only node in the page [other than the FOP]
/**/
BOOL FPMLastNode( SSIB *pssib )
	{
	INT cFreeTags = CPMIFreeTag( pssib->pbf->ppage );
	INT cUsedTags = ctagMax - cFreeTags;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

#ifdef DEBUG
#define itagFOP	0		// same as in dirapi.h
	Assert( cUsedTags >= 2 );
	if ( cUsedTags == 1 )
		{
		AssertPMGet( pssib, itagFOP );
		}
#endif
	return( cUsedTags == 2 );
	}


/* returns number of links in page
/**/
INT	CPMILinks( SSIB *pssib )
	{
	INT		itag;
	INT		cLinks = 0;
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );

	for ( itag = 0; itag < ppage->ctagMac; itag++ )
		{
		if ( *(LONG *)&ppage->rgtag[itag] & bitLink )
			cLinks++;
		}
		
	return cLinks;
	}


/* 	checks if current node is the only node in page other than FOP and links
/*	AND there are links
/**/
BOOL FPMLastNodeWithLinks( SSIB *pssib )
	{
	INT cFreeTags = CPMIFreeTag( pssib->pbf->ppage );
	INT cUsedTags = ctagMax - cFreeTags;
	INT	cLinks = CPMILinks( pssib );
	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

#ifdef DEBUG
#define itagFOP	0		// same as in dirapi.h
	Assert( cUsedTags - cLinks >= 2 );
	if ( cUsedTags == 1 )
		{
		AssertPMGet( pssib, itagFOP );
		}
#endif
	return( cLinks > 0 && cUsedTags - cLinks == 2 );
	}



/* checks if page has only one line -- that holding FOP
/**/
BOOL FPMEmptyPage( SSIB *pssib )
	{
	INT cFreeTags = CPMIFreeTag( pssib->pbf->ppage );
	INT cUsedTags = ctagMax - cFreeTags;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );
	Assert( cUsedTags >= 1 );

#ifdef DEBUG
#define itagFOP	0		// same as in dirapi.h
	if ( cUsedTags == 1 )
		{
		AssertPMGet( pssib, itagFOP );
		}
#endif

	return( cUsedTags == 1 );
	}


/* returns number of free tags in page
/**/
INT CPMIFreeTag( PAGE *ppage )
 	{
 	INT	citag = ctagMax - ppage->ctagMac;
 	INT	itag = ppage->itagFree;
 	TAG	*ptag;

//	CheckPage( ppage );

	for (; itag != itagNil; )
 		{
 		citag++;
 		Assert( citag <= ctagMax );	// catch an infinite loop
 		ptag = &ppage->rgtag[itag];
 		Assert( ptag->cb == 0 );
 		itag = ptag->ib;
 		}
 	return ( citag );
 	}


BOOL FPMFreeTag( SSIB *pssib, INT citagReq )
	{
	PAGE *ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );
	
	return ( ppage->ctagMac + citagReq <= ctagMax ||
		CPMIFreeTag( ppage ) >= citagReq );
	}


/*	returns count of bytes used for links.  Called by split
/*	to determine total count of data and data node tags in
/*	page for split selection.
/**/
INT CbPMLinkSpace( SSIB *pssib )
	{
	return CPMILinks( pssib ) * sizeof(TAG);
	}


VOID PMDirty( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

	Assert( fLogDisabled || !FDBIDLogOn(DbidOfPn( pssib->pbf->pn ) ) ||
			CmpLgpos( &pssib->ppib->lgposStart, &lgposMax ) != 0 );

	/* if current transaction is oldest then timestamp the BF
	/**/
	if ( !fLogDisabled && FDBIDLogOn(DbidOfPn( pssib->pbf->pn )) )
		{
		/*	check if current transaction is oldest then timestamp the BF
		 */
		BFEnterCriticalSection( pssib->pbf );
		if ( CmpLgpos( &pssib->pbf->lgposRC, &pssib->ppib->lgposStart ) > 0 )
			pssib->pbf->lgposRC = pssib->ppib->lgposStart;
		BFLeaveCriticalSection( pssib->pbf );
		}

	BFDirty( pssib->pbf );
	}

//====== Debugging Routines ===============================================

#ifdef DEBUG
VOID AssertPMGet( SSIB *pssib, LONG itag )
	{
	ERR		err;
	SSIB 	ssib;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

#ifdef DEBUG
		{
		ULONG ulPgno;
		LFromThreeBytes( &ulPgno, &pssib->pbf->ppage->pgnoThisPage );
		Assert( ulPgno == PgnoOfPn(pssib->pbf->pn));
		Assert( ulPgno != 0 );
		}
#endif

	ssib.pbf = pssib->pbf;
	err = ErrPMGet( &ssib, itag );
	Assert( err == JET_errSuccess );
	Assert( ssib.line.pb == pssib->line.pb );
	Assert( ssib.line.cb == pssib->line.cb );
	}


VOID PageConsistent( PAGE *ppage )
	{
	INT		cbTotal = 0;
	INT		itag, itagTmp;
	TAG		tag, tagTmp;
	INT		ibStart, ibEnd;
	INT		ibMic = sizeof(PAGE) - sizeof(PGTRLR);
	BYTE	*pbFirstFree = (BYTE *)(&ppage->rgtag[ppage->ctagMac]);
	BYTE	*pbLine;

#if DEBUGGING
	{
	ULONG ulTmp;

	LFromThreeBytes( &ulTmp, &ppage->pgnoThisPage );
	printf( "Checking if Page Consistent %lu\n", ulTmp );
	}
#endif

	for ( itag = 0; itag < ppage->ctagMac; itag++ )
		{
		tag = ppage->rgtag[itag];
		if ( !tag.cb )
			continue;
		if ( *(LONG *)&tag & bitLink )
			continue;
		Assert( tag.ib > sizeof(PGHDR) );
		Assert( tag.ib < sizeof(PAGE) - sizeof(PGTRLR) );
		Assert( tag.cb <= sizeof(PAGE) - sizeof(PGHDR) - sizeof(PGTRLR) );
		cbTotal += tag.cb;
		ibStart = tag.ib;
		ibEnd = tag.ib + tag.cb;

		if ( ibStart < ibMic )
			ibMic = ibStart;

		pbLine = (BYTE*) ppage + tag.ib;
		Assert( FNDNullSon(*pbLine) || CbNDSon(pbLine) != 0);

		Assert( pbFirstFree <= (BYTE *)ppage + ibStart );
		Assert( ibEnd <= cbPage - sizeof(PGTRLR) );

		/* make sure there is no overlap */
		for ( itagTmp = 0; itagTmp < ppage->ctagMac; itagTmp++ )
			{
			tagTmp = ppage->rgtag[itagTmp];
			if ( itag != itagTmp && ( ( *(LONG *)&tagTmp & bitLink ) == 0 ) )
				Assert( tagTmp.ib < ibStart || tagTmp.ib >= ibEnd );
			}
		}

	Assert( ibMic >= ppage->ibMic );
	Assert( ibMic - ( pbFirstFree - (BYTE *)ppage) <= ppage->cbFree );

	cbTotal += sizeof(PGHDR);
	cbTotal += sizeof(TAG) * ppage->ctagMac;
	cbTotal += ppage->cbFree;
	cbTotal += sizeof(PGTRLR);
	Assert( cbTotal == cbPage );
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\perfdisp.c ===
/*  Machine generated data file "perfdisp.c" from "edbperf.dat"  */


#include "std.h"

#include <stddef.h>

#include "winperf.h"

#pragma pack(4)


extern PM_ICF_PROC LProcNameICFLPpv;

PM_ICF_PROC* rgpicfPERFICF[] = {
	LProcNameICFLPpv,
};

extern PM_CEF_PROC LOpenTableCacheHitsCEFLPpv;
extern PM_CEF_PROC LOpenTablesCEFLPpv;
extern PM_CEF_PROC LLGBytesWrittenCEFLPpv;
extern PM_CEF_PROC LLGUsersWaitingCEFLPpv;
extern PM_CEF_PROC LLGCheckpointDepthCEFLPpv;
extern PM_CEF_PROC LBFSyncReadsCEFLPpv;
extern PM_CEF_PROC LBFAsyncReadsCEFLPpv;
extern PM_CEF_PROC LBFBytesReadCEFLPpv;
extern PM_CEF_PROC LBFSyncWritesCEFLPpv;
extern PM_CEF_PROC LBFAsyncWritesCEFLPpv;
extern PM_CEF_PROC LBFBytesWrittenCEFLPpv;
extern PM_CEF_PROC LBFIOQueueLengthCEFLPpv;
extern PM_CEF_PROC LBFCacheHitsCEFLPpv;
extern PM_CEF_PROC LBFCacheReqsCEFLPpv;
extern PM_CEF_PROC LBFCleanBuffersCEFLPpv;
extern PM_CEF_PROC LBFTotalBuffersCEFLPpv;
extern PM_CEF_PROC LBFAvailBuffersCEFLPpv;
extern PM_CEF_PROC LBFTotalBuffersCEFLPpv;

PM_CEF_PROC* rgpcefPERFCEF[] = {
	LOpenTableCacheHitsCEFLPpv,
	LOpenTablesCEFLPpv,
	LLGBytesWrittenCEFLPpv,
	LLGUsersWaitingCEFLPpv,
	LLGCheckpointDepthCEFLPpv,
	LBFSyncReadsCEFLPpv,
	LBFAsyncReadsCEFLPpv,
	LBFBytesReadCEFLPpv,
	LBFSyncWritesCEFLPpv,
	LBFAsyncWritesCEFLPpv,
	LBFBytesWrittenCEFLPpv,
	LBFIOQueueLengthCEFLPpv,
	LBFCacheHitsCEFLPpv,
	LBFCacheReqsCEFLPpv,
	LBFCleanBuffersCEFLPpv,
	LBFTotalBuffersCEFLPpv,
	LBFAvailBuffersCEFLPpv,
	LBFTotalBuffersCEFLPpv,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\perfutil.c ===
#include "std.h"
#include "version.h"

#include "perfutil.h"


	/*  DLL entry point for JETPERF.DLL  */

INT APIENTRY LibMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
	{
	return(1);
	}


	/*  Registry support functions  */

DWORD DwPerfUtilRegOpenKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult)
{
	return RegOpenKeyEx(hkeyRoot,lpszSubKey,0,KEY_QUERY_VALUE,phkResult);
}


DWORD DwPerfUtilRegCloseKeyEx(HKEY hkey)
{
	return RegCloseKey(hkey);
}


DWORD DwPerfUtilRegCreateKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult,LPDWORD lpdwDisposition)
{
	return RegCreateKeyEx(hkeyRoot,lpszSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,NULL,phkResult,lpdwDisposition);
}


DWORD DwPerfUtilRegDeleteKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey)
{
	return RegDeleteKey(hkeyRoot,lpszSubKey);
}


DWORD DwPerfUtilRegDeleteValueEx(HKEY hkey,LPTSTR lpszValue)
{
	return RegDeleteValue(hkey,lpszValue);
}


DWORD DwPerfUtilRegSetValueEx(HKEY hkey,LPCTSTR lpszValue,DWORD fdwType,CONST BYTE *lpbData,DWORD cbData)
{
		/*  make sure type is set correctly by deleting value first  */

	(VOID)DwPerfUtilRegDeleteValueEx(hkey,(LPTSTR)lpszValue);
	return RegSetValueEx(hkey,lpszValue,0,fdwType,lpbData,cbData);
}


	/*  DwPerfUtilRegQueryValueEx() adds to the functionality of RegQueryValueEx() by returning
	/*  the data in callee malloc()ed memory and automatically converting REG_EXPAND_SZ
	/*  strings using ExpandEnvironmentStrings() to REG_SZ strings.
	/*
	/*  NOTE:  references to nonexistent env vbles will be left unexpanded :-(  (Ex.  %UNDEFD% => %UNDEFD%)
	/**/

DWORD DwPerfUtilRegQueryValueEx(HKEY hkey,LPTSTR lpszValue,LPDWORD lpdwType,LPBYTE *lplpbData)
{
	DWORD cbData;
	LPBYTE lpbData;
	DWORD errWin;
	DWORD cbDataExpanded;
	LPBYTE lpbDataExpanded;

	*lplpbData = NULL;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,NULL,&cbData)) != ERROR_SUCCESS)
		return errWin;

	if ((lpbData = malloc(cbData)) == NULL)
		return ERROR_OUTOFMEMORY;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,lpbData,&cbData)) != ERROR_SUCCESS)
	{
		free(lpbData);
		return errWin;
	}

	if (*lpdwType == REG_EXPAND_SZ)
	{
		cbDataExpanded = ExpandEnvironmentStrings(lpbData,NULL,0);
		if ((lpbDataExpanded = malloc(cbDataExpanded)) == NULL)
		{
			free(lpbData);
			return ERROR_OUTOFMEMORY;
		}
		if (!ExpandEnvironmentStrings(lpbData,lpbDataExpanded,cbDataExpanded))
		{
			free(lpbData);
			free(lpbDataExpanded);
			return GetLastError();
		}
		free(lpbData);
		*lplpbData = lpbDataExpanded;
		*lpdwType = REG_SZ;
	}
	else  /*  lpdwType != REG_EXPAND_SZ  */
	{
		*lplpbData = lpbData;
	}

	return ERROR_SUCCESS;
}


	/*  shared performance data area resources  */

void *pvPERFSharedData = NULL;
HANDLE hPERFFileMap = NULL;
HANDLE hPERFSharedDataMutex = NULL;
HANDLE hPERFInstanceMutex = NULL;
HANDLE hPERFCollectSem = NULL;
HANDLE hPERFDoneEvent = NULL;
HANDLE hPERFProcCountSem = NULL;
HANDLE hPERFNewProcMutex = NULL;


	/*  Event Logging support  */

HANDLE hOurEventSource = NULL;

void PerfUtilLogEvent( DWORD evncat, WORD evntyp, const char *szDescription )
{
    char		*rgsz[3];

    	/*  convert args from internal types to event log types  */

	rgsz[0]	= "";
	rgsz[1] = "";
	rgsz[2] = (char *)szDescription;

		/*  write to our event log, if it has been opened  */

	if (hOurEventSource)
	{
		ReportEvent(
			hOurEventSource,
			(WORD)evntyp,
			(WORD)evncat,
			PLAIN_TEXT_ID,
			0,
			3,
			0,
			rgsz,
			0 );
	}

	return;
}


	/*  Init/Term routines for system indirection layer  */

DWORD dwInitCount = 0;

DWORD DwPerfUtilInit( VOID )
{
	DWORD					err;
	CHAR					szT[256];
    BYTE					rgbSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR	pSD = (PSECURITY_DESCRIPTOR) rgbSD;
	SECURITY_ATTRIBUTES		SA;
	SECURITY_ATTRIBUTES		*pSA;

		/*  if we haven't been initialized already, perform init  */

	if (!dwInitCount)
	{
			/*  open the event log  */

	    if (!(hOurEventSource = RegisterEventSource( NULL, szVerName )))
	    	return GetLastError();

		/*
		 * We've been having access denied problems opening the file mapping
		 * from the perfmon dll, so make extra sure that we have rights to do
		 * so by creating a SD that grants full access.  If the creation fails
		 * then just fall back on passing in a NULL SD pointer.
		 */
		if ( !InitializeSecurityDescriptor( pSD, SECURITY_DESCRIPTOR_REVISION ) ||
			!SetSecurityDescriptorDacl( pSD, TRUE, (PACL)NULL, FALSE ) )
			{
			pSD = NULL;
			}
		pSA = &SA;
		pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
		pSA->lpSecurityDescriptor = pSD;
		pSA->bInheritHandle = FALSE;

		/*  create the performance data area file mapping
		/**/
		hPERFFileMap = CreateFileMapping( (HANDLE)(-1),
			pSA,
			PAGE_READWRITE,
			0,
			PERF_SIZEOF_SHARED_DATA,
			szPERFVersion );

		if ( !hPERFFileMap )
		{
			err = GetLastError();
			goto CloseEventLog;
		}
		if (!(pvPERFSharedData = MapViewOfFile(hPERFFileMap,FILE_MAP_WRITE,0,0,0)))
		{
			err = GetLastError();
			goto CloseFileMap;
		}

			/*  open/create the collect semaphore, but do not acquire  */

		sprintf( szT,"Collect:  %.246s",szPERFVersion );
		if ( !( hPERFCollectSem = CreateSemaphore( pSA, 0, PERF_INIT_INST_COUNT, szT ) ) )
		{
			if (GetLastError() == ERROR_ALREADY_EXISTS)
				hPERFCollectSem = OpenSemaphore(SEMAPHORE_ALL_ACCESS,FALSE,szT);
		}
		if (!hPERFCollectSem)
		{
			err = GetLastError();
			goto UnmapFileMap;
		}

			/*  open/create the performance data collect done event  */

		sprintf(szT,"Done:  %.246s",szPERFVersion);
		if ( !( hPERFDoneEvent = CreateEvent( pSA, FALSE, FALSE, szT ) ) )
		{
			if (GetLastError() == ERROR_ALREADY_EXISTS)
				hPERFDoneEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,szT);
		}
		if (!hPERFDoneEvent)
		{
			err = GetLastError();
			goto FreeSem;
		}

			/*  create/open the performance data area mutex, but do not acquire  */

		sprintf(szT,"Access:  %.246s",szPERFVersion);
		if ( !( hPERFSharedDataMutex = CreateMutex( pSA, FALSE, szT ) ) )
		{
			err = GetLastError();
			goto FreeEvent;
		}

			/*  create/open the instance mutex, but do not acquire  */

		sprintf(szT,"Instance:  %.246s",szPERFVersion);
		if ( !( hPERFInstanceMutex = CreateMutex( pSA, FALSE, szT ) ) )
		{
			err = GetLastError();
			goto FreeMutex;
		}

			/*  create/open the process count semaphore, but do not acquire  */

		sprintf(szT,"Proc Count:  %.246s",szPERFVersion);
		if ( !( hPERFProcCountSem = CreateSemaphore( pSA, PERF_INIT_INST_COUNT, PERF_INIT_INST_COUNT, szT ) ) )
		{
			if (GetLastError() == ERROR_ALREADY_EXISTS)
				hPERFProcCountSem = OpenSemaphore(SEMAPHORE_ALL_ACCESS,FALSE,szT);
		}
		if (!hPERFProcCountSem)
		{
			err = GetLastError();
			goto FreeMutex2;
		}

			/*  create/open the new proc mutex, but do not acquire  */

		sprintf(szT,"New Proc:  %.246s",szPERFVersion);
		if ( !( hPERFNewProcMutex = CreateMutex( pSA, FALSE, szT ) ) )
		{
			err = GetLastError();
			goto FreeSem2;
		}
	}

		/*  init succeeded   */

	dwInitCount++;

	return ERROR_SUCCESS;

FreeSem2:
	CloseHandle(hPERFProcCountSem);
	hPERFProcCountSem = NULL;
FreeMutex2:
	CloseHandle(hPERFInstanceMutex);
	hPERFInstanceMutex = NULL;
FreeMutex:
	CloseHandle(hPERFSharedDataMutex);
	hPERFSharedDataMutex = NULL;
FreeEvent:
	CloseHandle(hPERFDoneEvent);
	hPERFDoneEvent = NULL;
FreeSem:
	CloseHandle(hPERFCollectSem);
	hPERFCollectSem = NULL;
UnmapFileMap:
	UnmapViewOfFile(pvPERFSharedData);
	pvPERFSharedData = NULL;
CloseFileMap:
	CloseHandle(hPERFFileMap);
	hPERFFileMap = NULL;
CloseEventLog:
	DeregisterEventSource( hOurEventSource );
	hOurEventSource = NULL;
	return err;
}


VOID PerfUtilTerm( VOID )
{
		/*  last one out, turn out the lights!  */

	if (!dwInitCount)
		return;
	dwInitCount--;
	if (!dwInitCount)
	{
			/*  close the new process mutex  */

		CloseHandle(hPERFNewProcMutex);
		hPERFNewProcMutex = NULL;
			
			/*  close the process count semaphore  */

		CloseHandle(hPERFProcCountSem);
		hPERFProcCountSem = NULL;
		
			/*  close the instance mutex  */

		CloseHandle(hPERFInstanceMutex);
		hPERFInstanceMutex = NULL;
		
			/*  close the performance data area mutex  */

		CloseHandle(hPERFSharedDataMutex);
		hPERFSharedDataMutex = NULL;
		
			/*  free the performance data collect done event  */

		CloseHandle(hPERFDoneEvent);
		hPERFDoneEvent = NULL;

			/*  free the performance data collect semaphore  */

		CloseHandle(hPERFCollectSem);
		hPERFCollectSem = NULL;

			/*  close the performance data area file mapping  */

		UnmapViewOfFile(pvPERFSharedData);
		pvPERFSharedData = NULL;
		CloseHandle(hPERFFileMap);
		hPERFFileMap = (HANDLE)(-1);
			
			/*  close the event log  */

		if (hOurEventSource)
			DeregisterEventSource( hOurEventSource );
		hOurEventSource = NULL;
	}
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\pib.c ===
#include "daestd.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

PIB		*ppibGlobal = ppibNil;
PIB		*ppibGlobalMin = NULL;
PIB		*ppibGlobalMax = NULL;

INT cpibOpen = 0;

#ifdef DEBUG
PIB *PpibPIBOldest()
	{
	PIB		*ppibT = ppibGlobal;
	PIB		*ppibTT = ppibGlobal;
	TRX		trxT;

	trxT = trxMax;
	for ( ; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->level > 0 && trxT > ppibT->trxBegin0 )
			{
			trxT = ppibT->trxBegin0;
			ppibTT = ppibT;
			}
		}

	return ppibTT;
	}
#endif


VOID RecalcTrxOldest()
	{
	PIB		*ppibT = ppibGlobal;

	trxOldest = trxMax;
	for ( ; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->level > 0 && trxOldest > ppibT->trxBegin0 )
			{
			trxOldest = ppibT->trxBegin0;
			}
		}
	}

	
ERR ErrPIBBeginSession( PIB **pppib, PROCID procidTarget )
	{
	ERR		err;
	PIB		*ppib;

	Assert( fRecovering || procidTarget == procidNil );
	
	SgEnterCriticalSection( critPIB );

	if ( procidTarget != procidNil )
		{
		PIB *ppibTarget;
		
		/*  allocate inactive PIB according to procidTarget
		/**/
		Assert( fRecovering );
		ppibTarget = PpibOfProcid( procidTarget );
		for ( ppib = ppibGlobal; ppib != ppibTarget && ppib != ppibNil; ppib = ppib->ppibNext );
		if ( ppib != ppibNil )
			{
			/*  we found a reusable one.
			/*	Set level to hold the pib
			/**/
			Assert( ppib->level == levelNil );
			Assert( ppib->procid == ProcidPIBOfPpib( ppib ) );
			Assert( ppib->procid == procidTarget );
			Assert( FUserOpenedDatabase( ppib, dbidTemp ) );
			ppib->level = 0;
			}
		}
	else
		{
		/*	allocate inactive PIB on anchor list
		/**/
		for ( ppib = ppibGlobal; ppib != ppibNil; ppib = ppib->ppibNext )
			{
			if ( ppib->level == levelNil )
				{
				/*  we found a reusable one.
				/*	Set level to hold the pib
				/**/
				Assert( FUserOpenedDatabase( ppib, dbidTemp ) );
				ppib->level = 0;
				break;
				}
			}
		}

	/*	return success if found PIB
	/**/
	if ( ppib != ppibNil )
		{
		/*  we found a reusable one.
		/*	Do not reset non-common items.
		/**/
		Assert( ppib->level == 0 );
		Assert( ppib->pdabList == pdabNil );
		
#ifdef DEBUG
		{
		DBID    dbidT;

		for ( dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			Assert( ppib->rgcdbOpen[dbidT] == 0 );
			}
		}

		(VOID *)PpibPIBOldest();
#endif
		Assert( ppib->pfucb == pfucbNil );
		Assert( ppib->procid != procidNil );
		
		/*  set PIB procid from parameter or native for session
		/**/
		Assert( ppib->procid == ProcidPIBOfPpib( ppib ) );
		Assert( ppib->procid != procidNil );
		}
	else
		{
NewPib:
		/*  allocate PIB from free list and
		/*	set non-common items.
		/**/
		ppib = PpibMEMAlloc();
		if ( ppib == NULL )
			{
			err = ErrERRCheck( JET_errOutOfSessions );
			goto HandleError;
			}

		ppib->prceNewest = prceNil;
		cpibOpen++;
		memset( (BYTE *)ppib, 0, sizeof(PIB) );
	
		/*  link PIB into list
		/**/
		SgAssertCriticalSection( critPIB );
		ppib->ppibNext = ppibGlobal;
		Assert( ppib != ppib->ppibNext );
		ppibGlobal = ppib;

		/*  general initialization for each new pib.
		/**/
		ppib->procid = ProcidPIBOfPpib( ppib );
		Assert( ppib->procid != procidNil );
		CallS( ErrSignalCreateAutoReset( &ppib->sigWaitLogFlush, NULL ) );
		ppib->lWaitLogFlush = lWaitLogFlush;    /* set default log flush value */
		ppib->grbitsCommitDefault = 0;			/* set default commit flags in IsamBeginSession */

		/*  the temporary database is always open
		/**/
		SetOpenDatabaseFlag( ppib, dbidTemp );

		if ( procidTarget != procidNil && ppib != PpibOfProcid( procidTarget ) )
			{
			ppib->level = levelNil;

			/*  set non-zero items used by version store so that version store
			/*  will not mistaken it.
			/**/
			ppib->lgposStart = lgposMax;
			ppib->trxBegin0 = trxMax;

			goto NewPib;
			}
		}

	/*  set common PIB initialization items
	/**/

	/*  set non-zero items
	/**/
	ppib->lgposStart = lgposMax;
	ppib->trxBegin0 = trxMax;
	
	ppib->lgposPrecommit0 = lgposMax;
	
	/*  set zero items including flags and monitor fields.
	/**/

	/*	set flags
	/**/
	ppib->fLGWaiting = fFalse;
	ppib->fAfterFirstBT = fFalse;
//	Assert( !FPIBDeferFreeNodeSpace( ppib ) );

	/*  default mark this a system session
	/**/
	ppib->fUserSession = fFalse;

	ppib->levelBegin = 0;
	ppib->fAfterFirstBT = fFalse;
	ppib->levelDeferBegin = 0;
	ppib->levelRollback = 0;

	Assert( FUserOpenedDatabase( ppib, dbidTemp ) );

#ifdef DEBUG
	Assert( ppib->dwLogThreadId == 0 );
#endif

	*pppib = ppib;
	err = JET_errSuccess;

HandleError:
	SgLeaveCriticalSection( critPIB );
	return err;
	}


VOID PIBEndSession( PIB *ppib )
	{
	SgEnterCriticalSection( critPIB );

#ifdef DEBUG
	Assert( ppib->dwLogThreadId == 0 );
#endif

	/*  all session resources except version buckets should have been
	/*  released to free pools.
	/**/
	Assert( ppib->pfucb == pfucbNil );

	ppib->level = levelNil;
	ppib->lgposStart = lgposMax;

	SgLeaveCriticalSection( critPIB );
	return;
	}


ERR VTAPI ErrIsamSetWaitLogFlush( JET_SESID sesid, long lmsec )
	{
	((PIB *)sesid)->lWaitLogFlush = lmsec;
	return JET_errSuccess;
	}

ERR VTAPI ErrIsamSetCommitDefault( JET_SESID sesid, long grbits )
	{
	((PIB *)sesid)->grbitsCommitDefault = grbits;
	return JET_errSuccess;
	}

extern long cBTSplits;

ERR VTAPI ErrIsamResetCounter( JET_SESID sesid, int CounterType )
	{
	switch( CounterType )
		{
		case ctAccessPage:
			((PIB *)sesid)->cAccessPage = 0;
			break;
		case ctLatchConflict:
			((PIB *)sesid)->cLatchConflict = 0;
			break;
		case ctSplitRetry:
			((PIB *)sesid)->cSplitRetry = 0;
			break;
		case ctNeighborPageScanned:
			((PIB *)sesid)->cNeighborPageScanned = 0;
			break;
		case ctSplits:
			cBTSplits = 0;
			break;
		}
	return JET_errSuccess;			
	}

extern PM_CEF_PROC LBTSplitsCEFLPpv;

ERR VTAPI ErrIsamGetCounter( JET_SESID sesid, int CounterType, long *plValue )
	{
	switch( CounterType )
		{
		case ctAccessPage:
			*plValue = ((PIB *)sesid)->cAccessPage;
			break;
		case ctLatchConflict:
			*plValue = ((PIB *)sesid)->cLatchConflict;
			break;
		case ctSplitRetry:
			*plValue = ((PIB *)sesid)->cSplitRetry;
			break;
		case ctNeighborPageScanned:
			*plValue = ((PIB *)sesid)->cNeighborPageScanned;
			break;
		case ctSplits:
			LBTSplitsCEFLPpv( 0, (void *) plValue );
			break;
		}
	return JET_errSuccess;			
	}


/*	determine number of open user sessions
/**/
LONG CppibPIBUserSessions( VOID )
	{
	PIB		*ppibT;
	LONG	cpibActive = 0;

	for ( ppibT = ppibGlobal; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->fUserSession && FPIBActive( ppibT ) )
			{
			cpibActive++;
			}
		}

	Assert( cpibActive <= lMaxSessions );

	return cpibActive;
	}


#ifdef DEBUG
VOID PIBPurge( VOID )
	{
	PIB     *ppib;

	SgEnterCriticalSection( critPIB );

	for ( ppib = ppibGlobal; ppib != ppibNil; ppib = ppibGlobal )
		{
		PIB             *ppibCur;
		PIB             *ppibPrev;

		Assert( !ppib->fLGWaiting );
		SignalClose( ppib->sigWaitLogFlush );
		cpibOpen--;

		ppibPrev = (PIB *)((BYTE *)&ppibGlobal - offsetof(PIB, ppibNext));
		while( ( ppibCur = ppibPrev->ppibNext ) != ppib && ppibCur != ppibNil )
			{
			ppibPrev = ppibCur;
			}

		if ( ppibCur != ppibNil )
			{
			ppibPrev->ppibNext = ppibCur->ppibNext;
			Assert( ppibPrev != ppibPrev->ppibNext );
			}

		MEMReleasePpib( ppib );
		}

	SgLeaveCriticalSection( critPIB );

	return;
	}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\rec.c ===
#include "daestd.h"

DeclAssertFile; 				/* Declare file name for assert macros */

/*=================================================================
ErrIsamMove

Description:
	Retrieves the first, last, (nth) next, or (nth) previous
	record from the specified file.

Parameters:

	PIB			*ppib			PIB of user
	FUCB	 	*pfucb	  		FUCB for file
	LONG	 	crow			number of rows to move
	JET_GRBIT	grbit 			options

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamMove( PIB *ppib, FUCB *pfucb, LONG crow, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucb2ndIdx;			// FUCB for non-clustered index (if any)
	FUCB	*pfucbIdx;				// FUCB of selected index (pri or sec)
	SRID	srid;					// bookmark of record
	DIB		dib;					// Information block for DirMan

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	Assert( ( grbit & JET_bitMoveInPage ) == 0 );
	dib.fFlags = fDIRNull;

	// Get non-clustered index FUCB if any
	pfucb2ndIdx = pfucb->pfucbCurIndex;
	if ( pfucb2ndIdx == pfucbNil )
		pfucbIdx = pfucb;
	else
		pfucbIdx = pfucb2ndIdx;

	if ( crow == JET_MoveLast )
		{
		DIRResetIndexRange( pfucb );

		dib.pos = posLast;
		dib.fFlags |= fDIRPurgeParent;

		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow > 0 )
		{
		LONG crowT = crow;

		if ( ( grbit & JET_bitMoveKeyNE ) != 0 )
			dib.fFlags |= fDIRNeighborKey;

		// Move forward number of rows given
		while ( crowT-- > 0 )
			{
			err = ErrDIRNext( pfucbIdx, &dib );
			if (err < 0)
				break;
			}
		}
	else if ( crow == JET_MoveFirst )
		{
		DIRResetIndexRange( pfucb );

		dib.pos = posFirst;
		dib.fFlags |= fDIRPurgeParent;

		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow == 0 )
		{
		err = ErrDIRGet( pfucb );
		}
	else
		{
		LONG crowT = crow;

		if ( ( grbit & JET_bitMoveKeyNE ) != 0)
			dib.fFlags |= fDIRNeighborKey;

		while ( crowT++ < 0 )
			{
			err = ErrDIRPrev( pfucbIdx, &dib );
			if ( err < 0 )
				break;
			}
		}

	/*	if the movement was successful and a non-clustered index is
	/*	in use, then position clustered index to record.
	/**/
	if ( err == JET_errSuccess && pfucb2ndIdx != pfucbNil && crow != 0 )
		{
		Assert( pfucb2ndIdx->lineData.pb != NULL );
		Assert( pfucb2ndIdx->lineData.cb >= sizeof(SRID) );
		srid = PcsrCurrent( pfucb2ndIdx )->item;
		DIRDeferGotoBookmark( pfucb, srid );
		Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
		pfucb->sridFather = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
		Assert( FFCBClusteredIndex( pfucb->u.pfcb ) );
		Assert( PgnoOfSrid( srid ) != pgnoNull );
		}

	if ( err == JET_errSuccess )
		return err;
	if ( err == JET_errPageBoundary )
		return ErrERRCheck( JET_errNoCurrentRecord );

	if ( crow > 0 )
		{
		PcsrCurrent(pfucbIdx)->csrstat = csrstatAfterLast;
		PcsrCurrent(pfucb)->csrstat = csrstatAfterLast;
		}
	else if ( crow < 0 )
		{
		PcsrCurrent(pfucbIdx)->csrstat = csrstatBeforeFirst;
		PcsrCurrent(pfucb)->csrstat = csrstatBeforeFirst;
		}

	switch ( err )
		{
		case JET_errRecordNotFound:
			err = ErrERRCheck( JET_errNoCurrentRecord );
		case JET_errNoCurrentRecord:
		case JET_errRecordDeleted:
			break;
		default:
			PcsrCurrent( pfucbIdx )->csrstat = csrstatBeforeFirst;
			if ( pfucb2ndIdx != pfucbNil )
				PcsrCurrent( pfucb2ndIdx )->csrstat =	csrstatBeforeFirst;
		}

	return err;
	}


VOID RECDeferMoveFirst( PIB *ppib, FUCB *pfucb )
	{
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRDeferMoveFirst( pfucb->pfucbCurIndex );
		}
	DIRDeferMoveFirst( pfucb );
	return;
	}



/*=================================================================
ErrIsamSeek

Description:
	Retrieve the record specified by the given key or the
	one just after it (SeekGT or SeekGE) or the one just
	before it (SeekLT or SeekLE).

Parameters:

	PIB			*ppib			PIB of user
	FUCB		*pfucb 			FUCB for file
	JET_GRBIT 	grbit			grbit

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	KEY			key;			  		//	key
	KEY			*pkey = &key; 			// pointer to the input key
	FUCB 		*pfucb2ndIdx;			// pointer to index FUCB (if any)
	BOOL 		fFoundLess;
	SRID 		srid;					//	bookmark of record
	JET_GRBIT	grbitMove = 0;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( ! ( FKSPrepared( pfucb ) ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}

	/*	Reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	ignore segment counter
	/**/
	pkey->pb = pfucb->pbKey + 1;
	pkey->cb = pfucb->cbKey - 1;

	pfucb2ndIdx = pfucb->pfucbCurIndex;

	if ( pfucb2ndIdx == pfucbNil )
		{
		err = ErrDIRDownFromDATA( pfucb, pkey );
		}
	else
		{
		Assert( FFUCBNonClustered( pfucb2ndIdx ) );
		err = ErrDIRDownFromDATA( pfucb2ndIdx, pkey );

		/*	if the movement was successful and a non-clustered index is
		/*	in use, then position clustered index to record.
		/**/
		if ( err == JET_errSuccess )
			{
			Assert(pfucb2ndIdx->lineData.pb != NULL);
			Assert(pfucb2ndIdx->lineData.cb >= sizeof(SRID));
			srid = PcsrCurrent( pfucb2ndIdx )->item;
			DIRDeferGotoBookmark( pfucb, srid );
			Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
			pfucb->sridFather = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
			Assert( FFCBClusteredIndex( pfucb->u.pfcb ) );
			Assert( PgnoOfSrid( srid ) != pgnoNull );
			}
		}

	if ( err == JET_errSuccess && ( grbit & JET_bitSeekEQ ) != 0 )
		{
		/*	found equal on seek equal.  If index range grbit is
		/*	set then set index range upper inclusive.
		/**/
		if ( grbit & JET_bitSetIndexRange )
			{
			CallR( ErrIsamSetIndexRange( ppib, pfucb, JET_bitRangeInclusive | JET_bitRangeUpperLimit ) );
			}
		/*	reset key status
		/**/
		KSReset( pfucb );

		return err;
		}

	/*	reset key status
	/**/
	KSReset( pfucb );

	/*	remember if found less
	/**/
	fFoundLess = ( err == wrnNDFoundLess );

	if ( err == wrnNDFoundLess || err == wrnNDFoundGreater )
		{
		err = ErrERRCheck( JET_errRecordNotFound );
		}
	else if ( err < 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		if ( pfucb2ndIdx != pfucbNil )
			{
			PcsrCurrent( pfucb2ndIdx )->csrstat = csrstatBeforeFirst;
			}
		}

#define bitSeekAll (JET_bitSeekEQ | JET_bitSeekGE | JET_bitSeekGT |	\
	JET_bitSeekLE | JET_bitSeekLT)

	/*	adjust currency for seek request
	/**/
	switch ( grbit & bitSeekAll )
		{
		case JET_bitSeekEQ:
			return err;

		case JET_bitSeekGE:
			if ( err != JET_errRecordNotFound )
				return err;
			err = ErrIsamMove( ppib, pfucb, +1L, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return ErrERRCheck( JET_errRecordNotFound );
			else
				{
				// Verify key (only possible if clustered index )
				Assert( pfucb2ndIdx != pfucbNil  ||
					CmpStKey( StNDKey( pfucb->ssib.line.pb ), pkey ) >= 0 );
				return ErrERRCheck( JET_wrnSeekNotEqual );
				}

		case JET_bitSeekGT:
			if ( err < 0 && err != JET_errRecordNotFound )
				return err;
			if ( err >= 0 || fFoundLess )
				grbitMove |= JET_bitMoveKeyNE;
			err = ErrIsamMove( ppib, pfucb, +1L, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return ErrERRCheck( JET_errRecordNotFound );
			else
				return err;

		case JET_bitSeekLE:
			if ( err != JET_errRecordNotFound )
			    return err;
			err = ErrIsamMove( ppib, pfucb, JET_MovePrevious, grbitMove );
			if ( err == JET_errNoCurrentRecord )
			    return ErrERRCheck( JET_errRecordNotFound );
			else
				{
				Assert( pfucb2ndIdx != pfucbNil  ||
					CmpStKey( StNDKey( pfucb->ssib.line.pb ), pkey ) < 0 );
			    return ErrERRCheck( JET_wrnSeekNotEqual );
				}

		case JET_bitSeekLT:
			if ( err < 0 && err != JET_errRecordNotFound )
				return err;
			if ( err >= 0 || !fFoundLess )
				grbitMove |= JET_bitMoveKeyNE;
			err = ErrIsamMove( ppib, pfucb, JET_MovePrevious, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return ErrERRCheck( JET_errRecordNotFound );
			else
				return err;
		}
    Assert(FALSE);
    return 0;
	}


ERR VTAPI ErrIsamGotoBookmark( PIB *ppib, FUCB *pfucb, BYTE *pbBookmark, ULONG cbBookmark )
	{
	ERR		err;
	LINE 	key;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	CheckNonClustered( pfucb );

	if ( cbBookmark != sizeof(SRID) )
		return ErrERRCheck( JET_errInvalidBookmark );
	Assert( cbBookmark == sizeof(SRID) );

	/*	reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	get node, and return error if this node is not there for caller.
	/**/
	DIRGotoBookmark( pfucb, *(SRID UNALIGNED *)pbBookmark );
	Call( ErrDIRGet( pfucb ) );
	Assert( FFCBClusteredIndex( pfucb->u.pfcb ) );
	Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
	pfucb->sridFather = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
	
	/*	bookmark must be for node in table cursor is on
	/**/
	Assert( PgnoPMPgnoFDPOfPage( pfucb->ssib.pbf->ppage ) == pfucb->u.pfcb->pgnoFDP );

	/*	goto bookmark record build key for non-clustered index
	/*	to bookmark record
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		/*	get non-clustered index cursor
		/**/
		FUCB	*pfucbIdx = pfucb->pfucbCurIndex;
		
		/*	allocate goto bookmark resources
		/**/
		if ( pfucb->pbKey == NULL )
			{
			pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost + 1 );
			if ( pfucb->pbKey == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			}

		/*	make key for record for non-clustered index
		/**/
		key.pb = pfucb->pbKey;
		Call( ErrRECRetrieveKeyFromRecord( pfucb, (FDB *)pfucb->u.pfcb->pfdb,
			pfucbIdx->u.pfcb->pidb, &key, 1, fFalse ) );
		Assert( err != wrnFLDOutOfKeys );

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !( pfucbIdx->u.pfcb->pidb->fidb & fidbNoNullSeg ) ||
			( err != wrnFLDNullSeg && err != wrnFLDNullFirstSeg && err != wrnFLDNullKey ) );

		/*	if item is not index, then move before first instead of seeking
		/**/
		Assert( err > 0 || err == JET_errSuccess );
		if ( ( err > 0 ) &&
			( err == wrnFLDNullKey && !( pfucbIdx->u.pfcb->pidb->fidb & fidbAllowAllNulls ) ) ||
			( err == wrnFLDNullFirstSeg && !( pfucbIdx->u.pfcb->pidb->fidb & fidbAllowFirstNull ) ) ||
			( err == wrnFLDNullSeg && !( pfucbIdx->u.pfcb->pidb->fidb & fidbAllowSomeNulls ) ) )
			{
			Assert( err > 0 );
			/*	assumes that NULLs sort low
			/**/
			DIRBeforeFirst( pfucbIdx );
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}
		else
			{
			Assert( err >= 0 );

			/*	move to DATA root
			/**/
			DIRGotoDataRoot( pfucbIdx );

			/*	seek on non-clustered key
			/**/
			Call( ErrDIRDownKeyBookmark( pfucbIdx, &key, *(SRID UNALIGNED *)pbBookmark ) );
			Assert( err == JET_errSuccess );

			/*	item must be same as bookmark and
			/*	clustered cursor must be on record.
			/**/
			Assert( pfucbIdx->lineData.pb != NULL );
			Assert( pfucbIdx->lineData.cb >= sizeof(SRID) );
			Assert( PcsrCurrent( pfucbIdx )->csrstat == csrstatOnCurNode );
			Assert( PcsrCurrent( pfucbIdx )->item == *(SRID UNALIGNED *)pbBookmark );
			}
		}

	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );

HandleError:
	KSReset( pfucb );
	return err;
	}


ERR VTAPI ErrIsamGotoPosition( PIB *ppib, FUCB *pfucb, JET_RECPOS *precpos )
	{
	ERR		err;
	FUCB 	*pfucb2ndIdx;
	SRID  	srid;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/*	Reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	reset key stat
	/**/
	KSReset( pfucb );

	/*	set non clustered index pointer, may be null
	/**/
	pfucb2ndIdx = pfucb->pfucbCurIndex;

	if ( pfucb2ndIdx == pfucbNil )
		{
		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucb );

		err = ErrDIRGotoPosition( pfucb, precpos->centriesLT, precpos->centriesTotal );
		}
	else
		{
		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucb2ndIdx );

		err = ErrDIRGotoPosition( pfucb2ndIdx, precpos->centriesLT, precpos->centriesTotal );

		/*	if the movement was successful and a non-clustered index is
		/*	in use, then position clustered index to record.
		/**/
		if ( err == JET_errSuccess )
			{
			Assert( pfucb2ndIdx->lineData.pb != NULL );
			Assert( pfucb2ndIdx->lineData.cb >= sizeof(SRID) );
			srid = PcsrCurrent( pfucb2ndIdx )->item;
			DIRDeferGotoBookmark( pfucb, srid );
			Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
			pfucb->sridFather = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
			Assert( FFCBClusteredIndex( pfucb->u.pfcb ) );
			Assert( PgnoOfSrid( srid ) != pgnoNull );
			}
		}

	/*	if no records then return JET_errRecordNotFound
	/*	otherwise return error from called routine
	/**/
	if ( err < 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;

		if ( pfucb2ndIdx != pfucbNil )
			{
			PcsrCurrent( pfucb2ndIdx )->csrstat = csrstatBeforeFirst;
			}
		}
	else
		{
		Assert (err==JET_errSuccess || err==wrnNDFoundLess || err==wrnNDFoundGreater );
		err = JET_errSuccess;
		}

	return err;
	}


ERR VTAPI ErrIsamSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbIdx;

	/*	ppib is not used in this function
	/**/
	NotUsed( ppib );

	/*	if instant duration index range, then reset index range.
	/**/
	if ( grbit & JET_bitRangeRemove )
		{
		if ( FFUCBLimstat( pfucb->pfucbCurIndex ? pfucb->pfucbCurIndex : pfucb ) )
			{
			DIRResetIndexRange( pfucb );
			Assert( err == JET_errSuccess );
			goto HandleError;
			}
		else
			{
			Error( JET_errInvalidOperation, HandleError );
			}
		}

	/*	must be on index
	/**/
	if ( pfucb->u.pfcb->pidb == pidbNil && pfucb->pfucbCurIndex == pfucbNil )
		{
		Error( JET_errNoCurrentIndex, HandleError );
		}

	/*	key must be prepared
	/**/
	if ( !( FKSPrepared( pfucb ) ) )
		{
		Error( JET_errKeyNotMade, HandleError );
		}

	/*	get cursor for current index.  If non-clustered index,
	/*	then copy index range key to non-clustered index.
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		if ( pfucbIdx->pbKey == NULL )
			{
			pfucbIdx->pbKey = LAlloc( 1L, JET_cbKeyMost + 1 );
			if ( pfucbIdx->pbKey == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			}
		pfucbIdx->cbKey = pfucb->cbKey;
		memcpy( pfucbIdx->pbKey, pfucb->pbKey, pfucbIdx->cbKey );
		}
	else
		{
		pfucbIdx = pfucb;
		}

	/*	set index range and check current position
	/**/
	DIRSetIndexRange( pfucbIdx, grbit );
	err = ErrDIRCheckIndexRange( pfucbIdx );

	/*	reset key status
	/**/
	KSReset( pfucb );

	/*	if instant duration index range, then reset index range.
	/**/
	if ( grbit & JET_bitRangeInstantDuration )
		{
		DIRResetIndexRange( pfucb );
		}

HandleError:
	return err;
	}


ERR VTAPI ErrIsamSetCurrentIndex( PIB *ppib, FUCB *pfucb, const CHAR *szName )
	{
	return ErrIsamSetCurrentIndex2( (JET_VSESID)ppib, (JET_VTID)pfucb, szName, JET_bitMoveFirst );
	}


ERR VTAPI ErrIsamSetCurrentIndex2( JET_VSESID vsesid, JET_VTID vtid, const CHAR *szName, JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib = (PIB *)vsesid;
	FUCB	*pfucb = (FUCB *)vtid;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	SRID	srid;
	BOOL	fSetGetBookmark = fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );
	Assert(	grbit == 0 ||
		grbit == JET_bitNoMove ||
		grbit == JET_bitMoveFirst ||
		grbit == JET_bitMoveBeforeFirst );

	/*	index name may be Null string for no index
	/**/
	if ( szName == NULL || *szName == '\0' )
		{
		*szIndex = '\0';
		}
	else
		{
		Call( ErrUTILCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );
		}

	switch ( grbit )
		{
		case JET_bitMoveFirst:
			{
			/*	change index and defer move first
			/**/
			Call( ErrRECSetCurrentIndex( pfucb, szIndex ) );
		
			if ( pfucb->pfucbCurIndex )
				{
				DIRDeferMoveFirst( pfucb->pfucbCurIndex );
				}
			DIRDeferMoveFirst( pfucb );

			break;
			}
		case JET_bitNoMove:
			{
			/*	get bookmark of current record, change index,
			/*	and goto bookmark.
			/**/
			if ( !FFUCBGetBookmark( pfucb ) )
				{
				fSetGetBookmark = fTrue;
				FUCBSetGetBookmark( pfucb );
				}
			Call( ErrDIRGetBookmark( pfucb, &srid ) );
			Call( ErrRECSetCurrentIndex( pfucb, szIndex ) );
			//	UNDONE:	error handling.  We should not have changed
			//	currency or current index, if set current index
			//	fails for any reason.  Note that this functionality
			//	could be provided by duplicating the cursor, on
			//	the clustered index, setting the current index to the
			//	new index, getting the bookmark from the original
			//	cursor, goto bookmark on the duplicate cursor,
			//	instating the duplicate cursor for the table id of
			//	the original cursor, and closing the original cursor.
			Call( ErrIsamGotoBookmark( pfucb->ppib, pfucb, (BYTE *)&srid, sizeof(srid) ) );
			break;
			}
		default:
			{
			Assert( grbit == JET_bitMoveBeforeFirst );

			/*	change index and defer move first
			/**/
			Call( ErrRECSetCurrentIndex( pfucb, szIndex ) );

			/*	ErrRECSetCurrentIndex should leave cursor before first
			/**/
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
			Assert( pfucb->pfucbCurIndex == pfucbNil ||
				PcsrCurrent( pfucb->pfucbCurIndex )->csrstat == csrstatBeforeFirst );

			break;
			}
		}
	
HandleError:
	if ( fSetGetBookmark )
		{
		FUCBResetGetBookmark( pfucb );
		}
	return err;
	}


ERR ErrRECSetCurrentIndex( FUCB *pfucb, CHAR *szIndex )
	{
	ERR		err;
	FCB		*pfcbFile;
	FCB		*pfcb2ndIdx;
	FUCB	**ppfucbCurIdx;
	BOOL	fSettingToClusteredIndex = fFalse;

	Assert( pfucb != pfucbNil );
	Assert( FFUCBIndex( pfucb ) );

	pfcbFile = pfucb->u.pfcb;
	Assert( pfcbFile != pfcbNil );
	ppfucbCurIdx = &pfucb->pfucbCurIndex;

	/*	szIndex == clustered index or NULL
	/**/
	if ( szIndex == NULL ||
		*szIndex == '\0' ||
		( pfcbFile->pidb != pidbNil &&
		UtilCmpName( szIndex, pfcbFile->pidb->szName ) == 0 ) )
		{
		fSettingToClusteredIndex = fTrue;
		}

	/*	have a current non-clustered index
	/**/
	if ( *ppfucbCurIdx != pfucbNil )
		{
		Assert( FFUCBIndex( *ppfucbCurIdx ) );
		Assert( (*ppfucbCurIdx)->u.pfcb != pfcbNil );
		Assert( (*ppfucbCurIdx)->u.pfcb->pidb != pidbNil );
		Assert( (*ppfucbCurIdx)->u.pfcb->pidb->szName != NULL );

		/*	changing to the current non-clustered index
		/**/
		if ( szIndex != NULL &&
			*szIndex != '\0' &&
			UtilCmpName( szIndex, (*ppfucbCurIdx)->u.pfcb->pidb->szName ) == 0 )
			{
			//	UNDONE:	this case should honor grbit move expectations
			return JET_errSuccess;
			}

		/*	really changing index, so close old one
		/**/
		DIRClose( *ppfucbCurIdx );
		*ppfucbCurIdx = pfucbNil;
		}
	else
		{
		/*	using clustered index or sequential scanning
		/**/
		if ( fSettingToClusteredIndex )
			{
			//	UNDONE:	this case should honor grbit move expectations
			return JET_errSuccess;
			}
		}

	/*	at this point there is no current non-clustered index
	/**/
	if ( fSettingToClusteredIndex )
		{
		/*	changing to clustered index.  Reset currency to beginning.
		/**/
		ppfucbCurIdx = &pfucb;
		goto ResetCurrency;
		}

	/*	set new current non-clustered index
	/**/
	for ( pfcb2ndIdx = pfcbFile->pfcbNextIndex;
		pfcb2ndIdx != pfcbNil;
		pfcb2ndIdx = pfcb2ndIdx->pfcbNextIndex )
		{
		Assert( pfcb2ndIdx->pidb != pidbNil );
		Assert( pfcb2ndIdx->pidb->szName != NULL );

		if ( UtilCmpName( pfcb2ndIdx->pidb->szName, szIndex ) == 0 )
			break;
		}
	if ( pfcb2ndIdx == pfcbNil || FFCBDeletePending( pfcb2ndIdx ) )
		{
		return ErrERRCheck( JET_errIndexNotFound );
		}
	Assert( !( FFCBDomainDenyRead( pfcb2ndIdx, pfucb->ppib ) ) );

	/*	open an FUCB for the new index
	/**/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->dbid == pfcb2ndIdx->dbid );
	CallR( ErrDIROpen( pfucb->ppib, pfcb2ndIdx, 0, ppfucbCurIdx ) );
	
	FUCBSetIndex( *ppfucbCurIdx );
	FUCBSetNonClustered( *ppfucbCurIdx );

	/*	reset the index and file currency
	/**/
ResetCurrency:
	Assert( PcsrCurrent(*ppfucbCurIdx) != pcsrNil );
	DIRBeforeFirst( *ppfucbCurIdx );
	if ( pfucb != *ppfucbCurIdx )
		{
		DIRBeforeFirst( pfucb );
		}

	return JET_errSuccess;
	}


BOOL FRECIIllegalNulls( FDB *pfdb, LINE *plineRec )
	{
	FIELD *pfield;
	LINE lineField;
	FID fid;
	ERR err;

	/*** Check fixed fields ***/
	pfield = PfieldFDBFixed( pfdb );
	for (fid = fidFixedLeast; fid <= pfdb->fidFixedLast; fid++, pfield++)
		{
		Assert( pfield == PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast ) );
		if ( pfield->coltyp == JET_coltypNil || !( FFIELDNotNull( pfield->ffield ) ) )
			continue;
		err = ErrRECIRetrieveColumn( pfdb, plineRec, &fid, pNil, 1, &lineField, 0 );
		Assert(err >= 0);
		if ( err == JET_wrnColumnNull )
			return fTrue;
		}

	/*** Check variable fields ***/
	Assert( pfield == PfieldFDBVar( pfdb ) );
	for (fid = fidVarLeast; fid <= pfdb->fidVarLast; fid++, pfield++)
		{
		Assert( pfield == PfieldFDBVar( pfdb ) + ( fid - fidVarLeast ) );
		if (pfield->coltyp == JET_coltypNil || !( FFIELDNotNull( pfield->ffield ) ) )
			continue;
		err = ErrRECIRetrieveColumn( pfdb, plineRec, &fid, pNil, 1, &lineField, 0 );
		Assert(err >= 0);
		if ( err == JET_wrnColumnNull )
			return fTrue;
		}

	return fFalse;
	}


ERR VTAPI ErrIsamGetCurrentIndex( PIB *ppib, FUCB *pfucb, CHAR *szCurIdx, ULONG cbMax )
	{
	ERR		err = JET_errSuccess;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( cbMax < 1 )
		{
		return JET_wrnBufferTruncated;
		}

	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( pfucb->pfucbCurIndex->u.pfcb != pfcbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->pidb != pidbNil );
		strcpy( szIndex, pfucb->pfucbCurIndex->u.pfcb->pidb->szName );
		}
	else if ( pfucb->u.pfcb->pidb != pidbNil )
		{
		strcpy( szIndex, pfucb->u.pfcb->pidb->szName );
		}
	else
		{
		szIndex[0] = '\0';
		}

	if ( cbMax > JET_cbNameMost + 1 )
		cbMax = JET_cbNameMost + 1;
	strncpy( szCurIdx, szIndex, (USHORT)cbMax - 1 );
	szCurIdx[ cbMax - 1 ] = '\0';
	Assert( err == JET_errSuccess );
	return err;
	}


ERR VTAPI ErrIsamGetChecksum( PIB *ppib, FUCB *pfucb, ULONG *pulChecksum )
	{
	ERR   	err = JET_errSuccess;

	CallR( ErrPIBCheck( ppib ) );
 	CheckFUCB( ppib, pfucb );
	CallR( ErrDIRGet( pfucb ) );
	*pulChecksum = UlChecksum( pfucb->lineData.pb, pfucb->lineData.cb );
	return err;
	}


ULONG UlChecksum( BYTE *pb, ULONG cb )
	{
	//	UNDONE:	find a way to compute check sum in longs independant
	//				of pb, byte offset in page

	/*	compute checksum by adding bytes in data record and shifting
	/*	result 1 bit to left after each operation.
	/**/
	BYTE   	*pbT = pb;
	BYTE  	*pbMax = pb + cb;
	ULONG  	ulChecksum = 0;

	/*	compute checksum
	/**/
	for ( ; pbT < pbMax; pbT++ )
		{
		ulChecksum += *pbT;
		ulChecksum <<= 1;
		}

	return ulChecksum;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\regenv.c ===
#include "regenv.h"

/*  registry environment settings ( registry value text )
/**/
TCHAR *rglpszParm[] =
	{
	_TEXT( "TempPath" ),
	_TEXT( "MaxBuffers" ),
	_TEXT( "MaxSessions" ),
	_TEXT( "MaxOpenTables" ),
	_TEXT( "MaxVerPages" ),
	_TEXT( "MaxCursors" ),
	_TEXT( "LogFilePath" ),
	_TEXT( "MaxOpenTableIndexes" ),
	_TEXT( "MaxTemporaryTables" ),
	_TEXT( "LogBuffers" ),
	_TEXT( "LogFileSize" ),
	_TEXT( "BfThrshldLowPrcnt" ),
	_TEXT( "BfThrshldHighPrcnt" ),
	_TEXT( "WaitLogFlush" ),
	_TEXT( "LogCheckpointPeriod" ),
	_TEXT( "LogWaitingUserMax" ),
	_TEXT( "PageFragment" ),
	_TEXT( "MaxOpenDatabases" ),
	_TEXT( "OnLineCompact" ),
	_TEXT( "BufBatchIOMax" ),
	_TEXT( "PageReadAheadMax" ),
	_TEXT( "AsynchIOMax" ),
	_TEXT( "EventSource" ),
	_TEXT( "DbExtensionSize" ),
	_TEXT( "CommitDefault" ),
	_TEXT( "BufLogGenAgeThreshold" ),
	_TEXT( "CircularLog" ),
	_TEXT( "PageTempDBMin" ),
	_TEXT( "BaseName" ),
	_TEXT( "BaseExtension" ),
	_TEXT( "TransactionLevel" ),
	_TEXT( "AssertAction" ),
	_TEXT( "RFS2IOsPermitted" ),
	_TEXT( "RFS2AllocsPermitted" ),
	_TEXT( "TempPath" ),
	_TEXT( "MaxBuffers" ),
	_TEXT( "MaxSessions" ),
	_TEXT( "MaxOpenTables" ),
	_TEXT( "MaxVerPages" ),
	_TEXT( "MaxCursors" ),
	_TEXT( "LogFilePath" ),
	_TEXT( "MaxOpenTableIndexes" ),
	_TEXT( "MaxTemporaryTables" ),
	_TEXT( "LogBuffers" ),
	_TEXT( "LogFileSize" ),
	_TEXT( "BfThrshldLowPrcnt" ),
	_TEXT( "BfThrshldHighPrcnt" ),
	_TEXT( "WaitLogFlush" ),
	_TEXT( "LogCheckpointPeriod" ),
	_TEXT( "LogWaitingUserMax" ),
	_TEXT( "PageFragment" ),
	_TEXT( "MaxOpenDatabases" ),
	_TEXT( "OnLineCompact" ),
	_TEXT( "BufBatchIOMax" ),
	_TEXT( "PageReadAheadMax" ),
	_TEXT( "AsynchIOMax" ),
	_TEXT( "EventSource" ),
	_TEXT( "DbExtensionSize" ),
	_TEXT( "CommitDefault" ),
	_TEXT( "BufLogGenAgeThreshold" ),
	_TEXT( "CircularLog" ),
	_TEXT( "PageTempDBMin" ),
	_TEXT( "BaseName" ),
	_TEXT( "BaseExtension" ),
	_TEXT( "TransactionLevel" ),
	_TEXT( "AssertAction" ),
	_TEXT( "RFS2IOsPermitted" ),
	_TEXT( "RFS2AllocsPermitted" ),
	NULL
	};


/*  registry environment settings ( JET_param ID's )
/**/
long rgparm[] =
	{
	JET_paramTempPath,
	JET_paramMaxBuffers,
	JET_paramMaxSessions,
	JET_paramMaxOpenTables,
	JET_paramMaxVerPages,
	JET_paramMaxCursors,
	JET_paramLogFilePath,
	JET_paramMaxOpenTableIndexes,
	JET_paramMaxTemporaryTables,
	JET_paramLogBuffers,
	JET_paramLogFileSize,
	JET_paramBfThrshldLowPrcnt,
	JET_paramBfThrshldHighPrcnt,
	JET_paramWaitLogFlush,
	JET_paramLogCheckpointPeriod,
	JET_paramLogWaitingUserMax,
	JET_paramPageFragment,
	JET_paramMaxOpenDatabases,
	JET_paramOnLineCompact,
	JET_paramBufBatchIOMax,
	JET_paramPageReadAheadMax,
	JET_paramAsynchIOMax,
	JET_paramEventSource,
	JET_paramDbExtensionSize,
	JET_paramCommitDefault,
	JET_paramBufLogGenAgeThreshold,
	JET_paramCircularLog,
	JET_paramPageTempDBMin,
	JET_paramBaseName,
	JET_paramBaseExtension,
	JET_paramTransactionLevel,
	JET_paramAssertAction,
	JET_paramRFS2IOsPermitted,
	JET_paramRFS2AllocsPermitted,
	JET_paramTempPath,
	JET_paramMaxBuffers,
	JET_paramMaxSessions,
	JET_paramMaxOpenTables,
	JET_paramMaxVerPages,
	JET_paramMaxCursors,
	JET_paramLogFilePath,
	JET_paramMaxOpenTableIndexes,
	JET_paramMaxTemporaryTables,
	JET_paramLogBuffers,
	JET_paramLogFileSize,
	JET_paramBfThrshldLowPrcnt,
	JET_paramBfThrshldHighPrcnt,
	JET_paramWaitLogFlush,
	JET_paramLogCheckpointPeriod,
	JET_paramLogWaitingUserMax,
	JET_paramPageFragment,
	JET_paramMaxOpenDatabases,
	JET_paramOnLineCompact,
	JET_paramBufBatchIOMax,
	JET_paramPageReadAheadMax,
	JET_paramAsynchIOMax,
	JET_paramEventSource,
	JET_paramDbExtensionSize,
	JET_paramCommitDefault,
	JET_paramBufLogGenAgeThreshold,
	JET_paramCircularLog,
	JET_paramPageTempDBMin,
	JET_paramBaseName,
	JET_paramBaseExtension,
	JET_paramTransactionLevel,
	JET_paramAssertAction,
	JET_paramRFS2IOsPermitted,
	JET_paramRFS2AllocsPermitted,
	-1
	};


/*  our hive name
/**/
TCHAR *lpszName = _TEXT( "SOFTWARE\\Microsoft\\" szVerName );


/*  load JET system parameters from registry under our hive
/*  in a subkey with the given application name
/**/
DWORD LoadRegistryEnvironment( TCHAR *lpszApplication )
	{
	DWORD dwErr;
	DWORD dwT;
	HKEY hkeyRoot;
	HKEY hkeyApp;
	long iparm;
	DWORD dwType;
	_TCHAR rgch[512];
	
	/*  create / open our hive
	/**/
	if ( ( dwErr = RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
									lpszName,
									0,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_ALL_ACCESS,
									NULL,
									&hkeyRoot,
									&dwT ) ) != ERROR_SUCCESS )
		{
		return dwErr;
		}

	/* create / open application subkey
	/**/
	if ( ( dwErr = RegCreateKeyEx(	hkeyRoot,
									lpszApplication,
									0,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_ALL_ACCESS,
									NULL,
									&hkeyApp,
									&dwT ) ) != ERROR_SUCCESS )
		{
		return dwErr;
		}

	/*  read all system parameters from the registry or create null entries
	/*  if they do not exist
	/**/
	for ( iparm = 0; rglpszParm[iparm]; iparm++ )
		{
		dwT = sizeof( rgch );
		if (	RegQueryValueEx(	hkeyApp,
									rglpszParm[iparm],
									0,
									&dwType,
									rgch,
									&dwT ) ||
				dwType != REG_SZ )
			{
			rgch[0] = 0;
			RegSetValueEx(	hkeyApp,
							rglpszParm[iparm],
							0,
							REG_SZ,
							rgch,
							sizeof( rgch[0] ) );
			}

		/*  we got a valid, non-NULL result, so set the system parameter
		/**/
		else if ( rgch[0] )
			{
			//  UNDONE:  how to map TCHAR to CHAR required by JetSetSystemParameter?
			JetSetSystemParameter(	NULL,
									JET_sesidNil,
									rgparm[iparm],
									_tcstoul( rgch, NULL, 0 ),
									rgch );
			}
		}

	/*  done
	/**/
	return ERROR_SUCCESS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\redut.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


/* variables used in redo only */
BYTE		*pbNext;		// redo only - location of next buffer entry
BYTE		*pbRead; 		// redo only - location of next rec to flush
INT			isecRead;		/* redo only - next disk to read. */

LGPOS		lgposRedo;
LGPOS		lgposLastRec;	/* mark for end of rec */


VOID GetLgposOfPbNext(LGPOS *plgpos)
	{
	char *pb = PbSecAligned(pbNext);
	int ib = (int)(pbNext - pb);
	int isec;

	if (pb > pbRead)
		isec = (int)(pbRead + csecLGBuf * cbSec - pb) / cbSec;
	else
		isec = (int)(pbRead - pb) / cbSec;
	isec = isecRead - isec;

	plgpos->isec = (USHORT)isec;
	plgpos->ib = (USHORT)ib;
	plgpos->lGeneration = plgfilehdrGlobal->lGeneration;
	}


#ifdef DEBUG

/* calculate the lgpos of the LR */
VOID PrintLgposReadLR ( VOID )
	{
	LGPOS lgpos;

	GetLgposOfPbNext(&lgpos);
	PrintF2("\n>%2u,%3u,%3u",
			plgfilehdrGlobal->lGeneration,
			lgpos.isec, lgpos.ib);
	}

#endif

/*  open a generation file on CURRENT directory
/**/
ERR ErrLGOpenLogGenerationFile( LONG lGeneration, HANDLE *phf )
	{
	ERR		err;
	CHAR	szFNameT[_MAX_FNAME + 1];

	LGSzFromLogId ( szFNameT, lGeneration );
	LGMakeLogName( szLogName, szFNameT );

	err = ErrUtilOpenFile ( szLogName, phf, 0L, fTrue, fFalse );
	return err;
	}


/*  open the redo point log file which must be in current directory.
/**/
ERR ErrLGOpenRedoLogFile( LGPOS *plgposRedoFrom, INT *pfStatus )
	{
	ERR		err;
	BOOL	fJetLog = fFalse;

	/*	try to open the redo from file as a normal generation log file
	/**/
	err = ErrLGOpenLogGenerationFile( plgposRedoFrom->lGeneration, &hfLog );
	if( err < 0 )
		{
		//	UNDONE:	remove this special case, and hence the next one
		/*	unable to open as a jetnnnnn.log, assume the redo point is
		/*	at the end of jetnnnnn.log and the jetnnnnn.log is moved to
		/*	backup directory already so we are able to open it.
		/*	Now try to open jetnnnn(n+1).log in current directory and
		/*	assume redo start from beginning of jetnnnn(n+1).log.
		/**/
		err = ErrLGOpenLogGenerationFile( ++plgposRedoFrom->lGeneration, &hfLog );
		if ( err < 0 )
			{
			/*	unable to open jetnnnn(n+1).log.  Redo point is in szJetLog.
			/**/
			--plgposRedoFrom->lGeneration;
			err = ErrLGOpenJetLog();
			if ( err >= 0 )
				fJetLog = fTrue;
			else
				{
				/*	szJetLog is not available either
				/**/
				*pfStatus = fNoProperLogFile;
				return JET_errSuccess;
				}
			}
		}

	/*	read the log file header to verify generation number
	/**/
	CallR( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fCheckLogID ) );

	lgposLastRec.isec = 0;
	if ( fJetLog )
		{
		LGPOS lgposFirstT;
		BOOL fCloseNormally;

		lgposFirstT.lGeneration = plgfilehdrGlobal->lGeneration;
		lgposFirstT.isec = (WORD) csecHeader;
		lgposFirstT.ib = 0;

		/* set last log rec in case of abnormal end */
		CallR( ErrLGCheckReadLastLogRecord( &fCloseNormally ) );
		if ( !fCloseNormally )
			GetLgposOfPbEntry( &lgposLastRec );
		}
		
	/*	set up a special case for pbLastMSFlush
	/**/
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

	/*	the following checks are necessary if the szJetLog is opened
	/**/
	if( plgfilehdrGlobal->lGeneration == plgposRedoFrom->lGeneration)
		{
		*pfStatus = fRedoLogFile;
		}
	else if ( plgfilehdrGlobal->lGeneration == plgposRedoFrom->lGeneration + 1 )
		{
		/*  this file starts next generation, set start position for redo
		/**/
		plgposRedoFrom->lGeneration++;
		plgposRedoFrom->isec = (WORD) csecHeader;
		plgposRedoFrom->ib	 = 0;

		*pfStatus = fRedoLogFile;
		}
	else
		{
		/*	log generation gap is found.  Current szJetLog can not be
		/*  continuation of backed up logfile.  Close current logfile
		/*	and return error flag.
		/**/
		CallS( ErrUtilCloseFile ( hfLog ) );
		hfLog = handleNil;

		*pfStatus = fNoProperLogFile;
		}

	return JET_errSuccess;
	}


/*	set pbEntry to the end of last log record.
 *	Set lgposLastRec if not close normally
 */
VOID LGSearchLastSector( LR *plr, BOOL *pfCloseNormally )
	{
	BOOL	fQuitWasRead = fFalse;
	
	/*	continue search after MS
	/**/
	Assert( plr->lrtyp == lrtypMS );

	/*	set pbEntry and *pfCloseNormally by traversing log records
	/**/

	forever
		{
		if ( plr->lrtyp == lrtypEnd )
			{
			if ( fQuitWasRead )
				{
				/*	a fQuit followed by Fill. Close normally last time
				/**/
				*pfCloseNormally = fTrue;
				}
			else
				{
				/*	we are reading a sector that is last flushed
				/**/
				*pfCloseNormally = fFalse;
				}

			/*	return the plr pointing at the Fill record
			/**/
			pbEntry = (CHAR *)plr;
			goto SetReturn;
			}
		else
			{
			/*	not an end record
			/**/
			if ( plr->lrtyp == lrtypTerm )
				{
				/*	check if it is last lrtypTerm in the log file. Advance
				/*	one more log rec and check if it is followed by
				/*	end record.
				/**/
				fQuitWasRead = fTrue;
				}
			else if ( plr->lrtyp != lrtypMS && plr->lrtyp != lrtypNOP )
				{
				/*	if reading non-skippable log record, then reset it.
				 */
				fQuitWasRead = fFalse;
				}
			}

		/*	move to next log record
		/**/
		pbEntry = (CHAR *)plr;
		plr = (LR *)( pbEntry + CbLGSizeOfRec( (LR *)pbEntry ) );

		if	( PbSecAligned( pbEntry ) != PbSecAligned( (BYTE *) plr ) )
			{
			*pfCloseNormally = fFalse;
			goto SetReturn;
			}
		}

SetReturn:
	if ( *pfCloseNormally )
		lgposLastRec.isec = 0;
	else
		{
		Assert( lgposLastMSFlush.lGeneration );
		Assert( lgposLastMSFlush.ib == pbLastMSFlush - PbSecAligned( pbLastMSFlush ) );
		lgposLastRec = lgposLastMSFlush;
		lgposLastRec.ib = (USHORT)(pbEntry - PbSecAligned(pbEntry));
		}

	return;
	}


/*
 *  Locate the real last log record entry in a given opened log file (hf) and
 *  the last recorded entry.
 *
 *  Note if a mutli-sec flush is done, then several small transactions
 *  were following it and stay on the same page, they were written with
 *  End at the end. Then another multi-sec flush is issued again, since
 *  we overwrite the Fill record, we have no idea where the last single
 *  sec flush is done. We simply keep reading till the last log record with
 *  entry in the candidate page is met and make it is the last record.
 *
 *  Rollback will undo the bogus log records between last effective single
 *  sec flush and the last record of the candidate sector.
 *
 *  Implicit Output parameter:
 *		INT   isecWrite
 *		CHAR  *pbEntry
 */
ERR ErrLGCheckReadLastLogRecord( BOOL *pfCloseNormally )
	{
	ERR		err;
	LGPOS	lgposScan;
	LRMS	lrms;
	INT		csecToRead;
	LR		*plr;
	BOOL	fAbruptEnd;
	BYTE	*pbNext;
	BYTE	*pbNextMS;

	*pfCloseNormally = fFalse;

	/*	read the first record which must be an MS.
	/**/
	CallR( ErrLGRead( hfLog, csecHeader, pbLGBufMin, 1 ) );
	csecToRead = 0;

	pbNext = pbLGBufMin;
	if ( *pbNext != lrtypMS )
		{
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
						 LOG_FILE_CORRUPTED_ID, 1, (const char **)&szLogName );
		return ErrERRCheck( JET_errLogFileCorrupt );
		}

	/* set for reading the MS chain */
	lgposScan.lGeneration = plgfilehdrGlobal->lGeneration;
	lgposScan.isec = (WORD) csecHeader;
	lgposScan.ib = (USHORT)(pbNext - pbLGBufMin);

	/*	now try to read the chain of lrms to the end
	/**/
	fAbruptEnd = fFalse;
	lgposLastMSFlush = lgposScan;
	Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
	pbLastMSFlush = pbNext;
	pbNextMS = pbNext;
	lrms = *(LRMS *)pbNextMS;

	while ( lrms.isecForwardLink != 0 )
		{
		LRMS lrmsNextMS;

		csecToRead = lrms.isecForwardLink - lgposScan.isec;

		if ( csecToRead + 1 > csecLGBuf )
			{
			BYTE *pbT = pbLGBufMin;

			/*	reallocate log buffers
			/**/
			pbLGBufMin = NULL;
			CallR( ErrLGInitLogBuffers( csecToRead + 1 ) );
			memcpy( pbLGBufMin, pbT, cbSec );
			pbLastMSFlush = pbLGBufMin + ( pbLastMSFlush - pbT );
			UtilFree( pbT );
			}

		if ( ErrLGRead(	hfLog, lgposScan.isec + 1, pbLGBufMin + cbSec, csecToRead ) < 0 )
			{
			/*	even when the read is fail, at least one sector
			/*	is read since the first sector was OK.
			/**/
			fAbruptEnd = fTrue;
			break;
			}

		/*	prepare to read next MS
		/**/
		pbNextMS = pbLGBufMin + csecToRead * cbSec + lrms.ibForwardLink;
		lrmsNextMS = *(LRMS *) pbNextMS;

		if ( *pbNextMS != lrtypMS
			||
			 lrmsNextMS.ulCheckSum != UlLGMSCheckSum( pbNextMS )
		   )
			{
			fAbruptEnd = fTrue;
			break;
			}

		if ( lrmsNextMS.isecForwardLink == 0 )
			{
			/* we have last 2 MS in buffer. */
			break;
			}
		
		/*	shift the last sector to the beginning of LGBuf
		/**/
		memmove( pbLGBufMin, pbLGBufMin + ( csecToRead * cbSec ), cbSec );

		lgposScan.isec = lrms.isecForwardLink;
		lgposScan.ib = lrms.ibForwardLink;

		lgposLastMSFlush = lgposScan;
		Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
		pbLastMSFlush = pbLGBufMin + lrms.ibForwardLink;

		lrms = lrmsNextMS;
		}

	if ( fAbruptEnd )
		{
		LRMS *plrms = (LRMS *)pbLastMSFlush;

		plrms->isecForwardLink = 0;
		plrms->ibForwardLink = 0;

		/* restore lgposScan to last MS
		 */
		lgposScan = lgposLastMSFlush;
		
		/*	set return values for both global and parameters
		/**/
		pbWrite = pbLGBufMin;
		isecWrite = lgposScan.isec;
		
		/*  we read to the end of last MS, looking for end log record
		/**/
		pbEntry = pbWrite + lgposScan.ib;
		plr = (LR *)pbEntry;
		}
	else if ( ((LRMS *)pbLastMSFlush)->isecForwardLink )
		{
		/* we read last 2 MS in */
		BOOL fQuitWasRead;
		BYTE *pbCur = (BYTE *) pbLastMSFlush;
		LRMS *plrms = (LRMS *) pbLastMSFlush;
			
		/*	set return values for both global and parameters
		/**/
		pbWrite = pbLGBufMin + cbSec * ( plrms->isecForwardLink - lgposLastMSFlush.isec );
		isecWrite = plrms->isecForwardLink;

		lgposLastMSFlush.lGeneration = plgfilehdrGlobal->lGeneration;
		lgposLastMSFlush.isec = lrms.isecForwardLink;
		lgposLastMSFlush.ib = lrms.ibForwardLink;
		pbLastMSFlush = pbWrite + lrms.ibForwardLink;

		/*  we read to the end of last MS, looking for end log record.
		 *	In order to decide if the quit is read, which may sit between
		 *	the 2 MS. So we have to search from the first MS.
		 **/
		fQuitWasRead = fFalse;
		for (;;)
			{
			pbCur = pbCur + CbLGSizeOfRec( (LR *)pbCur );
			if ( *pbCur == lrtypMS )
				{
				/* reach last MS */
				break;
				}
			else if ( *pbCur == lrtypTerm )
				{
				/*	quit is read, check if next one is MS
				 */
				fQuitWasRead = fTrue;
				}
			else
				fQuitWasRead = fFalse;
			}
		if ( *pbCur == lrtypMS && fQuitWasRead )
			{
			BYTE *pbT = pbCur + CbLGSizeOfRec( (LR *) pbCur );
			if ( *pbT == lrtypEnd )
				{
				/*	we get -- lrtypQuit + lrtypMS + lrtypEnd
				 */
				*pfCloseNormally = fTrue;
				pbEntry = pbT;
				return JET_errSuccess;
				}
			}

		/*	still not found. Search after last MS.
		 */
		pbEntry = pbLastMSFlush;
		plr = (LR *)pbEntry;
		}
	else
		{
		/* the first MS read has isecForwardLink == 0 */
		/*	set return values for both global and parameters
		/**/
		pbWrite = pbLGBufMin;
		isecWrite = lgposScan.isec;
		
		/*  the first MS is also the last MS, looking for end log record
		/**/
		pbEntry = pbWrite + lgposScan.ib;
		plr = (LR *)pbEntry;
		}

	LGSearchLastSector( plr, pfCloseNormally );
		
	return err;
	}


/*
 *	Database log based recovery initialization, creates first log
 *	generation file on first run.  On subseqent runs
 *	checks active log file to determine if failure has occurred.
 *	ErrLGRedo is called when failures detected to repair databases.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */

STATIC ERR ErrReadMS( LR *plr, LGPOS *plgposLR )
	{
	ERR		err;
	LRMS	*plrms = (LRMS *)plr;
	/*	redo only - on last sector of cur lg file
	/**/
	BOOL	fOnLastSec;

#ifdef DEBUG
	/*	same as TraceRedo() in redo.c
	/**/
	if ( fDBGTraceRedo )
		{
		extern INT cNOP;

		if ( cNOP >= 1 && plr->lrtyp != lrtypNOP )
			{
			FPrintF2( " * %d", cNOP );
			cNOP = 0;
			}

		if ( cNOP == 0 || plr->lrtyp != lrtypNOP )
			{
			PrintLgposReadLR();
			ShowLR( plr );
			}
		}
#endif

	/*  check if this MS was done completely by reading
	 *  the whole sector in. If it fails, then the sector
	 *  is the last sector available in the log file.
	 */
	fOnLastSec = plrms->isecForwardLink == 0;

	/*  The MS were read in successfully, reset LastMSFlush
	 *  so that when switching from read mode to write mode,
	 *  we will have a correct LastMSFlush pointers.
	 */
	pbLastMSFlush = (CHAR *)plrms;
	lgposLastMSFlush = *plgposLR;
	Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );

	if ( !fOnLastSec )
		{
		if ( isecRead <= plrms->isecForwardLink )
			{
			CHAR	*pb;
			INT		cb;
			INT		csecToRead = plrms->isecForwardLink - isecRead + 1;

			Assert( csecToRead > 0 );
				
			pb = PbSecAligned(pbNext);
			cb = (INT)(pbRead - pb);
			if ( csecToRead + isecRead > csecLGBuf )
				{
				/* the multiple sector will not fit in rest of */
				/* the available buffer. Shift the buffer. */
				memmove( pbLGBufMin, pb, cb );
					
				pbRead = pbLGBufMin + cb;				/* pbRead */
				pbNext = pbNext - pb + pbLGBufMin;		/* pbNext */
				pbLastMSFlush = (CHAR *) plrms - pb + pbLGBufMin;
				}

			/*	bring in multiple sectors
			/**/
			if ( pbRead + csecToRead * cbSec > pbLGBufMax )
				{
				BYTE *pbLGBufMinT = pbLGBufMin;
				pbLGBufMin = NULL;
				CallR( ErrLGInitLogBuffers( lLogBuffers ) );
				memcpy( pbLGBufMin, pbLGBufMinT, cb );
					
				pbRead = pbRead - pbLGBufMinT + pbLGBufMin;
				pbNext = pbNext - pbLGBufMinT + pbLGBufMin;
				pbLastMSFlush = pbLastMSFlush - pbLGBufMinT + pbLGBufMin;
					
				UtilFree( pbLGBufMinT );
				}

			err = ErrLGRead( hfLog, isecRead, pbRead, csecToRead );
			if ( err < 0 )
				{
				fOnLastSec = fTrue;
				}
			else
				{
				/*	get pb of new lrms
				/*/
				CHAR *pbLrmsNew = pbRead + ( csecToRead - 1 ) * cbSec + ((LRMS *)pbLastMSFlush)->ibForwardLink;
				LRMS *plrmsNew = (LRMS *) pbLrmsNew;

				/*	check if the check sum is correct
				/*/
				if ( *pbLrmsNew != lrtypMS
					||
					 plrmsNew->ulCheckSum != UlLGMSCheckSum( pbLrmsNew )
				   )
					{
					fOnLastSec = fTrue;
					}
				else
					{
					isecRead += csecToRead;
					pbRead += csecToRead * cbSec;
					}
				}
			}
		}

	if	( fOnLastSec )
		{
		/*	search to set lgposLastRec
		 */
		BOOL fCloseNormally;
		LGSearchLastSector( (LR *) pbNext, &fCloseNormally );
		}
	
	/*	skip MS and continue to read next record
	/**/
	Assert( *pbNext == lrtypMS );
	pbNext += CbLGSizeOfRec( (LR *)pbNext );
	
	return JET_errSuccess;
	}


/*
 *  Read first record pointed by plgposFirst.
 *  Initialize isecRead, pbRead, and pbNext.
 *	The first redo record must be within the good portion
 *	of the log file.
 */

//  VC21:  optimizations disabled due to code-gen bug with /Ox
#pragma optimize( "agw", off )

ERR ErrLGLocateFirstRedoLogRec(
	LGPOS *plgposRedo,				/* lgpos for first redo record */
	BYTE **ppbLR)
	{
	LGPOS lgposScan;
	ERR err;
	CHAR *pbNextMS;
	BOOL fStopEarly;
	LRMS lrms;

	/*  read first sector, and scan through till we hit the redo point.
	/*	the first record which must be an MS.
	/**/
	CallR( ErrLGRead( hfLog, csecHeader, pbLGBufMin, 1 ) );

	pbNext = pbLGBufMin;
	if ( *pbNext != lrtypMS )
		return ErrERRCheck( JET_errLogFileCorrupt );

	/* set for reading the MS chain */
	lgposScan.isec = (WORD) csecHeader;
	lgposScan.ib = (USHORT)(pbNext - pbLGBufMin);

	/*	now try to read the chain of lrms to the end
	/**/
	lgposLastMSFlush = lgposScan;
	Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
	pbLastMSFlush = pbNext;
	pbNextMS = pbNext;
	lrms = *(LRMS *)pbNextMS;

	if ( lrms.isecForwardLink == 0 )
		{
		pbRead = pbLGBufMin + cbSec;
		isecRead = csecHeader + 1;
		
		/* then go to end of the following while loop */
		}
	
	fStopEarly = fFalse;
	while ( lrms.isecForwardLink != 0 )
		{
		LRMS lrmsNextMS;
		INT csecToRead;

		csecToRead = lrms.isecForwardLink - lgposScan.isec;

		if ( lrms.isecForwardLink > plgposRedo->isec ||
			 ( lrms.isecForwardLink == plgposRedo->isec &&
			   lrms.ibForwardLink > plgposRedo->ib
			 )
		   )
			fStopEarly = fTrue;

		if ( csecToRead + 1 > csecLGBuf )
			{
			BYTE *pbT = pbLGBufMin;

			/*	reallocate log buffers
			/**/
			pbLGBufMin = NULL;
			CallR( ErrLGInitLogBuffers( csecToRead + 1 ) );
			memcpy( pbLGBufMin, pbT, cbSec );
			pbLastMSFlush = pbLGBufMin + ( pbLastMSFlush - pbT );
			UtilFree( pbT );
			}

		if ( ErrLGRead(	hfLog, lgposScan.isec + 1, pbLGBufMin + cbSec, csecToRead ) < 0 )
			{
			/*	even when the read is fail, at least one sector
			/*	is read since the first sector was OK.
			/**/
			Assert( lgposScan.isec == plgposRedo->isec );
			/* fAbruptEnd = fTrue; */
			
			pbRead = pbLGBufMin + cbSec;
			isecRead = lgposScan.isec + 1;

			break;
			}

		if ( fStopEarly )
			{
			pbRead = pbLGBufMin + cbSec * ( csecToRead + 1 );
			isecRead = lgposScan.isec + 1 + csecToRead;
			Assert( pbRead >= pbLGBufMin && pbRead <= pbLGBufMax );
			break;
			}

		/*	prepare to read next MS
		/**/
		pbNextMS = pbLGBufMin + csecToRead * cbSec + lrms.ibForwardLink;
		lrmsNextMS = *(LRMS *) pbNextMS;

		if ( *pbNextMS != lrtypMS
			||
			 lrmsNextMS.ulCheckSum != UlLGMSCheckSum( pbNextMS )
		   )
			{
			/* fAbruptEnd = fTrue; */
			pbRead = pbLGBufMin;
			isecRead = lgposScan.isec + 1;

			/*	read last MS sector again. If fails, read it shadow.
			 *	reading from shadow is done in LGRead.
			 */
			err = ErrLGRead( hfLog, isecRead, pbLGBufMin, 1 );
			CallS( err );	/* for debug only. */
			CallR( err );	/* file corrupted for reasons unknown, return */
			break;
			}

		/*	shift the last sector to the beginning of LGBuf
		/**/
		memmove( pbLGBufMin, pbLGBufMin + ( csecToRead * cbSec ), cbSec );

		pbRead = pbLGBufMin + cbSec;
		isecRead = lrms.isecForwardLink + 1;

		lgposScan.isec = lrms.isecForwardLink;
		lgposScan.ib = lrms.ibForwardLink;

		lgposLastMSFlush = lgposScan;
		Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
		pbLastMSFlush = pbLGBufMin + lrms.ibForwardLink;

		lrms = lrmsNextMS;
		}

	pbNext = pbLGBufMin + ( plgposRedo->isec - lgposLastMSFlush.isec ) * cbSec + plgposRedo->ib;

	if ( *(LRTYP *)pbNext == lrtypMS)
		{
		/* set up returned value. */
		pbNext += (ULONG) CbLGSizeOfRec((LR*)pbNext);
		}
	
	/* set up returned value. */
	Assert( pbRead > pbNext );
	Assert( pbRead >= pbLGBufMin && pbRead <= pbLGBufMax );
	*ppbLR = pbNext;

	return JET_errSuccess;
	}

#pragma optimize( "", on )

/*
 *  Set pbNext to next available log record.
 */
ERR ErrLGGetNextRec( BYTE **ppbLR )
	{
	ERR		err;
	LR		*plr;
	BYTE	*pbNextOld;
	LGPOS	lgposT;
		

	/* caller should have taken care of the Fill case. */
	Assert (*(LRTYP *)pbNext != lrtypEnd);

	/* move to next log record. */
	pbNextOld = pbNext;
	pbNext += (ULONG) CbLGSizeOfRec( (LR *)pbNext );

	Assert( pbNext < pbRead );
#if 0
	/* check if next log record is out of buffer range. */
	if (pbNext == pbRead)
		return ErrERRCheck( errLGNoMoreRecords );
	
	if (pbNext > pbRead)
		{
		pbNext = pbNextOld;
		return ErrERRCheck( errLGNoMoreRecords );
		}
#endif

	plr = (LR *) pbNext;

	if ( plr->lrtyp == lrtypMS )
		{
		/*	readMS will set pbNext and lgposLastRec if not a normal end.
		 *	If it is not closed normally, then lgposLastRec will be set.
		 *	And the read record could be out of sec boundary, check the.
		 *	returned record against lgposLastRec.
		 */
		GetLgposOfPbNext(&lgposT);
		CallR( ErrReadMS( plr, &lgposT ) );
		}

	GetLgposOfPbNext(&lgposT);

	/* if lgposLastRec.isec is set, then compare it. */
	if ( lgposLastRec.isec )
		{
		INT i = CmpLgpos( &lgposT, &lgposLastRec );

		Assert( i <= 0 );
		if ( i >= 0 )
			return ErrERRCheck( errLGNoMoreRecords );
#if 0
		if ( i > 0 )
			{
			pbNext = pbNextOld;
			return ErrERRCheck( errLGNoMoreRecords );
			}
#endif
		}

	*ppbLR = pbNext;
	return JET_errSuccess;
	}


//+------------------------------------------------------------------------
//
//	CbLGSizeOfRec
//	=======================================================================
//
//	ERR CbLGSizeOfRec( plgrec )
//
//	Returns the length of a log record.
//
//	PARAMETER	plgrec	pointer to log record
//
//	RETURNS		size of log record in bytes
//
//-------------------------------------------------------------------------
typedef struct {
	int cb;
	BOOL fDebugOnly;
	} LRD;		/* log record descriptor */
	
LRD mplrtyplrd[ lrtypMax ] = {
	{	/* 	0 	NOP      */			sizeof( LRTYP ),				0	},
	{	/* 	1 	Start    */			sizeof( LRINIT ),				0	},
	{	/* 	2 	Quit     */			sizeof( LRTERMREC ),			0	},
	{	/* 	3 	MS       */			sizeof( LRMS ),					0	},
	{	/* 	4 	Fill     */			sizeof( LRTYP ),				0	},

	{	/* 	5 	Begin    */			sizeof( LRBEGIN ),				0	},
	{	/*	6 	Commit   */			sizeof( LRCOMMIT ),				0	},
	{	/*	7 	Rollback */			sizeof( LRROLLBACK ),			0	},

	{	/*	8 	CreateDB */			0,								0	},
	{	/* 	9 	AttachDB */			0,								0	},
	{	/*	10	DetachDB */			0,								0	},

	{	/*	11	InitFDP  */			sizeof( LRINITFDP ),			0	},

	{	/*	12	Split    */			0,								0	},
	{	/*	13	EmptyPage*/			sizeof( LREMPTYPAGE ),			0	},
	{	/*	14	PageMerge*/			0,								0	},

	{	/* 	15	InsertND */			0,								0	},
	{	/* 	16	InsertIL */			0,								0	},
	{	/* 	17	FDelete  */			sizeof( LRFLAGDELETE ),			0	},
	{	/* 	18	Replace  */			0,								0	},
	{	/* 	19	ReplaceD */			0,								0	},

	{	/*	20	LockBI	 */			sizeof( LRLOCKBI ),				0	},
	{	/*	21	DeferBI	 */			0,								0	},
	
	{	/*  22  UpdtHdr  */			sizeof( LRUPDATEHEADER ),		0	},
	{	/* 	23	InsertI  */			sizeof( LRINSERTITEM ),			0	},
	{	/* 	24	InsertIS */			0,								0	},
	{	/* 	25	FDeleteI */			sizeof( LRFLAGITEM ),			0	},
	{	/* 	26	FInsertI */			sizeof( LRFLAGITEM ),			0	},
	{	/*	27	DeleteI  */			sizeof( LRDELETEITEM ),			0	},
	{	/*	28	SplitItm */			sizeof( LRSPLITITEMLISTNODE ),	0	},

	{	/*	29	Delta	 */			sizeof( LRDELTA ),				0	},

	{	/*	30	DelNode  */			sizeof( LRDELETE ),				0	},
	{	/*	31	ELC      */			sizeof( LRELC ),				0	},

	{	/*	32	FreeSpace*/			sizeof( LRFREESPACE ),			0	},
	{	/*	33	Undo     */			sizeof( LRUNDO ),				0	},

	{	/* 	34 	Precommit*/			sizeof( LRPRECOMMIT ),			0	},
	{	/* 	35 	Begin0   */			sizeof( LRBEGIN0 ),				0	},
	{	/*	36 	Commit0  */			sizeof( LRCOMMIT0 ),			0	},
	{	/*	37	Refresh	 */			sizeof( LRREFRESH ),			0	},
		
	{	/*  38  RcvrUndo */			0,								0	},
	{	/*  39  RcvrQuit */			sizeof( LRTERMREC ),			0	},
	{	/*  40  FullBkUp */			0,								0	},
	{	/*  41  IncBkUp  */			0,								0	},

	{	/*  42  CheckPage*/			sizeof( LRCHECKPAGE ),			1	},
	{	/*  43  JetOp    */			sizeof( LRJETOP ),				1	},
	{	/*	44 	Trace    */			0,								1	},
		
	{	/* 	45 	ShutDown */			sizeof( LRSHUTDOWNMARK ),		0	},
		
	{	/* 	46 	McrBegin */			sizeof( LRMACROBEGIN ),			0	},
	{	/* 	47 	McrCmmt  */			sizeof( LRMACROEND ),			0	},
	{	/* 	48 	McrAbort */			sizeof( LRMACROEND ),			0	},
	};


#ifdef DEBUG
BOOL FLGDebugLogRec( LR *plr )
	{
	return mplrtyplrd[plr->lrtyp].fDebugOnly;
	}
#endif


INT CbLGSizeOfRec( LR *plr )
	{
	INT		cb;

	Assert( plr->lrtyp < lrtypMax );

	if ( ( cb = mplrtyplrd[plr->lrtyp].cb ) != 0 )
		return cb;

	switch ( plr->lrtyp )
		{
	case lrtypRecoveryUndo:
	case lrtypFullBackup:
	case lrtypIncBackup:
		{
		LRLOGRESTORE *plrlogrestore = (LRLOGRESTORE *) plr;
		return sizeof(LRLOGRESTORE) + plrlogrestore->cbPath;
		}

	case lrtypCreateDB:
		{
		LRCREATEDB *plrcreatedb = (LRCREATEDB *)plr;
		Assert( plrcreatedb->cbPath != 0 );
		return sizeof(LRCREATEDB) + plrcreatedb->cbPath;
		}
	case lrtypAttachDB:
		{
		LRATTACHDB *plrattachdb = (LRATTACHDB *)plr;
		Assert( plrattachdb->cbPath != 0 );
		return sizeof(LRATTACHDB) + plrattachdb->cbPath;
		}
	case lrtypDetachDB:
		{
		LRDETACHDB *plrdetachdb = (LRDETACHDB *)plr;
		Assert( plrdetachdb->cbPath != 0 );
		return sizeof( LRDETACHDB ) + plrdetachdb->cbPath;
		}
	case lrtypSplit:
		{
		LRSPLIT *plrsplit = (LRSPLIT *) plr;
		return sizeof( LRSPLIT ) + plrsplit->cbKey + plrsplit->cbKeyMac +
				sizeof( BKLNK ) * plrsplit->cbklnk;
		}
	case lrtypMerge:
		{
		LRMERGE *plrmerge = (LRMERGE *) plr;
		return sizeof( LRMERGE ) + sizeof( BKLNK ) * plrmerge->cbklnk + plrmerge->cbKey;
		}
	case lrtypInsertNode:
	case lrtypInsertItemList:
		{
		LRINSERTNODE *plrinsertnode = (LRINSERTNODE *) plr;
		return	sizeof(LRINSERTNODE) +
				plrinsertnode->cbKey + plrinsertnode->cbData;
		}
	case lrtypInsertItems:
		{
		LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *) plr;
		return	sizeof(LRINSERTITEMS) +
				plrinsertitems->citem * sizeof(ITEM);
		}
	case lrtypReplace:
	case lrtypReplaceD:
		{
		LRREPLACE *plrreplace = (LRREPLACE *) plr;
		return sizeof(LRREPLACE) + plrreplace->cb;
		}
	case lrtypDeferredBI:
		{
		LRDEFERREDBI *plrdbi = (LRDEFERREDBI *) plr;
		return sizeof( LRDEFERREDBI ) + plrdbi->cbData;
		}
	case lrtypTrace:
		{
		LRTRACE *plrtrace = (LRTRACE *) plr;
		return sizeof(LRTRACE) + plrtrace->cb;
		}
	default:
		Assert( fFalse );
		}
    Assert(fFalse);
    return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\recupd.c ===
#include "daestd.h"

DeclAssertFile; 				/* Declare file name for assert macros */

/**************************** INTERNAL STUFF ***************************/
typedef struct ATIPB {			/*** AddToIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx; 			// index's FUCB (can be pfucbNil)
	SRID	srid;		   		// srid of data record
	BOOL	fFreeFUCB; 			// free index FUCB?
	} ATIPB;

typedef struct UIPB {			/*** UpdateIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx; 			// index's FUCB (can be pfucbNil)
	SRID	srid;	 			// SRID of record
	BOOL	fOpenFUCB; 			// open index FUCB?
	BOOL	fFreeFUCB; 			// free index FUCB?
} UIPB;

typedef struct DFIPB {				/*** DeleteFromIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx;				// index's FUCB (can be pfucbNil)
	SRID	sridRecord;				// SRID of deleted record
	BOOL	fFreeFUCB;				// free index FUCB?
} DFIPB;

INLINE LOCAL ERR ErrRECInsert( PIB *ppib, FUCB *pfucb, SRID *psrid );
INLINE LOCAL ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB *patipb );
INLINE LOCAL ERR ErrRECReplace( PIB *ppib, FUCB *pfucb );
INLINE LOCAL ERR ErrRECIUpdateIndex( FCB *pfcbIdx, UIPB *puipb );
LOCAL BOOL FRECIndexPossiblyChanged( BYTE *rgbitIdx, BYTE *rgbitSet );
LOCAL ERR ErrRECFIndexChanged( FUCB * pfucb, FCB * pfcb, FDB * pfdb, BOOL * fChanged );
INLINE LOCAL ERR ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb );

	ERR VTAPI
ErrIsamUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err;
	SRID	srid;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( pcbActual != NULL )
		*pcbActual = sizeof(srid);

	if ( FFUCBReplacePrepared( pfucb ) )
		{
		if ( cbMax > 0 )
			{
			FUCBSetGetBookmark( pfucb );
			CallR( ErrDIRGetBookmark( pfucb, &srid ) );
			memcpy( pb, &srid, min( cbMax, sizeof(srid) ) );
			}
		err = ErrRECReplace( ppib, pfucb );
		}
	else if ( FFUCBInsertPrepared( pfucb ) )
		{
		err = ErrRECInsert( ppib, pfucb, &srid );

		if ( pb != NULL && cbMax > 0 && err >= 0 )
			{
			FUCBSetGetBookmark( pfucb );
			memcpy( pb, &srid, min( cbMax, sizeof(srid) ) );
			}
		}
	else
		err = ErrERRCheck( JET_errUpdateNotPrepared );

	/*  free temp working buffer
	/**/
	if ( err >= 0 )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		pfucb->lineWorkBuf.pb = NULL;	//  verify that no one uses BF anymore
		}

	Assert( err != errDIRNotSynchronous );
	return err;
	}


//+local
// ErrRECInsert
// ========================================================================
// ErrRECInsert( PIB *ppib, FUCB *pfucb, SRID *psrid )
//
// Adds a record to a data file.  All indexes on the data file are
// updated to reflect the addition.
//
// PARAMETERS	ppib						PIB of user
//		 		pfucb						FUCB for file
//		 		plineBookmark				if this parameter is not NULL,
//		 									then bookmark of record is returned
//
// RETURNS		Error code, one of the following:
//					 JET_errSuccess		Everything went OK.
//					-KeyDuplicate		The record being added causes
//										an illegal duplicate entry in an index.
//					-NullKeyDisallowed	A key of the new record is NULL.
//					-RecordNoCopy		There is no working buffer to add from.
//					-NullInvalid		The record being added contains
//										at least one null-valued field
//										which is defined as NotNull.
// SIDE EFFECTS
//		After addition, file currency is left on the new record.
//		Index currency (if any) is left on the new index entry.
//		On failure, the currencies are returned to their initial states.
//
//	COMMENTS
//		No currency is needed to add a record.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//-
INLINE LOCAL ERR ErrRECInsert( PIB *ppib, FUCB *pfucb, SRID *psrid )
	{
	ERR		err = JET_errSuccess;  		 	// error code of various utility
	KEY		keyToAdd;					 	// key of new data record
	BYTE	rgbKey[ JET_cbKeyMost ];	 	// key buffer
	FCB		*pfcbTable;					 	// file's FCB
	FDB		*pfdb;						 	// field descriptor info
	FCB		*pfcbIdx;					 	// loop variable for each index on file
	ATIPB	atipb;						 	// parm block to ErrRECIAddToIndex
	FUCB	*pfucbT;
	LINE	*plineData;
	LINE	line;
	ULONG	ulRecordAutoIncrement;
	ULONG	ulTableAutoIncrement;
	BOOL	fPrepareInsertIndex = fFalse;
	BOOL	fCommit = fFalse;
	BOOL	fReadLatchSet = fFalse;
	DIB		dib;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/* should have been checked in PrepareUpdate
	/**/
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBInsertPrepared( pfucb ) );

	/* efficiency variables
	/**/
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	/*	record to use for put
	/**/
	plineData = &pfucb->lineWorkBuf;
	Assert( !( FLineNull( plineData ) ) );
	if ( FRECIIllegalNulls( (FDB *)pfcbTable->pfdb, plineData ) )
		return ErrERRCheck( JET_errNullInvalid );

	/*	if necessary, begin transaction
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	/*	open temp FUCB on data file
	/**/
	CallJ( ErrDIROpen( ppib, pfcbTable, 0, &pfucbT ), Abort );
	Assert(pfucbT != pfucbNil);
	FUCBSetIndex( pfucbT );

	/*	abort if index is being built on file
	/**/
	if ( FFCBWriteLatch( pfcbTable, ppib ) )
		{
		err = ErrERRCheck( JET_errWriteConflict );
		goto HandleError;
		}
	FCBSetReadLatch( pfcbTable );
	fReadLatchSet = fTrue;

	/*	efficiency variable
	/**/
	pfdb = (FDB *)pfcbTable->pfdb;
	Assert( pfdb != pfdbNil );

	/*	set version and autoinc fields
	/**/
	Assert( pfcbTable != pfcbNil );
	if ( pfdb->fidVersion != 0 && ! ( FFUCBColumnSet( pfucb, pfdb->fidVersion ) ) )
		{
		LINE	lineField;
		ULONG	ul = 0;

		/*	set field to zero
		/**/
		lineField.pb = (BYTE *)&ul;
		lineField.cb = sizeof(ul);
		Call( ErrRECSetColumn( pfucb, pfdb->fidVersion, 0, &lineField ) );
		}

	if ( pfdb->fidAutoInc != 0 )
		{
		Assert( FFUCBColumnSet( pfucb, pfdb->fidAutoInc ) );
		/*	get the value of autoinc that the user set
		/**/
		Call( ErrRECRetrieveColumn( pfucb, &pfdb->fidAutoInc, 0, &line, JET_bitRetrieveCopy ) );
		Assert( line.cb == sizeof(ulRecordAutoIncrement) );
		ulRecordAutoIncrement = *(ULONG UNALIGNED *)line.pb;

		/*	move to FDP root and seek to autoincrement
		/**/
		DIRGotoFDPRoot( pfucbT );
		dib.fFlags = fDIRPurgeParent;
		dib.pos = posDown;
		dib.pkey = pkeyAutoInc;
		err = ErrDIRDown( pfucbT, &dib );
		if ( err != JET_errSuccess )
			{
			if ( err > 0 )
				{
				DIRUp( pfucbT, 1 );
				err = ErrERRCheck( JET_errDatabaseCorrupted );
				}
			goto HandleError;
			}
		Call( ErrDIRGet( pfucbT ) );
		Assert( pfucbT->lineData.cb == sizeof(ulTableAutoIncrement) );
		ulTableAutoIncrement = *(ULONG UNALIGNED *)pfucbT->lineData.pb;
		Assert( ulTableAutoIncrement != 0 );

		/*	update FDP autoinc to be one greater than set value.
		/**/
		if ( ulRecordAutoIncrement >= ulTableAutoIncrement)
			{
			ulTableAutoIncrement = ulRecordAutoIncrement + 1;
			line.pb = (BYTE *)&ulTableAutoIncrement;
			line.cb = sizeof(ulTableAutoIncrement);
			Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
			}
		}

	/*	get key to add with new record
	/**/
	keyToAdd.pb = rgbKey;
	if ( pfcbTable->pidb == pidbNil )
		{
		DBK	dbk;

		/*	file is sequential
		/**/
		SgEnterCriticalSection( pfcbTable->critDBK );

		// dbk's are numbered starting at 1.  A dbk of 0 indicates that we must
		// first retrieve the dbkMost.  In the pathological case where there are
		// currently no dbk's, we'll go through here anyway, but only the first
		// time (since there will be dbk's after that).
		if ( pfcbTable->dbkMost == 0 )
			{
			DIB		dib;
			BYTE	*pb;

			DIRGotoDataRoot( pfucbT );

			/*	down to the last data record
			/**/
			dib.fFlags = fDIRNull;
			dib.pos = posLast;
			err = ErrDIRDown( pfucbT, &dib );
			Assert( err != JET_errNoCurrentRecord );
			switch( err )
				{
				case JET_errSuccess:
					pb = pfucbT->keyNode.pb;
					dbk = ( pb[0] << 24 ) + ( pb[1] << 16 ) + ( pb[2] << 8 ) + pb[3];
					Assert( dbk > 0 );		// dbk's start numbering at 1
					DIRUp( pfucbT, 1 );		// Back to DATA
					break;

				case JET_errRecordNotFound:
					dbk = 0;
					break;

				default:
					DIRClose( pfucbT );
					goto Abort;
				}

			// While retrieving the dbkMost, someone else may have been doing the same
			// thing and beaten us to it.  When this happens, cede to the other guy.
			// UNDONE:  This logic relies on critJet.  When we move to sg crit. sect.,
			// we should rewrite this.
			if ( pfcbTable->dbkMost != 0 )
				{
				dbk = ++pfcbTable->dbkMost;
				}
			else
				{
				// dbk contains the last set dbk.  Increment by 1 (for our insertion),
				// then update dbkMost.
				pfcbTable->dbkMost = ++dbk;
				}
			}
		else
			dbk = ++pfcbTable->dbkMost;
	
		Assert( dbk > 0 );
		Assert( dbk == pfcbTable->dbkMost );
		SgLeaveCriticalSection( pfcbTable->critDBK );

		keyToAdd.cb = sizeof(DBK);
		keyToAdd.pb[0] = (BYTE)((dbk >> 24) & 0xff);
		keyToAdd.pb[1] = (BYTE)((dbk >> 16) & 0xff);
		keyToAdd.pb[2] = (BYTE)((dbk >> 8) & 0xff);
		keyToAdd.pb[3] = (BYTE)(dbk & 0xff);
		}

	else
		{
		/*	file is clustered
		/**/
		Assert( plineData->cb == pfucb->lineWorkBuf.cb &&
				 plineData->pb == pfucb->lineWorkBuf.pb );
		Call( ErrRECRetrieveKeyFromCopyBuffer( pfucb, pfdb, pfcbTable->pidb,
			&keyToAdd, 1, fFalse ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

		if ( ( pfcbTable->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullKey || err == wrnFLDNullFirstSeg || err == wrnFLDNullSeg ) )
			Error( ErrERRCheck( JET_errNullKeyDisallowed ), HandleError )
		}

	/*	insert record.  Move to DATA root.
	/**/
	DIRGotoDataRoot( pfucbT );

	if ( pfcbTable->pidb == pidbNil )
		{
		/*	file is sequential
		/**/
		Call( ErrDIRInsert( pfucbT, plineData, &keyToAdd,
			fDIRVersion | fDIRDuplicate | fDIRPurgeParent ) );
		}
	else
		{
		Call( ErrDIRInsert( pfucbT, plineData, &keyToAdd,
			fDIRVersion | fDIRPurgeParent |
			( pfcbTable->pidb->fidb&fidbUnique ? 0 : fDIRDuplicate ) ) );
		}

	/*	return bookmark of inserted record
	/**/
	DIRGetBookmark( pfucbT, psrid );

	/*	insert item in non-clustered indexes
	/**/
	for ( pfcbIdx = pfcbTable->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		if ( !fPrepareInsertIndex )
			{
			/*	get SRID of inserted record
			/**/
			DIRGetBookmark( pfucbT, &atipb.srid );

			/*	set atipb for index insertion.
			/**/
			atipb.pfucb = pfucbT;
//			atipb.pfucbIdx = pfucbNil;
			atipb.fFreeFUCB = fFalse;
			fPrepareInsertIndex = fTrue;
			}
		atipb.fFreeFUCB = pfcbIdx->pfcbNextIndex == pfcbNil;
		Call( ErrRECIAddToIndex( pfcbIdx, &atipb ) );
		}

	/*	if no error, commit transaction
	/**/
	if ( fCommit )
		{
		Call( ErrDIRCommitTransaction( ppib, 0 ) );
		}
	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );

	/*	discard temp FUCB
	/**/
	DIRClose( pfucbT );

	Assert( pfcbTable != pfcbNil );
	FCBResetReadLatch( pfcbTable );

	return err;

HandleError:
	Assert( err < 0 );
	DIRClose( pfucbT );

Abort:
	/*	rollback all changes on error
	/**/
	if ( fCommit )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

	if ( fReadLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		FCBResetReadLatch( pfcbTable );
		}

	return err;
	}


//+local
// ErrRECIAddToIndex
// ========================================================================
// ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB patipb )
//
// Extracts key from data record, opens the index, adds that key with
// the given SRID to the index, and closes the index.
//
// PARAMETERS	pfcbIdx 		  			FCB of index to insert into
// 				patipb->ppib				who is calling this routine
// 				patipb->pfucbIdx			pointer to index's FUCB.      If pfucbNil,
//											an FUCB will be allocated by DIROpen.
//				patipb->srid	  			SRID of data record
//				patipb->fFreeFUCB			free index FUCB?
//
// RETURNS		JET_errSuccess, or error code from failing routine
//
// SIDE EFFECTS if patipb->pfucbIdx==pfucbNil, ErrDIROpen will allocate
//				an FUCB and it will be pointed at it.
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
// SEE ALSO		Insert
//-
INLINE LOCAL ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB *patipb )
	{
	ERR		err = JET_errSuccess;			// error code of various utility
	CSR		**ppcsrIdx; 				  	// index's currency
	KEY		keyToAdd;					  	// key to add to secondary index
	BYTE	rgbKey[ JET_cbKeyMost ];		// key extracted from data
	LINE	lineSRID;						// SRID to add to index
	ULONG	itagSequence; 					// used to extract keys
	ULONG	ulAddFlags; 					// flags to DIRAdd
	BOOL	fNullKey = fFalse;				// extracted NullTaggedKey -- so no more keys to extract

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfcbTable->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( patipb != NULL );
	Assert( patipb->pfucb != pfucbNil );
	Assert( patipb->pfucb->ppib != ppibNil );
	Assert( patipb->pfucb->ppib->level < levelMax );

	/*	open FUCB on this index
	/**/
	CallR( ErrDIROpen( patipb->pfucb->ppib, pfcbIdx, 0, &patipb->pfucbIdx ) )
	Assert( patipb->pfucbIdx != pfucbNil );

	/*	cursor on non-clustering index
	/**/
	FUCBSetIndex( patipb->pfucbIdx );
	FUCBSetNonClustered( patipb->pfucbIdx );

	ppcsrIdx = &PcsrCurrent( patipb->pfucbIdx );
	Assert( *ppcsrIdx != pcsrNil );
	lineSRID.cb = sizeof(SRID);
	lineSRID.pb = (BYTE *) &patipb->srid;
	ulAddFlags = ( pfcbIdx->pidb->fidb&fidbUnique ?
		0 : fDIRDuplicate ) | fDIRPurgeParent;

	/*	add all keys for this index from new data record
	/**/
	keyToAdd.pb = rgbKey;
	for ( itagSequence = 1; ; itagSequence++ )
		{
		Call( ErrDIRGet( patipb->pfucb ) );
		Call( ErrRECRetrieveKeyFromRecord( patipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb,
			pfcbIdx->pidb, &keyToAdd,
			itagSequence, fFalse ) );
		Assert( 	err == wrnFLDOutOfKeys ||
			err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequence > 1 );
			break;
			}

		if ( ( pfcbIdx->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullKey || err == wrnFLDNullFirstSeg || err == wrnFLDNullSeg ) )
			{
			err = ErrERRCheck( JET_errNullKeyDisallowed );
			goto HandleError;
			}

		if ( err == wrnFLDNullKey )
			{
			if ( pfcbIdx->pidb->fidb & fidbAllowAllNulls )
				{
				ulAddFlags |= fDIRDuplicate;
				fNullKey = fTrue;
				}
			else 
				break;
			}
		else
			{
			if ( err == wrnFLDNullFirstSeg && !( pfcbIdx->pidb->fidb & fidbAllowFirstNull ) )
				break;
			else
				{
				if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
					break;
				}
			}

		/*	move to DATA root and insert index node
		/**/
		DIRGotoDataRoot( patipb->pfucbIdx );
		Call( ErrDIRInsert( patipb->pfucbIdx, &lineSRID, &keyToAdd, fDIRVersion | ulAddFlags ) )

		/*	dont keep extracting for keys with no tagged segments
		/**/
		if ( !( pfcbIdx->pidb->fidb & fidbHasMultivalue ) || fNullKey )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDOutOfKeys ||
		err == wrnFLDNullKey ||
		err == wrnFLDNullFirstSeg ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/* close the FUCB
	/**/
	DIRClose( patipb->pfucbIdx );
	patipb->pfucbIdx = pfucbNil;

	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}


//+local
//	ErrRECReplace
//	========================================================================
//	ErrRECReplace( PIB *ppib, FUCB *pfucb )
//
//	Updates a record in a data file.	 All indexes on the data file are
// 	pdated to reflect the updated data record.
//
//	PARAMETERS	ppib		 PIB of this user
// 		  		pfucb		 FUCB for file
//	RETURNS		Error code, one of the following:
//					 JET_errSuccess	  			 Everything went OK.
//					-NoCurrentRecord			 There is no current record
//									  			 to update.
//					-RecordNoCopy				 There is no working buffer
//									  			 to update from.
//					-KeyDuplicate				 The new record data causes an
//									  			 illegal duplicate index entry
//									  			 to be generated.
//					-RecordClusteredChanged		 The new data causes the clustered
//									  			 key to change.
//	SIDE EFFECTS
//		After update, file currency is left on the updated record.
//		Similar for index currency.
//		The effect of a GetNext or GetPrevious operation will be
//		the same in either case.  On failure, the currencies are
//		returned to their initial states.
//		If there is a working buffer for SetField commands,
//		it is discarded.
//
//	COMMENTS
//		If currency is not ON a record, the update will fail.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		For temporary files, transaction logging is deactivated
//		for the duration of the routine.
//		Index entries are not made for entirely-null keys.
//-
INLINE LOCAL ERR ErrRECReplace( PIB *ppib, FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;	// error code of various utility
	FCB		*pfcbTable;				// file's FCB
	FCB		*pfcbIdx;				// loop variable for each index on file
	FCB		*pfcbCurIdx;			// FCB of current index (if any)
	IDB		*pidbFile;				// IDB of table (if any)
	UIPB   	uipb;					// parameter block to ErrRECIUpdateIndex
	LINE   	*plineNewData;
	FID		fidFixedLast;
	FID		fidVarLast;
	FID		fid;
	BOOL   	fUpdateIndex;
	BOOL   	fCommit = fFalse;
	BOOL	fReadLatchSet = fFalse;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/*	should have been checked in PrepareUpdate
	/**/
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBReplacePrepared( pfucb ) );

	/*	efficiency variables
	/**/
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	/*	must initialize pfucb for error handling.
	/**/
	uipb.pfucbIdx = pfucbNil;

	/*	record to use for update
	/**/
	plineNewData = &pfucb->lineWorkBuf;
	Assert( !( FLineNull( plineNewData ) ) );
	
	/*	if necessary, begin transaction
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	/*	optimistic locking, ensure that record has
	/*	not changed since PrepareUpdate
	/**/
	if ( FFUCBReplaceNoLockPrepared( pfucb ) )
		{
		//	UNDONE:	compute checksum on commit to level 0
		//			in support of following sequence:
		// 				BeginTransaction
		// 				PrepareUpdate, defer checksum since in xact
		// 				SetColumns
		// 				Commit to level 0, other user may update it
		// 				Update
		Assert( !FFUCBDeferredChecksum( pfucb ) ||
			pfucb->ppib->level > 0 );
		Call( ErrDIRGet( pfucb ) );
		if ( !FFUCBDeferredChecksum( pfucb ) &&
			!FFUCBCheckChecksum( pfucb ) )
			{
			Error( ErrERRCheck( JET_errWriteConflict ), HandleError );
			}
		}
		
	/*	error if index create in progress
	/**/
	if ( FFCBWriteLatch( pfcbTable, ppib ) )
		{
		Call( ErrERRCheck( JET_errWriteConflict ) );
		}
	FCBSetReadLatch( pfcbTable );
	fReadLatchSet = fTrue;

	/*	Set these efficiency varialbes after FUCB ReadLock is set.
	 */
	fidFixedLast = pfcbTable->pfdb->fidFixedLast;
	fidVarLast = pfcbTable->pfdb->fidVarLast;
	 
	/*	if need to update indexes, then cache old record.
	/**/
	fUpdateIndex = FRECIndexPossiblyChanged( pfcbTable->rgbitAllIndex,
											 pfucb->rgbitSet );

	if ( fUpdateIndex )
		{
		/* make sure clustered key did not change
		/**/
		pidbFile = pfcbTable->pidb;
		if ( pidbFile != pidbNil )
			{
		 	/*	check for unchanged key
		 	/*	UNDONE: this will sometimes allow the clustered index to be changed
		 	/*	when it should not be.
			/**/
			BOOL	fIndexChanged;
		   	Call( ErrRECFIndexChanged( pfucb, pfcbTable, (FDB *)pfcbTable->pfdb, &fIndexChanged ) );
			if ( fIndexChanged )
				{
				Error( ErrERRCheck( JET_errRecordClusteredChanged ), HandleError )
				}
			}
		}
#ifdef DEBUG
	else
		{
		if ( pfcbTable->pfdb && pfcbTable->pidb )
			{
			BOOL	fIndexChanged;
		   	Call( ErrRECFIndexChanged( pfucb, pfcbTable, (FDB *)pfcbTable->pfdb, &fIndexChanged ) );
			Assert( fIndexChanged == fFalse );
			}
		}
#endif

	/*	set autoinc and version fields if they are present
	/**/
	Assert( FFUCBIndex( pfucb ) );
	fid = pfcbTable->pfdb->fidVersion;
	if ( fid != 0 )
		{
		LINE	lineField;
		ULONG	ul;

		/*	increment field from value in current record
		/**/
		Call( ErrRECRetrieveColumn( pfucb, &fid, 0, &lineField, 0 ) );

		/*	handle case where field is NULL when column added
		/*	to table with records present
		/**/
		if ( lineField.cb == 0 )
			{
			ul = 1;
			lineField.cb = sizeof(ul);
			lineField.pb = (BYTE *)&ul;
			}
		else
			{
			Assert( lineField.cb == sizeof(ULONG) );
			++*(ULONG UNALIGNED *)lineField.pb;
			}

		Call( ErrRECSetColumn( pfucb, fid, 0, &lineField ) );
		}

	/*	complete changes to long values, before index update, so that
	/*	after image of long value updates will be available from database.
	/*	If updated separate long values then delete removed long values.
	/**/
	if ( FFUCBUpdateSeparateLV( pfucb ) )
		{
		Call( ErrRECAffectLongFields( pfucb, NULL, fDereferenceRemoved ) );
		}

	/*	update indexes
	/**/
	if ( fUpdateIndex )
		{
		uipb.pfucb = pfucb;
		uipb.fOpenFUCB = fTrue;
		uipb.fFreeFUCB = fFalse;

		/*	get SRID of record
		/**/
		DIRGetBookmark( pfucb, &uipb.srid );

		pfcbCurIdx = pfucb->pfucbCurIndex != pfucbNil ?	pfucb->pfucbCurIndex->u.pfcb : pfcbNil;

		for ( pfcbIdx = pfcbTable->pfcbNextIndex;
			pfcbIdx != pfcbNil;
			pfcbIdx = pfcbIdx->pfcbNextIndex )
			{
			IDB	*pidb = pfcbIdx->pidb;

			if ( pidb == NULL )
				{
				/*	this is a sequential index. it does not need to be updated
				/**/
				continue;
				}

			if ( FRECIndexPossiblyChanged( pidb->rgbitIdx, pfucb->rgbitSet ) )
				{
				Call( ErrRECIUpdateIndex( pfcbIdx, &uipb ) );
				}
#ifdef DEBUG
			else
				{
				BOOL	fIndexChanged;

			   	Call( ErrRECFIndexChanged( pfucb, pfcbIdx, (FDB *)pfcbTable->pfdb, &fIndexChanged ) );
				Assert( fIndexChanged == fFalse );
				}
#endif
			}
		}

	FLDFreeLVBuf( pfucb );

	/*	replace record data
	/**/
	Call( ErrDIRReplace( pfucb, plineNewData, fDIRVersion | fDIRLogColumnDiffs ) );

	/*	if no error, commit transaction
	/**/
	if ( fCommit )
		{
		Call( ErrDIRCommitTransaction( ppib, 0 ) );
		}

	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );

HandleError:
	if ( uipb.pfucbIdx != pfucbNil )
		{
		DIRClose( uipb.pfucbIdx );
		}

	/*	rollback all changes on error
	/**/
	if ( err < 0 && fCommit )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

	if ( fReadLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		FCBResetReadLatch( pfcbTable );
		}

	return err;
	}

/*	determines whether an index may have changed using the hashed tags
/**/
LOCAL BOOL FRECIndexPossiblyChanged( BYTE *rgbitIdx, BYTE *rgbitSet )
	{
	LONG	*plIdx;
	LONG	*plIdxMax;
	LONG	*plSet;
 
	plIdx = (LONG *)rgbitIdx;
	plSet = (LONG *)rgbitSet;
	plIdxMax = plIdx + (32 / sizeof( LONG ) );

	for ( ; plIdx < plIdxMax; plIdx++, plSet++ )
		{
		if ( *plIdx & *plSet)
			{
			return fTrue;
			}
		}
	return fFalse;
	}


/*	determines whether an index may has changed by comparing the kets
/**/
LOCAL ERR ErrRECFIndexChanged( FUCB * pfucb, FCB * pfcb, FDB * pfdb, BOOL * pfChanged )
	{
	KEY		keyOld;
	KEY		keyNew;
	BYTE	rgbOldKey[ JET_cbKeyMost ];
	BYTE	rgbNewKey[ JET_cbKeyMost ];
	LINE   	*plineNewData = &pfucb->lineWorkBuf;
	ERR		err;
	
	Assert( pfucb );
	Assert( pfcb );
	Assert( pfucb->lineWorkBuf.cb == plineNewData->cb &&
			pfucb->lineWorkBuf.pb == plineNewData->pb );

	/*	get new key from copy buffer
	/**/
	keyNew.pb = rgbNewKey;
	CallR( ErrRECRetrieveKeyFromCopyBuffer( pfucb, pfdb, pfcb->pidb, &keyNew, 1, fFalse ) );
	Assert( err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

	/*	get the old key from the node
	/**/
	keyOld.pb = rgbOldKey;

	/*	refresh currency
	/**/
	CallR( ErrDIRGet( pfucb ) );
	CallR( ErrRECRetrieveKeyFromRecord( pfucb, pfdb, pfcb->pidb, &keyOld, 1, fTrue ) );
	Assert( err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

	/*	record must honor index no NULL segment requirements
	/**/
	Assert( !( pfcb->pidb->fidb & fidbNoNullSeg ) ||
		( err != wrnFLDNullSeg && err != wrnFLDNullFirstSeg && err != wrnFLDNullKey ) );

	if ( keyOld.cb != keyNew.cb || memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) != 0 )
		{
		*pfChanged = fTrue;
		}
	else
		{
		*pfChanged = fFalse;
		}

	return JET_errSuccess;
	}


//+local
// ErrRECIUpdateIndex
// ========================================================================
// ERR ErrRECIUpdateIndex( FCB *pfcbIdx, UIPB *puipb )
//
// Extracts keys from old and new data records, and if they are different,
// opens the index, adds the new index entry, deletes the old index entry,
// and closes the index.
//
// PARAMETERS
//				pfcbIdx				  		FCB of index to insert into
//				puipb->ppib			  		who is calling this routine
//				puipb->pfucbIdx				pointer to index's FUCB.  If pfucbNil,
//									  		an FUCB will be allocated by DIROpen.
//				puipb->srid			  		SRID of record
//				puipb->fFreeFUCB	  		free index FUCB?
//
// RETURNS		JET_errSuccess, or error code from failing routine
//
// SIDE EFFECTS if patipb->pfucbIdx==pfucbNil, ErrDIROpen will allocate
//				an FUCB and it will be pointed at it.
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
// SEE ALSO		Replace
//-
INLINE LOCAL ERR ErrRECIUpdateIndex( FCB *pfcbIdx, UIPB *puipb )
	{
	ERR		err = JET_errSuccess;					// error code of various utility
	LINE   	lineSRID;								// SRID to add to index
	KEY		keyOld;				  					// key extracted from old record
	BYTE   	rgbOldKey[ JET_cbKeyMost];				// buffer for old key
	KEY		keyNew;				  					// key extracted from new record
	BYTE   	rgbNewKey[ JET_cbKeyMost ]; 			// buffer for new key
	ULONG  	itagSequenceOld; 						// used to extract keys
	ULONG  	itagSequenceNew;						// used to extract keys
	BOOL   	fHasMultivalue;							// index has tagged segment
	BOOL   	fMustDelete;							// record no longer generates key
	BOOL   	fMustAdd;								// record now generates this key
	BOOL   	fAllowNulls;							// this index allows NULL keys
	BOOL   	fAllowFirstNull;						// this index allows keys with first NULL segment
	BOOL   	fAllowSomeNulls;						// this index allows keys with NULL segments
	BOOL   	fNoNullSeg;								// this index prohibits any NULL key segment
	BOOL   	fDoOldNullKey;
	BOOL   	fDoNewNullKey;

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfcbTable->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( puipb != NULL );
	Assert( puipb->pfucb != pfucbNil );
	Assert( puipb->pfucb->ppib != ppibNil );
	Assert( puipb->pfucb->ppib->level < levelMax );

	/* open FUCB on this index
	/**/
	CallR( ErrDIROpen( puipb->pfucb->ppib, pfcbIdx, 0, &puipb->pfucbIdx ) );
	Assert( puipb->pfucbIdx != pfucbNil );
	FUCBSetIndex( puipb->pfucbIdx );
	FUCBSetNonClustered( puipb->pfucbIdx );

	fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;
	fAllowNulls = pfcbIdx->pidb->fidb & fidbAllowAllNulls;
	fAllowFirstNull = pfcbIdx->pidb->fidb & fidbAllowFirstNull;
	fAllowSomeNulls = pfcbIdx->pidb->fidb & fidbAllowSomeNulls;
	fNoNullSeg = pfcbIdx->pidb->fidb & fidbNoNullSeg;

	Assert( !( fNoNullSeg  &&  ( fAllowNulls || fAllowSomeNulls ) ) );
	// if fAllowNulls, then fAllowSomeNulls needs to be true
	Assert( !fAllowNulls || fAllowSomeNulls );

	keyOld.pb = rgbOldKey;
	keyNew.pb = rgbNewKey;

	/* delete the old key from the index 
	/**/
	fDoOldNullKey = fFalse;
	for ( itagSequenceOld = 1; ; itagSequenceOld++ )
		{
		Call( ErrDIRGet( puipb->pfucb ) );
		Call( ErrRECRetrieveKeyFromRecord( puipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb,
			pfcbIdx->pidb, &keyOld,
			itagSequenceOld, fTrue ) );
		Assert( err == wrnFLDOutOfKeys ||
			err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequenceOld > 1 );
			break;
			}

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !fNoNullSeg || ( err != wrnFLDNullSeg && err != wrnFLDNullFirstSeg && err != wrnFLDNullKey ) );

		if ( err == wrnFLDNullKey )
			{
			if ( fAllowNulls )
				fDoOldNullKey = fTrue;
			else
				break;
			}
		else
			{
			if ( err == wrnFLDNullFirstSeg && !fAllowFirstNull )
				break;
			else
				{
				if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
					break;
				}
			}

		fMustDelete = fTrue;
		fDoNewNullKey = fFalse;
		for ( itagSequenceNew = 1; ; itagSequenceNew++ )
			{
			/*	extract key from new data in copy buffer
			/**/
			Call( ErrRECRetrieveKeyFromCopyBuffer( puipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb,
				pfcbIdx->pidb, &keyNew,
				itagSequenceNew, fFalse ) );
			Assert( err == wrnFLDOutOfKeys ||
				err == wrnFLDNullKey ||
				err == wrnFLDNullFirstSeg ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );
			if ( err == wrnFLDOutOfKeys )
				{
				Assert( itagSequenceNew > 1 );
				break;
				}

			if ( err == wrnFLDNullKey )
				{
				if ( fAllowNulls )
					fDoNewNullKey = fTrue;
				else
					break;
				}
			else
				{
				if ( err == wrnFLDNullFirstSeg && !fAllowFirstNull )
					break;
				else
					{
					if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
						break;
					}
				}

			if ( keyOld.cb == keyNew.cb && memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) == 0 )
				{
				fMustDelete = fFalse;
				break;
				}

			if ( !fHasMultivalue || fDoNewNullKey )
				break;
			}

		if ( fMustDelete )
			{
			/*	move to DATA root.  Seek to index entry.
			/**/
			DIRGotoDataRoot( puipb->pfucbIdx );
			Call( ErrDIRDownKeyBookmark( puipb->pfucbIdx, &keyOld, puipb->srid ) );
			err = ErrDIRDelete( puipb->pfucbIdx, fDIRVersion );
			if ( err < 0 )
				{
				if ( err == JET_errRecordDeleted )
					{
					Assert( fHasMultivalue );
					/*	must have been record with multi-value column
					/*	with sufficiently similar values to produce
					/*	redundant index entries.
					/**/
					err = JET_errSuccess;
					}
				else
					goto HandleError;
				}
			}

		if ( !fHasMultivalue || fDoOldNullKey )
			break;
		}

	/* insert the new key into the index 
	/**/
	lineSRID.cb = sizeof(SRID);
	lineSRID.pb = (BYTE *)&puipb->srid;
	fDoNewNullKey = fFalse;
	for ( itagSequenceNew = 1; ; itagSequenceNew++ )
		{
		/*	extract key from new data in copy buffer
		/**/
		Call( ErrRECRetrieveKeyFromCopyBuffer( puipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb, 
			pfcbIdx->pidb, &keyNew, itagSequenceNew, fFalse ) );
		Assert( err == wrnFLDOutOfKeys ||
			err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequenceNew > 1 );
			break;
			}

		if ( fNoNullSeg && ( err == wrnFLDNullSeg || err == wrnFLDNullFirstSeg || err == wrnFLDNullKey ) )
			{
			err = ErrERRCheck( JET_errNullKeyDisallowed );
			goto HandleError;
			}

		if ( err == wrnFLDNullKey )
			{
			if ( fAllowNulls )
				fDoNewNullKey = fTrue;
			else
				break;
			}
		else
			{
			if ( err == wrnFLDNullFirstSeg && !fAllowFirstNull )
				break;
			else
				{
				if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
					break;
				}
			}

		fMustAdd = fTrue;
		fDoOldNullKey = fFalse;
		for ( itagSequenceOld = 1; ; itagSequenceOld++ )
			{
			Call( ErrDIRGet( puipb->pfucb ) );
			Call( ErrRECRetrieveKeyFromRecord( puipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb,
				pfcbIdx->pidb, &keyOld,
				itagSequenceOld, fTrue ) );
			Assert( err == wrnFLDOutOfKeys ||
				err == wrnFLDNullKey ||
				err == wrnFLDNullFirstSeg ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );
			if ( err == wrnFLDOutOfKeys )
				{
				Assert( itagSequenceOld > 1 );
				break;
				}

			/*	record must honor index no NULL segment requirements
			/**/
			Assert( !( pfcbIdx->pidb->fidb & fidbNoNullSeg ) ||
				( err != wrnFLDNullSeg && err != wrnFLDNullFirstSeg && err != wrnFLDNullKey ) );

			if ( err == wrnFLDNullKey )
				{
				if ( fAllowNulls )
					fDoOldNullKey = fTrue;
				else
					break;
				}
			else
				{
				if ( err == wrnFLDNullFirstSeg && !fAllowFirstNull )
					break;
				else
					{
					if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
						break;
					}
				}

			if ( keyOld.cb == keyNew.cb &&
				memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) ==0 )
				{
				fMustAdd = fFalse;
				break;
				}

			if ( !fHasMultivalue || fDoOldNullKey )
				break;
			}

		if ( fMustAdd )
			{
			BOOL fAllowDupls = fDoNewNullKey ||	!(pfcbIdx->pidb->fidb & fidbUnique);

			/*	move to DATA root and insert new index entry.
			/**/
			DIRGotoDataRoot( puipb->pfucbIdx );
			Call( ErrDIRInsert(puipb->pfucbIdx, &lineSRID, &keyNew,
				(fAllowDupls ? fDIRDuplicate : 0) |
				fDIRPurgeParent | fDIRVersion ) );
			}

		if ( !fHasMultivalue || fDoNewNullKey )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDOutOfKeys ||
		err == wrnFLDNullKey ||
		err == wrnFLDNullFirstSeg ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/*	close the FUCB
	/**/
	DIRClose( puipb->pfucbIdx );
	puipb->pfucbIdx = pfucbNil;

	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}


//+API
// ErrIsamDelete
// ========================================================================
// ErrIsamDelete( PIB *ppib, FCBU *pfucb )
//
// Deletes the current record from data file.  All indexes on the data
// file are updated to reflect the deletion.
//
// PARAMETERS
// 			ppib		PIB of this user
// 			pfucb		FUCB for file to delete from
// RETURNS
//		Error code, one of the following:
//			JET_errSuccess	 			Everything went OK.
//			-NoCurrentRecord			There is no current record
//							 			to delete.
// SIDE EFFECTS 
//			After the deletion, file currency is left just before
//			the next record.  Index currency (if any) is left just
//			before the next index entry.  If the deleted record was
//			the last in the file, the currencies are left after the
//			new last record.  If the deleted record was the only record
//			in the entire file, the currencies are left in the
//			"beginning of file" state.	On failure, the currencies are
//			returned to their initial states.
//			If there is a working buffer for SetField commands,
//			it is discarded.
// COMMENTS		
//			If the currencies are not ON a record, the delete will fail.
//			A transaction is wrapped around this function.	Thus, any
//			work done will be undone if a failure occurs.
//			Index entries are not made for entirely-null keys.
//			For temporary files, transaction logging is deactivated
//			for the duration of the routine.
//-
ERR VTAPI ErrIsamDelete( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;
	FCB		*pfcbTable;				// table FCB
	FCB		*pfcbIdx;				// loop variable for each index on file
	DFIPB  	dfipb;					// parameter to ErrRECIDeleteFromIndex
	BOOL	fCommitWasDone = fFalse;
	BOOL	fReadLatchSet = fFalse;

#ifdef DEBUG
	BOOL	fTraceCommit = fFalse;
	BOOL	fLogIsDone = fFalse;
#endif

	CallR( ErrPIBCheck( ppib ) );

	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	/*	reset copy buffer status on record delete
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	efficiency variables
	/**/
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	/*	if necessary, begin transaction
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommitWasDone = fTrue;
#ifdef DEBUG
		fTraceCommit = fTrue;
		fLogIsDone = !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) );
#endif
		}

	/* abort if index is being built on file 
	/**/
	if ( FFCBWriteLatch( pfcbTable, ppib ) )
		{ 
		err = ErrERRCheck( JET_errWriteConflict );
		goto HandleError;
		}
	FCBSetReadLatch( pfcbTable );
	fReadLatchSet = fTrue;
	
#ifdef DEBUG
	Assert( fTraceCommit == fCommitWasDone );
	Assert(	fLogIsDone == ( !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) ) ) );
#endif

	/*	get SRID of record being deleted for updating indexes
	/**/
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	DIRGetBookmark( pfucb, &dfipb.sridRecord );

#ifdef DEBUG
	Assert( fTraceCommit == fCommitWasDone );
	Assert(	fLogIsDone == ( !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) ) ) );
#endif

	/*	delete from non-clustered indexes
	/**/
	dfipb.pfucb = pfucb;
	dfipb.fFreeFUCB = fFalse;
	for( pfcbIdx = pfcbTable->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		dfipb.fFreeFUCB = pfcbIdx->pfcbNextIndex == pfcbNil;
		Call( ErrRECIDeleteFromIndex( pfcbIdx, &dfipb ) );
		}

	//	UNDONE:	optimize record deletion by  detecting presence of 
	//			long values on table or record basis.
	/*	delete record long values
	/**/
	Call( ErrRECAffectLongFields( pfucb, NULL, fDereference ) );

#ifdef DEBUG
	Assert( fTraceCommit == fCommitWasDone );
	Assert(	fLogIsDone == ( !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) ) ) );
#endif

	/*	delete record
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

#ifdef DEBUG
	Assert( fTraceCommit == fCommitWasDone );
	Assert(	fLogIsDone == ( !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) ) ) );
#endif

	/*	if no error, commit transaction
	/**/
	if ( fCommitWasDone )
		{
		Call( ErrDIRCommitTransaction( ppib, 0 ) );
		}

	Assert( err >= 0 );

HandleError:

#ifdef DEBUG
	Assert( fTraceCommit == fCommitWasDone );
	Assert(	fLogIsDone == ( !( fLogDisabled || fRecovering ) &&
					 !( !FDBIDLogOn(pfucb->dbid) ) ) );
#endif

	/*	rollback all changes on error
	/**/
	if ( err < 0 && fCommitWasDone )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

	if ( fReadLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		FCBResetReadLatch( pfcbTable );
		}

	return err;
	}


//+INTERNAL
//	ErrRECIDeleteFromIndex
//	========================================================================
//	ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb )
//	
//	Extracts key from data record, opens the index, deletes the key with
//	the given SRID, and closes the index.
//
//	PARAMETERS	
//				pfcbIdx							FCB of index to delete from
//				pdfipb->ppib					who is calling this routine
//				pdfipb->pfucbIdx				pointer to index's FUCB.
//				pdfipb->sridRecord  			SRID of deleted record
//				pdfipb->fFreeFUCB				free index FUCB?
//	RETURNS		
//				JET_errSuccess, or error code from failing routine
//	SIDE EFFECTS 
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
//	SEE ALSO  	ErrRECDelete
//-
INLINE LOCAL ERR ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb )
	{
	ERR		err;		 						// error code of various utility
	KEY		keyDeleted;						 	// key extracted from old data record
	BYTE	rgbDeletedKey[ JET_cbKeyMost ]; 	// buffer for keyDeleted
	ULONG	itagSequence; 					 	// used to extract keys
	BOOL	fHasMultivalue;  				 	// index key has a tagged field?

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfcbTable->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( pdfipb != NULL );
	Assert( pdfipb->pfucb != pfucbNil );

	/*	open FUCB on this index
	/**/
	CallR( ErrDIROpen( pdfipb->pfucb->ppib, pfcbIdx, 0, &pdfipb->pfucbIdx ) );
	Assert( pdfipb->pfucbIdx != pfucbNil );
	FUCBSetIndex( pdfipb->pfucbIdx );
	FUCBSetNonClustered( pdfipb->pfucbIdx );

	/*	delete all keys from this index for dying data record
	/**/
	fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;
	keyDeleted.pb = rgbDeletedKey;
	for ( itagSequence = 1; ; itagSequence++ )
		{
		/*	get record
		/**/
		Call( ErrDIRGet( pdfipb->pfucb ) );
		Call( ErrRECRetrieveKeyFromRecord( pdfipb->pfucb, (FDB *)pfcbIdx->pfcbTable->pfdb,
			pfcbIdx->pidb, &keyDeleted,
			itagSequence, fFalse ) );
		Assert(	err == wrnFLDOutOfKeys ||
			err == wrnFLDNullKey ||
			err == wrnFLDNullFirstSeg ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequence > 1 );
			break;
			}

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !( pfcbIdx->pidb->fidb & fidbNoNullSeg ) ||
			( err != wrnFLDNullSeg && err != wrnFLDNullFirstSeg && err != wrnFLDNullKey ) );

		if ( err == wrnFLDNullKey )
			{
			if ( pfcbIdx->pidb->fidb & fidbAllowAllNulls )
				{
				/*	move to DATA root and seek to index entry and delete it
				/**/
				DIRGotoDataRoot( pdfipb->pfucbIdx );
				Call( ErrDIRDownKeyBookmark( pdfipb->pfucbIdx, &keyDeleted, pdfipb->sridRecord ) );
				err = ErrDIRDelete( pdfipb->pfucbIdx, fDIRVersion );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						{
						Assert( fHasMultivalue );
						/*	must have been record with multi-value column
						/*	with sufficiently similar values to produce
						/*	redundant index entries.
							/**/
						err = JET_errSuccess;
						}
					else
						goto HandleError;
					}
				}
			break;
			}
		else
			{
			if ( err == wrnFLDNullFirstSeg && !( pfcbIdx->pidb->fidb & fidbAllowFirstNull ) )
				break;
			else
				{
				if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
					break;
				}
			}

		DIRGotoDataRoot( pdfipb->pfucbIdx );
		Call( ErrDIRDownKeyBookmark( pdfipb->pfucbIdx, &keyDeleted, pdfipb->sridRecord ) );
		err = ErrDIRDelete( pdfipb->pfucbIdx, fDIRVersion );
		if ( err < 0 )
			{
			if ( err == JET_errRecordDeleted )
				{
				Assert( fHasMultivalue );
				/*	must have been record with multi-value column
				/*	with sufficiently similar values to produce
				/*	redundant index entries.
				/**/
				err = JET_errSuccess;
				}
			else
				goto HandleError;
			}

		/* dont keep extracting for keys with no tagged segments
		/**/
		if ( !fHasMultivalue )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDOutOfKeys ||
		err == wrnFLDNullKey ||
		err == wrnFLDNullFirstSeg ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/* close the FUCB
	/**/
	DIRClose( pdfipb->pfucbIdx );
	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\sort.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1995 Microsoft Corporation.
*
* Component:  Sort
*
* File: sort.c
*
* File Comments:  implements an optimized memory/disk sort for use
*                 with TTs and index creation
*
* Revision History:
*
*    [0]  25-Jan-95  t-andygo	Recreated
*    [1]  06-Feb-95  t-andygo   Cascade Merge
*    [2]  20-Mar-95  t-andygo   Selectable Cascade / Opt. Tree Merge
*    [3]  29-Mar-95  t-andygo   Depth First Opt. Tree Merge
*
***********************************************************************/


#include "daestd.h"

DeclAssertFile;				/* Declare file name for assert macros */


//#if !defined( DEBUG ) && !defined( PERFDUMP )
//#define UtilPerfDumpStats( a )	( 0 )
//#else
//#undef UtilPerfDumpStats
//#endif


//  SORT internal functions

LOCAL LONG	IspairSORTISeekByKey(	SCB *pscb,
									BYTE *rgbRec,
									SPAIR *rgspair,
									LONG ispairMac,
									KEY *pkey,
									BOOL fGT );
LOCAL INT	ISORTICmpKeyStSt( BYTE *stKey1, BYTE *stKey2 );
LOCAL LONG	CspairSORTIUnique(	SCB *pscb,
								BYTE *rgbRec,
								SPAIR *rgspair,
								LONG ispairMac );
LOCAL ERR	ErrSORTIOutputRun( SCB *pscb );
LOCAL INT	ISORTICmpPspairPspair( SCB *pscb, SPAIR *pspair1, SPAIR *pspair2 );
LOCAL INT	ISORTICmp2PspairPspair( SCB *pscb, SPAIR *pspair1, SPAIR *pspair2 );
LOCAL VOID	SORTIInsertionSort( SCB *pscb, SPAIR *pspairMinIn, SPAIR *pspairMaxIn );
LOCAL VOID	SORTIQuicksort( SCB *pscb, SPAIR *pspairMinIn, SPAIR *pspairMaxIn );

LOCAL ERR	ErrSORTIRunStart( SCB *pscb, RUNINFO *pruninfo );
LOCAL ERR	ErrSORTIRunInsert( SCB *pscb, SREC *psrec );
LOCAL VOID	SORTIRunEnd( SCB *pscb );
LOCAL VOID	SORTIRunDelete( SCB *pscb, RUNINFO *pruninfo );
LOCAL VOID	SORTIRunDeleteList( SCB *pscb, RUNLINK **pprunlink, LONG crun );
LOCAL VOID	SORTIRunDeleteListMem( SCB *pscb, RUNLINK **pprunlink, LONG crun );
LOCAL ERR	ErrSORTIRunOpen( SCB *pscb, RUNINFO *pruninfo, RCB **pprcb );
LOCAL ERR	ErrSORTIRunNext( RCB *prcb, SREC **ppsrec );
LOCAL VOID	SORTIRunClose( RCB *prcb );
LOCAL ERR	ErrSORTIRunReadPage( RCB *prcb, PGNO pgno, LONG ipbf );

LOCAL ERR	ErrSORTIMergeToRun(	SCB *pscb,
								RUNLINK *prunlinkSrc,
								RUNLINK **pprunlinkDest );
LOCAL ERR	ErrSORTIMergeStart( SCB *pscb, RUNLINK *prunlinkSrc, BOOL fUnique );
LOCAL ERR	ErrSORTIMergeFirst( SCB *pscb, SREC **ppsrec );
LOCAL ERR	ErrSORTIMergeNext( SCB *pscb, SREC **ppsrec );
LOCAL VOID	SORTIMergeEnd( SCB *pscb );
LOCAL INT	ISORTICmpPsrecPsrec( SCB *pscb, SREC *psrec1, SREC *psrec2 );
LOCAL ERR	ErrSORTIMergeNextChamp( SCB *pscb, SREC **ppsrec );

LOCAL VOID	SORTIOptTreeInit( SCB *pscb );
LOCAL ERR	ErrSORTIOptTreeAddRun( SCB *pscb, RUNINFO *pruninfo );
LOCAL ERR	ErrSORTIOptTreeMergeLevel( SCB *pscb );
LOCAL ERR	ErrSORTIOptTreeMerge( SCB *pscb );
LOCAL VOID	SORTIOptTreeTerm( SCB *pscb );
LOCAL ERR	ErrSORTIOptTreeBuild( SCB *pscb, OTNODE **ppotnode );
LOCAL ERR	ErrSORTIOptTreeMergeDF( SCB *pscb, OTNODE *potnode, RUNLINK **pprunlink );
LOCAL VOID	SORTIOptTreeFree( SCB *pscb, OTNODE *potnode );


//----------------------------------------------------------
//	ErrSORTOpen( PIB *ppib, FUCB **pfucb, INT fFlags )
//
//	This function returns a pointer to an FUCB which can be
//	use to add records to a collection of records to be sorted.
//	Then the records can be retrieved in sorted order.
//	
//	The fFlags fUnique flag indicates that records with duplicate
//	keys should be eliminated.
//----------------------------------------------------------

ERR ErrSORTOpen( PIB *ppib, FUCB **ppfucb, INT fFlags )
	{
	ERR		err			= JET_errSuccess;
	FUCB   	*pfucb		= pfucbNil;
	SCB		*pscb		= pscbNil;
	SPAIR	*rgspair	= NULL;
	BYTE	*rgbRec		= NULL;

	/*	allocate a new SCB
	/**/
	CallR( ErrFUCBOpen( ppib, dbidTemp, &pfucb ) );
	if ( ( pscb = PscbMEMAlloc() ) == pscbNil )
		Error( ErrERRCheck( JET_errTooManySorts ), HandleError );

	/*	verify CSRs are setup correctly
	/**/
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );
	
	/*	initialize sort context to insert mode
	/**/
	FCBInitFCB( &pscb->fcb );
	FUCBSetSort( pfucb );
	pscb->fFlags	= fSCBInsert | fFlags;
	pscb->cRecords	= 0;

	/*	allocate sort pair buffer and record buffer
	/**/
	if ( !( rgspair = PvUtilAllocAndCommit( cbSortMemFastUsed ) ) )
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
	pscb->rgspair	= rgspair;
	if ( !( rgbRec = PvUtilAlloc( cbSortMemNormUsed ) ) )
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
	pscb->rgbRec	= rgbRec;
	pscb->cbCommit	= 0;

	/*	initialize sort pair buffer
	/**/
	pscb->ispairMac	= 0;

	/*	initialize record buffer
	/**/
	pscb->irecMac	= 0;
	pscb->crecBuf	= 0;
	pscb->cbData	= 0;

	/*	reset run count to zero
	/**/
	pscb->crun = 0;

	/*	link FUCB to FCB in SCB
	/**/
	FCBLink( pfucb, &( pscb->fcb ) );

	/*	defer allocating space for a disk merge as well as initializing for a
	/*	 merge until we are forced to perform one
	/**/
	pscb->fcb.pgnoFDP = pgnoNull;

	/*	return initialized FUCB
	/**/
	*ppfucb = pfucb;
	return JET_errSuccess;

HandleError:
	if ( rgbRec != NULL )
		UtilFree( rgbRec );
	if ( rgspair != NULL )
		UtilFree( rgspair );
	if ( pscb != pscbNil )
		MEMReleasePscb( pscb );
	if ( pfucb != pfucbNil )
		FUCBClose( pfucb );
	return err;
	}


//----------------------------------------------------------
//	ErrSORTInsert
//
//	Add the record rglineKeyRec[1] with key rglineKeyRec[0]
//	to the collection of sort records.
//----------------------------------------------------------

ERR ErrSORTInsert( FUCB *pfucb, LINE rglineKeyRec[] )
	{
	ERR		err				= JET_errSuccess;
	SCB		*pscb			= pfucb->u.pscb;
	LONG	cbNormNeeded;
	LONG	cirecNeeded;
	LONG	cbCommit;
	SREC	*psrec;
	LONG	irec;
	SPAIR	*pspair;
	LONG	cbKey;
	BYTE	*pbSrc;
	BYTE	*pbSrcMac;
	BYTE	*pbDest;
	BYTE	*pbDestMic;

	//  check input and input mode

	Assert( rglineKeyRec[0].cb <= JET_cbKeyMost );
	Assert( FSCBInsert( pscb ) );

	//  check SCB
	
	Assert( pscb->crecBuf <= cspairSortMax );
	Assert( pscb->irecMac <= irecSortMax );

	//  calculate required normal memory/record indexes to store this record

	cbNormNeeded = CbSRECSizePscbCbCb( pscb, rglineKeyRec[0].cb, rglineKeyRec[1].cb );
	cirecNeeded = CirecToStoreCb( cbNormNeeded );

	//  if we are out of committed normal memory but still have some reserved,
	//  commit another page

	if (	pscb->irecMac * cbIndexGran + cbNormNeeded > (ULONG) pscb->cbCommit &&
			pscb->cbCommit < cbSortMemNormUsed )
		{
		cbCommit = min( pscb->cbCommit + siSystemConfig.dwPageSize, cbSortMemNormUsed );
		if ( !PvUtilCommit( pscb->rgbRec, cbCommit ) )
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		pscb->cbCommit = cbCommit;
		}

	//  if we are out of fast or normal memory, output a run
	
	if (	pscb->irecMac * cbIndexGran + cbNormNeeded > cbSortMemNormUsed ||
			pscb->crecBuf == cspairSortMax )
		{
		//  sort previously inserted records into a run

		SORTIQuicksort( pscb, pscb->rgspair, pscb->rgspair + pscb->ispairMac );

		//  move the new run to disk
		
		Call( ErrSORTIOutputRun( pscb ) );
		}

	//  create and add the sort record for this record

	irec = pscb->irecMac;
	psrec = PsrecFromPbIrec( pscb->rgbRec, irec );
	pscb->irecMac += cirecNeeded;
	pscb->crecBuf++;
	pscb->cbData += cbNormNeeded;
	SRECSizePscbPsrecCb( pscb, psrec, cbNormNeeded );
	SRECKeySizePscbPsrecCb( pscb, psrec, rglineKeyRec[0].cb );
	memcpy( PbSRECKeyPscbPsrec( pscb, psrec ), rglineKeyRec[0].pb, rglineKeyRec[0].cb );
	memcpy( PbSRECDataPscbPsrec( pscb, psrec ), rglineKeyRec[1].pb, rglineKeyRec[1].cb );

	//  create and add the sort pair for this record

	//  get new SPAIR pointer and advance SPAIR counter

	pspair = pscb->rgspair + pscb->ispairMac++;

	//  copy key into prefix buffer BACKWARDS for fast compare

	cbKey = CbSRECKeyPscbPsrec( pscb, psrec );
	pbSrc = PbSRECKeyPscbPsrec( pscb, psrec );
	pbSrcMac = pbSrc + min( cbKey, cbKeyPrefix );
	pbDest = pspair->rgbKey + cbKeyPrefix - 1;

	while ( pbSrc < pbSrcMac )
		*( pbDest-- ) = *( pbSrc++ );

	//  do we have any unused buffer space?

	if ( pbDest >= pspair->rgbKey )
		{
		//  If this is an index, copy SRID into any unused space.  If the
		//  entire SRID fits in the buffer, this will guarantee that we will
		//  never need to access the full record for a sort comparison that
		//  involves this SPAIR, preventing several expensive cache misses.
		//
		//  NOTE:  This will only work due to assumptions about the way keys
		//  NOTE:  are constructed.  If this changes, this strategy must be
		//  NOTE:  reevaluated.

		if ( FSCBIndex( pscb ) )
			{
			pbSrc = PbSRECDataPscbPsrec( pscb, psrec ) + sizeof( SRID ) - 1;
			pbDestMic = max( pspair->rgbKey, pbDest - sizeof( SRID ) + 1 );

			while ( pbDest >= pbDestMic )
				*( pbDest-- ) = *( pbSrc-- );
			}

		//  If this is not an index, copy irec into any unused space such that
		//  its LSB is compared before its MSB.  This is done for reasons
		//  similar to those above.  We can ignore the effect this has on the
		//  sort order of identical keys because this is undefined in JET.

		else
			{
			pbDestMic = max( pspair->rgbKey, pbDest - sizeof( USHORT ) + 1 );

			*( pbDest-- ) = (BYTE) irec;
			if ( pbDest >= pbDestMic )
				*pbDest = (BYTE) ( irec >> 8 );
			}

		//  If there is still free space, we don't care because at this point
		//  all keys are unique anyway and this data won't be considered!!
		}

	//  set compressed pointer to full record
	
	pspair->irec = (USHORT) irec;

	//  keep track of record count

	pscb->cRecords++;

	//  check SCB
	
	Assert( pscb->crecBuf <= cspairSortMax );
	Assert( pscb->irecMac <= irecSortMax );

HandleError:
	return err;
	}


//----------------------------------------------------------
//	ErrSORTEndInsert
//
//	This function is called to indicate that no more records
//	will be added to the sort.  It performs all work that needs
//	to be done before the first record can be retrieved.
//----------------------------------------------------------

ERR ErrSORTEndInsert( FUCB *pfucb )
	{
	ERR		err		= JET_errSuccess;
	SCB		*pscb	= pfucb->u.pscb;

	//  verify insert mode

	Assert( FSCBInsert( pscb ) );

	//  deactivate insert mode
	
	SCBResetInsert( pscb );

	//  move CSR to before the first record (if any)
	
	pfucb->ispairCurr = -1L;
	PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;

	//  if we have no records, we're done

	if ( !pscb->cRecords )
		return JET_errSuccess;

	//  sort records in memory

	SORTIQuicksort( pscb, pscb->rgspair, pscb->rgspair + pscb->ispairMac );

	//  do we have any runs on disk?

	if ( pscb->crun )
		{
		//	empty sort buffer into final run

		Call( ErrSORTIOutputRun( pscb ) );

		//  free sort memory

		UtilFree( pscb->rgspair );
		pscb->rgspair = NULL;
		UtilFree( pscb->rgbRec );
		pscb->rgbRec = NULL;
		
		//	perform all but final merge

		Call( ErrSORTIOptTreeMerge( pscb ) );

#if defined( DEBUG ) || defined( PERFDUMP )
		UtilPerfDumpStats( "MERGE:  final level" );
#endif

		// initialize final merge and set it to remove duplicates, if requested

		Call( ErrSORTIMergeStart( pscb, pscb->runlist.prunlinkHead, FSCBUnique( pscb ) ) );
		}

	//  we have no runs on disk, so remove duplicates in sort buffer, if requested

	else if ( FSCBUnique( pscb ) )
		pscb->cRecords = CspairSORTIUnique( pscb, pscb->rgbRec, pscb->rgspair, pscb->ispairMac );

	//  return a warning if TT doesn't fit in memory, but success otherwise

	return	( pscb->crun > 0 || pscb->irecMac * cbIndexGran > cbResidentTTMax ) ?
				ErrERRCheck( JET_wrnSortOverflow ) :
				JET_errSuccess;

HandleError:
	return err;
	}


//----------------------------------------------------------
//	ErrSORTFirst
//
//	Move to first record in sort or return an error if the sort
//  has no records.
//----------------------------------------------------------
ERR ErrSORTFirst( FUCB *pfucb )
	{
	ERR		err;
	SCB		*pscb	= pfucb->u.pscb;
	SREC	*psrec;
	LONG	irec;

	//  verify that we are not in insert mode

	Assert( !FSCBInsert( pscb ) );

	//	reset index range

	FUCBResetLimstat( pfucb );

	//  if we have no records, error

	if ( !pscb->cRecords )
		return ErrERRCheck( JET_errNoCurrentRecord );
		
	//  if we have runs, start last merge and get first record
	
	if ( pscb->crun )
		{
		CallR( ErrSORTIMergeFirst( pscb, &psrec ) );
		}

	//  we have no runs, so just get first record in memory
	
	else
		{
		pfucb->ispairCurr = 0L;
		irec = pscb->rgspair[pfucb->ispairCurr].irec;
		psrec = PsrecFromPbIrec( pscb->rgbRec, irec );
		}

	//	get current record

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;			//  CSR on record
	pfucb->keyNode.cb  = CbSRECKeyPscbPsrec( pscb, psrec );		//  size of key
	pfucb->keyNode.pb  = PbSRECKeyPscbPsrec( pscb, psrec );		//  key
	pfucb->lineData.cb = CbSRECDataPscbPsrec( pscb, psrec );	//  size of data
	pfucb->lineData.pb = PbSRECDataPscbPsrec( pscb, psrec );	//  data

	return JET_errSuccess;
	}


//----------------------------------------------------------
//	ErrSORTNext
//
//	Return the next record, in sort order, after the previously
//	returned record.  If no records have been returned yet,
//	or the currency has been reset, this function returns
//	the first record.
//----------------------------------------------------------

ERR ErrSORTNext( FUCB *pfucb )
	{
	ERR		err;
	SCB		*pscb	= pfucb->u.pscb;
	SREC	*psrec;
	LONG	irec;

	//  verify that we are not in insert mode

	Assert( !FSCBInsert( pscb ) );

	//  if we have runs, get next record from last merge

	if ( pscb->crun )
		{
		CallR( ErrSORTIMergeNext( pscb, &psrec ) );
		}
	else
		{
		//  we have no runs, so get next record from memory

		if ( ++pfucb->ispairCurr < pscb->ispairMac )
			{
			irec = pscb->rgspair[pfucb->ispairCurr].irec;
			psrec = PsrecFromPbIrec( pscb->rgbRec, irec );
			}

		//  we have no more records in memory, so return no current record
		
		else
			{
			pfucb->ispairCurr = pscb->ispairMac;
			//PcsrCurrent( pfucb )->csrstat = csrstatAfterLast;
			return ErrERRCheck( JET_errNoCurrentRecord );
			}
		}

	//	get current record

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;			//  CSR on record
	pfucb->keyNode.cb  = CbSRECKeyPscbPsrec( pscb, psrec );		//  size of key
	pfucb->keyNode.pb  = PbSRECKeyPscbPsrec( pscb, psrec );		//  key
	pfucb->lineData.cb = CbSRECDataPscbPsrec( pscb, psrec );	//  size of data
	pfucb->lineData.pb = PbSRECDataPscbPsrec( pscb, psrec );	//  data

	//  handle index range, if requested

	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) )
		CallR( ErrSORTCheckIndexRange( pfucb ) );

	return JET_errSuccess;
	}


//----------------------------------------------------------
//	ErrSORTPrev
//
//	Return the previous record, in sort order, before the
//  previously returned record.  If no records have been
//  returned yet, the currency will be set to before the
//  first record.
//
//  NOTE:  This function supports in memory sorts only!
//  Larger sorts must be materialized for this functionality.
//----------------------------------------------------------

ERR ErrSORTPrev( FUCB *pfucb )
	{
	ERR		err;
	SCB		*pscb	= pfucb->u.pscb;
	SREC	*psrec;
	LONG	irec;

	//  verify that we have an in memory sort

	Assert( !pscb->crun );
	
	//  verify that we are not in insert mode

	Assert( !FSCBInsert( pscb ) );

	//  get previous record from memory

	if ( --pfucb->ispairCurr != -1L )
		{
		irec = pscb->rgspair[pfucb->ispairCurr].irec;
		psrec = PsrecFromPbIrec( pscb->rgbRec, irec );
		}

	//  we have no more records in memory, so return no current record
	
	else
		{
		pfucb->ispairCurr = -1L;
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

	//	get current record

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;			//  CSR on record
	pfucb->keyNode.cb  = CbSRECKeyPscbPsrec( pscb, psrec );		//  size of key
	pfucb->keyNode.pb  = PbSRECKeyPscbPsrec( pscb, psrec );		//  key
	pfucb->lineData.cb = CbSRECDataPscbPsrec( pscb, psrec );	//  size of data
	pfucb->lineData.pb = PbSRECDataPscbPsrec( pscb, psrec );	//  data

	//  handle index range, if requested

	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) )
		CallR( ErrSORTCheckIndexRange( pfucb ) );

	return JET_errSuccess;
	}


//----------------------------------------------------------
//	ErrSORTSeek
//
//	Return the first record with key >= pkey.
//	If pkey == NULL then return the first record.
//
//  Return Value
//		JET_errSuccess				record with key == pkey is found
//		JET_wrnSeekNotEqual			record with key > pkey is found
//		JET_errNoCurrentRecord		no record with key >= pkey is found
//
//  NOTE:  This function supports in memory sorts only!
//  Larger sorts must be materialized for this functionality.
//----------------------------------------------------------

ERR ErrSORTSeek( FUCB *pfucb, KEY *pkey, BOOL fGT )
	{
	SCB		*pscb	= pfucb->u.pscb;
	SREC	*psrec;
	LONG	irec;

	//  verify that we have an in memory sort

	Assert( FFUCBSort( pfucb ) );
	Assert( !pscb->crun );
	
	//  verify that we are not in insert mode

	Assert( !FSCBInsert( pscb ) );

	//  verify that we are scrollable or indexed or the key is NULL
	
	Assert( ( pfucb->u.pscb->grbit & JET_bitTTScrollable ) ||
		( pfucb->u.pscb->grbit & JET_bitTTIndexed ) ||
		( pkey == NULL ) );

	//  if we have no records, return error

	if ( !pscb->cRecords )
		return ErrERRCheck( JET_errNoCurrentRecord );

	//  verify that we have a valid key

	Assert( pkey->cb <= JET_cbKeyMost );

	//  seek to key or next highest key
	
	pfucb->ispairCurr = IspairSORTISeekByKey(	pscb,
												pscb->rgbRec,
												pscb->rgspair,
												pscb->ispairMac,
												pkey,
												fGT );

	//  if we are after last pair, record not found
	
	if ( pfucb->ispairCurr == pscb->ispairMac )
		return ErrERRCheck( JET_errRecordNotFound );

	//	get current record

	irec = pscb->rgspair[pfucb->ispairCurr].irec;
	psrec = PsrecFromPbIrec( pscb->rgbRec, irec );
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;			//  CSR on record
	pfucb->keyNode.cb  = CbSRECKeyPscbPsrec( pscb, psrec );		//  size of key
	pfucb->keyNode.pb  = PbSRECKeyPscbPsrec( pscb, psrec );		//  key
	pfucb->lineData.cb = CbSRECDataPscbPsrec( pscb, psrec );	//  size of data
	pfucb->lineData.pb = PbSRECDataPscbPsrec( pscb, psrec );	//  data

	//  return warning if key not equal, success otherwise

	return	CmpStKey( StSRECKeyPscbPsrec( pscb, psrec ), pkey ) ?
				ErrERRCheck( JET_wrnSeekNotEqual ) :
				JET_errSuccess;
	}


//----------------------------------------------------------
//	ErrSORTClose
//
//  Release sort FUCB and the sort itself if it is no longer
//  needed.
//----------------------------------------------------------

ERR ErrSORTClose( FUCB *pfucb )
	{
	ERR		err		= JET_errSuccess;
	SCB		*pscb	= pfucb->u.pscb;

	//	if this is the last cursor on sort, then release sort resources

	if ( pscb->fcb.wRefCnt == 1 )
		{
		//  if we have allocated sort space, free it and end all ongoing merge
		//  and output activities

		if ( pscb->fcb.pgnoFDP != pgnoNull )
			{
			/*	if we were merging, end merge
			/**/
			if ( pscb->crunMerge )
				SORTIMergeEnd( pscb );

			/*	free merge method resources
			/**/
			SORTIOptTreeTerm( pscb );

			/*	if our output buffer is still latched, free it
			/**/
			if ( pscb->pbfOut != pbfNil )
				BFResetWriteLatch( pscb->pbfOut, pscb->fcb.pfucb->ppib );

			/*	free FDP and allocated sort space (including runs)
			/**/
			CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
			(VOID)ErrSPFreeFDP( pfucb, pscb->fcb.pgnoFDP );
			err = ErrDIRCommitTransaction( pfucb->ppib, 0 );

			/*	rollback on a failure to commit
			/**/
			if ( err < 0 )
				{
				CallS( ErrDIRRollback( pfucb->ppib ) );
				}
			}
		}

	/*	release FUCB resources
	/**/
  	FCBUnlink( pfucb );
	FUCBClose( pfucb );

	/*	if there are no more references to this sort, free its resources
	/**/
	if ( !pscb->fcb.wRefCnt )
		{
		SORTClosePscb( pscb );
		}

	return JET_errSuccess;
	}


//----------------------------------------------------------
//	SORTClosePscb
//
//  Release this SCB and all its resources.
//----------------------------------------------------------

VOID SORTClosePscb( SCB *pscb )
	{
	if ( pscb->rgspair != NULL )
		UtilFree( pscb->rgspair );
	if ( pscb->rgbRec != NULL )
		UtilFree( pscb->rgbRec );
	if ( pscb->fcb.pidb != NULL )
		MEMReleasePidb( pscb->fcb.pidb );
	if ( pscb->fcb.pfdb != NULL )
		FDBDestruct( (FDB *)pscb->fcb.pfdb );
	MEMReleasePscb( pscb );
	}


//----------------------------------------------------------
//	ErrSORTCheckIndexRange
//
//  Restrain currency to a specific range.
//----------------------------------------------------------

ERR ErrSORTCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;
	SCB		*pscb = pfucb->u.pscb;

	//  range check FUCB

	err =  ErrFUCBCheckIndexRange( pfucb );
	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );

	//  if there is no current record, we must have wrapped around
	
	if ( err == JET_errNoCurrentRecord )
		{
		//  wrap around to bottom of sort

		if ( FFUCBUpper( pfucb ) )
			{
			pfucb->ispairCurr = pscb->ispairMac;
			PcsrCurrent( pfucb )->csrstat = csrstatAfterLast;
			}

		//  wrap around to top of sort
		
		else
			{
			pfucb->ispairCurr = -1L;
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
			}
		}

	//  verify that currency is valid

	Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
			PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
			PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
	Assert( pfucb->ispairCurr >= -1 && pfucb->ispairCurr <= pscb->ispairMac );

	return err;
	}


//----------------------------------------------------------
//	Module internal functions
//----------------------------------------------------------


//	returns index of first entry >= pbKey, or the index past the end of the array

LOCAL LONG IspairSORTISeekByKey(	SCB *pscb,
									BYTE *rgbRec,
									SPAIR *rgspair,
									LONG ispairMac,
									KEY *pkey,
									BOOL fGT )
	{
	LONG	ispairBeg	= 0;
	LONG	ispairMid;
	LONG	ispairEnd	= ispairMac;
	SREC	*psrec;
	LONG	irec;
	INT		wCmp;

	//  if there are no pairs, return end of array

	if ( !ispairMac )
		return 0;

	//  b-search array

	do  {
		//  calculate midpoint of this partition
		
		ispairMid = ispairBeg + ( ispairEnd - ispairBeg ) / 2;

		//  compare full keys
		
		irec = rgspair[ispairMid].irec;
		psrec = PsrecFromPbIrec( rgbRec, irec );
		wCmp = CmpStKey( StSRECKeyPscbPsrec( pscb, psrec ), pkey );

		//  select partition containing destination

		if ( fGT ? wCmp <= 0 : wCmp < 0 )
			ispairBeg = ispairMid + 1;
		else
			ispairEnd = ispairMid;
		}
	while ( ispairBeg != ispairEnd );

	return ispairEnd;
	}


//  perform simple pascal string comparison

INLINE LOCAL INT ISORTICmpKeyStSt( BYTE *stKey1, BYTE *stKey2 )
	{
	INT		w;

	w = memcmp( stKey1+1, stKey2+1, min( *stKey1, *stKey2 ) );
	return w ? w : (INT) *stKey1 - (INT) *stKey2;
	}


//  remove duplicates

LOCAL LONG CspairSORTIUnique( SCB *pscb, BYTE *rgbRec, SPAIR *rgspair, LONG ispairMac )
	{
	LONG	ispairSrc;
	SREC	*psrecSrc;
	LONG	irecSrc;
	LONG	ispairDest;
	SREC	*psrecDest;
	LONG	irecDest;

	//  if there are no records, there are no duplicates

	if ( !ispairMac )
		return 0;

	//  loop through records, moving unique records towards front of array

	for ( ispairDest = 0, ispairSrc = 1; ispairSrc < ispairMac; ispairSrc++ )
		{
		//  get sort record pointers for src/dest
		
		irecDest = rgspair[ispairDest].irec;
		psrecDest = PsrecFromPbIrec( rgbRec, irecDest );
		irecSrc = rgspair[ispairSrc].irec;
		psrecSrc = PsrecFromPbIrec( rgbRec, irecSrc );

		//  if the keys are unequal, copy them forward
		
		if ( ISORTICmpKeyStSt(	StSRECKeyPscbPsrec( pscb, psrecSrc ),
								StSRECKeyPscbPsrec( pscb, psrecDest ) ) )
			rgspair[++ispairDest] = rgspair[ispairSrc];
		}

	return ispairDest + 1;
	}


//  output current sort buffer to disk in a run

LOCAL ERR ErrSORTIOutputRun( SCB *pscb )
	{
	ERR		err;
	RUNINFO	runinfo;
	LONG	ispair;
	LONG	irec;
	SREC	*psrec;

	//  verify that there are records to put to disk

	Assert( pscb->ispairMac );

	//  if we haven't created our sort space on disk, we have not initialized
	//  for a disk merge, so do so now

	if ( pscb->fcb.pgnoFDP == pgnoNull )
		{
		FUCB	*pfucb = pscb->fcb.pfucb;
		CPG		cpgReq;
		CPG		cpgMin;

		//  allocate FDP and primary sort space
		//
		//  NOTE:  enough space is allocated to avoid file extension for a single
		//         level merge, based on the data size of the first run
		
		cpgReq = cpgMin = (PGNO) ( ( pscb->cbData + cbFreeSPAGE - 1 ) / cbFreeSPAGE * crunFanInMax );

		if ( pfucb->ppib->level == 0 )
			{
			CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
			pscb->fcb.pgnoFDP = pgnoNull;
			err = ErrSPGetExt(	pfucb,
								pgnoSystemRoot,
								&cpgReq,
								cpgMin,
								&( pscb->fcb.pgnoFDP ),
								fTrue );
			Assert( pfucb->ppib->level == 1 );
			if ( err >= 0 )
				{
				err = ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush );
				}
			if ( err < 0 )
				{
				CallS( ErrDIRRollback( pfucb->ppib ) );
				}
			Assert( pfucb->ppib->level == 0 );
			CallR( err );
			}
		else
			{
			pscb->fcb.pgnoFDP = pgnoNull;
			CallR( ErrSPGetExt(	pfucb,
								pgnoSystemRoot,
								&cpgReq,
								cpgMin,
								&( pscb->fcb.pgnoFDP ),
								fTrue ) );
	 		}

		//  initialize merge process

		SORTIOptTreeInit( pscb );

		//  reset sort/merge run output

		pscb->pbfOut		= pbfNil;

		//  reset merge run input

		pscb->crunMerge		= 0;
		}

	//  begin a new run big enough to store all our data

	runinfo.cb		= pscb->cbData;
	runinfo.crec	= pscb->crecBuf;
	
	CallR( ErrSORTIRunStart( pscb, &runinfo ) );

	//  scatter-gather our sorted records into the run

	for ( ispair = 0; ispair < pscb->ispairMac; ispair++ )
		{
		//  get sort record pointer
		
		irec = pscb->rgspair[ispair].irec;
		psrec = PsrecFromPbIrec( pscb->rgbRec, irec );

		// insert record into run

		CallJ( ErrSORTIRunInsert( pscb, psrec ), EndRun );
		}

	//  end run and add to merge

	SORTIRunEnd( pscb );
	CallJ( ErrSORTIOptTreeAddRun( pscb, &runinfo ), DeleteRun );
	
	//	reinitialize the SCB for another memory sort

	pscb->ispairMac	= 0;
	pscb->irecMac	= 0;
	pscb->crecBuf	= 0;
	pscb->cbData	= 0;

	return JET_errSuccess;

EndRun:
	SORTIRunEnd( pscb );
DeleteRun:
	SORTIRunDelete( pscb, &runinfo );
	return err;
	}


//  ISORTICmpPspairPspair compares two SPAIRs for the cache optimized Quicksort.
//  Only the key prefixes are compared, unless there is a tie in which case we
//  are forced to go to the full record at the cost of several wait states.

INLINE LOCAL INT ISORTICmpPspairPspair( SCB *pscb, SPAIR *pspair1, SPAIR *pspair2 )
	{
	BYTE	*rgb1	= (BYTE *) pspair1;
	BYTE	*rgb2	= (BYTE *) pspair2;

	//  Compare prefixes first.  If they aren't equal, we're done.  Prefixes are
	//  stored in such a way as to allow very fast integer comparisons instead
	//  of byte by byte comparisons like memcmp.  Note that these comparisons are
	//  made scanning backwards.

	//  NOTE:  special case code:  cbKeyPrefix = 14, irec is first

	Assert( cbKeyPrefix == 14 );
	Assert( offsetof( SPAIR, irec ) == 0 );

#ifdef _X86_

	//  bytes 15 - 12
	if ( *( (DWORD *) ( rgb1 + 12 ) ) < *( (DWORD *) ( rgb2 + 12 ) ) )
		return -1;
	if ( *( (DWORD *) ( rgb1 + 12 ) ) > *( (DWORD *) ( rgb2 + 12 ) ) )
		return 1;

	//  bytes 11 - 8
	if ( *( (DWORD *) ( rgb1 + 8 ) ) < *( (DWORD *) ( rgb2 + 8 ) ) )
		return -1;
	if ( *( (DWORD *) ( rgb1 + 8 ) ) > *( (DWORD *) ( rgb2 + 8 ) ) )
		return 1;

	//  bytes 7 - 4
	if ( *( (DWORD *) ( rgb1 + 4 ) ) < *( (DWORD *) ( rgb2 + 4 ) ) )
		return -1;
	if ( *( (DWORD *) ( rgb1 + 4 ) ) > *( (DWORD *) ( rgb2 + 4 ) ) )
		return 1;

	//  bytes 3 - 2
	if ( *( (USHORT *) ( rgb1 + 2 ) ) < *( (USHORT *) ( rgb2 + 2 ) ) )
		return -1;
	if ( *( (USHORT *) ( rgb1 + 2 ) ) > *( (USHORT *) ( rgb2 + 2 ) ) )
		return 1;

#else  //  !_X86_

	//  bytes 15 - 8
	if ( *( (QWORD *) ( rgb1 + 8 ) ) < *( (QWORD *) ( rgb2 + 8 ) ) )
		return -1;
	if ( *( (QWORD *) ( rgb1 + 8 ) ) > *( (QWORD *) ( rgb2 + 8 ) ) )
		return 1;

	//  bytes 7 - 2
	if (	( *( (QWORD *) ( rgb1 + 0 ) ) & 0xFFFFFFFFFFFF0000 ) <
			( *( (QWORD *) ( rgb2 + 0 ) ) & 0xFFFFFFFFFFFF0000 ) )
		return -1;
	if (	( *( (QWORD *) ( rgb1 + 0 ) ) & 0xFFFFFFFFFFFF0000 ) >
			( *( (QWORD *) ( rgb2 + 0 ) ) & 0xFFFFFFFFFFFF0000 ) )
		return 1;

#endif  //  _X86_
	
	//  perform secondary comparison and return result if prefixes identical

	return ISORTICmp2PspairPspair( pscb, pspair1, pspair2 );
	}

		
LOCAL INT ISORTICmp2PspairPspair( SCB *pscb, SPAIR *pspair1, SPAIR *pspair2 )
	{
	LONG	cbKey1;
	LONG	cbKey2;
	INT		w;
	SREC	*psrec1;
	SREC	*psrec2;

	//  get the addresses of the sort records associated with these pairs
	
	psrec1 = PsrecFromPbIrec( pscb->rgbRec, pspair1->irec );
	psrec2 = PsrecFromPbIrec( pscb->rgbRec, pspair2->irec );

	//  calculate the length of full key remaining that we can compare

	cbKey1 = CbSRECKeyPscbPsrec( pscb, psrec1 );
	cbKey2 = CbSRECKeyPscbPsrec( pscb, psrec2 );

	w = min( cbKey1, cbKey2 ) - cbKeyPrefix;

	//  compare the remainder of the full keys.  if they aren't equal, done

	if ( w > 0 )
		{
		w = memcmp(	PbSRECKeyPscbPsrec( pscb, psrec1 ) + cbKeyPrefix,
					PbSRECKeyPscbPsrec( pscb, psrec2 ) + cbKeyPrefix,
					w );
		if ( w )
			return w;
		}

	//  if the keys are different lengths or this isn't an index, done

	if ( ( w = cbKey1 - cbKey2 ) || !FSCBIndex( pscb ) )
		return w;

	//  keys are identical and this is an index, so return SRID comparison

	return	*(SRID UNALIGNED *)PbSRECDataPscbPsrec( pscb, psrec1 ) -
			*(SRID UNALIGNED *)PbSRECDataPscbPsrec( pscb, psrec2 );
	}


//  Swap functions

INLINE LOCAL VOID SWAPPspair( SPAIR **ppspair1, SPAIR **ppspair2 )
	{
	SPAIR *pspairT;

	pspairT = *ppspair1;
	*ppspair1 = *ppspair2;
	*ppspair2 = pspairT;
	}


//  we do not use cache aligned memory for spairT (is this bad?)

INLINE LOCAL VOID SWAPSpair( SPAIR *pspair1, SPAIR *pspair2 )
	{
	SPAIR spairT;

	spairT = *pspair1;
	*pspair1 = *pspair2;
	*pspair2 = spairT;
	}


INLINE LOCAL VOID SWAPPsrec( SREC **ppsrec1, SREC **ppsrec2 )
	{
	SREC *psrecT;

	psrecT = *ppsrec1;
	*ppsrec1 = *ppsrec2;
	*ppsrec2 = psrecT;
	}


INLINE LOCAL VOID SWAPPmtnode( MTNODE **ppmtnode1, MTNODE **ppmtnode2 )
	{
	MTNODE *pmtnodeT;

	pmtnodeT = *ppmtnode1;
	*ppmtnode1 = *ppmtnode2;
	*ppmtnode2 = pmtnodeT;
	}


//  SORTIInsertionSort is a cache optimized version of the standard Insertion
//  sort.  It is used to sort small partitions for SORTIQuicksort because it
//  provides a statistical speed advantage over a pure Quicksort.

LOCAL VOID SORTIInsertionSort( SCB *pscb, SPAIR *pspairMinIn, SPAIR *pspairMaxIn )
	{
	SPAIR	*pspairLast;
	SPAIR	*pspairFirst;
	SPAIR	*pspairKey = pscb->rgspair + cspairSortMax;

	//  This loop is optimized so that we only scan for the current pair's new
	//  position if the previous pair in the list is greater than the current
	//  pair.  This avoids unnecessary pair copying for the key, which is
	//  expensive for sort pairs.

	for (	pspairFirst = pspairMinIn, pspairLast = pspairMinIn + 1;
			pspairLast < pspairMaxIn;
			pspairFirst = pspairLast++ )
		if ( ISORTICmpPspairPspair( pscb, pspairFirst, pspairLast ) > 0 )
			{
			//  save current pair as the "key"

			*pspairKey = *pspairLast;

			//  move previous pair into this pair's position

			*pspairLast = *pspairFirst;
			
			//  insert key into the (sorted) first part of the array (MinIn through
			//  Last - 1), moving already sorted pairs out of the way

			while (	--pspairFirst >= pspairMinIn &&
					( ISORTICmpPspairPspair( pscb, pspairFirst, pspairKey ) ) > 0 )
				*( pspairFirst + 1 ) = *pspairFirst;
			*( pspairFirst + 1 ) = *pspairKey;
			}
	}


//  SORTIQuicksort is a cache optimized Quicksort that sorts sort pair arrays
//  generated by ErrSORTInsert.  It is designed to sort large arrays of data
//  without any CPU data cache misses.  To do this, it uses a special comparator
//  designed to work with the sort pairs (see ISORTICmpPspairPspair).

LOCAL VOID SORTIQuicksort( SCB *pscb, SPAIR *pspairMinIn, SPAIR *pspairMaxIn )
	{
	//  partition stack
	struct _part
		{
		SPAIR	*pspairMin;
		SPAIR	*pspairMax;
		}	rgpart[cpartQSortMax];
	LONG	cpart		= 0;

	SPAIR	*pspairFirst;
	SPAIR	*pspairLast;

	//  current partition = partition passed in arguments

	SPAIR	*pspairMin	= pspairMinIn;
	SPAIR	*pspairMax	= pspairMaxIn;

	//  Quicksort current partition
	
	forever
		{
		//  if this partition is small enough, insertion sort it

		if ( pspairMax - pspairMin < cspairQSortMin )
			{
			SORTIInsertionSort( pscb, pspairMin, pspairMax );
			
			//  if there are no more partitions to sort, we're done

			if ( !cpart )
				break;

			//  pop a partition off the stack and make it the current partition

			pspairMin = rgpart[--cpart].pspairMin;
			pspairMax = rgpart[cpart].pspairMax;
			continue;
			}

		//  determine divisor by sorting the first, middle, and last pairs and
		//  taking the resulting middle pair as the divisor (stored in first place)

		pspairFirst	= pspairMin + ( ( pspairMax - pspairMin ) >> 1 );
		pspairLast	= pspairMax - 1;

		if ( ISORTICmpPspairPspair( pscb, pspairFirst, pspairMin ) > 0 )
			SWAPSpair( pspairFirst, pspairMin );
		if ( ISORTICmpPspairPspair( pscb, pspairFirst, pspairLast ) > 0 )
			SWAPSpair( pspairFirst, pspairLast );
		if ( ISORTICmpPspairPspair( pscb, pspairMin, pspairLast ) > 0 )
			SWAPSpair( pspairMin, pspairLast );

		//  sort large partition into two smaller partitions (<=, >)
		//
		//  NOTE:  we are not sorting the two end pairs as the first pair is the
		//  divisor and the last pair is already known to be > the divisor

		pspairFirst = pspairMin + 1;
		pspairLast--;

		Assert( pspairFirst <= pspairLast );
		
		forever
			{
			//  advance past all pairs <= the divisor
			
			while (	pspairFirst <= pspairLast &&
					ISORTICmpPspairPspair( pscb, pspairFirst, pspairMin ) <= 0 )
				pspairFirst++;

			//  advance past all pairs > the divisor
			
			while (	pspairFirst <= pspairLast &&
					ISORTICmpPspairPspair( pscb, pspairLast, pspairMin ) > 0 )
				pspairLast--;

			//  if we have found a pair to swap, swap them and continue

			Assert( pspairFirst != pspairLast );
			
			if ( pspairFirst < pspairLast )
				SWAPSpair( pspairFirst++, pspairLast-- );

			//  no more pairs to compare, partitioning complete
			
			else
				break;
			}

		//  place the divisor at the end of the <= partition

		if ( pspairLast != pspairMin )
			SWAPSpair( pspairMin, pspairLast );

		//  set first/last to delimit larger partition (as min/max) and set
		//  min/max to delimit smaller partition for next iteration

		if ( pspairMax - pspairLast - 1 > pspairLast - pspairMin )
			{
			pspairFirst	= pspairLast + 1;
			SWAPPspair( &pspairLast, &pspairMax );
			}
		else
			{
			pspairFirst	= pspairMin;
			pspairMin	= pspairLast + 1;
			}

		//  push the larger partition on the stack (recurse if there is no room)

		if ( cpart < cpartQSortMax )
			{
			rgpart[cpart].pspairMin		= pspairFirst;
			rgpart[cpart++].pspairMax	= pspairLast;
			}
		else
			SORTIQuicksort( pscb, pspairFirst, pspairLast );
		}
	}

//  Create a new run with the supplied parameters.  The new run's id and size
//  in pages is returned on success

LOCAL ERR ErrSORTIRunStart( SCB *pscb, RUNINFO *pruninfo )
	{
	ERR		err;
#if defined( DEBUG ) || defined( PERFDUMP )
	char	szT[256];
#endif

	//  allocate space for new run according to given info

	pruninfo->cpgUsed	= ( pruninfo->cb + cbFreeSPAGE - 1 ) / cbFreeSPAGE;
	pruninfo->cpg		= pruninfo->cpgUsed;
	pruninfo->run		= runNull;
	CallR( ErrSPGetExt(	pscb->fcb.pfucb,
						pscb->fcb.pgnoFDP,
						&pruninfo->cpg,
						pruninfo->cpgUsed,
						&pruninfo->run,
						fFalse ) );

	Assert( pruninfo->cpg >= pruninfo->cpgUsed );

	//  initialize output run data

	pscb->pgnoNext	= pruninfo->run;
	pscb->pbfOut	= pbfNil;
	pscb->pbOutMac	= NULL;
	pscb->pbOutMax	= NULL;

#if defined( DEBUG ) || defined( PERFDUMP )
	sprintf(	szT,
				"  RUN:  start %ld  cpg %ld  cb %ld  crec %ld  cpgAlloc %ld",
				pruninfo->run,
				pruninfo->cpgUsed,
				pruninfo->cb,
				pruninfo->crec,
				pruninfo->cpg );
	UtilPerfDumpStats( szT );
#endif

	return JET_errSuccess;
	}


//  Inserts the given record into the run.  Records are stored compactly and
//  are permitted to cross page boundaries to avoid wasted space.

LOCAL ERR ErrSORTIRunInsert( SCB *pscb, SREC *psrec )
	{
	ERR	  	err;
	LONG	cb;
	PGNO	pgnoNext;
	SPAGE	*pspage;
	LONG	cbToWrite;

	//  assumption:  record size < free sort page data size (and is valid)

	Assert(	CbSRECSizePscbPsrec( pscb, psrec ) > CbSRECSizePscbCbCb( pscb, 0, 0 ) &&
			CbSRECSizePscbPsrec( pscb, psrec ) < cbFreeSPAGE );

	//  calculate number of bytes that will fit on the current page

	cb = min(	(LONG)(pscb->pbOutMax - pscb->pbOutMac),
				(LONG) CbSRECSizePscbPsrec( pscb, psrec ) );

	//  if some data will fit, write it

	if ( cb )
		{
		memcpy( pscb->pbOutMac, psrec, cb );
		pscb->pbOutMac += cb;
		}

	//  if all the data fit, save the offset of the unbroken SREC and return

	if ( cb == (LONG) CbSRECSizePscbPsrec( pscb, psrec ) )
		{

#ifdef PRED_PREREAD

		pspage = (SPAGE *) pscb->pbfOut->ppage;
		pspage->ibLastSREC = (USHORT) ( pscb->pbOutMac - cb - (BYTE *) pspage );

#endif  //  PRED_PREREAD

		return JET_errSuccess;
		}

	//  page is full, so release it so it can be lazily-written to disk

	if ( pscb->pbfOut != pbfNil )
		{
		BFResetWriteLatch( pscb->pbfOut, pscb->fcb.pfucb->ppib );
		pscb->pbfOut = pbfNil;
		}

	//  allocate a buffer for the next page in the run and latch it
	
	pgnoNext = pscb->pgnoNext++;
	CallR( ErrBFAllocPageBuffer(	pscb->fcb.pfucb->ppib,
									&pscb->pbfOut,
									PnOfDbidPgno( pscb->fcb.pfucb->dbid, pgnoNext ),
									lgposMax,
									pgtypSort ) );
	BFSetWriteLatch( pscb->pbfOut, pscb->fcb.pfucb->ppib );
	BFSetDirtyBit( pscb->pbfOut );

	//  initialize page

	pspage = (SPAGE *) pscb->pbfOut->ppage;

#ifdef PRED_PREREAD
	pspage->ibLastSREC = 0;
#endif  //  PRED_PREREAD
	pspage->pgtyp = pgtypSort;
	ThreeBytesFromL( &pspage->pgnoThisPage, pgnoNext );

	//  initialize data pointers for this page

	pscb->pbOutMac = PbDataStartPspage( pspage );
	pscb->pbOutMax = PbDataEndPspage( pspage );

	//  write the remainder of the data to this page

	cbToWrite = CbSRECSizePscbPsrec( pscb, psrec ) - cb;
	memcpy( pscb->pbOutMac, ( (BYTE *) psrec ) + cb, cbToWrite );
	pscb->pbOutMac += cbToWrite;

#ifdef PRED_PREREAD

	//  if this SREC fit entirely on this page, set offset

	if ( !cb )
		pspage->ibLastSREC = (USHORT) ( pscb->pbOutMac - cbToWrite - (BYTE *) pspage );

#endif  //  PRED_PREREAD

	return JET_errSuccess;
	}


//  ends current output run

LOCAL VOID SORTIRunEnd( SCB *pscb )
	{
	//  unlatch page so it can be lazily-written to disk

	BFResetWriteLatch( pscb->pbfOut, pscb->fcb.pfucb->ppib );
	pscb->pbfOut = pbfNil;
	}


//  Deletes a run from disk.  No error is returned because if delete fails,
//  it is not fatal (only wasted space in the temporary database).

INLINE LOCAL VOID SORTIRunDelete( SCB *pscb, RUNINFO *pruninfo )
	{
	//  delete run

	CallS( ErrSPFreeExt(	pscb->fcb.pfucb,
							pscb->fcb.pgnoFDP,
							pruninfo->run,
							pruninfo->cpg ) );
	}


//  Deletes crun runs in the specified run list, if possible

LOCAL VOID	SORTIRunDeleteList( SCB *pscb, RUNLINK **pprunlink, LONG crun )
	{
	RUNLINK	*prunlinkT;
	LONG	irun;

	//  walk list, deleting runs

	for ( irun = 0; *pprunlink != prunlinkNil && irun < crun; irun++ )
		{
		//  delete run
		
		SORTIRunDelete( pscb, &( *pprunlink )->runinfo );

		//  get next run to free

		prunlinkT = *pprunlink;
		*pprunlink = ( *pprunlink )->prunlinkNext;

		//  free RUNLINK

		RUNLINKReleasePrcb( prunlinkT );
		}
	}


//  Deletes the memory for crun runs in the specified run list, but does not
//  bother to delete the runs from disk

LOCAL VOID	SORTIRunDeleteListMem( SCB *pscb, RUNLINK **pprunlink, LONG crun )
	{
	RUNLINK	*prunlinkT;
	LONG	irun;

	//  walk list, deleting runs

	for ( irun = 0; *pprunlink != prunlinkNil && irun < crun; irun++ )
		{
		//  get next run to free

		prunlinkT = *pprunlink;
		*pprunlink = ( *pprunlink )->prunlinkNext;

		//  free RUNLINK

		RUNLINKReleasePrcb( prunlinkT );
		}
	}


//  Opens the specified run for reading.

LOCAL ERR ErrSORTIRunOpen( SCB *pscb, RUNINFO *pruninfo, RCB **pprcb )
	{
	ERR		err;
	RCB		*prcb	= prcbNil;
	LONG	ipbf;
	CPG		cpgRead;
	CPG		cpgT;
	
	//  allocate a new RCB

	if ( ( prcb = PrcbRCBAlloc() ) == prcbNil )
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );

	//  initialize RCB

	prcb->pscb = pscb;
	prcb->runinfo = *pruninfo;
	
	for ( ipbf = 0; ipbf < cpgClusterSize; ipbf++ )
		prcb->rgpbf[ipbf] = pbfNil;

	prcb->ipbf			= cpgClusterSize;
	prcb->pbInMac		= NULL;
	prcb->pbInMax		= NULL;
	prcb->cbRemaining	= prcb->runinfo.cb;
#ifdef PRED_PREREAD
	prcb->psrecPred		= psrecNegInf;
#endif  //  PRED_PREREAD
	prcb->pbfAssy		= pbfNil;

	//  preread the first part of the run, to be access paged later as required

#ifdef PRED_PREREAD

	cpgRead = min( prcb->runinfo.cpgUsed, cpgClusterSize );

#else  //  !PRED_PREREAD

	cpgRead = min( prcb->runinfo.cpgUsed, 2 * cpgClusterSize );

#endif  //  PRED_PREREAD

	BFPreread(	PnOfDbidPgno(	pscb->fcb.pfucb->dbid,
								(PGNO) prcb->runinfo.run ),
				cpgRead,
				&cpgT );

	//  return the initialized RCB

	*pprcb = prcb;
	return JET_errSuccess;

HandleError:
	*pprcb = prcbNil;
	return err;
	}


//  Returns next record in opened run (the first if the run was just opened).
//  Returns JET_errNoCurrentRecord if all records have been read.  The record
//  retrieved during the previous call is guaranteed to still be in memory
//  after this call for the purpose of duplicate removal comparisons.
//
//  Special care must be taken when reading the records because they could
//  be broken at arbitrary points across page boundaries.  If this happens,
//  the record is assembled in a temporary buffer, to which the pointer is
//  returned.  This memory is freed by this function or ErrSORTIRunClose.

LOCAL ERR ErrSORTIRunNext( RCB *prcb, SREC **ppsrec )
	{
	ERR		err;
	SCB		*pscb = prcb->pscb;
	SHORT	cbUnread;
	SHORT	cbRec;
	SPAGE	*pspage;
	LONG	ipbf;
	PGNO	pgnoNext;
	CPG		cpgRead;
	CPG		cpgT;
	SHORT	cbToRead;
#ifdef PRED_PREREAD
	RCB		*prcbMin;
	RCB		*prcbT;
	LONG	irun;
#endif  //  PRED_PREREAD

	//  free second to last assembly buffer, if present, and make last
	//  assembly buffer the second to last assembly buffer

	if ( FSCBUnique( pscb ) )
		{
		if ( pscb->pbfAssyLast != pbfNil )
			BFSFree( pscb->pbfAssyLast );
		pscb->pbfAssyLast = prcb->pbfAssy;
		}
	else
		{
		if ( prcb->pbfAssy != pbfNil )
			BFSFree( prcb->pbfAssy );
		}
	prcb->pbfAssy = pbfNil;

	//  abandon last buffer, if present

	if ( pscb->pbfLast != pbfNil )
		{
		BFUnpin( pscb->pbfLast );
		BFAbandon( ppibNil, pscb->pbfLast );
		pscb->pbfLast = pbfNil;
		}
	
	//  are there no more records to read?

	if ( !prcb->cbRemaining )
		{
		//  make sure we don't hold on to the last page of the run

		if ( prcb->rgpbf[prcb->ipbf] != pbfNil )
			{
			if ( FSCBUnique( pscb ) )
				pscb->pbfLast = prcb->rgpbf[prcb->ipbf];
			else
				{
				BFUnpin( prcb->rgpbf[prcb->ipbf] );
				BFAbandon( ppibNil, prcb->rgpbf[prcb->ipbf] );
				}
			prcb->rgpbf[prcb->ipbf] = pbfNil;
			}
			
		//  return No Current Record
		
		Error( ErrERRCheck( JET_errNoCurrentRecord ), HandleError );
		}
	
	//  calculate size of unread data still in page

	cbUnread = (SHORT)(prcb->pbInMax - prcb->pbInMac);

	//  is there any more data on this page?

	if ( cbUnread )
		{
		//  if the record is entirely on this page, return it

		if (	cbUnread > cbSRECReadMin &&
				(LONG) CbSRECSizePscbPsrec( pscb, (SREC *) prcb->pbInMac ) <= cbUnread )
			{
			cbRec = (SHORT) CbSRECSizePscbPsrec( pscb, (SREC *) prcb->pbInMac );
			*ppsrec = (SREC *) prcb->pbInMac;
			prcb->pbInMac += cbRec;
			prcb->cbRemaining -= cbRec;
			Assert( prcb->cbRemaining >= 0 );
			return JET_errSuccess;
			}

		//  allocate a new assembly buffer

		Call( ErrBFAllocTempBuffer( &prcb->pbfAssy ) );

		//  copy what there is of the record on this page into assembly buffer

		memcpy( prcb->pbfAssy->ppage, prcb->pbInMac, cbUnread );
		prcb->cbRemaining -= cbUnread;
		Assert( prcb->cbRemaining >= 0 );
		}

	//  get next page number

	if ( prcb->ipbf < cpgClusterSize )
		{
		//  next page is sequentially after the used up buffer's page number
		
		LFromThreeBytes( &pgnoNext, &( prcb->rgpbf[prcb->ipbf]->ppage->pgnoThisPage ) );
		pgnoNext++;
		
		//  move the used up buffer to the last buffer
		//  to guarantee validity of record read last call

		if ( FSCBUnique( pscb ) )
			{
			pscb->pbfLast = prcb->rgpbf[prcb->ipbf];
			}

		//  we don't need to save the used up buffer, so abandon it
		
		else
			{
			BFUnpin( prcb->rgpbf[prcb->ipbf] );
			BFAbandon( ppibNil, prcb->rgpbf[prcb->ipbf] );
			}

		prcb->rgpbf[prcb->ipbf] = pbfNil;
		}
	else
		{
		//  no pages are resident yet, so next page is the first page in the run
		
		pgnoNext = (PGNO) prcb->runinfo.run;
		}

	//  is there another pinned buffer available?

	if ( ++prcb->ipbf < cpgClusterSize )
		{
		//  yes, then this pbf should never be null

		Assert( prcb->rgpbf[prcb->ipbf] != pbfNil );
		
		//  set new page data pointers

		pspage = (SPAGE *) prcb->rgpbf[prcb->ipbf]->ppage;
		prcb->pbInMac = PbDataStartPspage( pspage );
		prcb->pbInMax = PbDataEndPspage( pspage );
		}
	else
		{
		//  no, get and pin all buffers that were read ahead last time

		cpgRead = min(	(LONG) ( prcb->runinfo.run + prcb->runinfo.cpgUsed - pgnoNext ),
						cpgClusterSize );
		Assert( cpgRead > 0 );
		
		for ( ipbf = 0; ipbf < cpgRead; ipbf++ )
			Call( ErrSORTIRunReadPage( prcb, pgnoNext + ipbf, ipbf ) );

		//  set new page data pointers

		prcb->ipbf		= 0;
		pspage			= (SPAGE *) prcb->rgpbf[prcb->ipbf]->ppage;
		prcb->pbInMac	= PbDataStartPspage( pspage );
		prcb->pbInMax	= PbDataEndPspage( pspage );
#ifdef PRED_PREREAD
		pspage			= (SPAGE *) prcb->rgpbf[cpgRead - 1]->ppage;
		if (	pspage->ibLastSREC == 0 ||
				pgnoNext + cpgRead == prcb->runinfo.run + prcb->runinfo.cpgUsed )
			prcb->psrecPred = psrecInf;
		else
			prcb->psrecPred = (SREC *) ( (BYTE *) pspage + pspage->ibLastSREC );
#endif  //  PRED_PREREAD

#ifdef PRED_PREREAD

		//  Loop to find run where the key of the last unbroken SREC is
		//  the least.  This will be the first run to need more data from
		//  disk and therefore the one we will preread from now.  A psrecInf
		//  psrecPred indicates that we should NOT preread for that run.
		//  A psrecNegInf psrecPred means that a run hasn't been initialized
		//  yet, so we should not start prereading yet.

		prcbMin = pscb->rgmtnode[0].prcb;
		for ( irun = 1; irun < pscb->crunMerge; irun++ )
			{
			prcbT = pscb->rgmtnode[irun].prcb;
			if ( prcbT->psrecPred == psrecNegInf )
				{
				prcbMin = prcbT;
				break;
				}
			if ( prcbT->psrecPred == psrecInf )
				continue;
			if (	prcbMin->psrecPred == psrecInf ||
					ISORTICmpPsrecPsrec(	pscb,
											prcbT->psrecPred,
											prcbMin->psrecPred ) < 0 )
				prcbMin = prcbT;
			}

		//  issue prefetch for next cluster of chosen run (if needed)

		if ( prcbMin->psrecPred != psrecNegInf && prcbMin->psrecPred != psrecInf )
			{
			LFromThreeBytes( &pgnoNext, &( prcbMin->rgpbf[cpgClusterSize - 1]->ppage->pgnoThisPage ) );
			pgnoNext++;
			cpgRead = min(	(LONG) ( prcbMin->runinfo.run + prcbMin->runinfo.cpgUsed - pgnoNext ),
							cpgClusterSize );
			if ( cpgRead > 0 )
				{
				Assert( pgnoNext >= prcbMin->runinfo.run );
				Assert(	pgnoNext + cpgRead - 1 <=
						prcbMin->runinfo.run + prcbMin->runinfo.cpgUsed - 1 );
				BFPreread(	PnOfDbidPgno(	pscb->fcb.pfucb->dbid,
											pgnoNext ),
							cpgRead,
							&cpgT );
				}
			}

#else  //  !PRED_PREREAD
		
		//  issue prefetch for next cluster (if needed)

		pgnoNext += cpgClusterSize;
		cpgRead = min(	(LONG) ( prcb->runinfo.run + prcb->runinfo.cpgUsed - pgnoNext ),
						cpgClusterSize );
		if ( cpgRead > 0 )
			{
			Assert( pgnoNext >= prcb->runinfo.run );
			Assert(	pgnoNext + cpgRead - 1 <=
					prcb->runinfo.run + prcb->runinfo.cpgUsed - 1 );
			BFPreread(	PnOfDbidPgno(	pscb->fcb.pfucb->dbid,
										pgnoNext ),
						cpgRead,
						&cpgT );
			}

#endif  //  PRED_PREREAD

		}

	//  if there was no data last time, entire record must be at the top of the
	//  page, so return it

	if ( !cbUnread )
		{
		cbRec = (SHORT) CbSRECSizePscbPsrec( pscb, (SREC *) prcb->pbInMac );
		Assert( cbRec > (LONG) CbSRECSizePscbCbCb( pscb, 0, 0 ) && cbRec < cbFreeSPAGE );
		*ppsrec = (SREC *) prcb->pbInMac;
		prcb->pbInMac += cbRec;
		prcb->cbRemaining -= cbRec;
		Assert( prcb->cbRemaining >= 0 );
		return JET_errSuccess;
		}

	//  if we couldn't get the record size from the last page, copy enough data
	//  to the assembly buffer to get the record size

	if ( cbUnread < cbSRECReadMin )
		memcpy(	( (BYTE *) prcb->pbfAssy->ppage ) + cbUnread,
				prcb->pbInMac,
				cbSRECReadMin - cbUnread );

	//  if not, copy remainder of record into assembly buffer

	cbToRead = (SHORT) (CbSRECSizePscbPsrec( pscb, (SREC *) prcb->pbfAssy->ppage ) - cbUnread);
	memcpy( ( (BYTE *) prcb->pbfAssy->ppage ) + cbUnread, prcb->pbInMac, cbToRead );
	prcb->pbInMac += cbToRead;
	prcb->cbRemaining -= cbToRead;
	Assert( prcb->cbRemaining >= 0 );

	//  return pointer to assembly buffer

	*ppsrec = (SREC *) prcb->pbfAssy->ppage;
	return JET_errSuccess;

HandleError:
	for ( ipbf = 0; ipbf < cpgClusterSize; ipbf++ )
		if ( prcb->rgpbf[ipbf] != pbfNil )
			{
			BFUnpin( prcb->rgpbf[ipbf] );
			BFAbandon( ppibNil, prcb->rgpbf[ipbf] );
			prcb->rgpbf[ipbf] = pbfNil;
			}
	*ppsrec = NULL;
	return err;
	}


//  Closes an opened run

LOCAL VOID SORTIRunClose( RCB *prcb )
	{
	LONG	ipbf;
	
	//  free record assembly buffer

	if ( prcb->pbfAssy != pbfNil )
		BFSFree( prcb->pbfAssy );

	//  unpin all read-ahead buffers
	
	for ( ipbf = 0; ipbf < cpgClusterSize; ipbf++ )
		if ( prcb->rgpbf[ipbf] != pbfNil )
			{
			BFUnpin( prcb->rgpbf[ipbf] );
			BFAbandon( ppibNil, prcb->rgpbf[ipbf] );
			prcb->rgpbf[ipbf] = pbfNil;
			}

	//  free RCB
	
	RCBReleasePrcb( prcb );
	}


//  get read access to a page in a run (buffer is pinned in memory)

INLINE LOCAL ERR ErrSORTIRunReadPage( RCB *prcb, PGNO pgno, LONG ipbf )
{
	ERR		err;

	//  verify that we are trying to read a page that is used in the run

	Assert( pgno >= prcb->runinfo.run );
	Assert( pgno < prcb->runinfo.run + prcb->runinfo.cpgUsed );
	
	//  read page

	CallR( ErrBFAccessPage(	prcb->pscb->fcb.pfucb->ppib,
							prcb->rgpbf + ipbf,
							PnOfDbidPgno( prcb->pscb->fcb.pfucb->dbid, pgno ) ) );

	//  pin buffer in memory

	BFPin( prcb->rgpbf[ipbf] );

	//  verify that this is a sort page

	Assert( ( (SPAGE *) prcb->rgpbf[ipbf]->ppage )->pgtyp == pgtypSort );

	return JET_errSuccess;
	}


//  Merges the specified number of runs from the source list into a new run in
//  the destination list

LOCAL ERR ErrSORTIMergeToRun( SCB *pscb, RUNLINK *prunlinkSrc, RUNLINK **pprunlinkDest )
	{
	ERR		err;
	LONG	irun;
	LONG	cbRun;
	LONG	crecRun;
	RUNLINK	*prunlink = prunlinkNil;
	SREC	*psrec;

	//  start merge and set to not remove duplicates (we wait until the last
	//  merge to remove duplicates to save time)

	CallR( ErrSORTIMergeStart( pscb, prunlinkSrc, fFalse ) );

	//  calculate new run size

	for ( cbRun = 0, crecRun = 0, irun = 0; irun < pscb->crunMerge; irun++ )
		{
		cbRun += pscb->rgmtnode[irun].prcb->runinfo.cb;
		crecRun += pscb->rgmtnode[irun].prcb->runinfo.crec;
		}

	//  create a new run to receive merge data

	if ( ( prunlink = PrunlinkRUNLINKAlloc() ) == prunlinkNil )
		Error( ErrERRCheck( JET_errOutOfMemory ), EndMerge );

	prunlink->runinfo.cb = cbRun;
	prunlink->runinfo.crec = crecRun;
	
	CallJ( ErrSORTIRunStart( pscb, &prunlink->runinfo ), FreeRUNLINK );

	//  stream data from merge into run

	while ( ( err = ErrSORTIMergeNext( pscb, &psrec ) ) >= 0 )
		CallJ( ErrSORTIRunInsert( pscb, psrec ), DeleteRun );

	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto DeleteRun;

	SORTIRunEnd( pscb );
	SORTIMergeEnd( pscb );

	//  add new run to destination run list

	prunlink->prunlinkNext = *pprunlinkDest;
	*pprunlinkDest = prunlink;

	return JET_errSuccess;

DeleteRun:
	SORTIRunEnd( pscb );
	SORTIRunDelete( pscb, &prunlink->runinfo );
FreeRUNLINK:
	RUNLINKReleasePrcb( prunlink );
EndMerge:
	SORTIMergeEnd( pscb );
	return err;
	}


/*	starts an n-way merge of the first n runs from the source run list.  The merge
/*	will remove duplicate values from the output if desired.
/**/
LOCAL ERR ErrSORTIMergeStart( SCB *pscb, RUNLINK *prunlinkSrc, BOOL fUnique )
	{
	ERR		err;
	RUNLINK	*prunlink;
	LONG	crun;
	LONG	irun;
	MTNODE	*pmtnode;
#if defined( DEBUG ) || defined( PERFDUMP )
	char	szT[1024];
#endif

	/*	if termination in progress, then fail sort
	/**/
	if ( fTermInProgress )
		return ErrERRCheck( JET_errTermInProgress );

	/*	determine number of runs to merge
	/**/
	prunlink = prunlinkSrc;
	crun = 1;
	while ( prunlink->prunlinkNext != prunlinkNil )
		{
		prunlink = prunlink->prunlinkNext;
		crun++;
		}

	/*	we only support merging two or more runs
	/**/
	Assert( crun > 1 );

	/*	init merge data in SCB
	/**/
	pscb->crunMerge		= crun;
	pscb->fUnique		= fUnique;
	pscb->pbfLast		= pbfNil;
	pscb->pbfAssyLast	= pbfNil;

#if defined( DEBUG ) || defined( PERFDUMP )
	sprintf( szT, "MERGE:  %ld runs -", crun );
#endif
	
	/*	initialize merge tree
	/**/
	prunlink = prunlinkSrc;
	for ( irun = 0; irun < crun; irun++ )
		{
		//  initialize external node

		pmtnode = pscb->rgmtnode + irun;
		Call( ErrSORTIRunOpen( pscb, &prunlink->runinfo, &pmtnode->prcb ) );
		pmtnode->pmtnodeExtUp = pscb->rgmtnode + ( irun + crun ) / 2;
		
		//  initialize internal node

		pmtnode->psrec = psrecNegInf;
		pmtnode->pmtnodeSrc = pmtnode;
		pmtnode->pmtnodeIntUp = pscb->rgmtnode + irun / 2;
		
#if defined( DEBUG ) || defined( PERFDUMP )
		sprintf(	szT + strlen( szT ),
					" %ld(%ld)",
					pmtnode->prcb->runinfo.run,
					pmtnode->prcb->runinfo.cpgUsed );
#endif

		//  get next run to open

		prunlink = prunlink->prunlinkNext;
		}

#if defined( DEBUG ) || defined( PERFDUMP )
	UtilPerfDumpStats( szT );
#endif

	return JET_errSuccess;

HandleError:
	pscb->crunMerge = 0;
	for ( irun--; irun >= 0; irun-- )
		SORTIRunClose( pscb->rgmtnode[irun].prcb );
	return err;
	}


//  Returns the first record of the current merge.  This function can be called
//  any number of times before ErrSORTIMergeNext is called to return the first
//  record, but it cannot be used to rewind to the first record after
//  ErrSORTIMergeNext is called.

LOCAL ERR ErrSORTIMergeFirst( SCB *pscb, SREC **ppsrec )
	{
	ERR		err;
	
	//  if the tree still has init records, read past them to first record

	while ( pscb->rgmtnode[0].psrec == psrecNegInf )
		Call( ErrSORTIMergeNextChamp( pscb, ppsrec ) );

	//  return first record

	*ppsrec = pscb->rgmtnode[0].psrec;

	return JET_errSuccess;

HandleError:
	Assert( err != JET_errNoCurrentRecord );
	*ppsrec = NULL;
	return err;
	}


//  Returns the next record of the current merge, or JET_errNoCurrentRecord
//  if no more records are available.  You can call this function without
//  calling ErrSORTIMergeFirst to get the first record.

LOCAL ERR ErrSORTIMergeNext( SCB *pscb, SREC **ppsrec )
	{
	ERR		err;
	SREC	*psrecLast;
	
	//  if the tree still has init records, return first record

	if ( pscb->rgmtnode[0].psrec == psrecNegInf )
		return ErrSORTIMergeFirst( pscb, ppsrec );

	//  get next record, performing duplicate removal if requested

	if ( !pscb->fUnique )
		return ErrSORTIMergeNextChamp( pscb, ppsrec );

	do	{
		psrecLast = pscb->rgmtnode[0].psrec;
		CallR( ErrSORTIMergeNextChamp( pscb, ppsrec ) );
		}
	while (!ISORTICmpKeyStSt(	StSRECKeyPscbPsrec( pscb, *ppsrec ),
								StSRECKeyPscbPsrec( pscb, psrecLast ) ) );

	return JET_errSuccess;
	}


//  Ends the current merge operation

LOCAL VOID SORTIMergeEnd( SCB *pscb )
	{
	LONG	irun;

	//  free / abandon BFs
	
	if ( pscb->pbfLast != pbfNil )
		{
		BFUnpin( pscb->pbfLast );
		BFAbandon( ppibNil, pscb->pbfLast );
		pscb->pbfLast = pbfNil;
		}
	if ( pscb->pbfAssyLast != pbfNil )
		{
		BFSFree( pscb->pbfAssyLast );
		pscb->pbfAssyLast = pbfNil;
		}

	//  close all input runs
	
	for ( irun = 0; irun < pscb->crunMerge; irun++ )
		SORTIRunClose( pscb->rgmtnode[irun].prcb );
	pscb->crunMerge = 0;
	}


//  ISORTICmpPsrecPsrec compares two SRECs for the replacement-selection sort.

INLINE LOCAL INT ISORTICmpPsrecPsrec( SCB *pscb, SREC *psrec1, SREC *psrec2 )
	{
	INT		w;

	//  if the full keys are different or this isn't an index, done

	w = ISORTICmpKeyStSt(	StSRECKeyPscbPsrec( pscb, psrec1 ),
							StSRECKeyPscbPsrec( pscb, psrec2 ) );
	if ( w || !FSCBIndex( pscb ) )
		return w;

	//  keys are identical and this is an index, so return SRID comparison

	return	*(SRID UNALIGNED *)PbSRECDataPscbPsrec( pscb, psrec1 ) -
			*(SRID UNALIGNED *)PbSRECDataPscbPsrec( pscb, psrec2 );
	}


//  Returns next champion of the replacement-selection tournament on input
//  data.  If there is no more data, it will return JET_errNoCurrentRecord.
//  The tree is stored in losers' representation, meaning that the loser of
//  each tournament is stored at each node, not the winner.

LOCAL ERR ErrSORTIMergeNextChamp( SCB *pscb, SREC **ppsrec )
	{
	ERR		err;
	MTNODE	*pmtnodeChamp;
	MTNODE	*pmtnodeLoser;

	//  goto exterior source node of last champ

	pmtnodeChamp = pscb->rgmtnode + 0;
	pmtnodeLoser = pmtnodeChamp->pmtnodeSrc;

	//  read next record (or lack thereof) from input run as the new
	//  contender for champ

	*ppsrec = NULL;
	err = ErrSORTIRunNext( pmtnodeLoser->prcb, &pmtnodeChamp->psrec );
	if ( err < 0 && err != JET_errNoCurrentRecord )
		return err;

	//  go up tree to first internal node

	pmtnodeLoser = pmtnodeLoser->pmtnodeExtUp;

	//  select the new champion by walking up the tree, swapping for lower
	//  and lower keys (or sentinel values)

	do	{
		//  if loser is psrecInf or champ is psrecNegInf, do not swap (if this
		//  is the case, we can't do better than we have already)

		if ( pmtnodeLoser->psrec == psrecInf || pmtnodeChamp->psrec == psrecNegInf )
			continue;

		//  if the loser is psrecNegInf or the current champ is psrecInf, or the
		//  loser is less than the champ, swap records

		if (	pmtnodeChamp->psrec == psrecInf ||
				pmtnodeLoser->psrec == psrecNegInf ||
				ISORTICmpPsrecPsrec(	pscb,
										pmtnodeLoser->psrec,
										pmtnodeChamp->psrec ) < 0 )
			{
			SWAPPsrec( &pmtnodeLoser->psrec, &pmtnodeChamp->psrec );
			SWAPPmtnode( &pmtnodeLoser->pmtnodeSrc, &pmtnodeChamp->pmtnodeSrc );
			}
		}
	while ( ( pmtnodeLoser = pmtnodeLoser->pmtnodeIntUp ) != pmtnodeChamp );

	//  return the new champion

	if ( ( *ppsrec = pmtnodeChamp->psrec ) == NULL )
		return ErrERRCheck( JET_errNoCurrentRecord );

	return JET_errSuccess;
	}


//  initializes optimized tree merge

LOCAL VOID SORTIOptTreeInit( SCB *pscb )
	{
	//  initialize runlist

	pscb->runlist.prunlinkHead		= prunlinkNil;
	pscb->runlist.crun				= 0;

#if defined( DEBUG ) || defined( PERFDUMP )
		UtilPerfDumpStats( "MERGE:  Optimized Tree Merge Initialized" );
#endif
	}


//  adds an initial run to be merged by optimized tree merge process

LOCAL ERR ErrSORTIOptTreeAddRun( SCB *pscb, RUNINFO *pruninfo )
	{
	RUNLINK	*prunlink;

	//  allocate and build a new RUNLINK for the new run

	if ( ( prunlink = PrunlinkRUNLINKAlloc() ) == prunlinkNil )
		return ErrERRCheck( JET_errOutOfMemory );
	prunlink->runinfo = *pruninfo;

	//  add the new run to the disk-resident runlist
	//
	//  NOTE:  by adding at the head of the list, we will guarantee that the
	//         list will be in ascending order by record count

	prunlink->prunlinkNext = pscb->runlist.prunlinkHead;
	pscb->runlist.prunlinkHead = prunlink;
	pscb->runlist.crun++;
	pscb->crun++;

	return JET_errSuccess;
	}


//  Performs an optimized tree merge of all runs previously added with
//  ErrSORTIOptTreeAddRun down to the last merge level (which is reserved
//  to be computed through the SORT iterators).  This algorithm is designed
//  to use the maximum fan-in as much as possible.

LOCAL ERR ErrSORTIOptTreeMerge( SCB *pscb )
	{
	ERR		err;
	OTNODE	*potnode = potnodeNil;
	
	//  If there are less than or equal to crunFanInMax runs, there is only
	//  one merge level -- the last one, which is to be done via the SORT
	//  iterators.  We are done.

	if ( pscb->runlist.crun <= crunFanInMax )
		return JET_errSuccess;

	//  build the optimized tree merge tree

	CallR( ErrSORTIOptTreeBuild( pscb, &potnode ) );

	//  perform all but the final merge

	Call( ErrSORTIOptTreeMergeDF( pscb, potnode, NULL ) );

	//  update the runlist information for the final merge

	Assert( pscb->runlist.crun == 0 );
	Assert( pscb->runlist.prunlinkHead == prunlinkNil );
	Assert( potnode->runlist.crun == crunFanInMax );
	Assert( potnode->runlist.prunlinkHead != prunlinkNil );
	pscb->runlist = potnode->runlist;

	//  free last node and return

	OTNODEReleasePotnode( potnode );
	return JET_errSuccess;

HandleError:
	if ( potnode != potnodeNil )
		{
		SORTIOptTreeFree( pscb, potnode );
		OTNODEReleasePotnode( potnode );
		}
	return err;
	}


//  free all optimized tree merge resources

LOCAL VOID SORTIOptTreeTerm( SCB *pscb )
	{
	//  delete all runlists

	SORTIRunDeleteListMem( pscb, &pscb->runlist.prunlinkHead, crunAll );
	}


//  Builds the optimized tree merge tree by level in such a way that we use the
//  maximum fan-in as often as possible and the smallest merges (by length in
//  records) will be on the left side of the tree (smallest index in the array).
//  This will provide very high BF cache locality when the merge is performed
//  depth first, visiting subtrees left to right.

LOCAL ERR ErrSORTIOptTreeBuild( SCB *pscb, OTNODE **ppotnode )
	{
	ERR		err;
	OTNODE	*potnodeAlloc	= potnodeNil;
	OTNODE	*potnodeT;
	OTNODE	*potnodeLast2;
	LONG	crunLast2;
	OTNODE	*potnodeLast;
	LONG	crunLast;
	OTNODE	*potnodeThis;
	LONG	crunThis;
	LONG	crunFanInFirst;
	OTNODE	*potnodeFirst;
	LONG	ipotnode;
	LONG	irun;

	//  Set the original number of runs left for us to use.  If a last level
	//  pointer is potnodeLevel0, this means that we should use original runs for
	//  making the new merge level.  These runs come from this number.  We do
	//  not actually assign original runs to merge nodes until we actually
	//  perform the merge.

	potnodeLast2	= potnodeNil;
	crunLast2		= 0;
	potnodeLast		= potnodeLevel0;
	crunLast		= pscb->crun;
	potnodeThis		= potnodeNil;
	crunThis		= 0;

	//  create levels until the last level has only one node (the root node)

	do	{
		//  Create the first merge of this level, using a fan in that will result
		//  in the use of the maximum fan in as much as possible during the merge.
		//  We calculate this value every level, but it should only be less than
		//  the maximum fan in for the first merge level (but doesn't have to be).

		//  number of runs to merge

		if ( crunLast2 + crunLast <= crunFanInMax )
			crunFanInFirst = crunLast2 + crunLast;
		else
			crunFanInFirst = 2 + ( crunLast2 + crunLast - crunFanInMax - 1 ) % ( crunFanInMax - 1 );
		Assert( potnodeLast == potnodeLevel0 || crunFanInFirst == crunFanInMax );

		//  allocate and initialize merge node
		
		if ( ( potnodeT = PotnodeOTNODEAlloc() ) == potnodeNil )
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		memset( potnodeT, 0, sizeof( OTNODE ) );
		potnodeT->potnodeAllocNext = potnodeAlloc;
		potnodeAlloc = potnodeT;
		ipotnode = 0;

		//  Add any leftover runs from the second to last level (the level before
		//  the last level) to the first merge of this level.

		Assert( crunLast2 < crunFanInMax );

		if ( potnodeLast2 == potnodeLevel0 )
			{
			Assert( potnodeT->runlist.crun == 0 );
			potnodeT->runlist.crun = crunLast2;
			}
		else
			{
			while ( potnodeLast2 != potnodeNil )
				{
				Assert( ipotnode < crunFanInMax );
				potnodeT->rgpotnode[ipotnode++] = potnodeLast2;
				potnodeLast2 = potnodeLast2->potnodeLevelNext;
				}
			}
		crunFanInFirst -= crunLast2;
		crunLast2 = 0;
			
		//  take runs from last level

		if ( potnodeLast == potnodeLevel0 )
			{
			Assert( potnodeT->runlist.crun == 0 );
			potnodeT->runlist.crun = crunFanInFirst;
			}
		else
			{
			for ( irun = 0; irun < crunFanInFirst; irun++ )
				{
				Assert( ipotnode < crunFanInMax );
				potnodeT->rgpotnode[ipotnode++] = potnodeLast;
				potnodeLast = potnodeLast->potnodeLevelNext;
				}
			}
		crunLast -= crunFanInFirst;

		//  save this node to add to this level later

		potnodeFirst = potnodeT;

		//  Create as many full merges for this level as possible, using the
		//  maximum fan in.
		
		while ( crunLast >= crunFanInMax )
			{
			//  allocate and initialize merge node

			if ( ( potnodeT = PotnodeOTNODEAlloc() ) == potnodeNil )
				Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			memset( potnodeT, 0, sizeof( OTNODE ) );
			potnodeT->potnodeAllocNext = potnodeAlloc;
			potnodeAlloc = potnodeT;
			ipotnode = 0;

			//  take runs from last level

			if ( potnodeLast == potnodeLevel0 )
				{
				Assert( potnodeT->runlist.crun == 0 );
				potnodeT->runlist.crun = crunFanInMax;
				}
			else
				{
				for ( irun = 0; irun < crunFanInMax; irun++ )
					{
					Assert( ipotnode < crunFanInMax );
					potnodeT->rgpotnode[ipotnode++] = potnodeLast;
					potnodeLast = potnodeLast->potnodeLevelNext;
					}
				}
			crunLast -= crunFanInMax;

			//  add this node to the current level

			potnodeT->potnodeLevelNext = potnodeThis;
			potnodeThis = potnodeT;
			crunThis++;
			}

		//  add the first merge to the current level

		potnodeFirst->potnodeLevelNext = potnodeThis;
		potnodeThis = potnodeFirst;
		crunThis++;

		//  Move level history back one level in preparation for next level.

		Assert( potnodeLast2 == potnodeNil || potnodeLast2 == potnodeLevel0 );
		Assert( crunLast2 == 0 );
		
		potnodeLast2	= potnodeLast;
		crunLast2		= crunLast;
		potnodeLast		= potnodeThis;
		crunLast		= crunThis;
		potnodeThis		= potnodeNil;
		crunThis		= 0;
		}
	while ( crunLast2 + crunLast > 1 );

	//  verify that all nodes / runs were used

	Assert( potnodeLast2 == potnodeNil || potnodeLast2 == potnodeLevel0 );
	Assert( crunLast2 == 0 );
	Assert(	potnodeLast != potnodeNil
			&& potnodeLast->potnodeLevelNext == potnodeNil );
	Assert( crunLast == 1 );

	//  return root node pointer

	*ppotnode = potnodeLast;
	return JET_errSuccess;
	
HandleError:
	while ( potnodeAlloc != potnodeNil )
		{
		SORTIRunDeleteListMem( pscb, &potnodeAlloc->runlist.prunlinkHead, crunAll );
		potnodeT = potnodeAlloc->potnodeAllocNext;
		OTNODEReleasePotnode( potnodeAlloc );
		potnodeAlloc = potnodeT;
		}
	*ppotnode = potnodeNil;
	return err;
	}

//  Performs an optimized tree merge depth first according to the provided
//  optimized tree.  When pprunlink is NULL, the current level is not
//  merged (this is used to save the final merge for the SORT iterator).

LOCAL ERR ErrSORTIOptTreeMergeDF( SCB *pscb, OTNODE *potnode, RUNLINK **pprunlink )
	{
	ERR		err;
	LONG	crunPhantom = 0;
	LONG	ipotnode;
	LONG	irun;
	RUNLINK	*prunlinkNext;

	//  if we have phantom runs, save how many so we can get them later

	if ( potnode->runlist.prunlinkHead == prunlinkNil )
		crunPhantom = potnode->runlist.crun;

	//  recursively merge all trees below this node

	for ( ipotnode = 0; ipotnode < crunFanInMax; ipotnode++ )
		{
		//  if this subtree pointer is potnodeNil, skip it

		if ( potnode->rgpotnode[ipotnode] == potnodeNil )
			continue;

		//  merge this subtree

		CallR( ErrSORTIOptTreeMergeDF(	pscb,
										potnode->rgpotnode[ipotnode],
										&potnode->runlist.prunlinkHead ) );
		OTNODEReleasePotnode( potnode->rgpotnode[ipotnode] );
		potnode->rgpotnode[ipotnode] = potnodeNil;
		potnode->runlist.crun++;
		}

	//  If this node has phantom (unbound) runs, we must grab the runs to merge
	//  from the list of original runs.  This is done to ensure that we use the
	//  original runs in the reverse order that they were generated to maximize
	//  the possibility of a BF cache hit.

	if ( crunPhantom > 0 )
		{
		for ( irun = 0; irun < crunPhantom; irun++ )
			{
			prunlinkNext = pscb->runlist.prunlinkHead->prunlinkNext;
			pscb->runlist.prunlinkHead->prunlinkNext = potnode->runlist.prunlinkHead;
			potnode->runlist.prunlinkHead = pscb->runlist.prunlinkHead;
			pscb->runlist.prunlinkHead = prunlinkNext;
			}
		pscb->runlist.crun -= crunPhantom;
		}

	//  merge all runs for this node

	if ( pprunlink != NULL )
		{
		//  merge the runs in the runlist
		
		CallR( ErrSORTIMergeToRun(	pscb,
									potnode->runlist.prunlinkHead,
									pprunlink ) );
		SORTIRunDeleteList( pscb, &potnode->runlist.prunlinkHead, crunAll );
		potnode->runlist.crun = 0;
		}

	return JET_errSuccess;
	}


//  frees an optimized tree merge tree (except the given OTNODE's memory)

LOCAL VOID SORTIOptTreeFree( SCB *pscb, OTNODE *potnode )
	{
	LONG	ipotnode;

	//  recursively free all trees below this node

	for ( ipotnode = 0; ipotnode < crunFanInMax; ipotnode++ )
		{
		if ( potnode->rgpotnode[ipotnode] == potnodeNil )
			continue;

		SORTIOptTreeFree( pscb, potnode->rgpotnode[ipotnode] );
		OTNODEReleasePotnode( potnode->rgpotnode[ipotnode] );
		}

	//  free all runlists for this node

	SORTIRunDeleteListMem( pscb, &potnode->runlist.prunlinkHead, crunAll );
	}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\redo.c ===
#include "daestd.h"
#include "version.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

ERR	errGlobalRedoError;
BOOL fGlobalAfterEndAllSessions = fFalse;
LGPOS lgposRedoShutDownMarkGlobal;

static	CPPIB   *rgcppibGlobal = NULL;
static	CPPIB   *pcppibAvail = NULL;
static	INT		ccppibGlobal = 0;

extern CRIT  critSplit;
extern LONG lGlobalGenLowRestore;
extern LONG lGlobalGenHighRestore;

LOCAL CPPIB *PcppibOfProcid( PROCID procid );
LOCAL ERR ErrLGPpibFromProcid( PROCID procid, PIB **pppib );
LOCAL ERR ErrLGGetFucb( PIB *ppib, PN fdp, FUCB **ppfucb );
LOCAL ERR ErrLGInitSession( DBMS_PARAM *pdbms_param, LGSTATUSINFO *plgstat );
LOCAL ERR ErrLGSetCSR( FUCB *pfucb );
LOCAL ERR ErrRedoSplitPage( FUCB *pfucb, LRSPLIT *plrsplit, INT splitt, BOOL fRedoOnly );
LOCAL ERR ErrLGCheckAttachedDB( DBID dbid, BOOL fReadOnly, ATCHCHK *patchchk, BOOL *pfAttachNow, SIGNATURE *psignLog );
LOCAL ERR ErrLGEndAllSessions( BOOL fEndOfLog, LGPOS *plgposRedoFrom );

typedef struct {
	BF	*pbf;
	TRX trxBegin0;
} BFUSAGE;

		
/*	validate that page needs redoing, returns buffer pointer pbf.
/*	Also set qwDBTimeCurrent properly.
/**/
ERR ErrLGRedoable( PIB *ppib, PN pn, QWORD qwDBTime, BF **ppbf, BOOL *pfRedoable )
	{
	ERR		err;
	PAGE	*ppage;
	DBID	dbid = DbidOfPn( pn );

	/*	if database not open, i.e. due to detachment, then
	/*	should not call ErrLGRedoable
	/**/
	Assert( rgfmp[dbid].hf != handleNil );

	Call( ErrBFAccessPage( ppib, ppbf, pn ) );
	ppage = (*ppbf)->ppage;

	/*	qwDBTimeCurrent may > qwDBTime is this is a replay of MacroOperations.
	 */
	if ( rgfmp[dbid].qwDBTimeCurrent <= qwDBTime )
		rgfmp[dbid].qwDBTimeCurrent = qwDBTime;

	*pfRedoable = qwDBTime > QwPMDBTime( ppage );

	if ( (*ppbf)->fDirty )
		{
		if ( (*ppbf)->pbfDepend || (*ppbf)->cDepend != 0 )
			{
			Call( ErrBFRemoveDependence( ppib, *ppbf, fBFNoWait ) );

			// Must re-access page because we may have lost critJet during RemoveDependence.
			Call( ErrBFAccessPage( ppib, ppbf, pn ) );
			}
		}

	err = JET_errSuccess;

HandleError:
	/*	succeed or page is not ready
	/**/
	Assert( err == JET_errOutOfMemory ||
		err == JET_errSuccess ||
		err == JET_errReadVerifyFailure ||
		err == JET_errDiskIO ||
		err == JET_errDiskFull );
	return err;
	}


ERR ErrDBStoreDBPath( CHAR *szDBName, CHAR **pszDBPath )
	{
	CHAR	szFullName[JET_cbFullNameMost + 1];
	INT		cb;
	CHAR	*sz;

	if ( _fullpath( szFullName, szDBName, JET_cbFullNameMost ) == NULL )
		{
		// UNDONE: should be illegal name or name too long etc.
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	cb = strlen(szFullName) + 1;
	if ( !( sz = SAlloc( cb ) ) )
		{
		*pszDBPath = NULL;
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memcpy( sz, szFullName, cb );
	Assert( sz[cb - 1] == '\0' );
	if ( *pszDBPath != NULL )
		SFree( *pszDBPath );
	*pszDBPath = sz;

	return JET_errSuccess;
	}

#ifdef DEBUG
BOOL fDBGNoLog = fFalse;
#endif


/*
 *      Redo database operations in log from lgposRedoFrom to end.
 *
 *  GLOBAL PARAMETERS
 *                      szLogName		(IN)		full path to szJetLog (blank if current)
 *                      lgposRedoFrom	(INOUT)		starting/ending lGeneration and ilgsec.
 *
 *  RETURNS
 *                      JET_errSuccess
 *						error from called routine
 */
ERR ErrLGRedo( CHECKPOINT *pcheckpoint, LGSTATUSINFO *plgstat )
	{
	ERR		err;
	PIB		*ppibRedo = ppibNil;
	LGPOS	lgposRedoFrom;
	INT		fStatus;

	/*	set flag to suppress logging
	/**/
	fRecovering = fTrue;
	fRecoveringMode = fRecoveringRedo;

	/*	open the proper log file
	/**/
	lgposRedoFrom = pcheckpoint->lgposCheckpoint;

	Call( ErrLGOpenRedoLogFile( &lgposRedoFrom, &fStatus ) );
	Assert( hfLog != handleNil );

	if ( fStatus != fRedoLogFile )
		{
		Call( ErrERRCheck( JET_errMissingPreviousLogFile ) );
		}

	Assert( fRecoveringMode == fRecoveringRedo );
	Call( ErrLGInitLogBuffers( pcheckpoint->dbms_param.ulLogBuffers ) );

	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
	lgposToFlush = lgposRedoFrom;

	AssertCriticalSection( critJet );
	Call( ErrLGLoadFMPFromAttachments( pcheckpoint->rgbAttach ) );
	logtimeFullBackup = pcheckpoint->logtimeFullBackup;
	lgposFullBackup = pcheckpoint->lgposFullBackup;
	logtimeIncBackup = pcheckpoint->logtimeIncBackup;
	lgposIncBackup = pcheckpoint->lgposIncBackup;

	/*	Check attached db already. No need to check in LGInitSession.
	 */
	Call( ErrLGInitSession( &pcheckpoint->dbms_param, plgstat ) );
	fGlobalAfterEndAllSessions = fFalse;

	Assert( hfLog != handleNil );
	err = ErrLGRedoOperations( &pcheckpoint->lgposCheckpoint, plgstat );
	if ( err < 0 )
		{
		if ( rgcppibGlobal != NULL )
			{
			/*	half way of recovering, release resouces.
			/**/
			Assert( rgcppibGlobal != NULL );
			LFree( rgcppibGlobal );
			rgcppibGlobal = NULL;
			ccppibGlobal = 0;

			CallS( ErrITTerm( fTermError ) );
			}
		}
	else
		{
		fRecoveringMode = fRecoveringUndo;
#ifdef DEBUG
		fDBGNoLog = fFalse;
#endif
		
		/*	set checkpoint before any logging activity
		 */
		pcheckpointGlobal->lgposCheckpoint = pcheckpoint->lgposCheckpoint;

		/*	set up pbWrite pbEntry etc for writing out the undo records
		/**/
		EnterCriticalSection( critLGBuf );

		Assert( pbRead >= pbLGBufMin + cbSec );
		pbEntry = pbNext;
		if ( pbLastMSFlush )
			{
			/*	should flush from last MS
			/**/
			Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
			isecWrite = lgposLastMSFlush.isec;
			pbWrite = PbSecAligned( pbLastMSFlush );
			}
		else
			{
			/*	no MS was read. continue flush from currently read page
			/**/
			pbWrite = PbSecAligned( pbEntry );
			isecWrite = csecHeader;
			}

		GetLgposOfPbEntry( &lgposLogRec );
		lgposToFlush = lgposLogRec;

		LeaveCriticalSection( critLGBuf );

		if ( fGlobalAfterEndAllSessions &&
			 fHardRestore )
			{
			/*	Start another session in order to do detachment.
			 *	Pass null dbms_param to use last init settings.
			 */
			Call( ErrLGInitSession( NULL, NULL ) );
			fGlobalAfterEndAllSessions = fFalse;

			/*	Log the start operations.
			 */
			Call( ErrLGStart() );
			}
			
		if ( !fGlobalAfterEndAllSessions )
			{
			Call( ErrLGEndAllSessions( fTrue, &pcheckpoint->lgposCheckpoint ) );
			fGlobalAfterEndAllSessions = fTrue;
			}

		Assert( hfLog != handleNil );
		}

HandleError:
	/*	set flag to suppress logging
	/**/
	fRecovering = fFalse;
	fRecoveringMode = fRecoveringNone;
	return err;
	}


/*
 *      Returns ppib for a given procid from log record.
 *
 *      PARAMETERS      procid          process id of session being redone
 *                              pppib           out ppib
 *
 *      RETURNS         JET_errSuccess or error from called routine
 */

LOCAL CPPIB *PcppibOfProcid( PROCID procid )
	{
	CPPIB   *pcppib = rgcppibGlobal;
	CPPIB   *pcppibMax = pcppib + ccppibGlobal;

	/*	find pcppib corresponding to procid if it exists
	/**/
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		if ( procid == pcppib->procid )
			{
			Assert( procid == pcppib->ppib->procid );
			return pcppib;
			}
		}
	return NULL;
	}


LOCAL INLINE PIB *PpibLGOfProcid( PROCID procid )
	{
	CPPIB *pcppib = PcppibOfProcid( procid );
	
	if ( pcppib )
		return pcppib->ppib;
	else
		return ppibNil;
	}


//+------------------------------------------------------------------------
//
//      ErrLGPpibFromProcid
//      =======================================================================
//
//      LOCAL ERR ErrLGPpibFromProcid( procid, pppib )
//
//      Initializes a redo information block for a session to be redone.
//      A BeginSession is performed and the corresponding ppib is stored
//      in the block.  Start transaction level and transaction level
//      validity are initialized.  Future references to this sessions
//      information block will be identified by the given procid.
//
//      PARAMETERS      procid  process id of session being redone
//                              pppib
//
//      RETURNS         JET_errSuccess, or error code from failing routine
//
//-------------------------------------------------------------------------
LOCAL ERR ErrLGPpibFromProcid( PROCID procid, PIB **pppib )
	{
	ERR             err = JET_errSuccess;

	/*	if no record for procid then start new session
	/**/
	if ( ( *pppib = PpibLGOfProcid( procid ) ) == ppibNil )
		{
		/*	check if have run out of ppib table lookup
		/*	positions. This could happen if between the
		/*	failure and redo, the number of system PIBs
		/*	set in CONFIG.DAE has been changed.
		/**/
		if ( pcppibAvail >= rgcppibGlobal + ccppibGlobal )
			{
			Assert( 0 );    /* should never happen */
			return ErrERRCheck( JET_errTooManyActiveUsers );
			}
		pcppibAvail->procid = procid;

		/*	use procid as unique user name
		/**/
		CallR( ErrPIBBeginSession( &pcppibAvail->ppib, procid ) );
		Assert( procid == pcppibAvail->ppib->procid );
		*pppib = pcppibAvail->ppib;

		pcppibAvail++;
		}

	return JET_errSuccess;
	}


/*
 *      Returns pfucb for given pib and FDP.
 *
 *      PARAMETERS      ppib    pib of session being redone
 *                              fdp             FDP page for logged page
 *                              pbf             buffer for logged page
 *                              ppfucb  out FUCB for open table for logged page
 *
 *      RETURNS         JET_errSuccess or error from called routine
 */

LOCAL ERR ErrLGGetFucb( PIB *ppib, PN pnFDP, FUCB **ppfucb )
	{
	ERR		err = JET_errSuccess;
	FCB		*pfcbTable;
	FCB		*pfcb;
	FUCB    *pfucb;
	PGNO    pgnoFDP = PgnoOfPn( pnFDP );
	DBID    dbid = DbidOfPn ( pnFDP );
	CPPIB   *pcppib = PcppibOfProcid( ppib->procid );

	/*	ppib pcppib must already exists
	/**/
	Assert( pcppib != NULL );
	
	/*	allocate an all-purpose fucb for this database if necessary
	/**/
	if ( pcppib->rgpfucbOpen[dbid] == pfucbNil )
		{
		CallR( ErrFUCBOpen( ppib, dbid, &pcppib->rgpfucbOpen[dbid] ) );
		Assert( pcppib->rgpfucbOpen[dbid] != pfucbNil );
		PcsrCurrent( pcppib->rgpfucbOpen[dbid] )->pcsrPath = pcsrNil;
		( pcppib->rgpfucbOpen[dbid] )->pfucbNextInstance = pfucbNil;
		}

	/*	reset copy buffer and key buffer
	/**/
	*ppfucb = pfucb = pcppib->rgpfucbOpen[dbid];
	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	if ( pfucb->u.pfcb != pfcbNil && pfucb->u.pfcb->pgnoFDP == pgnoFDP )
		{
		pfcb = (*ppfucb)->u.pfcb;
		}
	else
		{
		/*	we need to switch FCBs.  Check for previous fcb and unlink
		/*	it if found.
		/**/
		if ( pfucb->u.pfcb != pfcbNil )
			{
			FCBUnlink( *ppfucb );
			}

		//	UNDONE:	hash all FCBs and find FCB via hash table instead of
		//			via global linked list search.
		/*	find fcb corresponding to pqgnoFDP, if it exists.
		/*	Search all FCBs on global FCB list.  Search each table index,
		/*	and then move on to next table.
		/**/
		for ( pfcbTable = pfcbGlobalMRU;
			pfcbTable != pfcbNil;
			pfcbTable = pfcbTable->pfcbLRU )
			{
			for ( pfcb = pfcbTable;
				pfcb != pfcbNil;
				pfcb = pfcb->pfcbNextIndex )
				{
				if ( pgnoFDP == pfcb->pgnoFDP && dbid == pfcb->dbid )
					goto FoundFCB;
				}
			}

		/*	no existing fcb for FDP: open new fcb. Always open the FCB as
		/*	a regular table FCB and not a secondary index FCB. This is
		/*	will (hopefully) work for redo operations even for Dir operations
		/*	on secondary indexes (the FCB will already exist).
		/**/
		/* allocate an FCB and set up for FUCB
		/**/
		CallR( ErrFCBAlloc( ppib, &pfcb ) )
		memset( pfcb, 0, sizeof(FCB) );

		pfcb->pgnoFDP = pgnoFDP;
		pfcb->pidb = pidbNil;
		pfcb->dbid = dbid;
		Assert( pfcb->wRefCnt == 0 );
		Assert( pfcb->ulFlags == 0 );
		pfucb->u.pfcb = pfcb;

		/*	put into global list
		/**/
		FCBInsert( pfcb );
FoundFCB:
		FCBLink( pfucb, pfcb);  /* link in the FUCB to new FCB */
		}

	pfucb->dbid = dbid;
	
	Assert( *ppfucb == pfucb );
	Assert( pfucb->ppib == ppib );
	return JET_errSuccess;
	}


//+------------------------------------------------------------------------
//
//      ErrLGSetCSR
//      =======================================================================
//
//      LOCAL ERR ErrLGSetCSR( pfucb )
//
//      Returns sets up the CSR for a given pfucb. The SSIB including pbf
//      must have been set up previously, and the page must be in the buffer.
//
//      PARAMETERS      pfucb  FUCB with SSIB and BF set up
//
//      RETURNS         JET_errSuccess (asserts on bad log record).
//
//-------------------------------------------------------------------------

LOCAL ERR ErrLGSetCSR( FUCB *pfucb )
	{
	CSR		*pcsr = pfucb->pcsr;
	PAGE	*ppage = pfucb->ssib.pbf->ppage;
	INT		itag = pfucb->ssib.itag;
	INT		itagFather = 0;
	INT		ibSon = 0;

	/*	current node is FOP
	/**/
	if ( itag != 0 )
		{
		/*	current node is not FOP, scan all lines to find its father
		/**/
		NDGetItagFatherIbSon( &itagFather, &ibSon, ppage, itag );
		if ( ibSon == ibSonNull )
			{
			Assert( fFalse );

			/*	cannot find father node, return failure
			/**/
			return ErrERRCheck( JET_errInvalidLoggedOperation );
			}
		}

	/*	set up CSR and exit
	/**/
		{
		pcsr->csrstat = csrstatOnCurNode;
		Assert(pcsr->pgno);
		pcsr->ibSon = (SHORT)ibSon;
		pcsr->itagFather = (SHORT)itagFather;
		pcsr->itag = (SHORT)itag;
		}

	return JET_errSuccess;
	}


VOID LGRestoreDBMSParam( DBMS_PARAM *pdbms_param )
	{
//	if ( !fDoNotOverWriteLogFilePath )
//		{
//		strcpy( szLogFilePath, pdbms_param->szLogFilePath );
//		strcat( szLogFilePath, "\\" );
//
//		strcpy( szSystemPath, pdbms_param->szSystemPath );
//		}

	//	UNDONE: better cover additional needed resources and
	//	reduce asynchronous activity during recovery
	/*	during recovery, even more resources may be necessary than
	/*	during normal operation, since asynchronous activites are
	/*	both being done, for recovery operation, and being redo by
	/*	recovery operation.
	/**/
	lMaxSessions = pdbms_param->ulMaxSessions;
	lMaxOpenTables = pdbms_param->ulMaxOpenTables;
	lMaxVerPages = pdbms_param->ulMaxVerPages;
	lMaxCursors = pdbms_param->ulMaxCursors;
	lLogBuffers = pdbms_param->ulLogBuffers;
	csecLGFile = pdbms_param->ulcsecLGFile;
	lMaxBuffers = pdbms_param->ulMaxBuffers;

	Assert( lMaxSessions > 0 );
	Assert( lMaxOpenTables > 0 );
	Assert( lMaxVerPages > 0 );
	Assert( lMaxCursors > 0 );
	Assert( lLogBuffers > 0 );
	Assert( lMaxBuffers > 0 );

	return;
	}


LOCAL ERR ErrLGInitSession( DBMS_PARAM *pdbms_param, LGSTATUSINFO *plgstat )
	{
	ERR		err;
	INT		idbid;
	CPPIB	*pcppib;
	CPPIB	*pcppibMax;
	DBID	dbid;

	/*	set log stored db environment
	/**/
	if ( pdbms_param )
		LGRestoreDBMSParam( pdbms_param );

	CallR( ErrITSetConstants( ) );

	CallR( ErrITInit() );

	/*	Make sure all the attached database are consistent!
	 */
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[dbid];
		CHAR *szName;
		BOOL fAttachNow;
		INT irstmap;

		szName = pfmp->szDatabaseName;
		if ( !szName )
			continue;

		if ( !pfmp->patchchk )
			continue;

		if ( fHardRestore )
			{
			/*	attach the database specified in restore map.
			 */
			err = ErrLGGetDestDatabaseName( pfmp->szDatabaseName, &irstmap, plgstat);
			if ( err == JET_errFileNotFound )
				{
				/*	not in the restore map, set to skip it.
				 */
				Assert( pfmp->pdbfilehdr == NULL );
				err = JET_errSuccess;
				continue;
				}
			else
				CallR( err ) ;

			szName = rgrstmapGlobal[irstmap].szNewDatabaseName;
			}

		if ( ( ErrLGCheckAttachedDB( dbid, pfmp->fReadOnly, pfmp->patchchk,
				&fAttachNow, &signLogGlobal ) )  != JET_errSuccess )
			{
			/*	ignore this create DB.
			 */
			continue;
			}

		Assert( pfmp->pdbfilehdr != NULL );
		if ( fAttachNow )
			{
			if ( fHardRestore )
				{
				if ( fGlobalSimulatedRestore )
					{
					Assert( !fGlobalExternalRestore );
					Assert( fGlobalRepair );
					}
				else
					CallR( ErrLGPatchDatabase( dbid, irstmap ) );
				}

			/*	Do not re-create the database. Simply attach it.
			 */
			Assert( pfmp->pdbfilehdr );
			DBIDSetAttached( dbid );
			
			/*	restore information stored in database file
			/**/
			pfmp->pdbfilehdr->bkinfoFullCur.genLow = lGlobalGenLowRestore;
			pfmp->pdbfilehdr->bkinfoFullCur.genHigh = lGlobalGenHighRestore;

			CallR( ErrUtilOpenFile( szName, &pfmp->hf, 0, fFalse, fTrue ));
			pfmp->qwDBTimeCurrent = 0;
			DBHDRSetDBTime(	pfmp->pdbfilehdr, 0 );

			/*	Keep extra copy of patchchk for error message.
			 */
			if ( pfmp->patchchkRestored == NULL )
				if (( pfmp->patchchkRestored = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
					return ErrERRCheck( JET_errOutOfMemory );
			*(pfmp->patchchkRestored) = *(pfmp->patchchk);
			}
		else
			{
			/*	wait for redoing  to attach this db.
			 */
			Assert( pfmp->szDatabaseName != NULL );
			UtilFree( pfmp->pdbfilehdr );
			pfmp->pdbfilehdr = NULL;
			}

		/* keep attachment info and update it. */
		Assert( pfmp->patchchk != NULL );
		}

	/*	initialize CPPIB structure
	/**/
	Assert( lMaxSessions > 0 );
	ccppibGlobal = lMaxSessions + cpibSystem;
	Assert( rgcppibGlobal == NULL );
	rgcppibGlobal = (CPPIB *) LAlloc( ccppibGlobal, sizeof(CPPIB) );
	if ( rgcppibGlobal == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	pcppibMax = rgcppibGlobal + ccppibGlobal;
	for ( pcppib = rgcppibGlobal; pcppib < pcppibMax; pcppib++ )
		{
		pcppib->procid = procidNil;
		pcppib->ppib = NULL;
		for( idbid = 0; idbid < dbidMax; idbid++ )
			pcppib->rgpfucbOpen[idbid] = pfucbNil;
		}
	pcppibAvail = rgcppibGlobal;

	return err;
	}


VOID LGSetDBTime( )
	{
	DBID    dbid;

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[ dbid ];

		/*	if there were operations and the file was opened for theose
		/*	operations, then set the time stamp.
		/**/
		if ( pfmp->qwDBTimeCurrent != 0 )
			{
			/* must be attached and opened */
			if ( pfmp->hf != handleNil )
				DBHDRSetDBTime( pfmp->pdbfilehdr, pfmp->qwDBTimeCurrent );
			}
		}

	return;
	}


ERR ErrLGICheckDatabaseFileSize( PIB *ppib, DBID dbid )
	{
	ERR	err;

	if ( ( err = ErrDBSetLastPage( ppib, dbid ) ) == JET_errFileNotFound )
		{
		//	UNDONE: The file should be there. Put this code to get around
		//	UNDONE: such that DS database file that was not detached can
		//	UNDONE: continue recovering.
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY, FILE_NOT_FOUND_ERROR_ID, 1, &rgfmp[dbid].szDatabaseName );
		}
	else
		{
		/*	make sure the file size matches.
		 */
		PGNO pgnoLast = ( rgfmp[ dbid ].ulFileSizeHigh << 20 )
					  + ( rgfmp[ dbid ].ulFileSizeLow >> 12 );
		err = ErrIONewSize( dbid, pgnoLast + cpageDBReserved );
		}

	return err;
	}


ERR ErrLGCheckDatabaseFileSize( VOID )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib;
	DBID    dbid;

	CallR( ErrPIBBeginSession( &ppib, procidNil ) );

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[dbid];

		/*	for each attached database
		/**/
		if ( pfmp->pdbfilehdr &&
			 CmpLgpos( &pfmp->pdbfilehdr->lgposAttach, &lgposMax ) != 0 )
			{
			ERR errT = ErrLGICheckDatabaseFileSize( ppib, dbid );
			if ( err == JET_errSuccess )
				err = errT;
			}
		}

	PIBEndSession( ppib );
	return err;
	}


/*
 *      Ends redo session.
 *  If fEndOfLog, then write log records to indicate the operations
 *  for recovery. If fPass1 is true, then it is for phase1 operations,
 *  otherwise for phase 2.
 */

LOCAL ERR ErrLGEndAllSessions( BOOL fEndOfLog, LGPOS *plgposRedoFrom )
	{
	ERR		err = JET_errSuccess;
	CPPIB   *pcppib;
	CPPIB   *pcppibMax;
	LGPOS   lgposRecoveryUndo;

	LGSetDBTime( );

	/*	write a RecoveryUndo record to indicate start to undo
	/**/
	if ( fEndOfLog )
		{
		/*  close and reopen log file in R/W mode
		/**/
		LeaveCriticalSection( critJet );
		EnterCriticalSection( critLGFlush );
		CallS( ErrUtilCloseFile( hfLog ) );
		hfLog = handleNil;
		CallR( ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse ) );
		LeaveCriticalSection( critLGFlush );
		EnterCriticalSection( critJet );

		CallR( ErrLGRecoveryUndo( szRestorePath ) );
		}

	lgposRecoveryUndo = lgposLogRec;

	//	UNDONE: is this call needed
	(VOID)ErrRCECleanAllPIB();

	pcppib = rgcppibGlobal;
	pcppibMax = pcppib + ccppibGlobal;
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		PIB *ppib = pcppib->ppib;

		if ( ppib == NULL )
			break;

		Assert( sizeof(JET_VSESID) == sizeof(ppib) );

		if ( ppib->fPrecommit )
			{
			/*	commit the transaction
			 */
			Assert( ppib->level == 1 );
			if ( !ppib->fPrecommit )
				VERPrecommitTransaction( ppib );
			CallR( ErrLGCommitTransaction( ppib, 0 ) );
			VERCommitTransaction( ppib, 0 );
			}

		if ( ppib->fMacroGoing )
			{
			/*	release recorded log. This must be done first.
			 *	the rgbLogRec is union of rgpbfLatched. We need to reset it
			 *	before LGMacroAbort is called which will check rgpbfLatched.
			 */
			if ( ppib->rgbLogRec )
				{
				SFree( ppib->rgbLogRec );
				ppib->rgbLogRec = NULL;
				ppib->ibLogRecAvail = 0;
				ppib->cbLogRecMac = 0;
				}

			/*	Record LGMacroAbort.
			 */
			CallR( ErrLGMacroAbort( ppib ) );
			Assert( ppib->levelMacro == 0 );
			}
		
		CallS( ErrIsamEndSession( (JET_VSESID)ppib, 0 ) );
		pcppib->procid = procidNil;
		pcppib->ppib = NULL;
		}

	(VOID)ErrRCECleanAllPIB();

	FCBResetAfterRedo();

	CallR( ErrBFFlushBuffers( 0, fBFFlushAll ) );

	/*	make sure the attached database's size is consistent with the file size.
	/**/
	if ( fEndOfLog )
		{
		CallR( ErrLGCheckDatabaseFileSize() );
		}

	/*	Detach all the faked attachment. Detach all the databases that were restored
	 *	to new location. Attach those database with new location.
	 */
	if ( fHardRestore && fEndOfLog )
		{
		DBID dbid;
		PIB *ppib;

		CallR( ErrPIBBeginSession( &ppib, procidNil ) );

		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			FMP *pfmp = &rgfmp[dbid];

			/*	if a db is attached. Check if it is restored to a new location.
			 */
			if ( pfmp->pdbfilehdr )
				{
				INT irstmap;

				Assert( pfmp->patchchk );

				CallS( ErrLGGetDestDatabaseName( pfmp->szDatabaseName, &irstmap, NULL ) );
				/*	check if restored to a new location
				 */
				if ( irstmap >= 0
					 && _stricmp( rgrstmapGlobal[irstmap].szDatabaseName,
							  rgrstmapGlobal[irstmap].szNewDatabaseName ) != 0
				   )
					{
					DBFILEHDR *pdbfilehdr = pfmp->pdbfilehdr;
					CHAR *szNewDb = rgrstmapGlobal[irstmap].szNewDatabaseName;
					JET_GRBIT grbit = 0;

					/*	reconstruct grbit for attachment.
					 */
					if ( !FDBIDLogOn( dbid ) )
						grbit |= JET_bitDbRecoveryOff;

					if ( rgfmp[dbid].fReadOnly )
						grbit |= JET_bitDbReadOnly;

					/*	do detachment.
					 */
					if ( pfmp->pdbfilehdr->bkinfoFullCur.genLow != 0 )
						{
						Assert( pfmp->pdbfilehdr->bkinfoFullCur.genHigh != 0 );
						pfmp->pdbfilehdr->bkinfoFullPrev = pfmp->pdbfilehdr->bkinfoFullCur;
						memset(	&pfmp->pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
						}
					CallR( ErrIsamDetachDatabase( (JET_VSESID) ppib, pfmp->szDatabaseName ) );

					/*	do attachment. Keep the backup info
					 */
					CallR( ErrIsamAttachDatabase( (JET_VSESID) ppib, szNewDb, grbit ) );
					}
				}

			/*	for each faked attached database, log database detachment
			 *	This happen only when someone restore a database that was compacted,
			 *	attached, used, then crashed. When restore, we ignore the compact and
			 *	attach after compact since the db does not match. At the end of restore
			 *	we fake a detach since the database is not recovered.
			 */
			if ( !pfmp->pdbfilehdr && pfmp->patchchk )
				{
				BYTE szT1[128];
				BYTE szT2[128];
				CHAR *rgszT[3];
				LOGTIME tm;

//				may not be set if database not present, and logs
//				do not include attachment/creation.
//				Assert( pfmp->fFakedAttach );
				Assert( pfmp->patchchk );
				Assert( pfmp->szDatabaseName != NULL );
				
				/*	Log event that the database is not recovered completely.
				 */
				rgszT[0] = rgfmp[dbid].szDatabaseName;
				tm = rgfmp[dbid].patchchk->signDb.logtimeCreate;
				sprintf( szT1, "%d/%d/%d %d:%d:%d",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
				rgszT[1] = szT1;

				if ( rgfmp[dbid].patchchkRestored )
					{
					tm = rgfmp[dbid].patchchkRestored->signDb.logtimeCreate;
					sprintf( szT2, "%d/%d/%d %d:%d:%d",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
					rgszT[2] = szT2;

					UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
						RESTORE_DATABASE_PARTIALLY_ERROR_ID, 3, rgszT );
					}
				else
					{
					UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
						RESTORE_DATABASE_MISSED_ERROR_ID, 2, rgszT );
					}
				
				CallR( ErrLGDetachDB(
						ppib,
						dbid,
						(CHAR *)pfmp->szDatabaseName,
						strlen(pfmp->szDatabaseName) + 1,
						NULL ));

				/*	Clean up the fmp entry.
				 */
				pfmp->fFlags = 0;

				SFree( pfmp->szDatabaseName);
				pfmp->szDatabaseName = NULL;

				SFree( pfmp->patchchk );
				pfmp->patchchk = NULL;
				}

			if ( pfmp->patchchkRestored )
				{
				SFree( pfmp->patchchkRestored );
				pfmp->patchchkRestored = NULL;
				}
			}
		}
		
	/*	close the redo sesseion incurred in previous ErrLGRedo
	/**/
	Assert( rgcppibGlobal != NULL );
	LFree( rgcppibGlobal );
	pcppibAvail =
	rgcppibGlobal = NULL;
	ccppibGlobal = 0;

	if ( fEndOfLog )
		{
		/*	Enable checkpoint updates.
		 */
		fGlobalFMPLoaded = fTrue;
		}

	/*	Term with checkpoint updates
	 */
	CallS( ErrITTerm( fTermNoCleanUp ) );

	/*	Stop checkpoint updates.
	 */	
	fGlobalFMPLoaded = fFalse;

	if ( fEndOfLog )
		{
		CallR( ErrLGRecoveryQuit( &lgposRecoveryUndo,
			plgposRedoFrom,
			fHardRestore ) );
		}
		
	/*	Note: flush is needed in case a new generation is generated and
	/*	the global variable szLogName is set while it is changed to new names.
	/*	critical section not requested, not needed
	/**/
	LeaveCriticalSection( critJet );
#ifdef PERFCNT
	err = ErrLGFlushLog( 0 );
#else
	err = ErrLGFlushLog();
#endif
	EnterCriticalSection( critJet );

	return err;
	}


#define cbSPExt 30

#ifdef DEBUG
static  INT iSplit = 0;
#endif

INLINE VOID UpdateSiblingPtr(SSIB *pssib, PGNO pgno, BOOL fLeft)
	{
	THREEBYTES tb;

	ThreeBytesFromL( &tb, pgno );
	if ( fLeft )
		pssib->pbf->ppage->pgnoPrev = tb;
	else
		pssib->pbf->ppage->pgnoNext = tb;
	}


ERR ErrLGRedoBackLinks(
	SPLIT   *psplit,
	FUCB    *pfucb,
	BKLNK   *rgbklnk,
	INT     cbklnk,
	QWORD   qwDBTimeRedo )
	{
	ERR             err;
	INT             ibklnk;
	SSIB    *pssib = &pfucb->ssib;
	BOOL    fLatched;

	/* backlinks maybe used by both split and merge
	/*
	/* when used by MERGE only:
	/*	sridBackLink != pgnoSplit
	/*	==> a regular backlink
	/*	sridBackLink == pgnoSplit && sridNew == sridNull
	/*	==> move the node from old page to new page,
	/*	                delete node on old page.
	/*	sridBackLink == pgnoSplit && sridNew != sridNull
	/*	==> replace link on old page with new link.
	/**/
	for ( ibklnk = 0; ibklnk < cbklnk; ibklnk++ )
		{
		BKLNK   *pbklnk = &rgbklnk[ ibklnk ];
		PGNO    pgno = PgnoOfSrid( (SRID) ( (BKLNK UNALIGNED *) pbklnk )->sridBackLink );
		INT             itag = ItagOfSrid( (SRID) ( (BKLNK UNALIGNED *) pbklnk )->sridBackLink );
		SRID    sridNew = (SRID) ( (BKLNK UNALIGNED *) pbklnk )->sridNew; //efficiency variable

		PcsrCurrent( pfucb )->pgno = pgno;
		CallR( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( fRecovering );
		if ( QwPMDBTime( pssib->pbf->ppage ) >= qwDBTimeRedo )
			continue;

		pssib->itag = itag;
		BFSetDirtyBit( pssib->pbf );

		if ( sridNew == sridNull )
			{
			INT itagFather;
			INT ibSon;

			NDGetItagFatherIbSon( &itagFather, &ibSon, pssib->pbf->ppage, pssib->itag );
			PcsrCurrent(pfucb)->itag = (SHORT)pssib->itag;
			PcsrCurrent(pfucb)->itagFather = (SHORT)itagFather;
			PcsrCurrent(pfucb)->ibSon = (SHORT)ibSon;
			CallR( ErrNDDeleteNode( pfucb ) );
			}
		else if ( pgno == psplit->pgnoSplit )
			{
			INT itagFather;
			INT ibSon;

			/* locate FOP, and delete its sons entry
			/**/
			NDGetItagFatherIbSon( &itagFather, &ibSon, pssib->pbf->ppage, pssib->itag );
			PcsrCurrent(pfucb)->itag = (SHORT)pssib->itag;
			PcsrCurrent(pfucb)->itagFather = (SHORT)itagFather;
			PcsrCurrent(pfucb)->ibSon = (SHORT)ibSon;
			Assert( PgnoOfSrid( sridNew ) != pgnoNull );
			Assert( (UINT) ItagOfSrid( sridNew ) > 0 );
			Assert( (UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
			
			NDGet( pfucb, itag );
			if ( FNDVersion( *pssib->line.pb ) )
				{
				INT cbReserved = CbVERGetNodeReserve(
									ppibNil,
									pfucb->dbid,
									SridOfPgnoItag( pgno, itag ),
									CbNDData( pssib->line.pb, pssib->line.cb ) );

				Assert( cbReserved >= 0 );
				if ( cbReserved > 0 )
					{
					PAGE *ppage = pssib->pbf->ppage;
					ppage->cbUncommittedFreed -= (SHORT)cbReserved;
					Assert( ppage->cbUncommittedFreed >= 0  &&
					ppage->cbUncommittedFreed <= ppage->cbFree );
					}
				}

			CallS( ErrNDReplaceWithLink( pfucb, sridNew ) );
			}
		else
			{
			Assert( PgnoOfSrid( sridNew ) != pgnoNull );
			Assert( (UINT) ItagOfSrid( sridNew ) > 0 );
			Assert( (UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
			PMReplaceLink( pssib, sridNew );
			}

		/* store backlink page buffers
		/**/
		CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );

		if ( fLatched )
			continue;

		/* do latch such that it will be released in ReleaseSplitBfs
		/**/
		BFSetWriteLatch( pssib->pbf, pssib->ppib );

		//	UNDONE: improve this code
		/*	set qwDBTime in such a way that it will be redo if the same
		/*	page is referenced again. 3 is a magic number that is the
		/*	biggest qwDBTime increment for any one page operation.
		/**/
		PMSetDBTime( pssib->pbf->ppage, qwDBTimeRedo - 3 );
		}

	return JET_errSuccess;
	}


LOCAL ERR ErrLGILatchMergePagePtr( SPLIT *psplit, LRMERGE *plrmerge, FUCB *pfucb )
	{
	ERR err;

	psplit->key.cb = plrmerge->cbKey;
	psplit->key.pb = psplit->rgbKey;
	psplit->itagPagePointer = plrmerge->itagPagePtr;
	memcpy( psplit->rgbKey, plrmerge->rgb, plrmerge->cbKey );
	PcsrCurrent( pfucb )->pgno = plrmerge->pgnoParent;
	CallR( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	psplit->pbfPagePtr = pfucb->ssib.pbf;

	return JET_errSuccess;
	}


/*	LOCAL ERR ErrLGRedoMergePage(
/*	        FUCB            *pfucb,
/*	        LRMERGE         *plrmerge,
/*	        BOOL            fCheckBackLinkOnly )
/**/
LOCAL ERR ErrLGRedoMergePage(
	FUCB            *pfucb,
	LRMERGE         *plrmerge,
	BOOL            fCheckBackLinkOnly,
	BOOL            fNoUpdateSibling,
	BOOL			fUpdatePagePtr )
	{
	ERR				err;
	SPLIT           *psplit;
	SSIB            *pssib = &pfucb->ssib;
	FUCB            *pfucbRight = pfucbNil;
	SSIB            *pssibRight;
	QWORDX			qwxDBTime;

	/******************************************************
	/*	initialize local variables and allocate split resources
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	qwxDBTime.l = plrmerge->ulDBTimeLow;
	qwxDBTime.h = plrmerge->ulDBTimeHigh;
	
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;
	psplit->qwDBTimeRedo = qwxDBTime.qw;
	psplit->pgnoSplit = PgnoOfPn( plrmerge->pn );
	if ( fNoUpdateSibling )
		Assert( !psplit->pgnoSibling );
	else
		psplit->pgnoSibling = plrmerge->pgnoRight;

	if ( fCheckBackLinkOnly )
		{
		/* only need to check backlinks
		/**/
		Call( ErrLGRedoBackLinks(
					psplit,
					pfucb,
					(BKLNK *) ( plrmerge->rgb + plrmerge->cbKey ),
					plrmerge->cbklnk, psplit->qwDBTimeRedo ) );

		if ( fUpdatePagePtr )
			{
			Call( ErrLGILatchMergePagePtr( psplit, plrmerge, pfucb ) );
			Call( ErrBMDoMergeParentPageUpdate( pfucb, psplit ) );
			}
		}
	else
		{
		/*	access merged and sibling pages, and latch buffers
		/**/
		psplit->ibSon = 0;
		psplit->splitt = splittRight;

		/*	access page to free and remove buffer dependencies
		/**/
		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrmerge->pn );
		forever
			{
			Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

			/*	if no dependencies, then break
			/**/
			if ( pfucb->ssib.pbf->cDepend == 0 &&
				pfucb->ssib.pbf->pbfDepend == pbfNil )
				{
				break;
				}

			/*	remove dependencies on buffer of page to be removed, to
			/*	prevent buffer anomalies after buffer is reused.
			/**/
			Call( ErrBFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf, fBFWait ) );
			}
		Assert( pfucb->ssib.pbf->cDepend == 0 );

		/*	latch the merge page after next remove dependency is done.
		 */

		if ( !fNoUpdateSibling )
			{
			/*	allocate cursor for right page
			/**/
			Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbRight ) );
			pssibRight = &pfucbRight->ssib;

			/*	access page to free and remove buffer dependencies
			/**/
			PcsrCurrent( pfucbRight )->pgno = plrmerge->pgnoRight;
#if 0
			Call( ErrBFWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ) );
			Assert( !( FBFWriteLatchConflict( pfucbRight->ppib, pfucbRight->ssib.pbf ) ) );
#else
			forever
				{
				Call( ErrBFWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ) );
				Assert( !( FBFWriteLatchConflict( pfucbRight->ppib, pfucbRight->ssib.pbf ) ) );
				
				/*	if no dependencies, then break
				/**/
//				if ( pfucbRight->ssib.pbf->cDepend == 0 &&
//					pfucbRight->ssib.pbf->pbfDepend == pbfNil )
				if ( pfucbRight->ssib.pbf->pbfDepend == pbfNil )
					{
					break;
					}

				/*	remove dependencies on buffer of page to be removed, to
				/*	prevent buffer anomalies after buffer is reused.
				/**/
				Call( ErrBFRemoveDependence( pfucbRight->ppib, pfucbRight->ssib.pbf, fBFWait ) );
				Assert( pfucbRight->ssib.pbf->cDepend == 0 );
				}
#endif
			BFSetWriteLatch( pssibRight->pbf, pfucbRight->ppib );
			psplit->pbfSibling = pssibRight->pbf;
			}

		if ( fUpdatePagePtr )
			{
			Call( ErrLGILatchMergePagePtr( psplit, plrmerge, pfucb ) );
			}

		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrmerge->pn );
		Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		BFSetWriteLatch( pssib->pbf, pfucb->ppib );
		psplit->pbfSplit = pssib->pbf;

		err = ErrBMDoMerge(
					pfucb,
					fNoUpdateSibling ? pfucbNil : pfucbRight,
					psplit,
					fNoUpdateSibling ? plrmerge : NULL );
		Assert( err == JET_errSuccess );
		}

HandleError:
	if ( pfucbRight != pfucbNil )
		{
		DIRClose( pfucbRight );
		}

	/* release allocated buffers
	/**/
	BTReleaseSplitBfs( fTrue, psplit, err );
	Assert( psplit != NULL );
	SFree( psplit );

	/*	Remove dependency right away, if possible
	 */
	if ( err >= 0 )
		{
		/*	check for dependency. If dependency is generated,
		 *	remove it right away.
		 */
		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrmerge->pn );
		CallS( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		CallR( ErrBFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf, fBFNoWait ) );
		}

	return err;
	}


/*
 *      ERR ErrRedoSplitPage(
 *              FUCB            *pfucb,
 *              LRSPLIT         *plrsplit,
 *              INT                     splitt,
 *              BOOL            fSkipMoves )
 *
 *              pfucb           cursor pointing at node which is to be split
 *              pgnonew new page which has already been allocated for the split
 *              ibSplitSon is node at which to split for R or L, 0 for V, and
 *                                      total sons of FOP for Addend
 *              pgnoFather      page which contains pointer to page being split
 *                                      (V: unused)
 *              itagFather itag of the father node in the page
 *              splitt  type of split
 *              pgtyp           page type for new page
 *              fSkipMoves      Do not do moves, do correct links and insert parent
 */

ERR ErrRedoSplitPage(
	FUCB		*pfucb,
	LRSPLIT		*plrsplit,
	INT			splitt,
	BOOL		fSkipMoves )
	{
	ERR			err = JET_errSuccess;
	SPLIT		*psplit;
	SSIB		*pssib = &pfucb->ssib;
	CSR			*pcsr = pfucb->pcsr;
	FUCB		*pfucbNew;
	FUCB		*pfucbNew2 = pfucbNil;
	FUCB		*pfucbNew3 = pfucbNil;
	SSIB		*pssibNew;
	SSIB		*pssibNew2;
	SSIB		*pssibNew3;
	static		BYTE rgb[cbPage];
	BOOL		fAppend;
	QWORDX		qwxDBTime;

//	Assert( !fRecovering );

	/*	allocate additional cursor
	/**/
	pfucbNew = pfucbNil;
	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew ) );
	pssibNew = &pfucbNew->ssib;
	if ( splitt == splittDoubleVertical )
		{
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew2 ) );
		pssibNew2 = &pfucbNew2->ssib;
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew3 ) );
		pssibNew3 = &pfucbNew3->ssib;
		}

	/*	initialize local variables and
	/*	allocate and set up split resources
	/**/
	SetupSSIB( pssibNew, pfucb->ppib );
	SSIBSetDbid( pssibNew, pfucb->dbid );

	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	qwxDBTime.l = plrsplit->ulDBTimeLow;
	qwxDBTime.h = plrsplit->ulDBTimeHigh;
	
	memset( (BYTE *)psplit, '\0', sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;
	psplit->qwDBTimeRedo = qwxDBTime.qw;
	psplit->dbid = pfucb->dbid;
	psplit->pgnoSplit = PgnoOfPn(plrsplit->pn);
	psplit->itagSplit = plrsplit->itagSplit;
	psplit->ibSon = plrsplit->ibSonSplit;
	psplit->pgnoNew = plrsplit->pgnoNew;
	psplit->pgnoNew2 = plrsplit->pgnoNew2;
	psplit->pgnoNew3 = plrsplit->pgnoNew3;
	psplit->pgnoSibling = plrsplit->pgnoSibling;
	psplit->splitt = splitt;
	Assert( plrsplit->fLeaf == fFalse || plrsplit->fLeaf == fTrue );
	psplit->fLeaf = plrsplit->fLeaf;
	psplit->key.cb = plrsplit->cbKey;
	psplit->key.pb = plrsplit->rgb;
	psplit->keyMac.cb = plrsplit->cbKeyMac;
	psplit->keyMac.pb = plrsplit->rgb + plrsplit->cbKey;
	fAppend = ( splitt == splittAppend );

	/*	set up FUCB
	/**/
	pfucb->ssib.itag =
		PcsrCurrent(pfucb)->itag = (SHORT)psplit->itagSplit;
	PcsrCurrent(pfucb)->pgno = psplit->pgnoSplit;

	/*	set up the two split pages
	/*	always update new page for append
	/**/
	if ( fAppend || !fSkipMoves )
		{
		Call( ErrBFReadAccessPage(
			pfucb,
			psplit->pgnoSplit ) );

	    Call( ErrBTSetUpSplitPages(
			pfucb,
			pfucbNew,
			pfucbNew2,
			pfucbNew3,
			psplit,
			plrsplit->pgtyp,
			fAppend,
			fSkipMoves ) );

		if ( psplit->pbfSplit != pbfNil )
			{
			BFSetDirtyBit( pssib->pbf );
			}
		else
			{
			/*	give up the buffer
			/**/
			pssib->pbf = pbfNil;
			}

		BFSetDirtyBit( pssibNew->pbf );
		}

	/******************************************************
	 *      perform split
	 */

	switch ( psplit->splitt )
		{
		case splittVertical:
			{
			if ( fSkipMoves )
				break;

			CallR( ErrBTSplitVMoveNodes( pfucb,
				pfucbNew,
				psplit,
				pcsr,
				rgb,
				fAllocBufOnly ) );
			
			/*	call page space to make sure we have room to insert!
			 */
			if ( psplit->pbfSplit != pbfNil )
				(void) CbNDFreePageSpace( psplit->pbfSplit );

			CallS( ErrBTSplitVMoveNodes( pfucb,
				pfucbNew,
				psplit,
				pcsr,
				rgb,
				fDoMove ) );
			break;
			}

		case splittDoubleVertical:
			{
			if ( fSkipMoves )
				break;

			BFSetDirtyBit( pssibNew2->pbf );
			BFSetDirtyBit( pssibNew3->pbf );

			CallR( ErrBTSplitDoubleVMoveNodes( pfucb,
				pfucbNew,
				pfucbNew2,
				pfucbNew3,
				psplit,
				pcsr,
				rgb,
				fAllocBufOnly ) );

			/*	call page space to make sure we have room to insert!
			 */
			if ( psplit->pbfSplit != pbfNil )
				(void) CbNDFreePageSpace( psplit->pbfSplit );

			CallS( ErrBTSplitDoubleVMoveNodes( pfucb,
				pfucbNew,
				pfucbNew2,
				pfucbNew3,
				psplit,
				pcsr,
				rgb,
				fDoMove ) );
			break;
			}

		case splittLeft:
		case splittRight:
		case splittAppend:
			{
			CSR     csrPagePointer;
			BOOL    fLeft = psplit->splitt == splittLeft;

			/*	do not call the following function if it is not redoable
			/**/
			Assert( pssib == &pfucb->ssib );

			if ( psplit->pbfSplit == pbfNil )
				{
				Assert( fAppend || fSkipMoves );

				if ( fAppend )
					{
					/*	always update new page links for append
					/**/
					UpdateSiblingPtr( pssibNew, psplit->pgnoSplit, !fLeft );
					UpdateSiblingPtr( pssibNew, psplit->pgnoSibling, fLeft );
					AssertBFDirty( pssibNew->pbf );
					}

				goto RedoLink;
				}

			/*	we check the time stamp in redoable function
			/**/
			Assert( psplit->qwDBTimeRedo > QwPMDBTime( pssib->pbf->ppage ) );

			CallR( ErrLGSetCSR( pfucb ) );
			CallR( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fAllocBufOnly ) );
			CallS( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fDoMove ) );

			UpdateSiblingPtr( pssib, psplit->pgnoNew, fLeft );
			AssertBFDirty( pssib->pbf );

			UpdateSiblingPtr( pssibNew, psplit->pgnoSplit, !fLeft );
			UpdateSiblingPtr( pssibNew, psplit->pgnoSibling, fLeft );
			AssertBFDirty( pssibNew->pbf );

RedoLink:
			/*	make sure qwDBTime is set properly in btsplit and
			/*	then check if link is necessary.
			/**/
			Assert( pssib == &pfucb->ssib );
			Assert( pssibNew == &pfucbNew->ssib );

			if ( plrsplit->pgnoSibling == 0 )
				goto UpdateParentPage;

			CallR( ErrBFWriteAccessPage( pfucb, plrsplit->pgnoSibling ) );
			if ( psplit->qwDBTimeRedo <= QwPMDBTime( pssib->pbf->ppage ) )
				goto UpdateParentPage;

			psplit->pbfSibling = pssib->pbf;
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			BFSetDirtyBit( pssib->pbf );

			UpdateSiblingPtr( pssib,
				psplit->pgnoNew,
				psplit->splitt != splittLeft );

UpdateParentPage:
			/*	set page pointer to point to father node
			/**/
			CallR( ErrBFWriteAccessPage( pfucb, plrsplit->pgnoFather ) );

			/*	make sure qwDBTime is set properly in InsertPage.
			/*	check the page's db time stamp to see if insert is necessary.
			/**/
			Assert( pssib == &pfucb->ssib );
			if ( psplit->qwDBTimeRedo <= QwPMDBTime( pssib->pbf->ppage ) )
				break;

			/*	keep track of parent page. Simulate the work in PrepInsertPagePtr
			 */
			psplit->pbfPagePtr = pssib->pbf;
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			BFSetDirtyBit( pssib->pbf );

			/*	call page space to make sure we have room to insert!
			 */
			(void) CbNDFreePageSpace( pssib->pbf );

			/*	set csr for BTinsertPagePointer function.
			 */
			csrPagePointer.pgno = plrsplit->pgnoFather;
			csrPagePointer.itag = plrsplit->itagFather;
			csrPagePointer.itagFather = plrsplit->itagGrandFather;
			csrPagePointer.ibSon = plrsplit->ibSonFather;

			Call( ErrBTInsertPagePointer( pfucb,
				&csrPagePointer,
				psplit,
				rgb ) );
			break;
			}
		}

	/*	check if any backlinks needs update even we did not do moves
	/**/
	if ( fSkipMoves )
		{
		CallR( ErrLGRedoBackLinks(
			psplit,
			pfucb,
			(BKLNK *)( plrsplit->rgb + plrsplit->cbKey + plrsplit->cbKeyMac ),
			plrsplit->cbklnk,
			psplit->qwDBTimeRedo ) );
		}

HandleError:
//      Assert( psplit->splitt != splittNull );
	#ifdef SPLIT_TRACE
		FPrintF2( "Split............................... %d\n", iSplit++);
		switch ( psplit->splitt )
			{
			case splittNull:
				FPrintF2( "split split type = null\n" );
				break;
			case splittVertical:
				FPrintF2( "split split type = vertical\n" );
				break;
			case splittRight:
				if      ( fAppend )
					FPrintF2( "split split type = append\n" );
				else
					FPrintF2( "split split type = right\n" );
				break;
			case splittLeft:
				FPrintF2( "split split type = left\n" );
			};
		FPrintF2( "split page = %lu\n", psplit->pgnoSplit );
		FPrintF2( "dbid = %u\n", psplit->dbid );
		FPrintF2( "fFDP = %d\n", psplit->fFDP );
		FPrintF2( "fLeaf = %d\n", FNDVisibleSons( *pssib->line.pb ) );
		FPrintF2( "split itag = %d\n", psplit->itagSplit );
		FPrintF2( "split ibSon = %d\n", psplit->ibSon );
		FPrintF2( "new page = %lu\n", psplit->pgnoNew );
		FPrintF2( "\n" );
	#endif

	/*	release split resources
	/**/
	Assert( psplit != NULL );
	BTReleaseSplitBfs( fTrue, psplit, err );
	Assert( psplit != NULL );
	SFree( psplit );

	if ( pfucbNew != pfucbNil )
		DIRClose( pfucbNew );
	if ( pfucbNew2 != pfucbNil )
		DIRClose( pfucbNew2 );
	if ( pfucbNew3 != pfucbNil )
		DIRClose( pfucbNew3 );

	/*	Remove dependency right away
	 */
	if ( err >= 0 )
		{
		/*	check for dependency. If dependency is generated,
		 *	remove it right away.
		 */
		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrsplit->pn );
		CallS( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		CallR( ErrBFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf, fBFNoWait ) );
		}

	return err;
	}


#ifdef DEBUG
void TraceRedo(LR *plr)
	{
	/* easier to debug */
	if (fDBGTraceRedo)
		{
		extern INT cNOP;

		EnterCriticalSection( critDBGPrint );
		if ( cNOP >= 1 && plr->lrtyp != lrtypNOP )
			{
			FPrintF2( " * %d", cNOP );
			cNOP = 0;
			}

		if ( cNOP == 0 || plr->lrtyp != lrtypNOP )
			{
			PrintLgposReadLR();
			ShowLR(plr);
			}
		LeaveCriticalSection( critDBGPrint );
		}
	}
#else
#define TraceRedo
#endif


#ifdef DEBUG
#ifndef RFS2

#undef CallJ
#undef CallR

#define CallJ(f, hndlerr)                                                                       \
		{                                                                                                       \
		if ((err = (f)) < 0)                                                            \
			{                                                                                               \
			AssertSz(0,"Debug Only: ignore this assert");   \
			goto hndlerr;                                                                   \
			}                                                                                               \
		}

#define CallR(f)                                                                                        \
		{                                                                                                       \
		if ((err = (f)) < 0)                                                            \
			{                                                                                               \
			AssertSz(0,"Debug Only: ignore this assert");   \
			return err;                                                                             \
			}                                                                                               \
		}

#endif
#endif


VOID LGIReportEventOfReadError( DBID dbid, PN pn, ERR err )
	{
	BYTE szT1[16];
	BYTE szT2[16];
	CHAR *rgszT[3];

	rgszT[0] = rgfmp[dbid].szDatabaseName;
	sprintf( szT1, "%d", PgnoOfPn(pn) );
	rgszT[1] = szT1;
	sprintf( szT2, "%d", err );
	rgszT[2] = szT2;

	UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
		RESTORE_DATABASE_READ_PAGE_ERROR_ID, 3, rgszT );
	}


#define cbStep	512
ERR ErrLGIStoreLogRec( PIB *ppib, LR *plr )
	{
	INT cb = CbLGSizeOfRec( plr );
	INT cbAlloc = max( cbStep, cbStep * ( cb / cbStep + 1 ) );
	
	while ( ppib->ibLogRecAvail + cb >= ppib->cbLogRecMac )
		{
		BYTE *rgbLogRecOld = ppib->rgbLogRec;
		INT cbLogRecMacOld = ppib->cbLogRecMac;
		BYTE *rgbLogRec = SAlloc( cbLogRecMacOld + cbAlloc );
		if ( rgbLogRec == NULL )
			return ErrERRCheck( JET_errOutOfMemory );

		memcpy( rgbLogRec, rgbLogRecOld, cbLogRecMacOld );
		memset( rgbLogRec + cbLogRecMacOld, 0, cbAlloc );
		ppib->rgbLogRec = rgbLogRec;
		ppib->cbLogRecMac = cbLogRecMacOld + cbAlloc;
		if ( rgbLogRecOld )
			SFree( rgbLogRecOld );
		}

	memcpy( ppib->rgbLogRec + ppib->ibLogRecAvail, plr, cb );
	ppib->ibLogRecAvail += (USHORT)cb;

	return JET_errSuccess;
	}

ERR ErrLGIRedoOnePageOperation( LR *plr )
	{
	ERR				err;
	PIB				*ppib;
	FUCB			*pfucb;
	PN				pn;
	BF				*pbf;
	PROCID			procid;
	DBID			dbid;
	KEY				key;
	BOOL			fRedoNeeded;
	QWORDX			qwxDBTime;
	CSR				*pcsr;
	LRINSERTNODE	*plrinsertnode = (LRINSERTNODE *) plr;

	procid = plrinsertnode->procid;
	pn = plrinsertnode->pn;
	qwxDBTime.l = plrinsertnode->ulDBTimeLow;
	qwxDBTime.h = plrinsertnode->ulDBTimeHigh;

	CallR( ErrLGPpibFromProcid( procid, &ppib ) );

	if ( ppib->fMacroGoing )
		return ErrLGIStoreLogRec( ppib, plr );

	if ( !ppib->fAfterFirstBT )
		return JET_errSuccess;

	/*	check if we have to redo the database.
	/**/
	dbid = DbidOfPn( pn );
	if ( rgfmp[dbid].pdbfilehdr == NULL )
		return JET_errSuccess;

	Assert( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) < 0 );

	/*	check if database needs opening
	/**/
	if ( !FUserOpenedDatabase( ppib, dbid ) )
		{
		DBID dbidT = dbid;
		CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ) );
		Assert( dbidT == dbid);

		/*	reset to prevent interference
		/**/
		DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 );
		}
	
	err = ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded );
	if ( err < 0 )
		{
		if ( fGlobalRepair )
			{
			LGIReportEventOfReadError( dbid, pn, err );
			errGlobalRedoError = err;
			err = JET_errSuccess;
			}
		return err;
		}

	TraceRedo( plr );

	CallR( ErrLGGetFucb( ppib,
		PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
		&pfucb ) );

	// Re-access page in case we lost critJet.
	CallR( ErrBFAccessPage( ppib, &pbf, pn ) );

	// Ensure page isn't flushed in case we lose critJet.
	BFPin( pbf );

	/*	operation on the node on the page; prepare for it
	/**/
	pcsr = PcsrCurrent( pfucb );

	pfucb->ssib.pbf = pbf;
	pcsr->pgno = PgnoOfPn( pn );

	switch ( plr->lrtyp )
		{
		case lrtypInsertNode:
		case lrtypInsertItemList:
			{
			LRINSERTNODE    *plrinsertnode = (LRINSERTNODE *)plr;
			LINE            line;
			BYTE            bHeader = plrinsertnode->bHeader;
			LONG			fDIRFlags = plrinsertnode->fDirVersion ? fDIRVersion : 0;

			/*	set CSR
			/**/
			pcsr->itag = plrinsertnode->itagSon;
			pcsr->itagFather = plrinsertnode->itagFather;
			pcsr->ibSon = plrinsertnode->ibSon;

			key.pb = plrinsertnode->szKey;
			key.cb = plrinsertnode->cbKey;
			line.pb = key.pb + key.cb;
			line.cb = plrinsertnode->cbData;

			if ( plr->lrtyp == lrtypInsertItemList )
				{
				pcsr->isrid = 0;
				pcsr->bm = SridOfPgnoItag( pcsr->pgno, pcsr->itag );
				/*	cach item for later reference
				/**/
				Assert( line.cb == sizeof(SRID) );
				pcsr->item = *(UNALIGNED SRID *)line.pb;
				}

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( plr->lrtyp == lrtypInsertItemList )
					{
					if ( !( fDIRFlags & fDIRVersion ) )
						{
						err = JET_errSuccess;
						goto HandleError;
						}
					while ( ( err = ErrVERInsertItem( pfucb, pcsr->bm ) ) == errDIRNotSynchronous );
					Call( err );
					}
				else if ( FNDVersion( bHeader ) )
					{
					/*	set ssib pointing to node flags
					/**/
					pfucb->ssib.line.pb = &bHeader;
					pfucb->ssib.line.cb = sizeof(BYTE);

					pfucb->lineData.pb = pbNil;
					pfucb->lineData.cb = 0;

					while ( ( err = ErrVERInsert( pfucb,
						SridOfPgnoItag( pcsr->pgno, pcsr->itag ) ) )
						==  errDIRNotSynchronous );
					Call( err );
					}

				err = JET_errSuccess;
				goto HandleError;
				}

			if ( plr->lrtyp == lrtypInsertItemList )
				{
				do
					{
					Assert( PcsrCurrent( pfucb )->isrid == 0 );
					err = ErrNDInsertItemList( pfucb,
						&key,
						pcsr->item,
						fDIRFlags );
					}
				while ( err == errDIRNotSynchronous );
				Call( err );
				}
			else
				{
				/*	pfucb->ssib, key, line must be set correctly.
				 *      get precise cbUncommitedFree first.
				 */
				INT cbReq = 1 +                                 /* node header */
							1 +                                     /* cbKey */
							key.cb +                        /* key */
							line.cb +                       /* data */
							sizeof( TAG ) +         /* tag for the inserted node */
							1 +                                     /* entry in father node */
							1;                                      /* father node son count if it was null */

				if ( cbReq >
					 (INT) ( pfucb->ssib.pbf->ppage->cbFree -
							 pfucb->ssib.pbf->ppage->cbUncommittedFreed ) )
					{
					BOOL f = FVERCheckUncommittedFreedSpace( pfucb->ssib.pbf, cbReq );
					Assert( f );
					}

				do      {
					err = ErrNDInsertNode( pfucb, &key, &line, bHeader, fDIRFlags | fDIRNoLog );
					} while ( err == errDIRNotSynchronous );

				Call( err );
				}
			Assert( pfucb->pcsr->itag == plrinsertnode->itagSon );
			Assert( pfucb->pcsr->ibSon == plrinsertnode->ibSon );
			}
			break;

		case lrtypReplace:
		case lrtypReplaceD:
			{
			LRREPLACE       *plrreplace = (LRREPLACE *)plr;
			LINE            line;
			BYTE            rgbRecNew[cbNodeMost];
			UINT            cbOldData = plrreplace->cbOldData;
			UINT            cbNewData = plrreplace->cbNewData;
			LONG			fDIRFlags = plrreplace->fDirVersion ? fDIRVersion : 0;

			/* set CSR
			/**/
			pcsr->itag = plrreplace->itag;
			pcsr->bm = plrreplace->bm;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				RCE *prce;

				if ( !( fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				pfucb->lineData.cb = plrreplace->cbOldData;
				while( ErrVERModify( pfucb,
						pcsr->bm,
						operReplaceWithDeferredBI,
						&prce )
						== errDIRNotSynchronous );
				Call( err );

				if ( prce != prceNil && cbNewData != cbOldData )
					{
					VERSetCbAdjust( pfucb,
						prce,
						cbNewData,
						cbOldData,
						fDoNotUpdatePage );
					}

				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			/*	line to point to the data/diffs of lrreplace/lrreplaceD
			/**/
			if ( plr->lrtyp == lrtypReplaceD )
				{
				INT cb;
				BYTE *pbDiff = plrreplace->szData;
				INT cbDiff = plrreplace->cb;

				LGGetAfterImage( pbDiff, cbDiff, pfucb->lineData.pb, pfucb->lineData.cb,
					rgbRecNew, &cb );

				line.pb = rgbRecNew;
				line.cb = cb;
				Assert( line.cb < sizeof( rgbRecNew ) );
				}
			else
				{
				line.pb = plrreplace->szData;
				line.cb = plrreplace->cb;
				}
			Assert( line.cb == cbNewData );

			/*	cache node
			/**/
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );
			NDGetNode( pfucb );

			/*	replace node may return not synchronous error if out of
			/*	version buckets so call in loop to ensure this case handled.
			/**/

//                      /*	get precise cbUncommitedFree. No need to do it since ReplaceNodeData
//                       *      will do it for us.
//                       */
//                      if ( pfucb->lineData.cb < line.cb )
//                              {
//                              BOOL f = FVERCheckUncommittedFreedSpace(
//                                                      &pfucb->ssib,
//                                                      line.cb - pfucb->lineData.cb );
//                              Assert( f );
//                              }

			do      {
				err = ErrNDReplaceNodeData( pfucb, &line, fDIRFlags );
				} while ( err == errDIRNotSynchronous );
					
			Call( err );
			}
			break;

		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrflagdelete = (LRFLAGDELETE *) plr;
			LONG	fDIRFlags = plrflagdelete->fDirVersion ? fDIRVersion : 0;

			/*	set CSR
			/**/
			pcsr->itag = plrflagdelete->itag;
			pcsr->bm = plrflagdelete->bm;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( ! ( fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				while( ( err = ErrVERModify( pfucb,
					pcsr->bm,
					operFlagDelete,
					pNil ) )
					== errDIRNotSynchronous );
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );

			/*	redo operation
			/**/
			while( ( err = ErrNDFlagDeleteNode( pfucb, fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypLockBI:
			{
			LRLOCKBI        *plrlockbi = (LRLOCKBI *) plr;
			RCE             *prce;

			/*	set CSR
			/**/
			pcsr->itag = plrlockbi->itag;
			pcsr->bm = plrlockbi->bm;

			if ( fRedoNeeded )
				{
				NDGet( pfucb, pcsr->itag );
				NDGetNode( pfucb );
				}

			/*	set ssib so that VERModify can work properly
			/**/
			pfucb->lineData.cb = plrlockbi->cbOldData;
			while( ErrVERModify( pfucb,
					pcsr->bm,
					fRedoNeeded ? operReplace : operReplaceWithDeferredBI,
					&prce )
					== errDIRNotSynchronous );
			Call( err );

			if ( !fRedoNeeded )
				{
				goto HandleError;
				}
			BFSetDirtyBit( pbf );
			}
			break;

		case lrtypUpdateHeader:
			{
			LRUPDATEHEADER *plrupdateheader = (LRUPDATEHEADER *) plr;

			/*	set CSR
			/**/
			pcsr->itag = plrupdateheader->itag;
			pcsr->bm = plrupdateheader->bm;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	redo operation
			/**/
			err = ErrNDSetNodeHeader( pfucb, plrupdateheader->bHeader );
			Call( err );
			}
			break;

		case lrtypDelete:
			{
			LRDELETE        *plrdelete = (LRDELETE *) plr;
			SSIB            *pssib = &pfucb->ssib;

			/*	set CSR
			/**/
			pssib->itag =
				pcsr->itag = plrdelete->itag;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	redo the node delete
			/**/
			Call( ErrLGSetCSR ( pfucb ) );
			while( ( err = ErrNDDeleteNode( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypInsertItem:
			{
			LRINSERTITEM    *plrinsertitem = (LRINSERTITEM *)plr;
			LONG			fDIRFlags = plrinsertitem->fDirVersion ? fDIRVersion : 0;

			/*	set CSR
			/**/
			pcsr->item = plrinsertitem->srid;
			pcsr->itag = plrinsertitem->itag;
			pcsr->bm = plrinsertitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( !( fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}
				while( ( err = ErrVERInsertItem( pfucb,
					pcsr->bm ) ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			Assert( pcsr == PcsrCurrent( pfucb ) );
			err = ErrNDSeekItem( pfucb, plrinsertitem->srid );
			Assert( err == JET_errSuccess ||
				err == errNDGreaterThanAllItems );

			/*	redo operation
			/**/
			while( ( err = ErrNDInsertItem( pfucb, plrinsertitem->srid,
				fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypInsertItems:
			{
			LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *) plr;

			/*	set CSR
			/**/
			pcsr->itag = plrinsertitems->itag;

			/*	if necessary, create an Insert RCE for node
			/**/
			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			Assert( pcsr == PcsrCurrent( pfucb ) );

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			/*	do the item operation
			/**/
			while( ( err = ErrNDInsertItems( pfucb, plrinsertitems->rgitem, plrinsertitems->citem ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypFlagInsertItem:
			{
			LRFLAGITEM *plrflagitem = (LRFLAGITEM *) plr;

			/*	set CSR
			/**/
			pcsr->item = plrflagitem->srid;
			pcsr->itag = plrflagitem->itag;
			pcsr->bm = plrflagitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				while ( err = ErrVERFlagInsertItem( pfucb,
					pcsr->bm ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == wrnNDDuplicateItem );

			/*	redo operation
			/**/
			while( ( err = ErrNDFlagInsertItem( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypFlagDeleteItem:
			{
			LRFLAGITEM *plrflagitem = (LRFLAGITEM *) plr;

			/*	set CSR
			/**/
			pcsr->item = plrflagitem->srid;
			pcsr->itag = plrflagitem->itag;
			pcsr->bm = plrflagitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				while ( err = ErrVERFlagDeleteItem( pfucb, pcsr->bm ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == wrnNDDuplicateItem );

			/*	redo operation
			/**/
			while( ( err = ErrNDFlagDeleteItem( pfucb, 0 ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypSplitItemListNode:
			{
			LRSPLITITEMLISTNODE *plrsplititemlistnode = (LRSPLITITEMLISTNODE *)plr;
			LONG fDIRFlags = plrsplititemlistnode->fDirAppendItem ? fDIRAppendItem : 0;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	set CSR
			/**/
			pcsr->itag = plrsplititemlistnode->itagToSplit;
			pcsr->itagFather = plrsplititemlistnode->itagFather;
			pcsr->ibSon = plrsplititemlistnode->ibSon;

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			while( ( err = ErrNDSplitItemListNode( pfucb, fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypDeleteItem:
			{
			SSIB                    *pssib = &pfucb->ssib;
			LRDELETEITEM    *plrdeleteitem = (LRDELETEITEM *) plr;

			/*	set CSR
			/**/
			pssib->itag =
				pcsr->itag = plrdeleteitem->itag;
			pcsr->item = plrdeleteitem->srid;
			pcsr->bm = plrdeleteitem->sridItemList;

			/*	delete item does not support transactions and
			/*	hence does not require rollback support during
			/*	recovery.
			/**/
			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == wrnNDDuplicateItem );

			/*	redo operation
			/**/
			while( ( err = ErrNDDeleteItem( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypDelta:
			{
			SSIB    *pssib = &pfucb->ssib;
			LRDELTA *plrdelta = (LRDELTA *) plr;
			LONG    lDelta;
			LONG	fDIRFlags = plrdelta->fDirVersion ? fDIRVersion : 0;

			/*	set CSR
			/**/
			pssib->itag = pcsr->itag = plrdelta->itag;
			pcsr->bm = plrdelta->bm;
			lDelta = plrdelta->lDelta;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( !( fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				pfucb->lineData.pb = (BYTE *)&lDelta;
				pfucb->lineData.cb = sizeof(lDelta);
				while ( ( err = ErrVERDelta( pfucb, pcsr->bm ) ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			while( ( err = ErrNDDelta( pfucb, lDelta, fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypCheckPage:
			{
			LRCHECKPAGE *plrcheckpage = (LRCHECKPAGE *)plr;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	check page parameters, including cbFree,
			/*	and next tag.
			/**/
			Assert( pfucb->ssib.pbf->ppage->cbFree ==
				plrcheckpage->cbFree );
//                      Assert( pfucb->ssib.pbf->ppage->cbUncommittedFreed ==
//                              plrcheckpage->cbUncommitted );
			Assert( (SHORT)ItagPMQueryNextItag( &pfucb->ssib ) ==
				plrcheckpage->itagNext );

			/*	dirty buffer to conform to other redo logic
			/**/
			BFSetDirtyBit( pfucb->ssib.pbf );
			}
			break;

		default:
			Assert( fFalse );
		}

	Assert( fRedoNeeded );
	AssertFBFWriteAccessPage( pfucb, PgnoOfPn(pn) );
	Assert( pfucb->ssib.pbf->pn == pn );
	Assert( pbf->fDirty );
//	Assert( pbf->ppage->pghdr.ulDBTime <= ulDBTime );
	/*	the timestamp set in ND operation is not correct so reset it
	/**/
	PMSetDBTime( pbf->ppage, qwxDBTime.qw );

	err = JET_errSuccess;

HandleError:

	Assert( pfucb->ppib == ppib );
	BFUnpin( pbf );
	return err;
	}


#define fNSGotoDone             1
#define fNSGotoCheck    2


ERR ErrLGIRedoFill( LR **pplr, BOOL fLastLRIsQuit, INT *pfNSNextStep )
	{
	ERR     err;
	LONG    lgen;
	BOOL    fCloseNormally;
	LOGTIME tmOldLog = plgfilehdrGlobal->tmCreate;
	CHAR    szDriveT[_MAX_DRIVE + 1];
	CHAR    szDirT[_MAX_DIR + 1];
	CHAR    szFNameT[_MAX_FNAME + 1];
	CHAR    szExtT[_MAX_EXT + 1];
	LGPOS   lgposFirstT;
	BOOL    fJetLog = fFalse;

	/*	split log name into name components
	/**/
	_splitpath( szLogName, szDriveT, szDirT, szFNameT, szExtT );

	/*	end of redoable logfile, read next generation
	/**/
	if ( UtilCmpName( szFNameT, szJet ) == 0 )
		{
		Assert( szLogCurrent != szRestorePath );

		/*	we have done all the log records
		/**/
		*pfNSNextStep = fNSGotoDone;
		return JET_errSuccess;
		}

	/* close current logfile, open next generation */
	CallS( ErrUtilCloseFile( hfLog ) );
	/* set hfLog as handleNil to indicate it is closed. */
	hfLog = handleNil;

	lgen = plgfilehdrGlobal->lGeneration + 1;
	LGSzFromLogId( szFNameT, lgen );
	LGMakeLogName( szLogName, szFNameT );
	err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );

	if ( err == JET_errFileNotFound )
		{
		if ( szLogCurrent == szRestorePath )
			{
			/*	try current working directory
			/**/
			szLogCurrent = szLogFilePath;
			LGSzFromLogId( szFNameT, lgen );
			LGMakeLogName( szLogName, szFNameT );
			err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
			}
		}

	if ( err == JET_errFileNotFound )
		{
		/*	open fails
		/**/
		Assert( hfLog == handleNil );
		/* try szJetLog
		/**/
		strcpy( szFNameT, szJet );
		LGMakeLogName( szLogName, szFNameT );
		err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
		if ( err == JET_errSuccess )
			fJetLog = fTrue;
		}
	if ( err < 0 )
		{
		if ( err == JET_errFileNotFound )
			{
			//	UNDONE: check gen number high of backup directory */

			/* we run out of log files, create a new edb.log in current
			 * directory for later use.
			 */
			LeaveCriticalSection( critJet );
			EnterCriticalSection( critLGFlush );
			/*	Reset LG buf pointers since we are done with all the
			 *      old log records in buffer.
			 */
			EnterCriticalSection( critLGBuf );
			pbEntry = pbLGBufMin;
			pbWrite = pbLGBufMin;
			LeaveCriticalSection( critLGBuf );

			if ( ( err = ErrLGNewLogFile( lgen - 1, fLGOldLogInBackup ) ) < 0 )
				{
				LeaveCriticalSection( critLGFlush );
				EnterCriticalSection( critJet );
				return err;
				}

			EnterCriticalSection( critLGBuf );
			memcpy( plgfilehdrGlobal, plgfilehdrGlobalT, sizeof( LGFILEHDR ) );
			isecWrite = csecHeader;
			LeaveCriticalSection( critLGBuf );

			LeaveCriticalSection( critLGFlush );
			EnterCriticalSection( critJet );

			Assert( plgfilehdrGlobal->lGeneration == lgen );

			Assert( pbLastMSFlush == pbWrite );
			Assert( lgposLastMSFlush.lGeneration == lgen );

			strcpy( szFNameT, szJet );
			LGMakeLogName( szLogName, szFNameT );
			err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
			Assert( pbWrite == pbLastMSFlush );
			
			/*	set up pbNext for caller to switch
			 *      from proper pbNext to pbEntry.
			 */
			Assert( *pbWrite == lrtypMS );
			pbNext = pbWrite + sizeof( LRMS );

			*pfNSNextStep = fNSGotoDone;
			return err;
			}

		/* Open Fails */
		Assert( fFalse );
		Assert( hfLog == handleNil );
		if ( fLastLRIsQuit )
			{
			/* we are lucky, we have a normal end */
			*pfNSNextStep = fNSGotoDone;
			return JET_errSuccess;
			}
		return err;
		}

	/* reset the log buffers */
	CallR( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fCheckLogID ) );

#ifdef CHECK_LOG_VERSION
	if ( !fLGIgnoreVersion )
		{
		if ( plgfilehdrGlobal->ulMajor != rmj ||
			plgfilehdrGlobal->ulMinor != rmm ||
			plgfilehdrGlobal->ulUpdate != rup )
			{
			return ErrERRCheck( JET_errBadLogVersion );
			}
		if ( !FSameTime( &tmOldLog, &plgfilehdrGlobal->tmPrevGen ) )
			{
			return ErrERRCheck( JET_errInvalidLogSequence );
			}
		}
#endif

	lgposFirstT.lGeneration = plgfilehdrGlobal->lGeneration;
	lgposFirstT.isec = (WORD) csecHeader;
	lgposFirstT.ib = 0;

	lgposLastRec.isec = 0;
	if ( fJetLog )
		{
		CallR( ErrLGCheckReadLastLogRecord( &fCloseNormally ) );
		if ( !fCloseNormally )
			GetLgposOfPbEntry( &lgposLastRec );
		}

	CallR( ErrLGLocateFirstRedoLogRec( &lgposFirstT, (BYTE **)pplr ) );
	*pfNSNextStep = fNSGotoCheck;
	return JET_errSuccess;
	}


INT IrstmapLGGetRstMapEntry( CHAR *szName )
	{
	INT  irstmap;
	BOOL fFound = fFalse;
	
	for ( irstmap = 0; irstmap < irstmapGlobalMac; irstmap++ )
		{
		CHAR	szDriveT[_MAX_DRIVE + 1];
		CHAR	szDirT[_MAX_DIR + 1];
		CHAR	szFNameT[_MAX_FNAME + 1];
		CHAR	szExtT[_MAX_EXT + 1];
		CHAR	*szT;
		CHAR	*szRst;

		if ( fGlobalExternalRestore )
			{
			/*	Use the database path to search.
			 */
			szT = szName;
			szRst = rgrstmapGlobal[irstmap].szDatabaseName;
			}
		else
			{
			/*	use the generic name to search
			 */
			_splitpath( szName, szDriveT, szDirT, szFNameT, szExtT );
			szT = szFNameT;
			szRst = rgrstmapGlobal[irstmap].szGenericName;
			}

		if ( _stricmp( szRst, szT ) == 0 )
			{
			fFound = fTrue;
			break;
			}
		}
	if ( !fFound )
		return -1;
	else
		return irstmap;
	}

			
/*	Make sure the database has matched signLog and
 *	this lgpos is proper for the database file.
 */
ERR ErrLGCheckAttachedDB( DBID dbid, BOOL fReadOnly, ATCHCHK *patchchk, BOOL *pfAttachNow, SIGNATURE *psignLogged )
	{
	ERR err;
	INT i;
	CHAR *szName;
	DBFILEHDR *pdbfilehdr = NULL;
	INT  irstmap;

	Assert( rgfmp[dbid].pdbfilehdr == NULL );

	pdbfilehdr = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdbfilehdr == NULL )
		CallR( ErrERRCheck( JET_errOutOfMemory ) );

	/*	choose the right file to check.
	 */
	if ( fHardRestore )
		{
		CallS( ErrLGGetDestDatabaseName( rgfmp[dbid].szDatabaseName, &irstmap, NULL ) );
		Assert( irstmap >= 0 );
		szName = rgrstmapGlobal[irstmap].szNewDatabaseName;
		Assert( szName );
		}
	else
		szName = rgfmp[dbid].szDatabaseName;

	err = ErrUtilReadShadowedHeader( szName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) );
	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );
	Call( err );

	if ( pdbfilehdr->fDBState != fDBStateConsistent &&
		 pdbfilehdr->fDBState != fDBStateInconsistent )
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );

	if ( memcmp( &pdbfilehdr->signDb, &patchchk->signDb, sizeof( SIGNATURE ) ) != 0 )
   		Call( ErrERRCheck( JET_errBadDbSignature ) );

	if ( fReadOnly ||
		 memcmp( &pdbfilehdr->signLog, &signLogGlobal, sizeof( SIGNATURE ) ) != 0 )
		{
		if ( psignLogged )
			{
			/*	must be called by redo attachdb.
			 */
			if ( memcmp( &pdbfilehdr->signLog, psignLogged, sizeof( SIGNATURE ) ) != 0 ||
				 CmpLgpos( &patchchk->lgposConsistent, &pdbfilehdr->lgposConsistent ) != 0 )
				{
				/*	the database's log signture is not the same as current log neither
				 *	the same as the one before it was attached. Or they are the same but
				 *	its consistent time is different, return wrong db to attach!
				 */
				Call( ErrERRCheck( JET_errBadLogSignature ) );
				}
			else if ( !fReadOnly )
				{
				/*	The attach operation is logged, but header is not changed.
				 *	set up the header such that it looks like it is set up after attach.
				 */
				DBISetHeaderAfterAttach( pdbfilehdr, lgposRedo, dbid, fFalse );
				Call( ErrUtilWriteShadowedHeader( szName, (BYTE *)pdbfilehdr, sizeof(DBFILEHDR)));

				/*	fall through to set up pfAttachNow and pfmp->pdbfilehdr.
				 */
				}
			}
		}

	Assert( pfAttachNow );
	Assert( patchchk );

	/*	This must be called from redoing attachdb operation.
	 */
	if ( fReadOnly )
		{
		*pfAttachNow = fTrue;
		goto HandleError;
		}

#if 0
	i = CmpLgpos( &patchchk->lgposAttach, &pdbfilehdr->lgposAttach );
	if ( i == 0 )
		{
		if ( !psignLogged ||
			 CmpLgpos( &patchchk->lgposConsistent, &pdbfilehdr->lgposConsistent ) == 0 )
			*pfAttachNow = fTrue;
		else
			*pfAttachNow = fFalse;
		}
	else
		{
		/*	attach later
		 */
		*pfAttachNow = fFalse;
		}
#else
	if ( !psignLogged )
		{
		/*	A create, check if the attached db is the one created at this point.
		 */
		i = CmpLgpos( &patchchk->lgposAttach, &pdbfilehdr->lgposAttach );
		if ( i == 0 )
			*pfAttachNow = fTrue;
		else
			*pfAttachNow = fFalse;
		}
	else
		{
		/*	An attachment. Check if it as same last consistent point.
		 */
		if ( CmpLgpos( &patchchk->lgposConsistent, &pdbfilehdr->lgposConsistent ) == 0 )
			{
			pdbfilehdr->lgposAttach = patchchk->lgposAttach;
			*pfAttachNow = fTrue;
			}
		else
			*pfAttachNow = fFalse;
		}
#endif

HandleError:
	if ( err < 0 )
		{
		BYTE szT1[16];
		CHAR *rgszT[2];

		UtilFree( pdbfilehdr );
		
		rgszT[0] = rgfmp[dbid].szDatabaseName;
		sprintf( szT1, "%d", err );
		rgszT[1] = szT1;

		UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
			RESTORE_DATABASE_READ_HEADER_WARNING_ID, 2, rgszT );
		}
	else
		rgfmp[ dbid ].pdbfilehdr = pdbfilehdr;

	return err;
	}


ERR ErrLGIRedoOperation( LR *plr )
	{
	ERR		err = JET_errSuccess;
	BF		*pbf;
	PIB		*ppib;
	FUCB	*pfucb;
	PN		pn;
	DBID	dbid;
	QWORDX	qwxDBTime;
	LEVEL   levelCommitTo;

	switch ( plr->lrtyp )
		{

	default:
		{
#ifndef RFS2
		AssertSz( fFalse, "Debug Only, Ignore this Assert" );
#endif
		return ErrERRCheck( JET_errLogCorrupted );
		}

	/****************************************************
	 *     Page Oriented Operations                     *
	 ****************************************************/

	case lrtypInsertNode:
	case lrtypInsertItemList:
	case lrtypReplace:
	case lrtypReplaceD:
	case lrtypFlagDelete:
	case lrtypUpdateHeader:
	case lrtypDelete:
	case lrtypInsertItem:
	case lrtypInsertItems:
	case lrtypFlagInsertItem:
	case lrtypFlagDeleteItem:
	case lrtypSplitItemListNode:
	case lrtypDeleteItem:
	case lrtypDelta:
	case lrtypLockBI:
	case lrtypCheckPage:    /* debug only records */
		err = ErrLGIRedoOnePageOperation( plr );

		if ( err == JET_errWriteConflict )
			{
//          Assert( fFalse );
			/*	trx is not in ssync with lgpos. So try to clean up version
			/*	store and retry.
			/**/
			(VOID)ErrRCECleanAllPIB();
			err = ErrLGIRedoOnePageOperation( plr );
			}
			
		CallR( err );
		break;

	case lrtypDeferredBI:
		{
		LRDEFERREDBI	*plrdbi = (LRDEFERREDBI *)plr;
		RCE				*prce;

		CallR( ErrLGPpibFromProcid( plrdbi->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		/*	check if we have to redo the database
		/**/
		if ( rgfmp[plrdbi->dbid].pdbfilehdr == NULL )
			break;
			
		if ( CmpLgpos( &rgfmp[ plrdbi->dbid ].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		TraceRedo( plr );

		/*	patch up BI of corresponding RCE
		/**/
		prce = PrceRCEGet( plrdbi->dbid, plrdbi->bm );
		if ( prce == prceNil )
			{
			/*	Precommit have cleaned up the BI.
			 */
			Assert( ppib->fPrecommit );
			break;
			}

		while ( prce != prceNil &&
				( ( prce->oper != operReplaceWithDeferredBI && prce->oper != operReplace )
				  || prce->level != plrdbi->level
				)
			  )
			{
//			Assert( prce->prcePrevOfNode != prceNil );
			prce = prce->prcePrevOfNode;
			}

		if ( prce == prceNil )
			{
			/*	Precommit have cleaned up the BI.
			 */
			Assert( ppib->fPrecommit );
			break;
			}

		if ( prce->oper == operReplaceWithDeferredBI )
			{
			Assert( prce->cbData == plrdbi->cbData + cbReplaceRCEOverhead );
			memcpy( prce->rgbData + cbReplaceRCEOverhead, plrdbi->rgbData, plrdbi->cbData );
			prce->oper = operReplace;
			}

		/*	take out the entry in the deferred BI chain since it has been logged.
		 *	and its commit has not been redone yet.
		 */
		pbf = prce->pbfDeferredBI;
		if ( pbf == pbfNil )
			break;
				
		VERDeleteFromDeferredBIChain( prce );

		CallR( ErrBFRemoveDependence( ppib, pbf, fBFNoWait ) );
		}
		break;

	/****************************************************
	 *     Transaction Operations                       *
	 ****************************************************/

	case lrtypBegin:
	case lrtypBegin0:
		{
		LRBEGIN *plrbegin = (LRBEGIN *)plr;
		LRBEGIN0 *plrbegin0 = (LRBEGIN0 *)plr;

		TraceRedo( plr );

		Assert( plrbegin->level >= 0 && plrbegin->level <= levelMax );
		CallR( ErrLGPpibFromProcid( plrbegin->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		/*	do BT only after first BT based on level 0 is executed
		/**/
		if ( ( ppib->fAfterFirstBT ) ||
			( !ppib->fAfterFirstBT && plrbegin->levelBegin == 0 ) )
			{
			LEVEL levelT = plrbegin->level;

			Assert( ppib->level <= plrbegin->levelBegin );

			if ( ppib->level == 0 )
				{
				Assert( plrbegin->levelBegin == 0 );
				ppib->trxBegin0 = plrbegin0->trxBegin0;
				ppib->lgposStart = lgposRedo;
				trxNewest = max( trxNewest, ppib->trxBegin0 );
				if ( trxOldest == trxMax )
					trxOldest = ppib->trxBegin0;
				}

			/*	issue begin transactions
			/**/
			while ( ppib->level < plrbegin->levelBegin + plrbegin->level )
				{
				CallS( ErrVERBeginTransaction( ppib ) );
				}

			/*	assert at correct transaction level
			/**/
			Assert( ppib->level == plrbegin->levelBegin + plrbegin->level );

			ppib->fAfterFirstBT = fTrue;
			}
		break;
		}

	case lrtypRefresh:
		{
		LRREFRESH *plrrefresh = (LRREFRESH *)plr;

		TraceRedo( plr );

		CallR( ErrLGPpibFromProcid( plrrefresh->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		/*	imitate a begin transaction.
		 */
		Assert( ppib->level <= 1 );
		ppib->level = 1;
		ppib->trxBegin0 = plrrefresh->trxBegin0;
			
		break;
		}

	case lrtypPrecommit:
		{
		LRPRECOMMIT *plrprecommit = (LRPRECOMMIT *)plr;

		CallR( ErrLGPpibFromProcid( plrprecommit->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		Assert( ppib->level == 1 );

		TraceRedo( plr );

		ppib->fPrecommit = fTrue;
		VERPrecommitTransaction( ppib );
		break;
		}
			
	case lrtypCommit:
	case lrtypCommit0:
		{
		LRCOMMIT *plrcommit = (LRCOMMIT *)plr;
		LRCOMMIT0 *plrcommit0 = (LRCOMMIT0 *)plr;

		CallR( ErrLGPpibFromProcid( plrcommit->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		/*	check transaction level
		/**/
		Assert( ppib->level >= 1 );

		TraceRedo( plr );

		levelCommitTo = plrcommit->level;

		while ( ppib->level != levelCommitTo )
			{
			if ( ppib->level == 1 )
				{
				ppib->trxCommit0 = plrcommit0->trxCommit0;
				trxNewest = max( trxNewest, ppib->trxCommit0 );

				Assert( ppib->fPrecommit );
				ppib->fPrecommit = fFalse;
				}
			else
				VERPrecommitTransaction( ppib );

			VERCommitTransaction( ppib, 0 );
			}

		break;
		}

	case lrtypRollback:
		{
		LRROLLBACK *plrrollback = (LRROLLBACK *)plr;
		LEVEL   level = plrrollback->levelRollback;

		CallR( ErrLGPpibFromProcid( plrrollback->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		/*	check transaction level
		/**/
//      if ( ppib->level <= 0 )
//           break;
		Assert( ppib->level >= level );

		TraceRedo( plr );

		while ( level-- && ppib->level > 0 )
			{
			CallS( ErrVERRollback( ppib ) );
			}
#ifdef DEBUG
		/*	there should be no RCEs
		 */
		if ( ppib->level == 0 )
			{
			RCE *prceT = ppib->prceNewest;
			while ( prceT != prceNil )
				Assert( prceT->oper == operNull );
			}
#endif
		break;
		}

	case lrtypFreeSpace:
		{
		BOOL			fRedoNeeded;
		LRFREESPACE		*plrfs = (LRFREESPACE *)plr;
		FUCB			*pfucb;
		SRID			bm = plrfs->bm;
		RCE				*prce;

		dbid = plrfs->dbid;
		CallR( ErrLGPpibFromProcid( plrfs->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/*	check transaction level
		/**/
		Assert( ppib->level > 0 );

		TraceRedo( plr );

		pn = PnOfDbidPgno( dbid, PgnoOfSrid( plrfs->bmTarget ) );
		qwxDBTime.l = plrfs->ulDBTimeLow;
		qwxDBTime.h = (ULONG) plrfs->wDBTimeHigh;
		err = ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				LGIReportEventOfReadError( dbid, pn, err );
				errGlobalRedoError = err;
				err = JET_errSuccess;
				break;
				}
			else
				return err;
			}

		CallR( ErrLGGetFucb( ppib,
			PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
			&pfucb ) );

		/*	locate the version entry out of version store
		/**/
		prce = PrceRCEGet( dbid, bm );
		Assert( prce != prceNil );

		for (   ;
				prce != prceNil &&
				plrfs->level == prce->level &&
				( prce->oper == operReplace || prce->oper == operReplaceWithDeferredBI ) &&
				PpibLGOfProcid( plrfs->procid ) == pfucb->ppib ;
				prce = prce->prcePrevOfNode )
			{
			Assert( plrfs->level == prce->level &&
				( prce->oper == operReplace || prce->oper == operReplaceWithDeferredBI ) &&
				PpibLGOfProcid( plrfs->procid ) == pfucb->ppib );

			if ( !fRedoNeeded )
				{
				Assert( prce->bmTarget == sridNull );
				Assert( plrfs->bmTarget != sridNull );
				Assert( plrfs->bmTarget != 0 );

				/*	reset deferred space so that there will be no redo for commit
				/**/
				*( (SHORT *)prce->rgbData + 1 ) = 0;
				}
			else
				{
				/*	store the ulDBTime in prce such that it when redoing freespace,
				 *      we will set the correct timestamp.
				 */
				prce->bmTarget = plrfs->bmTarget;
				prce->qwDBTime = qwxDBTime.qw;
				}
			}
		break;
		}

	case lrtypUndo:
		{
		BOOL    fRedoNeeded;
		LRUNDO  *plrundo = (LRUNDO *)plr;
		FUCB    *pfucb;
		SRID    bm = plrundo->bm;
		SRID    item = plrundo->item;
		RCE		*prce;

		dbid = plrundo->dbid;
		CallR( ErrLGPpibFromProcid( plrundo->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/*	check transaction level
		/**/
		if ( ppib->level <= 0 )
			break;

		TraceRedo( plr );

		pn = PnOfDbidPgno( dbid, PgnoOfSrid( plrundo->bmTarget ) );
		qwxDBTime.l = plrundo->ulDBTimeLow;
		qwxDBTime.h = (ULONG) plrundo->wDBTimeHigh;
		err = ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				LGIReportEventOfReadError( dbid, pn, err );
				errGlobalRedoError = err;
				err = JET_errSuccess;
				break;
				}
			else
				return err;
			}

		CallR( ErrLGGetFucb( ppib,
			PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
			&pfucb ) );

		/*	take the version entry out of version store
		/**/
		prce = PrceRCEGet( dbid, bm );
		Assert( prce != prceNil );
		while ( prce != prceNil )
			{
			if ( plrundo->oper == operInsertItem ||
				plrundo->oper == operFlagInsertItem ||
				plrundo->oper == operFlagDeleteItem )
				{
				while ( prce != prceNil &&
					*(SRID *)prce->rgbData != item )
					{
					prce = prce->prcePrevOfNode;
					}
				}

			Assert( prce != prceNil );
			if ( prce == prceNil )
				break;

			if ( plrundo->level == prce->level &&
				 PpibLGOfProcid( plrundo->procid ) == prce->pfucb->ppib &&
				 ( plrundo->oper == prce->oper ||
				   plrundo->oper == operReplace && prce->oper == operReplaceWithDeferredBI )
			   )
				{
				if ( fRedoNeeded )
					{
					Assert( prce->oper != operReplaceWithDeferredBI );
					
					Assert( FVERUndoLoggedOper( prce ) );
						
					Assert( prce->bmTarget == sridNull );
					Assert( plrundo->bmTarget != sridNull );
					Assert( plrundo->bmTarget != 0 );
					prce->bmTarget = plrundo->bmTarget;
					prce->qwDBTime = qwxDBTime.qw;
					err = ErrVERUndo( prce );
					}

				prce->oper = operNull;
				VERDeleteRce( prce );
				break;
				}
			else
				{
				/*	continue searching next rce
				 */
				prce = prce->prcePrevOfNode;
				}
			}

		break;
		}

	/****************************************************
	 *     Split Operations                             *
	 ****************************************************/

	case lrtypSplit:
		{
		LRSPLIT	*plrsplit = (LRSPLIT *)plr;
		INT		splitt = plrsplit->splitt;
		BOOL	fRedoNeeded;
		BOOL	fSkipMoves;
		INT		iGetBufRetry = 0;

		CallR( ErrLGPpibFromProcid( plrsplit->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		pn = plrsplit->pn;
		dbid = DbidOfPn( pn );

		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/*	check if database needs opening
		/**/
		if ( !FUserOpenedDatabase( ppib, dbid ) )
			{
			DBID dbidT = dbid;

			CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ) );
			Assert( dbidT == dbid);
			/*	reset to prevent interference
			/**/
			DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 );
			}

		/*	check if the split page need be redone
		/**/
		qwxDBTime.l = plrsplit->ulDBTimeLow;
		qwxDBTime.h = plrsplit->ulDBTimeHigh;
		if ( ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded )
				== JET_errSuccess && fRedoNeeded == fFalse )
			{
			PN pnNew;
			PATCH *ppatch;

			fSkipMoves = fTrue;

			/*	we might have to patch the page if a patch is available.
			/**/
			pnNew = PnOfDbidPgno( dbid, plrsplit->pgnoNew );
			if ( fHardRestore &&
				 plrsplit->splitt != splittAppend &&
				 ( ( ErrLGRedoable( ppib, pnNew, qwxDBTime.qw, &pbf, &fRedoNeeded )
				   != JET_errSuccess ) || fRedoNeeded )
			   )
				{
				ppatch = PpatchLGSearch( qwxDBTime.qw, pnNew );
				Assert( ppatch != NULL );
				if ( ppatch != NULL )
					{
					CallR( ErrLGPatchPage( ppib, pnNew, ppatch ) );
					}
				else
					{
					CallR( ErrERRCheck( JET_errMissingPatchPage ) );
					}
				}

			if ( plrsplit->splitt == splittDoubleVertical )
				{
				pnNew = PnOfDbidPgno( dbid, plrsplit->pgnoNew2 );
				if ( fHardRestore &&
					( ( ErrLGRedoable( ppib, pnNew, qwxDBTime.qw, &pbf, &fRedoNeeded )
						!= JET_errSuccess ) || fRedoNeeded )
				   )
					{
					ppatch = PpatchLGSearch( qwxDBTime.qw, pnNew );
					Assert( ppatch != NULL );
					if ( ppatch != NULL )
						{
						CallR( ErrLGPatchPage( ppib, pnNew, ppatch ) );
						}
					else
						{
						CallR( ErrERRCheck( JET_errMissingPatchPage ) );
						}
					}
				pnNew = PnOfDbidPgno( dbid, plrsplit->pgnoNew3 );
				if ( fHardRestore &&
					( ( ErrLGRedoable( ppib, pnNew, qwxDBTime.qw, &pbf, &fRedoNeeded )
						!= JET_errSuccess ) || fRedoNeeded )
				   )
					{
					ppatch = PpatchLGSearch( qwxDBTime.qw, pnNew );
					Assert( ppatch != NULL );
					if ( ppatch != NULL )
						{
						CallR( ErrLGPatchPage( ppib, pnNew, ppatch ) );
						}
					else
						{
						CallR( ErrERRCheck( JET_errMissingPatchPage ) );
						}
					}
				}
			}
		else
			fSkipMoves = fFalse;

		TraceRedo( plr );

		CallR( ErrLGGetFucb( ppib,
			PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
			&pfucb ) );

		/*	redo the split, set time stamp accordingly
		/**/
#define iGetBufRetryMax 10
		iGetBufRetry = 0;
		while ( ( err = ErrRedoSplitPage( pfucb,
			plrsplit, splitt, fSkipMoves ) ) == JET_errOutOfMemory )
			{
			BFSleep( 100L );
			iGetBufRetry++;

			if ( iGetBufRetry > iGetBufRetryMax )
				break;
			}
		CallR( err );
		}
		break;

	case lrtypMerge:
		{
		LRMERGE *plrmerge = (LRMERGE *)plr;
		BOOL    fRedoNeeded;
		BOOL    fCheckBackLinkOnly;
		BOOL    fCheckNoUpdateSibling;
		INT     crepeat = 0;
		PN		pnRight;
		PN		pnPagePtr;
		BOOL	fUpdatePagePtr;
			
		CallR( ErrLGPpibFromProcid( plrmerge->procid, &ppib ) );
//		Assert( fFalse );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		/*	merge always happen on level 0
		/**/
//		if ( !( ppib->fAfterFirstBT ) )
//			break;

		/*	fake the lgposStart.
		 */
		ppib->lgposStart = lgposRedo;

		pn = plrmerge->pn;
		dbid = DbidOfPn( pn );

		/*	if not redo system database,
		/*	or softrestore in second page then continue to next.
		/**/
		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/* check if database needs opening
		/**/
		if ( !FUserOpenedDatabase( ppib, dbid ) )
			{
			DBID    dbidT = dbid;

			CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ) );
			Assert( dbidT == dbid);
			/* reset to prevent interference
			/**/
			DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 );
			}

		pnRight = PnOfDbidPgno( dbid, plrmerge->pgnoRight );
			
		/* first, check right page, then check if the merge page need be redone.
		/**/
		qwxDBTime.l = plrmerge->ulDBTimeLow;
		qwxDBTime.h = plrmerge->ulDBTimeHigh;
		if ( ( ErrLGRedoable( ppib, pnRight, qwxDBTime.qw, &pbf, &fRedoNeeded )
			== JET_errSuccess ) && ( fRedoNeeded == fFalse ) )
			{
			fCheckNoUpdateSibling = fTrue;
			}
		else
			{
			fCheckNoUpdateSibling = fFalse;

			/*	call page space to make sure we have room to insert!
			 */
			(void) CbNDFreePageSpace( pbf );
			}

		if ( ( ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded )
			== JET_errSuccess ) && ( fRedoNeeded == fFalse ) )
			{
			PATCH *ppatch;

			fCheckBackLinkOnly = fTrue;

			/*	check if a more advanced sibling page exists.
			 */
			if ( fHardRestore &&
				 fCheckNoUpdateSibling == fFalse &&
				 ( ppatch = PpatchLGSearch( qwxDBTime.qw, pnRight ) ) != NULL )
				{
				CallR( ErrLGPatchPage( ppib, pnRight, ppatch ) );
				fCheckNoUpdateSibling = fTrue;
				}
			}
		else
			{
			fCheckBackLinkOnly = fFalse;
			}

		pnPagePtr = PnOfDbidPgno( dbid, plrmerge->pgnoParent );

		if ( ( ErrLGRedoable( ppib, pnPagePtr, qwxDBTime.qw, &pbf, &fRedoNeeded )
			== JET_errSuccess ) && ( fRedoNeeded == fFalse ) )
			{
			fUpdatePagePtr = fFalse;
			}
		else
			{
			fUpdatePagePtr = fTrue;
			}

		TraceRedo( plr );

		CallR( ErrLGGetFucb( ppib, PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ), &pfucb ) );

		/* redo the split, set time stamp accordingly
		/* conflict at redo time is not admissible
		/**/
		do
			{
			SignalSend( sigBFCleanProc );

			if ( crepeat++ )
				{
				BFSleep( cmsecWaitGeneric );
				}
			Assert( crepeat < 20 );
			CallR( ErrLGRedoMergePage(
					pfucb, plrmerge, fCheckBackLinkOnly, fCheckNoUpdateSibling, fUpdatePagePtr ) );
			}
		while( err == wrnBMConflict );
		}
		break;

	case lrtypEmptyPage:
		{
		LREMPTYPAGE     *plrep = (LREMPTYPAGE *)plr;
		BOOL            fRedoNeeded;
		BOOL            fSkipDelete;
		RMPAGE          rmpage;
		BOOL            fDummy;

		qwxDBTime.l = plrep->ulDBTimeLow;
		qwxDBTime.h = plrep->ulDBTimeHigh;

		memset( (BYTE *)&rmpage, 0, sizeof(RMPAGE) );
		rmpage.qwDBTimeRedo = qwxDBTime.qw;
		rmpage.dbid = DbidOfPn( plrep->pn );
		rmpage.pgnoRemoved = PgnoOfPn( plrep->pn );
		rmpage.pgnoLeft = plrep->pgnoLeft;
		rmpage.pgnoRight = plrep->pgnoRight;
		rmpage.pgnoFather = plrep->pgnoFather;
		rmpage.itagFather = plrep->itagFather;
		rmpage.itagPgptr = plrep->itag;
		rmpage.ibSon = plrep->ibSon;

		CallR( ErrLGPpibFromProcid( plrep->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		rmpage.ppib = ppib;
		dbid = DbidOfPn( plrep->pn );

		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/*	check if database needs opening
		/**/
		if ( !FUserOpenedDatabase( ppib, dbid ) )
			{
			DBID dbidT = dbid;

			CallR( ErrDBOpenDatabase( ppib,
				rgfmp[dbid].szDatabaseName,
				&dbidT,
				0 ) );
			Assert( dbidT == dbid);
			DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 ); /* reset to prevent interference */
			}

		/*	check if the remove pointer to empty page need be redone
		/**/
		pn = PnOfDbidPgno( dbid, plrep->pgnoFather );
		if ( ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded )
			== JET_errSuccess && fRedoNeeded == fFalse )
			fSkipDelete = fTrue;
		else
			fSkipDelete = fFalse;

		CallR( ErrLGGetFucb( ppib,
			PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
			&pfucb ) );

		/*	make sure the dependecy is removed.
		 */
		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrep->pn );
		CallR( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
		if ( pfucb->ssib.pbf->cDepend != 0 || pfucb->ssib.pbf->pbfDepend != pbfNil )
			CallR( ErrBFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf, fBFWait ) );

		TraceRedo( plr );

		/* latch parent and sibling pages as needed
		/**/
		if ( !fSkipDelete )
			{
			CallR( ErrBFAccessPage( ppib, &rmpage.pbfFather,
				PnOfDbidPgno( dbid, plrep->pgnoFather ) ) );
			err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfFather );
			Assert( err != JET_errWriteConflict );
			CallR( err );
			}
		else
			{
			Assert( rmpage.pbfFather == pbfNil );
			}

		if ( plrep->pgnoLeft == pgnoNull )
			{
			rmpage.pbfLeft = pbfNil;
			}
		else
			{
			CallJ( ErrBFAccessPage( ppib,
				&rmpage.pbfLeft,
				PnOfDbidPgno( dbid, plrep->pgnoLeft ) ),
				EmptyPageFail );
			if ( QwPMDBTime( rmpage.pbfLeft->ppage ) >= qwxDBTime.qw )
				rmpage.pbfLeft = pbfNil;
			else
				{
				err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfLeft );
				Assert( err != JET_errWriteConflict );
				CallJ( err, EmptyPageFail );
				}
			}

		if ( plrep->pgnoRight == pgnoNull )
			{
			rmpage.pbfRight = pbfNil;
			}
		else
			{
			CallJ( ErrBFAccessPage( ppib, &rmpage.pbfRight,
				PnOfDbidPgno( dbid, plrep->pgnoRight ) ), EmptyPageFail);
			if ( QwPMDBTime( rmpage.pbfRight->ppage ) >= qwxDBTime.qw )
				rmpage.pbfRight = pbfNil;
			else
				{
				err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfRight );
				Assert( err != JET_errWriteConflict );
				CallJ( err, EmptyPageFail );
				}
			}
		err = ErrBMDoEmptyPage( pfucb, &rmpage, fFalse, &fDummy, fSkipDelete);
		Assert( err == JET_errSuccess );
EmptyPageFail:

		/*	release latches
		/**/
		BTReleaseRmpageBfs( fTrue, &rmpage );
		CallR( err );
		}
		break;

	/****************************************************/
	/*	Misc Operations                              */
	/****************************************************/

	case lrtypInitFDP:
		{
		BOOL		fRedoNeeded;
		LRINITFDP	*plrinitfdppage = (LRINITFDP*)plr;
		PGNO		pgnoFDP;

		CallR( ErrLGPpibFromProcid( plrinitfdppage->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		pn = plrinitfdppage->pn;
		dbid = DbidOfPn( pn );
		pgnoFDP = PgnoOfPn(pn);

		if ( rgfmp[dbid].pdbfilehdr == NULL )
			break;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			break;

		/*	check if database needs opening
		/**/
		if ( !FUserOpenedDatabase( ppib, dbid ) )
			{
			DBID dbidT = dbid;

			CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName,
				&dbidT, 0 ) );
			Assert( dbidT == dbid);
			/*	reset to prevent interference
			/**/
			DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 );
			}

		/*	check if the FDP page need be redone
		/*	always redo since it is a new page, if we do not use checksum.
		/*	The ulDBTime could be larger than the given ulDBTime since the
		/*	page is not initialized.
		/**/
#ifdef CHECKSUM
		qwxDBTime.l = plrinitfdppage->ulDBTimeLow;
		qwxDBTime.h = plrinitfdppage->ulDBTimeHigh;
		if ( ErrLGRedoable(ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded )
				== JET_errSuccess && fRedoNeeded == fFalse )
			break;
#endif
		TraceRedo(plr);

		CallR( ErrLGGetFucb( ppib, pn, &pfucb ) );

		CallR( ErrSPInitFDPWithExt(
				pfucb,
				plrinitfdppage->pgnoFDPParent,
				pgnoFDP,
				plrinitfdppage->cpgGot + 1,   /* include fdp page again */
				plrinitfdppage->cpgWish ) );

		CallR( ErrBFAccessPage( ppib, &pbf, pn ) );
		BFSetDirtyBit( pbf );
		rgfmp[dbid].qwDBTimeCurrent = qwxDBTime.qw;
		PMSetDBTime( pbf->ppage, qwxDBTime.qw );
		}
		break;

	case lrtypELC:
		{
		BOOL    fRedoNeeded;
		LRELC   *plrelc = (LRELC*)plr;
		PGNO    pgno, pgnoSrc;
		PN      pn, pnSrc;
		SSIB    *pssib;
		CSR     *pcsr;
		BOOL	fEnterCritSplit = fFalse;
		BOOL	fPinPage = fFalse;

		qwxDBTime.l = plrelc->ulDBTimeLow;
		qwxDBTime.h = plrelc->ulDBTimeHigh;

		pn = plrelc->pn;
		dbid = DbidOfPn( pn );
		pgno = PgnoOfPn(pn);
		pgnoSrc = PgnoOfSrid(plrelc->sridSrc);
		pnSrc = PnOfDbidPgno(dbid, pgnoSrc);

		CallR( ErrLGPpibFromProcid( plrelc->procid, &ppib ) );

		if ( ppib->fMacroGoing )
			return ErrLGIStoreLogRec( ppib, plr );

		if ( !ppib->fAfterFirstBT )
			break;

		Assert( ppib->level == 1 );
			
		if ( rgfmp[dbid].pdbfilehdr == NULL )
			goto DoCommit;

		if ( CmpLgpos( &rgfmp[dbid].pdbfilehdr->lgposAttach, &lgposRedo ) > 0 )
			goto DoCommit;

		/*	check if database needs opening
		/**/
		if ( !FUserOpenedDatabase( ppib, dbid ) )
			{
			DBID dbidT = dbid;

			CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ) );
			Assert( dbidT == dbid);
			/*	reset to prevent interference
			/**/
			DBHDRSetDBTime( rgfmp[ dbid ].pdbfilehdr, 0 );
			}

		/*	get critSplit to block RCECleanProc
		/**/
		LeaveCriticalSection( critJet );
		EnterNestableCriticalSection( critSplit );
		fEnterCritSplit = fTrue;
		EnterCriticalSection( critJet );
			
		err = ErrLGRedoable( ppib, pn, qwxDBTime.qw, &pbf, &fRedoNeeded );
		if ( err < 0 )
			{
			err = JET_errSuccess;
			goto DoCommit;
			}

		TraceRedo(plr);

		CallJ( ErrLGGetFucb( ppib,
			PnOfDbidPgno( dbid, pbf->ppage->pgnoFDP ),
			&pfucb), ReleaseCritSplit )

		// Re-access page in case we lost critJet.
		CallJ( ErrBFAccessPage( ppib, &pbf, pn ), ReleaseCritSplit );

		// Ensure page isn't flushed in case we lose critJet.
		BFPin( pbf );
		fPinPage = fTrue;

		pssib = &pfucb->ssib;
		pcsr = PcsrCurrent( pfucb );

		pssib->pbf = pbf;
		pcsr->pgno = pgno;
		pssib->itag =
		pcsr->itag = plrelc->itag;
		if ( pgno == pgnoSrc )
			{
			// UNDONE: the following special casing is a hack to
			// handle ELC when src and destination pages are same
			// fix this by changing ErrBTMoveNode in merge/split
			if ( qwxDBTime.qw > QwPMDBTime( pssib->pbf->ppage ) )
				{
				BF *pbf;

				/*	cache node
				/**/
				NDGet( pfucb, pcsr->itag );
				(VOID)ErrNDExpungeBackLink( pfucb );

				pbf = pssib->pbf;
				Assert( pbf->pn == pn );
				AssertBFDirty(pbf);

				pssib->itag =
				pcsr->itag = ItagOfSrid(plrelc->sridSrc);

				BFSetDirtyBit( pssib->pbf );
				PMExpungeLink( pssib );

				pbf = pssib->pbf;
				Assert( pbf->pn == pnSrc );
				AssertBFDirty( pbf );
				rgfmp[dbid].qwDBTimeCurrent = qwxDBTime.qw;
				PMSetDBTime( pbf->ppage, qwxDBTime.qw );
				}
			}
		else
			{
			if ( qwxDBTime.qw > QwPMDBTime( pssib->pbf->ppage ) )
				{
				BF *pbf;

				/*	cache node
				/**/
				NDGet( pfucb, pcsr->itag );
				(VOID)ErrNDExpungeBackLink( pfucb );

				pbf = pssib->pbf;
				Assert( pbf->pn == pn );
				AssertBFDirty(pbf);
				rgfmp[dbid].qwDBTimeCurrent = qwxDBTime.qw;
				PMSetDBTime( pbf->ppage, qwxDBTime.qw );
				}

			pcsr->pgno = pgnoSrc;
			CallJ( ErrBFWriteAccessPage( pfucb, pgnoSrc ), ReleaseCritSplit );
			if ( qwxDBTime.qw > QwPMDBTime( pssib->pbf->ppage ) )
				{
				BF	*pbf;

				pssib->itag =
				pcsr->itag = ItagOfSrid(plrelc->sridSrc);

				BFSetDirtyBit( pssib->pbf );
				PMExpungeLink( pssib );

				pbf = pssib->pbf;
				Assert( pbf->pn == pnSrc );
				AssertBFDirty( pbf );
				rgfmp[dbid].qwDBTimeCurrent = qwxDBTime.qw;
				PMSetDBTime( pbf->ppage, qwxDBTime.qw );
				}
			}

DoCommit:
		Assert( ppib->level == 1 );
		if ( !ppib->fPrecommit )
			VERPrecommitTransaction( ppib );
		VERCommitTransaction( ppib, fRCECleanSession );

ReleaseCritSplit:
		if ( fPinPage )
			BFUnpin( pbf );
		if ( fEnterCritSplit )
			LeaveNestableCriticalSection( critSplit );

		if ( err < 0 )
			return err;
		}

		break;
		} /*** end of switch statement ***/

	return JET_errSuccess;
	}


/*
 *  ErrLGRedoOperations( )
 *
 *      Scan from lgposRedoFrom to end of usable log generations. For each log
 *  record, perform operations to redo original operation.
 *  Each redo function must call ErrLGRedoable to set qwDBTimeCurrent. If
 *  the function is not called, then qwDBTimeCurrent should manually set.
 *
 *      RETURNS         JET_errSuccess, or error code from failing routine, or one
 *                              of the following "local" errors:
 *                              -LogCorrupted   Logs could not be interpreted
 */

ERR ErrLGRedoOperations( LGPOS *plgposRedoFrom, LGSTATUSINFO *plgstat)
	{
	ERR		err;
	LR		*plr;
	BOOL	fLastLRIsQuit = fFalse;
	BOOL	fShowSectorStatus = fFalse;

	/* if the file is Jet.log closed abnormally, then lgposLastRec is set
	 * so that we will not redo operation over the point. lgposLastRec is
	 * set in LgOpenRedoLogFile.
	 */
//      CallR( ErrLGCheckReadLastLogRecord( &fCloseNormally))
//      GetLgposOfPbEntry(&lgposLastRec);

	/*	initialize global variable.
	 */
	lgposRedoShutDownMarkGlobal = lgposMin;

	/*	reset pbLastMSFlush before restart
	/**/
	CallR( ErrLGLocateFirstRedoLogRec( plgposRedoFrom, (BYTE **) &plr ) );

	GetLgposOfPbNext(&lgposRedo);
	if ( lgposLastRec.isec )
		{
		LGPOS lgposT;
		INT i;

		GetLgposOfPbNext(&lgposT);
		i = CmpLgpos( &lgposT, &lgposLastRec );

		Assert( i <= 0 || lgposT.ib == lgposLastRec.ib + 1 && *( pbNext - 1 ) != lrtypTerm );
		if ( i >= 0 )
			goto Done;
		}

	/*	log redo progress.
	 */
		{
		CHAR	*rgszT[1];
		rgszT[0] = szLogName;
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY,
					REDO_STATUS_ID, 1, rgszT );
		}

	if ( plgstat )
		{
		if ( fShowSectorStatus = ( plgstat->fCountingSectors ) )
			{
			/*	reset byte counts
			/**/
			plgstat->cSectorsSoFar = plgposRedoFrom->isec;
			plgstat->cSectorsExpected = plgfilehdrGlobal->csecLGFile;
			}
		}


	/*	initialize all the system parameters
	/**/
	do
		{
		FMP		*pfmp;			// for db operations
		DBID	dbid;			// for db operations
		INT     fNSNextStep;

		if ( err == errLGNoMoreRecords )
			goto NextGeneration;

CheckNextRec:
		GetLgposOfPbNext(&lgposRedo);

		switch ( plr->lrtyp )
			{
		case lrtypNOP:
			continue;

		case lrtypMacroBegin:
			{
			PIB *ppib;

			LRMACROBEGIN *plrmbegin = (LRMACROBEGIN *) plr;
			Call( ErrLGPpibFromProcid( plrmbegin->procid, &ppib ) );
			Assert( !ppib->fMacroGoing );
			ppib->fMacroGoing = fTrue;
			ppib->levelMacro = ppib->level;
			break;
			}

		case lrtypMacroCommit:
		case lrtypMacroAbort:
			{
			PIB *ppib;
			LRMACROEND *plrmend = (LRMACROEND *) plr;

			Call( ErrLGPpibFromProcid( plrmend->procid, &ppib ) );
			Assert( ppib->fMacroGoing );

			/*	disable fMacroGoing before redo the recorded macro ops.
			 */
			ppib->fMacroGoing = fFalse;
			ppib->levelMacro = 0;
			
			/*	If it is commit, redo all the recorded log records,
			 *	otherwise, throw away the logs.
			 */
			if ( lrtypMacroCommit == plr->lrtyp )
				{
				INT ibLR = 0;

				while ( ibLR < ppib->ibLogRecAvail )
					{
					LR *plr = (LR *) ( ppib->rgbLogRec + ibLR );

					Call( ErrLGIRedoOperation( plr ) );
					ibLR += CbLGSizeOfRec( plr );
					}
				}

			if ( ppib->rgbLogRec )
				{
				SFree( ppib->rgbLogRec );
				ppib->rgbLogRec = NULL;
				ppib->ibLogRecAvail = 0;
				ppib->cbLogRecMac = 0;
				}
			break;
			}

		case lrtypFullBackup:
			lgposFullBackup = lgposRedo;
			break;
			
		case lrtypIncBackup:
			lgposIncBackup = lgposRedo;
			break;

		case lrtypTrace:                /* Debug only log records. */
		case lrtypJetOp:
		case lrtypRecoveryUndo:
			break;

		case lrtypShutDownMark:
			lgposRedoShutDownMarkGlobal = lgposRedo;
			break;

		case lrtypInit:
			{
			/*	start mark the jet init. Abort all active seesions.
			/**/
			LRINIT  *plrstart = (LRINIT *)plr;

			TraceRedo( plr );

			if ( !fGlobalAfterEndAllSessions )
				{
				Call( ErrLGEndAllSessions( fFalse, plgposRedoFrom ) );
				fGlobalAfterEndAllSessions = fTrue;
				}

			/*	Check Init session for hard restore only.
			 */
			Call( ErrLGInitSession( &plrstart->dbms_param, plgstat ) );
			fGlobalAfterEndAllSessions = fFalse;
			}
			break;

		case lrtypRecoveryQuit:
		case lrtypTerm:
			/*	all records are re/done. all rce entries should be gone now.
			/**/
#ifdef DEBUG
			{
			CPPIB   *pcppib = rgcppibGlobal;
			CPPIB   *pcppibMax = pcppib + ccppibGlobal;
			for ( ; pcppib < pcppibMax; pcppib++ )
				if ( pcppib->ppib != ppibNil &&
					 pcppib->ppib->prceNewest != prceNil &&
					 !pcppib->ppib->fPrecommit
					 )
					{
					RCE *prceT = pcppib->ppib->prceNewest;
					while ( prceT != prceNil )
						{
						Assert( prceT->oper == operNull );
						prceT = prceT->prceNextOfSession;
						}
					}
			}
#endif
			
			/*	quit marks the end of a normal run. All sessions
			/*	have ended or must be forced to end. Any further
			/*	sessions will begin with a BeginT.
			/**/
#ifdef DEBUG
			fDBGNoLog = fTrue;
#endif
			/*	set lgposLogRec such that later start/shut down
			 *	will put right lgposConsistent into dbfilehdr
			 *	when closing the database.
			 */
			if ( !fGlobalAfterEndAllSessions )
				{
				Call( ErrLGEndAllSessions( fFalse, plgposRedoFrom ) );
				fGlobalAfterEndAllSessions = fTrue;
				}

			fLastLRIsQuit = fTrue;
			continue;

		case lrtypEnd:
			{
NextGeneration:
			Call( ErrLGIRedoFill( &plr, fLastLRIsQuit, &fNSNextStep) );

			switch( fNSNextStep )
				{
				case fNSGotoDone:
					goto Done;

				case fNSGotoCheck:
					/*	log redo progress.
					 */
						{
						CHAR	*rgszT[1];
						rgszT[0] = szLogName;
						UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY,
								REDO_STATUS_ID, 1, rgszT );
						}

					if ( !plgstat )
						{
						if ( fGlobalRepair )
							printf( " Recovering Generation %d.\n", plgfilehdrGlobal->lGeneration );
						}
					else
						{
						JET_SNPROG	*psnprog = &(plgstat->snprog);
						ULONG		cPercentSoFar;

						plgstat->cGensSoFar += 1;
						Assert(plgstat->cGensSoFar <= plgstat->cGensExpected);
						cPercentSoFar = (ULONG)
							((plgstat->cGensSoFar * 100) / plgstat->cGensExpected);

						Assert( fGlobalSimulatedRestore || cPercentSoFar >= psnprog->cunitDone );
						if ( cPercentSoFar > psnprog->cunitDone )
							{
							psnprog->cunitDone = cPercentSoFar;
							(*plgstat->pfnStatus)( 0, JET_snpRestore,
								JET_sntProgress, psnprog);
							}

						if ( fShowSectorStatus )
							{
							/*	reset byte counts
							/**/
							plgstat->cSectorsSoFar = 0;
							plgstat->cSectorsExpected = plgfilehdrGlobal->csecLGFile;
							}
						}
					goto CheckNextRec;
				}

			/*	should never get here
			/**/
			Assert( fFalse );
			}

   		/****************************************************/
   		/*	Database Operations                          */
   		/****************************************************/

		case lrtypCreateDB:
			{
			LRCREATEDB      *plrcreatedb = (LRCREATEDB *)plr;
			CHAR            *szName = plrcreatedb->rgb;
			INT				irstmap;
			ATCHCHK			*patchchk;
			PIB				*ppib;
			
			dbid = plrcreatedb->dbid;
			Assert( dbid != dbidTemp );

			TraceRedo(plr);

			pfmp = &rgfmp[dbid];

			Assert( pfmp->hf == handleNil );
			Assert( !pfmp->szDatabaseName );
			Call( ErrDBStoreDBPath( szName, &pfmp->szDatabaseName ) );

			/*	Check if need to do Patch DB.
			 */
			if ( fHardRestore )
				{
				/*	attach the database specified in restore map.
				 */
				err = ErrLGGetDestDatabaseName( pfmp->szDatabaseName, &irstmap, plgstat );
				if ( err == JET_errFileNotFound )
					{
					/*	not in the restore map, set to skip it.
					 */
					Assert( pfmp->pdbfilehdr == NULL );
					break;
					}
				else
					Call( err ) ;

				szName = rgrstmapGlobal[irstmap].szNewDatabaseName;
				}

			Call( ErrLGPpibFromProcid( plrcreatedb->procid, &ppib ) );

			if ( pfmp->patchchk == NULL )
				if (( pfmp->patchchk = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
					return ErrERRCheck( JET_errOutOfMemory );

			patchchk = pfmp->patchchk;			
			patchchk->signDb = plrcreatedb->signDb;
			patchchk->lgposConsistent = lgposMin;
			patchchk->lgposAttach = lgposRedo;

			if ( FIOFileExists( szName ) )
				{
				BOOL		fAttachNow;

				/*	Make sure the database has matched signLog and
				 *	this lgpos is proper for the database file.
				 */
				err = ErrLGCheckAttachedDB( dbid, fFalse, patchchk, &fAttachNow, NULL );
				if ( err == JET_errDatabaseCorrupted )
					{
					/*	Delete the file and re-create.
					 */
					goto CreateNewDb;
					}
				else
					{
					if ( err != JET_errSuccess )
						{
						/*	ignore this create DB.
						 */
						break;
						}
					}

				Assert( pfmp->pdbfilehdr );
				if ( fAttachNow )
					{
					if ( fHardRestore )
						{
						if (fGlobalSimulatedRestore )
							{
							Assert( !fGlobalExternalRestore );
							Assert( fGlobalRepair );
							}
						else
							Call( ErrLGPatchDatabase( dbid, irstmap ) );
						}

					/*	Do not re-create the database. Simply attach it. Assuming the
					 *	given database is a good one since signature matches.
					 */
					pfmp->fFlags = 0;
					DBIDSetAttached( dbid );
					
					/*	restore information stored in database file
					/**/
					pfmp->pdbfilehdr->bkinfoFullCur.genLow = lGlobalGenLowRestore;
					pfmp->pdbfilehdr->bkinfoFullCur.genHigh = lGlobalGenHighRestore;

					Call( ErrUtilOpenFile( szName, &pfmp->hf, 0, fFalse, fTrue ));
					pfmp->qwDBTimeCurrent = 0;
					DBHDRSetDBTime( pfmp->pdbfilehdr, 0 );
					pfmp->fLogOn = plrcreatedb->fLogOn;

					// If there's a log record for CreateDatabase(), then logging
					// must be on.
					Assert( pfmp->fLogOn );
			
					// Versioning flag is not persisted (since versioning off
					// implies logging off).
					Assert( !pfmp->fVersioningOff );
					
					/*	Keep extra copy of patchchk for error message.
					 */
					if ( pfmp->patchchkRestored == NULL )
						if (( pfmp->patchchkRestored = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
							return ErrERRCheck( JET_errOutOfMemory );
					*(pfmp->patchchkRestored) = *(pfmp->patchchk);
					}
				else
					{
					/*	wait for next attachment to attach this db.
					 */
					Assert( pfmp->hf == handleNil );
					Assert( pfmp->szDatabaseName );
					UtilFree( pfmp->pdbfilehdr );
					pfmp->pdbfilehdr = NULL;

					/*	still have to set fFlags for keep track of the db status.
					 */					
					pfmp->fLogOn = plrcreatedb->fLogOn;
					
					/*	ignore this create DB.
					 */
					pfmp->fFakedAttach = fTrue;
					break;
					}
				}
			else
				{
CreateNewDb:
				/*	if database exist, delete it and rebuild the database
				/**/
				if ( FIOFileExists( szName ) )
					(VOID) ErrUtilDeleteFile( szName );

				Call( ErrDBCreateDatabase( ppib,
					rgfmp[dbid].szDatabaseName,
					NULL,
					&dbid,
					cpgDatabaseMin,
					plrcreatedb->grbit,
					&plrcreatedb->signDb ) );

				/*	close it as it will get reopened on first use
				/**/
				Call( ErrDBCloseDatabase( ppib, dbid, 0 ) );

				/*	restore information stored in database file
				/**/
				pfmp->pdbfilehdr->bkinfoFullCur.genLow = lGlobalGenLowRestore;
				pfmp->pdbfilehdr->bkinfoFullCur.genHigh = lGlobalGenHighRestore;

				pfmp->qwDBTimeCurrent = QwDBHDRDBTime( pfmp->pdbfilehdr );

				/*	reset to prevent interference
				/**/
				DBHDRSetDBTime( pfmp->pdbfilehdr, 0 );

				Assert( err == JET_errSuccess || err == JET_wrnDatabaseAttached );
				}
			}
			break;

		case lrtypAttachDB:
			{
			LRATTACHDB  *plrattachdb = (LRATTACHDB *)plr;
			CHAR        *szName = plrattachdb->rgb;
			BOOL		fAttachNow;
			BOOL		fReadOnly = plrattachdb->fReadOnly;
			INT			irstmap;
			ATCHCHK		*patchchk;

			dbid = plrattachdb->dbid;

			Assert( dbid != dbidTemp );

			TraceRedo( plr );

			pfmp = &rgfmp[dbid];

			/*	check if szName is in the restore map. If it is, set
			 *	up the fmp.
			 */
			if ( !pfmp->szDatabaseName )
				Call( ErrDBStoreDBPath( szName, &pfmp->szDatabaseName) )

			/*	Check if need to do Patch DB.
			 */
			if ( fHardRestore )
				{
				/*	attach the database specified in restore map.
				 */
				err = ErrLGGetDestDatabaseName( pfmp->szDatabaseName, &irstmap, plgstat );
				if ( err == JET_errFileNotFound )
					{
					/*	not in the restore map, set to skip it.
					 */
					Assert( pfmp->pdbfilehdr == NULL );
					break;
					}
				else
					Call( err ) ;

				szName = rgrstmapGlobal[irstmap].szNewDatabaseName;
				}

			/*	Make sure the database has matched signLog and
			 *	this lgpos is proper for the database file.
			 */
			if ( pfmp->patchchk == NULL )
				if (( pfmp->patchchk = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
					return ErrERRCheck( JET_errOutOfMemory );

			patchchk = pfmp->patchchk;			
			patchchk->signDb = plrattachdb->signDb;
			patchchk->lgposConsistent = plrattachdb->lgposConsistent;
			patchchk->lgposAttach = lgposRedo;

			err = ErrLGCheckAttachedDB( dbid, fReadOnly, patchchk, &fAttachNow, &plrattachdb->signLog );
			if ( err != JET_errSuccess || !fAttachNow )
				{
				/*	ignore error to continue restore.
				 */
				if ( err == JET_errSuccess )
					{
					/*	wait for next attachment to attach this db.
					 */
					Assert( pfmp->hf == handleNil );
					Assert( pfmp->szDatabaseName != NULL );
					UtilFree( pfmp->pdbfilehdr );
					pfmp->pdbfilehdr = NULL;
					}
				
				/*	still have to set fFlags for keep track of the db status.
				 */
				pfmp->fLogOn = plrattachdb->fLogOn;
				pfmp->fVersioningOff = plrattachdb->fVersioningOff;
				pfmp->fReadOnly = fReadOnly;

				pfmp->fFakedAttach = fTrue;

				/*	ignore this attach DB.
				 */
				break;
				}
			else
				{
				DBFILEHDR	*pdbfilehdr = pfmp->pdbfilehdr;

				Assert( pfmp->pdbfilehdr );
				Assert( fAttachNow );
				if ( fHardRestore )
					{
					if (fGlobalSimulatedRestore )
						{
						Assert( !fGlobalExternalRestore );
						Assert( fGlobalRepair );
						}
					else
						Call( ErrLGPatchDatabase( dbid, irstmap ) );
					}

				pfmp->fFlags = 0;
				DBIDSetAttached( dbid );
				
				/*	Update database file header.
				 */
				if ( !fReadOnly )
					{
					BOOL fKeepBackupInfo = fFalse;

					if ( fHardRestore &&
						 _stricmp( rgrstmapGlobal[irstmap].szDatabaseName,
								  rgrstmapGlobal[irstmap].szNewDatabaseName ) == 0 )
						{
						/*	An attach after a hard restore, the attach must be created
						 *	by previous recovery undo mode. Do not erase backup info then.
						 */
						fKeepBackupInfo = fTrue;
						}

					DBISetHeaderAfterAttach( pdbfilehdr, lgposRedo, dbid, fKeepBackupInfo );
					Call( ErrUtilWriteShadowedHeader( szName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
					}

				/*	restore information stored in database file
				/**/
				pfmp->pdbfilehdr->bkinfoFullCur.genLow = lGlobalGenLowRestore;
				pfmp->pdbfilehdr->bkinfoFullCur.genHigh = lGlobalGenHighRestore;

				Call( ErrUtilOpenFile( szName, &pfmp->hf, 0, fFalse, fTrue ) );
				pfmp->qwDBTimeCurrent = 0;
				DBHDRSetDBTime( pfmp->pdbfilehdr, 0 );

				pfmp->fLogOn = plrattachdb->fLogOn;
				pfmp->fVersioningOff = plrattachdb->fVersioningOff;
				pfmp->fReadOnly = fReadOnly;

				// If there's a log record for AttachDatabase(), then logging
				// must be on.
				Assert( pfmp->fLogOn );

				// Versioning flag is not persisted (since versioning off
				// implies logging off).
				Assert( !pfmp->fVersioningOff );

				/*	Keep extra copy of patchchk for error message.
				 */
				if ( pfmp->patchchkRestored == NULL )
					if (( pfmp->patchchkRestored = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
						return ErrERRCheck( JET_errOutOfMemory );
				*(pfmp->patchchkRestored) = *(pfmp->patchchk);
				}
			}
			break;

		case lrtypDetachDB:
			{
			LRDETACHDB		*plrdetachdb = (LRDETACHDB *)plr;
			DBID			dbid = plrdetachdb->dbid;

			Assert( dbid != dbidTemp );
			pfmp = &rgfmp[dbid];

			if ( pfmp->pdbfilehdr )
				{
				/*	close database for all active user.
				 */
				CPPIB   *pcppib = rgcppibGlobal;
				CPPIB   *pcppibMax = pcppib + ccppibGlobal;
				PIB		*ppib;

				/*	find pcppib corresponding to procid if it exists
				 */
				for ( ; pcppib < pcppibMax; pcppib++ )
					{
					PIB *ppib = pcppib->ppib;
					
					if ( ppib == NULL )
						continue;

					while( FUserOpenedDatabase( ppib, dbid ) )
						{
						/*	close all fucb on this database.
						 */
						if ( pcppib->rgpfucbOpen[dbid] != pfucbNil )
							{
							Assert( pcppib->rgpfucbOpen[dbid]->pbKey == NULL );
							Assert( !FFUCBDenyRead( pcppib->rgpfucbOpen[dbid] ) );
							Assert( !FFUCBDenyWrite( pcppib->rgpfucbOpen[dbid] ) );
							FCBUnlink( pcppib->rgpfucbOpen[dbid] );
							FUCBClose( pcppib->rgpfucbOpen[dbid] );
							}
						Call( ErrDBCloseDatabase( ppib, dbid, 0 ) );
						}
					}

				/*	if attached before this detach.
				 *	there should be no more operations on this database entry.
				 *	detach it!!
				 */
				if ( pfmp->pdbfilehdr->bkinfoFullCur.genLow != 0 )
					{
					Assert( pfmp->pdbfilehdr->bkinfoFullCur.genHigh != 0 );
					pfmp->pdbfilehdr->bkinfoFullPrev = pfmp->pdbfilehdr->bkinfoFullCur;
					memset(	&pfmp->pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
					memset(	&pfmp->pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
					}
				Call( ErrLGPpibFromProcid( plrdetachdb->procid, &ppib ) );
				if ( !pfmp->fReadOnly )
					{
					/*	make the size matching.
					 */
					Call( ErrLGICheckDatabaseFileSize( ppib, dbid ) );
					}
				Call( ErrIsamDetachDatabase( (JET_VSESID) ppib, pfmp->szDatabaseName ) );
				}
			else
				{
				Assert( pfmp->szDatabaseName != NULL );
				if ( pfmp->szDatabaseName != NULL )
					{
					SFree( pfmp->szDatabaseName);
					pfmp->szDatabaseName = NULL;
					}

				pfmp->fFlags = 0;
				}

			if ( pfmp->patchchk )
				{
				SFree( pfmp->patchchk );
				pfmp->patchchk = NULL;
				}

			TraceRedo(plr);
			}
			break;

   		/****************************************************/
   		/*	Operations Using ppib (procid)                  */
   		/****************************************************/

		default:
			Call( ErrLGIRedoOperation( plr ) );
			} /* switch */

#ifdef DEBUG
		fDBGNoLog = fFalse;
#endif
		fLastLRIsQuit = fFalse;

		/*	update sector status, if we moved to a new sector
		/**/
		Assert( !fShowSectorStatus || lgposRedo.isec >= plgstat->cSectorsSoFar );
		Assert( lgposRedo.isec != 0 );
		if ( fShowSectorStatus && lgposRedo.isec > plgstat->cSectorsSoFar )
			{
			ULONG		cPercentSoFar;
			JET_SNPROG	*psnprog = &(plgstat->snprog);

			Assert( plgstat->pfnStatus );
			
			plgstat->cSectorsSoFar = lgposRedo.isec;
			cPercentSoFar = (ULONG)((100 * plgstat->cGensSoFar) / plgstat->cGensExpected);
			
			cPercentSoFar += (ULONG)((plgstat->cSectorsSoFar * 100) /
				(plgstat->cSectorsExpected * plgstat->cGensExpected));

			Assert( cPercentSoFar <= 100 );

			/*	because of rounding, we might think that we finished
			/*	the generation when we really have not, so comparison
			/*	is <= instead of <.
			/**/
			Assert( cPercentSoFar <= (ULONG)( ( 100 * ( plgstat->cGensSoFar + 1 ) ) / plgstat->cGensExpected ) );

//			Assert( fGlobalSimulatedRestore || cPercentSoFar >= psnprog->cunitDone );
			if ( cPercentSoFar > psnprog->cunitDone )
				{
				psnprog->cunitDone = cPercentSoFar;
				(*plgstat->pfnStatus)( 0, JET_snpRestore, JET_sntProgress, psnprog );
				}
			}
		}
	while ( ( err = ErrLGGetNextRec( (BYTE **) &plr ) ) ==
		JET_errSuccess || err == errLGNoMoreRecords );


Done:
	err = JET_errSuccess;

HandleError:
	/*	assert all operations successful for restore from consistent
	/*	backups
	/**/
#ifndef RFS2
	AssertSz( err >= 0,     "Debug Only, Ignore this Assert");
#endif

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\std.c ===
#include "std.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\sortapi.c ===
#include "daestd.h"

DeclAssertFile; 				/* Declare file name for assert macros */

/* table definition of LIDMap table
/**/
static CODECONST( JET_COLUMNDEF ) columndefLIDMap[] =
	{
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed | JET_bitColumnTTKey},
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed}
	};

#define ccolumndefLIDMap ( sizeof( columndefLIDMap ) / sizeof( JET_COLUMNDEF ) )

#define icolumnLidSrc		0				/* column index for columndefLIDMap */
#define icolumnLidDest		1				/* column index for columndefLIDMap */

#define cbLvMax				(16*cbPage)		/* buffer for copying tagged columns */


#define fCOLSDELETEDNone		0					// Flags to determine if any columns have been deleted.
#define	fCOLSDELETEDFixedVar	(1<<0)
#define fCOLSDELETEDTagged		(1<<1)

#define FCOLSDELETEDNone( fColumnsDeleted )			( (fColumnsDeleted) == fCOLSDELETEDNone )
#define FCOLSDELETEDFixedVar( fColumnsDeleted )		( (fColumnsDeleted) & fCOLSDELETEDFixedVar )
#define FCOLSDELETEDTagged( fColumnsDeleted )		( (fColumnsDeleted) & fCOLSDELETEDTagged )

#define FCOLSDELETEDSetNone( fColumnsDeleted )		( (fColumnsDeleted) = fCOLSDELETEDNone )
#define FCOLSDELETEDSetFixedVar( fColumnsDeleted )	( (fColumnsDeleted) |= fCOLSDELETEDFixedVar )
#define FCOLSDELETEDSetTagged( fColumnsDeleted )	( (fColumnsDeleted) |= fCOLSDELETEDTagged )



/*	globals for off-line compact
/**/
STATIC	JET_TABLEID		tableidGlobalLIDMap = JET_tableidNil;
STATIC	JET_COLUMNDEF	rgcolumndefGlobalLIDMap[ccolumndefLIDMap];

/*	set up LV copy buffer and tableids for IsamCopyRecords
/**/
ERR ErrSORTInitLIDMap( PIB *ppib )
	{
	ERR				err;
	JET_COLUMNID 	rgcolumnid[ccolumndefLIDMap];
	ULONG			icol;

	Assert( tableidGlobalLIDMap == JET_tableidNil );

	memcpy( rgcolumndefGlobalLIDMap, columndefLIDMap, sizeof( columndefLIDMap ) );

	/*	open temporary table
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		rgcolumndefGlobalLIDMap,
		ccolumndefLIDMap,
		0,
		JET_bitTTUpdatable|JET_bitTTIndexed,
		&tableidGlobalLIDMap,
		rgcolumnid ) );

	for ( icol = 0; icol < ccolumndefLIDMap; icol++ )
		{
		rgcolumndefGlobalLIDMap[icol].columnid = rgcolumnid[icol];
		}

	return err;
	}


/*	free LVBuffer and close LIDMap table
/**/
INLINE LOCAL ERR ErrSORTTermLIDMap( PIB *ppib )
	{
	ERR		err;

	Assert( tableidGlobalLIDMap != JET_tableidNil );
	CallR( ErrDispCloseTable( (JET_SESID)ppib, tableidGlobalLIDMap ) );
	tableidGlobalLIDMap = JET_tableidNil;
	return JET_errSuccess;
	}


INLINE LOCAL ERR ErrSORTTableOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, LANGID langid, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid )
	{
	ERR				err;
	INT				icolumndefMax = (INT)ccolumndef;
	INT				wFlags = (INT)grbit;
	FUCB  			*pfucb = pfucbNil;
	FDB				*pfdb;
	JET_COLUMNDEF	*pcolumndef;
	JET_COLUMNID	*pcolumnid;
	JET_COLUMNDEF	*pcolumndefMax = rgcolumndef+icolumndefMax;
	TCIB			tcib = { fidFixedLeast - 1, fidVarLeast - 1, fidTaggedLeast - 1 };
	ULONG			ibRec;
	BOOL			fTruncate;
	//	UNDONE:		find better way to set these values.  Note that this causes
	//				a problem because QJET would have to notify us of locale and
	//				it does not do this.
	IDB				idb;

	CheckPIB( ppib );

	CallJ( ErrSORTOpen( ppib, &pfucb, ( wFlags & JET_bitTTUnique ? fSCBUnique : 0 ) ), SimpleError )
	*ppfucb = pfucb;

	/*	save open flags
	/**/
	pfucb->u.pscb->grbit = grbit;

	/*	determine max field ids and fix up lengths
	/**/

	//====================================================
	// Determine field "mode" as follows:
	// if ( JET_bitColumnTagged given ) or "long" ==> TAGGED
	// else if ( numeric type || JET_bitColumnFixed given ) ==> FIXED
	// else ==> VARIABLE
	//====================================================
	// Determine maximum field length as follows:
	// switch ( field type )
	//	   case numeric:
	//		   max = <exact length of specified type>;
	//	   case "short" textual:
	//		   if ( specified max == 0 ) max = JET_cbColumnMost
	//		   else max = MIN( JET_cbColumnMost, specified max )
	//====================================================
	for ( pcolumndef = rgcolumndef, pcolumnid = rgcolumnid; pcolumndef < pcolumndefMax; pcolumndef++, pcolumnid++ )
		{
		if ( ( pcolumndef->grbit & JET_bitColumnTagged ) ||
			FRECLongValue( pcolumndef->coltyp ) )
			{
			if ( ( *pcolumnid = ++tcib.fidTaggedLast ) > fidTaggedMost )
				{
				Error( ErrERRCheck( JET_errTooManyColumns ), HandleError );
				}
			}
		else if ( pcolumndef->coltyp == JET_coltypBit ||
			pcolumndef->coltyp == JET_coltypUnsignedByte ||
			pcolumndef->coltyp == JET_coltypShort ||
			pcolumndef->coltyp == JET_coltypLong ||
			pcolumndef->coltyp == JET_coltypCurrency ||
			pcolumndef->coltyp == JET_coltypIEEESingle ||
			pcolumndef->coltyp == JET_coltypIEEEDouble ||
			pcolumndef->coltyp == JET_coltypDateTime ||
#ifdef NEW_TYPES
			pcolumndef->coltyp == JET_coltypDate ||
			pcolumndef->coltyp == JET_coltypTime ||
			pcolumndef->coltyp == JET_coltypGuid ||
#endif
			( pcolumndef->grbit & JET_bitColumnFixed ) )
			{
			if ( ( *pcolumnid = ++tcib.fidFixedLast ) > fidFixedMost )
				{
				Error( ErrERRCheck( JET_errTooManyColumns ), HandleError );
				}
			}
		else
			{
			if ( ( *pcolumnid = ++tcib.fidVarLast ) > fidVarMost )
				Error( ErrERRCheck( JET_errTooManyColumns ), HandleError );
			}
		}

	Call( ErrRECNewFDB( &pfdb, &tcib, fFalse ) );

	pfucb->u.pscb->fcb.pfdb = pfdb;
	Assert( pfucb->u.pscb->fcb.pidb == pidbNil );

	ibRec = sizeof(RECHDR);

	idb.iidxsegMac = 0;
	for ( pcolumndef = rgcolumndef, pcolumnid = rgcolumnid; pcolumndef < pcolumndefMax; pcolumndef++, pcolumnid++ )
		{
		FIELDEX fieldex;

		fieldex.field.coltyp = pcolumndef->coltyp;
		fieldex.field.ffield = 0;
		fieldex.field.itagFieldName = 0;
		if ( FRECTextColumn( fieldex.field.coltyp ) )
			{
			fieldex.field.cp = pcolumndef->cp;
			}

		Assert( fieldex.field.coltyp != JET_coltypNil );
		fieldex.field.cbMaxLen = UlCATColumnSize( fieldex.field.coltyp, pcolumndef->cbMax, &fTruncate );

		fieldex.fid = (FID)*pcolumnid;

		/*	ibRecordOffset is only relevant for fixed fields.  It will be ignored by
		/*	RECAddFieldDef(), so do not set it.
		/**/
		if ( FFixedFid ( fieldex.fid ) )
			{
			fieldex.ibRecordOffset = (WORD) ibRec;
			ibRec += fieldex.field.cbMaxLen;
			}

		Call( ErrRECAddFieldDef( pfdb, &fieldex ) );

		if ( ( pcolumndef->grbit & JET_bitColumnTTKey ) && idb.iidxsegMac < JET_ccolKeyMost )
			{
			idb.rgidxseg[idb.iidxsegMac++] = ( pcolumndef->grbit & JET_bitColumnTTDescending ) ?
				-(IDXSEG)*pcolumnid : (IDXSEG)*pcolumnid;
			}
		}
	RECSetLastOffset( pfdb, (WORD) ibRec );

	/*	set up the IDB and index definition if necessary
	/**/
	if ( idb.iidxsegMac > 0 )
		{
		idb.cbVarSegMac = JET_cbKeyMost;

		if ( langid == 0 )
			idb.langid = langidDefault;
		else
			idb.langid = langid;

		idb.fidb = ( fidbAllowAllNulls
			| fidbAllowFirstNull
			| fidbAllowSomeNulls
			| ( wFlags & JET_bitTTUnique ? fidbUnique : 0 )
			| ( ( langid != 0 ) ? fidbLangid : 0 ) );
		idb.szName[0] = 0;

		Call( ErrFILEIGenerateIDB( &( pfucb->u.pscb->fcb ), pfdb, &idb ) );
		}

	/*	reset copy buffer
	/**/
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );

	/*	reset key buffer
	/**/
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	return JET_errSuccess;

HandleError:
	CallS( ErrSORTClose( pfucb ) );
SimpleError:
	*ppfucb = pfucbNil;
	return err;
	}


ERR VTAPI ErrIsamSortOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, ULONG langid, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid )
	{
	ERR			err;
	FUCB 		*pfucb;

#ifdef	DISPATCHING
	JET_TABLEID	tableid;

	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefTTSortIns ) );

	Call( ErrSORTTableOpen( ppib, rgcolumndef, ccolumndef, (LANGID)langid, grbit, &pfucb, rgcolumnid ) );
	Assert( pfucb->u.pscb->fcb.wRefCnt == 1 );

	/*	sort is done on the temp database which is always updatable
	/**/
	FUCBSetUpdatable( pfucb );

	/*	inform dispatcher of correct JET_VTID
	/**/
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	pfucb->tableid = tableid;
	*(JET_TABLEID *) ppfucb = tableid;
	FUCBSetVdbid( pfucb );

	return JET_errSuccess;

HandleError:
	ReleaseTableid( tableid );
	return err;
#else
	CallR( ErrSORTTableOpen( ppib, rgcolumndef, ccolumndef, (LANGID)langid, grbit, &pfucb, rgcolumnid ) );
	Assert( pfucb->u.pscb->fcb.wRefCnt == 1 );

	/*	sort is done on the temp database which is always updatable
	/**/
	FUCBSetUpdatable( pfucb );

	*ppfucb = pfucb;

	return JET_errSuccess;
#endif
	}



ERR VTAPI ErrIsamSortEndInsert( PIB *ppib, FUCB *pfucb, JET_GRBIT *pgrbit )
	{
	ERR	err;
	ERR	wrn;

	*pgrbit = (ULONG)pfucb->u.pscb->grbit;

	/*	must return warning from ErrSORTEndInsert since it is used
	/*	in decision to materialize sort.
	/**/
	Call( ErrSORTEndInsert( pfucb ) );
	wrn = err;
	Call( ErrSORTFirst( pfucb ) );
	return wrn;

HandleError:
	return err;
	}


ERR VTAPI ErrIsamSortSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );
	Assert( pfucb->u.pscb->grbit & JET_bitTTScrollable|JET_bitTTIndexed );

	if ( !FKSPrepared( pfucb ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}

	FUCBSetIndexRange( pfucb, grbit );
	err =  ErrSORTCheckIndexRange( pfucb );

	/*	reset key status
	/**/
	KSReset( pfucb );

	/*	if instant duration index range, then reset index range.
	/**/
	if ( grbit & JET_bitRangeInstantDuration )
		{
		DIRResetIndexRange( pfucb );
		}

	return err;
	}


ERR VTAPI ErrIsamSortMove( PIB *ppib, FUCB *pfucb, long csrid, JET_GRBIT grbit )
	{
	ERR		err;
	BOOL  	fLast = ( csrid == JET_MoveLast );

	Assert( !FSCBInsert( pfucb->u.pscb ) );

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );

	/*	reset copy buffer status
	/**/
	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );

	/*	move forward csrid records
	/**/
	if ( csrid > 0 )
		{
		while ( csrid-- > 0 )
			{
			if ( ( err = ErrSORTNext( pfucb ) ) < 0 )
				{
				if ( fLast )
					err = JET_errSuccess;
				return err;
				}
			}
		}
	else if ( csrid < 0 )
		{
		Assert( ( pfucb->u.pscb->grbit & ( JET_bitTTScrollable | JET_bitTTIndexed ) ) );
		if ( csrid == JET_MoveFirst )
			{
			err = ErrSORTFirst( pfucb );
			return err;
			}
		else
			{
			while ( csrid++ < 0 )
				{
				if ( ( err = ErrSORTPrev( pfucb ) ) < 0 )
					return err;
				}
			}
		}
	else
		{
		/*	return currency status for move 0
		/**/
		SCB	*pscb = pfucb->u.pscb;

		Assert( csrid == 0 );
		if ( ! ( pfucb->u.pscb->ispairMac > 0 &&
			pfucb->ispairCurr < pfucb->u.pscb->ispairMac &&
			pfucb->ispairCurr >= 0 ) )
			{
			return ErrERRCheck( JET_errNoCurrentRecord );
			}
		else
			{
			return JET_errSuccess;
			}
		}

	Assert( err == JET_errSuccess );
	return err;
	}


ERR VTAPI ErrIsamSortSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err;
	KEY		key;
	BOOL 	fGT = ( grbit & ( JET_bitSeekGT | JET_bitSeekGE ) );

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );
	/*	assert reset copy buffer status
	/**/
	Assert( !FFUCBSetPrepared( pfucb ) );
	Assert( ( pfucb->u.pscb->grbit & ( JET_bitTTIndexed ) ) );

	if ( !( FKSPrepared( pfucb ) ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}

	/*	ignore segment counter
	/**/
	key.pb = pfucb->pbKey + 1;
	key.cb = pfucb->cbKey - 1;

	/*	perform seek for equal to or greater than
	/**/
	err = ErrSORTSeek( pfucb, &key, fGT );
	if ( err >= 0 )
		{
		KSReset( pfucb );
		}

	Assert( err == JET_errSuccess ||
		err == JET_errRecordNotFound ||
		err == JET_wrnSeekNotEqual );

#define bitSeekAll (JET_bitSeekEQ | JET_bitSeekGE | JET_bitSeekGT |	\
	JET_bitSeekLE | JET_bitSeekLT)

	/*	take additional action if necessary or polymorph error return
	/*	based on grbit
	/**/
	switch ( grbit & bitSeekAll )
		{
	case JET_bitSeekEQ:
		if ( err == JET_wrnSeekNotEqual )
			err = ErrERRCheck( JET_errRecordNotFound );
	case JET_bitSeekGE:
	case JET_bitSeekLE:
		break;
	case JET_bitSeekLT:
		if ( err == JET_wrnSeekNotEqual )
			err = JET_errSuccess;
		else if ( err == JET_errSuccess )
			{
			err = ErrIsamSortMove( ppib, pfucb, JET_MovePrevious, 0 );
			if ( err == JET_errNoCurrentRecord )
				err = ErrERRCheck( JET_errRecordNotFound );
			}
		break;
	default:
		Assert( grbit == JET_bitSeekGT );
		if ( err == JET_wrnSeekNotEqual )
			err = JET_errSuccess;
		else if ( err == JET_errSuccess )
			{
			err = ErrIsamSortMove( ppib, pfucb, JET_MoveNext, 0 );
			if ( err == JET_errNoCurrentRecord )
				err = ErrERRCheck( JET_errRecordNotFound );
			}
		break;
		}

	return err;
	}


ERR VTAPI ErrIsamSortGetBookmark(
	PIB					*ppib,
	FUCB				*pfucb,
	void				*pv,
	unsigned long		cbMax,
	unsigned long		*pcbActual )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;
	long	ipb;

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );
	Assert( pv != NULL );
	Assert( pscb->crun == 0 );

	if ( cbMax < sizeof( ipb ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}

	/*	bookmark on sort is index to pointer to byte
	/**/
	ipb = pfucb->ispairCurr;
	if ( ipb < 0 || ipb >= pfucb->u.pscb->ispairMac )
		return ErrERRCheck( JET_errNoCurrentRecord );
	
	if ( cbMax >= sizeof( ipb ) )
		{
		*(long *)pv = ipb;
		}

	if ( pcbActual )
		{
		*pcbActual = sizeof(ipb);
		}

	Assert( err == JET_errSuccess );
	return err;
	}


ERR VTAPI ErrIsamSortGotoBookmark(
	PIB				*ppib,
	FUCB 			*pfucb,
	void 			*pv,
	unsigned long	cbBookmark )
	{
	ERR		err = JET_errSuccess;

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );
	Assert( pfucb->u.pscb->crun == 0 );
	/*	assert reset copy buffer status
	/**/
	Assert( !FFUCBSetPrepared( pfucb ) );

	if ( cbBookmark != sizeof( long ) )
		{
		return ErrERRCheck( JET_errInvalidBookmark );
		}

	Assert( *( long *)pv < pfucb->u.pscb->ispairMac );
	Assert( *( long *)pv >= 0 );
	
	pfucb->ispairCurr = *(LONG *)pv;
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;

	Assert( err == JET_errSuccess );
	return err;
	}


#ifdef DEBUG

ERR VTAPI ErrIsamSortMakeKey(	
	PIB	 	*ppib,
	FUCB		*pfucb,
	BYTE		*pbKeySeg,
	ULONG		cbKeySeg,
	ULONG		grbit )
	{
	return ErrIsamMakeKey( ppib, pfucb, pbKeySeg, cbKeySeg, grbit );
	}


ERR VTAPI ErrIsamSortRetrieveColumn(	
	PIB				*ppib,
	FUCB			*pfucb,
	JET_COLUMNID	columnid,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual,
	ULONG			grbit,
	JET_RETINFO		*pretinfo )
	{
	return ErrIsamRetrieveColumn( ppib, pfucb, columnid, pb, cbMax,
		pcbActual, grbit, pretinfo );
	}


ERR VTAPI ErrIsamSortRetrieveKey(
	PIB					*ppib,
	FUCB   				*pfucb,
	void   				*pv,
	unsigned long		cbMax,
	unsigned long		*pcbActual,
	JET_GRBIT			grbit )
	{
	return ErrIsamRetrieveKey( ppib, pfucb, (BYTE *)pv, cbMax, pcbActual, 0L );
	}


ERR VTAPI ErrIsamSortSetColumn(	
	PIB				*ppib,
	FUCB			*pfucb,
	JET_COLUMNID	columnid,
	BYTE			*pbData,
	ULONG			cbData,
	ULONG			grbit,
	JET_SETINFO		*psetinfo )
	{
	return ErrIsamSetColumn( ppib, pfucb, columnid, pbData, cbData, grbit, psetinfo );
	}

#endif	// DEBUG


/*	update only supports insert
/**/
ERR VTAPI ErrIsamSortUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	BYTE  	rgbKeyBuf[ JET_cbKeyMost ];
	FDB		*pfdb;					
	LINE  	*plineData;
	LINE  	rgline[2];

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucb );

	Assert( FFUCBSort( pfucb ) );
	if ( !( FFUCBInsertPrepared( pfucb ) ) )
		{
		return ErrERRCheck( JET_errUpdateNotPrepared );
		}
	Assert( pfucb->u.pscb != pscbNil );
	pfdb = (FDB *)((FCB *)pfucb->u.pscb)->pfdb;
	Assert( pfdb != pfdbNil );
	/*	cannot get bookmark before sorting.
	/**/

	/*	record to use for put
	/**/
	plineData = &pfucb->lineWorkBuf;
	if ( FLineNull( plineData ) )
		{
		return ErrERRCheck( JET_errRecordNoCopy );
		}
	else if ( FRECIIllegalNulls( pfdb, plineData ) )
		{
		return ErrERRCheck( JET_errNullInvalid );
		}

	rgline[0].pb = rgbKeyBuf;
	Assert(((FCB *)pfucb->u.pscb)->pidb != pidbNil);
	//	UNDONE:	sort to support tagged columns
	CallR( ErrRECRetrieveKeyFromCopyBuffer( pfucb, pfdb, ((FCB *)pfucb->u.pscb)->pidb,
		(KEY*)&rgline[0], 1, fFalse ) );
	Assert( err != wrnFLDOutOfKeys );
	Assert( err == JET_errSuccess ||
		err == wrnFLDNullSeg ||
		err == wrnFLDNullFirstSeg ||
		err == wrnFLDNullKey );

	/*	return err if sort requires no NULL segment and segment NULL
	/**/
	if ( ( ((FCB *)pfucb->u.pscb)->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullSeg || err == wrnFLDNullFirstSeg || err == wrnFLDNullKey ) )
		{
		return ErrERRCheck( JET_errNullKeyDisallowed );
		}

	/*	add if sort allows
	/**/
	rgline[1] = *plineData;
	if ( err == JET_errSuccess ||
		err == wrnFLDNullKey && ( ( (FCB *)pfucb->u.pscb )->pidb->fidb & fidbAllowAllNulls ) ||
		err == wrnFLDNullFirstSeg && ( ( (FCB *)pfucb->u.pscb )->pidb->fidb & fidbAllowFirstNull ) ||
		err == wrnFLDNullSeg &&	( ( (FCB *)pfucb->u.pscb )->pidb->fidb & fidbAllowSomeNulls ) )
		{
		CallR( ErrSORTInsert( pfucb, rgline ) );
		}

	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );

	return err;
	}


ERR VTAPI ErrIsamSortDupCursor(
	PIB				*ppib,
	FUCB   			*pfucb,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit )
	{
	ERR				err;
	FUCB   			**ppfucbDup	= (FUCB **)ptableid;
	FUCB   			*pfucbDup = pfucbNil;
#ifdef	DISPATCHING
	JET_TABLEID		tableid;
#endif	/* DISPATCHING */

	if ( FFUCBIndex( pfucb ) )
		{
		err = ErrIsamDupCursor( ppib, pfucb, ppfucbDup, grbit );
		return err;
		}

#ifdef	DISPATCHING
	CallR( ErrAllocateTableid(&tableid, (JET_VTID) 0, &vtfndefTTSortIns) );
#endif	/* DISPATCHING */

	Call( ErrFUCBOpen( ppib, dbidTemp, &pfucbDup ) );
  	FCBLink( pfucbDup, &(pfucb->u.pscb->fcb) );

	pfucbDup->ulFlags = pfucb->ulFlags;

	pfucbDup->pbKey = NULL;
	KSReset( pfucbDup );

	/*	initialize working buffer to unallocated
	/**/
	pfucbDup->pbfWorkBuf = pbfNil;
	pfucbDup->lineWorkBuf.pb = NULL;
	FUCBResetDeferredChecksum( pfucbDup );
	FUCBResetUpdateSeparateLV( pfucbDup );
	FUCBResetCbstat( pfucbDup );
	Assert( pfucb->pLVBuf == NULL );

	/*	move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamSortMove( ppib, pfucbDup, (ULONG)JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucbDup ) );
	pfucbDup->fVtid = fTrue;
	pfucbDup->tableid = tableid;
	*(JET_TABLEID *) ppfucbDup = tableid;
#else	/* !DISPATCHING */
	*ppfucbDup = pfucbDup;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( pfucbDup != pfucbNil )
		{
		FUCBClose( pfucbDup );
		}
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */
	return err;
	}


ERR VTAPI ErrIsamSortClose( PIB *ppib, FUCB *pfucb )
	{
	ERR	  			err;
#ifdef DISPATCHING
	JET_TABLEID		tableid = pfucb->tableid;
#ifdef DEBUG
	VTFNDEF			*pvtfndef;
#endif
#endif	// DISPATCHING	

	CallR( ErrPIBCheck( ppib ) );
	Assert( pfucb->fVtid );
	Assert( pfucb->tableid != JET_tableidNil );

	/*	reset fVtid for ErrFILECloseTable
	/**/
#ifdef DISPATCHING
	Assert( FValidateTableidFromVtid( (JET_VTID)pfucb, tableid, &pvtfndef ) );
	Assert( pvtfndef == &vtfndefTTBase ||
		pvtfndef == &vtfndefTTSortRet ||
		pvtfndef == &vtfndefTTSortIns );
	ReleaseTableid( tableid );
#endif	// DISPATCHING
	pfucb->tableid = JET_tableidNil;
	pfucb->fVtid = fFalse;

	if ( FFUCBIndex( pfucb ) )
		{
		CheckTable( ppib, pfucb );
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	else
		{
		CheckSort( ppib, pfucb );
		Assert( FFUCBSort( pfucb ) );
		
		/*	release key buffer
		/**/
		if ( pfucb->pbKey != NULL )
			{
			LFree( pfucb->pbKey );
			pfucb->pbKey = NULL;
			}

		/*	release working buffer
		/**/
		if ( pfucb->pbfWorkBuf != pbfNil )
			{
			BFSFree( pfucb->pbfWorkBuf );
			pfucb->pbfWorkBuf = pbfNil;
			pfucb->lineWorkBuf.pb = NULL;
			}

		CallS( ErrSORTClose( pfucb ) );
		}

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamSortGetTableInfo(
	PIB 			*ppib,
	FUCB			*pfucb,
	void			*pv,
	unsigned long	cbOutMax,
	unsigned long	lInfoLevel )
	{
	if ( lInfoLevel != JET_TblInfo )
		{
		return ErrERRCheck( JET_errInvalidOperation );
		}

	/*	check buffer size
	/**/
	if ( cbOutMax < sizeof(JET_OBJECTINFO) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	memset( (BYTE *)pv, 0x00, (SHORT)cbOutMax );
	( (JET_OBJECTINFO *)pv )->cbStruct = sizeof(JET_OBJECTINFO);
	( (JET_OBJECTINFO *)pv )->objtyp   = JET_objtypTable;
	( (JET_OBJECTINFO *)pv )->cRecord  = pfucb->u.pscb->cRecords;

	return JET_errSuccess;
	}


// Advances the copy progress meter.
INLINE LOCAL ERR ErrSORTCopyProgress(
	STATUSINFO	*pstatus,
	ULONG		cPagesTraversed )
	{
	JET_SNPROG	snprog;

	Assert( pstatus->pfnStatus );
	Assert( pstatus->snt == JET_sntProgress );

	pstatus->cunitDone += ( cPagesTraversed * pstatus->cunitPerProgression );
	Assert( pstatus->cunitDone <= pstatus->cunitTotal );

	snprog.cbStruct = sizeof( JET_SNPROG );
	snprog.cunitDone = pstatus->cunitDone;
	snprog.cunitTotal = pstatus->cunitTotal;

	return ( ERR )( *pstatus->pfnStatus )(
		pstatus->sesid,
		pstatus->snp,
		pstatus->snt,
		&snprog );
	}


INLINE LOCAL ERR ErrSORTCopyOneSeparatedLV(
	FUCB		*pfucbSrc,
	FUCB		*pfucbDest,
	LID			lidSrc,
	LID			*plidDest,
	BYTE		*pbLVBuf,
	STATUSINFO	*pstatus )
	{
	ERR			err;
	JET_SESID	sesid = (JET_SESID)pfucbSrc->ppib;
	BOOL		fNewInstance;
	ULONG		cbActual;

	Assert( pbLVBuf );

	/*	set up temporary table LID map for single-instance long value support
	/**/
	if ( tableidGlobalLIDMap == JET_tableidNil )
		{
		Call( ErrSORTInitLIDMap( pfucbSrc->ppib ) );
		}

	/*	check for lidSrc in LVMapTable
	/**/
	Call( ErrDispMakeKey(
		sesid,
		tableidGlobalLIDMap,
		&lidSrc,
		sizeof(LID),
		JET_bitNewKey ) );

	err = ErrDispSeek( sesid, tableidGlobalLIDMap, JET_bitSeekEQ );
	if ( err < 0 && err != JET_errRecordNotFound )
		{
		Call( err );
		}

	if ( fNewInstance = ( err == JET_errRecordNotFound ) )
		{
		LINE	lineField;
		ULONG	ibLongValue = 0;
#ifdef DEBUG
		LID		lidSave;
#endif

		lineField.pb = pbLVBuf;
		lineField.cb = 0;

		Call( ErrRECSeparateLV( pfucbDest, &lineField, plidDest, NULL ) );

#ifdef DEBUG
		lidSave = *plidDest;
#endif

		do
			{
			Call( ErrRECRetrieveSLongField(
				pfucbSrc,
				lidSrc,
				ibLongValue,
				pbLVBuf,
				cbLvMax,
				&cbActual ) );
			Assert( err == JET_errSuccess  ||  err == JET_wrnBufferTruncated );

			Assert( lineField.pb == pbLVBuf );
			lineField.cb = min( cbLvMax, cbActual );

			Call( ErrRECAOSeparateLV(
				pfucbDest, plidDest, &lineField, JET_bitSetAppendLV, 0, 0 ) );
			Assert( *plidDest == lidSave );		// Ensure the lid doesn't change on us.
			Assert( err != JET_wrnCopyLongValue );

			ibLongValue += cbLvMax;		// Prepare for next chunk.
			}
		while ( cbActual > cbLvMax );

		/* insert src LID and dest LID into the global LID map table
		/**/
		Call( ErrDispPrepareUpdate( sesid, tableidGlobalLIDMap, JET_prepInsert ) );

		Call( ErrDispSetColumn( sesid,
			tableidGlobalLIDMap,
			rgcolumndefGlobalLIDMap[icolumnLidSrc].columnid,
			&lidSrc,
			sizeof(LID),
			0,
			NULL ) );

		Call( ErrDispSetColumn( sesid,
			tableidGlobalLIDMap,
			rgcolumndefGlobalLIDMap[icolumnLidDest].columnid,
			(VOID *)plidDest,
			sizeof(LID),
			0,
			NULL ) );

		Call( ErrDispUpdate( sesid, tableidGlobalLIDMap, NULL, 0, NULL ) );

		if ( pstatus != NULL )
			{
			ULONG	cbTotalRetrieved;
			ULONG	cLVPagesTraversed;

			// ibLongValue should be sitting at the next retrieval point.
			// To determine the total bytes copied, go to the previous retrieval
			// point and add the cbActual from the last retrieval.
			// Dividing cbTotalRetrieved by cbChunkMost will give us the
			// MINIMUM number of pages occupied by this long value.
			Assert( ibLongValue >= cbLvMax );
			cbTotalRetrieved = ( ibLongValue - cbLvMax ) + cbActual;
			cLVPagesTraversed = cbTotalRetrieved / cbChunkMost;

			pstatus->cbRawDataLV += cbTotalRetrieved;
			pstatus->cLVPagesTraversed += cLVPagesTraversed;
			Call( ErrSORTCopyProgress( pstatus, cLVPagesTraversed ) );
			}
		}

	else
		{
		/*	This long value has been seen before, do not insert value.
		/*	Instead retrieve LIDDest from LVMapTable and adjust only
		/*	reference count in destination table
		/**/
		Assert( err == JET_errSuccess );

		Call( ErrDispRetrieveColumn( sesid,
			tableidGlobalLIDMap,
			rgcolumndefGlobalLIDMap[icolumnLidDest].columnid,
			(VOID *)plidDest,
			sizeof(LID),
			&cbActual,
			0,
			NULL ) );
		Assert( cbActual == sizeof(LID) );

		Call( ErrRECAffectSeparateLV( pfucbDest, plidDest, fLVReference ) );
		}

HandleError:
	return err;
	}



// This function assumes that the source record has already been completely copied
// over to the destination record.  The only thing left to do is rescan the tagged
// portion of the record looking for separated long values.  If we find any,
// copy them over and update the record's LID accordingly.
INLINE LOCAL ERR ErrSORTCopySeparatedLVs(
	FUCB				*pfucbSrc,
	FUCB				*pfucbDest,
	BYTE				*pbRecTagged,
	BYTE				*pbLVBuf,
	STATUSINFO			*pstatus )
	{
	ERR					err = JET_errSuccess;
	FIELD				*pfieldTagged = PfieldFDBTagged( pfucbDest->u.pfcb->pfdb );
	TAGFLD UNALIGNED	*ptagfld;
	BYTE				*pbRecMax = pfucbDest->lineWorkBuf.pb + pfucbDest->lineWorkBuf.cb;

	Assert( pbRecTagged > pfucbDest->lineWorkBuf.pb );
	Assert( pbRecTagged <= pfucbDest->lineWorkBuf.pb + pfucbDest->lineWorkBuf.cb );

	ptagfld = (TAGFLD *)pbRecTagged;
	while ( (BYTE *)ptagfld < pbRecMax )
		{
		Assert( FTaggedFid( ptagfld->fid ) );
		Assert( ptagfld->fid <= pfucbDest->u.pfcb->pfdb->fidTaggedLast );

		if ( FRECLongValue( pfieldTagged[ptagfld->fid-fidTaggedLeast].coltyp )  &&
			!ptagfld->fNull  &&
			FFieldIsSLong( ptagfld->rgb ) )
			{
			LID	lid;

			Assert( ptagfld->cb == sizeof(LV) );
			Call( ErrSORTCopyOneSeparatedLV(
				pfucbSrc,
				pfucbDest,
				LidOfLV( ptagfld->rgb ),		// source lid
				&lid,							// destination lid
				pbLVBuf,
				pstatus ) );
			LidOfLV( ptagfld->rgb ) = lid;
			}

		else if ( pstatus != NULL )
			{
			pstatus->cbRawData += ptagfld->cb;
			}

		ptagfld = PtagfldNext( ptagfld );
		}

	Assert( (BYTE *)ptagfld == pbRecMax );

HandleError:
	return err;
	}


INLINE LOCAL ERR ErrSORTCopyTaggedColumns(
	FUCB				*pfucbSrc,
	FUCB				*pfucbDest,	
	BYTE				*pbRecSrcTagged,
	BYTE				*pbRecDestTagged,
	BYTE				*pbRecBuf,
	BYTE				*pbLVBuf,
	JET_COLUMNID		*mpcolumnidcolumnidTagged,
	STATUSINFO			*pstatus )
	{
	ERR					err = JET_errSuccess;
	FIELD				*pfieldTagged = PfieldFDBTagged( pfucbSrc->u.pfcb->pfdb );
	ULONG				cbRecSrc;
	ULONG				cbRecSrcTagged;
	BYTE				*pbRecMax;
	TAGFLD UNALIGNED	*ptagfld;
	FID					fid;
	ULONG				cb;

	// Verify pbRecSrcTagged is currently pointing to the start of the tagged columns
	// in the source record and pbRecDestTagged is pointing to the start of the tagged
	// columns in the destination record.
	cbRecSrc = pfucbSrc->lineData.cb;
	Assert( pbRecSrcTagged > pfucbSrc->lineData.pb );
	Assert( pbRecSrcTagged <= pfucbSrc->lineData.pb + cbRecSrc );
	Assert( pbRecDestTagged > pfucbDest->lineWorkBuf.pb );

	// Copy the tagged columns into the record buffer, because we may lose critJet
	// while copying separated long values, thus invalidating  the lineData.pb pointer.
	cbRecSrcTagged = (ULONG)(( pfucbSrc->lineData.pb + cbRecSrc ) - pbRecSrcTagged);
	Assert( pbRecBuf != NULL );
	memcpy( pbRecBuf, pbRecSrcTagged, cbRecSrcTagged );
	pbRecMax = pbRecBuf + cbRecSrcTagged;

	ptagfld = (TAGFLD *)pbRecBuf;
	while ( (BYTE *)ptagfld < pbRecMax )
		{
		fid = ptagfld->fid;
		Assert( FTaggedFid( fid ) );
		Assert( fid <= pfucbSrc->u.pfcb->pfdb->fidTaggedLast );
		Assert( pfieldTagged[fid-fidTaggedLeast].coltyp == JET_coltypNil  ||
			FTaggedFid( mpcolumnidcolumnidTagged[fid-fidTaggedLeast] ) );
		if ( pfieldTagged[fid-fidTaggedLeast].coltyp != JET_coltypNil )
			{
			Assert( mpcolumnidcolumnidTagged[fid-fidTaggedLeast] >= fidTaggedLeast );
			Assert( mpcolumnidcolumnidTagged[fid-fidTaggedLeast] <= pfucbDest->u.pfcb->pfdb->fidTaggedLast );
			Assert( mpcolumnidcolumnidTagged[fid-fidTaggedLeast] <= fid );

			// Copy tagfld, and modify FID appropriately.
			cb = sizeof(TAGFLD) + ptagfld->cb;
			memcpy( pbRecDestTagged, (BYTE *)ptagfld, cb );
			( (TAGFLD UNALIGNED *)pbRecDestTagged )->fid =
				(FID)mpcolumnidcolumnidTagged[fid-fidTaggedLeast];

			// If it's a separated long value, copy it and update LID.
			if ( FRECLongValue( pfieldTagged[fid-fidTaggedLeast].coltyp )  &&
				!ptagfld->fNull  &&
				FFieldIsSLong( ptagfld->rgb ) )
				{
				LID	lid;

				Assert( cb - sizeof(TAGFLD) == sizeof(LV) );
				Assert( ( (TAGFLD UNALIGNED *)pbRecDestTagged )->cb == sizeof(LV) );
				Call( ErrSORTCopyOneSeparatedLV(
					pfucbSrc,
					pfucbDest,
					LidOfLV( ptagfld->rgb ),		// source lid
					&lid,							// destination lid
					pbLVBuf,
					pstatus ) );
				LidOfLV( ( (TAGFLD UNALIGNED *)pbRecDestTagged )->rgb ) = lid;
				}
			else if ( pstatus != NULL )
				{
				pstatus->cbRawData += ptagfld->cb;
				}
		
			pbRecDestTagged += cb;
			}

		ptagfld = PtagfldNext( ptagfld );
		}
	Assert( (BYTE *)ptagfld == pbRecMax );

	Assert( pbRecDestTagged > pfucbDest->lineWorkBuf.pb );
	pfucbDest->lineWorkBuf.cb = (ULONG)(pbRecDestTagged - pfucbDest->lineWorkBuf.pb);

	Assert( pfucbDest->lineWorkBuf.cb >= cbRECRecordMin );
	Assert( pfucbDest->lineWorkBuf.cb <= cbRecSrc );

HandleError:
	return err;
	}




// Returns a count of the bytes copied.
INLINE LOCAL ULONG CbSORTCopyFixedVarColumns(
	FDB				*pfdbSrc,
	FDB				*pfdbDest,
   	CPCOL			*rgcpcol,			// Only used for DEBUG
	ULONG			ccpcolMax,			// Only used for DEBUG
	BYTE			*pbRecSrc,
	BYTE			*pbRecDest )
	{
	WORD			*pibFixOffsSrc;
	WORD			*pibFixOffsDest;
	WORD UNALIGNED	*pibVarOffsSrc;
	WORD UNALIGNED	*pibVarOffsDest;
	FIELD			*pfieldFixedSrc;
	FIELD			*pfieldFixedDest;
	FIELD			*pfieldVarSrc;
	FIELD			*pfieldVarDest;
	BYTE			*prgbitNullSrc;
	BYTE			*prgbitNullDest;
	FID				fidFixedLastSrc;
	FID				fidVarLastSrc;
	FID				fidFixedLastDest;
	FID				fidVarLastDest;
	INT				ifid;
	BYTE			*pbChunkSrc;
	BYTE			*pbChunkDest;
	ULONG			cbChunk;
#ifdef DEBUG
	FID				fidVarLastSave;
#endif


	fidFixedLastSrc = ( (RECHDR *)pbRecSrc )->fidFixedLastInRec;
	fidVarLastSrc = ( (RECHDR *)pbRecSrc )->fidVarLastInRec;

	pibFixOffsSrc = PibFDBFixedOffsets( pfdbSrc );
	pibVarOffsSrc = (WORD *)( pbRecSrc +
		pibFixOffsSrc[fidFixedLastSrc] + (fidFixedLastSrc + 7) / 8 );

	pfieldFixedSrc = PfieldFDBFixedFromOffsets( pfdbSrc, pibFixOffsSrc );
	pfieldVarSrc = PfieldFDBVarFromFixed( pfdbSrc, pfieldFixedSrc );

	Assert( (BYTE *)pibVarOffsSrc > pbRecSrc );
	Assert( (BYTE *)pibVarOffsSrc < pbRecSrc + cbRECRecordMost );

	pibFixOffsDest = PibFDBFixedOffsets( pfdbDest );
	pfieldFixedDest = PfieldFDBFixedFromOffsets( pfdbDest, pibFixOffsDest );
	pfieldVarDest = PfieldFDBVarFromFixed( pfdbDest, pfieldFixedDest );

	prgbitNullSrc = pbRecSrc + pibFixOffsSrc[fidFixedLastSrc];

	// Need some space for the null-bit array.  Use the space after the
	// theoretical maximum space for fixed columns (ie. if all fixed columns
	// were set).  Assert that the null-bit array will fit in the pathological case.
	Assert( pibFixOffsSrc[pfdbSrc->fidFixedLast] < cbRECRecordMost );
	Assert( pibFixOffsDest[pfdbDest->fidFixedLast] <= pibFixOffsSrc[pfdbSrc->fidFixedLast] );
	Assert( pibFixOffsDest[pfdbDest->fidFixedLast] + ( ( fidFixedMost + 7 ) / 8 )
		<= cbRECRecordMost );
	prgbitNullDest = pbRecDest + pibFixOffsDest[pfdbDest->fidFixedLast];
	memset( prgbitNullDest, 0, ( fidFixedMost + 7 ) / 8 );

	pbChunkSrc = pbRecSrc + sizeof(RECHDR);
	pbChunkDest = pbRecDest + sizeof(RECHDR);
	cbChunk = 0;

	fidFixedLastDest = fidFixedLeast-1;
	for ( ifid = 0; ifid < ( fidFixedLastSrc + 1 - fidFixedLeast ); ifid++ )
		{
		// Copy only undeleted columns
		if ( pfieldFixedSrc[ifid].coltyp == JET_coltypNil )
			{
			if ( cbChunk > 0 )
				{
				memcpy( pbChunkDest, pbChunkSrc, cbChunk );
				pbChunkDest += cbChunk;
				}

			pbChunkSrc = pbRecSrc + pibFixOffsSrc[ifid+1];
			cbChunk = 0;
			}
		else
			{
#ifdef DEBUG		// Assert that the fids match what the columnid map says
			BOOL	fFound = fFalse;
			ULONG	i;

			for ( i = 0; i < ccpcolMax; i++ )
				{
				if ( rgcpcol[i].columnidSrc == (JET_COLUMNID)( ifid+fidFixedLeast ) )
					{
					Assert( rgcpcol[i].columnidDest == (JET_COLUMNID)( fidFixedLastDest+1 ) );
					fFound = fTrue;
					break;
					}
				}
			Assert( fFound );
#endif

			// If the source field is null, assert that the destination column
			// has also been flagged as such.
			Assert( !FFixedNullBit( prgbitNullSrc + ( ifid/8 ), ifid )  ||
				FFixedNullBit( prgbitNullDest + ( fidFixedLastDest / 8 ), fidFixedLastDest ) );
			if ( !FFixedNullBit( prgbitNullSrc + ( ifid/8 ), ifid ) )
				{
				ResetFixedNullBit(
					prgbitNullDest + ( fidFixedLastDest / 8 ),
					fidFixedLastDest );
 				}

			Assert( pibFixOffsSrc[ifid+1] > pibFixOffsSrc[ifid] );
			Assert( pibFixOffsDest[fidFixedLastDest] >= sizeof(RECHDR) );
			Assert( pibFixOffsDest[fidFixedLastDest] < cbRECRecordMost );
			Assert( pibFixOffsDest[fidFixedLastDest] < pibFixOffsDest[pfdbDest->fidFixedLast] );

			Assert( pfieldFixedSrc[ifid].cbMaxLen == (ULONG)( pibFixOffsSrc[ifid+1] - pibFixOffsSrc[ifid] ) );
			cbChunk += pibFixOffsSrc[ifid+1] - pibFixOffsSrc[ifid];

			// Don't increment till the very end, because the code above requires
			// the fid as an index.
			fidFixedLastDest++;
			}
		}

	Assert( fidFixedLastDest <= pfdbDest->fidFixedLast );

	// Should end up at the start of the null-bit array.
	Assert( cbChunk > 0  ||
		 pbChunkDest == pbRecDest + pibFixOffsDest[fidFixedLastDest+1-fidFixedLeast] );
	if ( cbChunk > 0 )
		{
		memcpy( pbChunkDest, pbChunkSrc, cbChunk );
		Assert( pbChunkDest + cbChunk ==
			pbRecDest + pibFixOffsDest[fidFixedLastDest+1-fidFixedLeast] );
		}

	// Shift the null-bit array into place.
	memmove(
		pbRecDest + pibFixOffsDest[fidFixedLastDest+1-fidFixedLeast],
		prgbitNullDest,
		( fidFixedLastDest + 7 ) / 8 );



	// The variable columns must be done in two passes.  The first pass
	// just determines the highest variable columnid in the record.
	// The second pass does the work.

	pibVarOffsDest = (WORD *)( pbRecDest +
		pibFixOffsDest[fidFixedLastDest] + ( ( fidFixedLastDest + 7 ) / 8 ) );

	fidVarLastDest = fidVarLeast-1;
	for ( ifid = 0; ifid < ( fidVarLastSrc + 1 - fidVarLeast ) ; ifid++ )
		{
		// Only care about undeleted columns
		if ( pfieldVarSrc[ifid].coltyp != JET_coltypNil )
			{
#ifdef DEBUG		// Assert that the fids match what the columnid map says
			BOOL	fFound = fFalse;
			ULONG	i;

			for ( i = 0; i < ccpcolMax; i++ )
				{
				if ( rgcpcol[i].columnidSrc == (JET_COLUMNID)( ifid+fidVarLeast ) )
					{
					Assert( rgcpcol[i].columnidDest == (JET_COLUMNID)( fidVarLastDest+1 ) );
					fFound = fTrue;
					break;
					}
				}
			Assert( fFound );
#endif

			fidVarLastDest++;
			}
		}
	Assert( fidVarLastDest <= pfdbDest->fidVarLast );


	// Set first entry to point to just past the offsets array, and make it non-null.
	pibVarOffsDest[0] = (WORD)((BYTE *)( pibVarOffsDest +
		( fidVarLastDest + 1 - fidVarLeast + 1 ) ) - pbRecDest);
	Assert( !FVarNullBit( pibVarOffsDest[0] ) );

	// The second iteration through the variable columns, we copy the column data
	// and update the offsets and nullity.
	pbChunkSrc = (BYTE *)( pibVarOffsSrc + ( fidVarLastSrc + 1 - fidVarLeast + 1 ) );
	Assert( pbChunkSrc == pbRecSrc + ibVarOffset( pibVarOffsSrc[0] ) );
	pbChunkDest = (BYTE *)( pibVarOffsDest + ( fidVarLastDest + 1 - fidVarLeast + 1 ) );
	Assert( pbChunkDest == pbRecDest + ibVarOffset( pibVarOffsDest[0] ) );
	cbChunk = 0;

#ifdef DEBUG
	fidVarLastSave = fidVarLastDest;
#endif

	fidVarLastDest = fidVarLeast-1;
	for ( ifid = 0; ifid < ( fidVarLastSrc + 1 - fidVarLeast ) ; ifid++ )
		{
		// Copy only undeleted columns
		if ( pfieldVarSrc[ifid].coltyp == JET_coltypNil )
			{
			if ( cbChunk > 0 )
				{
				memcpy( pbChunkDest, pbChunkSrc, cbChunk );
				pbChunkDest += cbChunk;
				}

			pbChunkSrc = pbRecSrc + ibVarOffset( pibVarOffsSrc[ifid+1] );
			cbChunk = 0;
			}
		else
			{
			fidVarLastDest++;

			if ( FVarNullBit( pibVarOffsSrc[ifid] ) )
				{
				SetVarNullBit( pibVarOffsDest[fidVarLastDest-fidVarLeast] );
				pibVarOffsDest[fidVarLastDest+1-fidVarLeast] =
					ibVarOffset( pibVarOffsDest[fidVarLastDest-fidVarLeast] );
				}
			else
				{
				// The null-bit defaults to column present (it's implicitly set by the
				// previous iteration of the loop).
				Assert( !FVarNullBit( pibVarOffsDest[fidVarLastDest-fidVarLeast] ) );
				Assert( ibVarOffset( pibVarOffsSrc[ifid+1] ) >=
					ibVarOffset( pibVarOffsSrc[ifid] ) );
				pibVarOffsDest[fidVarLastDest+1-fidVarLeast] =
					ibVarOffset( pibVarOffsDest[fidVarLastDest-fidVarLeast] ) +
					( ibVarOffset( pibVarOffsSrc[ifid+1] ) -
						ibVarOffset( pibVarOffsSrc[ifid] ) );
				}

			// The null-bit for the next column is implicitly cleared.
			Assert( !FVarNullBit( pibVarOffsDest[fidVarLastDest+1-fidVarLeast] ) );


			cbChunk += ibVarOffset( pibVarOffsSrc[ifid+1] ) - ibVarOffset( pibVarOffsSrc[ifid] );
			}
		}

	Assert( fidVarLastDest == fidVarLastSave );

	// Should end up at the start of the tagflds.
	Assert( cbChunk > 0  ||
		 pbChunkDest == pbRecDest + ibVarOffset( pibVarOffsDest[fidVarLastDest+1-fidVarLeast] ) );
	if ( cbChunk > 0 )
		{
		memcpy( pbChunkDest, pbChunkSrc, cbChunk );
		Assert( pbChunkDest + cbChunk ==
			pbRecDest + ibVarOffset( pibVarOffsDest[fidVarLastDest+1-fidVarLeast] ) );
		}


	( (RECHDR *)pbRecDest )->fidFixedLastInRec = (BYTE)fidFixedLastDest;
	( (RECHDR *)pbRecDest )->fidVarLastInRec = (BYTE)fidVarLastDest;

	Assert( ibVarOffset( pibVarOffsDest[fidVarLastDest+1-fidVarLeast] ) <=
		ibVarOffset( pibVarOffsSrc[fidVarLastSrc+1-fidVarLeast] ) );
	return (ULONG)ibVarOffset( pibVarOffsDest[fidVarLastDest+1-fidVarLeast] );
	}


INLINE LOCAL ERR ErrSORTCopyOneRecord(
	FUCB			*pfucbSrc,
	FUCB			*pfucbDest,
	BYTE			fColumnsDeleted,
	BYTE			*pbRecBuf,
	BYTE			*pbLVBuf,
	CPCOL			*rgcpcol,
	ULONG			ccpcolMax,
	JET_COLUMNID	*mpcolumnidcolumnidTagged,
	STATUSINFO		*pstatus )
	{
	ERR				err;
	BYTE			*pbRecSrc;
	BYTE			*pbRecDest;
	ULONG			cbRecSrc;
	ULONG			cbRecSrcFixedVar;
	ULONG			cbRecDestFixedVar;
	FID				fidFixedLast;
	FID				fidVarLast;
	WORD			*pibFixOffs;		// Alignment is guaranteed. do so don't need UNALIGNED.
	WORD UNALIGNED	*pibVarOffs;		// Alignment is not guaranteed, so need UNALIGNED.

	/*	setup pfucbDest for insert
	/**/
	CallR( ErrDIRBeginTransaction( pfucbDest->ppib ) );
	Call( ErrIsamPrepareUpdate( pfucbDest->ppib, pfucbDest, JET_prepInsert ) );

	/*	access source record
	/**/
	Call( ErrDIRGet( pfucbSrc ) );

	pbRecSrc = pfucbSrc->lineData.pb;
	cbRecSrc = pfucbSrc->lineData.cb;
	pbRecDest = pfucbDest->lineWorkBuf.pb;

	Assert( cbRecSrc >= cbRECRecordMin );
	Assert( cbRecSrc <= cbRECRecordMost );

	fidFixedLast = ( (RECHDR *)pbRecSrc )->fidFixedLastInRec;
	fidVarLast = ( (RECHDR *)pbRecSrc )->fidVarLastInRec;

	Assert( fidFixedLast >= fidFixedLeast-1  &&
		fidFixedLast <= pfucbSrc->u.pfcb->pfdb->fidFixedLast );
	Assert( fidVarLast >= fidVarLeast-1  &&
		fidVarLast <= pfucbSrc->u.pfcb->pfdb->fidVarLast );

	pibFixOffs = PibFDBFixedOffsets( pfucbSrc->u.pfcb->pfdb );
	pibVarOffs = (WORD *)( pbRecSrc + pibFixOffs[fidFixedLast] + (fidFixedLast + 7) / 8 );

	cbRecSrcFixedVar = ibVarOffset( pibVarOffs[fidVarLast+1-fidVarLeast] );
	Assert( cbRecSrcFixedVar >= cbRECRecordMin );
	Assert( cbRecSrcFixedVar <= cbRecSrc );

	Assert( (BYTE *)pibVarOffs > pbRecSrc );
	Assert( (BYTE *)pibVarOffs < pbRecSrc + cbRecSrc );

	if ( FCOLSDELETEDNone( fColumnsDeleted ) )
		{
		// Do the copy as one big chunk.
		memcpy( pbRecDest, pbRecSrc, cbRecSrc );
		pfucbDest->lineWorkBuf.cb = cbRecSrc;
		cbRecDestFixedVar = cbRecSrcFixedVar;
		}

	else	// !( FCOLSDELETEDNone( fColumnsDeleted ) )
		{
		if ( FCOLSDELETEDFixedVar( fColumnsDeleted ) )
			{
			LgHoldCriticalSection( critJet );	// Ensure's pbRecSrc remains valid.
			cbRecDestFixedVar = CbSORTCopyFixedVarColumns(
									(FDB *)pfucbSrc->u.pfcb->pfdb,
									(FDB *)pfucbDest->u.pfcb->pfdb,
									rgcpcol,
									ccpcolMax,
									pbRecSrc,
									pbRecDest );
			LgReleaseCriticalSection( critJet );
			}

		else
			{
			memcpy( pbRecDest, pbRecSrc, cbRecSrcFixedVar );
			cbRecDestFixedVar = cbRecSrcFixedVar;
			}

		Assert( cbRecDestFixedVar >= cbRECRecordMin );
		Assert( cbRecDestFixedVar <= cbRecSrcFixedVar );

		if ( FCOLSDELETEDTagged( fColumnsDeleted ) )
			{
			// pfucbDest->lineWorkBuf.cb will be set within this function.
			Call( ErrSORTCopyTaggedColumns(
				pfucbSrc,
				pfucbDest,
				pbRecSrc+cbRecSrcFixedVar,
				pbRecDest+cbRecDestFixedVar,
				pbRecBuf,
				pbLVBuf,
				mpcolumnidcolumnidTagged,
				pstatus ) );

			Assert( pfucbDest->lineWorkBuf.cb >= cbRecDestFixedVar );
			Assert( pfucbDest->lineWorkBuf.cb <= cbRecSrc );

			// When we copied the tagged columns, we also took care of
			// copying the separated LV's.  We're done now, so go ahead and
			// insert the record.
			goto InsertRecord;

			}

		else
			{
			memcpy( pbRecDest+cbRecDestFixedVar, pbRecSrc+cbRecSrcFixedVar,
				cbRecSrc - cbRecSrcFixedVar );
			pfucbDest->lineWorkBuf.cb = cbRecDestFixedVar + ( cbRecSrc - cbRecSrcFixedVar );

			Assert( pfucbDest->lineWorkBuf.cb >= cbRecDestFixedVar );
			Assert( pfucbDest->lineWorkBuf.cb <= cbRecSrc );
			}

		}	// ( FCOLSDELETEDNone( fColumnsDeleted ) )


	// Now fix up the LID's for separated long values, if any.
	Call( ErrSORTCopySeparatedLVs(
		pfucbSrc,
		pfucbDest,
		pbRecDest + cbRecDestFixedVar,
		pbLVBuf,
		pstatus ) );

InsertRecord:
	if ( pstatus != NULL )
		{
		ULONG	cbOverhead;

		fidFixedLast = ( (RECHDR *)pbRecDest )->fidFixedLastInRec;
		fidVarLast = ( (RECHDR *)pbRecDest )->fidVarLastInRec;

		Assert( fidFixedLast >= fidFixedLeast-1  &&
			fidFixedLast <= pfucbDest->u.pfcb->pfdb->fidFixedLast );
		Assert( fidVarLast >= fidVarLeast-1  &&
			fidVarLast <= pfucbDest->u.pfcb->pfdb->fidVarLast );

		// Don't count record header.
		cbOverhead = cbRECRecordMin +							// Record header + offset to tagged fields
			( ( fidFixedLast + 1 - fidFixedLeast ) + 7 ) / 8  +	// Null array for fixed columns
			( fidVarLast + 1 - fidVarLeast ) * sizeof(WORD);	// Variable offsets array
		Assert( cbRecDestFixedVar >= cbOverhead );

		// Don't count offsets tables or null arrays.
		pstatus->cbRawData += ( cbRecDestFixedVar - cbOverhead );
		}

	Call( ErrIsamUpdate( pfucbDest->ppib, pfucbDest, NULL, 0, NULL ) );
	Call( ErrDIRCommitTransaction( pfucbDest->ppib, 0 ) );

	return err;

HandleError:
	CallS( ErrDIRRollback( pfucbDest->ppib ) );
	return err;
	}

#ifdef DEBUG		// Verify integrity of columnid maps.
LOCAL VOID SORTAssertColumnidMaps(
	FDB				*pfdb,
	CPCOL			*rgcpcol,
	ULONG			ccpcolMax,
	JET_COLUMNID	*mpcolumnidcolumnidTagged,
	BYTE			fColumnsDeleted )
	{
	INT				i;
	FIELD			*pfieldTagged = PfieldFDBTagged( pfdb );

	if ( FCOLSDELETEDFixedVar( fColumnsDeleted ) )
		{
		// Ensure columnids are monotonically increasing.
		for ( i = 0; i < (INT)ccpcolMax; i++ )
			{
			Assert( rgcpcol[i].columnidDest <= rgcpcol[i].columnidSrc );
			if ( FFixedFid( rgcpcol[i].columnidSrc ) )
				{
				Assert( FFixedFid( rgcpcol[i].columnidDest ) );
				if ( i > 0 )
					{
					Assert( rgcpcol[i].columnidDest == rgcpcol[i-1].columnidDest + 1 );
					}
				}
			else
				{
				Assert( FVarFid( rgcpcol[i].columnidSrc ) );
				Assert( FVarFid( rgcpcol[i].columnidDest ) );
				if ( i > 0 )
					{
					if ( FVarFid( rgcpcol[i-1].columnidDest ) )
						{
						Assert( rgcpcol[i].columnidDest == rgcpcol[i-1].columnidDest + 1 );
						}
					else
						{
						Assert( FFixedFid( rgcpcol[i-1].columnidDest ) );
						}
					}
				}
			}
		}
	else
		{
		// No deleted columns, so ensure columnids didn't change.  Additionally,
		// columnids should be monotonically increasing.
		for ( i = 0; i < (INT)ccpcolMax; i++ )
			{
			Assert( rgcpcol[i].columnidDest == rgcpcol[i].columnidSrc );

			if ( FFixedFid( rgcpcol[i].columnidSrc ) )
				{
				Assert( i == 0 ?
					rgcpcol[i].columnidDest == fidFixedLeast :
					rgcpcol[i].columnidDest == rgcpcol[i-1].columnidDest + 1 );
				}
			else
				{
				Assert( FVarFid( rgcpcol[i].columnidSrc ) );
				if ( i == 0 )
					{
					// If we get here, there's no fixed columns.
					Assert( rgcpcol[i].columnidDest == fidVarLeast );
					Assert( pfdb->fidFixedLast == fidFixedLeast - 1 );
					}
				else if ( FVarFid( rgcpcol[i-1].columnidDest ) )
					{					
					Assert( rgcpcol[i].columnidDest == rgcpcol[i-1].columnidDest + 1 );
					}
				else
					{
					// Must be the beginning of the variable columns.
					Assert( rgcpcol[i].columnidDest == fidVarLeast );
					Assert( rgcpcol[i-1].columnidDest == pfdb->fidFixedLast );
					}
				}
			}
		}


	if ( FCOLSDELETEDTagged( fColumnsDeleted ) )
		{
		for ( i = 0; i < pfdb->fidTaggedLast + 1 - fidTaggedLeast; i++ )
			{
			if ( pfieldTagged[i].coltyp != JET_coltypNil )
				{
				Assert( FTaggedFid( mpcolumnidcolumnidTagged[i] ) );
				Assert(	mpcolumnidcolumnidTagged[i] <=
					(JET_COLUMNID)( i + fidTaggedLeast ) );
				}
			}
		}
	else
		{
		// No deleted columns, so ensure columnids didn't change.
		for ( i = 0; i < pfdb->fidTaggedLast + 1 - fidTaggedLeast; i++ )
			{
			Assert( i == 0 ?
				mpcolumnidcolumnidTagged[i] == fidTaggedLeast :
				mpcolumnidcolumnidTagged[i] == mpcolumnidcolumnidTagged[i-1] + 1 );
			Assert( mpcolumnidcolumnidTagged[i] == (JET_COLUMNID)( i + fidTaggedLeast ) );
			}
		}

	}

#else		// !DEBUG

#define SORTAssertColumnidMaps( pfdb, rgcpcol, ccpcolMax, mpcolumnidcolumnidTagged, fColumnsDeleted )

#endif		// !DEBUG


ERR ISAMAPI ErrIsamCopyRecords(
	JET_SESID		sesid,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	CPCOL			*rgcpcol,
	ULONG			ccpcolMax,
	long			crecMax,
	ULONG			*pcsridCopied,
	ULONG			*precidLast,
	JET_COLUMNID	*mpcolumnidcolumnidTagged,
	STATUSINFO		*pstatus )
	{
	ERR				err;
	PIB				*ppib;
	FUCB			*pfucbSrc;
	FUCB			*pfucbDest;
	FDB				*pfdb;
	FIELD			*pfieldTagged;
	BYTE			fColumnsDeleted;
	LONG			dsrid = 0;
	BYTE			*pbRecBuf = NULL;		// allocate buffer for source record
	BYTE			*pbLVBuf = NULL;		// allocate buffer for copying long values
	BOOL			fDoAll = ( crecMax == 0 );
	PGNO			pgnoCurrPage;
	INT				i;

#if DEBUG
	VTFNDEF			*pvtfndef;
#endif

	pbLVBuf = LAlloc( cbLvMax, 1 );
	if ( pbLVBuf == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	pbRecBuf = SAlloc( cbRECRecordMost );
	if ( pbRecBuf == NULL )
		{
		Assert( pbLVBuf != NULL );
		LFree( pbLVBuf );
		return ErrERRCheck( JET_errOutOfMemory );
		}
	
	ppib = (PIB *)UtilGetVSesidOfSesidTableid( sesid, tableidSrc );
	Assert( sesid == SesidOfPib( ppib ) );
		
	/*	ensure tableidSrc and tableidDest are system ISAM
	/**/
	Assert( ErrGetPvtfndefTableid( sesid, tableidSrc, &pvtfndef ) == JET_errSuccess );
	Assert( pvtfndef == (VTFNDEF *)&vtfndefIsam  ||  pvtfndef == (VTFNDEF *)&vtfndefTTBase );
	Assert( ErrGetPvtfndefTableid( sesid, tableidDest, &pvtfndef ) == JET_errSuccess );
	Assert( pvtfndef == (VTFNDEF *)&vtfndefIsam  ||  pvtfndef == (VTFNDEF *)&vtfndefTTBase );

	Call( ErrGetVtidTableid( sesid, tableidSrc, (JET_VTID *) &pfucbSrc ) );
	Call( ErrGetVtidTableid( sesid, tableidDest, (JET_VTID *) &pfucbDest ) );

	Assert( ppib == pfucbSrc->ppib  &&  ppib == pfucbDest->ppib );

	pfdb = (FDB *)pfucbSrc->u.pfcb->pfdb;

	// Need to determine if there were any columns deleted.
	FCOLSDELETEDSetNone( fColumnsDeleted );

	// The fixed/variable columnid map already filters out deleted columns.
	// If the size of the map is not equal to the number of fixed and variable
	// columns in the source table, then we know some have been deleted.
	Assert( ccpcolMax <=
		(ULONG)( ( pfdb->fidFixedLast + 1 - fidFixedLeast ) + ( pfdb->fidVarLast + 1 - fidVarLeast ) ) );
	if ( ccpcolMax < (ULONG)( ( pfdb->fidFixedLast + 1 - fidFixedLeast ) + ( pfdb->fidVarLast + 1 - fidVarLeast ) ) )
		{
		FCOLSDELETEDSetFixedVar( fColumnsDeleted );	
		}

	/*	tagged columnid map works differently than the fixed/variable columnid
	/*	map; deleted columns are not filtered out (they have an entry of 0).  So we
	/*	have to consult the source table's FDB.
	/**/
	pfieldTagged = PfieldFDBTagged( pfdb );
	for ( i = 0; i < ( pfdb->fidTaggedLast + 1 - fidTaggedLeast ); i++ )
		{
		if ( pfieldTagged[i].coltyp == JET_coltypNil )
			{
			FCOLSDELETEDSetTagged( fColumnsDeleted );
			break;
			}
		}

	SORTAssertColumnidMaps(
		pfdb,
		rgcpcol,
		ccpcolMax,
		mpcolumnidcolumnidTagged,
		fColumnsDeleted );

	Assert( crecMax >= 0 );	

	/*	move 0 to check and set currency
	/**/
	Call( ErrIsamMove( ppib, pfucbSrc, 0, 0 ) );

	pgnoCurrPage = PcsrCurrent( pfucbSrc )->pgno;

	forever
		{
		err = ErrSORTCopyOneRecord(
			pfucbSrc,
			pfucbDest,
			fColumnsDeleted,
			pbRecBuf,
			pbLVBuf,
			rgcpcol,						// Only used for DEBUG
			ccpcolMax,						// Only used for DEBUG
			mpcolumnidcolumnidTagged,
			pstatus );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				// UNDONE:  The event log here should say that we lost the entire
				// record, not just a column.
				UtilReportEvent( EVENTLOG_WARNING_TYPE, REPAIR_CATEGORY, REPAIR_BAD_COLUMN_ID, 0, NULL );
				}
			else
				goto HandleError;
			}

		dsrid++;

		/*	break if copied required records or if no next/prev record
		/**/

		if ( !fDoAll  &&  --crecMax == 0 )
			break;

		err = ErrIsamMove( pfucbSrc->ppib, pfucbSrc, JET_MoveNext, 0 );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord  &&  pstatus != NULL )
				{
				ERR errT;

				pstatus->cLeafPagesTraversed++;
				errT = ErrSORTCopyProgress( pstatus, 1 );
				if ( errT < 0 )
					err = errT;
				}
			goto HandleError;
			}

		else if ( pstatus != NULL  &&  pgnoCurrPage != PcsrCurrent( pfucbSrc )->pgno )
			{
			pgnoCurrPage = PcsrCurrent( pfucbSrc )->pgno;
			pstatus->cLeafPagesTraversed++;
			Call( ErrSORTCopyProgress( pstatus, 1 ) );
			}
		}

HandleError:
	if ( pcsridCopied )
		*pcsridCopied = dsrid;
	if ( precidLast )
		*precidLast = 0xffffffff;

	if ( pbRecBuf != NULL )
		{
		SFree( pbRecBuf );
		}
	if ( pbLVBuf != NULL )
		{
		LFree( pbLVBuf );
		}

	if ( ( err < 0 ) && ( tableidGlobalLIDMap != JET_tableidNil ) )
		{
		CallS( ErrSORTTermLIDMap( ppib ) );
		Assert( tableidGlobalLIDMap == JET_tableidNil );
		}

	return err;
	}


/*=================================================================
ErrIsamSortMaterialize

Description: Converts a SORT file into a temporary file so that it
			 may be accessed using the normal file access functions.


/*	1.	create temporary table
/*	2.	use DIR operations to convert SORT data to FILE data
/*	3.	fake SORT cursor to be FILE cursor
/*	4.	close SORT cursor and return SORT resources
/**/
/*
Parameters:	FUCB *pfucbSort 	pointer to the FUCB for the sort file

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamMove( PIB *ppib, FUCB *pfucb, LONG crow, JET_GRBIT grbit );



CRIT  			critTTName;
static ULONG 	ulTempNum = 0;

INLINE LOCAL ULONG ulRECTempNameGen( VOID )
	{
	ULONG ulNum;

	SgEnterCriticalSection( critTTName );
	ulNum = ulTempNum++;
	SgLeaveCriticalSection( critTTName );

	return ulNum;
	}


ERR VTAPI ErrIsamSortMaterialize( PIB *ppib, FUCB *pfucbSort, BOOL fIndex )
	{
	ERR		err;
	FUCB   	*pfucbTable = pfucbNil;
	FCB		*pfcbTable;
	FCB		*pfcbSort;
	FDB		*pfdb;
	IDB		*pidb;
	BYTE   	szName[JET_cbNameMost+1];
	BOOL	fBeginTransaction = fFalse;
	JET_TABLECREATE	tablecreate = {
		sizeof(JET_TABLECREATE),
		szName,
	   	16, 100, 			// Pages and density
	   	NULL, 0, NULL, 0,	// Columns and indexes
	   	0,					// grbit
	   	0,					// returned tableid
	   	0 };				// returned count of objects created

	CallR( ErrPIBCheck( ppib ) );
	CheckSort( ppib, pfucbSort );

	Assert( ppib->level < levelMax );
	Assert( pfucbSort->ppib == ppib );
	Assert( !( FFUCBIndex( pfucbSort ) ) );

	/*	causes remaining runs to be flushed to disk
	/**/
	if ( FSCBInsert( pfucbSort->u.pscb ) )
		{
		CallR( ErrSORTEndInsert( pfucbSort ) );
		}

	CallR( ErrDIRBeginTransaction( ppib ) );
	fBeginTransaction = fTrue;

	/*	generate temporary file name
	/**/
	//	UNDONE:  use GetTempFileName()
	sprintf( szName, "TEMP%lu", ulRECTempNameGen() );

	/*	create table
	/**/
	Call( ErrFILECreateTable( ppib, dbidTemp, &tablecreate ) );
	pfucbTable = (FUCB *)( tablecreate.tableid );
	/*	only one table created
	/**/
	Assert( tablecreate.cCreated == 1 );

	/*	move to DATA root
	/**/
	DIRGotoDataRoot( pfucbTable );

	pfcbSort = &(pfucbSort->u.pscb->fcb);
	pfcbTable = pfucbTable->u.pfcb;

	err = ErrSORTFirst( pfucbSort );

	if ( fIndex )
		{
		while ( err >= 0 )
			{
			Call( ErrDIRInsert( pfucbTable,
				&pfucbSort->lineData,
				&pfucbSort->keyNode,
				fDIRBackToFather ) );
			err = ErrSORTNext( pfucbSort );
			}
		}
	else
		{
		KEY		key;
		DBK		dbk = 0;
		BYTE  	rgb[4];

		key.cb = sizeof(DBK);
		key.pb = rgb;

		while ( err >= 0 )
			{
			key.pb[0] = (BYTE)(dbk >> 24);
			key.pb[1] = (BYTE)((dbk >> 16) & 0xff);
			key.pb[2] = (BYTE)((dbk >> 8) & 0xff);
			key.pb[3] = (BYTE)(dbk & 0xff);
			dbk++;

			Call( ErrDIRInsert( pfucbTable,
				&pfucbSort->lineData,
				&key,
				fDIRDuplicate | fDIRBackToFather ) );
			err = ErrSORTNext( pfucbSort );
			}

		pfcbTable->dbkMost = dbk;
		}

	if ( err < 0 && err != JET_errNoCurrentRecord )
		{
		goto HandleError;
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	fBeginTransaction = fFalse;

	/*	convert sort cursor into table cursor by changing flags.
	/**/
	Assert( pfcbTable->pfcbNextIndex == pfcbNil );
	Assert( pfcbTable->dbid == dbidTemp );
	pfcbTable->cbDensityFree = 0;
	//	UNDONE:	clean up flag reset
	Assert( FFCBDomainDenyReadByUs( pfcbTable, ppib ) );
	pfcbTable->ulFlags = 0;
	pfcbTable->fFCBDomainDenyRead = 1;
	FCBSetTemporaryTable( pfcbTable );
	FCBSetClusteredIndex( pfcbTable );

	/*	switch sort and table FDP so FDP preserved and ErrFILECloseTable.
	/**/
	pfdb = (FDB *)pfcbSort->pfdb;
	pfcbSort->pfdb = pfcbTable->pfdb;
	pfcbTable->pfdb = pfdb;

	/*	switch sort and table IDB so IDB preserved and ErrFILECloseTable,
	/*	only if fIndex.
	/**/
	if ( fIndex )
		{
		pidb = pfcbSort->pidb;
		pfcbSort->pidb = pfcbTable->pidb;
		pfcbTable->pidb = pidb;
		}

	/*	convert sort cursor flags to table flags, with fFUCBOrignallySort
	/**/
	Assert( pfucbSort->dbid == dbidTemp );
	Assert( pfucbSort->pfucbCurIndex == pfucbNil );
	FUCBSetIndex( pfucbSort );
	FUCBResetSort( pfucbSort );

	/*	release SCB and close table cursor
	/**/
	SORTClosePscb( pfucbSort->u.pscb );
	FCBLink( pfucbSort, pfcbTable );
	CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	pfucbTable = pfucbNil;

	/*	move to the first record ignoring error if table empty
	/**/
	err = ErrIsamMove( ppib, pfucbSort, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		}

	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	return err;

HandleError:
	Assert( err < 0 );
	if ( pfucbTable != pfucbNil )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		}
	if ( fBeginTransaction )
		{
		CallS( ErrDIRRollback( ppib ) );
		}
	return err;
	}


#pragma warning(disable:4028 4030)

#ifndef DEBUG
#define ErrIsamSortMakeKey	 		ErrIsamMakeKey
#define ErrIsamSortSetColumn 		ErrIsamSetColumn
#define ErrIsamSortRetrieveColumn	ErrIsamRetrieveColumn
#define ErrIsamSortRetrieveKey		ErrIsamRetrieveKey
#endif

#ifdef DB_DISPATCHING
extern VDBFNCapability				ErrIsamCapability;
extern VDBFNCloseDatabase			ErrIsamCloseDatabase;
extern VDBFNCreateObject			ErrIsamCreateObject;
extern VDBFNCreateTable 			ErrIsamCreateTable;
extern VDBFNDeleteObject			ErrIsamDeleteObject;
extern VDBFNDeleteTable 			ErrIsamDeleteTable;
extern VDBFNGetColumnInfo			ErrIsamGetColumnInfo;
extern VDBFNGetDatabaseInfo 		ErrIsamGetDatabaseInfo;
extern VDBFNGetIndexInfo			ErrIsamGetIndexInfo;
extern VDBFNGetObjectInfo			ErrIsamGetObjectInfo;
extern VDBFNOpenTable				ErrIsamOpenTable;
extern VDBFNRenameTable 			ErrIsamRenameTable;
extern VDBFNGetObjidFromName		ErrIsamGetObjidFromName;
extern VDBFNRenameObject			ErrIsamRenameObject;


CODECONST(VDBFNDEF) vdbfndefIsam =
	{
	sizeof(VDBFNDEF),
	0,
	NULL,
	ErrIsamCapability,
	ErrIsamCloseDatabase,
	ErrIsamCreateObject,
	ErrIsamCreateTable,
	ErrIsamDeleteObject,
	ErrIsamDeleteTable,
	ErrIllegalExecuteSql,
	ErrIsamGetColumnInfo,
	ErrIsamGetDatabaseInfo,
	ErrIsamGetIndexInfo,
	ErrIsamGetObjectInfo,
	ErrIllegalGetReferenceInfo,
	ErrIsamOpenTable,
	ErrIsamRenameObject,
	ErrIsamRenameTable,
	ErrIsamGetObjidFromName,
	};
#endif


extern VTFNAddColumn				ErrIsamAddColumn;
extern VTFNCloseTable				ErrIsamCloseTable;
extern VTFNComputeStats 			ErrIsamComputeStats;
extern VTFNCopyBookmarks			ErrIsamCopyBookmarks;
extern VTFNCreateIndex				ErrIsamCreateIndex;
extern VTFNDelete					ErrIsamDelete;
extern VTFNDeleteColumn 			ErrIsamDeleteColumn;
extern VTFNDeleteIndex				ErrIsamDeleteIndex;
extern VTFNDupCursor				ErrIsamDupCursor;
extern VTFNGetBookmark				ErrIsamGetBookmark;
extern VTFNGetChecksum				ErrIsamGetChecksum;
extern VTFNGetCurrentIndex			ErrIsamGetCurrentIndex;
extern VTFNGetCursorInfo			ErrIsamGetCursorInfo;
extern VTFNGetRecordPosition		ErrIsamGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrIsamGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrIsamGetTableIndexInfo;
extern VTFNGetTableInfo 			ErrIsamGetTableInfo;
extern VTFNGotoBookmark 			ErrIsamGotoBookmark;
extern VTFNGotoPosition 			ErrIsamGotoPosition;
extern VTFNMakeKey					ErrIsamMakeKey;
extern VTFNMove 					ErrIsamMove;
extern VTFNNotifyBeginTrans			ErrIsamNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrIsamNotifyCommitTrans;
extern VTFNNotifyRollback			ErrIsamNotifyRollback;
extern VTFNPrepareUpdate			ErrIsamPrepareUpdate;
extern VTFNRenameColumn 			ErrIsamRenameColumn;
extern VTFNRenameIndex				ErrIsamRenameIndex;
extern VTFNRetrieveColumn			ErrIsamRetrieveColumn;
extern VTFNRetrieveKey				ErrIsamRetrieveKey;
extern VTFNSeek 					ErrIsamSeek;
extern VTFNSeek 					ErrIsamSortSeek;
extern VTFNSetCurrentIndex			ErrIsamSetCurrentIndex;
extern VTFNSetColumn				ErrIsamSetColumn;
extern VTFNSetIndexRange			ErrIsamSetIndexRange;
extern VTFNSetIndexRange			ErrIsamSortSetIndexRange;
extern VTFNUpdate					ErrIsamUpdate;
extern VTFNVtIdle					ErrIsamVtIdle;
extern VTFNRetrieveColumn			ErrIsamInfoRetrieveColumn;
extern VTFNSetColumn				ErrIsamInfoSetColumn;
extern VTFNUpdate					ErrIsamInfoUpdate;

extern VTFNDupCursor				ErrIsamSortDupCursor;
extern VTFNGetTableInfo		 		ErrIsamSortGetTableInfo;
extern VTFNCloseTable				ErrIsamSortClose;
extern VTFNMove 					ErrIsamSortMove;
extern VTFNGetBookmark				ErrIsamSortGetBookmark;
extern VTFNGotoBookmark 			ErrIsamSortGotoBookmark;
extern VTFNRetrieveKey				ErrIsamSortRetrieveKey;
extern VTFNUpdate					ErrIsamSortUpdate;

extern VTFNDupCursor				ErrTTSortRetDupCursor;

extern VTFNDupCursor				ErrTTBaseDupCursor;
extern VTFNMove 					ErrTTSortInsMove;
extern VTFNSeek 					ErrTTSortInsSeek;


CODECONST(VTFNDEF) vtfndefIsam =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIsamAddColumn,
	ErrIsamCloseTable,
	ErrIsamComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIsamCreateIndex,
	ErrIllegalCreateReference,
	ErrIsamDelete,
	ErrIsamDeleteColumn,
	ErrIsamDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIsamDupCursor,
	ErrIsamGetBookmark,
	ErrIsamGetChecksum,
	ErrIsamGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIsamGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIsamGetTableIndexInfo,
	ErrIsamGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamGotoBookmark,
	ErrIsamGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIsamRenameColumn,
	ErrIsamRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveKey,
	ErrIsamSeek,
	ErrIsamSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetIndexRange,
	ErrIsamUpdate,
	ErrIllegalEmptyTable,
	};


CODECONST(VTFNDEF) vtfndefIsamInfo =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamCloseTable,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIllegalDupCursor,
	ErrIllegalGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIllegalGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIllegalMakeKey,
	ErrIllegalMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamInfoRetrieveColumn,
	ErrIllegalRetrieveKey,
	ErrIllegalSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamInfoSetColumn,
	ErrIllegalSetIndexRange,
	ErrIsamInfoUpdate,
	ErrIllegalEmptyTable,
	};


CODECONST(VTFNDEF) vtfndefTTSortIns =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIllegalDupCursor,
	ErrIllegalGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIllegalGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrTTSortInsMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIllegalRetrieveColumn,
	ErrIsamSortRetrieveKey,
	ErrTTSortInsSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIllegalSetIndexRange,
	ErrIsamSortUpdate,
	ErrIllegalEmptyTable,
	};


CODECONST(VTFNDEF) vtfndefTTSortRet =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrTTSortRetDupCursor,
	ErrIsamSortGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIsamSortGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamSortGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamSortMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIllegalPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamSortRetrieveKey,
	ErrIsamSortSeek,
	ErrIllegalSetCurrentIndex,
	ErrIllegalSetColumn,
	ErrIsamSortSetIndexRange,
	ErrIllegalUpdate,
	ErrIllegalEmptyTable,
	};


CODECONST(VTFNDEF) vtfndefTTBase =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIsamDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrTTBaseDupCursor,
	ErrIsamGetBookmark,
	ErrIsamGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIsamSortGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveKey,
	ErrIsamSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetIndexRange,
	ErrIsamUpdate,
	ErrIllegalEmptyTable,
	};


#ifdef DEBUG
JET_TABLEID TableidOfVtid( FUCB *pfucb )
	{
	JET_TABLEID	tableid;
	VTFNDEF		*pvtfndef;
	
	tableid = pfucb->tableid;
	Assert( FValidateTableidFromVtid( (JET_VTID)pfucb, tableid, &pvtfndef ) );
	Assert( pvtfndef == &vtfndefIsam ||
		pvtfndef == &vtfndefIsamInfo ||
		pvtfndef == &vtfndefTTBase ||
		pvtfndef == &vtfndefTTSortRet ||
		pvtfndef == &vtfndefTTSortIns );

	return tableid;
	}
#endif


/*=================================================================
// ErrIsamOpenTempTable
//
// Description:
//
//	Returns a tableid for a temporary (lightweight) table.	The data
//	definitions for the table are specified at open time.
//
// Parameters:
//	JET_SESID			sesid				user session id
//	JET_TABLEID			*ptableid			new JET (dispatchable) tableid
//	ULONG				csinfo				count of JET_COLUMNDEF structures
//											(==number of columns in table)
//	JET_COLUMNDEF		*rgcolumndef		An array of column and key defintions
//											Note that TT's do require that a key be
//											defined. (see jet.h for JET_COLUMNDEF)
//	JET_GRBIT			grbit				valid values
//											JET_bitTTUpdatable (for insert and update)
//											JET_bitTTScrollable (for movement other then movenext)
//
// Return Value:
//	err			jet error code or JET_errSuccess.
//	*ptableid	a dispatchable tableid
//
// Errors/Warnings:
//
// Side Effects:
//
=================================================================*/
ERR VDBAPI ErrIsamOpenTempTable(
	JET_SESID				sesid,
	const JET_COLUMNDEF		*rgcolumndef,
	unsigned long			ccolumndef,
	unsigned long			langid,
	JET_GRBIT				grbit,
	JET_TABLEID				*ptableid,
	JET_COLUMNID			*rgcolumnid)
	{
	ERR						err;
	JET_TABLEID				tableid;
	JET_VTID   				vtid;
	INT						fIndexed;
	INT						fLongValues;
	INT						i;

	CallR( ErrIsamSortOpen( (PIB *)sesid, (JET_COLUMNDEF *)rgcolumndef, ccolumndef, (ULONG)langid, grbit, (FUCB **)&tableid, rgcolumnid ) );
	CallS( ErrGetVtidTableid( sesid, tableid, &vtid ) );

	fIndexed = fFalse;
	fLongValues = fFalse;
	for ( i = 0; i < (INT)ccolumndef; i++ )
		{
		fIndexed |= ((rgcolumndef[i].grbit & JET_bitColumnTTKey) != 0);
		fLongValues |= FRECLongValue( rgcolumndef[i].coltyp );
		}

	if ( !fIndexed || fLongValues )
		{
		err = ErrIsamSortMaterialize( (PIB *)sesid, (FUCB *)vtid, fIndexed );
		if ( err < 0 && err != JET_errNoCurrentRecord )
			{
			CallS( ErrIsamSortClose( sesid, vtid ) );
			return err;
			}
		/*	supress JET_errNoCurrentRecord error when opening
		/*	empty temporary table.
		/**/
		err = JET_errSuccess;

		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTBase ) );
		}
	else
		{
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTSortIns ) );
		}

	*ptableid = tableid;
	return err;
	}


ERR ErrTTEndInsert( JET_SESID sesid, JET_VTID vtid, JET_TABLEID tableid )
	{
	ERR				err;
	INT				fMaterialize;
	JET_GRBIT		grbitOpen;

	/*	ErrIsamSortEndInsert returns JET_errNoCurrentRecord if sort empty
	/**/
	err = ErrIsamSortEndInsert( (PIB *)sesid, (FUCB *)vtid, &grbitOpen );

	fMaterialize = ( grbitOpen & JET_bitTTUpdatable ) ||
		( grbitOpen & ( JET_bitTTScrollable | JET_bitTTIndexed ) ) &&
		( err == JET_wrnSortOverflow );

	if ( fMaterialize )
		{
		err = ErrIsamSortMaterialize( (PIB *)sesid, (FUCB *)vtid, ( grbitOpen & JET_bitTTIndexed ) != 0 );
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTBase ) );
		}
	else
		{
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTSortRet ) );
		/*	ErrIsamSortEndInsert returns currency on first record
		/**/
		}

	return err;
	}


/*=================================================================
// ErrTTSortInsMove
//
//	Functionally the same as JetMove().  This routine traps the first
//	move call on a TT, to perform any necessary transformations.
//	Routine should only be used by ttapi.c via disp.asm.
//
//	May cause a sort to be materialized
=================================================================*/
ERR VTAPI ErrTTSortInsMove( JET_SESID sesid, JET_VTID vtid, long crow, JET_GRBIT grbit )
	{
	ERR				err;
	JET_TABLEID		tableid = ((FUCB *)vtid)->tableid;
#ifdef DEBUG
	VTFNDEF			*pvtfndef;
	
	Assert( FValidateTableidFromVtid( vtid, tableid, &pvtfndef ) );
	Assert( pvtfndef == &vtfndefTTSortIns );
#endif		

	CallR( ErrTTEndInsert( sesid, vtid, tableid ) );

	if ( crow == JET_MoveFirst || crow == 0 || crow == 1 )
		return JET_errSuccess;

	err = ErrDispMove( sesid, tableid, crow, grbit );
	return err;
	}


/*=================================================================
// ErrTTSortInsSeek
//
//	Functionally the same as JetSeek().  This routine traps the first
//	seek call on a TT, to perform any necessary transformations.
//	Routine should only be used by ttapi.c via disp.asm.
//
//	May cause a sort to be materialized
=================================================================*/
ERR VTAPI ErrTTSortInsSeek( JET_SESID sesid, JET_VTID vtid, JET_GRBIT grbit )
	{
	ERR				err;
	JET_TABLEID		tableid = ((FUCB *)vtid)->tableid;
#ifdef DEBUG
	VTFNDEF			*pvtfndef;

	Assert( FValidateTableidFromVtid( vtid, tableid, &pvtfndef ) );
	Assert( pvtfndef == &vtfndefTTSortIns );
#endif	

	Call( ErrTTEndInsert(sesid, vtid, tableid ) );
	err = ErrDispSeek(sesid, tableid, grbit );

HandleError:
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


ERR VTAPI ErrTTSortRetDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID *ptableidDup, JET_GRBIT grbit )
	{
	ERR		err;

	err = ErrIsamSortDupCursor( sesid, vtid, ptableidDup, grbit );
	if ( err >= 0 )
		{
		CallS( ErrSetPvtfndefTableid( sesid, *ptableidDup, &vtfndefTTSortRet ) );
		}

	return err;
	}


ERR VTAPI ErrTTBaseDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID *ptableidDup, JET_GRBIT grbit )
	{
	ERR		err;

	err = ErrIsamSortDupCursor( sesid, vtid, ptableidDup, grbit );
	if ( err >= 0 )
		{
		CallS( ErrSetPvtfndefTableid( sesid, *ptableidDup, &vtfndefTTBase ) );
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\stats.c ===
#include "daestd.h"

DeclAssertFile; 				/* Declare file name for assert macros */

ERR ErrSTATSComputeIndexStats( PIB *ppib, FCB *pfcbIdx, FUCB *pfucbTable )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbIdx;
	SR				sr;
	JET_DATESERIAL	dt;
	OBJID			objidTable;
	CHAR 			*szIndexName;

	CallR( ErrDIROpen( ppib, pfcbIdx, 0, &pfucbIdx ) );
	Assert( pfucbIdx != pfucbNil );
	FUCBSetIndex( pfucbIdx );

	/*	initialize stats record
	/**/
	sr.cPages = sr.cItems = sr.cKeys = 0L;
	UtilGetDateTime( &dt );
	memcpy( &sr.dtWhenRun, &dt, sizeof sr.dtWhenRun );

	if ( FFCBClusteredIndex( pfcbIdx ) )
		{
		objidTable = (OBJID)pfcbIdx->pgnoFDP;
		szIndexName = NULL;
		}
	else
		{
		objidTable = (OBJID)pfucbTable->u.pfcb->pgnoFDP;
		szIndexName = pfcbIdx->pidb->szName;
		FUCBSetNonClustered( pfucbIdx );
		}
	Call( ErrDIRComputeStats( pfucbIdx, &sr.cItems, &sr.cKeys, &sr.cPages ) );
	FUCBResetNonClustered( pfucbIdx );

	/*	write stats
	/**/
	Call(ErrCATStats(ppib, pfucbIdx->dbid, objidTable, szIndexName, &sr, fTrue));

HandleError:
	/*	set non-clustered for cursor reuse support.
	/**/
	if ( !FFCBClusteredIndex( pfcbIdx ) )
		FUCBSetNonClustered( pfucbIdx );
	DIRClose( pfucbIdx );
	return err;
	}


ERR VTAPI ErrIsamComputeStats( PIB *ppib, FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	FCB		*pfcbIdx;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	/*	start a transaction, in case anything fails
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	compute stats for each index
	/**/
	Assert( pfucb->u.pfcb != pfcbNil );
	for ( pfcbIdx = pfucb->u.pfcb; pfcbIdx != pfcbNil; pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		/*	do not compute stats for index with delete pending
		/**/
		if ( FFCBDeletePending( pfcbIdx ) )
			{
			continue;
			}
		Call( ErrSTATSComputeIndexStats( ppib, pfcbIdx, pfucb ) );
		}

	/*	commit transaction if everything went OK
	/**/
	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return err;

HandleError:
	Assert( err < 0 );
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


/*=================================================================
ErrSTATSRetrieveStats

Description: Returns the number of records and pages used for a table

Parameters:		ppib				pointer to PIB for current session or ppibNil
				dbid				database id or 0
				pfucb				cursor or pfucbNil
				szTableName			the name of the table or NULL
				pcRecord			pointer to count of records
				pcPage				pointer to count of pages

Errors/Warnings:
				JET_errSuccess or error from called routine.

=================================================================*/
ERR ErrSTATSRetrieveTableStats(
	PIB		*ppib,
	DBID   	dbid,
	char   	*szTable,
	long   	*pcRecord,
	long   	*pcKey,
	long   	*pcPage )
	{
	ERR		err;
	FUCB	*pfucb = NULL;
	SR		sr;

	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, szTable, 0 ) );

	Call(ErrCATStats(pfucb->ppib, pfucb->dbid, (OBJID)pfucb->u.pfcb->pgnoFDP, 
		NULL, &sr, fFalse));

	/*	set output variables
	/**/
	if ( pcRecord )
		*pcRecord = sr.cItems;
	if ( pcPage )
		*pcPage = sr.cPages;
	if ( pcKey )
		*pcKey = sr.cKeys;

	Assert(err == JET_errSuccess);

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


ERR ErrSTATSRetrieveIndexStats(
	FUCB   	*pfucbTable,
	char   	*szIndex,
	BOOL	fClustered,
	long   	*pcItem,
	long   	*pcKey,
	long   	*pcPage )
	{
	ERR		err;
	SR		sr;

	// The name is assumed to be valid.

	CallR(ErrCATStats(pfucbTable->ppib, pfucbTable->dbid,
		(OBJID)pfucbTable->u.pfcb->pgnoFDP, (fClustered ? NULL : szIndex),
		&sr, fFalse));

	/*	set output variables
	/**/
	if ( pcItem )
		*pcItem = sr.cItems;
	if ( pcPage )
		*pcPage = sr.cPages;
	if ( pcKey )
		*pcKey = sr.cKeys;

	Assert(err == JET_errSuccess);

	return JET_errSuccess;
	}


	ERR VTAPI
ErrIsamGetRecordPosition( JET_VSESID vsesid, JET_VTID vtid, JET_RECPOS *precpos, unsigned long cbRecpos )
	{
	ERR		err;
	ULONG  	ulLT;
	ULONG	ulTotal;
	PIB *ppib = (PIB *)vsesid;
	FUCB *pfucb = (FUCB *)vtid;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );

	if ( cbRecpos < sizeof(JET_RECPOS) )
		return ErrERRCheck( JET_errInvalidParameter );
	precpos->cbStruct = sizeof(JET_RECPOS);

	/*	get position of non-clustered or clustered cursor
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Call( ErrDIRGetPosition( pfucb->pfucbCurIndex, &ulLT, &ulTotal ) );
		}
	else
		{
		Call( ErrDIRGetPosition( pfucb, &ulLT, &ulTotal ) );
		}

	precpos->centriesLT = ulLT;
	//	CONSIDER:	remove this bogus field
	precpos->centriesInRange = 1;
	precpos->centriesTotal = ulTotal;

HandleError:
	return err;
	}


ERR ISAMAPI ErrIsamIndexRecordCount( JET_SESID sesid, JET_TABLEID tableid, unsigned long *pulCount, unsigned long ulCountMost )
	{
	ERR	 	err;
	PIB	 	*ppib = (PIB *)sesid;
	FUCB 	*pfucb;
	FUCB 	*pfucbIdx;

	CallR( ErrPIBCheck( ppib ) );

	/*	get pfucb from tableid
	/**/
	CallR( ErrGetVtidTableid( sesid, tableid, (JET_VTID *)&pfucb ) );

	CheckTable( ppib, pfucb );

	/*	get cursor for current index
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		pfucbIdx = pfucb->pfucbCurIndex;
	else
		pfucbIdx = pfucb;

	err = ErrDIRIndexRecordCount( pfucbIdx, pulCount, ulCountMost, fTrue );
	return err;
	};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\sysinit.c ===
#include "daestd.h"

#include <ctype.h>
#include <io.h>

DeclAssertFile;					/* Declare file name for assert macros */

extern INT itibGlobal;
extern void *  critSplit;
extern BOOL	fBackupInProgress;
extern PIB	*ppibBackup;
extern ULONG cMPLTotalEntries;

BOOL fSTInit = fSTInitNotDone;

#if defined( DEBUG ) || defined( PERFDUMP )
BOOL	fDBGPerfOutput = fFalse;
long	lAPICallLogLevel = 4;
#endif	/* DEBUG || PERFDUMP */

/*	system parameter constants
/**/
long	lMaxDatabaseOpen = cdabDefault;
long	lMaxBuffers = cbfDefault;
long	lMaxSessions = cpibDefault;
long	lMaxOpenTables = cfcbDefault;
long	lPreferredMaxOpenTables = cfcbDefault;
long	lMaxOpenTableIndexes = cidbDefault;
long	lMaxTemporaryTables = cscbDefault;
long	lMaxCursors = cfucbDefault;
long	lMaxVerPages = cbucketDefault;
long	lLogBuffers = csecLogBufferDefault;
long	lLogFileSize = csecLogFileSizeDefault;
long	lLogFlushThreshold = csecLogFlushThresholdDefault;
long	lBufThresholdLowPercent = ulThresholdLowDefault;
long	lBufThresholdHighPercent = ulThresholdHighDefault;
long	lBufGenAge = cBufGenAgeDefault;
long	lWaitLogFlush = lWaitLogFlushDefault;
long	lCommitDefault = 0;
long	lLogFlushPeriod = lLogFlushPeriodDefault;
long	lLGCheckPointPeriod = lLGCheckpointPeriodDefault;
long	lLGWaitingUserMax = lLGWaitingUserMaxDefault;
long	lPageFragment = lPageFragmentDefault;
CHAR	szLogFilePath[cbFilenameMost + 1] = ".\0";	/* cur dir as default */
BOOL	fDoNotOverWriteLogFilePath = fFalse;
CHAR	szRecovery[cbFilenameMost + 1] = "on";		/* on by default */
BOOL	fOLCompact = fTrue;	/*	on by default */

long lBufBatchIOMax = lBufBatchIOMaxDefault;
long lPageReadAheadMax = lPageReadAheadMaxDefault;
long lAsynchIOMax = lAsynchIOMaxDefault;
long cpageTempDBMin = cpageTempDBMinDefault;

char szBaseName[16]				= "edb";
char szBaseExt[16]				= "edb";
char szSystemPath[_MAX_PATH+1]	= ".\0";
int  fTempPathSet				= 0;
char szTempPath[_MAX_PATH + 1]	= "temp.edb";
char szJet[16] 					= "edb";
char szJetLog[16] 				= "edb.log";
char szJetLogNameTemplate[16] 	= "edb00000";
char szJetTmp[16] 				= "edbtmp";
char szJetTmpLog[16]  			= "edbtmp.log";
char szMdbExt[16] 				= ".edb";
char szJetTxt[16] 				= "edb.txt";

LONG cpgSESysMin = cpageDbExtensionDefault;	// minimum secondary extent size, default is 16

#define	szTempDbPath	szTempPath

/* NOTE: whenever this is changed, also update the #define's in util.h */
RES  rgres[] = {
/* 1*/	sizeof(CSR),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 2*/	sizeof(FCB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 3*/	sizeof(FUCB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 4*/	sizeof(IDB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 5*/	sizeof(PIB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 6*/	sizeof(SCB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 7*/	sizeof(DAB),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 8*/	sizeof(BUCKET),		0,	NULL,	0,	NULL, 0,	0,	NULL,
/* 9*/	sizeof(BF),			0,	NULL,	0,	NULL, 0,	0,	NULL,
/*10*/	0,					0,	NULL,	0,	NULL, 0,	0,	NULL,
/*11*/	0,					0,	NULL,	0,	NULL, 0,	0,	NULL,
/*12*/	0,					0,	NULL,	0,	NULL, 0,	0,	NULL };

extern BOOL fDBGPrintToStdOut;


#ifdef DEBUG
VOID ITDBGSetConstants( VOID )
	{
	CHAR		*sz;					

	if ( ( sz = GetDebugEnvValue ( "PrintToStdOut" ) ) != NULL )
		{
		fDBGPrintToStdOut = fTrue;
		SFree( sz );
		}
	else
		{
		fDBGPrintToStdOut = fFalse;
		}

	/*	use system environment variables to overwrite the default.
	/*	if the JETUSEENV is set.
	/**/
	if ( ( sz = GetDebugEnvValue ( "JETUSEENV" ) ) == NULL )
		return;
	
	SFree( sz );

	if ( ( sz = GetDebugEnvValue ( "JETRecovery" ) ) != NULL )
		{
		if ( strlen( sz ) > sizeof(szRecovery) )
			{
			SFree( sz );
			return;
			}
		strcpy( szRecovery, sz );
		SFree( sz );
		}
		 
	if ( ( sz = GetDebugEnvValue ( "JETLogFilePath" ) ) != NULL )
		{
		if ( strlen( sz ) > sizeof( szLogFilePath ) )
			{
			SFree( sz );
			return;
			}
		strcpy( szLogFilePath, sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETDbExtensionSize" ) ) != NULL )
		{
		cpgSESysMin = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETBfThrshldLowPrcnt" ) ) != NULL )
		{
		lBufThresholdLowPercent = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETBfThrshldHighPrcnt" ) ) != NULL )
		{
		lBufThresholdHighPercent = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETBfGenAge" ) ) != NULL )
		{
		lBufGenAge = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETMaxBuffers" ) ) != NULL )
		{
		lMaxBuffers = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETBufBatchIOMax" )) != NULL )
		{
		lBufBatchIOMax = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETPageReadAheadMax" ) ) != NULL )
		{
		lPageReadAheadMax = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETPageAsynchIOMax" ) ) != NULL )
		{
		lAsynchIOMax = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETPageTempDBMin" ) ) != NULL )
		{
		cpageTempDBMin = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxDBOpen" ) ) != NULL )
		{
		lMaxDatabaseOpen = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETMaxSessions" ) ) != NULL )
		{
		lMaxSessions = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxOpenTables" ) ) != NULL )
		{
		lMaxOpenTables = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxOpenTableIndexes" ) ) != NULL )
		{
		lMaxOpenTableIndexes = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxTemporaryTables" ) ) != NULL )
		{
		lMaxTemporaryTables = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxCursors" ) ) != NULL )
		{
		lMaxCursors = atol( sz );
		SFree( sz );
		}
	
	if ( ( sz = GetDebugEnvValue ( "JETMaxVerPages" ) ) != NULL )
		{
		lMaxVerPages = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogBuffers" ) ) != NULL )
		{
		lLogBuffers = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogFlushThreshold" ) ) != NULL )
		{
		lLogFlushThreshold = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETCheckPointPeriod" ) ) != NULL )
		{
		lLGCheckPointPeriod = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogWaitingUserMax" ) ) != NULL )
		{
		lLGWaitingUserMax = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogFileSize" ) ) != NULL )
		{
		lLogFileSize = atol(sz);
		SFree(sz);
		}

	if ( ( sz = GetDebugEnvValue ( "JETWaitLogFlush" ) ) != NULL )
		{
		lWaitLogFlush = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogFlushPeriod" ) ) != NULL )
		{
		lLogFlushPeriod = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "JETLogCircularLogging" ) ) != NULL )
		{
		fLGGlobalCircularLog = atol( sz );
		SFree( sz );
		}

	if ( ( sz = GetDebugEnvValue ( "PERFOUTPUT" ) ) != NULL )
		{
		fDBGPerfOutput = fTrue;
		SFree( sz );
		}
	else
		{
		fDBGPerfOutput = fFalse;
		}

	if ( ( sz = GetDebugEnvValue ( "APICallLogLevel" ) ) != NULL )
		{
		lAPICallLogLevel = atol(sz);
		SFree(sz);
		}
	else
		lAPICallLogLevel = 4;
	}
#endif

ERR ErrITSetConstants( VOID )
	{
#ifdef DEBUG
	ITDBGSetConstants();
#endif
		
	/*	initialize rgres.  system path in rgtib[itib].szSystemPath,
	/*	is initialized by JET layer.
	/**/
	rgres[iresFCB].cblockAlloc = lMaxOpenTables;
	rgres[iresFUCB].cblockAlloc = lMaxCursors;
	rgres[iresIDB].cblockAlloc = lMaxOpenTableIndexes;

	/*	each user session can begin another one for BMCleanBeforeSplit
	/**/
	rgres[iresPIB].cblockAlloc = lMaxSessions + cpibSystem; 
	rgres[iresSCB].cblockAlloc = lMaxTemporaryTables;
	if ( fRecovering )
		{
		rgres[iresVER].cblockAlloc =
			(LONG) max( (ULONG) lMaxVerPages * 1.1, (ULONG) lMaxVerPages + 2 ) + cbucketSystem;
		}
	else
		{
		rgres[iresVER].cblockAlloc = lMaxVerPages + cbucketSystem;
		}
	rgres[iresBF].cblockAlloc = lMaxBuffers;
	rgres[iresDAB].cblockAlloc = lMaxDatabaseOpen;

	/*	compute derived parameters
	/**/
	rgres[iresCSR].cblockAlloc = lCSRPerFUCB * rgres[iresFUCB].cblockAlloc;
	
	return JET_errSuccess;
	}


//+API
//	ErrITInit
//	========================================================
//	ERR ErrITInit( VOID )
//
//	Initialize the storage system: page buffers, log buffers, and the
//	database files.
//
//	RETURNS		JET_errSuccess
//-
ERR ErrITInit( VOID )
	{
	ERR		err;
	PIB		*ppib = ppibNil;
	DBID	dbidTempDb;

	/*	sleep while initialization is in progress
	/**/
	while ( fSTInit == fSTInitInProgress )
		{
		UtilSleep( 1000 );
		}

	/*	serialize system initialization
	/**/
	if ( fSTInit == fSTInitDone )
		{
		return JET_errSuccess;
		}

	/*	initialization in progress
	/**/
	fSTInit = fSTInitInProgress;

	/*	initialize critical sections
	/**/
	Call( SgErrInitializeCriticalSection( &critBuf ) );
	Call( SgErrInitializeCriticalSection( &critGlobalFCBList ) );
	Call( ErrInitializeCriticalSection( &critSplit ) );

	/*	initialize Global variables
	/**/
	ppibGlobal = ppibNil;

	/*	initialize subcomponents
	/**/
	Call( ErrIOInit() );
	CallJ( ErrMEMInit(), TermIO );
	if ( lPreferredMaxOpenTables < lMaxOpenTables )
		{
		Assert( rgres[iresFCB].cblockAlloc == lMaxOpenTables );
		rgres[iresFCB].pbPreferredThreshold =
			rgres[iresFCB].pbAlloc + ( lPreferredMaxOpenTables * rgres[iresFCB].cbSize );
		}
	ppibGlobalMin = (PIB *)rgres[iresPIB].pbAlloc;
	ppibGlobalMax = (PIB *)rgres[iresPIB].pbAlloc + rgres[iresPIB].cblockAlloc;
	pdabGlobalMin = (DAB *)rgres[iresDAB].pbAlloc;
	pdabGlobalMax = (DAB *)rgres[iresDAB].pbAlloc + rgres[iresDAB].cblockAlloc;
	CallJ( ErrBFInit(), TermMEM );
	CallJ( ErrVERInit(), TermBF );
	CallJ( ErrMPLInit(), TermVER );
	FCBHashInit();

	/*	must initialize BM after log is initialized so that no interference
	/*	from BMClean thread to recovery operations.
	/**/
	CallJ( ErrBMInit(), TermMPL );

	/*	begin storage level session to support all future system
	/*	initialization activites that require a user for
	/*	transaction control
	/**/
	AssertCriticalSection( critJet );
	CallJ( ErrPIBBeginSession( &ppib, procidNil ), TermBM );

	/*  open and set size of temp database
	/**/
	if ( FDBIDAttached( dbidTemp ) )
		{
		DBIDResetAttached( dbidTemp );
		SFree(rgfmp[dbidTemp].szDatabaseName);
		rgfmp[dbidTemp].szDatabaseName = 0;
		rgfmp[dbidTemp].hf = handleNil;
		}

	dbidTempDb = dbidTemp;
	CallJ( ErrDBCreateDatabase( ppib,
		szTempDbPath,
		NULL,
		&dbidTempDb,
		cpageTempDBMin,
		JET_bitDbRecoveryOff,
		NULL ), ClosePIB );
	Assert( dbidTempDb == dbidTemp );

	PIBEndSession( ppib );

	/*	begin backup session 
	/**/
	Assert( ppibBackup == ppibNil );
	if ( !fRecovering )
		{
		CallJ( ErrPIBBeginSession( &ppibBackup, procidNil ), TermBM );
		}
	
	fSTInit = fSTInitDone;
	/*	give theads a chance to initialize
	/**/
	LeaveCriticalSection( critJet );
	UtilSleep( 1000 );
	EnterCriticalSection( critJet );
	return JET_errSuccess;

ClosePIB:
	Assert( ppib != ppibNil );
	PIBEndSession( ppib );

TermBM:
	CallS( ErrBMTerm() );

TermMPL:
	MPLTerm();

TermVER:
	VERTerm( fFalse /* not normal */ );

TermBF:
	BFTerm( fFalse /* not normal */ );

TermMEM:
	MEMTerm();

TermIO:
	(VOID)ErrIOTerm( fFalse /* not normal */ );

HandleError:
	ppibGlobal = ppibNil;
	FCBTerm();

	fSTInit = fSTInitNotDone;
	return err;
	}


//+api------------------------------------------------------
//
//	ErrITTerm
//	========================================================
//
//	ERR ErrITTerm( VOID )
//
//	Flush the page buffers to disk so that database file be in 
//	consistent state.  If error in RCCleanUp or in BFFlush, then DO NOT
//	terminate log, thereby forcing redo on next initialization.
//
//----------------------------------------------------------

ERR ErrITTerm( INT fTerm )
	{
	ERR			err;
	ERR			errRet = JET_errSuccess;
	ULONG		icall = 0;

	Assert( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp || fTerm == fTermError );
			
	/*	sleep while initialization is in progress
	/**/
	AssertCriticalSection( critJet );
	while ( fSTInit == fSTInitInProgress )
		{
		LeaveCriticalSection( critJet );
		UtilSleep( 1000 );
		EnterCriticalSection( critJet );
		}

	/*	make sure no other transactions in progress
	/**/
	/*	if write error on page, RCCleanup will return -err
	/*	if write error on buffer, BFFlush will return -err
	/*	-err passed to LGTerm will cause correctness flag to
	/*	be omitted from log thereby forcing recovery on next
	/*	startup, and causing LGTerm to return +err, which
	/*	may be used by JetQuit to show error
	/**/
	if ( fSTInit == fSTInitNotDone )
		return ErrERRCheck( JET_errNotInitialized );

	if ( ( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp ) && fBackupInProgress )
		{
		return ErrERRCheck( JET_errBackupInProgress );
		}

	/*	terminate backup session
	/**/
	if ( ppibBackup != ppibNil )
		{
		PIBEndSession( ppibBackup );
		}
	ppibBackup = ppibNil;
	
#ifdef DEBUG
	MEMPrintStat();
#endif

	/*	clean up all entries
	/**/
	if ( fTerm == fTermCleanUp )
		{
#ifdef DEBUG		
		FCB	*pfcbT;
#endif
		
		do
			{
			err = ErrRCECleanAllPIB();
			Assert( err == JET_errSuccess || err == JET_wrnRemainingVersions );
			}
		while ( err == JET_wrnRemainingVersions );
		
#ifdef DEBUG
		// Verify that all FCB's have been cleaned and there are no outstanding versions.
		for ( pfcbT = pfcbGlobalMRU; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbLRU )
			{
			Assert( pfcbT->cVersion == 0 );
			}
#endif
		}
		
	else
		{
		(VOID)ErrRCECleanAllPIB();
		}

	/* 	complete bookmark clean up
	/**/
	if ( !fRecovering && fTerm == fTermCleanUp )
		{
		ULONG	cConsecutiveNullOps = 0;
		
		/* heuristic -- each page in MPL causes at most one merge
		/* therefore, loop for at most 2*cMPLTotalEntries
		/**/
		do
			{
			Assert( ppibBMClean != ppibNil );
			CallR( ErrBMClean( ppibBMClean ) );
			if ( err == wrnBMCleanNullOp )
				{
				cConsecutiveNullOps++;
				}
			else 
				{
				cConsecutiveNullOps = 0;
				}
			} while ( ++icall < icallIdleBMCleanMax && 
					  cConsecutiveNullOps <= cMPLTotalEntries &&
					  err != JET_wrnNoIdleActivity );
		}
	
	if ( ( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp ) && trxOldest != trxMax )
		{
		return ErrERRCheck( JET_errTooManyActiveUsers );
		}

	/*
	 *	Enter no-returning point. Once we kill one thread, we kill them all !!!!
	 */
	fSTInit = fSTInitNotDone;

	/*	stop bookmark clean up to prevent from interfering buffer flush
	/**/
	err = ErrBMTerm();
	if ( err < 0 )
		{
		if ( errRet >= 0 )
			errRet = err;
		}

	MPLTerm();
	
	/*	This work is done at every EndSession for Windows runs.
	/*	By the time we get here, there is nothing left to do and
	/*	no more buffers left to flush.
	/**/
	VERTerm( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp );

	/*	flush all buffers
	/**/
	if ( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp )
		{
		err = ErrBFFlushBuffers( 0, fBFFlushAll );
		if ( err < 0 )
			{
			fTerm = fTermError;
			if ( errRet >= 0 )
				errRet = err;
			}
		}

	/*	finish on-going buffer clean up
	/**/
	BFTerm( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp );

	/*  set temp database size
	/**/
	if ( cpageTempDBMin )
		(VOID)ErrIONewSize( dbidTemp, cpageTempDBMin + cpageDBReserved );

	err = ErrIOTerm( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp );
	if ( err < 0 )
		{
		fTerm = fTermError;
		if ( errRet >= 0 )
			errRet = err;
		}
	
	if ( !cpageTempDBMin )
		(VOID)ErrUtilDeleteFile( szTempDbPath );
		
	DeleteCriticalSection( critSplit );

	/*	reset initialization flag
	/**/
	if ( fTerm == fTermCleanUp || fTerm == fTermNoCleanUp )
		{
		/*	if error occurs, cVersion in FCB maybe inaccurate. Purge only
		 *	for regular Term.
		 */
		FCBPurgeDatabase( 0 );
		}
	
#ifdef DEBUG
	PIBPurge();
#else
	ppibGlobal = ppibNil;
#endif

	MEMTerm();
	FCBTerm();

	return errRet;
	}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\tmplteng.c ===
/* systemen.mdb Database Def */

unsigned char rgbEngSysDbDef[] = {
	0x00, 0x20,

	/* Database Page 0 */

	0xFF, 0x77, 0x2C, 0x53, 0x20, 0x9F, 0xF7, 0xAB, 
	0x60, 0x19, 0xEE, 0x78, 0xD1, 0xC5, 0xBC, 0x18, 
	0xBE, 0x42, 0x52, 0xC1, 0xC6, 0xCF, 0x1C, 0x9A, 
	0xDC, 0x7C, 0xED, 0x6C, 0xA9, 0x79, 0x94, 0x96, 
	0xB7, 0xEC, 0x54, 0xBD, 0x0A, 0x8F, 0xBF, 0x7F, 
	0xD6, 0xDD, 0x53, 0x79, 0x5B, 0x41, 0x27, 0x45, 
	0xFE, 0x0C, 0x93, 0xB3, 0xAC, 0xF5, 0x06, 0xC6, 
	0x59, 0x04, 0xFB, 0x8D, 0xDE, 0x2F, 0x71, 0xA2, 
	0x83, 0x84, 0x46, 0x8F, 0x7B, 0x17, 0x11, 0x50, 
	0xC2, 0x5C, 0xC1, 0xB4, 0x83, 0x98, 0x21, 0xCE, 
	0xF5, 0xA4, 0xAF, 0xD4, 0xA7, 0xFE, 0xA6, 0xD5, 
	0x3E, 0x4F, 0xFA, 0x12, 0xB9, 0xB6, 0x03, 0xF4, 
	0x87, 0x87, 0x41, 0xDB, 0x43, 0x15, 0x65, 0x37, 
	0xEF, 0x50, 0x82, 0xAF, 0x91, 0x5F, 0xC7, 0x3D, 
	0x72, 0x79, 0x6A, 0xCE, 0x36, 0x66, 0xDD, 0x5A, 
	0x1B, 0xB6, 0x18, 0x4A, 0xCE, 0x15, 0x75, 0x4C, 
	0x87, 0xFF, 0xA2, 0x7F, 0x94, 0x2A, 0x75, 0x05, 
	0xD7, 0x48, 0xC9, 0xE3, 0x48, 0x72, 0x2A, 0xAC, 
	0xFF, 0xF1, 0x39, 0xE4, 0xB8, 0x2A, 0x08, 0x3F, 
	0xD5, 0x67, 0x59, 0xA4, 0x1D, 0x94, 0x29, 0x3B, 
	0x31, 0x75, 0xFB, 0xC1, 0x51, 0x06, 0x5A, 0xF1, 
	0x80, 0x24, 0xE7, 0x62, 0xDA, 0xA6, 0xD2, 0x0E, 
	0xD2, 0x6C, 0xC7, 0x84, 0x8A, 0x55, 0x4F, 0x2B, 
	0x49, 0xC6, 0xC2, 0x66, 0xBB, 0x49, 0x0E, 0xC3, 
	0xE4, 0x4B, 0x66, 0x3A, 0x16, 0xA5, 0x33, 0xD6, 
	0x1B, 0xBF, 0xD8, 0x76, 0xD7, 0xDC, 0x2F, 0xD1, 
	0x56, 0x8A, 0x34, 0x7A, 0x89, 0x7E, 0x80, 0x28, 
	0x1E, 0x26, 0xFE, 0xEA, 0x14, 0xE2, 0x33, 0xE5, 
	0xA5, 0xFF, 0xE1, 0x75, 0xF5, 0x87, 0x20, 0x82, 
	0xD2, 0x02, 0x7D, 0xE3, 0xA3, 0xCA, 0x4E, 0xFC, 
	0xEC, 0x53, 0x67, 0xA4, 0xA3, 0x70, 0x63, 0x1A, 
	0x26, 0x61, 0xAE, 0x20, 0xD1, 0x24, 0xD8, 0xAA, 
	0x91, 0x3F, 0xFF, 0x6F, 0x0D, 0x93, 0xD3, 0x70, 
	0xB1, 0xB2, 0x46, 0xF9, 0x36, 0x5D, 0x4D, 0xC9, 
	0x11, 0x5C, 0x18, 0x4F, 0xDA, 0xD5, 0x2E, 0x36, 
	0xBB, 0x32, 0x9C, 0x15, 0x71, 0x3D, 0xED, 0xB4, 
	0xCA, 0xBD, 0xF5, 0xD4, 0x91, 0xDC, 0xBD, 0x90, 
	0xB1, 0xC4, 0xD6, 0xBA, 0x38, 0xF8, 0xBF, 0x6F, 
	0x2D, 0x5F, 0x71, 0x93, 0x8E, 0xE1, 0xEC, 0x4F, 
	0x5B, 0xA1, 0xD3, 0x58, 0x93, 0x05, 0xE4, 0x1F, 
	0x92, 0x14, 0x0D, 0xC1, 0x6B, 0xF0, 0x27, 0x0E, 
	0x60, 0x12, 0x56, 0xF0, 0xED, 0xE2, 0xE3, 0x6B, 
	0xC9, 0xCD, 0xC4, 0x63, 0x8F, 0xF2, 0x2E, 0x59, 
	0x26, 0x3B, 0x04, 0xDE, 0xE2, 0x96, 0x34, 0xAC, 
	0x54, 0x49, 0xEA, 0xCB, 0xAF, 0x01, 0x99, 0xCF, 
	0xFB, 0x89, 0xCE, 0xD8, 0x4A, 0x11, 0xE5, 0x80, 
	0x8D, 0xFB, 0x72, 0x52, 0x12, 0xBB, 0x25, 0x36, 
	0x93, 0xD3, 0xA7, 0xAB, 0xDA, 0x70, 0xD0, 0x13, 
	0x11, 0xCA, 0x1F, 0xFF, 0x0A, 0x8D, 0x6D, 0x09, 
	0xB9, 0x6E, 0x14, 0x21, 0x27, 0xF3, 0x57, 0xEF, 
	0x5D, 0x59, 0x95, 0x11, 0x40, 0xDA, 0xD7, 0x40, 
	0xFC, 0xF7, 0x47, 0xE4, 0x69, 0x8B, 0x05, 0xF4, 
	0x37, 0x1F, 0x78, 0x97, 0x83, 0x66, 0x9F, 0x37, 
	0x63, 0xC0, 0xD0, 0x72, 0x4A, 0x9A, 0x9F, 0xE4, 
	0x40, 0x92, 0x3E, 0xC4, 0x84, 0xE4, 0x2F, 0x66, 
	0x6B, 0x85, 0xA3, 0x2A, 0x89, 0x34, 0xBB, 0xF2, 
	0xD7, 0xA3, 0xB1, 0x15, 0xB7, 0xCF, 0x76, 0x48, 
	0x01, 0x03, 0x6B, 0x5C, 0x62, 0xAF, 0x86, 0x0F, 
	0x27, 0xC5, 0x0F, 0x04, 0x21, 0x8F, 0xA0, 0x0E, 
	0x1E, 0xD5, 0xAD, 0x1F, 0xDD, 0xB6, 0x5C, 0xCD, 
	0xA6, 0x19, 0x52, 0x07, 0x93, 0x0F, 0x81, 0xA1, 
	0x53, 0x81, 0x37, 0xE8, 0xD8, 0x10, 0x1E, 0x59, 
	0x0D, 0xEA, 0xA4, 0x9F, 0xCE, 0x6D, 0x5D, 0xFF, 
	0x4F, 0x98, 0xDB, 0xBA, 0x5E, 0x20, 0xF6, 0x44, 
	0x5A, 0x1B, 0x01, 0x01, 0xFF, 0x6E, 0xF9, 0xA6, 
	0x2E, 0x54, 0x82, 0x44, 0x98, 0x12, 0xEA, 0x17, 
	0x38, 0x3A, 0x2A, 0x9B, 0x2E, 0x97, 0xED, 0x95, 
	0x69, 0x3D, 0xD8, 0x02, 0x59, 0x8C, 0xAB, 0xC3, 
	0xF7, 0xCE, 0xEF, 0x62, 0x0A, 0xAB, 0xA5, 0x64, 
	0x09, 0x35, 0x09, 0x01, 0x4B, 0x8E, 0xF2, 0xEC, 
	0x81, 0x54, 0xA5, 0x98, 0x11, 0x47, 0x85, 0x9A, 
	0xAF, 0xAF, 0x46, 0x15, 0x69, 0xE7, 0xEB, 0x95, 
	0x76, 0xEC, 0xBC, 0x30, 0xE0, 0xAE, 0x0A, 0xB3, 
	0x09, 0x9E, 0xDB, 0x31, 0xC1, 0x31, 0x27, 0x18, 
	0x6B, 0xDB, 0xAF, 0xC9, 0xAF, 0x11, 0x1A, 0xD0, 
	0x2C, 0xDC, 0xEE, 0x3A, 0xD1, 0x31, 0x60, 0x6D, 
	0x8F, 0xB3, 0x9B, 0x23, 0x2A, 0x47, 0x68, 0xC6, 
	0x9B, 0xBB, 0x69, 0x40, 0xE9, 0x8A, 0x94, 0xAF, 
	0x73, 0xF9, 0x08, 0xCC, 0x02, 0x99, 0x26, 0x2C, 
	0x1F, 0xBD, 0x05, 0xB0, 0x52, 0x0F, 0x7A, 0xAF, 
	0xCC, 0x97, 0x59, 0xD8, 0x81, 0xFF, 0x46, 0x1B, 
	0x50, 0x01, 0x70, 0xFC, 0xBD, 0xFB, 0x00, 0x79, 
	0x94, 0x4A, 0x2F, 0x5D, 0x03, 0xF1, 0x7C, 0x31, 
	0x72, 0xEF, 0x53, 0xC1, 0xD1, 0xD9, 0x88, 0xA3, 
	0x3F, 0xCA, 0xA6, 0xD7, 0xD7, 0x95, 0x47, 0x5B, 
	0xA6, 0xD9, 0x3F, 0xA6, 0x1E, 0xBC, 0xEF, 0xB6, 
	0x32, 0x1A, 0x49, 0x62, 0xF2, 0xAC, 0x35, 0x61, 
	0x0E, 0x27, 0x74, 0x07, 0x87, 0x58, 0x7D, 0x9D, 
	0xD8, 0x21, 0x6A, 0xEE, 0xAD, 0x76, 0xB4, 0x1E, 
	0xA5, 0x7F, 0x95, 0x3B, 0x86, 0x50, 0x70, 0x98, 
	0xDA, 0x96, 0x8E, 0x86, 0x3C, 0x57, 0xD6, 0xF5, 
	0x91, 0xA8, 0x6F, 0x3B, 0x83, 0xDF, 0x0F, 0x3F, 
	0x10, 0xAE, 0x00, 0x89, 0xD4, 0x9A, 0xAE, 0x5B, 
	0x1A, 0xDF, 0x78, 0x5A, 0xDF, 0x2A, 0x2B, 0x89, 
	0x56, 0x2E, 0x75, 0xE6, 0xAF, 0xE4, 0xDE, 0xC4, 
	0x60, 0x97, 0x2A, 0x6C, 0x6F, 0xC9, 0x12, 0x6D, 
	0x6D, 0xCB, 0xD1, 0x19, 0x61, 0xCC, 0xFF, 0xE9, 
	0x90, 0x69, 0x26, 0x16, 0x63, 0x43, 0x83, 0x3F, 
	0xB7, 0x62, 0xB2, 0xEE, 0xDA, 0x3B, 0x2A, 0xCD, 
	0x43, 0xD6, 0x23, 0x4E, 0x8B, 0x8E, 0x5B, 0x1B, 
	0xA3, 0xA4, 0xA3, 0xF5, 0x82, 0x4C, 0x2F, 0x00, 
	0x2C, 0xC1, 0xFF, 0x88, 0x85, 0x59, 0x55, 0x6E, 
	0x88, 0xD3, 0x35, 0xA9, 0x56, 0xE7, 0x8F, 0xBB, 
	0xD6, 0x54, 0xDE, 0x26, 0xAB, 0x48, 0x15, 0x65, 
	0x41, 0xCE, 0x1B, 0x61, 0xD1, 0x20, 0x5C, 0x42, 
	0xCE, 0x1A, 0x48, 0xC6, 0xA0, 0x4F, 0x87, 0xC9, 
	0x14, 0x80, 0xF5, 0xB0, 0xB9, 0x9B, 0xA5, 0x9E, 
	0x53, 0x73, 0x31, 0xF1, 0x9E, 0xC1, 0x0D, 0xE9, 
	0x65, 0x1E, 0x20, 0x08, 0x2C, 0x54, 0x5C, 0x64, 
	0xAB, 0x6E, 0xD8, 0x40, 0x46, 0x25, 0x09, 0x45, 
	0x61, 0x2A, 0x10, 0xE0, 0xF5, 0xF4, 0x95, 0xC3, 
	0x6F, 0x51, 0x50, 0x88, 0xE4, 0x57, 0xEC, 0x86, 
	0xC8, 0x35, 0x17, 0x79, 0xCA, 0x42, 0x2E, 0xFF, 
	0x9C, 0x8E, 0x8A, 0x83, 0x25, 0xB1, 0xB2, 0xE7, 
	0x8A, 0xAE, 0x9A, 0x9C, 0xA5, 0x38, 0xB4, 0x1D, 
	0xC7, 0xBD, 0xE7, 0x1A, 0xE0, 0x33, 0x47, 0x1C, 
	0x55, 0xE0, 0x19, 0x34, 0xA8, 0x1F, 0xAD, 0xAF, 
	0xBE, 0x40, 0x68, 0xDA, 0x5C, 0x48, 0xA1, 0x47, 
	0xF2, 0xB2, 0x73, 0xF3, 0x72, 0xE3, 0xD7, 0xD3, 
	0x1C, 0x9C, 0xE2, 0x75, 0xA9, 0xF1, 0x9E, 0x06, 
	0x50, 0xD5, 0xDF, 0xD6, 0x35, 0xB5, 0xAE, 0xF2, 
	0xEE, 0x15, 0xF2, 0xD4, 0x89, 0xB4, 0x58, 0xFC, 
	0x54, 0x77, 0x21, 0xCE, 0x18, 0x7D, 0xEA, 0x83, 
	0x6E, 0xFF, 0xA8, 0x6B, 0xF5, 0xBF, 0x91, 0x51, 
	0x1B, 0x52, 0x75, 0x0D, 0x87, 0x31, 0x6F, 0xC8, 
	0x25, 0x08, 0xD7, 0xF2, 0x26, 0xB4, 0x8C, 0x0C, 
	0xE5, 0x42, 0xB7, 0x17, 0x30, 0x84, 0x29, 0x30, 
	0x69, 0xAC, 0x31, 0xB7, 0x59, 0x0D, 0x44, 0xEF, 
	0x12, 0xCD, 0x3E, 0xEF, 0xE4, 0xAC, 0x00, 0xE2, 
	0xFF, 0x31, 0xD4, 0x36, 0x71, 0xC7, 0x3A, 0xC8, 
	0xE4, 0x4D, 0xCF, 0x66, 0xF5, 0xF3, 0xB5, 0xE3, 
	0x04, 0x88, 0x27, 0x0B, 0xF1, 0xE0, 0xB2, 0xFD, 
	0x9B, 0xCD, 0xC8, 0x4C, 0x86, 0xBA, 0x62, 0xCE, 
	0xFB, 0x38, 0x90, 0xCD, 0xC6, 0x73, 0x26, 0xDA, 
	0x41, 0xB3, 0xAC, 0xDF, 0x13, 0x2D, 0x7A, 0x72, 
	0xE3, 0xD1, 0x71, 0x31, 0x54, 0x28, 0x04, 0x2B, 
	0x4C, 0x4C, 0x25, 0xBF, 0x6A, 0xD3, 0xFE, 0xA1, 
	0xDE, 0xBC, 0xE6, 0x32, 0xA8, 0xE1, 0xEC, 0x38, 
	0x6D, 0x2D, 0xE8, 0x21, 0xD6, 0xBB, 0xF3, 0x09, 
	0xA1, 0x90, 0xE6, 0x5B, 0x4D, 0xFB, 0x30, 0xED, 
	0x6F, 0x45, 0x1E, 0xC4, 0x19, 0x1B, 0x14, 0xDB, 
	0x7A, 0xB5, 0xAC, 0x3E, 0x53, 0xEE, 0x82, 0x58, 
	0x8B, 0x6E, 0x14, 0x84, 0x0C, 0xFF, 0x60, 0x86, 
	0xCC, 0xF2, 0xED, 0xB5, 0x9B, 0x2B, 0x38, 0x2A, 
	0x77, 0x59, 0x8A, 0xFD, 0xFF, 0xCC, 0xF5, 0xCF, 
	0xAE, 0xFF, 0x96, 0xEA, 0x7C, 0x59, 0x2A, 0x4D, 
	0x0D, 0x9A, 0xCC, 0xD9, 0x2B, 0x9A, 0x8F, 0x5B, 
	0x95, 0xB9, 0xA6, 0xB1, 0x8C, 0x62, 0x1C, 0xAA, 
	0xE8, 0x8A, 0xAC, 0x7E, 0x68, 0xAB, 0x2D, 0x29, 
	0xA3, 0x91, 0xC6, 0x83, 0x62, 0x91, 0x69, 0xE6, 
	0xB0, 0xB8, 0xE1, 0x86, 0x5E, 0xCB, 0x16, 0xE2, 
	0xD5, 0xBC, 0x48, 0x1F, 0x08, 0xF5, 0x45, 0xB4, 
	0x0F, 0x83, 0x25, 0x65, 0xDD, 0x70, 0xE6, 0xCB, 
	0x9D, 0x3B, 0xC4, 0xA8, 0x1F, 0xBC, 0x12, 0x57, 
	0x43, 0x05, 0x39, 0x4F, 0xEC, 0x73, 0xCC, 0x04, 
	0x2B, 0x38, 0x02, 0x9F, 0x37, 0x70, 0xBF, 0x33, 
	0xED, 0x2C, 0xCF, 0xE4, 0xD4, 0x95, 0x55, 0xF1, 
	0x8C, 0x56, 0xCA, 0x84, 0x4B, 0xBD, 0xA3, 0xCA, 
	0x56, 0xD3, 0xAF, 0x6E, 0xDD, 0x7B, 0xDB, 0xD9, 
	0xA4, 0x9C, 0x48, 0x19, 0xA3, 0xC9, 0xA5, 0xE0, 
	0xC2, 0xB0, 0x3B, 0x5C, 0xC3, 0x05, 0x78, 0xBC, 
	0x0C, 0x36, 0xFF, 0x6E, 0x06, 0x68, 0x6A, 0xE7, 
	0xA2, 0xB2, 0xD1, 0x05, 0x35, 0xF9, 0x8C, 0x0E, 
	0x14, 0xB9, 0x21, 0x69, 0x3A, 0x88, 0x0A, 0x12, 
	0x62, 0x62, 0xCB, 0xA9, 0x95, 0x39, 0x1C, 0x1E, 
	0x3F, 0xAA, 0xCB, 0xE2, 0xA6, 0x66, 0x05, 0xD6, 
	0xD7, 0x7B, 0x84, 0x85, 0xA0, 0xB1, 0x45, 0x96, 
	0x60, 0xC1, 0x1E, 0x3D, 0xAB, 0x4D, 0xC6, 0x2E, 
	0xDE, 0x24, 0xA2, 0x8F, 0x82, 0x81, 0x93, 0xF8, 
	0xF7, 0xCC, 0x7C, 0x7A, 0xA4, 0xAD, 0x6C, 0xB4, 
	0x01, 0xC9, 0xD3, 0x59, 0x6E, 0x21, 0x56, 0x05, 
	0xDB, 0x6C, 0xE5, 0x08, 0xAF, 0xB3, 0xB9, 0xBF, 
	0x98, 0x3C, 0xCE, 0x88, 0x99, 0xC4, 0x92, 0x38, 
	0xB2, 0x38, 0x61, 0xBD, 0x60, 0x46, 0x8B, 0xE2, 
	0xFF, 0x4A, 0xB2, 0x64, 0xA8, 0x44, 0x6D, 0x4D, 
	0x4A, 0xA7, 0x4D, 0x28, 0x5F, 0x25, 0x15, 0x28, 
	0x4D, 0x3C, 0x77, 0xF3, 0xB1, 0xF8, 0x5B, 0x40, 
	0x0B, 0xAD, 0x35, 0xFF, 0xEE, 0x48, 0x11, 0x17, 
	0xB2, 0x2B, 0xF9, 0xCF, 0x29, 0x75, 0xAF, 0xDE, 
	0x16, 0x0F, 0xA4, 0xDE, 0xE6, 0xD3, 0xF7, 0xC1, 
	0x32, 0x0A, 0xF2, 0x42, 0xBB, 0xE9, 0x01, 0xF1, 
	0x03, 0x93, 0x03, 0x24, 0x76, 0xC2, 0x08, 0xA9, 
	0xB6, 0x08, 0xB4, 0x90, 0xDE, 0x68, 0x0E, 0x12, 
	0x46, 0x8E, 0xA0, 0xCD, 0x09, 0x34, 0x7D, 0xCD, 
	0x1F, 0x47, 0x1B, 0xE7, 0x76, 0x71, 0xD4, 0xF2, 
	0xD2, 0x44, 0x23, 0x4F, 0x57, 0x45, 0xB2, 0x29, 
	0xBA, 0x48, 0x6B, 0x6D, 0xC7, 0xE6, 0xC0, 0x3D, 
	0x0E, 0xA7, 0x91, 0x74, 0x7D, 0xB1, 0x13, 0x86, 
	0x75, 0x68, 0x3D, 0x61, 0x97, 0x20, 0xB0, 0x8D, 
	0x63, 0x0D, 0xFC, 0x4A, 0xAF, 0xE5, 0x39, 0x69, 
	0x61, 0xDA, 0xC6, 0x54, 0x41, 0x94, 0x69, 0x8E, 
	0x4C, 0x9F, 0x52, 0x37, 0x81, 0x82, 0xEB, 0x04, 
	0x80, 0x36, 0x77, 0x2B, 0x66, 0x2F, 0x78, 0xBA, 
	0x2A, 0xA9, 0x12, 0xF6, 0xFF, 0x03, 0x05, 0x63, 
	0x14, 0xB3, 0x72, 0x36, 0xAB, 0x99, 0x8E, 0x04, 
	0x10, 0x72, 0xE6, 0x03, 0x08, 0x56, 0x4E, 0x61, 
	0xED, 0x01, 0xB1, 0x50, 0xB2, 0xDA, 0x10, 0x38, 
	0xD3, 0xF8, 0x60, 0xF7, 0x66, 0x8E, 0x98, 0x90, 
	0xD7, 0x74, 0xE8, 0x6D, 0x3A, 0x02, 0xA7, 0xE4, 
	0x72, 0x0A, 0x5C, 0x6E, 0xB3, 0x0F, 0x08, 0x0A, 
	0x73, 0x0F, 0x73, 0x54, 0xB0, 0xBA, 0x7F, 0x93, 
	0xC8, 0x01, 0xE7, 0x9E, 0x92, 0xB9, 0x69, 0xD6, 
	0x97, 0x77, 0x65, 0xFD, 0x6F, 0xAB, 0x70, 0x6E, 
	0x78, 0x6F, 0x97, 0xD0, 0xD1, 0xF9, 0x92, 0x57, 
	0xB7, 0xD1, 0x95, 0x0B, 0xBC, 0x92, 0x22, 0x14, 
	0xD1, 0x7D, 0x75, 0xC2, 0xA3, 0x6D, 0x1C, 0x97, 
	0x1A, 0x6B, 0x02, 0xCE, 0xEF, 0xB2, 0x40, 0x17, 
	0x5C, 0xB3, 0x33, 0x00, 0xB7, 0xFF, 0xE9, 0x6D, 
	0xE5, 0xFA, 0xC7, 0x16, 0x48, 0xAA, 0xE1, 0x57, 
	0x9C, 0x1F, 0xC6, 0x2B, 0x51, 0xFF, 0xDE, 0x35, 
	0xB3, 0x23, 0xFC, 0xE1, 0x70, 0x3E, 0x41, 0x59, 
	0xBE, 0xD1, 0x49, 0xA5, 0xA4, 0xD7, 0x86, 0x9A, 
	0x9D, 0x45, 0x11, 0xDB, 0x3F, 0x69, 0x92, 0xB7, 
	0x2B, 0x70, 0x2C, 0xC5, 0xBF, 0xDF, 0x45, 0xC6, 
	0xC3, 0x73, 0xE2, 0xBB, 0x51, 0x3D, 0xE8, 0xAB, 
	0x0E, 0x6F, 0x80, 0x1C, 0x93, 0x45, 0x85, 0xFE, 
	0x62, 0xE4, 0x7C, 0x96, 0x6A, 0xDD, 0x10, 0x9E, 
	0x27, 0xA7, 0x75, 0x15, 0xE0, 0xBE, 0x0C, 0x54, 
	0x41, 0x13, 0xB1, 0xCF, 0x94, 0x55, 0x5A, 0xF2, 
	0x18, 0x82, 0x39, 0x31, 0xA6, 0x94, 0x7B, 0x22, 
	0x62, 0x7B, 0x76, 0x83, 0xE4, 0x7F, 0xE8, 0x31, 
	0x54, 0xA0, 0x15, 0x75, 0x2F, 0xFD, 0x3B, 0x14, 
	0xB1, 0x78, 0xE6, 0x70, 0x80, 0x6E, 0x89, 0x48, 
	0x6E, 0x56, 0xCE, 0x52, 0x46, 0x67, 0x3D, 0xBD, 
	0x99, 0x0E, 0x7B, 0x8F, 0x21, 0x48, 0x78, 0x87, 
	0x8A, 0xD8, 0xC5, 0x62, 0xD6, 0xD5, 0x7F, 0x7F, 

	/* Database Page 1 */

	0xFF, 0x14, 0xC9, 0x46, 0x84, 0x47, 0xF9, 0x38, 
	0x6F, 0xA5, 0x0D, 0x8C, 0xB9, 0x73, 0x2A, 0x15, 
	0x7F, 0x65, 0x0D, 0x02, 0x76, 0xB5, 0x15, 0x94, 
	0xAD, 0x1F, 0xFF, 0x94, 0x5D, 0x2E, 0xD4, 0x1A, 
	0x33, 0x0A, 0x7D, 0xFD, 0xC9, 0x70, 0xC1, 0xCE, 
	0xCF, 0x78, 0x08, 0x38, 0x91, 0x8D, 0x1C, 0xE7, 
	0x87, 0xAA, 0x40, 0xB2, 0x6D, 0x88, 0xB0, 0xA8, 
	0xFA, 0x13, 0xA1, 0xE1, 0x71, 0xF5, 0xC6, 0x95, 
	0xA1, 0x89, 0x19, 0x21, 0xF5, 0x92, 0x86, 0x7F, 
	0xE8, 0x52, 0xD9, 0xAB, 0x37, 0xC6, 0x22, 0x58, 
	0xFD, 0x76, 0x44, 0x59, 0x59, 0xC8, 0x3C, 0x9E, 
	0x1D, 0x05, 0xCC, 0x1D, 0x50, 0xE8, 0xA8, 0x9D, 
	0x6F, 0xA9, 0x4F, 0x66, 0x82, 0xC9, 0x70, 0x36, 
	0xA6, 0x4B, 0x54, 0xAF, 0x34, 0x9C, 0x14, 0xE8, 
	0xFD, 0xDC, 0xE7, 0x92, 0x10, 0x90, 0x4E, 0x73, 
	0x9A, 0x03, 0xCC, 0x14, 0x67, 0xF1, 0xF2, 0xAE, 
	0x98, 0xFF, 0x8A, 0xA4, 0xAE, 0x31, 0x56, 0x38, 
	0xED, 0xA9, 0x88, 0xC8, 0x2A, 0x32, 0xC0, 0x08, 
	0x5D, 0x77, 0x2E, 0x33, 0x18, 0x01, 0xF6, 0x02, 
	0x83, 0x4E, 0xE7, 0x79, 0xC0, 0xD3, 0x88, 0x35, 
	0x50, 0xE7, 0x99, 0x2E, 0xA8, 0x91, 0x77, 0xFB, 
	0x72, 0x18, 0x63, 0xC9, 0xFA, 0x55, 0x85, 0x5D, 
	0xE2, 0xCD, 0x30, 0x1A, 0xEB, 0x95, 0x47, 0x01, 
	0x7D, 0xEA, 0xE1, 0xEE, 0x79, 0x8C, 0xDA, 0x58, 
	0xB3, 0x76, 0xAD, 0xB9, 0xDF, 0x11, 0xDC, 0x3D, 
	0x9D, 0x76, 0x77, 0xE4, 0xA9, 0x8C, 0x79, 0x28, 
	0x86, 0xAB, 0x83, 0x52, 0x9C, 0x24, 0x5B, 0xCD, 
	0xF1, 0x39, 0xAE, 0xF1, 0x88, 0x75, 0x63, 0xB2, 
	0x23, 0xE8, 0x81, 0x92, 0x67, 0x55, 0x19, 0x4B, 
	0xCA, 0xD1, 0xA7, 0xDD, 0x46, 0x8C, 0x74, 0x2F, 
	0xCB, 0x90, 0x66, 0x4F, 0xCB, 0xFF, 0x3B, 0xB7, 
	0x04, 0x4C, 0xA0, 0xCF, 0x2D, 0x85, 0x69, 0xA0, 
	0xC9, 0x16, 0xFF, 0x34, 0x44, 0x3A, 0x05, 0x01, 
	0x97, 0x2C, 0xD7, 0x4D, 0x36, 0x5F, 0x37, 0x1C, 
	0x6F, 0xF9, 0x0D, 0x7D, 0xE1, 0x8E, 0x90, 0xF7, 
	0x49, 0xB2, 0x69, 0xE8, 0xDC, 0xBD, 0x64, 0xE1, 
	0x09, 0x0A, 0x46, 0x26, 0xC6, 0x33, 0xBD, 0xB9, 
	0x7A, 0xA6, 0xFB, 0x9D, 0xC9, 0x2E, 0x5F, 0xA2, 
	0xFB, 0xE2, 0xE4, 0x21, 0xFE, 0xD5, 0x43, 0x7A, 
	0x01, 0x64, 0x69, 0x23, 0x98, 0xA4, 0x59, 0x40, 
	0x21, 0xAF, 0x6C, 0xEB, 0xAA, 0x5D, 0x6B, 0x7A, 
	0xAF, 0xF5, 0x83, 0x48, 0x71, 0x40, 0xEF, 0x25, 
	0x01, 0x59, 0xB5, 0xBD, 0xCB, 0x04, 0x66, 0x65, 
	0x4B, 0xB0, 0xDD, 0xCE, 0xDE, 0x91, 0x77, 0x8C, 
	0xA4, 0xCC, 0xA9, 0x31, 0x35, 0xDF, 0x9F, 0x3F, 
	0x36, 0x12, 0x34, 0x89, 0x62, 0xE5, 0x62, 0x2A, 
	0x35, 0x81, 0x1F, 0x91, 0xDB, 0x10, 0x37, 0xD6, 
	0xB4, 0xDA, 0xCC, 0xEC, 0x33, 0xF8, 0x32, 0x27, 
	0x86, 0xAC, 0xE1, 0xFF, 0xD2, 0xEA, 0xA7, 0x7E, 
	0x61, 0x65, 0xCC, 0x18, 0x48, 0x7F, 0x0E, 0x84, 
	0x48, 0xF8, 0x28, 0x7C, 0xDC, 0xC7, 0xA2, 0x6C, 
	0x3E, 0x53, 0xAD, 0x33, 0x1D, 0xE7, 0x1C, 0x01, 
	0x83, 0xCC, 0xE0, 0x32, 0xED, 0x34, 0x84, 0x9A, 
	0x6C, 0xA3, 0xF4, 0x7E, 0x2F, 0x9E, 0x17, 0x6D, 
	0x14, 0x61, 0xD1, 0x4B, 0x41, 0x84, 0xCF, 0x2E, 
	0x4A, 0x3C, 0xAF, 0x0B, 0xBE, 0x2C, 0x90, 0x6E, 
	0xC7, 0x17, 0x75, 0x1D, 0xB3, 0xDE, 0xFE, 0x73, 
	0x36, 0x04, 0xC0, 0x29, 0xCB, 0xCF, 0xF1, 0xFD, 
	0x43, 0x73, 0xBC, 0x41, 0xF9, 0xF7, 0x3F, 0xFB, 
	0x25, 0x62, 0xFD, 0x61, 0xBC, 0x94, 0xB5, 0xBF, 
	0x83, 0x7D, 0x04, 0x0D, 0xA3, 0xD0, 0xA7, 0x6C, 
	0x2D, 0x67, 0x7E, 0x00, 0x24, 0xC4, 0x37, 0xC3, 
	0x9D, 0x02, 0x32, 0x62, 0x23, 0x6A, 0x0A, 0x1E, 
	0x70, 0x58, 0x44, 0x20, 0xC0, 0xF8, 0x2A, 0x89, 
	0xB8, 0x80, 0xEC, 0xA7, 0xFF, 0xA7, 0x09, 0x6A, 
	0x21, 0x04, 0x68, 0xE0, 0x6F, 0xBE, 0xFD, 0x02, 
	0x66, 0xE5, 0xF7, 0x6A, 0x5B, 0xEF, 0x9E, 0x06, 
	0x3E, 0x14, 0xA8, 0xD5, 0xB3, 0x02, 0x0C, 0x04, 
	0xC0, 0x3E, 0x52, 0x40, 0x9F, 0xC1, 0x13, 0x3E, 
	0x51, 0xAE, 0x11, 0x04, 0x72, 0xEC, 0x9C, 0x36, 
	0x40, 0x9E, 0x63, 0x57, 0x14, 0xB2, 0x86, 0xD1, 
	0x06, 0xE3, 0x43, 0x79, 0x4A, 0xC6, 0xCA, 0x99, 
	0xC3, 0x4B, 0x92, 0xA1, 0x21, 0x49, 0xF5, 0xE0, 
	0xE2, 0x65, 0xAB, 0x81, 0xE6, 0xFE, 0x08, 0x4B, 
	0x4C, 0xAC, 0xD0, 0x02, 0x8A, 0x35, 0x68, 0x04, 
	0x8C, 0x15, 0xD9, 0x97, 0x2E, 0x81, 0xEE, 0x1A, 
	0x6D, 0x44, 0x19, 0xD4, 0xD0, 0x48, 0x33, 0x92, 
	0x8C, 0x5C, 0x2C, 0x55, 0xD9, 0xB6, 0x02, 0x20, 
	0xF5, 0xD0, 0xEF, 0x13, 0x71, 0x8F, 0xD4, 0x71, 
	0xB3, 0xBB, 0xA9, 0x7B, 0xFA, 0x56, 0xA6, 0x31, 
	0x44, 0xC2, 0xDD, 0xF1, 0xC3, 0xFF, 0x64, 0x9B, 
	0xDF, 0x3A, 0xC3, 0x00, 0x0B, 0x1B, 0xD5, 0xEA, 
	0x74, 0xE4, 0x11, 0xF0, 0x07, 0x86, 0xB0, 0xC4, 
	0xC7, 0x65, 0xBB, 0x9E, 0x6A, 0xCA, 0x77, 0xDF, 
	0xB0, 0xF2, 0x29, 0x9C, 0x02, 0x08, 0x2F, 0xE0, 
	0x55, 0xFD, 0xAE, 0xF3, 0x79, 0xED, 0xA3, 0x4B, 
	0x8D, 0x2E, 0x75, 0x85, 0xC1, 0xF0, 0x56, 0xFD, 
	0x03, 0x25, 0x75, 0x05, 0x2D, 0x22, 0xEA, 0xBB, 
	0x02, 0x58, 0x34, 0xDE, 0xD7, 0x17, 0xDF, 0x98, 
	0x10, 0xF1, 0x56, 0x1C, 0xCF, 0x9F, 0x21, 0x7C, 
	0x99, 0x50, 0xCC, 0x70, 0x41, 0xB9, 0x1E, 0x44, 
	0x0B, 0xEE, 0x05, 0x56, 0x6D, 0x61, 0xDF, 0xA1, 
	0xFE, 0x8D, 0x55, 0x5E, 0x20, 0xD6, 0x6A, 0x2B, 
	0xD8, 0xEF, 0x9E, 0x32, 0x52, 0x31, 0xCF, 0xA0, 
	0xE2, 0x4F, 0x29, 0xA6, 0x80, 0xB5, 0x87, 0x3F, 
	0xB9, 0x19, 0xEA, 0xFD, 0x70, 0xD8, 0xB5, 0xB9, 
	0xC8, 0xC9, 0xC4, 0x55, 0xCD, 0xFA, 0xFF, 0x28, 
	0x47, 0xB0, 0x16, 0xC9, 0x91, 0x1F, 0xCD, 0x98, 
	0x9C, 0xD6, 0x7C, 0xB0, 0x1A, 0xF1, 0xF9, 0xA7, 
	0xD8, 0xB3, 0xCD, 0x5C, 0x68, 0xE4, 0xDC, 0xE5, 
	0x8F, 0x42, 0x76, 0x13, 0xAD, 0xAC, 0xC7, 0x64, 
	0xE7, 0x82, 0x6B, 0xF3, 0x7C, 0x15, 0xBB, 0x45, 
	0x56, 0xB2, 0xCD, 0x32, 0xA0, 0x59, 0xAB, 0xF7, 
	0x30, 0x6F, 0x26, 0xC7, 0x34, 0xA7, 0xDC, 0x7B, 
	0xA6, 0x7B, 0xEE, 0xF6, 0x2E, 0xAA, 0xE1, 0xC0, 
	0xFE, 0x65, 0x2E, 0xA0, 0xF0, 0x40, 0x0C, 0xB2, 
	0x66, 0x16, 0x7D, 0x80, 0xBE, 0x63, 0x94, 0x32, 
	0x50, 0x0E, 0x3A, 0x7D, 0x62, 0xF3, 0x80, 0x8F, 
	0xF7, 0x34, 0xE9, 0xC2, 0x4C, 0xA3, 0xBF, 0xAF, 
	0x09, 0x0E, 0xD3, 0xD7, 0x6D, 0x0F, 0x3B, 0xA5, 
	0x3E, 0x00, 0x8C, 0xFC, 0xDF, 0xCB, 0x00, 0x35, 
	0x4D, 0xF9, 0x05, 0xE7, 0xB0, 0x6D, 0xD5, 0x8C, 
	0x67, 0xBB, 0x83, 0x78, 0x34, 0x6F, 0x39, 0xFF, 
	0xBD, 0x12, 0x60, 0xC5, 0xBF, 0x0D, 0xC9, 0x8E, 
	0x7B, 0x67, 0xC0, 0xAE, 0x67, 0xE0, 0x94, 0x12, 
	0x13, 0xF9, 0x75, 0x47, 0x14, 0xB4, 0xF6, 0xC4, 
	0xD1, 0x3B, 0x4A, 0xA1, 0x6E, 0x54, 0xF5, 0xE3, 
	0x3D, 0xAB, 0xFD, 0xAC, 0xB0, 0xF2, 0x46, 0x9E, 
	0xA3, 0x48, 0x32, 0x45, 0x0E, 0xAF, 0x4F, 0x48, 
	0xC1, 0x23, 0x83, 0x3F, 0x6E, 0xD1, 0x88, 0x4B, 
	0x8D, 0xEA, 0xCF, 0x7A, 0x0F, 0x54, 0xD9, 0x1C, 
	0x4D, 0x98, 0xE2, 0x10, 0xBB, 0x4A, 0x28, 0x14, 
	0x24, 0x7C, 0x56, 0x87, 0x9F, 0x3A, 0x87, 0x4F, 
	0xC1, 0x69, 0xBE, 0x51, 0xD8, 0xB2, 0x4D, 0x8F, 
	0x24, 0xCD, 0x72, 0x9D, 0x01, 0x1A, 0x8B, 0xD4, 
	0x4C, 0x42, 0xBB, 0x40, 0xAA, 0x4A, 0x25, 0xBE, 
	0x07, 0x29, 0x69, 0x6D, 0x5D, 0x46, 0x41, 0x3F, 
	0x9C, 0xE7, 0x41, 0x1D, 0x8F, 0xAF, 0xF1, 0x96, 
	0x50, 0x9A, 0x6E, 0x67, 0x57, 0xBD, 0x24, 0xCE, 
	0xFF, 0x6B, 0x10, 0x94, 0xDC, 0x13, 0x2C, 0x0F, 
	0xE1, 0x6E, 0x9C, 0xEC, 0x8C, 0x5A, 0x39, 0x70, 
	0xB6, 0x4F, 0xEE, 0xCE, 0x54, 0x8C, 0x1B, 0xF7, 
	0x80, 0x29, 0x87, 0x44, 0x4A, 0xA2, 0xD0, 0x0E, 
	0x98, 0x2C, 0x9C, 0x9E, 0xD3, 0x95, 0xEA, 0x13, 
	0x1C, 0x59, 0xB8, 0xD1, 0x75, 0x62, 0x86, 0xFD, 
	0xD7, 0x76, 0xAC, 0xFF, 0x30, 0x4A, 0xC3, 0x01, 
	0x24, 0x25, 0xE1, 0x97, 0x65, 0xAA, 0x0F, 0xFF, 
	0x8A, 0x41, 0x60, 0x9B, 0xBB, 0xD8, 0xEB, 0x61, 
	0x14, 0xCB, 0x89, 0x0F, 0x3A, 0xAC, 0xD3, 0x51, 
	0x33, 0x1C, 0xBA, 0x9B, 0x44, 0x71, 0x6F, 0xB1, 
	0x36, 0x11, 0x35, 0x59, 0xC0, 0x57, 0xB8, 0x15, 
	0x43, 0xB9, 0x68, 0xCF, 0x61, 0x4E, 0x97, 0x9B, 
	0x2D, 0xB1, 0x54, 0xB7, 0x40, 0x8D, 0xCB, 0x41, 
	0x5D, 0x7E, 0x62, 0xBB, 0x91, 0x0A, 0x99, 0xDC, 
	0x17, 0xAB, 0x78, 0x3D, 0x08, 0x50, 0x80, 0x62, 
	0x72, 0xFF, 0xB9, 0xCB, 0x46, 0xA8, 0x63, 0x31, 
	0xE8, 0xFC, 0xFF, 0xB6, 0x01, 0x6E, 0x65, 0xC0, 
	0xB3, 0x92, 0xDC, 0x6E, 0x2F, 0x4E, 0x1C, 0x53, 
	0x12, 0xB3, 0xBB, 0x32, 0xA6, 0xD1, 0x0C, 0x3B, 
	0x65, 0xFA, 0x7D, 0x1D, 0x35, 0x10, 0x2D, 0xA0, 
	0xEA, 0x8A, 0xFC, 0xB2, 0x7C, 0xB9, 0x15, 0xDF, 
	0x6B, 0xA6, 0x4A, 0x18, 0xAD, 0xE9, 0x37, 0xC0, 
	0x1F, 0x13, 0xB9, 0x83, 0x93, 0x30, 0xF1, 0xE9, 
	0xF0, 0x09, 0xAF, 0xC3, 0x45, 0x3C, 0x04, 0x1B, 
	0xFD, 0x1E, 0x34, 0xB8, 0x28, 0x8D, 0x5B, 0xEF, 
	0x39, 0x9F, 0xE9, 0xA7, 0x71, 0x5E, 0xDD, 0x4C, 
	0x17, 0xB9, 0xE1, 0xB7, 0x7E, 0x20, 0x3A, 0xA0, 
	0xFE, 0x60, 0xCF, 0xEC, 0x0A, 0x55, 0xC3, 0x81, 
	0xFE, 0xF8, 0xE5, 0x7E, 0x66, 0x2B, 0x9B, 0x62, 
	0x8B, 0x85, 0xFD, 0x44, 0x02, 0x18, 0x59, 0xCA, 
	0x19, 0xC7, 0xA6, 0x9C, 0x43, 0x49, 0xAC, 0xD7, 
	0xB1, 0x6F, 0xFF, 0x08, 0xFE, 0x51, 0x52, 0xED, 
	0x2E, 0x82, 0xA5, 0x7A, 0x99, 0xB3, 0x5F, 0x98, 
	0x41, 0xE9, 0xF7, 0x06, 0xC5, 0xEB, 0x8C, 0x3E, 
	0x80, 0x36, 0xCB, 0x33, 0xDD, 0x41, 0xBC, 0x5B, 
	0x77, 0x55, 0xF9, 0x78, 0x91, 0xEB, 0xB6, 0x0B, 
	0xD1, 0xE2, 0x6F, 0xD8, 0xDA, 0x1E, 0x31, 0x01, 
	0xFB, 0x25, 0x91, 0xC3, 0xC5, 0x0A, 0xA3, 0x8E, 
	0x16, 0x1C, 0x85, 0xE1, 0x39, 0x9A, 0xCB, 0x58, 
	0x76, 0x24, 0x8E, 0x35, 0x34, 0x41, 0x48, 0xB1, 
	0x85, 0x11, 0x77, 0x38, 0x7B, 0x6E, 0xEC, 0xA6, 
	0xFB, 0xE9, 0x37, 0x38, 0x21, 0x64, 0x8A, 0xE3, 
	0x83, 0x53, 0x03, 0x84, 0x4B, 0xFC, 0xFF, 0xF7, 
	0x08, 0xD7, 0x8B, 0xD4, 0x28, 0x63, 0x3F, 0xB6, 
	0xF7, 0x86, 0x82, 0x0E, 0xD5, 0x16, 0xDE, 0x93, 
	0x9B, 0x49, 0xC3, 0xB3, 0xD9, 0xFC, 0x82, 0x65, 
	0x36, 0x6D, 0x96, 0x89, 0xF4, 0xAA, 0xDB, 0xC7, 
	0xF4, 0x17, 0x84, 0xFF, 0x19, 0xF5, 0x6C, 0x62, 
	0xB1, 0x04, 0xD8, 0xA9, 0xAC, 0x58, 0x2C, 0xD2, 
	0xE9, 0x0F, 0x60, 0xF0, 0xA6, 0x4E, 0x2E, 0x7E, 
	0x9E, 0x4D, 0x66, 0x00, 0xF0, 0x63, 0x5B, 0xD3, 
	0x44, 0xC3, 0x9C, 0xA7, 0xAE, 0x46, 0x18, 0x08, 
	0x13, 0x3E, 0x72, 0x56, 0x93, 0xCA, 0x36, 0xB8, 
	0xCF, 0x81, 0x63, 0x04, 0xCB, 0x4A, 0xC0, 0xFE, 
	0x54, 0x38, 0x89, 0xC6, 0x69, 0x41, 0x23, 0x53, 
	0x12, 0x91, 0x42, 0xA9, 0xA9, 0xAD, 0x2A, 0x7C, 
	0xA6, 0x4F, 0x71, 0xCD, 0x1C, 0xE9, 0xE5, 0xA8, 
	0xDB, 0x36, 0xC0, 0xB8, 0x6B, 0x3D, 0x47, 0x19, 
	0xE4, 0x66, 0xDD, 0x18, 0xEC, 0x8E, 0x3F, 0x21, 
	0xC7, 0xD6, 0x8E, 0x49, 0x80, 0x97, 0xE7, 0x91, 
	0x60, 0xE6, 0x6B, 0x8E, 0x29, 0x55, 0xE6, 0xDC, 
	0xB8, 0x86, 0x71, 0x10, 0x78, 0x2B, 0x93, 0xBC, 
	0x01, 0x94, 0x1D, 0x8D, 0x15, 0xE9, 0x81, 0x56, 
	0x24, 0x01, 0x42, 0x5C, 0xFF, 0x78, 0xAD, 0xC1, 
	0xF7, 0x61, 0x01, 0x2E, 0x88, 0xBA, 0x65, 0x1F, 
	0x9B, 0xD6, 0xAF, 0x66, 0xEF, 0x22, 0x4C, 0x9D, 
	0xE2, 0x56, 0x5E, 0x47, 0x37, 0x53, 0x3B, 0x1F, 
	0x66, 0x23, 0xA2, 0x48, 0xC1, 0x91, 0xA1, 0x04, 
	0x81, 0x42, 0xE1, 0xE8, 0xA5, 0xFF, 0x2D, 0x7C, 
	0x6B, 0x2C, 0x4C, 0x53, 0x90, 0x69, 0xBC, 0xAC, 
	0xD9, 0x1E, 0x5F, 0xAE, 0xA0, 0xFC, 0x59, 0x88, 
	0x2D, 0x35, 0x52, 0x52, 0x79, 0xBC, 0x5C, 0xB7, 
	0x4F, 0xAF, 0xCF, 0xA0, 0xCD, 0xFD, 0x50, 0x63, 
	0x81, 0xDB, 0x9F, 0x78, 0x7C, 0x0D, 0x00, 0x62, 
	0x3C, 0xD9, 0xF7, 0x24, 0x35, 0x84, 0xBE, 0x70, 
	0x74, 0x94, 0x83, 0x6D, 0x6B, 0x4E, 0x50, 0xCC, 
	0x22, 0x5E, 0x17, 0xF2, 0x98, 0xE5, 0x15, 0xE9, 
	0x68, 0x02, 0x4E, 0xB2, 0x46, 0x93, 0x5B, 0xB6, 
	0x8A, 0xFE, 0xA0, 0xD4, 0x7E, 0x9E, 0xB3, 0x0C, 
	0x10, 0x5C, 0xCF, 0x9D, 0x57, 0xFF, 0x42, 0x56, 
	0xDD, 0xE4, 0x80, 0xED, 0xF2, 0x75, 0xA1, 0xC2, 
	0xD5, 0xB4, 0xDE, 0x51, 0xD9, 0x7B, 0x2B, 0xF8, 
	0xCA, 0x86, 0x46, 0xA7, 0xE3, 0x7B, 0x6C, 0xE7, 
	0x06, 0x94, 0x52, 0x91, 0x12, 0x58, 0x9F, 0x85, 
	0x6E, 0xBA, 0xDF, 0xBB, 0xD2, 0x2C, 0x02, 0xA9, 
	0x41, 0xE1, 0xA7, 0xFC, 0x08, 0xA9, 0xDE, 0x42, 
	0x28, 0x9B, 0x97, 0x14, 0x98, 0x53, 0xFA, 0x16, 
	0x96, 0x02, 0xFD, 0x93, 0x35, 0x96, 0xA7, 0x73, 
	0x53, 0x61, 0x16, 0x55, 0x5A, 0x92, 0xB6, 0xD8, 
	0x6D, 0x45, 0x90, 0xAF, 0xEA, 0x74, 0x51, 0xE5, 
	0x54, 0x95, 0xF6, 0xAC, 0xE7, 0xA3, 0xCC, 0x9B, 
	0x84, 0x34, 0xF0, 0x66, 0x67, 0x47, 0x25, 0xFD, 
	0xC0, 0xED, 0xC0, 0x49, 0x44, 0x18, 0xFA, 0x6C, 
	0xD5, 0x3F, 0x6E, 0x33, 0x6F, 0x6F, 0x3F, 0x86, 
	0xA8, 0xC5, 0x99, 0xD1, 0x41, 0xE0, 0xEB, 0xCC, 
	0x71, 0x2A, 0x04, 0xE5, 0x53, 0x69, 0xFF, 0x5D, 
	0x5A, 0x88, 0xCE, 0xBF, 0xFE, 0x2A, 0xEB, 0x29, 
	0x31, 0x86, 0xAA, 0xA9, 0x2C, 0x20, 0x55, 0xC3, 
	0x57, 0x08, 0x9D, 0xBD, 0xD2, 0xF3, 0x1D, 0x63, 
	0x65, 0x32, 0x84, 0xF9, 0x0A, 0xBA, 0x7C, 0xA5, 
	0x49, 0xA5, 0xF3, 0x8E, 0x14, 0xF5, 0xDA, 0x0D, 
	0x8B, 0xFA, 0xF1, 0x26, 0x92, 0xE3, 0xA0, 0x2E, 
	0x0A, 0x84, 0x30, 0x69, 0x8F, 0xBF, 0x83, 0xC1, 
	0x6E, 0x8F, 0x8F, 0x89, 0xD8, 0x9C, 0xE3, 0x53, 
	0x7A, 0x24, 0x05, 0x94, 0x42, 0x01, 0x8E, 0x57, 
	0x9E, 0x85, 0xE1, 0x29, 0xF8, 0x39, 0xE4, 0x2E, 
	0x53, 0xDF, 0x89, 0x52, 0x15, 0xA1, 0x9B, 0xFE, 
	0xE0, 0x2D, 0x51, 0x37, 0x55, 0xE2, 0xAF, 0xC5, 
	0x96, 0x13, 0xB0, 0x2C, 0xC0, 0x9F, 0xC3, 0x5F, 
	0xA4, 0x5B, 0x8A, 0xE7, 0xE8, 0x96, 0xA1, 0x51, 
	0x82, 0xA5, 0x40, 0xF5, 0x80, 0x5A, 0xCB, 0xFD, 
	0x0B, 0x9A, 0x7B, 0xEB, 0x6A, 0xD8, 0x17, 0xFF, 
	0x05, 0xEC, 0xF2, 0xCA, 0x00, 0x6C, 0x68, 0x2D, 
	0x39, 0x52, 0x2D, 0x4D, 0x55, 0x7F, 0xAB, 0xBE, 
	0xA3, 0x65, 0xE6, 0xD5, 0x93, 0xFC, 0x92, 0xC8, 
	0x51, 0x8B, 0xA6, 0x1A, 0xD1, 0xD0, 0xD7, 0xBB, 
	0xE1, 0x01, 0x10, 0xDC, 0xB5, 0xEE, 0x81, 0x30, 
	0x33, 0x74, 0x65, 0x40, 0x9C, 0x67, 0x9A, 0x2D, 
	0xD3, 0x41, 0x06, 0x8F, 0xC4, 0xC6, 0x1F, 0xAB, 
	0xFE, 0xB6, 0x2F, 0x30, 0xAE, 0x98, 0xD1, 0x23, 
	0x8B, 0xDC, 0x55, 0x06, 0xF4, 0x36, 0x84, 0x99, 
	0xD8, 0xF7, 0x7D, 0x97, 0x43, 0xC5, 0x48, 0x83, 
	0x2D, 0x5F, 0xDF, 0x49, 0x33, 0x21, 0xB4, 0x80, 
	0xB6, 0x4D, 0xA9, 0xEA, 0x39, 0xC2, 0x82, 0x60, 
	0x41, 0x96, 0xEE, 0xA4, 0x9A, 0x56, 0x1F, 0x3D, 
	0xD0, 0x43, 0x78, 0xAB, 0xAB, 0x8E, 0xFC, 0x25, 
	0x1E, 0x0C, 0x4B, 0xBF, 0xF8, 0x5B, 0x7C, 0x58, 
	0x90, 0x51, 0xBC, 0x46, 0x63, 0x1D, 0x04, 0xAC, 

	/* Database Page 2 */

	0xFF, 0x2E, 0xFA, 0x31, 0x90, 0xBC, 0xDC, 0xFF, 
	0xAE, 0xE0, 0x37, 0x8F, 0x53, 0x9B, 0x59, 0xC0, 
	0x59, 0xC3, 0xDD, 0x15, 0x14, 0x2C, 0x20, 0x6C, 
	0x88, 0xC5, 0x5C, 0xC9, 0x6D, 0x85, 0x2F, 0x96, 
	0x6E, 0xE1, 0x4D, 0xA7, 0xE6, 0xC1, 0xC9, 0x62, 
	0x1B, 0x02, 0xC6, 0x0B, 0x38, 0x6A, 0xBF, 0xD7, 
	0xEF, 0xBB, 0xCA, 0xD0, 0x20, 0xF1, 0x96, 0x32, 
	0x86, 0x56, 0x22, 0x49, 0x04, 0x51, 0xE7, 0xFA, 
	0x2D, 0x0B, 0x55, 0x1E, 0x82, 0xE6, 0x37, 0x1A, 
	0xDD, 0xE2, 0x61, 0x94, 0x61, 0x9F, 0x3F, 0x51, 
	0x20, 0x5E, 0x09, 0x13, 0x49, 0x05, 0x78, 0xF7, 
	0xDA, 0x65, 0xB1, 0x97, 0x08, 0x25, 0xF1, 0x15, 
	0x28, 0x19, 0xEE, 0x98, 0x9D, 0x41, 0xFC, 0x08, 
	0x96, 0xC6, 0xEE, 0x77, 0xFE, 0xB2, 0x21, 0x0D, 
	0x24, 0x17, 0xAC, 0x16, 0x13, 0x6A, 0x52, 0xF2, 
	0x29, 0x69, 0x48, 0x2F, 0x2E, 0x70, 0xF5, 0xC7, 
	0xC7, 0xFF, 0xA1, 0xFE, 0x57, 0x99, 0xCD, 0xCA, 
	0xCD, 0x33, 0x3F, 0xA4, 0x2D, 0x88, 0xC5, 0xBE, 
	0xA0, 0x0E, 0xBE, 0x88, 0x60, 0x8C, 0xEE, 0x54, 
	0x9B, 0xA6, 0x1E, 0x46, 0x69, 0xF9, 0x3A, 0x8C, 
	0x4E, 0x28, 0x28, 0x38, 0x94, 0x1F, 0x22, 0x6D, 
	0x4D, 0xE5, 0xAD, 0x7F, 0x09, 0x5C, 0x10, 0xBB, 
	0xA4, 0x1F, 0x49, 0xC9, 0xBC, 0xE3, 0x42, 0xBD, 
	0x67, 0x78, 0x99, 0x6C, 0x66, 0x62, 0x71, 0x99, 
	0xC8, 0x8B, 0xC6, 0x18, 0xB0, 0x5C, 0x87, 0xC3, 
	0xA4, 0xC9, 0x32, 0x4A, 0xD2, 0x81, 0x90, 0x4B, 
	0xA0, 0x05, 0xBD, 0x9C, 0x56, 0x33, 0x7E, 0x2A, 
	0x82, 0xC3, 0x79, 0x4A, 0xB8, 0x4E, 0x4B, 0xB7, 
	0xE1, 0x39, 0x5D, 0x27, 0xBB, 0xD2, 0x6F, 0x39, 
	0x74, 0xB4, 0xBB, 0xA6, 0x4D, 0x3B, 0xBE, 0x83, 
	0x72, 0x89, 0xE1, 0x14, 0x9F, 0xAB, 0x34, 0xF4, 
	0x22, 0x3B, 0x3F, 0xE8, 0x96, 0xDA, 0x6C, 0x09, 
	0xD4, 0x3A, 0xFF, 0xBC, 0xCD, 0xDC, 0x76, 0xB4, 
	0xE9, 0xE0, 0x72, 0x92, 0x3D, 0x5D, 0x63, 0x3A, 
	0x9C, 0x8D, 0x98, 0x3E, 0x85, 0x0C, 0x21, 0x89, 
	0x37, 0x66, 0x22, 0x80, 0x17, 0x9B, 0x95, 0x83, 
	0x76, 0xA6, 0x1A, 0x55, 0x88, 0xBD, 0xCB, 0x7B, 
	0x40, 0x0B, 0x94, 0xAF, 0x29, 0x8D, 0x4E, 0x39, 
	0xE3, 0x61, 0xC1, 0x06, 0xD3, 0xEB, 0xDE, 0x20, 
	0x6B, 0x8F, 0x13, 0xA0, 0x88, 0xEA, 0x59, 0x24, 
	0xC5, 0x0D, 0x12, 0xA0, 0x42, 0x27, 0x87, 0x72, 
	0xF0, 0x42, 0x36, 0x30, 0xCB, 0x49, 0xBB, 0xC3, 
	0xEB, 0x4D, 0xF2, 0xCE, 0x9D, 0x0B, 0xC3, 0x2C, 
	0x2C, 0x2A, 0xC7, 0x2B, 0xEC, 0x26, 0x53, 0x4C, 
	0xE6, 0xA1, 0x1E, 0x27, 0x34, 0x96, 0x04, 0x49, 
	0xA1, 0x96, 0xCD, 0xA3, 0x7B, 0x41, 0x30, 0xC6, 
	0x73, 0xBF, 0x7F, 0xBC, 0xD0, 0x07, 0x10, 0xDB, 
	0x53, 0x94, 0x39, 0xF9, 0x52, 0xDF, 0x0E, 0xE8, 
	0xF0, 0xF7, 0x31, 0xFF, 0xA1, 0x41, 0xC9, 0xFD, 
	0x0F, 0x1F, 0x98, 0x55, 0x71, 0x98, 0x26, 0x10, 
	0x53, 0xB6, 0x5E, 0x72, 0x07, 0xE4, 0xAB, 0x26, 
	0xF4, 0x9C, 0xD8, 0xBF, 0x61, 0x42, 0x25, 0xF2, 
	0xCD, 0xA1, 0x22, 0x51, 0xFF, 0xC7, 0xEA, 0x0C, 
	0xD3, 0xB3, 0x57, 0xD3, 0x10, 0xCC, 0xAC, 0xBD, 
	0xCF, 0x03, 0x28, 0xBE, 0xED, 0x8F, 0x86, 0x6A, 
	0xF7, 0xD7, 0x00, 0x0F, 0xA9, 0x34, 0x0C, 0xAA, 
	0x06, 0xF7, 0x5C, 0xF3, 0x74, 0x79, 0x2B, 0x18, 
	0x32, 0x9E, 0x86, 0xFE, 0x5C, 0x98, 0x40, 0x19, 
	0x8A, 0x0D, 0xF1, 0x9D, 0x54, 0xE0, 0x97, 0xD4, 
	0xD6, 0x42, 0x35, 0xF6, 0x98, 0xDC, 0x7A, 0xC3, 
	0xA7, 0x0E, 0xB0, 0x5D, 0x19, 0xE3, 0xA6, 0xEB, 
	0x24, 0xB2, 0xFF, 0xDA, 0x46, 0x1E, 0x2B, 0x63, 
	0xF3, 0x15, 0x4C, 0xEC, 0xC9, 0x3E, 0x7F, 0x2B, 
	0x15, 0x4B, 0x75, 0x2D, 0xD9, 0x05, 0x8C, 0xE6, 
	0x8E, 0xCB, 0xC4, 0xF4, 0xFF, 0xF7, 0xC8, 0x56, 
	0xC9, 0x6F, 0x9A, 0xE7, 0xC8, 0x47, 0xFC, 0x0F, 
	0xBB, 0x02, 0xC5, 0x91, 0xEC, 0x47, 0xC2, 0x8D, 
	0x1A, 0x50, 0x89, 0xB9, 0x56, 0xAA, 0x91, 0x8E, 
	0x36, 0x27, 0x7F, 0x8C, 0xEC, 0x97, 0x8E, 0x20, 
	0x2D, 0x2D, 0x88, 0xF3, 0x44, 0x4D, 0x39, 0x63, 
	0x4E, 0x52, 0x0A, 0x20, 0x8E, 0x87, 0x4F, 0xD1, 
	0x6C, 0x6A, 0x30, 0xAB, 0xFB, 0xDC, 0x82, 0x96, 
	0xCC, 0x0F, 0xE7, 0x4A, 0x09, 0x7A, 0xCC, 0x3E, 
	0x10, 0x46, 0xBA, 0x8A, 0x11, 0x04, 0x75, 0xA2, 
	0x29, 0x66, 0x47, 0xAA, 0x08, 0x10, 0xBC, 0xB2, 
	0x4C, 0x01, 0xA6, 0x97, 0x75, 0xE9, 0x13, 0x40, 
	0xC7, 0xCD, 0x10, 0x70, 0x2F, 0x46, 0x33, 0x12, 
	0x47, 0xEA, 0x1A, 0x2D, 0xE4, 0x70, 0x61, 0x64, 
	0xF3, 0x6B, 0xA5, 0xF1, 0xED, 0xAE, 0xE1, 0xED, 
	0x9E, 0x5F, 0x3A, 0xC5, 0x36, 0x32, 0x5D, 0xBD, 
	0x8E, 0x25, 0x5D, 0x3A, 0x16, 0xFF, 0x5B, 0x09, 
	0x6F, 0xB8, 0x88, 0x64, 0x95, 0xC8, 0x4D, 0x3F, 
	0x5E, 0x1C, 0x11, 0xEB, 0x93, 0xCA, 0xD7, 0x0A, 
	0x5C, 0x99, 0x71, 0xD9, 0x1A, 0x84, 0x98, 0x78, 
	0xC4, 0xB1, 0xCA, 0x8A, 0xB4, 0x7F, 0x09, 0x7C, 
	0x30, 0x78, 0x5C, 0x70, 0x61, 0x43, 0xB2, 0x0E, 
	0xFB, 0xA2, 0x56, 0xF9, 0x93, 0x68, 0x26, 0x6C, 
	0x3C, 0x47, 0x8D, 0xC0, 0xA4, 0x8E, 0x3B, 0xAB, 
	0x0B, 0x31, 0xE7, 0x02, 0x15, 0x6D, 0xE7, 0xAD, 
	0xD5, 0xFF, 0x84, 0xBD, 0x81, 0xF2, 0x2B, 0xF1, 
	0xF5, 0xD2, 0x23, 0xD7, 0x6D, 0x7F, 0x56, 0x0E, 
	0xDD, 0xB2, 0x5F, 0x93, 0xE8, 0x8A, 0x85, 0xE2, 
	0x9C, 0x21, 0x2B, 0xAC, 0xF4, 0xA8, 0xFD, 0xCD, 
	0x0E, 0xBB, 0x96, 0xDA, 0x98, 0x0C, 0x8E, 0xC8, 
	0xDA, 0x97, 0x4D, 0x4D, 0xC6, 0x36, 0x46, 0xCD, 
	0x70, 0xA6, 0xB3, 0x19, 0x02, 0x0C, 0x06, 0x09, 
	0x39, 0x4B, 0x59, 0x10, 0x0C, 0xB0, 0xFF, 0x95, 
	0xDD, 0x08, 0xA1, 0x9E, 0x0F, 0xF3, 0x89, 0x6F, 
	0x37, 0xCB, 0x61, 0x50, 0x83, 0x1F, 0x91, 0x30, 
	0x86, 0xF4, 0x12, 0xB9, 0x4A, 0x62, 0x2F, 0xA4, 
	0xB8, 0x96, 0x92, 0x94, 0x0B, 0xDE, 0xA7, 0x4C, 
	0x0B, 0x18, 0x57, 0xE5, 0x96, 0x73, 0x6C, 0xB9, 
	0xDB, 0x50, 0xF6, 0x88, 0xF6, 0x6A, 0xF2, 0x0E, 
	0x2B, 0x8E, 0x8B, 0x68, 0xEF, 0x45, 0x2D, 0xEF, 
	0x12, 0xFD, 0xF2, 0xC3, 0x0E, 0x0E, 0x7D, 0x41, 
	0x26, 0x40, 0x57, 0x92, 0xB8, 0x75, 0xCE, 0x44, 
	0x1E, 0x59, 0xEE, 0xC8, 0x14, 0xBE, 0x8F, 0xF5, 
	0x49, 0x0D, 0x98, 0xDA, 0x5A, 0x55, 0x7A, 0xC3, 
	0x87, 0xAE, 0x08, 0xFF, 0x9A, 0x10, 0x6D, 0x0F, 
	0x8C, 0x30, 0xA9, 0x42, 0x58, 0x52, 0x6E, 0x97, 
	0x0D, 0x65, 0xAC, 0xC0, 0x2C, 0xB8, 0xEA, 0x82, 
	0xC3, 0x29, 0x0C, 0x27, 0x32, 0xF1, 0xBD, 0x84, 
	0xC8, 0x94, 0xEC, 0x26, 0x7A, 0xEB, 0x44, 0xFF, 
	0x15, 0x5D, 0xDC, 0x42, 0xCA, 0x48, 0x32, 0xD3, 
	0x3A, 0x04, 0x72, 0x71, 0xAD, 0x2D, 0x08, 0x49, 
	0x36, 0x66, 0x6C, 0xEC, 0x19, 0xB7, 0xAB, 0x48, 
	0xDC, 0x43, 0x26, 0x6D, 0xDA, 0x53, 0x96, 0xEB, 
	0x93, 0x90, 0xDC, 0xFB, 0x0F, 0xCA, 0xF3, 0x98, 
	0x31, 0xCB, 0xA8, 0xAC, 0x9C, 0x4B, 0xF1, 0xB8, 
	0x07, 0xF5, 0x9A, 0x9B, 0x26, 0xE4, 0x27, 0x6E, 
	0x1E, 0x01, 0xCB, 0xD1, 0xFA, 0x5C, 0xA1, 0x5C, 
	0x2E, 0x87, 0x6E, 0x11, 0x11, 0x4F, 0xCD, 0xB2, 
	0x6E, 0xDD, 0xA7, 0xBB, 0x3E, 0x92, 0xB8, 0xCF, 
	0x30, 0x4F, 0xF9, 0xC0, 0x68, 0x0A, 0x40, 0x5B, 
	0xA6, 0x0D, 0xBC, 0x12, 0xE6, 0xD1, 0x42, 0xB5, 
	0xDC, 0x74, 0x52, 0x8A, 0x83, 0x6C, 0x61, 0xBA, 
	0xD0, 0xC8, 0x6E, 0x79, 0x9B, 0x21, 0x9A, 0x12, 
	0xD2, 0xB0, 0xB4, 0x3C, 0x96, 0xA6, 0x82, 0x91, 
	0x3B, 0x06, 0xDD, 0x2A, 0x4B, 0xBB, 0x3B, 0xFB, 
	0xFF, 0x80, 0xB3, 0xD5, 0x2A, 0x2D, 0xF6, 0x9C, 
	0xFE, 0x6C, 0x60, 0xB4, 0x53, 0x3E, 0x3F, 0xC0, 
	0x3A, 0xF7, 0xB0, 0x67, 0x90, 0x22, 0x83, 0x0F, 
	0x5D, 0x19, 0xF7, 0x76, 0x82, 0x44, 0x27, 0x2C, 
	0x5C, 0xBD, 0xDF, 0x73, 0x5C, 0x7F, 0x00, 0x85, 
	0x7F, 0xE8, 0xDA, 0x46, 0x0A, 0x6A, 0x97, 0x38, 
	0x03, 0x34, 0x30, 0x43, 0x5C, 0x28, 0xCB, 0x85, 
	0x47, 0xF8, 0x09, 0xC6, 0x20, 0x78, 0xA1, 0xF9, 
	0xBC, 0x7D, 0x58, 0xF0, 0x7B, 0x1C, 0x44, 0xBE, 
	0x72, 0x69, 0x31, 0xF8, 0xB0, 0xB0, 0x1C, 0xAF, 
	0xEB, 0x67, 0x9C, 0x14, 0x96, 0xD8, 0x1C, 0xB7, 
	0xED, 0x18, 0x73, 0x2D, 0xD9, 0x3D, 0xD0, 0x97, 
	0xEA, 0xEF, 0xAC, 0xB1, 0xA3, 0x37, 0xA9, 0xDE, 
	0x8F, 0xB7, 0x46, 0xA0, 0x97, 0x1E, 0x3F, 0xF8, 
	0x61, 0xA8, 0xEE, 0x83, 0xD0, 0x46, 0x3A, 0x17, 
	0x75, 0x07, 0x65, 0x33, 0x82, 0xB6, 0x2A, 0xEA, 
	0x6F, 0xFF, 0x3C, 0x8B, 0xE0, 0x36, 0x88, 0xD9, 
	0x80, 0xF1, 0x1E, 0x71, 0xAE, 0x0F, 0x51, 0xD0, 
	0x31, 0x65, 0x32, 0xFD, 0xE5, 0xC1, 0x08, 0x70, 
	0x9A, 0xDE, 0xF7, 0xD0, 0x45, 0x2A, 0xC1, 0xA0, 
	0x5E, 0xB0, 0xB9, 0x05, 0x87, 0x4C, 0x03, 0xE5, 
	0x5D, 0x48, 0x6C, 0x40, 0x93, 0x22, 0x68, 0x1E, 
	0x4C, 0xC3, 0xDE, 0xCC, 0x65, 0xA2, 0x27, 0x99, 
	0x73, 0x3B, 0x73, 0x4C, 0x8A, 0xF3, 0x58, 0x18, 
	0xB7, 0xDF, 0xD5, 0x3A, 0x76, 0xCC, 0xC5, 0x1F, 
	0x54, 0x64, 0xB1, 0xED, 0xFA, 0x02, 0x9F, 0x49, 
	0x2B, 0x76, 0x3B, 0xA0, 0x81, 0x3E, 0x02, 0x80, 
	0xC9, 0x92, 0x25, 0x94, 0x33, 0xC8, 0x36, 0xF7, 
	0x79, 0x86, 0xC0, 0x14, 0xED, 0x14, 0xB1, 0x81, 
	0xF5, 0x17, 0xCF, 0x71, 0xFC, 0xFB, 0x80, 0x0D, 
	0x54, 0x0F, 0x40, 0x5C, 0xFE, 0x9D, 0x9C, 0x84, 
	0x5C, 0x7D, 0xE4, 0x5B, 0xFF, 0x72, 0x27, 0x92, 
	0x53, 0xE3, 0xFF, 0xC3, 0xC6, 0x10, 0xF6, 0x3C, 
	0x28, 0xBC, 0x91, 0xEA, 0x20, 0xEC, 0xB0, 0xF7, 
	0xF4, 0xB0, 0x50, 0x73, 0x53, 0xF9, 0x1E, 0xBA, 
	0x71, 0x61, 0xD9, 0x28, 0x18, 0x89, 0x4D, 0x25, 
	0x39, 0x2D, 0x1E, 0x4C, 0xD9, 0x17, 0x4C, 0x54, 
	0xFB, 0x82, 0xD3, 0x2F, 0xD0, 0xFD, 0x7D, 0xA4, 
	0x67, 0x39, 0x29, 0x39, 0x44, 0x02, 0x62, 0x29, 
	0x0B, 0x34, 0x5D, 0x7A, 0xC6, 0x39, 0xE8, 0x91, 
	0x9C, 0xCD, 0x81, 0x70, 0xF9, 0x44, 0x24, 0xAB, 
	0xFE, 0xD3, 0xF0, 0x53, 0x0B, 0x6A, 0xE2, 0xA7, 
	0xC2, 0xD4, 0xC1, 0x39, 0xAD, 0x69, 0x34, 0x58, 
	0x6B, 0x07, 0x11, 0x89, 0xA5, 0x3E, 0x8D, 0x8D, 
	0xBE, 0x94, 0x57, 0xBD, 0xA1, 0xD4, 0xA5, 0x1A, 
	0xDE, 0xD2, 0xF7, 0xC3, 0x1A, 0x51, 0xAC, 0xBA, 
	0x53, 0x54, 0x35, 0x8F, 0x3E, 0xBA, 0x8F, 0xE7, 
	0x30, 0x22, 0xA3, 0x06, 0x83, 0xA6, 0x12, 0x48, 
	0x90, 0x94, 0x89, 0xFF, 0xB3, 0x42, 0x77, 0x65, 
	0xA2, 0xB1, 0x51, 0x3B, 0xB3, 0x05, 0xC4, 0xCE, 
	0x3D, 0x38, 0xC4, 0x86, 0x37, 0x8B, 0x47, 0x9E, 
	0x1D, 0xD0, 0x00, 0x4C, 0x2A, 0x7E, 0x67, 0x35, 
	0x4D, 0xBB, 0xB0, 0x7B, 0xEE, 0x1F, 0x75, 0x5F, 
	0x9F, 0xEC, 0x71, 0x4F, 0x3A, 0xD3, 0xB0, 0xAE, 
	0x97, 0x5E, 0x40, 0xD7, 0x50, 0x06, 0x81, 0x8C, 
	0x9A, 0xE9, 0x11, 0x82, 0xFE, 0xFE, 0x4B, 0x80, 
	0xC7, 0x01, 0x79, 0xAD, 0xE6, 0xA2, 0x2C, 0xAD, 
	0xC1, 0xE2, 0x3F, 0xA6, 0xB2, 0xF7, 0xEB, 0x1E, 
	0xB4, 0xA7, 0xAF, 0xC5, 0x5C, 0xA3, 0x64, 0xF6, 
	0x74, 0xCC, 0x78, 0x06, 0x85, 0x89, 0x1C, 0xF5, 
	0xF3, 0x26, 0x10, 0xA3, 0x38, 0x94, 0x91, 0xCC, 
	0xD4, 0xA1, 0x3E, 0x64, 0xA0, 0xA6, 0xF9, 0x73, 
	0xDC, 0x47, 0xD7, 0x72, 0xD6, 0x5A, 0xF0, 0xA3, 
	0x76, 0x15, 0x62, 0xC4, 0x32, 0x33, 0x1F, 0x92, 
	0xAC, 0x82, 0x1D, 0x08, 0xFF, 0x4B, 0x96, 0xF2, 
	0x5E, 0xAC, 0xC6, 0x37, 0xC8, 0xBA, 0xB2, 0xD8, 
	0x1E, 0xD2, 0xA6, 0x2E, 0xF8, 0x18, 0x40, 0xC3, 
	0xE3, 0xB5, 0x72, 0x9C, 0xD3, 0x32, 0x2F, 0xA4, 
	0x73, 0xFE, 0x82, 0x11, 0x3A, 0xBB, 0x74, 0x03, 
	0xE8, 0xA4, 0x20, 0x9F, 0x33, 0xDF, 0xAB, 0xD6, 
	0xD0, 0xA1, 0xAD, 0xD8, 0xB2, 0xDE, 0xD1, 0x2B, 
	0x4D, 0xB6, 0x2B, 0x89, 0x38, 0xF8, 0xFF, 0x83, 
	0x54, 0xBF, 0x0A, 0x49, 0xCF, 0xEA, 0x79, 0x25, 
	0xA6, 0x7C, 0x05, 0x4B, 0x3A, 0x67, 0xBF, 0x60, 
	0xC6, 0x65, 0x3F, 0xF5, 0x32, 0x2A, 0x43, 0xFF, 
	0xCD, 0xC0, 0x1B, 0xD2, 0xDC, 0xF0, 0xBF, 0xC0, 
	0x97, 0xD3, 0x2B, 0x6C, 0xE5, 0x64, 0xF7, 0x72, 
	0x9B, 0xAB, 0x54, 0x77, 0xC5, 0xAE, 0x9F, 0xAB, 
	0x57, 0x8D, 0x33, 0xE8, 0x3C, 0x30, 0xA7, 0x25, 
	0xDB, 0x61, 0xD0, 0x47, 0x5D, 0x64, 0x9C, 0x59, 
	0xBA, 0x8A, 0xE9, 0xC1, 0xEF, 0xFF, 0xE6, 0x9C, 
	0x5C, 0x83, 0x06, 0xE9, 0x5A, 0xD5, 0x29, 0x72, 
	0x9A, 0xC4, 0x66, 0x5A, 0xAB, 0xD0, 0x68, 0x14, 
	0xC4, 0xE2, 0x73, 0x6E, 0x28, 0xD6, 0x67, 0x14, 
	0x0C, 0x8A, 0x7E, 0x3B, 0x34, 0x28, 0x97, 0xB3, 
	0x99, 0x8A, 0xCA, 0x54, 0xD8, 0xA8, 0xD7, 0x58, 
	0x9F, 0x70, 0xA0, 0xE9, 0x6D, 0xA4, 0x7A, 0x6B, 
	0xB0, 0x15, 0x7A, 0xDD, 0x0C, 0x39, 0x25, 0x97, 
	0x25, 0xF0, 0x1E, 0x72, 0x41, 0x43, 0x95, 0xD8, 
	0x12, 0xCD, 0x72, 0x30, 0x66, 0xE9, 0xA9, 0x49, 
	0xEF, 0x5B, 0x04, 0x37, 0xC8, 0x34, 0x75, 0xC8, 
	0xCF, 0x2C, 0xDB, 0x41, 0x23, 0x1C, 0x04, 0x06, 
	0xF1, 0x75, 0x48, 0x02, 0xE4, 0xFD, 0xC4, 0x6C, 
	0x25, 0x76, 0x94, 0x2B, 0xD5, 0x5B, 0xD4, 0x6D, 
	0xF3, 0x14, 0x70, 0xB4, 0xEA, 0x8E, 0xB2, 0x25, 
	0xBA, 0x3C, 0x9E, 0xFD, 0x03, 0x12, 0xC6, 0x98, 
	0x6D, 0x91, 0xF3, 0x62, 0xC6, 0x0B, 0xFF, 0x24, 
	0x4C, 0xE9, 0xAE, 0xB8, 0x45, 0xC2, 0x01, 0xD9, 
	0x5B, 0x3F, 0x65, 0xEB, 0x06, 0x6C, 0x9E, 0xF0, 
	0x4C, 0x65, 0x37, 0xB2, 0x43, 0xF5, 0xC0, 0xBF, 
	0x0E, 0xC1, 0xB3, 0x9F, 0x98, 0xEF, 0x43, 0x8F, 
	0x03, 0x7F, 0x2C, 0x40, 0x79, 0xD9, 0xF6, 0x58, 
	0xAF, 0x9E, 0x45, 0x42, 0xEA, 0x61, 0x9B, 0x04, 
	0x25, 0x81, 0xF3, 0x1A, 0x1C, 0xC8, 0x4F, 0xB3, 
	0x24, 0xDD, 0xC1, 0xD5, 0x18, 0x39, 0xF1, 0xA4, 
	0x7F, 0xE4, 0xA6, 0x5B, 0xD4, 0x72, 0x69, 0x78, 
	0xB3, 0x44, 0xB5, 0xF0, 0x83, 0x10, 0x0C, 0x32, 
	0xE2, 0xEA, 0xFD, 0x24, 0x0D, 0x98, 0xF1, 0x84, 
	0x8E, 0x20, 0x40, 0x59, 0x67, 0xD8, 0xAD, 0x79, 
	0x4F, 0x3E, 0x49, 0x20, 0x63, 0x22, 0xF5, 0x4C, 
	0x4F, 0xB6, 0xCA, 0xE2, 0xE7, 0xC9, 0x80, 0xBA, 
	0x9B, 0x36, 0x6B, 0x21, 0x97, 0xDF, 0x0F, 0x3B, 
	0x7E, 0xDF, 0x1D, 0x75, 0x62, 0x56, 0x75, 0xFF, 
	0x3D, 0x5E, 0x9C, 0xA1, 0xD8, 0xC7, 0x68, 0xD7, 
	0x73, 0x84, 0xF9, 0xEE, 0x00, 0x34, 0xBF, 0xC8, 
	0x0C, 0xD6, 0xA6, 0xA2, 0x4C, 0xF6, 0xB4, 0xEF, 
	0x16, 0xF4, 0x8D, 0x09, 0x7B, 0x66, 0x65, 0x6A, 
	0xDB, 0x93, 0x54, 0x8B, 0x49, 0xEB, 0x7E, 0x73, 
	0xAC, 0x2C, 0x8A, 0x02, 0x32, 0x47, 0xA3, 0xFA, 
	0x3B, 0x6A, 0x10, 0xCB, 0xB9, 0xD9, 0x71, 0x06, 
	0x0F, 0xAA, 0x75, 0xDD, 0x0B, 0xA0, 0x2D, 0xDC, 
	0x64, 0xC7, 0xCE, 0xFC, 0xCA, 0x48, 0x69, 0xC2, 
	0x9A, 0xAB, 0x7A, 0xAB, 0x18, 0x20, 0xAB, 0x23, 
	0xD3, 0xBA, 0xF3, 0xCC, 0x4A, 0x82, 0x68, 0xCE, 
	0x73, 0x81, 0x8A, 0x43, 0x50, 0x41, 0xBD, 0x6F, 
	0xF3, 0x6B, 0x9C, 0x42, 0xCF, 0xC3, 0x19, 0x63, 
	0xEB, 0x47, 0x28, 0x8C, 0xC0, 0x3A, 0x87, 0x2E, 
	0x4E, 0x39, 0x2C, 0xDF, 0x24, 0xC2, 0x8C, 0x62, 
	0x38, 0x10, 0x49, 0x1A, 0x52, 0x00, 0xB7, 0xD6, 

	/* Database Page 3 */

	0xFF, 0x13, 0x58, 0x44, 0x0E, 0x14, 0xFD, 0xB2, 
	0x5C, 0x11, 0x1E, 0xBA, 0x24, 0xEB, 0xDF, 0xBB, 
	0x04, 0x2B, 0xF3, 0x52, 0xA5, 0x3F, 0x51, 0xC2, 
	0xC0, 0x15, 0xDB, 0x05, 0xBE, 0x49, 0xBC, 0xF3, 
	0x6E, 0x55, 0xB0, 0x96, 0xF8, 0xA1, 0xC5, 0x73, 
	0xBC, 0xDF, 0xBD, 0xEB, 0xDF, 0x27, 0x53, 0xE0, 
	0x79, 0xEE, 0xB8, 0x6E, 0xB2, 0x3C, 0x13, 0x67, 
	0x51, 0x66, 0xF9, 0xE9, 0x6D, 0x79, 0x66, 0xE5, 
	0x87, 0x85, 0x35, 0x33, 0xDB, 0xD8, 0x31, 0x2A, 
	0x2A, 0x36, 0x52, 0xF2, 0x15, 0x61, 0x14, 0x94, 
	0x6E, 0x63, 0x10, 0xCA, 0x56, 0xCE, 0x39, 0xA5, 
	0x8D, 0x27, 0x6E, 0x0A, 0x84, 0x12, 0xE3, 0xD4, 
	0xC8, 0xD9, 0x24, 0x1A, 0x7E, 0xE9, 0x9F, 0xA0, 
	0x4F, 0x82, 0x4B, 0x07, 0x0C, 0xED, 0x6F, 0xD1, 
	0x5F, 0x52, 0xDB, 0x72, 0x0E, 0xBD, 0x6C, 0x15, 
	0x86, 0x6B, 0x7E, 0x47, 0x45, 0x3E, 0x87, 0x25, 
	0xBE, 0xFF, 0x62, 0x9E, 0xCC, 0xC5, 0xDC, 0x03, 
	0x49, 0xD7, 0x04, 0x04, 0x06, 0x01, 0x64, 0xA3, 
	0xC2, 0x80, 0x7A, 0x92, 0xB7, 0xE7, 0x42, 0xD6, 
	0xE5, 0xB4, 0xD5, 0x4A, 0xB4, 0xE4, 0xD9, 0xA0, 
	0x3E, 0x07, 0x5B, 0xB8, 0xFA, 0xA9, 0x7F, 0x0E, 
	0x08, 0x9B, 0x80, 0xC0, 0xB4, 0x10, 0xB9, 0xDF, 
	0x62, 0x5D, 0x8E, 0x23, 0x86, 0xFD, 0x1D, 0x5D, 
	0x14, 0xCF, 0xC5, 0xDB, 0x61, 0x58, 0xAB, 0xEB, 
	0x5D, 0xEB, 0xDB, 0xE8, 0x9B, 0x8B, 0x16, 0x96, 
	0x84, 0x99, 0x26, 0xF0, 0x6E, 0x56, 0x81, 0xCA, 
	0x31, 0x8C, 0xC1, 0xA9, 0x40, 0xA3, 0xE1, 0x21, 
	0x43, 0x10, 0x68, 0xE6, 0x91, 0xA2, 0xA8, 0xD2, 
	0xA4, 0xA3, 0x1E, 0xC4, 0x05, 0x3F, 0x81, 0x07, 
	0x7B, 0x28, 0x38, 0x90, 0x0D, 0xA8, 0x74, 0x7D, 
	0x49, 0x62, 0x80, 0x7A, 0x8C, 0xD4, 0x08, 0x1B, 
	0x30, 0x53, 0x6D, 0x17, 0x09, 0xFF, 0x7D, 0xFC, 
	0x47, 0x24, 0xFF, 0xA0, 0x64, 0xAB, 0x58, 0x26, 
	0x24, 0x1E, 0x87, 0x04, 0x90, 0x38, 0x47, 0x73, 
	0x99, 0x08, 0x58, 0x80, 0x79, 0xBF, 0xE4, 0xEF, 
	0xBF, 0x47, 0x59, 0x98, 0xD2, 0xCB, 0x30, 0xB0, 
	0x21, 0x6F, 0xD3, 0x89, 0x4A, 0xA8, 0x5F, 0x6C, 
	0x09, 0x5E, 0x01, 0x7E, 0xB6, 0x7D, 0x5D, 0xFA, 
	0x3E, 0x9B, 0xC8, 0x58, 0x5F, 0x6E, 0xB0, 0x79, 
	0x10, 0x4D, 0xCB, 0xE3, 0x05, 0x6E, 0xA0, 0x46, 
	0xA8, 0x5D, 0x66, 0x42, 0xA8, 0xE3, 0xE7, 0xD2, 
	0xCC, 0x64, 0x18, 0xAA, 0xC8, 0x7B, 0x13, 0x05, 
	0x20, 0x9E, 0x7B, 0xEA, 0x70, 0x94, 0xFC, 0xC7, 
	0xB5, 0x7D, 0xE8, 0xE4, 0xC7, 0x88, 0xDE, 0x17, 
	0x05, 0x3B, 0x8F, 0xE9, 0xA8, 0x26, 0x90, 0x10, 
	0xEE, 0x25, 0x24, 0x32, 0x64, 0x19, 0x04, 0x62, 
	0x93, 0x90, 0x07, 0x3C, 0x1D, 0x87, 0x1C, 0xC7, 
	0x05, 0xF2, 0x2A, 0x49, 0xFA, 0xDD, 0xFD, 0x12, 
	0xD7, 0xDB, 0xA1, 0xFF, 0x18, 0x4D, 0xD3, 0xCF, 
	0xFF, 0x00, 0x78, 0xFD, 0x46, 0xA9, 0xBE, 0x4B, 
	0x01, 0x8A, 0xDE, 0xE7, 0x70, 0x51, 0xE5, 0xAB, 
	0x1C, 0xEA, 0x37, 0xA8, 0x8E, 0xB6, 0x58, 0x28, 
	0x33, 0x90, 0x7B, 0x06, 0x37, 0xE4, 0x66, 0x18, 
	0x42, 0x0D, 0x31, 0x0C, 0x73, 0xE3, 0xBA, 0x37, 
	0x38, 0xF2, 0xBD, 0x32, 0x25, 0xD6, 0x14, 0x0B, 
	0xF0, 0x84, 0x02, 0xAA, 0x1F, 0xFB, 0x34, 0x74, 
	0xC0, 0x3D, 0x1A, 0xD4, 0xB2, 0x8F, 0x38, 0x6C, 
	0xAE, 0x29, 0xD0, 0x2D, 0x48, 0x8A, 0xA5, 0xD3, 
	0x20, 0x9C, 0x48, 0x20, 0x59, 0xF1, 0x45, 0x52, 
	0x23, 0x3C, 0x2E, 0xB1, 0xA2, 0x5F, 0xC1, 0x6A, 
	0xB8, 0xB8, 0x2A, 0xA7, 0x57, 0xCE, 0x68, 0xD9, 
	0xF3, 0x56, 0xC7, 0x81, 0x8E, 0xA5, 0x9B, 0x90, 
	0x70, 0x84, 0x40, 0x30, 0xDF, 0x0C, 0xBE, 0x64, 
	0x8D, 0xE2, 0x6C, 0xC1, 0x2C, 0xEC, 0xFF, 0xE1, 
	0x4B, 0x04, 0xFB, 0xF8, 0xFF, 0x18, 0x72, 0xBD, 
	0x2A, 0xFC, 0xEC, 0x9C, 0x56, 0x79, 0x38, 0xDB, 
	0x4E, 0x6C, 0xEC, 0x52, 0xD1, 0xCA, 0x6B, 0x2A, 
	0xC1, 0x73, 0xCC, 0x72, 0xA8, 0x6C, 0xF3, 0x70, 
	0x23, 0x37, 0x7A, 0x80, 0xF3, 0x8C, 0xFC, 0x82, 
	0x7D, 0x30, 0xE4, 0xD6, 0x3F, 0x67, 0x65, 0x16, 
	0x2A, 0xC3, 0x2B, 0x56, 0x20, 0x0A, 0x02, 0x1D, 
	0x40, 0x4F, 0xE5, 0x8A, 0x04, 0xA3, 0x68, 0x3C, 
	0x91, 0x7E, 0xAE, 0x14, 0x48, 0x1B, 0x13, 0x21, 
	0xA5, 0x88, 0xE7, 0x95, 0xB9, 0x4E, 0x14, 0xAC, 
	0x57, 0xF9, 0x38, 0xBA, 0x4C, 0x5C, 0xDA, 0x54, 
	0xFA, 0x41, 0xF8, 0x42, 0x05, 0xF2, 0x3C, 0x73, 
	0xD3, 0x0B, 0x7F, 0x7B, 0x98, 0x88, 0xFC, 0x18, 
	0x6E, 0x55, 0xBD, 0x1D, 0x7E, 0x65, 0xD5, 0x93, 
	0x15, 0x66, 0x1D, 0x9D, 0x18, 0x51, 0x7A, 0x7E, 
	0x15, 0x23, 0x65, 0xE7, 0xF3, 0x32, 0x7E, 0x4B, 
	0x55, 0xB6, 0x37, 0x7A, 0x12, 0xFF, 0xFF, 0xD7, 
	0x44, 0x5F, 0xA0, 0x44, 0x57, 0x16, 0x20, 0x91, 
	0x63, 0xD3, 0x06, 0x13, 0x60, 0xD5, 0xFB, 0x5A, 
	0x4A, 0x42, 0x1C, 0xC1, 0xB4, 0xA0, 0x13, 0x40, 
	0x32, 0x1A, 0x8B, 0xCB, 0x60, 0xEA, 0x77, 0x92, 
	0x9D, 0x7A, 0xB6, 0x2F, 0x76, 0x56, 0xFA, 0x9F, 
	0xF5, 0xEE, 0x78, 0xC4, 0x10, 0xC8, 0x95, 0x04, 
	0x8D, 0xE9, 0xF9, 0x82, 0x94, 0x3B, 0x87, 0x6D, 
	0x63, 0x48, 0x3A, 0xAE, 0x4C, 0x5E, 0x0B, 0x89, 
	0xE7, 0x94, 0x9F, 0xC7, 0x0E, 0x3E, 0xDE, 0x46, 
	0xCC, 0xED, 0x1D, 0xCF, 0x6A, 0x21, 0xBF, 0x7D, 
	0x76, 0x69, 0x47, 0xE1, 0xC4, 0x50, 0xF9, 0xE5, 
	0xE0, 0xDD, 0x20, 0x72, 0xFB, 0xC6, 0x66, 0x7F, 
	0x30, 0x27, 0x8D, 0x02, 0x9B, 0x49, 0x4F, 0x5E, 
	0x35, 0xF2, 0x80, 0x57, 0xED, 0xBF, 0x45, 0x90, 
	0x55, 0xB3, 0x59, 0xE5, 0x93, 0xE8, 0x46, 0x80, 
	0x2A, 0xD8, 0x80, 0x90, 0x08, 0x55, 0xFF, 0x59, 
	0x62, 0x4F, 0x48, 0x64, 0x9E, 0xCC, 0xD5, 0x57, 
	0x52, 0xB6, 0x4B, 0x5E, 0x2A, 0xCD, 0x7C, 0x82, 
	0xDC, 0x12, 0x82, 0x7B, 0x04, 0x5F, 0x20, 0x04, 
	0xC1, 0x5A, 0xFC, 0x97, 0xA6, 0x87, 0xA0, 0x50, 
	0x57, 0x7C, 0x70, 0x8A, 0xC2, 0xD4, 0x66, 0x91, 
	0xD9, 0xB0, 0x3C, 0x8C, 0x86, 0x04, 0xF7, 0xF2, 
	0x59, 0x61, 0x2E, 0x8A, 0xA4, 0x5F, 0x13, 0x97, 
	0xB9, 0x47, 0x8A, 0x66, 0xE1, 0xE7, 0x6B, 0x74, 
	0x87, 0x81, 0x6F, 0x84, 0x9B, 0x7A, 0x7B, 0xBF, 
	0x03, 0x3D, 0xD8, 0x5B, 0x9F, 0xCF, 0x72, 0xC1, 
	0x9E, 0x63, 0xEE, 0x80, 0x47, 0x07, 0x74, 0x71, 
	0x41, 0x7A, 0x15, 0xBA, 0xF2, 0xF0, 0x5A, 0x60, 
	0xF9, 0xB7, 0x93, 0x42, 0x40, 0x14, 0x34, 0xF6, 
	0x22, 0xA0, 0x4A, 0xFC, 0xED, 0x6B, 0xD2, 0x93, 
	0x36, 0x2D, 0xB2, 0x22, 0x10, 0xB7, 0xDE, 0x1B, 
	0x06, 0x81, 0x43, 0x73, 0xF9, 0x00, 0xC8, 0xFF, 
	0x26, 0x4D, 0x17, 0x3A, 0x36, 0x89, 0x01, 0xB9, 
	0xDC, 0x6D, 0xA2, 0x13, 0xB9, 0xCA, 0x05, 0x95, 
	0xCA, 0xC7, 0x99, 0x7E, 0x1E, 0x24, 0x37, 0xED, 
	0xBD, 0x4F, 0x60, 0x5D, 0x00, 0xEB, 0xEA, 0xE3, 
	0x55, 0x6F, 0x0B, 0x16, 0x98, 0xB9, 0xB8, 0xEA, 
	0x44, 0x6C, 0x11, 0x26, 0xE5, 0x23, 0xAC, 0xA2, 
	0x3A, 0x32, 0x8F, 0x43, 0x2A, 0xF7, 0x6B, 0x91, 
	0x93, 0x15, 0x03, 0x46, 0xED, 0xB2, 0xB7, 0x17, 
	0xAE, 0xBA, 0x54, 0xD6, 0x95, 0x1C, 0x21, 0x2F, 
	0x39, 0x95, 0xEA, 0xE3, 0x74, 0x30, 0x7D, 0x28, 
	0xC8, 0xA9, 0xA8, 0x36, 0xF1, 0xEA, 0x4B, 0x0E, 
	0xD7, 0xFE, 0x94, 0xD4, 0x16, 0x81, 0x48, 0x23, 
	0x33, 0xE3, 0x35, 0x54, 0xF6, 0x01, 0x54, 0x3D, 
	0x8B, 0xB2, 0xE3, 0x76, 0xB7, 0xE6, 0xDB, 0x97, 
	0xC6, 0x33, 0x6D, 0xB8, 0x30, 0x18, 0x8B, 0x11, 
	0x6C, 0x4A, 0x1E, 0x59, 0xF1, 0x23, 0x1F, 0xC2, 
	0xFF, 0x96, 0xB8, 0xF7, 0xAE, 0x0D, 0x0D, 0x37, 
	0x42, 0xE0, 0x58, 0xCB, 0x59, 0x45, 0xDC, 0x5F, 
	0x52, 0xE5, 0xB5, 0x57, 0x34, 0x9F, 0x54, 0x66, 
	0x94, 0xE1, 0xA0, 0xFD, 0xB8, 0xA3, 0xDD, 0x69, 
	0xDA, 0x67, 0xD7, 0x23, 0x97, 0xF6, 0xB8, 0x31, 
	0x7A, 0x24, 0xA8, 0x61, 0x78, 0x6B, 0xCD, 0x73, 
	0x94, 0x84, 0x81, 0x3C, 0xFB, 0x58, 0xDE, 0x24, 
	0x8B, 0x39, 0xD5, 0xB1, 0xAB, 0xAD, 0x21, 0x02, 
	0xB5, 0x5C, 0xB2, 0x9E, 0x57, 0x20, 0xA1, 0x34, 
	0x94, 0x99, 0x59, 0xC9, 0x34, 0xEE, 0x2A, 0x69, 
	0x37, 0x00, 0xE5, 0x55, 0xD5, 0x6D, 0xB6, 0xA4, 
	0x33, 0xD6, 0xD6, 0xD6, 0xD0, 0x86, 0x12, 0x0A, 
	0xF9, 0x8D, 0xCA, 0x57, 0x87, 0x52, 0xFA, 0x27, 
	0x21, 0xFC, 0x12, 0x8B, 0x3F, 0x17, 0xF1, 0xCF, 
	0x68, 0xDB, 0xEC, 0x1D, 0x94, 0xD4, 0xC4, 0xF9, 
	0x46, 0x66, 0x26, 0x86, 0xDD, 0x53, 0xD4, 0x18, 
	0xCF, 0xFF, 0x15, 0x83, 0xAF, 0x0A, 0x07, 0x17, 
	0xBB, 0x56, 0x9B, 0x60, 0x76, 0x8A, 0xF9, 0x8E, 
	0x45, 0xB0, 0xB1, 0x7D, 0xEE, 0x09, 0x6E, 0xAA, 
	0x5E, 0x32, 0xD7, 0x4B, 0x28, 0x36, 0x88, 0x54, 
	0x91, 0x6F, 0xE9, 0x55, 0xAD, 0x68, 0x0B, 0x7B, 
	0x34, 0xEE, 0xA6, 0x7A, 0x8B, 0x56, 0x74, 0x16, 
	0xD2, 0x6C, 0xB2, 0x97, 0x1F, 0x66, 0xDF, 0x45, 
	0x1C, 0x2F, 0xF7, 0x54, 0xEB, 0x61, 0x12, 0x79, 
	0x22, 0x7A, 0x60, 0x20, 0x05, 0x9C, 0xEB, 0x2C, 
	0x05, 0x55, 0x8B, 0x58, 0xCA, 0x0E, 0xE8, 0xAF, 
	0x77, 0xD5, 0x75, 0xB0, 0xB9, 0xF1, 0x1F, 0x5E, 
	0xA1, 0x17, 0x62, 0x22, 0x9C, 0x15, 0x19, 0x13, 
	0xAC, 0x6C, 0xFE, 0xCE, 0x27, 0x7B, 0x7F, 0x75, 
	0x8B, 0xF6, 0xC7, 0x91, 0xB8, 0xA9, 0xF7, 0xF5, 
	0x7B, 0x47, 0x24, 0x3F, 0x64, 0x98, 0xCF, 0x4F, 
	0xD3, 0x5E, 0xB3, 0xC0, 0x5A, 0x5B, 0x5D, 0x03, 
	0x56, 0x65, 0xFF, 0xD4, 0xCC, 0x5D, 0xCC, 0xCB, 
	0xA9, 0x4B, 0xAF, 0x6E, 0xED, 0x03, 0x8B, 0x4F, 
	0x97, 0x06, 0x4B, 0xC1, 0x44, 0x0D, 0xE0, 0x37, 
	0xF8, 0x1F, 0x55, 0x9A, 0x74, 0xB3, 0x9A, 0x12, 
	0x27, 0xA8, 0x3B, 0x7D, 0x29, 0x0A, 0xE2, 0x61, 
	0x7E, 0x74, 0x2F, 0x22, 0x77, 0xFB, 0x42, 0x36, 
	0x1F, 0x3B, 0xB5, 0x3F, 0x4B, 0x0E, 0x48, 0xA0, 
	0x7E, 0x6B, 0xB3, 0x48, 0xA0, 0x5D, 0x65, 0x61, 
	0x27, 0x74, 0xFD, 0x4E, 0x39, 0x85, 0xC6, 0x53, 
	0x29, 0x3B, 0x14, 0xC3, 0x53, 0x5D, 0x79, 0x6F, 
	0x8D, 0x64, 0x7A, 0x14, 0x87, 0x29, 0xEA, 0xD1, 
	0xA2, 0x51, 0xE8, 0xA1, 0x10, 0xE6, 0xD7, 0x27, 
	0xE3, 0x3D, 0xA6, 0xC5, 0xBA, 0xF3, 0xB9, 0x3D, 
	0xD9, 0xD0, 0x4E, 0xC9, 0x2A, 0x13, 0x74, 0x2A, 
	0xFF, 0x42, 0xD6, 0xF3, 0xC3, 0x26, 0x9D, 0xD3, 
	0x95, 0x81, 0x6F, 0xEC, 0xD0, 0x94, 0x3F, 0xFD, 
	0x27, 0x02, 0xB8, 0xFF, 0x98, 0x92, 0x89, 0x37, 
	0xA9, 0xC3, 0xF6, 0x1D, 0x6F, 0x64, 0xFB, 0x2B, 
	0xB3, 0xE3, 0x2C, 0xA5, 0x6E, 0x8A, 0x2F, 0x77, 
	0x9A, 0xB0, 0xFD, 0x5E, 0xD2, 0x61, 0xEE, 0xF0, 
	0x1D, 0xE8, 0x7F, 0xAF, 0x5B, 0x27, 0x9F, 0xB0, 
	0xAA, 0x2A, 0xE7, 0x92, 0x14, 0xC6, 0xE8, 0x75, 
	0xDB, 0x38, 0x9F, 0x6F, 0x2D, 0x0C, 0x1B, 0x71, 
	0x67, 0x60, 0xB3, 0x49, 0x04, 0x00, 0x9E, 0xEB, 
	0xF1, 0x36, 0xE2, 0x2D, 0x2E, 0xF1, 0xAB, 0x4F, 
	0xC0, 0xD2, 0x74, 0x9B, 0x0F, 0x43, 0x07, 0xAE, 
	0xA1, 0x70, 0xF7, 0x62, 0xC7, 0x96, 0x4A, 0x14, 
	0xF3, 0x0F, 0x56, 0xF3, 0xA4, 0x8B, 0x5F, 0x0F, 
	0x1D, 0x17, 0xA7, 0x7E, 0x8A, 0x27, 0x4E, 0x07, 
	0x43, 0x90, 0xA2, 0x2B, 0x7E, 0x79, 0x93, 0x87, 
	0xE2, 0xB4, 0x54, 0x4F, 0x90, 0xA9, 0x86, 0x1A, 
	0x60, 0xDA, 0x63, 0x3E, 0xC0, 0xEA, 0x19, 0xB0, 
	0x1E, 0xDF, 0xB1, 0x05, 0xFF, 0xDE, 0x31, 0xF0, 
	0x4F, 0x44, 0x30, 0x70, 0x1F, 0x8C, 0x7F, 0x2D, 
	0x0C, 0x02, 0x51, 0x9A, 0x43, 0xE5, 0x95, 0x5B, 
	0xE2, 0xD4, 0x8D, 0xCB, 0x81, 0x2B, 0x88, 0x39, 
	0x12, 0xCC, 0xAA, 0xFD, 0x22, 0x33, 0xF5, 0x7C, 
	0x0C, 0x05, 0xAB, 0x52, 0xA8, 0x25, 0x85, 0x14, 
	0x9D, 0xFB, 0x6F, 0xB3, 0xCA, 0x94, 0xB8, 0x61, 
	0x47, 0xBB, 0x87, 0xE7, 0xA2, 0x23, 0xC8, 0x09, 
	0x78, 0xC3, 0x87, 0x99, 0xDA, 0xA6, 0x87, 0xA4, 
	0xF5, 0x0B, 0x04, 0xAE, 0xD9, 0xE0, 0xE8, 0x63, 
	0x78, 0xD3, 0x2D, 0xE6, 0x3C, 0x0C, 0x0D, 0x69, 
	0xEA, 0x65, 0x53, 0x10, 0x1A, 0xA6, 0xD2, 0xA0, 
	0xC5, 0xA6, 0xAD, 0x58, 0x0D, 0x4A, 0x11, 0xF6, 
	0x93, 0x3F, 0x26, 0x5D, 0x7C, 0xB7, 0xE6, 0x6B, 
	0x40, 0x30, 0x03, 0xB9, 0x41, 0xF1, 0x58, 0x85, 
	0x0D, 0x1C, 0x75, 0xA9, 0x37, 0xDC, 0x92, 0x02, 
	0x16, 0x10, 0x99, 0x0E, 0xA7, 0xFF, 0x2B, 0x68, 
	0xF9, 0xD7, 0xC2, 0x3C, 0xCB, 0x06, 0x35, 0xD3, 
	0x48, 0xCA, 0xF2, 0x6B, 0x92, 0x3F, 0x83, 0xB7, 
	0x00, 0xEB, 0x0B, 0x14, 0x7D, 0xEB, 0x76, 0xF2, 
	0x56, 0x8A, 0xA0, 0xCD, 0xD9, 0x76, 0x13, 0xCB, 
	0xBF, 0x4A, 0x92, 0x50, 0x85, 0x89, 0x45, 0x6E, 
	0xA6, 0x21, 0x46, 0x07, 0x47, 0x79, 0x31, 0x91, 
	0xFE, 0x7C, 0x0A, 0x09, 0x6E, 0xD3, 0x68, 0xA9, 
	0xC2, 0x21, 0xE3, 0xBD, 0x5B, 0x4B, 0xA6, 0x1F, 
	0x57, 0xC9, 0x14, 0x26, 0xC7, 0x20, 0xA4, 0xB8, 
	0x8F, 0x7B, 0x3C, 0x3E, 0x1B, 0x61, 0xEA, 0xC2, 
	0x97, 0x88, 0xB5, 0xAE, 0x42, 0x79, 0xD5, 0xCB, 
	0xDD, 0xF1, 0x81, 0x6F, 0x2B, 0xD8, 0x5A, 0xAB, 
	0x83, 0x3D, 0x3B, 0xF5, 0xF6, 0xB2, 0xDC, 0xDF, 
	0x4C, 0xD0, 0x45, 0xF5, 0x79, 0x6F, 0x37, 0xB4, 
	0xCA, 0x5A, 0x6A, 0x7D, 0x86, 0xA6, 0x5F, 0x2A, 
	0xE1, 0x66, 0xB6, 0xD0, 0x73, 0xB0, 0xFF, 0x1F, 
	0x3E, 0xF4, 0xDC, 0x10, 0xEF, 0xB8, 0x8D, 0xF5, 
	0x54, 0x7F, 0xD5, 0x27, 0x2B, 0xF6, 0x64, 0xC1, 
	0x13, 0xCA, 0x47, 0xFF, 0x6B, 0xDA, 0xFC, 0x68, 
	0xA4, 0xB5, 0x0B, 0xC7, 0xEF, 0x2A, 0xE5, 0x54, 
	0xF0, 0x0E, 0xBB, 0xDE, 0xFB, 0xA3, 0x8E, 0xE3, 
	0x9A, 0xD6, 0x03, 0x4D, 0xD4, 0x59, 0xF4, 0x44, 
	0x97, 0x20, 0x6A, 0x0E, 0x88, 0x1E, 0x9A, 0xD3, 
	0xF2, 0x05, 0x0E, 0xDA, 0xFA, 0x3B, 0xDE, 0xCA, 
	0x09, 0x45, 0x27, 0x91, 0x33, 0xA0, 0x98, 0x13, 
	0xC8, 0x7D, 0x18, 0xD9, 0xD9, 0xCC, 0x08, 0x1C, 
	0x49, 0xE1, 0x49, 0x41, 0x71, 0x69, 0x0E, 0x81, 
	0x5C, 0xB9, 0x7B, 0x2A, 0xA5, 0xD0, 0x96, 0x3E, 
	0xF0, 0x03, 0xFB, 0xD6, 0x76, 0x8F, 0x2E, 0x2F, 
	0x65, 0x9B, 0x44, 0x8A, 0x45, 0xD3, 0xE8, 0xC3, 
	0x76, 0x92, 0x5F, 0xAE, 0x26, 0x94, 0x4C, 0xE3, 
	0x62, 0xAB, 0x3B, 0x1E, 0x60, 0x09, 0xE7, 0xFF, 
	0x31, 0xA8, 0xB5, 0x80, 0xD3, 0xA4, 0xF7, 0xDB, 
	0xBC, 0x80, 0x9B, 0xDE, 0x4A, 0xAE, 0xA9, 0x84, 
	0x0D, 0x30, 0x68, 0x1C, 0x86, 0xC7, 0xC7, 0x58, 
	0xCB, 0x29, 0xFA, 0x0B, 0xAA, 0xDE, 0xBE, 0x9F, 
	0xB9, 0x66, 0x59, 0x3E, 0x89, 0xFB, 0x55, 0xB0, 
	0x2B, 0x1C, 0xE0, 0x0F, 0x0F, 0x67, 0x70, 0x7C, 
	0x5F, 0x1D, 0x9D, 0x93, 0x1A, 0xD1, 0x49, 0x5C, 
	0xCB, 0x6D, 0xD9, 0x77, 0xC5, 0xB6, 0xB7, 0xEA, 
	0xE0, 0xB6, 0x34, 0x5C, 0xF2, 0xC4, 0x71, 0xC3, 
	0x66, 0xDB, 0xAA, 0x82, 0x14, 0x96, 0x49, 0x34, 
	0xB8, 0xAC, 0xF3, 0xA8, 0x24, 0x09, 0x67, 0x62, 
	0x86, 0xFE, 0x9B, 0xE8, 0xA4, 0x64, 0xE8, 0xA6, 
	0xC1, 0x05, 0x8D, 0x22, 0x35, 0x3C, 0xEE, 0xF1, 
	0x05, 0x21, 0x27, 0x24, 0xD5, 0x87, 0xC8, 0xCE, 
	0xBD, 0xD1, 0xF8, 0x1C, 0xE7, 0xAF, 0xEB, 0x37, 
	0xFF, 0xE1, 0xF9, 0x4D, 0xAF, 0x30, 0xE2, 0x7D, 

	/* Database Page 4 */

	0xFF, 0xD3, 0x21, 0x5A, 0xAE, 0x34, 0x5F, 0x05, 
	0x42, 0x16, 0x00, 0x60, 0x31, 0x40, 0x95, 0xE3, 
	0xFC, 0x01, 0x8A, 0x7E, 0x9A, 0x13, 0x67, 0x53, 
	0xC7, 0x07, 0xD2, 0x91, 0x79, 0xD3, 0xCC, 0x5D, 
	0xCB, 0x9B, 0xEA, 0x0A, 0xAD, 0xF8, 0x97, 0x67, 
	0x37, 0x20, 0x0D, 0xB9, 0xD6, 0x8A, 0x2C, 0xEA, 
	0x1B, 0xE9, 0x7F, 0x28, 0x09, 0xD8, 0xD9, 0x9B, 
	0xAF, 0x4D, 0x50, 0x40, 0x97, 0xE8, 0x42, 0x64, 
	0xB6, 0xA3, 0x84, 0x93, 0xD7, 0xE3, 0x93, 0x1F, 
	0x10, 0x81, 0xB2, 0x0F, 0x80, 0x17, 0xBB, 0xB3, 
	0x62, 0xD8, 0x47, 0x0E, 0x49, 0x6F, 0xF4, 0xDF, 
	0xCC, 0x25, 0x3B, 0x7A, 0xA3, 0x0D, 0xE8, 0xDA, 
	0x5F, 0xD6, 0xAE, 0x5E, 0x26, 0xD2, 0x18, 0x96, 
	0xCF, 0x91, 0xA3, 0x1D, 0x3C, 0x21, 0x92, 0x50, 
	0xD5, 0xF6, 0xC5, 0x5D, 0x4A, 0x77, 0x83, 0x33, 
	0xFB, 0x59, 0xB9, 0x14, 0xCC, 0x7D, 0xB8, 0x65, 
	0x98, 0xFF, 0x24, 0x7A, 0x32, 0x09, 0x50, 0x7F, 
	0x2C, 0x12, 0xBD, 0xAE, 0xEA, 0xB9, 0x69, 0x6A, 
	0xD2, 0xBA, 0xEC, 0x31, 0xC5, 0xBB, 0x20, 0x1F, 
	0xC1, 0x01, 0xEC, 0x62, 0x0F, 0x06, 0xF6, 0x1C, 
	0x33, 0xFF, 0xA3, 0xAB, 0x51, 0xDF, 0x03, 0xB1, 
	0xFB, 0x38, 0xC0, 0xF6, 0x87, 0x5D, 0x60, 0x20, 
	0x7B, 0x8D, 0xB4, 0x75, 0xE3, 0xCE, 0x8A, 0x97, 
	0x23, 0x65, 0xA5, 0xB5, 0xF6, 0xFA, 0xD1, 0x76, 
	0xF7, 0xEC, 0x78, 0xBF, 0x84, 0xDE, 0xC4, 0x4F, 
	0x5C, 0x4D, 0x4B, 0x6C, 0xE9, 0x97, 0x55, 0xF9, 
	0xA0, 0x3E, 0x64, 0x26, 0x63, 0xA4, 0xF2, 0xDE, 
	0x4D, 0x3D, 0x5A, 0xC0, 0x12, 0xDD, 0x78, 0x3C, 
	0x6E, 0x48, 0x81, 0x7F, 0xBE, 0xEC, 0xDA, 0x75, 
	0xB0, 0xD4, 0x0B, 0xC9, 0xCB, 0x7E, 0x79, 0xD7, 
	0xF8, 0x46, 0x68, 0xE6, 0xB3, 0x99, 0x20, 0x01, 
	0xCD, 0xFE, 0x2D, 0xCA, 0x00, 0xB6, 0x89, 0x29, 
	0xB3, 0xCF, 0xFF, 0x86, 0x49, 0x2D, 0x77, 0x0D, 
	0xCD, 0xBC, 0x4B, 0x7E, 0x7A, 0x47, 0x1C, 0xB0, 
	0xD0, 0xB7, 0x93, 0x65, 0x9F, 0xA5, 0x55, 0x47, 
	0x34, 0xC4, 0xD4, 0x11, 0xC1, 0xCF, 0x25, 0x64, 
	0x17, 0x2A, 0x40, 0xC4, 0x75, 0xAE, 0xD9, 0x1B, 
	0xC9, 0x5A, 0xBE, 0xE2, 0xEE, 0xA5, 0x47, 0xC6, 
	0x3F, 0x21, 0x4D, 0xCF, 0x44, 0x41, 0x10, 0xE6, 
	0xF1, 0x2F, 0x37, 0x1F, 0xB7, 0x15, 0x12, 0x41, 
	0x8B, 0x1D, 0x28, 0x5B, 0x85, 0x34, 0x4B, 0xCD, 
	0x1D, 0xDE, 0x05, 0xF0, 0xA6, 0x9A, 0x3A, 0x6D, 
	0x2F, 0xB2, 0x8B, 0x7C, 0x3C, 0x55, 0x8E, 0x87, 
	0xDF, 0x15, 0x8F, 0x10, 0x8E, 0x9F, 0x73, 0x81, 
	0xEF, 0xF8, 0x6D, 0xAC, 0xAA, 0x8B, 0x9D, 0x89, 
	0xB0, 0xFB, 0x05, 0x9D, 0x1C, 0x4E, 0x68, 0xAE, 
	0x38, 0x1B, 0x8B, 0x9E, 0x3A, 0xDD, 0xAB, 0xD8, 
	0xB4, 0xD8, 0x16, 0x28, 0x8E, 0x5D, 0xFC, 0x4E, 
	0xB4, 0x04, 0xE9, 0xFF, 0x3B, 0x91, 0x91, 0x6B, 
	0x02, 0x53, 0x4B, 0xD6, 0x51, 0xC0, 0xD4, 0x8C, 
	0x68, 0x3C, 0xC2, 0x23, 0x6A, 0x15, 0x1C, 0x7A, 
	0x8A, 0x64, 0xBB, 0xE3, 0x6F, 0x23, 0xEF, 0xB8, 
	0x1D, 0xC9, 0x3C, 0x6C, 0xBC, 0xB9, 0x19, 0x1F, 
	0x8B, 0xF2, 0xD4, 0x03, 0xB1, 0xA9, 0x32, 0x0C, 
	0xFF, 0xB0, 0x4C, 0xA1, 0x5C, 0x50, 0x7B, 0x74, 
	0xBE, 0x2B, 0xF6, 0x49, 0xF9, 0xB6, 0x57, 0x72, 
	0x1C, 0x0B, 0x17, 0x7D, 0x5D, 0xBF, 0xF5, 0x9C, 
	0xA8, 0x34, 0x94, 0x9E, 0x3C, 0x1D, 0x20, 0xD2, 
	0xD6, 0x65, 0x0E, 0x0E, 0x09, 0x8E, 0xE9, 0xF2, 
	0x9F, 0xD3, 0x9B, 0x5C, 0xDB, 0xD7, 0x22, 0xF9, 
	0x46, 0xD8, 0x81, 0xA3, 0xCF, 0xEE, 0x23, 0x84, 
	0xBA, 0x57, 0x5C, 0x1E, 0xF1, 0x72, 0x68, 0xC3, 
	0x19, 0x66, 0x60, 0x17, 0xFD, 0xE6, 0xDB, 0x0D, 
	0x24, 0x12, 0x0A, 0x85, 0x1F, 0xAE, 0x9F, 0x42, 
	0x5F, 0x22, 0x8C, 0x55, 0xFF, 0x62, 0xAC, 0x6A, 
	0xE3, 0xA2, 0x22, 0x63, 0x9D, 0x68, 0xE0, 0xF9, 
	0xF2, 0x60, 0xAE, 0x4B, 0x6E, 0xDA, 0x38, 0xF7, 
	0xB0, 0xCA, 0x99, 0xAB, 0x5A, 0xD6, 0x50, 0xEA, 
	0xA6, 0x79, 0x80, 0x6F, 0x77, 0x24, 0x9E, 0xA8, 
	0xE1, 0xA2, 0x47, 0xDC, 0xB0, 0x9D, 0x08, 0x7A, 
	0xF0, 0xF8, 0x5A, 0x5F, 0x73, 0x69, 0x0C, 0x4C, 
	0x25, 0x60, 0x6B, 0x13, 0x44, 0xF2, 0xA1, 0xF5, 
	0x28, 0x72, 0xDA, 0xE6, 0x78, 0x1D, 0x24, 0xE8, 
	0x64, 0x6F, 0xC6, 0x3F, 0x14, 0x87, 0x16, 0xDF, 
	0x4B, 0xEC, 0x9E, 0xDA, 0x92, 0xAA, 0xED, 0x2A, 
	0xD5, 0x85, 0x71, 0xAE, 0xFA, 0x80, 0xD8, 0x3C, 
	0x4A, 0x49, 0x78, 0x97, 0xEC, 0x0A, 0xD3, 0xC2, 
	0x85, 0x67, 0xF2, 0xD4, 0x29, 0x5F, 0x25, 0x53, 
	0xD1, 0x0E, 0xF1, 0x79, 0x4A, 0x89, 0x69, 0xC8, 
	0xCD, 0xDD, 0xBD, 0x05, 0x5D, 0x65, 0x6A, 0x16, 
	0xBB, 0x2E, 0x50, 0xFF, 0x38, 0xFF, 0xF2, 0xE2, 
	0xA4, 0xBE, 0xB5, 0xC8, 0xD3, 0x96, 0x28, 0x8A, 
	0xA8, 0x92, 0xF3, 0x84, 0xB6, 0xB4, 0xFD, 0x93, 
	0x14, 0xF0, 0xCC, 0x02, 0xF9, 0x4B, 0xA5, 0x8E, 
	0xA5, 0xF8, 0x15, 0x57, 0xA9, 0x12, 0x40, 0x74, 
	0x94, 0x2E, 0x6D, 0x55, 0xEB, 0x88, 0x3A, 0xFD, 
	0x71, 0xF4, 0xFB, 0x08, 0xC6, 0xF8, 0x18, 0x8A, 
	0xAD, 0x43, 0x5B, 0xC3, 0x04, 0x77, 0x1C, 0x27, 
	0xCC, 0xEE, 0xB3, 0x4D, 0x66, 0x64, 0x04, 0xE4, 
	0x78, 0xE5, 0x66, 0xAC, 0x59, 0x61, 0x44, 0x41, 
	0xBE, 0x7A, 0xC2, 0xB7, 0xD3, 0x30, 0xE8, 0x8C, 
	0x6E, 0x41, 0x13, 0xA1, 0xB3, 0xBE, 0xF5, 0xF7, 
	0x42, 0x0B, 0x18, 0x5C, 0x63, 0xCD, 0x4C, 0x43, 
	0xAD, 0x45, 0xC1, 0xCB, 0xE3, 0x28, 0xEC, 0x47, 
	0x03, 0xD5, 0x3C, 0x60, 0x66, 0x83, 0x5C, 0x15, 
	0x0E, 0xF4, 0xDB, 0x7B, 0x38, 0x59, 0xB1, 0x8A, 
	0xA4, 0x0E, 0xAC, 0x35, 0xBA, 0xCD, 0xFF, 0xDF, 
	0x18, 0x13, 0xB1, 0xCA, 0xE1, 0x4D, 0x40, 0x71, 
	0x0D, 0xD2, 0xBB, 0x0D, 0xAA, 0x81, 0x21, 0x01, 
	0xB7, 0x5C, 0x12, 0xB6, 0xE7, 0xD3, 0x13, 0x57, 
	0x0B, 0xFF, 0x38, 0xDD, 0x1C, 0xFD, 0xEA, 0x42, 
	0x72, 0xEA, 0x1E, 0x5E, 0x88, 0x44, 0x18, 0x1F, 
	0xC4, 0x91, 0x77, 0x09, 0xFF, 0x73, 0xA1, 0x22, 
	0x2B, 0x49, 0x12, 0xBF, 0x6F, 0x78, 0xA0, 0x0A, 
	0xA9, 0xE2, 0x39, 0x45, 0x8B, 0xB1, 0x20, 0x62, 
	0x57, 0x52, 0xDF, 0x02, 0x06, 0xCB, 0xAA, 0xA9, 
	0x8D, 0x12, 0x81, 0x68, 0xEC, 0x56, 0x87, 0x90, 
	0xF2, 0x44, 0xED, 0x0A, 0x2A, 0x3D, 0x0E, 0xF4, 
	0x86, 0xE1, 0x2D, 0x68, 0x9C, 0x32, 0x9D, 0xE3, 
	0x9E, 0x8A, 0x22, 0x5C, 0xFC, 0xDD, 0xB6, 0x2D, 
	0xA1, 0xFF, 0xDC, 0x9B, 0x22, 0xFA, 0x3F, 0x23, 
	0x7A, 0x3F, 0x6C, 0xC3, 0x25, 0x31, 0x92, 0xDF, 
	0x74, 0x5E, 0xAC, 0xE1, 0xC1, 0x46, 0x95, 0xFF, 
	0x61, 0x36, 0x94, 0xC7, 0x15, 0x79, 0x0D, 0xE8, 
	0xCD, 0xD2, 0xE2, 0xC8, 0x97, 0x63, 0x39, 0x78, 
	0xCA, 0x85, 0x05, 0xE4, 0x41, 0x9E, 0xC4, 0x82, 
	0x96, 0x07, 0x43, 0x1F, 0x78, 0x22, 0x44, 0xB8, 
	0x6C, 0x34, 0xFE, 0xBD, 0x24, 0x6D, 0x05, 0x8C, 
	0x70, 0x56, 0xDB, 0x86, 0x4D, 0x33, 0x8A, 0x1A, 
	0x66, 0x2D, 0xAF, 0x7D, 0x40, 0x71, 0x61, 0xCF, 
	0xBE, 0xD0, 0x2E, 0x8C, 0x8A, 0xFA, 0xAC, 0x1C, 
	0xD1, 0x18, 0x7F, 0xC0, 0x87, 0x7E, 0xCB, 0xEA, 
	0x52, 0x55, 0x75, 0x83, 0x56, 0x43, 0x8A, 0x13, 
	0xD4, 0xAA, 0x73, 0x98, 0x14, 0x37, 0xBA, 0x66, 
	0x7E, 0x9E, 0x36, 0xBF, 0x7B, 0xC3, 0xD8, 0xF6, 
	0x75, 0x9F, 0x9A, 0x55, 0xA4, 0x13, 0x44, 0xE3, 
	0x41, 0x0B, 0x38, 0x5B, 0x7F, 0x02, 0xD7, 0xC5, 
	0x57, 0x95, 0xF2, 0x64, 0xD7, 0x15, 0x88, 0xAE, 
	0x2E, 0x8E, 0x70, 0xF1, 0x8D, 0x07, 0x0B, 0x13, 
	0xFF, 0x77, 0xA2, 0x07, 0xFF, 0x76, 0xBB, 0xA6, 
	0x12, 0x6E, 0x69, 0x79, 0x9A, 0x7A, 0x4F, 0x31, 
	0xE3, 0xF1, 0x7D, 0x7A, 0xDA, 0xDA, 0x7D, 0x69, 
	0xB0, 0xE3, 0x16, 0x0F, 0x3F, 0xA5, 0x1D, 0x03, 
	0x72, 0x73, 0xE2, 0x43, 0xD8, 0xA0, 0xB3, 0x7C, 
	0x4B, 0x7C, 0xFE, 0xEC, 0xBB, 0xB8, 0x64, 0x93, 
	0xAA, 0xC2, 0x95, 0x67, 0x64, 0x83, 0xD7, 0xA5, 
	0xC7, 0x09, 0x0F, 0xF9, 0x5E, 0xE8, 0xB7, 0x13, 
	0xD0, 0x03, 0xBA, 0x51, 0x63, 0x85, 0xC1, 0x79, 
	0x96, 0x2B, 0x29, 0xA7, 0xD7, 0xEE, 0xF8, 0xDA, 
	0x99, 0xCA, 0xD6, 0xE9, 0x6F, 0x3B, 0x49, 0xC5, 
	0x71, 0x17, 0x5A, 0xB6, 0xE1, 0x58, 0xB2, 0xDC, 
	0x52, 0xF7, 0x50, 0xA5, 0xEA, 0x1E, 0xE0, 0xB1, 
	0x32, 0xD7, 0xE4, 0xDA, 0x73, 0x5D, 0xAF, 0x43, 
	0x22, 0x74, 0x04, 0x66, 0xCC, 0x11, 0x63, 0xD9, 
	0xC0, 0x2F, 0x8E, 0x20, 0xF7, 0xED, 0x0B, 0x69, 
	0xBC, 0xFF, 0x60, 0x95, 0x89, 0x6B, 0x0D, 0x34, 
	0xBD, 0x05, 0x08, 0x61, 0x1D, 0x0F, 0x22, 0x01, 
	0x77, 0x5D, 0x89, 0xBD, 0xDF, 0x67, 0xB5, 0x8A, 
	0xD8, 0xF0, 0x3E, 0xAB, 0x2A, 0xFF, 0xC3, 0x44, 
	0xE4, 0xAA, 0x32, 0xB6, 0xE1, 0x48, 0x7D, 0x34, 
	0xBC, 0xFB, 0x92, 0x61, 0xA6, 0x2B, 0xB0, 0x1C, 
	0x68, 0x59, 0xF3, 0x85, 0x42, 0xC6, 0x01, 0x14, 
	0x6D, 0x18, 0x15, 0x6D, 0x12, 0x63, 0x70, 0x79, 
	0xC0, 0xFB, 0x59, 0xD0, 0x84, 0x16, 0x2C, 0xEE, 
	0xE9, 0xD0, 0xCD, 0x40, 0x75, 0x39, 0xCF, 0x55, 
	0x3D, 0xED, 0x77, 0x2A, 0x70, 0xF6, 0x0A, 0x45, 
	0x6E, 0x77, 0xF0, 0x27, 0x5B, 0x4F, 0xAC, 0x8A, 
	0xA6, 0xD3, 0xDB, 0x01, 0x61, 0xFD, 0x0C, 0x3A, 
	0x13, 0xD4, 0x2B, 0x32, 0x98, 0x36, 0xD0, 0x75, 
	0x64, 0x0E, 0xAC, 0xD9, 0xFC, 0x86, 0xE0, 0x14, 
	0x9F, 0x7E, 0x08, 0x70, 0x8A, 0xAF, 0xBF, 0x9A, 
	0x42, 0x46, 0xFF, 0xF8, 0xCF, 0x65, 0x72, 0x52, 
	0x02, 0x18, 0xCE, 0x0C, 0x71, 0xCA, 0x8C, 0x7D, 
	0xFB, 0x85, 0xEB, 0x90, 0xB5, 0x27, 0x25, 0x9F, 
	0x9B, 0xD9, 0xF4, 0xCD, 0x9B, 0xA2, 0x1B, 0x9A, 
	0xDF, 0x7F, 0xC5, 0xEA, 0xA5, 0x5A, 0x6B, 0x2A, 
	0x9A, 0xB5, 0x78, 0xE7, 0x5E, 0xEB, 0xB6, 0x64, 
	0x84, 0x47, 0xD4, 0x2B, 0x37, 0x5B, 0xEE, 0x77, 
	0x68, 0x4B, 0x36, 0x39, 0x39, 0x15, 0x4C, 0xB8, 
	0x6C, 0xDE, 0x2F, 0x9D, 0x45, 0xD7, 0xC7, 0x3C, 
	0x28, 0x45, 0x6A, 0x08, 0x3B, 0xCF, 0x44, 0xA6, 
	0x7D, 0xF0, 0xD8, 0x6D, 0x74, 0x92, 0x6D, 0x75, 
	0xE6, 0x15, 0x31, 0x68, 0x17, 0x7E, 0xA8, 0xD8, 
	0xCA, 0x09, 0xA2, 0x42, 0x4C, 0x50, 0xDB, 0xC4, 
	0x76, 0x2A, 0xCD, 0x1F, 0xAC, 0xB5, 0x3A, 0xE0, 
	0x13, 0x79, 0x48, 0x7E, 0x1A, 0x3F, 0xF7, 0x2D, 
	0x32, 0x2F, 0x53, 0xC7, 0xB0, 0xEB, 0xF3, 0x7C, 
	0x3D, 0x2A, 0xE2, 0xFF, 0xB5, 0x3A, 0xBA, 0xDA, 
	0x8C, 0x23, 0xB2, 0xA4, 0x1F, 0xE5, 0xDC, 0x57, 
	0xA0, 0x45, 0x78, 0x8B, 0x85, 0xF5, 0x69, 0x92, 
	0x77, 0x39, 0x1E, 0xA4, 0x95, 0x1D, 0xF4, 0xB8, 
	0x48, 0x94, 0x28, 0x97, 0x46, 0xFC, 0xDC, 0x3E, 
	0x45, 0x8B, 0x6C, 0xFE, 0xF7, 0x03, 0x47, 0x34, 
	0xBA, 0x95, 0x96, 0x47, 0xC0, 0x48, 0x95, 0x6E, 
	0x61, 0x3D, 0x57, 0x70, 0x4F, 0x67, 0xC5, 0xC3, 
	0xB5, 0xAC, 0xCE, 0x87, 0xE5, 0xA9, 0x7E, 0x74, 
	0x74, 0xD9, 0xF3, 0xF6, 0x1E, 0xCF, 0x10, 0x23, 
	0x23, 0x58, 0x2C, 0x23, 0x38, 0x7F, 0x88, 0x31, 
	0x52, 0x3A, 0x33, 0x21, 0x6E, 0x0F, 0xEE, 0xCA, 
	0xF7, 0x7E, 0xD9, 0x5D, 0x3F, 0xB3, 0x00, 0x8C, 
	0x74, 0x72, 0x0A, 0x75, 0x57, 0x13, 0xAF, 0x7F, 
	0x81, 0x8A, 0x7B, 0x0E, 0x54, 0x1B, 0x05, 0xB7, 
	0xC5, 0xB1, 0xE2, 0x43, 0xDB, 0x98, 0x3C, 0xD7, 
	0x0F, 0x9C, 0xC9, 0xD0, 0xFF, 0xD6, 0xFD, 0x80, 
	0x6E, 0xFD, 0xE5, 0x19, 0xB5, 0xDE, 0xAC, 0x1E, 
	0xD4, 0xBC, 0x1C, 0xA5, 0xCA, 0x4A, 0xDA, 0x88, 
	0xEF, 0x68, 0x0E, 0x84, 0x21, 0x80, 0xD6, 0x64, 
	0xFB, 0x4B, 0x41, 0x67, 0xA5, 0x64, 0x09, 0xFF, 
	0x6C, 0xBB, 0xD8, 0xCA, 0x94, 0x2D, 0x31, 0xDD, 
	0xF6, 0x92, 0x77, 0x5A, 0xB7, 0x45, 0x89, 0xA0, 
	0xC5, 0x64, 0x41, 0x34, 0x6C, 0x71, 0x2C, 0xD8, 
	0xE1, 0x67, 0x20, 0x43, 0x2D, 0x2D, 0x02, 0x27, 
	0x1A, 0x10, 0x22, 0x2A, 0xB4, 0x23, 0x47, 0x73, 
	0xB6, 0x21, 0x88, 0x7D, 0x45, 0x5D, 0xE0, 0x01, 
	0x0C, 0x9A, 0x00, 0x7A, 0x12, 0x6C, 0xF8, 0x6D, 
	0x76, 0x4B, 0xBB, 0x7C, 0xBF, 0x29, 0xB0, 0x74, 
	0x84, 0xFF, 0xCE, 0x47, 0x66, 0x2E, 0x41, 0x97, 
	0x8F, 0x81, 0x88, 0x3D, 0xB5, 0xB2, 0x95, 0x56, 
	0x77, 0x11, 0x92, 0xB9, 0xDF, 0xCE, 0xA8, 0xA1, 
	0xF1, 0x4E, 0x43, 0x34, 0xA6, 0xFF, 0x7D, 0x1E, 
	0xB3, 0x0C, 0x1E, 0x1B, 0xA4, 0x88, 0x7D, 0x49, 
	0x50, 0x53, 0x8D, 0x09, 0x43, 0x29, 0xF7, 0x55, 
	0x95, 0x11, 0x8C, 0xD9, 0xEA, 0xE1, 0xAA, 0xEC, 
	0xFF, 0x3E, 0xFB, 0x4D, 0x69, 0x27, 0x5E, 0x24, 
	0x79, 0xD2, 0xDC, 0x46, 0x2B, 0x16, 0x9A, 0x4B, 
	0x5C, 0x0A, 0x29, 0x4F, 0x63, 0xA6, 0x27, 0xC6, 
	0x5B, 0x48, 0x12, 0x93, 0xD8, 0x12, 0x0F, 0x22, 
	0xA7, 0x1E, 0x0D, 0xE4, 0x0B, 0x71, 0x7F, 0x5D, 
	0x8E, 0x7B, 0xC9, 0x6D, 0x32, 0x67, 0x59, 0xCE, 
	0xD3, 0x62, 0xD3, 0x30, 0x30, 0x61, 0xD9, 0xB9, 
	0x38, 0x7D, 0xB6, 0xE5, 0x3F, 0xD6, 0x6E, 0x86, 
	0x63, 0xA0, 0x76, 0x14, 0x8E, 0xF9, 0x32, 0xEF, 
	0xD0, 0x94, 0x29, 0x31, 0xF4, 0x5F, 0x36, 0x16, 
	0xE8, 0xCE, 0xAA, 0x72, 0x26, 0x33, 0x67, 0x7D, 
	0xC7, 0x37, 0x8F, 0xF6, 0x99, 0x6A, 0xC8, 0x78, 
	0x71, 0xB1, 0x5E, 0x7D, 0x41, 0x6C, 0xFF, 0x28, 
	0xD1, 0x0A, 0x41, 0xE3, 0x69, 0xD3, 0xAC, 0x89, 
	0x49, 0x2D, 0x49, 0x63, 0x99, 0x1F, 0x77, 0x01, 
	0x41, 0xE2, 0x7B, 0xE5, 0xB3, 0x47, 0x8D, 0xF5, 
	0x18, 0x61, 0x41, 0xB4, 0x2A, 0xCC, 0x28, 0xF0, 
	0xF9, 0x5C, 0xA2, 0x32, 0x28, 0xA7, 0x48, 0x62, 
	0xE8, 0x9C, 0x29, 0x44, 0x34, 0x5B, 0x22, 0x85, 
	0x1C, 0x5C, 0x4D, 0xA0, 0xB5, 0x50, 0x35, 0xAA, 
	0x2F, 0x6D, 0xC1, 0x55, 0x61, 0xA5, 0x43, 0x5F, 
	0xF3, 0xDC, 0x25, 0xAD, 0x8F, 0x6D, 0x62, 0x88, 
	0x18, 0xCB, 0xE3, 0x7E, 0xE3, 0x1E, 0xED, 0x3D, 
	0xDF, 0x38, 0xFA, 0xA8, 0xD1, 0xD0, 0x39, 0x10, 
	0x21, 0xEE, 0x20, 0xCB, 0x40, 0x8B, 0x79, 0x58, 
	0xB5, 0x7F, 0x2C, 0xD2, 0x33, 0xD9, 0x7C, 0x37, 
	0x3B, 0xED, 0x5A, 0x56, 0x18, 0xD7, 0xFE, 0x07, 
	0xFC, 0xF4, 0xD3, 0xFB, 0x6E, 0x41, 0x8B, 0xAF, 
	0x80, 0xA9, 0x72, 0xDF, 0x8A, 0x69, 0x29, 0xFF, 
	0x8C, 0xE2, 0xF4, 0xFC, 0x26, 0xA1, 0x7D, 0xC0, 
	0x2F, 0xB6, 0x80, 0x12, 0x55, 0x40, 0x5F, 0xE2, 
	0x04, 0x04, 0xA3, 0x81, 0x0E, 0x22, 0x98, 0x33, 
	0x43, 0x6D, 0x07, 0xC4, 0xAF, 0x2B, 0xE2, 0xCB, 
	0x66, 0x44, 0xD1, 0xFA, 0xB3, 0x68, 0xA0, 0x05, 
	0x89, 0x58, 0x6E, 0x48, 0x0F, 0x3F, 0x5A, 0x8D, 
	0x12, 0x0C, 0x74, 0x0A, 0x84, 0x20, 0x17, 0xA4, 
	0x50, 0x3B, 0x7F, 0xA1, 0xF2, 0xCF, 0x99, 0xDF, 
	0x78, 0x86, 0xA4, 0x53, 0xFD, 0x3E, 0x48, 0x31, 
	0xD9, 0x68, 0x27, 0x9B, 0x29, 0xE5, 0x3F, 0xC8, 
	0xA0, 0xB5, 0x27, 0xBB, 0x3E, 0xB2, 0x61, 0x4A, 
	0xAC, 0xCC, 0x69, 0x15, 0xF7, 0x7A, 0x68, 0xCF, 
	0x85, 0x57, 0x9E, 0x3D, 0x6A, 0x3D, 0x29, 0x6F, 
	0xBC, 0x8F, 0x1C, 0x31, 0xC1, 0x6C, 0xE8, 0xC9, 
	0xCC, 0xA1, 0x01, 0x9F, 0x44, 0x41, 0x57, 0xD9, 
	0xF3, 0xA7, 0x44, 0x5A, 0x6F, 0x96, 0x19, 0x19, 

	/* Database Page 5 */

	0xFF, 0x39, 0x2D, 0x74, 0x13, 0x61, 0x09, 0x47, 
	0x2E, 0xE6, 0xF1, 0xEF, 0xB6, 0x78, 0x30, 0x1E, 
	0x95, 0x77, 0x7D, 0x4D, 0x02, 0x5E, 0x44, 0xD0, 
	0x83, 0xFA, 0xB7, 0xD3, 0x17, 0x6E, 0x13, 0xF6, 
	0x28, 0x9E, 0x55, 0xEF, 0xBF, 0x6D, 0x35, 0xFD, 
	0x5A, 0xBF, 0x84, 0x13, 0x3D, 0x84, 0x20, 0xEF, 
	0x95, 0xDA, 0x03, 0x12, 0x0F, 0xA8, 0xC6, 0xAE, 
	0x1A, 0x9E, 0x79, 0xE5, 0x2C, 0x7D, 0xE5, 0x6A, 
	0x84, 0xD1, 0xC3, 0xA7, 0x54, 0x22, 0x36, 0xB9, 
	0x00, 0xF5, 0xEA, 0xC2, 0x62, 0x54, 0x1F, 0x99, 
	0xE3, 0xA1, 0x88, 0x07, 0xB7, 0x8A, 0x64, 0xB0, 
	0x9D, 0x82, 0xE7, 0x61, 0x14, 0x61, 0xC7, 0xEE, 
	0x25, 0x73, 0x7F, 0x38, 0xE1, 0xAD, 0x63, 0xA0, 
	0xBC, 0xA1, 0xD3, 0xDB, 0x74, 0x26, 0x79, 0xBA, 
	0xBA, 0x0D, 0xDC, 0x10, 0xD3, 0x4F, 0x89, 0x1D, 
	0x97, 0x2A, 0xAC, 0xAE, 0x10, 0x61, 0xAC, 0xDC, 
	0x8C, 0xFF, 0xFE, 0x20, 0x3E, 0xCD, 0xCD, 0x1F, 
	0xE7, 0x1D, 0xF9, 0x7B, 0x75, 0x67, 0x5A, 0x10, 
	0x76, 0x39, 0x65, 0x13, 0x07, 0x5F, 0x5E, 0xD3, 
	0x1C, 0x00, 0x0D, 0x8B, 0x64, 0x77, 0x84, 0xE2, 
	0x1E, 0x2A, 0xA8, 0x72, 0x75, 0xF3, 0x29, 0x5C, 
	0x30, 0x94, 0xFB, 0x45, 0x3F, 0x96, 0x75, 0x04, 
	0x76, 0x55, 0x99, 0x9A, 0xD6, 0x24, 0xC6, 0xC9, 
	0x91, 0xE1, 0xA7, 0xED, 0xA3, 0xA8, 0x03, 0x32, 
	0xA4, 0x54, 0xF3, 0xA0, 0x5C, 0xB3, 0x0B, 0x2A, 
	0x25, 0x2F, 0x95, 0x06, 0x92, 0xBF, 0xD2, 0x53, 
	0x60, 0x52, 0x0B, 0xE8, 0x6C, 0xD4, 0x6D, 0x64, 
	0x16, 0xFF, 0x72, 0x99, 0x2F, 0x18, 0x15, 0x07, 
	0x8F, 0x5F, 0x62, 0xD2, 0x71, 0x38, 0x01, 0xB9, 
	0xBF, 0xAA, 0x54, 0x4D, 0x09, 0x2D, 0x84, 0x5A, 
	0xEA, 0x76, 0xF3, 0x5A, 0x98, 0xA6, 0x9A, 0xA1, 
	0x13, 0xBF, 0x12, 0xAC, 0x7E, 0xCB, 0x40, 0xD1, 
	0x67, 0xB3, 0xFF, 0x49, 0xE1, 0x58, 0x83, 0x33, 
	0x2B, 0x64, 0xD9, 0x3C, 0x84, 0x46, 0x13, 0x0F, 
	0x63, 0x46, 0xF9, 0x1E, 0x6D, 0xB5, 0x1B, 0x43, 
	0x8C, 0x29, 0x56, 0x3A, 0x22, 0x5B, 0x4A, 0xD0, 
	0x36, 0x33, 0x6D, 0x3A, 0x8F, 0xBF, 0x15, 0x5C, 
	0xD9, 0xD6, 0x3D, 0x08, 0xF3, 0xE3, 0x40, 0xD5, 
	0x1D, 0x7A, 0xB4, 0x68, 0xCA, 0x77, 0xD8, 0x1C, 
	0xF7, 0xD8, 0x15, 0x74, 0x73, 0x64, 0xEB, 0x25, 
	0x6C, 0x50, 0x9B, 0x0C, 0xEC, 0x88, 0x53, 0x66, 
	0x02, 0xC2, 0xBB, 0x03, 0x99, 0x65, 0x01, 0x0E, 
	0x08, 0x7F, 0x3B, 0x8B, 0x92, 0x68, 0x92, 0x74, 
	0x44, 0x73, 0xF9, 0x76, 0xA2, 0x06, 0xE4, 0x6A, 
	0xA2, 0x3B, 0x13, 0x2E, 0x60, 0xBB, 0xB2, 0x17, 
	0x58, 0x6F, 0x05, 0x38, 0xF0, 0xB7, 0x87, 0x13, 
	0x39, 0x29, 0x1C, 0x2C, 0xF9, 0xA4, 0x09, 0x36, 
	0x06, 0x1B, 0x06, 0xF2, 0x22, 0x91, 0x2D, 0x98, 
	0x3B, 0x78, 0xF8, 0xFF, 0x58, 0x3F, 0x23, 0x7D, 
	0x1C, 0x8F, 0xDC, 0xC6, 0xA2, 0x62, 0xDA, 0x81, 
	0xC0, 0x7C, 0x00, 0x73, 0x7E, 0x6D, 0xC7, 0x2C, 
	0xB8, 0xEB, 0x72, 0x13, 0x7D, 0x5F, 0xDE, 0x59, 
	0xC1, 0xA1, 0xFB, 0xD7, 0x6F, 0x3A, 0xF9, 0x57, 
	0xFE, 0xBD, 0xE3, 0x3D, 0xB1, 0x31, 0xFB, 0xBA, 
	0x11, 0x37, 0x5B, 0x0B, 0xC1, 0x65, 0xF1, 0x41, 
	0x50, 0xB6, 0x92, 0x96, 0x7B, 0x08, 0x01, 0x68, 
	0x18, 0x1E, 0xB4, 0x42, 0x03, 0x0A, 0x9B, 0x7B, 
	0xB2, 0x7C, 0xE2, 0x4A, 0x39, 0xA6, 0x84, 0x17, 
	0x40, 0xDA, 0xAE, 0x57, 0x3A, 0x88, 0xF5, 0x4C, 
	0x5C, 0x57, 0x3D, 0xC7, 0x17, 0xA2, 0xE1, 0x3E, 
	0x5C, 0x20, 0x92, 0x80, 0x6F, 0x20, 0x51, 0xB9, 
	0xDC, 0x5E, 0x85, 0xA3, 0x53, 0x0D, 0x23, 0xCC, 
	0x52, 0x6C, 0xE8, 0xE2, 0x13, 0x9A, 0xE5, 0xD5, 
	0xC3, 0xFC, 0xF2, 0x2C, 0x59, 0x30, 0x3E, 0x26, 
	0xA7, 0x7E, 0x02, 0x1B, 0xFF, 0x86, 0x71, 0xC9, 
	0x47, 0xD2, 0x87, 0x17, 0x89, 0x62, 0x93, 0x94, 
	0xB2, 0x8B, 0x5E, 0xA4, 0x59, 0x8A, 0xE8, 0xC1, 
	0x91, 0x5C, 0x60, 0x7E, 0x10, 0x56, 0x0E, 0x74, 
	0x35, 0x50, 0x92, 0x07, 0x53, 0x56, 0x01, 0x7B, 
	0x8C, 0x8A, 0x63, 0x4E, 0x57, 0xC7, 0xA8, 0x5A, 
	0x27, 0xAC, 0x2D, 0x78, 0xAD, 0xD1, 0x7B, 0xC4, 
	0x53, 0x3C, 0xDC, 0xE8, 0xE8, 0xBE, 0x96, 0xC9, 
	0x5F, 0x5F, 0x7B, 0xE9, 0xCD, 0x71, 0x70, 0x1A, 
	0xA2, 0x6A, 0x12, 0xFD, 0xF5, 0xC1, 0xC8, 0xC3, 
	0x74, 0x2C, 0x9A, 0x04, 0x8F, 0xD8, 0x5A, 0xBA, 
	0xA5, 0xAD, 0x32, 0xA5, 0x56, 0x1B, 0x4C, 0xDD, 
	0x3F, 0x47, 0x48, 0xCA, 0x40, 0xC1, 0x14, 0x0D, 
	0x07, 0x1E, 0x29, 0x27, 0x0A, 0x1C, 0xA2, 0x2E, 
	0xB6, 0x50, 0x1E, 0xA6, 0xE0, 0x78, 0x6A, 0x0B, 
	0xC7, 0x5B, 0x02, 0x05, 0x30, 0x9A, 0xA1, 0xD9, 
	0xCC, 0x47, 0xBB, 0xC4, 0x25, 0xFF, 0x53, 0xC4, 
	0x73, 0x76, 0x23, 0xFE, 0x30, 0xBD, 0x71, 0xE3, 
	0x5E, 0xCF, 0xF2, 0x49, 0xC4, 0xC7, 0xA4, 0x78, 
	0x43, 0x43, 0x1A, 0x64, 0xEE, 0x24, 0x15, 0x80, 
	0xCB, 0xD6, 0x4E, 0x85, 0xCB, 0x65, 0xB0, 0x8D, 
	0xB7, 0xC4, 0x47, 0xC1, 0x52, 0x80, 0xCB, 0xCC, 
	0x26, 0x49, 0x34, 0x2C, 0xB0, 0xB0, 0xEC, 0x71, 
	0xAE, 0xF0, 0x61, 0x9E, 0xB3, 0x34, 0x8E, 0xC2, 
	0xD6, 0x4B, 0xFE, 0xF3, 0xA4, 0xFC, 0xE3, 0x08, 
	0x23, 0x42, 0xC4, 0x49, 0x95, 0x33, 0xF4, 0x88, 
	0x39, 0x01, 0x8A, 0x61, 0xFF, 0x0A, 0x58, 0x30, 
	0xC8, 0x1C, 0xD4, 0x3E, 0x4E, 0x04, 0xB9, 0x7A, 
	0x8E, 0xFF, 0xB3, 0xD6, 0x1C, 0x0F, 0xFD, 0x4F, 
	0xF6, 0x75, 0x52, 0x7D, 0x8E, 0x69, 0x45, 0x3D, 
	0xC9, 0x98, 0x76, 0x5A, 0xE1, 0xDB, 0x2B, 0x3E, 
	0x3B, 0x3A, 0xC2, 0xDC, 0x61, 0x70, 0x76, 0x59, 
	0x88, 0x00, 0xCD, 0xD2, 0x92, 0xEF, 0xFF, 0x8D, 
	0x6A, 0x88, 0xBC, 0x34, 0xDE, 0x92, 0xAC, 0x4E, 
	0x1F, 0x1B, 0x26, 0x1C, 0x27, 0xB5, 0x35, 0x10, 
	0xA0, 0x96, 0xAD, 0xC3, 0x29, 0x82, 0xB1, 0xF7, 
	0x4F, 0x47, 0x7F, 0xD7, 0x14, 0x4C, 0x0E, 0x52, 
	0xE8, 0x9A, 0x73, 0x5A, 0x65, 0xBE, 0x6A, 0x1E, 
	0xAF, 0xC9, 0x46, 0x2C, 0x0B, 0x5F, 0x20, 0xF3, 
	0xE1, 0x23, 0x70, 0x78, 0xD2, 0x96, 0xD7, 0x2C, 
	0x97, 0x52, 0x34, 0xFC, 0xA0, 0xC9, 0x17, 0x4C, 
	0xB3, 0xD0, 0x97, 0x64, 0xD6, 0xF4, 0xE3, 0x91, 
	0xCC, 0x9B, 0xAD, 0xD0, 0x7A, 0x11, 0x75, 0xD5, 
	0xC7, 0x45, 0xC7, 0xB2, 0x87, 0x09, 0x51, 0x9E, 
	0x42, 0xFC, 0xF9, 0x11, 0xAC, 0xA9, 0xF3, 0x22, 
	0xFD, 0xDB, 0x82, 0x30, 0xCC, 0x7F, 0x8D, 0xDF, 
	0xB5, 0x97, 0xF9, 0x83, 0x44, 0xBF, 0x30, 0x25, 
	0xED, 0x8C, 0x83, 0x39, 0xC5, 0x9E, 0x98, 0xF1, 
	0xAC, 0x3F, 0xE6, 0x86, 0x7A, 0x14, 0x66, 0xFF, 
	0xEF, 0xF7, 0xE4, 0x21, 0x9C, 0xE1, 0x15, 0xC0, 
	0x23, 0xF0, 0xA6, 0xA3, 0xAF, 0x22, 0x35, 0x2C, 
	0x89, 0x98, 0x4A, 0x24, 0xD1, 0x70, 0xE2, 0xFB, 
	0x88, 0xAD, 0x4F, 0x2F, 0xC2, 0x0D, 0x55, 0xF8, 
	0x58, 0xBE, 0xAB, 0xAE, 0x02, 0xAB, 0xE3, 0x45, 
	0x92, 0xCA, 0xA6, 0x66, 0xE3, 0x1C, 0x9D, 0x27, 
	0x33, 0x43, 0x90, 0xDC, 0x3D, 0xEB, 0x01, 0xFA, 
	0xA6, 0xE0, 0x26, 0x7B, 0xEF, 0xF1, 0x42, 0x72, 
	0x63, 0x8B, 0x30, 0x12, 0x56, 0xF4, 0x28, 0xED, 
	0x7D, 0x1F, 0xD4, 0x99, 0x2B, 0x74, 0x72, 0xF7, 
	0xD1, 0x35, 0xD8, 0xB8, 0x54, 0x63, 0x68, 0xE6, 
	0x88, 0x10, 0x1B, 0xE0, 0x43, 0x78, 0xEF, 0xA8, 
	0x0F, 0x07, 0x5A, 0x55, 0xDD, 0xEE, 0x8A, 0x0A, 
	0xD8, 0x86, 0xB8, 0x21, 0xCE, 0x54, 0xD9, 0x7B, 
	0x5B, 0x11, 0x56, 0x16, 0xD0, 0x8C, 0x4A, 0x6B, 
	0x22, 0x56, 0xE6, 0x13, 0x42, 0x61, 0xC9, 0xAD, 
	0xFF, 0xFD, 0x19, 0xC1, 0xA2, 0xC4, 0x7E, 0x6B, 
	0xF5, 0x36, 0xFA, 0xE5, 0x25, 0x47, 0xB0, 0x66, 
	0x93, 0x26, 0x02, 0x30, 0xE1, 0xFF, 0x4E, 0x9E, 
	0xC0, 0x15, 0x86, 0x79, 0x8F, 0x15, 0xA3, 0xF2, 
	0x77, 0x40, 0x31, 0x8D, 0x05, 0xBE, 0xE1, 0xE7, 
	0x56, 0x71, 0xD2, 0x16, 0x7C, 0xDE, 0xC0, 0x5A, 
	0xD4, 0x97, 0xF0, 0xC0, 0xB8, 0x94, 0x4E, 0x59, 
	0x71, 0x92, 0xF3, 0x78, 0x39, 0xC8, 0x55, 0x12, 
	0x14, 0xB2, 0xF0, 0x43, 0xB1, 0x53, 0x34, 0xC8, 
	0xBF, 0x1C, 0x3D, 0x20, 0xCF, 0xD2, 0x70, 0x1F, 
	0x2C, 0xC2, 0x98, 0xA8, 0xB3, 0x7C, 0x63, 0x64, 
	0x59, 0x0D, 0x57, 0xB0, 0xAB, 0x46, 0x49, 0x77, 
	0xC4, 0xDC, 0xE1, 0xC0, 0x4C, 0xA8, 0xAF, 0xE2, 
	0xE0, 0xCE, 0x54, 0xC2, 0x67, 0x9A, 0x40, 0xEC, 
	0xF7, 0x94, 0x49, 0x70, 0xC5, 0xDC, 0x2A, 0x08, 
	0x18, 0x70, 0xE5, 0xE4, 0x2C, 0xBB, 0x12, 0x99, 
	0xB7, 0xFF, 0xBF, 0xC1, 0x5B, 0x1A, 0x98, 0xEE, 
	0x8D, 0x8F, 0xD7, 0x9F, 0x4D, 0x35, 0x58, 0xDD, 
	0x4C, 0x96, 0x90, 0xCB, 0x5A, 0x42, 0x86, 0xC8, 
	0x8A, 0x51, 0x51, 0xAF, 0xA7, 0x54, 0x54, 0x10, 
	0xEF, 0xE8, 0x5F, 0xC0, 0x77, 0xDF, 0x30, 0x0C, 
	0xFC, 0x4E, 0x7C, 0x2F, 0x59, 0x0B, 0x94, 0x6F, 
	0x0F, 0xA9, 0xBD, 0xB0, 0x6E, 0x41, 0x08, 0xAF, 
	0xE4, 0x95, 0xF8, 0x9B, 0x6F, 0xC9, 0x14, 0x68, 
	0x90, 0x9E, 0x9D, 0xF2, 0xB7, 0x15, 0x84, 0x07, 
	0x1E, 0xD1, 0x7B, 0xA1, 0x95, 0x2F, 0x31, 0x3D, 
	0xF1, 0x4A, 0x52, 0x0B, 0x9F, 0xE2, 0x9B, 0x8B, 
	0x87, 0xC2, 0xDA, 0x80, 0x0C, 0x72, 0xEF, 0x9C, 
	0x3C, 0x26, 0xDD, 0x74, 0x6C, 0x79, 0x8B, 0xDA, 
	0x6B, 0xA4, 0x7A, 0x52, 0x60, 0x5E, 0x95, 0xEA, 
	0x4D, 0x3C, 0x83, 0x92, 0xDA, 0xE0, 0x47, 0x7C, 
	0x75, 0x4C, 0x69, 0xCD, 0x45, 0xFF, 0x53, 0xB9, 
	0x1F, 0xD4, 0xFF, 0xEF, 0x15, 0x23, 0x23, 0x71, 
	0x55, 0xD9, 0x14, 0x42, 0x0B, 0xCA, 0x08, 0x88, 
	0x71, 0x1E, 0x45, 0x3B, 0xF8, 0x02, 0xA8, 0x6D, 
	0x78, 0xDA, 0x23, 0x64, 0x81, 0xF2, 0x08, 0x24, 
	0x9A, 0x52, 0xA2, 0x52, 0x44, 0xFB, 0xD8, 0x26, 
	0x59, 0xB4, 0x72, 0x14, 0xAA, 0x47, 0xDA, 0x0F, 
	0x92, 0x13, 0x24, 0x38, 0x46, 0x24, 0xC5, 0x38, 
	0x34, 0xA1, 0xA3, 0x46, 0x1A, 0x7F, 0x8D, 0x39, 
	0x3D, 0xE0, 0xF3, 0x51, 0x5A, 0x94, 0x75, 0x1D, 
	0x41, 0x03, 0x67, 0x4F, 0xF8, 0x82, 0xB6, 0xA4, 
	0xED, 0x6A, 0x63, 0xC6, 0x99, 0x10, 0xC0, 0xBC, 
	0x1F, 0x2A, 0xEF, 0xB7, 0x5B, 0x76, 0x51, 0x05, 
	0xD1, 0x66, 0x29, 0xF5, 0x81, 0x9F, 0xCC, 0x68, 
	0x2C, 0x72, 0xD6, 0x62, 0xAA, 0x4D, 0x63, 0x57, 
	0xD0, 0xED, 0xCF, 0x7C, 0x01, 0x2B, 0x25, 0x17, 
	0x09, 0xB6, 0x0C, 0x01, 0x4C, 0xE6, 0x7C, 0x92, 
	0x46, 0xF8, 0xE3, 0xFF, 0xB4, 0x83, 0x5B, 0x2D, 
	0xAF, 0x97, 0x54, 0x49, 0xEC, 0x65, 0x65, 0x31, 
	0xD8, 0xAD, 0x9E, 0x74, 0x1C, 0x47, 0xAB, 0x53, 
	0x4C, 0x2A, 0xE4, 0xBF, 0x7F, 0x4D, 0x85, 0xA8, 
	0x21, 0xD2, 0xED, 0x81, 0x1B, 0x88, 0xFB, 0x1D, 
	0xC1, 0x93, 0xA7, 0xE0, 0x47, 0x6E, 0xD9, 0xE3, 
	0x9B, 0x95, 0xEB, 0x60, 0xDA, 0x70, 0xAF, 0xCD, 
	0xBC, 0x9A, 0xD3, 0x80, 0xCA, 0x6A, 0x41, 0xCA, 
	0xAE, 0x63, 0x53, 0x50, 0xC4, 0xC5, 0xCA, 0xAE, 
	0x66, 0x87, 0xD5, 0x44, 0x30, 0x87, 0x5F, 0x71, 
	0x13, 0xAD, 0x47, 0xBA, 0xC7, 0x77, 0x42, 0xB7, 
	0xB7, 0xAD, 0x85, 0x5B, 0x78, 0xC1, 0xCF, 0x6C, 
	0xCE, 0xE1, 0x5A, 0x27, 0xA1, 0x3C, 0xA9, 0x91, 
	0x8E, 0x61, 0x85, 0x59, 0xE4, 0x7A, 0x10, 0x08, 
	0xA5, 0x3A, 0xB3, 0x77, 0xAC, 0x5A, 0x41, 0x87, 
	0x87, 0x2C, 0x95, 0xD7, 0x6A, 0xC0, 0xEE, 0x99, 
	0x6D, 0x55, 0x19, 0xDE, 0xFF, 0xED, 0xF8, 0x0C, 
	0xEA, 0x58, 0x6F, 0x16, 0x2C, 0xEC, 0xCF, 0xA2, 
	0x48, 0xB7, 0x15, 0x75, 0xF9, 0xB4, 0xDD, 0x18, 
	0x66, 0x17, 0x35, 0xC0, 0x58, 0xC5, 0x9D, 0x90, 
	0x79, 0xE0, 0x09, 0x0C, 0xFF, 0x71, 0x96, 0x79, 
	0xA4, 0x26, 0x2D, 0xFA, 0xE0, 0x56, 0xAA, 0x5E, 
	0x60, 0x7D, 0x28, 0x8E, 0x20, 0x4B, 0xCF, 0x29, 
	0xB7, 0xA6, 0x20, 0xEC, 0x4F, 0x0A, 0xDA, 0x1E, 
	0x41, 0x71, 0x84, 0xDE, 0xD4, 0x0F, 0x5D, 0x34, 
	0x82, 0xDD, 0x03, 0xD7, 0x3D, 0xD6, 0x2B, 0xB0, 
	0xD0, 0x1B, 0xC7, 0xB7, 0x2F, 0xE9, 0xFA, 0x47, 
	0x0A, 0x2A, 0x32, 0xC6, 0x0C, 0x66, 0xEF, 0xDB, 
	0x9C, 0x47, 0x82, 0x39, 0x4C, 0x9E, 0x95, 0x8C, 
	0xBF, 0xB6, 0xD2, 0x4C, 0x75, 0x83, 0x18, 0xEB, 
	0xA7, 0xA6, 0xFB, 0xDA, 0xB6, 0x6D, 0x89, 0x0C, 
	0x7E, 0x67, 0x5B, 0x9B, 0x2E, 0xA8, 0x96, 0x41, 
	0x1F, 0xF6, 0xB4, 0x74, 0x02, 0xFF, 0xD2, 0xD0, 
	0x8A, 0x73, 0x2F, 0x19, 0xB1, 0xA6, 0x3D, 0x25, 
	0xAB, 0x20, 0x40, 0xC6, 0xCC, 0x7C, 0x5B, 0x78, 
	0x0A, 0x12, 0x27, 0x9D, 0x6F, 0xC3, 0x07, 0x8D, 
	0xC9, 0x23, 0x31, 0xAA, 0x55, 0x31, 0xF7, 0x44, 
	0x18, 0xE6, 0xBD, 0x26, 0xE4, 0x0F, 0x76, 0xA7, 
	0x82, 0xEE, 0xB8, 0x70, 0xF8, 0x0F, 0x8E, 0xDD, 
	0xEA, 0x78, 0x87, 0x3C, 0x11, 0x1C, 0xBA, 0xF1, 
	0x54, 0x69, 0xF8, 0x1B, 0x7C, 0x31, 0x97, 0x3F, 
	0xBD, 0x2F, 0x51, 0xE3, 0x9B, 0x53, 0x28, 0x84, 
	0x1C, 0x90, 0x37, 0x22, 0x2D, 0x0C, 0xDA, 0x08, 
	0xB4, 0x4B, 0x05, 0x95, 0x2E, 0xB2, 0xAB, 0x73, 
	0xBC, 0x15, 0x88, 0x55, 0x29, 0xF6, 0xF6, 0x2B, 
	0x05, 0x71, 0x00, 0x25, 0x44, 0xDB, 0x16, 0x49, 
	0x9A, 0x75, 0xDA, 0x22, 0xFD, 0x63, 0x70, 0x31, 
	0xC2, 0xFD, 0xDB, 0x28, 0x89, 0xFC, 0xBE, 0x25, 
	0x77, 0xEC, 0x2E, 0x70, 0x76, 0xB7, 0xFF, 0xB4, 
	0x6D, 0xD7, 0x08, 0x55, 0x88, 0xC3, 0x07, 0x0F, 
	0x44, 0x78, 0x7F, 0x27, 0x21, 0x98, 0x45, 0xB3, 
	0x4E, 0x03, 0x8E, 0xB3, 0x28, 0x3F, 0x62, 0x96, 
	0x87, 0xF4, 0x2B, 0x3D, 0x5A, 0xA3, 0x84, 0x88, 
	0x87, 0xFF, 0xA7, 0xC1, 0x0D, 0x31, 0x88, 0x9F, 
	0xC4, 0xC8, 0xBE, 0xF3, 0x09, 0x41, 0xCC, 0xC0, 
	0x24, 0x50, 0x35, 0xD2, 0x66, 0xEA, 0xDA, 0x96, 
	0x16, 0x8E, 0x79, 0x7B, 0x9C, 0x0A, 0xED, 0x28, 
	0x24, 0x60, 0x79, 0xD9, 0x40, 0xB2, 0xAD, 0xC9, 
	0xE3, 0x50, 0xB7, 0xEA, 0x8E, 0x98, 0x57, 0x2E, 
	0x4F, 0x2C, 0xCE, 0x93, 0x1D, 0x5E, 0x02, 0x08, 
	0x36, 0x2F, 0xDE, 0xFF, 0xEA, 0x64, 0x8E, 0x8E, 
	0xF7, 0x2E, 0x5E, 0x08, 0xE0, 0x8D, 0xFA, 0xE4, 
	0x1A, 0xB1, 0x33, 0x68, 0x69, 0xB1, 0xA6, 0x90, 
	0xA9, 0x35, 0xBB, 0x4B, 0x6C, 0x1E, 0x44, 0xD4, 
	0x6F, 0x4B, 0xE0, 0xA2, 0x04, 0xB3, 0x03, 0xFF, 
	0x3E, 0xA8, 0x2A, 0xA6, 0x6B, 0xC5, 0x57, 0x9C, 
	0x0C, 0xDC, 0x82, 0x22, 0xB4, 0x46, 0x49, 0x3D, 
	0x39, 0x15, 0x0F, 0xED, 0x3B, 0x5C, 0xC5, 0xC4, 
	0x13, 0xAA, 0x61, 0xFD, 0x4E, 0x76, 0x3A, 0xAF, 
	0xB5, 0x4D, 0xA7, 0x70, 0x21, 0xB7, 0xB9, 0xF1, 
	0xC8, 0x23, 0x5D, 0x1D, 0x0C, 0xC1, 0x18, 0xA8, 
	0x51, 0xB3, 0xDE, 0xA5, 0xDE, 0xCD, 0x32, 0xCE, 
	0xC8, 0x24, 0xE0, 0x71, 0x7E, 0x72, 0xD5, 0x4E, 
	0xC5, 0x8D, 0x6E, 0xA5, 0x69, 0xB9, 0xDD, 0x44, 
	0x49, 0x75, 0x7C, 0xF7, 0xF6, 0x3A, 0x39, 0xE1, 
	0x98, 0x98, 0x73, 0xDD, 0x69, 0x88, 0x26, 0x33, 
	0x13, 0x84, 0x75, 0xCF, 0x54, 0x5B, 0x8E, 0xCD, 
	0xA7, 0x6A, 0xA3, 0x51, 0xAB, 0x9A, 0x98, 0x6C, 
	0xBA, 0xCB, 0xA2, 0x3F, 0xF0, 0x7E, 0xD7, 0x6D, 
	0xEA, 0x27, 0xEC, 0x7C, 0xD1, 0x85, 0x78, 0xAD, 
	0x24, 0x47, 0x7D, 0xB9, 0x45, 0xEF, 0x8D, 0x43, 

	/* Database Page 6 */

	0xFF, 0xC4, 0x74, 0x40, 0x87, 0xC4, 0x64, 0x96, 
	0x28, 0x97, 0xB9, 0x1D, 0x0E, 0x88, 0x69, 0x4E, 
	0x5A, 0x6D, 0x5E, 0x4F, 0xDD, 0xA7, 0xAF, 0x28, 
	0xFA, 0x95, 0xFA, 0x20, 0x73, 0x70, 0xF6, 0x86, 
	0xED, 0x03, 0x04, 0x64, 0x46, 0xA5, 0x26, 0xC4, 
	0x81, 0x40, 0x34, 0xF8, 0x1E, 0xB3, 0xF3, 0xC9, 
	0x5E, 0x96, 0x08, 0x26, 0x7D, 0xE6, 0x6A, 0x88, 
	0x0D, 0x90, 0x7F, 0x45, 0x30, 0x81, 0x52, 0x80, 
	0xCA, 0x12, 0x30, 0x19, 0xDA, 0x36, 0xF3, 0x27, 
	0x75, 0x52, 0xAD, 0x59, 0xF8, 0xD9, 0xE4, 0x6E, 
	0xE4, 0xB3, 0x2A, 0x24, 0xE2, 0xEF, 0x67, 0xB7, 
	0x89, 0x2B, 0xA9, 0xB5, 0xCA, 0x71, 0x2F, 0xBC, 
	0x47, 0x59, 0x92, 0xE7, 0x76, 0xC7, 0xEE, 0xAC, 
	0xB9, 0xAA, 0xC7, 0x32, 0x19, 0x03, 0x0D, 0x32, 
	0x5C, 0x51, 0xB9, 0xEE, 0x05, 0xF5, 0x36, 0x09, 
	0xDC, 0x9C, 0x1A, 0xC1, 0xB0, 0xEC, 0x17, 0x7E, 
	0x76, 0xFF, 0xF4, 0x1B, 0xEB, 0x7E, 0xDA, 0x38, 
	0x01, 0xD0, 0xCE, 0x6C, 0x85, 0x11, 0xE9, 0x10, 
	0xB6, 0x84, 0x90, 0x9B, 0xED, 0x08, 0x12, 0x48, 
	0x15, 0x44, 0xA0, 0xCF, 0x84, 0x46, 0x8E, 0x7D, 
	0x44, 0x48, 0x19, 0x4B, 0xBF, 0x1C, 0xC9, 0xD6, 
	0xF3, 0xEC, 0xE8, 0x18, 0xE8, 0x35, 0x0A, 0x86, 
	0x6B, 0x0A, 0x65, 0xBD, 0x93, 0x5D, 0x77, 0x59, 
	0x69, 0xEF, 0x5A, 0x9D, 0xD0, 0xFE, 0xDD, 0xA3, 
	0xCE, 0x75, 0xCB, 0x58, 0x90, 0xF7, 0x7A, 0x15, 
	0x8F, 0x1B, 0x1F, 0xB8, 0x91, 0xF9, 0xC2, 0x55, 
	0x5F, 0x39, 0xF2, 0x77, 0x88, 0xB3, 0xF7, 0x7F, 
	0x99, 0x3C, 0x54, 0x3C, 0x24, 0x1F, 0x39, 0xF4, 
	0x05, 0x9D, 0x2C, 0x3F, 0x8B, 0x03, 0x24, 0x21, 
	0x24, 0xDE, 0xDC, 0xDD, 0xBB, 0x38, 0xED, 0x6A, 
	0xA0, 0x98, 0x25, 0x32, 0x67, 0x36, 0x8D, 0x48, 
	0x06, 0xEE, 0x7D, 0xD4, 0xF2, 0x14, 0x95, 0xA5, 
	0xFA, 0x57, 0xFF, 0xF2, 0x54, 0xA9, 0xC1, 0xE3, 
	0x65, 0xD8, 0x88, 0x10, 0xF7, 0x24, 0x47, 0xDB, 
	0xF3, 0xA9, 0x73, 0x6E, 0x39, 0x56, 0x31, 0x89, 
	0x35, 0xD4, 0x8D, 0x50, 0x63, 0xDC, 0x1D, 0x65, 
	0xF4, 0xA6, 0xFA, 0x4A, 0xCA, 0x79, 0xCE, 0xF9, 
	0xE0, 0xE1, 0x21, 0xC4, 0xE1, 0x31, 0x77, 0x9E, 
	0x43, 0x4D, 0x0A, 0x2C, 0x15, 0xBE, 0x4D, 0x36, 
	0x27, 0xCC, 0xFD, 0x03, 0x51, 0x7F, 0x4F, 0x43, 
	0x09, 0x78, 0x66, 0xBE, 0x0E, 0xE0, 0x7B, 0xA4, 
	0x99, 0x96, 0x8C, 0xB1, 0xB7, 0x2F, 0x06, 0xF9, 
	0xFC, 0xEF, 0x0B, 0xB6, 0x22, 0xD0, 0x48, 0x45, 
	0x86, 0x30, 0x9B, 0xF6, 0xBF, 0x03, 0xB0, 0x87, 
	0x8E, 0xD3, 0x2D, 0xC4, 0x83, 0xEB, 0x7B, 0x31, 
	0x39, 0xBC, 0x7F, 0x33, 0x2B, 0xC4, 0x45, 0x26, 
	0x4F, 0x12, 0x54, 0xEA, 0xC6, 0x22, 0x8B, 0xB3, 
	0x3E, 0x31, 0x4A, 0xA7, 0x23, 0xC9, 0x47, 0xB7, 
	0xDD, 0x4C, 0x12, 0xFF, 0xDC, 0x75, 0xF0, 0xFD, 
	0x62, 0x14, 0xDA, 0x7A, 0xF5, 0xDC, 0xE2, 0xC0, 
	0x1A, 0x68, 0xFA, 0xC3, 0xAC, 0xB6, 0x2D, 0xBA, 
	0xB8, 0xEB, 0xC4, 0xF9, 0x6A, 0x30, 0xC5, 0x94, 
	0xE7, 0x5D, 0x75, 0x44, 0xCC, 0x22, 0x43, 0x10, 
	0x9D, 0x1F, 0x69, 0x00, 0x68, 0x04, 0x92, 0x0D, 
	0x7B, 0x06, 0xB8, 0x8E, 0x6F, 0x18, 0x5E, 0x7E, 
	0xE9, 0x96, 0x7B, 0xD2, 0xFD, 0xCF, 0x2E, 0x84, 
	0xEB, 0x7E, 0x17, 0xF5, 0x81, 0x43, 0xE9, 0x85, 
	0x05, 0xFF, 0xF1, 0xEA, 0x81, 0xEA, 0x19, 0x6A, 
	0x1A, 0xF5, 0x4E, 0xA0, 0x28, 0xDB, 0x22, 0xDD, 
	0xB8, 0xCA, 0x75, 0xBC, 0x43, 0x17, 0x82, 0xF8, 
	0xFD, 0x48, 0x38, 0x5D, 0x3B, 0xD3, 0x67, 0xD9, 
	0x10, 0x8D, 0xE1, 0x62, 0xF1, 0xE2, 0xDD, 0x1F, 
	0x44, 0x1A, 0x26, 0x09, 0x16, 0x90, 0x3B, 0x7D, 
	0xB7, 0x4B, 0xD0, 0x80, 0xFD, 0xA1, 0xA7, 0x51, 
	0x43, 0xD3, 0x4B, 0xD4, 0xFF, 0x6A, 0xCD, 0x98, 
	0x64, 0x66, 0x76, 0xCD, 0x06, 0x39, 0x0A, 0x25, 
	0xC5, 0x9A, 0x15, 0x8D, 0xF1, 0xF8, 0x2D, 0x7C, 
	0x85, 0x2F, 0xB1, 0xF8, 0xB5, 0x82, 0x60, 0x88, 
	0xC3, 0xD9, 0x94, 0x1A, 0x9A, 0x64, 0x29, 0x34, 
	0xCA, 0x8A, 0x1D, 0x71, 0x1C, 0x12, 0xF6, 0x5E, 
	0xF1, 0x4D, 0xD8, 0x9B, 0x6A, 0x81, 0x71, 0x48, 
	0xA4, 0xA2, 0xBC, 0x16, 0xB2, 0x27, 0x1B, 0x7F, 
	0x17, 0x2D, 0x29, 0xFA, 0xA3, 0xFE, 0xB9, 0xD3, 
	0x8A, 0x7C, 0xE7, 0xC3, 0x66, 0xD7, 0xA5, 0x26, 
	0x67, 0x24, 0xD6, 0x50, 0xC5, 0xFA, 0x16, 0x36, 
	0x24, 0x94, 0xF5, 0x79, 0x84, 0x81, 0x74, 0x34, 
	0xE0, 0x8A, 0x71, 0x29, 0x6C, 0xE1, 0x13, 0xCC, 
	0x96, 0x22, 0x8D, 0x9F, 0xB9, 0x50, 0xA6, 0xC9, 
	0x3F, 0x0C, 0xB0, 0x7A, 0xB7, 0xEB, 0x27, 0xBE, 
	0x3F, 0x48, 0xBC, 0x37, 0xCA, 0x82, 0x4E, 0x6C, 
	0x6E, 0xA6, 0x00, 0xFE, 0xC5, 0xFF, 0xC3, 0xC9, 
	0x1C, 0xEA, 0xED, 0x06, 0xA9, 0x3D, 0x7C, 0x2D, 
	0x52, 0x95, 0x80, 0x47, 0xB1, 0x04, 0x3E, 0xC4, 
	0x36, 0xAE, 0xB2, 0xDB, 0x6B, 0x76, 0xF9, 0xFE, 
	0x09, 0x10, 0x7B, 0xF3, 0x4D, 0xC9, 0x77, 0x8D, 
	0x68, 0x6D, 0x02, 0xAB, 0x53, 0xFA, 0x4B, 0xFE, 
	0x7E, 0x15, 0x88, 0x19, 0x48, 0x24, 0x82, 0xC8, 
	0x9D, 0x17, 0x49, 0x04, 0x8E, 0x8D, 0xDC, 0x62, 
	0xAB, 0x30, 0xA9, 0x0A, 0xED, 0x1F, 0xF6, 0xFA, 
	0x61, 0x1F, 0x0A, 0x30, 0x73, 0xB6, 0x03, 0xEA, 
	0xAB, 0x7E, 0x9B, 0xFB, 0xAB, 0x5B, 0x2E, 0x10, 
	0xAE, 0x60, 0xBF, 0x94, 0x01, 0x05, 0x8B, 0x5B, 
	0x11, 0xE4, 0x10, 0xE6, 0x6A, 0x86, 0x5E, 0xA3, 
	0x5D, 0xB5, 0x83, 0x62, 0xA9, 0x69, 0xB4, 0xC7, 
	0xD8, 0x86, 0xC0, 0x85, 0xE3, 0xCF, 0x84, 0x7A, 
	0x88, 0x55, 0x0E, 0x2F, 0x49, 0x48, 0x9C, 0xC5, 
	0x60, 0xCC, 0xC3, 0xB8, 0x66, 0xFF, 0xFF, 0x5F, 
	0xF5, 0xB7, 0x90, 0xD8, 0x02, 0xDF, 0x56, 0x9C, 
	0x06, 0x5A, 0x76, 0x9C, 0x2F, 0xC9, 0x1E, 0xFC, 
	0x80, 0x4B, 0x0D, 0x4F, 0x1C, 0x16, 0x38, 0xA1, 
	0x26, 0x07, 0xDC, 0x76, 0x59, 0xA8, 0x2E, 0x62, 
	0x6B, 0xDC, 0x7E, 0xED, 0xE8, 0x3C, 0x16, 0x03, 
	0x9B, 0x5F, 0x03, 0xA8, 0x43, 0x79, 0x4C, 0xDC, 
	0x4A, 0xF6, 0x8B, 0xAD, 0xB8, 0xBA, 0x13, 0x58, 
	0x8D, 0xA0, 0xED, 0xA2, 0xA1, 0xF9, 0xB2, 0x17, 
	0xB8, 0xD8, 0xFC, 0xED, 0x37, 0x6E, 0x78, 0x35, 
	0x19, 0xC4, 0x49, 0xAA, 0x87, 0x7A, 0x1E, 0x4E, 
	0x4E, 0xEC, 0x3C, 0x73, 0x08, 0xBF, 0x97, 0xC2, 
	0xD4, 0x4C, 0x91, 0x29, 0x7B, 0xEC, 0xB5, 0x0D, 
	0x76, 0x4A, 0x76, 0x62, 0xCE, 0x87, 0xA3, 0x53, 
	0x9B, 0x77, 0x92, 0xC7, 0xEC, 0xD5, 0xD4, 0x21, 
	0x21, 0x8A, 0xE2, 0x8C, 0x56, 0x14, 0xE5, 0x00, 
	0x1B, 0x24, 0x44, 0x14, 0x9B, 0xE7, 0x55, 0xFF, 
	0x40, 0x07, 0x48, 0x96, 0x54, 0xAF, 0x84, 0x66, 
	0x0F, 0x03, 0x12, 0x1F, 0x6C, 0xDC, 0x54, 0x57, 
	0x48, 0xFB, 0x47, 0xFB, 0x27, 0xC8, 0xBB, 0xAC, 
	0xFF, 0x43, 0xB6, 0xD4, 0xBB, 0x9A, 0x2F, 0x3B, 
	0x42, 0x3C, 0x8E, 0x19, 0x79, 0x12, 0x69, 0x77, 
	0x86, 0xE6, 0x59, 0x91, 0x75, 0xF1, 0x91, 0x49, 
	0x03, 0x9A, 0x13, 0xBF, 0x84, 0x5F, 0x94, 0xB1, 
	0xB0, 0xEF, 0x2B, 0xE1, 0x35, 0x52, 0xFB, 0x34, 
	0xEE, 0x73, 0xC4, 0x5E, 0x14, 0xB4, 0x48, 0xAD, 
	0x94, 0x3E, 0x21, 0x65, 0x0C, 0x1A, 0x13, 0x6B, 
	0xB0, 0x88, 0x92, 0x04, 0x86, 0x03, 0x70, 0xE5, 
	0xC4, 0xBD, 0x54, 0x6B, 0x4F, 0x48, 0xAC, 0xBB, 
	0x67, 0x56, 0xD6, 0x9E, 0x87, 0x53, 0xF7, 0x8D, 
	0xFC, 0xF5, 0xA5, 0x14, 0xB6, 0xFA, 0xF4, 0x56, 
	0xC0, 0xFD, 0x0A, 0xA8, 0xB9, 0x15, 0x1D, 0x2C, 
	0x2C, 0x4E, 0xA1, 0x3D, 0xFA, 0x68, 0x79, 0x9C, 
	0xFF, 0xE9, 0x48, 0xF9, 0xA7, 0x88, 0xA4, 0x26, 
	0x6D, 0x5D, 0x21, 0x41, 0xF7, 0x70, 0xCC, 0xEC, 
	0xEB, 0x14, 0xF9, 0xE2, 0x06, 0x40, 0xDD, 0x17, 
	0x34, 0x7C, 0x52, 0xC0, 0xCE, 0xBF, 0x5B, 0x6A, 
	0x96, 0xCC, 0xAA, 0xF5, 0x33, 0xBE, 0x92, 0x41, 
	0x1E, 0x7B, 0x81, 0x38, 0xB9, 0x2C, 0x25, 0x47, 
	0x13, 0xE6, 0x2C, 0xC3, 0x2B, 0x8C, 0x8B, 0xED, 
	0x2A, 0xD3, 0xE5, 0x01, 0x15, 0x8E, 0x25, 0x96, 
	0x0D, 0x4E, 0x52, 0xE6, 0xEC, 0x9D, 0x41, 0x67, 
	0xD0, 0x22, 0x38, 0xDA, 0xF0, 0x1C, 0x86, 0x2F, 
	0x7A, 0xF1, 0x31, 0xD2, 0x1A, 0x79, 0x3F, 0xC0, 
	0x5A, 0x2C, 0xFC, 0xFE, 0x80, 0x15, 0x24, 0xA9, 
	0xCB, 0xFC, 0xD7, 0xE9, 0x5D, 0x40, 0xC4, 0xCE, 
	0xEE, 0x00, 0xD8, 0xFB, 0x84, 0x85, 0x9C, 0x04, 
	0x60, 0x5E, 0xBF, 0x58, 0x93, 0xEA, 0x26, 0xC1, 
	0xD4, 0x35, 0xEF, 0xA7, 0xC1, 0x98, 0xA0, 0x5E, 
	0xC8, 0xFF, 0x5E, 0x86, 0x0C, 0x85, 0x89, 0xDB, 
	0x92, 0x77, 0xBD, 0x12, 0xFE, 0x44, 0x4F, 0xF5, 
	0xF0, 0x0E, 0x8D, 0x10, 0xF0, 0x77, 0x8F, 0x18, 
	0x73, 0x74, 0x21, 0x7A, 0xEA, 0xD0, 0xE0, 0x5E, 
	0xA1, 0xB1, 0xD8, 0x6E, 0xFC, 0xEC, 0x5C, 0x49, 
	0x6A, 0xD8, 0x1F, 0xD8, 0xC2, 0x38, 0x31, 0xB5, 
	0x56, 0xA0, 0x11, 0x26, 0x48, 0x54, 0x42, 0xE8, 
	0x5F, 0x57, 0x1A, 0xD4, 0xBD, 0x40, 0xC3, 0x50, 
	0x5D, 0xCF, 0xB3, 0x23, 0xB8, 0x45, 0x41, 0xC6, 
	0x36, 0xC2, 0xC2, 0xEC, 0x45, 0xD8, 0x36, 0xD7, 
	0x6F, 0x63, 0x74, 0xC6, 0x65, 0x50, 0x6E, 0x04, 
	0x67, 0x32, 0xC6, 0x6D, 0x75, 0x7D, 0x7E, 0xD3, 
	0x11, 0x47, 0x83, 0x5A, 0xB0, 0xAA, 0xCB, 0x44, 
	0xD0, 0xD6, 0x87, 0x23, 0xEF, 0x8A, 0x57, 0xC9, 
	0x72, 0x28, 0xF1, 0xE2, 0xFA, 0xE1, 0x39, 0xCC, 
	0x55, 0x2D, 0x97, 0x14, 0x82, 0x6C, 0x8B, 0xA0, 
	0x28, 0x66, 0xFF, 0xF2, 0x97, 0x6B, 0xB3, 0x4E, 
	0x1C, 0x25, 0x12, 0x15, 0x4E, 0xDC, 0x12, 0xDC, 
	0x26, 0x0B, 0xFF, 0x7D, 0xDF, 0xDE, 0xF5, 0x6F, 
	0xFE, 0x4C, 0x9C, 0x74, 0xEA, 0x6E, 0xA4, 0x61, 
	0xAD, 0x9C, 0xC8, 0x63, 0xFA, 0x86, 0xF5, 0x6E, 
	0x63, 0x3B, 0xAE, 0xD5, 0xE7, 0x90, 0xE6, 0x73, 
	0xBE, 0x61, 0x91, 0x3B, 0x73, 0xAC, 0x48, 0x4A, 
	0xCA, 0x3A, 0x5C, 0xF8, 0x87, 0xC5, 0x60, 0x44, 
	0xF5, 0x6F, 0x9F, 0xFC, 0x15, 0x66, 0xC1, 0x27, 
	0x1B, 0x02, 0xBA, 0xAD, 0xCF, 0x70, 0x99, 0x23, 
	0x09, 0xBB, 0x57, 0x9B, 0xE4, 0xD5, 0xA2, 0x3D, 
	0x80, 0x7D, 0x55, 0xCC, 0x3F, 0xF6, 0xB2, 0x23, 
	0x35, 0x3F, 0xF5, 0x7D, 0xB6, 0x7C, 0xEC, 0x8B, 
	0x8F, 0x11, 0xF7, 0x6D, 0x98, 0x93, 0x97, 0x83, 
	0x82, 0x61, 0xE7, 0x97, 0x4A, 0x70, 0x37, 0x91, 
	0x50, 0x9F, 0xDC, 0x00, 0x6B, 0x03, 0xB7, 0x46, 
	0xD8, 0xB2, 0xF1, 0xFF, 0x2D, 0xF1, 0xEE, 0x62, 
	0xAC, 0x7E, 0xC9, 0xC0, 0xC1, 0x4A, 0x41, 0x62, 
	0xE3, 0x68, 0xC8, 0xAD, 0x43, 0xE1, 0x92, 0xA6, 
	0xAB, 0xD4, 0xAB, 0x2B, 0x1F, 0xFA, 0xE8, 0x13, 
	0xA8, 0xE0, 0x68, 0x4F, 0xC0, 0x5A, 0x17, 0x13, 
	0x18, 0x94, 0xE5, 0x2A, 0x16, 0xA6, 0x04, 0x43, 
	0x81, 0xFB, 0x50, 0x5D, 0xC2, 0x33, 0x8F, 0x5A, 
	0xE0, 0x00, 0x9E, 0x10, 0xE8, 0x6A, 0x3F, 0x18, 
	0x62, 0x16, 0x16, 0x8C, 0x64, 0x23, 0xA0, 0x5A, 
	0x31, 0x9D, 0x6A, 0x67, 0x12, 0x91, 0x12, 0xF0, 
	0x70, 0x13, 0x1A, 0x2C, 0x81, 0xC7, 0xF3, 0xB5, 
	0xEA, 0xFE, 0x49, 0xB2, 0xAC, 0x0C, 0x88, 0x29, 
	0xA5, 0x1A, 0xA5, 0xB7, 0x0D, 0x1E, 0xB0, 0x38, 
	0xAF, 0x53, 0xEB, 0x87, 0x2C, 0x34, 0x48, 0x0B, 
	0xAA, 0x3D, 0x19, 0x0C, 0x24, 0xD2, 0x7B, 0x76, 
	0xAD, 0xF6, 0x0A, 0x49, 0x10, 0xD6, 0x9E, 0xD2, 
	0x70, 0x17, 0xBB, 0xB7, 0xFF, 0x7F, 0x7F, 0x2D, 
	0x72, 0xCE, 0x74, 0x17, 0x55, 0xCC, 0x6F, 0x73, 
	0x8F, 0x2D, 0xC6, 0xBC, 0xD7, 0xB8, 0x41, 0x25, 
	0x99, 0x65, 0xC7, 0x83, 0xB9, 0x19, 0x56, 0x4B, 
	0xEA, 0x94, 0x62, 0x92, 0x83, 0x68, 0x0B, 0xD2, 
	0x5B, 0x73, 0x64, 0xCF, 0x51, 0x25, 0xC7, 0xCD, 
	0x11, 0x95, 0xB5, 0xBA, 0xCC, 0x2D, 0x97, 0xDD, 
	0xC2, 0x66, 0x9B, 0x85, 0x49, 0x2A, 0xB7, 0x13, 
	0x5F, 0x47, 0x1C, 0x19, 0xF7, 0x21, 0x1E, 0x39, 
	0x00, 0x62, 0x42, 0x7F, 0xA8, 0xDE, 0xF2, 0x6B, 
	0xEC, 0x45, 0xD5, 0xBB, 0xB0, 0xBC, 0x43, 0x86, 
	0xD5, 0x3F, 0xF9, 0x3C, 0x0E, 0xBD, 0x1F, 0x85, 
	0x5D, 0x43, 0x17, 0xF1, 0x0F, 0xB8, 0x19, 0xAD, 
	0x3A, 0x99, 0x39, 0x16, 0xE0, 0xFE, 0xCF, 0x43, 
	0x58, 0x00, 0x86, 0xCA, 0xA4, 0x17, 0x51, 0xBC, 
	0x4B, 0xEE, 0xEA, 0xAE, 0x68, 0x57, 0x3D, 0x45, 
	0x96, 0xEF, 0xC8, 0xA8, 0x17, 0xFF, 0xA9, 0x09, 
	0xBD, 0xF8, 0xB9, 0xB5, 0x88, 0x7F, 0x6B, 0x9C, 
	0x98, 0x5C, 0x76, 0x6E, 0x52, 0xDF, 0xBB, 0xD0, 
	0xD7, 0xFE, 0x51, 0xBB, 0x42, 0xE2, 0x3C, 0xD9, 
	0xE9, 0x05, 0x19, 0x5E, 0x59, 0x8C, 0x39, 0xDF, 
	0xC1, 0x63, 0x45, 0x8E, 0x2E, 0x9C, 0xA1, 0xE2, 
	0x24, 0xAA, 0x4F, 0x68, 0x3B, 0xA4, 0x14, 0x42, 
	0xAD, 0x8D, 0x4E, 0xF2, 0x04, 0xB9, 0x03, 0x9F, 
	0xC8, 0x6B, 0xBE, 0x25, 0xDA, 0x45, 0x2C, 0x9C, 
	0x6C, 0x58, 0x87, 0xAF, 0xC3, 0x0F, 0x0B, 0xA9, 
	0xC0, 0x01, 0x43, 0xB1, 0x79, 0x74, 0x37, 0xE5, 
	0xC5, 0xD1, 0x59, 0x1D, 0x05, 0x37, 0xE8, 0x51, 
	0x15, 0x54, 0x43, 0x9A, 0x78, 0xE2, 0xDB, 0x25, 
	0x9C, 0x3D, 0x24, 0xD7, 0xD7, 0xCC, 0x0A, 0x5D, 
	0x64, 0xBA, 0xB4, 0xF1, 0xB4, 0xBE, 0xA6, 0xD3, 
	0x2B, 0x59, 0xEB, 0xA6, 0xBC, 0x59, 0x46, 0x8C, 
	0x0E, 0x23, 0x9A, 0x64, 0xCC, 0xE8, 0xFF, 0xE5, 
	0x72, 0xED, 0x12, 0xFB, 0xCB, 0x05, 0x53, 0x00, 
	0xD2, 0x1C, 0x1E, 0x10, 0x99, 0x85, 0xDC, 0x7D, 
	0x88, 0x89, 0x31, 0xD1, 0x87, 0x3A, 0x5F, 0xA5, 
	0x7C, 0xD6, 0x87, 0x44, 0x58, 0x10, 0x2D, 0x08, 
	0xEE, 0x8E, 0xDC, 0xE1, 0xD8, 0xCB, 0x3B, 0x9E, 
	0x24, 0x77, 0x48, 0x3A, 0xC6, 0x78, 0xDB, 0xE5, 
	0x11, 0x25, 0x62, 0x4D, 0x13, 0xA0, 0xE2, 0x84, 
	0x41, 0xDA, 0x59, 0x6A, 0x84, 0xC7, 0x60, 0x1C, 
	0x6D, 0x60, 0xEE, 0x77, 0x07, 0x1E, 0x5C, 0xC0, 
	0x7F, 0x6E, 0x34, 0x0C, 0x2B, 0x50, 0x16, 0x6A, 
	0xA5, 0x35, 0x16, 0x45, 0xB3, 0x73, 0x41, 0x03, 
	0xDE, 0xFE, 0xFE, 0x74, 0x73, 0x72, 0xAD, 0x32, 
	0x37, 0x88, 0x51, 0x47, 0xE1, 0x48, 0x73, 0xB4, 
	0xD5, 0x26, 0xDE, 0x72, 0xF2, 0x25, 0x97, 0x5A, 
	0xA1, 0xCE, 0x82, 0x88, 0x17, 0x2F, 0xC0, 0xF4, 
	0xFA, 0x60, 0x8B, 0x9A, 0xB9, 0x45, 0x87, 0xFF, 
	0xF6, 0xA3, 0x03, 0x2E, 0xB2, 0xF4, 0xFD, 0x8C, 
	0x74, 0xCA, 0x8F, 0xE3, 0xBA, 0x06, 0x68, 0x48, 
	0x25, 0x4B, 0x79, 0x5E, 0x4C, 0x1B, 0x01, 0x1E, 
	0x78, 0x81, 0x00, 0x93, 0xCE, 0x75, 0x6D, 0xBC, 
	0x35, 0x80, 0xC4, 0x18, 0xDC, 0xEB, 0x79, 0x00, 
	0xC8, 0x68, 0x5B, 0xFC, 0xBE, 0xD6, 0x21, 0x53, 
	0xA2, 0xA6, 0x7F, 0xDA, 0xDB, 0x25, 0x71, 0x6F, 
	0x80, 0x1A, 0xD4, 0x26, 0x02, 0x86, 0xDF, 0xC2, 
	0xEB, 0x82, 0x51, 0xA4, 0xD9, 0xD9, 0x03, 0x9A, 
	0x36, 0x85, 0xCE, 0xED, 0x58, 0x3C, 0xED, 0x3D, 
	0xF1, 0xF4, 0x83, 0x83, 0x4E, 0x51, 0x31, 0xE3, 
	0xCB, 0x3C, 0xB8, 0x10, 0x53, 0x5E, 0x38, 0x75, 
	0x67, 0xCE, 0x85, 0x86, 0xCA, 0x55, 0xB0, 0x2F, 
	0x29, 0x0D, 0x5A, 0xDB, 0x05, 0x72, 0x78, 0xEA, 
	0xE9, 0x8B, 0x61, 0x82, 0x08, 0x8F, 0x40, 0x29, 
	0xCA, 0xB0, 0x21, 0xB5, 0x6D, 0x70, 0x4A, 0xF4, 

	/* Database Page 7 */

	0xFF, 0x8F, 0xEB, 0x68, 0x51, 0x49, 0xAF, 0xB3, 
	0x68, 0xAF, 0xF6, 0x7F, 0x94, 0x74, 0x1E, 0x36, 
	0x41, 0x01, 0x27, 0x85, 0xC1, 0xED, 0xC0, 0x27, 
	0xFA, 0x15, 0x59, 0xF6, 0x48, 0x73, 0x9E, 0xBE, 
	0x5B, 0x1A, 0x4E, 0x29, 0x44, 0x5B, 0xF8, 0x00, 
	0x34, 0x7D, 0xBC, 0x72, 0x6A, 0x09, 0xEF, 0x78, 
	0x16, 0xBA, 0xF7, 0xFB, 0x47, 0xAB, 0x36, 0x9E, 
	0x2F, 0x3D, 0x2E, 0x46, 0x39, 0x6C, 0x25, 0x62, 
	0x2B, 0x29, 0x8C, 0x65, 0x7F, 0x88, 0xCE, 0x7A, 
	0x0C, 0x14, 0xED, 0x67, 0xC7, 0x6C, 0x6D, 0xB0, 
	0xEA, 0xC9, 0x7C, 0x9A, 0x6C, 0x19, 0xDB, 0xD7, 
	0x88, 0x37, 0x67, 0x8B, 0xDE, 0x93, 0x38, 0x8D, 
	0x85, 0xCD, 0xC0, 0xB3, 0xB5, 0xB8, 0x2C, 0xBB, 
	0x06, 0xCE, 0x7F, 0x4A, 0x96, 0xD8, 0x2D, 0x04, 
	0x69, 0xFE, 0xC8, 0x3A, 0xD0, 0x7B, 0x2E, 0x65, 
	0x46, 0x14, 0x8E, 0x0E, 0x62, 0x97, 0x49, 0x83, 
	0x4C, 0xFF, 0x92, 0x67, 0x67, 0x5B, 0x57, 0x15, 
	0xD5, 0x5E, 0x33, 0x73, 0xBF, 0xFE, 0xFE, 0xD3, 
	0x72, 0xBD, 0x19, 0x46, 0xC9, 0x99, 0x23, 0x80, 
	0x05, 0xCA, 0xF7, 0x3C, 0x3E, 0x18, 0xDF, 0xBC, 
	0x85, 0x65, 0x2F, 0xE3, 0x5F, 0xF1, 0x52, 0xED, 
	0x2A, 0x75, 0x52, 0x37, 0xEA, 0x8D, 0x1D, 0x15, 
	0x73, 0x60, 0xD7, 0x48, 0x45, 0x7B, 0x7D, 0x59, 
	0x73, 0xE6, 0x31, 0xA5, 0xF9, 0x8D, 0x7C, 0xEF, 
	0x1E, 0x44, 0x87, 0x5B, 0x8A, 0x07, 0xC4, 0x89, 
	0xDB, 0x9E, 0xE0, 0xD3, 0x67, 0xF8, 0xD5, 0x31, 
	0xAD, 0x8F, 0xD2, 0xBE, 0xAF, 0xE5, 0x2E, 0xC1, 
	0xD9, 0x63, 0x4D, 0xF8, 0x77, 0xB5, 0xF4, 0x18, 
	0xD4, 0xE1, 0x69, 0x78, 0xF6, 0x2D, 0x48, 0xD3, 
	0x97, 0x74, 0x2E, 0x78, 0xD6, 0xAE, 0xF5, 0xBF, 
	0x10, 0xB9, 0x71, 0x8E, 0xC7, 0x3C, 0xA8, 0x0F, 
	0xBC, 0x89, 0xCB, 0x3D, 0xBF, 0xAB, 0x18, 0x86, 
	0x0F, 0x12, 0xFF, 0xCB, 0xE8, 0x0F, 0x98, 0xBE, 
	0x94, 0x5E, 0x5B, 0x8E, 0xAB, 0x64, 0xFE, 0xDC, 
	0xA5, 0x5C, 0x50, 0x38, 0xA2, 0xB4, 0x96, 0xA3, 
	0x59, 0x65, 0xC9, 0x48, 0x71, 0xEC, 0xD2, 0xB5, 
	0x40, 0x9A, 0x7E, 0xD5, 0xFE, 0xEE, 0xDA, 0xA9, 
	0xF1, 0xD9, 0x61, 0x60, 0x87, 0x5E, 0x97, 0x1A, 
	0xD9, 0x5A, 0xD8, 0xB4, 0x39, 0xD7, 0x4B, 0x7B, 
	0xC6, 0x99, 0x75, 0x6B, 0x82, 0x9B, 0x47, 0xBF, 
	0x43, 0xE8, 0xA8, 0x6D, 0x9C, 0x78, 0x4A, 0x35, 
	0xEF, 0x10, 0x53, 0x6E, 0x70, 0x5E, 0xDD, 0xE7, 
	0x15, 0x59, 0xCD, 0x1F, 0xCC, 0x01, 0x70, 0xD5, 
	0xB9, 0xDA, 0x5A, 0x80, 0xCE, 0xEE, 0x73, 0x23, 
	0xA8, 0x77, 0xC1, 0x17, 0x1B, 0x0B, 0xD1, 0xB1, 
	0x79, 0x60, 0xD4, 0x53, 0x81, 0x07, 0x34, 0xEE, 
	0xD1, 0x0E, 0xCF, 0x2D, 0x32, 0x95, 0x1B, 0x5C, 
	0xF5, 0x0C, 0x7E, 0xAB, 0x81, 0x24, 0x78, 0x87, 
	0xEF, 0x87, 0x45, 0xFF, 0x43, 0xFE, 0x9B, 0xF2, 
	0x96, 0x6B, 0x98, 0xB8, 0xFC, 0x5C, 0x7C, 0xAC, 
	0x9B, 0xF2, 0x92, 0xDA, 0x66, 0x4D, 0x82, 0x06, 
	0x2F, 0x7F, 0xEA, 0x70, 0x01, 0x0B, 0xD8, 0xB2, 
	0x27, 0x58, 0x51, 0xDC, 0x17, 0x2D, 0x6C, 0xF9, 
	0xE9, 0xBA, 0x71, 0x72, 0x19, 0xB3, 0x8C, 0x48, 
	0xD9, 0x4D, 0x18, 0x78, 0x5C, 0xFB, 0x88, 0xCD, 
	0x01, 0x93, 0x66, 0xE3, 0xE7, 0x2E, 0xB5, 0x1C, 
	0xDE, 0x70, 0x2C, 0x60, 0x6B, 0xA1, 0x07, 0x95, 
	0x34, 0x22, 0x1A, 0x24, 0xD0, 0x88, 0x19, 0xCE, 
	0x92, 0xFA, 0xA7, 0xE5, 0x95, 0x1B, 0x09, 0x12, 
	0xE1, 0x7B, 0xAE, 0x84, 0xA1, 0xCE, 0xB7, 0xCC, 
	0x08, 0x1C, 0x4A, 0x22, 0xF7, 0x08, 0xAF, 0xF8, 
	0x36, 0x62, 0xD2, 0x99, 0x7D, 0x8F, 0xFA, 0xB8, 
	0x6D, 0xC5, 0xE8, 0x0D, 0x12, 0x70, 0xCC, 0xF8, 
	0x92, 0x2D, 0xD5, 0x6A, 0x01, 0xB1, 0x4F, 0x16, 
	0xE5, 0xF5, 0x81, 0xBA, 0xFF, 0x54, 0x3C, 0x63, 
	0x22, 0x4F, 0x7A, 0x7E, 0x97, 0x8B, 0x0D, 0x91, 
	0x38, 0xC5, 0x38, 0xF3, 0xC6, 0x43, 0xEF, 0x1E, 
	0x3B, 0x32, 0x63, 0x23, 0x14, 0xF9, 0xC6, 0xF7, 
	0xD3, 0x81, 0x1E, 0x9F, 0xA8, 0xBA, 0xCE, 0xF5, 
	0xF2, 0x97, 0x71, 0x9F, 0x53, 0x4B, 0xFD, 0xF4, 
	0x2D, 0x62, 0x32, 0x22, 0x6A, 0xE9, 0x51, 0x04, 
	0x6A, 0x09, 0x54, 0x12, 0xE0, 0x25, 0xAF, 0x3D, 
	0x5B, 0xEA, 0x9F, 0x07, 0x19, 0x62, 0x55, 0x16, 
	0x03, 0x66, 0x3F, 0x1D, 0x2E, 0xBB, 0x5E, 0x2F, 
	0x86, 0x73, 0x0B, 0x2F, 0x69, 0x20, 0xF6, 0x62, 
	0xA9, 0x07, 0x1B, 0x5D, 0xDB, 0x09, 0x3F, 0xC7, 
	0xCB, 0x49, 0xEE, 0x57, 0x5F, 0x24, 0xA1, 0x77, 
	0xCB, 0xF3, 0x80, 0x2B, 0x33, 0xD0, 0x9B, 0x0E, 
	0x9D, 0x5C, 0x22, 0xDE, 0x66, 0x6F, 0x5C, 0x9A, 
	0x41, 0x6D, 0xF6, 0x54, 0xC8, 0xD4, 0x2F, 0x2B, 
	0xFC, 0xC6, 0x76, 0xF7, 0x80, 0xFF, 0xFA, 0xA7, 
	0x5C, 0xA0, 0x0D, 0x4D, 0x69, 0x7C, 0x7B, 0x41, 
	0xCD, 0x7F, 0x3B, 0xA0, 0x1B, 0x71, 0x23, 0xDA, 
	0x16, 0x05, 0x83, 0xD5, 0xA3, 0x48, 0x23, 0xAD, 
	0xB0, 0xBE, 0xFE, 0xB6, 0x58, 0x62, 0x81, 0x96, 
	0xBA, 0xED, 0x32, 0xDD, 0xC6, 0x0C, 0xFB, 0x51, 
	0x4E, 0xBD, 0x3C, 0x37, 0x69, 0x3B, 0xF5, 0x5A, 
	0xBE, 0xDD, 0xEB, 0xFD, 0x2A, 0xE9, 0x0E, 0xE8, 
	0xA3, 0x45, 0xDE, 0x86, 0xD9, 0x49, 0x77, 0xC4, 
	0x5D, 0xDF, 0x56, 0xC5, 0xDD, 0x99, 0xC0, 0x98, 
	0xA2, 0x85, 0xEE, 0xB2, 0x7F, 0x01, 0x32, 0x07, 
	0xD6, 0x75, 0xA8, 0x91, 0x2B, 0xF1, 0x20, 0xAB, 
	0x86, 0x98, 0x37, 0x37, 0x29, 0xC0, 0x21, 0xB5, 
	0x00, 0xA8, 0x14, 0x7B, 0xBF, 0x76, 0x97, 0x13, 
	0x3E, 0xF1, 0x7C, 0x42, 0xFA, 0x31, 0x1C, 0x6A, 
	0xAC, 0xAF, 0x41, 0xDE, 0x58, 0x31, 0x97, 0xF4, 
	0x36, 0x19, 0x70, 0x5A, 0xF4, 0xDA, 0xFF, 0xB9, 
	0xC5, 0x57, 0xCA, 0xFE, 0xF7, 0x93, 0x5B, 0x41, 
	0x4B, 0xCC, 0x41, 0x75, 0x6F, 0xD5, 0xDD, 0xD6, 
	0x67, 0x81, 0xFE, 0xF4, 0x44, 0x04, 0xD6, 0x75, 
	0x05, 0xAC, 0x71, 0x49, 0xEC, 0x0D, 0x90, 0xF9, 
	0x22, 0xAC, 0x7F, 0xBF, 0x1C, 0xE0, 0x00, 0x70, 
	0x07, 0x93, 0x31, 0x48, 0x86, 0x3C, 0x7D, 0xFA, 
	0xF8, 0xAE, 0x51, 0xC1, 0xD3, 0x83, 0xE2, 0xAC, 
	0x99, 0xA2, 0x28, 0xA9, 0xEA, 0x05, 0x43, 0xFC, 
	0xF4, 0x84, 0x68, 0xD4, 0xF4, 0xE0, 0x27, 0x6F, 
	0x2C, 0xDC, 0x65, 0x27, 0xBC, 0x70, 0x54, 0xBE, 
	0x64, 0x1C, 0x29, 0x41, 0x77, 0x3F, 0x3B, 0x20, 
	0xBC, 0x51, 0xCC, 0x57, 0xC1, 0xEC, 0xDF, 0x70, 
	0x27, 0x0A, 0xBD, 0x72, 0x1F, 0x0B, 0x42, 0x8E, 
	0xDA, 0xC5, 0xBC, 0xFC, 0x77, 0xAB, 0x26, 0xE8, 
	0x65, 0x3D, 0x28, 0x0D, 0x8B, 0x1E, 0x6E, 0xE0, 
	0xC9, 0xFF, 0x88, 0x6C, 0x41, 0x40, 0x16, 0xFF, 
	0x90, 0x23, 0x61, 0x63, 0xED, 0xB9, 0xA0, 0xFD, 
	0x13, 0xDE, 0xF7, 0x69, 0x1F, 0x49, 0x35, 0x3E, 
	0x3C, 0xD8, 0xF8, 0x3B, 0xAE, 0x42, 0xBB, 0xED, 
	0x76, 0x03, 0x0C, 0x8C, 0xAE, 0x29, 0xE2, 0xCC, 
	0xAA, 0x96, 0xEA, 0x38, 0x49, 0x8C, 0xC8, 0xE3, 
	0xFC, 0x15, 0x6F, 0x1D, 0xCF, 0x63, 0xCC, 0xE8, 
	0xB4, 0xD6, 0x94, 0x88, 0x57, 0xD5, 0xD8, 0xA8, 
	0x5A, 0x35, 0x5D, 0x0F, 0xEC, 0x06, 0x80, 0x1B, 
	0xDB, 0x4E, 0xC6, 0x0F, 0xA9, 0xA4, 0x1D, 0x51, 
	0x61, 0x06, 0x10, 0x38, 0x5F, 0xC0, 0x8E, 0x26, 
	0x62, 0x1B, 0xE7, 0xD9, 0x91, 0xF0, 0x76, 0xA6, 
	0xF6, 0x65, 0xBD, 0x99, 0x42, 0x84, 0x9D, 0x84, 
	0xBB, 0x82, 0x4E, 0x61, 0x59, 0x3B, 0xE3, 0x98, 
	0x54, 0x26, 0x6D, 0x92, 0x50, 0x79, 0x25, 0x50, 
	0xB0, 0xE6, 0x6F, 0xFF, 0xFA, 0x2D, 0x5F, 0xFC, 
	0xFF, 0x34, 0xD2, 0x47, 0xA0, 0x8D, 0x94, 0x36, 
	0xFF, 0xE4, 0x02, 0x7C, 0x2E, 0x23, 0xAF, 0x65, 
	0xFD, 0x20, 0xAB, 0xA8, 0x93, 0xDD, 0x35, 0xD0, 
	0xA5, 0x5E, 0x31, 0x29, 0x58, 0x6D, 0x8B, 0x07, 
	0xCF, 0x0D, 0x46, 0x67, 0x79, 0xAA, 0x7E, 0x9C, 
	0x25, 0xEF, 0x3F, 0xB4, 0x3D, 0x90, 0xFE, 0x2F, 
	0xFB, 0x2F, 0x55, 0x37, 0x4D, 0xE6, 0x24, 0xE5, 
	0x1E, 0x68, 0xA0, 0x80, 0x4F, 0x6C, 0xA7, 0x35, 
	0x29, 0x7B, 0xE4, 0x18, 0xED, 0x44, 0xC6, 0x25, 
	0x5D, 0x49, 0x16, 0xDA, 0x9E, 0x5F, 0x88, 0x73, 
	0xE1, 0x03, 0x47, 0x0B, 0x2E, 0xCA, 0x50, 0x62, 
	0x31, 0xC6, 0x8E, 0xFE, 0x5B, 0xD6, 0x54, 0xA1, 
	0xC0, 0x5D, 0x6E, 0x84, 0xD3, 0xD7, 0x6B, 0x9B, 
	0xDD, 0x2F, 0x8A, 0x4C, 0x83, 0x0A, 0x31, 0x8A, 
	0x90, 0x2B, 0x3A, 0x07, 0x01, 0xA9, 0x67, 0xA5, 
	0x64, 0xEA, 0x33, 0x81, 0x59, 0x3A, 0x87, 0x53, 
	0x03, 0x89, 0xD5, 0x8C, 0x1C, 0x44, 0xA1, 0x7C, 
	0x24, 0xFF, 0x4A, 0x93, 0x18, 0x4D, 0x37, 0x8F, 
	0xBB, 0x2D, 0x57, 0xCC, 0x48, 0x65, 0x74, 0x3F, 
	0xB3, 0x5D, 0xF9, 0x7B, 0xA1, 0xBF, 0x85, 0x6C, 
	0x1E, 0x37, 0xD3, 0x8F, 0x4F, 0x60, 0x40, 0x49, 
	0xB0, 0x13, 0x57, 0x2B, 0xC1, 0xAB, 0x58, 0x60, 
	0xB2, 0x96, 0x75, 0x9C, 0xA1, 0x0E, 0x32, 0x29, 
	0x3C, 0x07, 0xC6, 0x34, 0x27, 0xF7, 0xC4, 0x00, 
	0x26, 0x0D, 0xC3, 0x2B, 0x19, 0xAE, 0xEC, 0xEE, 
	0xFF, 0x05, 0x60, 0x1D, 0x8A, 0xC4, 0x3E, 0x2F, 
	0xFF, 0xB0, 0x02, 0xEF, 0xDB, 0xE3, 0xDA, 0x15, 
	0x5D, 0x4C, 0xDD, 0xC6, 0xEF, 0xF0, 0x36, 0xE8, 
	0x2D, 0x99, 0x26, 0x62, 0x1D, 0x21, 0x6E, 0x2D, 
	0x91, 0x7C, 0xBA, 0x44, 0x87, 0xCD, 0x33, 0xC3, 
	0xEF, 0x70, 0xD9, 0xB0, 0xF2, 0x6B, 0x13, 0xE9, 
	0xB7, 0xE4, 0xAA, 0x4D, 0xE1, 0xDC, 0x24, 0x68, 
	0x89, 0xC5, 0x29, 0x8B, 0xDA, 0xE1, 0x74, 0x7B, 
	0xD4, 0x79, 0xFF, 0x49, 0x59, 0x40, 0xF8, 0x17, 
	0x8D, 0x38, 0xEC, 0x03, 0x30, 0x68, 0x3A, 0x52, 
	0x40, 0x09, 0x0F, 0x40, 0x74, 0x1A, 0xB6, 0xF1, 
	0xBF, 0xC6, 0xF8, 0x70, 0xA3, 0x79, 0xBE, 0xA2, 
	0xC1, 0x13, 0x5B, 0x71, 0x7B, 0xB8, 0x44, 0xA6, 
	0x60, 0xB6, 0x63, 0xE2, 0x13, 0x09, 0x50, 0x1B, 
	0xCD, 0xA8, 0xBA, 0x57, 0xF6, 0x63, 0x63, 0x4A, 
	0x5E, 0xD3, 0xD7, 0xE7, 0xC8, 0x22, 0x95, 0x88, 
	0xCD, 0x42, 0xE8, 0xC8, 0x39, 0x6C, 0xE2, 0xAA, 
	0xAF, 0x64, 0xC7, 0x0D, 0xB9, 0xCC, 0xC8, 0x0D, 
	0xDD, 0xA5, 0x19, 0xCA, 0x45, 0x33, 0x1B, 0x43, 
	0x2B, 0x38, 0xA1, 0x37, 0x73, 0x75, 0xBE, 0x72, 
	0x77, 0xBB, 0xA5, 0x1A, 0x3F, 0x30, 0xCC, 0x79, 
	0xAD, 0xF3, 0x38, 0xD0, 0xA5, 0x8E, 0xFA, 0xBC, 
	0x91, 0x59, 0x6A, 0x22, 0x75, 0x32, 0xA9, 0x4E, 
	0xD1, 0x75, 0x7A, 0x15, 0x4D, 0xB5, 0x96, 0xF8, 
	0xB9, 0x9D, 0x42, 0xFF, 0x25, 0xF7, 0x69, 0xCC, 
	0x32, 0xD6, 0xEF, 0xBA, 0x69, 0x27, 0x02, 0xD2, 
	0xCB, 0x2B, 0x6F, 0xB3, 0xDB, 0x55, 0x7C, 0x19, 
	0x30, 0x14, 0xA6, 0xA3, 0x9B, 0xCB, 0xC7, 0xD3, 
	0x91, 0x62, 0xC0, 0x9E, 0x6D, 0x95, 0x74, 0xD6, 
	0xCC, 0x50, 0xFE, 0x4F, 0x51, 0x54, 0xE2, 0xB9, 
	0xC4, 0xFA, 0xA3, 0x78, 0x59, 0xC7, 0x1E, 0x69, 
	0xC5, 0xFE, 0xE4, 0x05, 0x23, 0xB1, 0xB9, 0xCE, 
	0x45, 0x12, 0x7B, 0x10, 0xCE, 0x07, 0x05, 0xBA, 
	0xBE, 0x34, 0xFE, 0x7C, 0x15, 0x6B, 0x01, 0xD2, 
	0xC8, 0x80, 0xC9, 0x80, 0x92, 0x81, 0x3F, 0xEE, 
	0x0C, 0x58, 0x6D, 0x6E, 0x22, 0x19, 0x40, 0xD5, 
	0x52, 0x4C, 0x11, 0x84, 0x6D, 0xE7, 0x6F, 0x73, 
	0x12, 0xB0, 0x4D, 0x7C, 0x1E, 0x45, 0x68, 0x52, 
	0x5F, 0xCB, 0x3C, 0xBE, 0x31, 0x86, 0xB9, 0x6D, 
	0x89, 0x91, 0x7F, 0x97, 0xCC, 0x4D, 0x83, 0xB0, 
	0xBB, 0xFA, 0x24, 0xDE, 0xFF, 0xC6, 0xBD, 0x19, 
	0x92, 0xC2, 0x82, 0x60, 0x1B, 0xDF, 0x37, 0xC8, 
	0xD6, 0x5D, 0x2C, 0x27, 0x3C, 0x11, 0xB0, 0x31, 
	0x26, 0xC3, 0xAE, 0x8D, 0x85, 0xB2, 0x78, 0x23, 
	0xA2, 0x58, 0x92, 0xCD, 0x98, 0xB4, 0xEE, 0x59, 
	0x16, 0xAE, 0x28, 0xA3, 0xEE, 0x42, 0xFE, 0x0B, 
	0xB2, 0xDD, 0x08, 0xAE, 0x50, 0xA0, 0xF9, 0x64, 
	0x92, 0xD8, 0x9D, 0x9C, 0x7F, 0x08, 0xBA, 0xE9, 
	0xE4, 0x29, 0x06, 0x27, 0xC2, 0xCE, 0x19, 0xF6, 
	0x30, 0x8D, 0x7B, 0x76, 0x63, 0xF7, 0x21, 0x6E, 
	0x39, 0x28, 0x95, 0xE6, 0x9B, 0xFD, 0x45, 0xE2, 
	0xF9, 0x99, 0x51, 0xDA, 0x5B, 0xDA, 0xA8, 0x0B, 
	0x60, 0x94, 0xE5, 0x1E, 0x80, 0xD5, 0xEA, 0xD3, 
	0x7E, 0x6A, 0x0B, 0xDE, 0x47, 0x7B, 0x87, 0xFE, 
	0x6E, 0xAA, 0xD8, 0xE8, 0x08, 0xB1, 0x37, 0x6D, 
	0x11, 0x84, 0xAA, 0xC9, 0xCB, 0x80, 0x4A, 0x8D, 
	0x39, 0xE9, 0xE3, 0xCC, 0x21, 0xFF, 0xF7, 0x9C, 
	0xA2, 0x53, 0xB4, 0x19, 0xB8, 0x91, 0x4C, 0x74, 
	0xEE, 0x76, 0xCB, 0x21, 0x81, 0x8D, 0x77, 0x09, 
	0xD1, 0x42, 0x4F, 0x08, 0x0C, 0xBE, 0xD1, 0xBF, 
	0x4E, 0x48, 0x25, 0xE8, 0xBC, 0xE1, 0xD5, 0x57, 
	0xCA, 0x0C, 0xEA, 0x60, 0x74, 0x9C, 0x57, 0x33, 
	0x88, 0x03, 0x33, 0x4F, 0xAC, 0x87, 0x8B, 0x67, 
	0x13, 0x89, 0x87, 0xE9, 0xE0, 0x01, 0x47, 0x0F, 
	0x1A, 0x3B, 0x0C, 0xD0, 0xC1, 0xD0, 0xBD, 0xF2, 
	0x0D, 0x3A, 0x50, 0x51, 0x1D, 0x50, 0x8C, 0xC6, 
	0xD6, 0x3C, 0xED, 0x03, 0x9F, 0x3E, 0xDF, 0xDA, 
	0xEA, 0x99, 0x50, 0x04, 0x11, 0x35, 0xB8, 0xFE, 
	0x43, 0xFA, 0x90, 0x0A, 0x6B, 0xFB, 0x94, 0x42, 
	0xA8, 0xD7, 0x09, 0x07, 0x74, 0x5A, 0x4D, 0x32, 
	0xC9, 0xDE, 0x7A, 0x5A, 0x38, 0xA6, 0xD9, 0xA2, 
	0xA5, 0x85, 0xD1, 0x17, 0xD5, 0x90, 0x0F, 0x22, 
	0x4C, 0xF3, 0x17, 0x6F, 0x8F, 0x82, 0xFF, 0x1C, 
	0x50, 0x0F, 0xFC, 0x22, 0x06, 0x99, 0x7D, 0x7F, 
	0x6A, 0x28, 0x71, 0x13, 0x24, 0x65, 0x81, 0x62, 
	0xC2, 0x1C, 0x30, 0xBF, 0xAA, 0x83, 0x34, 0x7E, 
	0x05, 0x67, 0x78, 0xAC, 0x04, 0x87, 0xD0, 0xC3, 
	0xD8, 0x57, 0x7C, 0x19, 0xCC, 0x17, 0x47, 0x9E, 
	0x2F, 0x6E, 0x42, 0x13, 0x8F, 0xA4, 0x8D, 0xF1, 
	0xE0, 0xC8, 0x65, 0xB4, 0x58, 0x20, 0x4C, 0x86, 
	0x5B, 0x57, 0xD4, 0x6F, 0xE5, 0x59, 0xF6, 0xCD, 
	0xA6, 0xD3, 0xE8, 0x43, 0xB5, 0xEE, 0x2F, 0x8F, 
	0x34, 0xDA, 0x5E, 0x12, 0xE5, 0x8E, 0xCB, 0xA2, 
	0xD0, 0x54, 0xCC, 0xA6, 0xEB, 0x61, 0x46, 0x1C, 
	0xD9, 0x24, 0x91, 0x10, 0x15, 0xC3, 0xB8, 0xCF, 
	0x9F, 0x83, 0x8E, 0xCD, 0xEE, 0x75, 0x06, 0x92, 
	0x00, 0xA5, 0x7E, 0xAC, 0x99, 0x79, 0x48, 0xCF, 
	0x4B, 0x0D, 0x8A, 0xF6, 0x04, 0xC5, 0x37, 0xBB, 
	0x33, 0x59, 0x55, 0xB1, 0x7C, 0x83, 0x31, 0xFF, 
	0xC5, 0x7D, 0x81, 0x3D, 0x05, 0x6D, 0x9B, 0xDC, 
	0xD5, 0xBC, 0xD1, 0x6C, 0x3B, 0x0F, 0x4D, 0x1D, 
	0x2B, 0x9F, 0xA8, 0xE9, 0xF6, 0xA3, 0x19, 0x88, 
	0x55, 0x84, 0x01, 0x5E, 0xA0, 0x12, 0xFF, 0x5E, 
	0x70, 0x0F, 0x59, 0x26, 0xEB, 0x25, 0x50, 0x43, 
	0x57, 0xD1, 0xF9, 0x08, 0xCC, 0x30, 0xD5, 0x46, 
	0xAA, 0xE1, 0x32, 0x41, 0x18, 0x95, 0x5C, 0xE2, 
	0x06, 0x46, 0xA7, 0xB2, 0xD9, 0x9E, 0xFB, 0x96, 
	0x6A, 0x6A, 0x2A, 0xB7, 0x9D, 0xF7, 0xE4, 0xB2, 
	0x15, 0x4B, 0x62, 0x44, 0x1A, 0xA4, 0xA9, 0x2B, 
	0xEC, 0x35, 0x10, 0xA8, 0x29, 0x10, 0xFC, 0x17, 
	0x4D, 0xEE, 0x0D, 0xF1, 0x88, 0x60, 0xA1, 0xAA, 
	0xFD, 0x1F, 0x1B, 0x1E, 0x97, 0x29, 0xBC, 0xFD, 
	0xC1, 0xBC, 0x25, 0x4F, 0xCA, 0x71, 0xA0, 0xF2, 
	0x11, 0x3A, 0xB2, 0xA5, 0xA4, 0x43, 0xAB, 0x24, 
	0x35, 0xD9, 0xAC, 0x07, 0x27, 0x05, 0x38, 0x89, 

	/* Database Page 8 */

	0xFF, 0x13, 0xDE, 0x61, 0x56, 0x9C, 0x06, 0x06, 
	0x56, 0xDD, 0x8A, 0x1E, 0xEC, 0x88, 0xBD, 0xEC, 
	0x9F, 0xFD, 0xD8, 0x7B, 0x78, 0x29, 0xA1, 0xC1, 
	0xB2, 0x6A, 0x5B, 0x66, 0x26, 0xED, 0x6E, 0x5A, 
	0xFC, 0x6E, 0x1B, 0xDB, 0xF8, 0x7F, 0xDA, 0x80, 
	0x27, 0x15, 0x7A, 0xEC, 0x8F, 0x0F, 0x6D, 0xB0, 
	0x04, 0x5B, 0xE7, 0xFE, 0xE7, 0xF2, 0x36, 0x82, 
	0xBF, 0x70, 0x81, 0xB6, 0xFE, 0xD3, 0x72, 0xA4, 
	0x85, 0xD8, 0x97, 0x22, 0xA8, 0xBA, 0x08, 0x10, 
	0x07, 0xB3, 0x52, 0x73, 0x7A, 0xBB, 0x6E, 0x88, 
	0x53, 0xCB, 0xE7, 0x9C, 0xCC, 0x70, 0x90, 0x18, 
	0xC8, 0xAB, 0x4E, 0xB1, 0xB4, 0x74, 0x82, 0x12, 
	0x06, 0x89, 0x87, 0x81, 0xD2, 0xF3, 0x7A, 0xDD, 
	0xCB, 0x73, 0x4A, 0x5C, 0xE6, 0xDF, 0xC1, 0x7A, 
	0xC7, 0xA3, 0xEB, 0x0F, 0x23, 0x51, 0x07, 0xB5, 
	0xAC, 0xC0, 0x23, 0xA0, 0xE7, 0xA7, 0xF1, 0x44, 
	0x6F, 0xFF, 0xF2, 0xC4, 0xA9, 0xBB, 0x29, 0xEE, 
	0xA1, 0x0F, 0x65, 0x90, 0x09, 0xD1, 0x9D, 0x18, 
	0x2E, 0x77, 0xD3, 0x64, 0xF1, 0xD7, 0x4F, 0xAF, 
	0x06, 0x52, 0x0B, 0x80, 0x5E, 0xF7, 0x5C, 0xBC, 
	0x9C, 0x11, 0xD0, 0xD5, 0x47, 0xF4, 0xE0, 0xF9, 
	0x6F, 0x6E, 0xC4, 0xF1, 0xCE, 0xF0, 0x9C, 0xBC, 
	0x04, 0xDA, 0xA8, 0xB8, 0xB2, 0x18, 0x18, 0x65, 
	0x7B, 0xCB, 0x32, 0x7E, 0xBD, 0x6A, 0xC8, 0xBE, 
	0xBE, 0x33, 0x38, 0x5C, 0x4D, 0x4F, 0x44, 0x9A, 
	0x0C, 0x44, 0x0E, 0x3F, 0x1F, 0x26, 0xD9, 0xC1, 
	0x3D, 0x4C, 0x63, 0x34, 0xEC, 0x75, 0xD0, 0x65, 
	0x2F, 0x5D, 0x9D, 0xE4, 0xC0, 0xE9, 0x30, 0x02, 
	0xB3, 0x1D, 0xE1, 0x71, 0x77, 0x75, 0xD8, 0x2D, 
	0x54, 0xC2, 0xC9, 0x15, 0xEC, 0xA6, 0x40, 0x7D, 
	0x35, 0x34, 0xD1, 0xE8, 0x75, 0x10, 0x38, 0x76, 
	0x30, 0xAB, 0xF8, 0x63, 0xB2, 0x02, 0xE9, 0xE1, 
	0x31, 0xE7, 0xFF, 0x7A, 0x94, 0xC3, 0xC6, 0xFD, 
	0x8F, 0xE7, 0x35, 0xE8, 0xAA, 0xF9, 0x00, 0x48, 
	0xDA, 0x69, 0xCE, 0xDB, 0x38, 0xB6, 0x8A, 0x4E, 
	0x36, 0x0C, 0xA5, 0x6C, 0x9E, 0xD4, 0xF2, 0x58, 
	0x3D, 0x07, 0x27, 0x80, 0x2F, 0x1A, 0xE9, 0xE8, 
	0xCA, 0x78, 0x47, 0xBF, 0xEF, 0xB6, 0x64, 0xF8, 
	0xB5, 0x5C, 0x93, 0x09, 0xDF, 0x89, 0xC7, 0xC7, 
	0x57, 0x28, 0xB3, 0x25, 0x33, 0x51, 0x44, 0xA9, 
	0x06, 0x8B, 0x24, 0x75, 0x33, 0x2B, 0xAF, 0x69, 
	0x8B, 0xF1, 0x35, 0xDF, 0xDA, 0xE5, 0x60, 0x48, 
	0x79, 0xD8, 0x4F, 0xB6, 0x32, 0xA6, 0x57, 0x78, 
	0x06, 0x30, 0xB8, 0x1D, 0xB4, 0x42, 0x16, 0xD4, 
	0xBC, 0xC8, 0x8B, 0x79, 0x96, 0x9D, 0x60, 0x68, 
	0x9A, 0x33, 0xE4, 0x6D, 0x11, 0x02, 0x57, 0x55, 
	0xA1, 0x1C, 0x1E, 0xB6, 0x75, 0x25, 0x18, 0xE5, 
	0x5A, 0x62, 0x25, 0x78, 0x81, 0xB9, 0xB1, 0x0F, 
	0x0F, 0x80, 0xE6, 0xFF, 0xDB, 0xD7, 0xD8, 0x36, 
	0x40, 0xE5, 0x09, 0x99, 0x86, 0x21, 0xE2, 0x73, 
	0x44, 0x1D, 0xDD, 0x3D, 0xB3, 0x50, 0xCA, 0xCB, 
	0xB3, 0x7F, 0xBB, 0xED, 0x3D, 0x0E, 0x65, 0x91, 
	0x43, 0x6C, 0x7D, 0x20, 0x09, 0xDC, 0xEA, 0x4B, 
	0x5F, 0x49, 0x09, 0x06, 0xC5, 0x09, 0x06, 0x42, 
	0x3B, 0x64, 0xCB, 0x00, 0x9A, 0x94, 0x75, 0x0A, 
	0x95, 0x69, 0x59, 0x2F, 0xE6, 0x93, 0x4C, 0xA8, 
	0xE0, 0x9F, 0x53, 0xD1, 0xC3, 0x2B, 0xCE, 0x9F, 
	0xC5, 0x64, 0x04, 0x11, 0x6B, 0x0B, 0x0B, 0x97, 
	0x19, 0x6D, 0x83, 0x24, 0x37, 0x65, 0x44, 0x5B, 
	0x86, 0x0B, 0x99, 0xD8, 0xBA, 0xE1, 0x83, 0x9A, 
	0xF0, 0xE7, 0x3F, 0x9B, 0x65, 0x56, 0x62, 0x49, 
	0x9A, 0x52, 0x63, 0x37, 0x48, 0x63, 0x2B, 0xB5, 
	0xCF, 0x03, 0x57, 0x19, 0x62, 0xA1, 0x53, 0x62, 
	0xE0, 0xE5, 0x2D, 0x16, 0xFC, 0x92, 0x91, 0xD0, 
	0x09, 0xA1, 0x5F, 0x97, 0xFF, 0x15, 0x2F, 0x5D, 
	0xF1, 0xA9, 0x2C, 0xCA, 0x20, 0x56, 0x18, 0xD1, 
	0xC3, 0x9D, 0x11, 0x46, 0xFC, 0xB1, 0xD6, 0x7D, 
	0x7C, 0xFB, 0xB3, 0xF1, 0x05, 0x7D, 0x45, 0x3E, 
	0x27, 0x1D, 0x4A, 0xAD, 0xB7, 0x51, 0x0C, 0x86, 
	0xF1, 0x68, 0xEE, 0x28, 0x90, 0x97, 0xF0, 0x3D, 
	0xD3, 0xB7, 0x10, 0x49, 0x01, 0x8B, 0xBE, 0xD4, 
	0x74, 0x43, 0x82, 0x8C, 0x20, 0x40, 0xD9, 0x44, 
	0xC9, 0x10, 0xF8, 0x47, 0xF8, 0xC2, 0xDD, 0x93, 
	0x5E, 0x0B, 0xD2, 0x41, 0xE9, 0x83, 0x92, 0x7D, 
	0x9E, 0x26, 0x30, 0x0C, 0x2D, 0x37, 0x1B, 0xDD, 
	0xBF, 0xD4, 0x88, 0x47, 0xEA, 0xF1, 0x9C, 0x2F, 
	0x78, 0x76, 0x18, 0x54, 0x75, 0x9B, 0x54, 0x38, 
	0x4C, 0xC3, 0xA2, 0x2F, 0x03, 0xC3, 0xB6, 0x16, 
	0x37, 0xC3, 0x7E, 0x1F, 0x17, 0x52, 0xE4, 0xA1, 
	0xB4, 0x03, 0x40, 0xF5, 0x54, 0x67, 0xBE, 0x43, 
	0xBF, 0x5C, 0x56, 0x56, 0xF4, 0xFF, 0x81, 0x12, 
	0x9A, 0x8B, 0x0B, 0x46, 0x10, 0x65, 0x09, 0x4A, 
	0xC7, 0x09, 0x14, 0x1A, 0x7A, 0x23, 0x85, 0xD5, 
	0x61, 0x19, 0x65, 0xDA, 0x4E, 0x38, 0x80, 0x15, 
	0xBE, 0xB2, 0x39, 0x8F, 0xAD, 0x96, 0xFD, 0xD6, 
	0x5A, 0x9C, 0xDE, 0x36, 0xFC, 0x0A, 0x7B, 0x10, 
	0xF8, 0xFB, 0xED, 0xAD, 0xAC, 0x94, 0x73, 0x0C, 
	0x9F, 0xDA, 0x2C, 0x27, 0x9D, 0x8A, 0x47, 0xCC, 
	0x54, 0xA3, 0xB5, 0x19, 0x08, 0x11, 0x2C, 0xC1, 
	0xA7, 0xF3, 0x62, 0x02, 0x4F, 0x43, 0xA2, 0xAD, 
	0xF7, 0x38, 0x64, 0x66, 0x48, 0x67, 0x01, 0x9D, 
	0xA7, 0xEE, 0x25, 0x35, 0x64, 0x08, 0x2B, 0x78, 
	0x40, 0xF8, 0x84, 0xA1, 0x51, 0xCD, 0xFA, 0x64, 
	0xBD, 0x05, 0xA7, 0x74, 0x2D, 0x0E, 0x99, 0xFA, 
	0xEA, 0x42, 0x22, 0xAC, 0xE3, 0xD9, 0xB7, 0x34, 
	0xFD, 0xDC, 0x0B, 0xD0, 0x49, 0x43, 0x89, 0xC0, 
	0x33, 0x62, 0x51, 0x25, 0xF8, 0x47, 0xFF, 0xB9, 
	0x0D, 0x90, 0x56, 0x3F, 0x91, 0x4D, 0x15, 0x71, 
	0x6C, 0xC0, 0xDB, 0x48, 0xF6, 0x20, 0x12, 0xC1, 
	0x9C, 0x96, 0x1C, 0x4F, 0xE0, 0xAB, 0x8D, 0x1C, 
	0x71, 0xC8, 0x29, 0xEC, 0xAC, 0xCD, 0x34, 0xEA, 
	0xC9, 0x6D, 0x18, 0x83, 0xB5, 0x8F, 0xA8, 0x23, 
	0x88, 0x07, 0x63, 0xCE, 0x30, 0x86, 0x33, 0xF5, 
	0x75, 0x07, 0xBB, 0xFE, 0x2E, 0xA2, 0x06, 0x0E, 
	0x4C, 0x9D, 0xE4, 0x63, 0x92, 0xA3, 0xA4, 0x76, 
	0xB3, 0xCF, 0x05, 0x95, 0xD2, 0xBE, 0xDD, 0x3A, 
	0x33, 0xFD, 0x1F, 0x5D, 0x94, 0x38, 0xF4, 0xE3, 
	0x08, 0x3C, 0x42, 0x38, 0xD2, 0x49, 0x28, 0x2F, 
	0x45, 0xCF, 0xA2, 0x85, 0x87, 0x0B, 0xCB, 0xF6, 
	0x0D, 0x77, 0x06, 0x7B, 0x73, 0x46, 0x58, 0x93, 
	0x10, 0x90, 0x7D, 0xF2, 0x63, 0xC4, 0xE6, 0x3D, 
	0xC9, 0x27, 0x11, 0xBA, 0xF4, 0x3B, 0x2C, 0xAF, 
	0x20, 0x65, 0xE6, 0xD3, 0x6B, 0x5C, 0xC1, 0xFF, 
	0x0E, 0x8C, 0xE3, 0x53, 0xFB, 0x68, 0x7B, 0x36, 
	0x03, 0x98, 0x84, 0x5C, 0x05, 0xED, 0x23, 0xC9, 
	0xEA, 0x23, 0xC7, 0x97, 0x78, 0x47, 0xA2, 0x77, 
	0xB7, 0xEE, 0x99, 0xBB, 0x47, 0xAA, 0x9B, 0x1E, 
	0x77, 0x38, 0x03, 0x52, 0xF6, 0x1B, 0x58, 0xBF, 
	0xEC, 0x96, 0xEB, 0x90, 0x55, 0xD9, 0x04, 0xD1, 
	0x22, 0x05, 0xD5, 0x30, 0xF2, 0xBD, 0xA8, 0x54, 
	0x30, 0x85, 0x4D, 0x58, 0x4B, 0xDF, 0xF1, 0xDF, 
	0xA5, 0xD3, 0x5B, 0xD3, 0x0B, 0x10, 0xE6, 0x8A, 
	0xC7, 0xA8, 0x8D, 0xDA, 0xDC, 0xBC, 0x95, 0xA4, 
	0x97, 0x0C, 0x7E, 0x35, 0xE5, 0x61, 0x15, 0xB7, 
	0x8E, 0xB4, 0xB0, 0x2B, 0xEB, 0x4D, 0xAE, 0x6F, 
	0x75, 0x8F, 0xBA, 0xE7, 0x59, 0x55, 0xCD, 0x58, 
	0x6B, 0x22, 0xE5, 0x2B, 0xA9, 0xD1, 0x87, 0xFB, 
	0xCC, 0x58, 0xCA, 0x79, 0xD9, 0x77, 0x2D, 0xE4, 
	0x92, 0x84, 0xB6, 0xD9, 0x4A, 0x1F, 0x84, 0xB5, 
	0xFF, 0xA2, 0x4A, 0x9A, 0x00, 0x16, 0xD9, 0x4D, 
	0xA1, 0x91, 0x11, 0x42, 0x63, 0x05, 0xEF, 0xB0, 
	0x4B, 0xE6, 0x41, 0xB5, 0xB6, 0x17, 0x0D, 0x22, 
	0x3A, 0x10, 0x34, 0x10, 0xCE, 0xE0, 0x2F, 0xB1, 
	0x62, 0x32, 0x1A, 0x2D, 0x71, 0xEB, 0x57, 0x37, 
	0xA9, 0x40, 0x74, 0xA2, 0xFE, 0x7A, 0xAB, 0x9A, 
	0xED, 0xA0, 0x38, 0x39, 0x93, 0x12, 0x30, 0x1D, 
	0x87, 0xC6, 0x24, 0xAE, 0x3A, 0x98, 0x76, 0x44, 
	0xB3, 0xB3, 0x36, 0xE3, 0x78, 0xAC, 0x2B, 0xA1, 
	0xAB, 0x93, 0x50, 0x1C, 0x2D, 0x5D, 0x4F, 0xAD, 
	0x3E, 0x61, 0x62, 0x63, 0x05, 0x1D, 0x23, 0x3C, 
	0xCC, 0x38, 0x1D, 0x20, 0x0F, 0xD5, 0xB0, 0xDC, 
	0xDE, 0x60, 0x77, 0x1B, 0x3F, 0x2D, 0x4A, 0x7F, 
	0xAB, 0x62, 0x4C, 0x0F, 0xDA, 0x80, 0xF0, 0x59, 
	0x8E, 0x11, 0xFA, 0x07, 0x94, 0x79, 0xD5, 0x9D, 
	0xA5, 0x7E, 0xA7, 0x9D, 0x25, 0xF3, 0x14, 0x83, 
	0x72, 0xFF, 0xE5, 0xDF, 0x11, 0xE8, 0x6C, 0xD4, 
	0xA9, 0x33, 0x7F, 0x8C, 0x88, 0x74, 0x86, 0xBE, 
	0x32, 0xD8, 0xA5, 0xE7, 0x41, 0x0E, 0xB4, 0x19, 
	0x95, 0xAF, 0x53, 0x87, 0x9F, 0x65, 0x7D, 0x2A, 
	0xFB, 0x98, 0x52, 0xB2, 0x7F, 0x91, 0xEA, 0xDA, 
	0x06, 0x48, 0x4E, 0x63, 0x47, 0x15, 0x50, 0xF2, 
	0x47, 0x56, 0xF2, 0x9F, 0xEF, 0x46, 0x97, 0x01, 
	0xB2, 0xF6, 0xD7, 0x82, 0x06, 0x02, 0x5F, 0xAC, 
	0x73, 0xAC, 0xED, 0x4F, 0xFF, 0xCC, 0xC8, 0x3A, 
	0xE1, 0xCD, 0x3D, 0x9B, 0xD9, 0x0A, 0xCA, 0x54, 
	0xAD, 0x0F, 0x73, 0xAA, 0xC7, 0x49, 0x56, 0x77, 
	0x8E, 0x3D, 0x0C, 0x58, 0xE1, 0x72, 0xE8, 0x5D, 
	0x53, 0xF8, 0xBA, 0xD7, 0xD1, 0x07, 0x0E, 0xCD, 
	0x0E, 0x3B, 0x6B, 0x3F, 0xE1, 0x5E, 0xA3, 0x03, 
	0xD6, 0xBA, 0x68, 0x08, 0x35, 0x5D, 0x9B, 0x56, 
	0xED, 0x71, 0x08, 0x9B, 0xF2, 0x10, 0xFE, 0x25, 
	0x63, 0x29, 0xFF, 0xC2, 0x5D, 0x3D, 0xBE, 0x67, 
	0xCF, 0x36, 0xC2, 0x7B, 0x4D, 0x76, 0xF9, 0xCB, 
	0xFF, 0x72, 0x59, 0x2D, 0x02, 0xCB, 0x74, 0x3E, 
	0xA3, 0xD1, 0x9D, 0x6A, 0xA8, 0x08, 0xEE, 0x38, 
	0xB2, 0x7C, 0xD1, 0xEC, 0x9A, 0x94, 0xE0, 0xBD, 
	0x67, 0x8B, 0xEF, 0x31, 0xC1, 0xB1, 0xF3, 0xFA, 
	0xB6, 0x2E, 0x1B, 0x56, 0xD0, 0xBD, 0x90, 0x1C, 
	0x6B, 0xA2, 0x03, 0x6F, 0xE4, 0x60, 0xEF, 0xA0, 
	0x1C, 0xE7, 0x3E, 0xE8, 0x43, 0x17, 0xBD, 0x8C, 
	0x8B, 0x80, 0x08, 0x16, 0xD8, 0x4D, 0xB8, 0x08, 
	0xAA, 0x78, 0x82, 0x6E, 0xB2, 0x6B, 0x38, 0xAD, 
	0x07, 0x0E, 0xE5, 0xF7, 0xC4, 0x23, 0x70, 0x94, 
	0xEE, 0xC5, 0x03, 0x2B, 0xA4, 0x2A, 0x96, 0x1B, 
	0xEB, 0x78, 0x4B, 0x79, 0x74, 0x5D, 0xBF, 0x1B, 
	0xEC, 0x3D, 0x5A, 0x40, 0xF2, 0x55, 0x82, 0xD3, 
	0xDD, 0x49, 0xD8, 0xE7, 0x8F, 0x29, 0x3C, 0x53, 
	0x5C, 0x52, 0xF6, 0xFF, 0xE7, 0x6B, 0xE3, 0x59, 
	0x4D, 0x82, 0x27, 0xC2, 0x67, 0xE7, 0x04, 0x29, 
	0x38, 0xB3, 0xFB, 0x50, 0x60, 0xD6, 0xB9, 0xE8, 
	0x5E, 0x5D, 0x37, 0xE3, 0xD2, 0x33, 0x0E, 0xEA, 
	0xC9, 0x16, 0x04, 0x53, 0x2E, 0x0C, 0x6C, 0x5F, 
	0xB9, 0xF9, 0xF4, 0x85, 0xA0, 0xAC, 0xC4, 0x03, 
	0x4F, 0x55, 0xB3, 0xB8, 0xC8, 0xEB, 0x5B, 0x7C, 
	0x89, 0xBD, 0x39, 0x61, 0x85, 0xA1, 0xA3, 0xEF, 
	0x5A, 0xCF, 0xC2, 0x1F, 0x40, 0xB0, 0x4B, 0x8C, 
	0xF1, 0x1E, 0xD4, 0x52, 0x29, 0x44, 0x41, 0x7A, 
	0x41, 0xCC, 0x1B, 0x20, 0x6B, 0xE0, 0xF2, 0x57, 
	0xFB, 0xCF, 0x8B, 0x91, 0xA8, 0x61, 0x44, 0x78, 
	0x5C, 0x88, 0xD0, 0x01, 0xE0, 0x73, 0xBB, 0x85, 
	0x61, 0x14, 0xCC, 0x7D, 0x50, 0x84, 0x94, 0x8A, 
	0xD0, 0x3B, 0x3E, 0xA7, 0x14, 0x67, 0x77, 0x39, 
	0x03, 0x79, 0x41, 0x5A, 0x2F, 0x60, 0x24, 0x37, 
	0x0F, 0xE3, 0x35, 0xC3, 0xFF, 0x0F, 0x1B, 0x9B, 
	0x07, 0x09, 0x4A, 0x82, 0xFB, 0x86, 0xAA, 0xFF, 
	0x65, 0xDA, 0x0A, 0x77, 0xC4, 0xF1, 0x53, 0xBA, 
	0xB0, 0xCE, 0x45, 0x7B, 0xB0, 0x7C, 0xFA, 0xCC, 
	0xA6, 0xD5, 0x94, 0xAC, 0x72, 0x17, 0x7D, 0x38, 
	0x1F, 0x91, 0xC7, 0xC6, 0xAD, 0x5D, 0xDF, 0xB3, 
	0x27, 0xC3, 0x17, 0x59, 0x7C, 0xAA, 0x10, 0x33, 
	0xBF, 0x3F, 0xCE, 0xDA, 0x42, 0xEE, 0x23, 0x09, 
	0x50, 0x3F, 0xF2, 0xF7, 0xCE, 0x61, 0xD1, 0xD2, 
	0x51, 0x16, 0x2B, 0x9C, 0x51, 0x02, 0x16, 0x44, 
	0x6F, 0xF0, 0xC3, 0xF1, 0xDD, 0xC8, 0x15, 0x0A, 
	0x02, 0x4B, 0xEB, 0xAE, 0xE8, 0x42, 0x08, 0x16, 
	0x55, 0x81, 0x91, 0xB9, 0x35, 0xFC, 0x11, 0x58, 
	0x1F, 0x31, 0x80, 0x70, 0x66, 0xE5, 0x5F, 0xF4, 
	0x05, 0x22, 0x06, 0xEC, 0x1D, 0x06, 0x2F, 0x40, 
	0xE0, 0x67, 0x1B, 0xF3, 0x16, 0x43, 0x6D, 0x4B, 
	0x66, 0x58, 0xE5, 0xE4, 0x9B, 0xFF, 0x58, 0xBC, 
	0x67, 0x36, 0x97, 0x02, 0xAA, 0xEF, 0x82, 0xDC, 
	0x75, 0xB8, 0x2F, 0xCC, 0xE8, 0x98, 0xB8, 0x97, 
	0x33, 0x84, 0x3D, 0x19, 0x73, 0x33, 0x7F, 0xEB, 
	0x64, 0xB3, 0x5D, 0x77, 0xFE, 0x9E, 0xAC, 0x1D, 
	0x73, 0x3B, 0xE2, 0x68, 0xF9, 0xBC, 0x46, 0x90, 
	0x44, 0x9C, 0xE8, 0xC3, 0x4E, 0xAD, 0xA7, 0xA3, 
	0xD1, 0x54, 0xB2, 0x9F, 0xC7, 0x94, 0x3A, 0x93, 
	0x76, 0xA1, 0x92, 0xA7, 0x35, 0x80, 0x40, 0x93, 
	0x9C, 0x23, 0x73, 0x50, 0x6A, 0x41, 0xCB, 0xAF, 
	0x97, 0x28, 0x45, 0x59, 0x93, 0x8F, 0x04, 0xA3, 
	0x99, 0xF5, 0x76, 0x38, 0x1A, 0x3C, 0x8F, 0x60, 
	0xF5, 0xCB, 0x0C, 0x2B, 0xC0, 0x0F, 0x2C, 0x08, 
	0x02, 0xF8, 0x5C, 0x06, 0x67, 0xE6, 0xF6, 0x44, 
	0x49, 0x06, 0xC7, 0x70, 0x81, 0xCA, 0x27, 0x0F, 
	0x9E, 0x91, 0x2F, 0x20, 0x9B, 0xD6, 0x15, 0x08, 
	0x55, 0x70, 0xEF, 0x41, 0x3E, 0xCA, 0xFF, 0x6E, 
	0x34, 0x8E, 0xCD, 0xCB, 0xE8, 0xB6, 0x4C, 0xEF, 
	0x1E, 0xA7, 0xA6, 0x22, 0xFF, 0x94, 0x3D, 0xBA, 
	0xDE, 0xDA, 0xC6, 0xDC, 0x33, 0x76, 0x29, 0x31, 
	0xBF, 0x91, 0x95, 0xFA, 0xAD, 0x9B, 0x66, 0x9F, 
	0x2D, 0x57, 0x9A, 0xB8, 0x3A, 0x3B, 0xFF, 0x17, 
	0xF9, 0x8D, 0xEE, 0xF5, 0xED, 0x4C, 0x50, 0x19, 
	0xF0, 0xB9, 0x78, 0x08, 0x1B, 0x89, 0xC0, 0x22, 
	0xCD, 0x1D, 0xEE, 0x25, 0xA0, 0x75, 0xF1, 0x17, 
	0xB1, 0x0E, 0x42, 0x17, 0x81, 0xCB, 0x04, 0xC1, 
	0x8F, 0xE3, 0xB2, 0x3E, 0xAC, 0xA8, 0x64, 0xA2, 
	0xB8, 0x95, 0xCE, 0x97, 0xC2, 0x12, 0xCA, 0xD8, 
	0xAD, 0xDA, 0xED, 0xB5, 0x37, 0x0A, 0x8D, 0x0A, 
	0x40, 0x7C, 0x94, 0xCC, 0xCB, 0x3E, 0x18, 0x65, 
	0x74, 0xB9, 0xE7, 0xEC, 0x1D, 0x4B, 0x44, 0x2C, 
	0x36, 0x6C, 0x40, 0x2F, 0x29, 0xBD, 0x59, 0x4D, 
	0x7E, 0x66, 0x0A, 0x68, 0xCC, 0xEF, 0xF0, 0xFF, 
	0x39, 0x02, 0xFA, 0x40, 0xCF, 0x2F, 0x19, 0x9E, 
	0x68, 0x29, 0x16, 0x4B, 0xF2, 0x66, 0xE3, 0xD0, 
	0x76, 0xA0, 0xA1, 0xBB, 0x79, 0x11, 0xEF, 0xEE, 
	0x0B, 0x24, 0xD6, 0x1C, 0x0F, 0xC4, 0xD1, 0xCA, 
	0x89, 0x65, 0x82, 0xA1, 0x59, 0xCA, 0x8F, 0x2E, 
	0x04, 0x5D, 0x87, 0x3F, 0x63, 0x57, 0xE8, 0x89, 
	0xB8, 0x15, 0x31, 0xF2, 0x96, 0x8F, 0x13, 0x1E, 
	0x84, 0x77, 0xA0, 0x22, 0x92, 0x0A, 0x76, 0x76, 
	0xF5, 0xC4, 0xCC, 0xE4, 0x69, 0xE3, 0x7C, 0x16, 
	0xEA, 0x99, 0x7B, 0x94, 0x4D, 0x8F, 0x85, 0xAC, 
	0xA6, 0x6A, 0xF6, 0xA7, 0xAF, 0x33, 0x61, 0x04, 
	0x54, 0x16, 0x66, 0xE7, 0x6D, 0xF9, 0xB7, 0xD3, 
	0xFD, 0x6A, 0xE1, 0x98, 0x30, 0xE8, 0x3E, 0x5E, 
	0x0B, 0x9B, 0x8F, 0x78, 0x72, 0xB8, 0x2D, 0x84, 
	0xF2, 0x67, 0x52, 0xD6, 0x88, 0x62, 0xE8, 0x02, 
	0x5F, 0xFF, 0x4F, 0x82, 0x35, 0x5C, 0xAA, 0x82, 

	/* Database Page 9 */

	0xFF, 0x41, 0xF2, 0x76, 0x31, 0xA3, 0xB5, 0x9C, 
	0xFA, 0x1A, 0x8F, 0xB8, 0x5C, 0x96, 0x8E, 0x72, 
	0x36, 0x09, 0xA3, 0xFF, 0x71, 0xF4, 0x43, 0x65, 
	0x75, 0xE0, 0x92, 0xA5, 0xA3, 0xEE, 0xBA, 0x1C, 
	0x51, 0x08, 0xCA, 0x66, 0x85, 0xBF, 0x16, 0x36, 
	0x0A, 0x85, 0x1E, 0x76, 0x6B, 0x21, 0xB2, 0x1F, 
	0x17, 0x83, 0x7D, 0xEE, 0x86, 0xA0, 0x5C, 0xE7, 
	0x60, 0x5D, 0x1F, 0x8E, 0xD2, 0xD3, 0x54, 0x7C, 
	0x6B, 0x54, 0x1F, 0x76, 0xBE, 0x7A, 0xEB, 0x25, 
	0xCE, 0xDC, 0x68, 0xF3, 0x3A, 0x36, 0xBF, 0x7C, 
	0xE9, 0x91, 0x84, 0x5E, 0xF1, 0x64, 0xA8, 0xEC, 
	0x12, 0x97, 0xD1, 0x68, 0x8E, 0x0F, 0x20, 0x90, 
	0x08, 0x93, 0xC0, 0x6B, 0xB9, 0x70, 0xFA, 0x17, 
	0xB0, 0x0D, 0x70, 0x89, 0xE4, 0xE0, 0x0D, 0x68, 
	0xDB, 0xEE, 0x97, 0x00, 0x5D, 0x12, 0xA7, 0x1D, 
	0xAB, 0xAB, 0xF7, 0x20, 0x84, 0x60, 0xFC, 0x61, 
	0x50, 0xFF, 0x58, 0x8F, 0xCC, 0xC4, 0xF7, 0x36, 
	0xD1, 0xF4, 0x1B, 0x37, 0x72, 0x0A, 0x7D, 0xE1, 
	0x14, 0x68, 0xC7, 0xCE, 0x50, 0xAB, 0x2A, 0x50, 
	0x31, 0xF2, 0x8A, 0x54, 0xC6, 0x1F, 0x70, 0xE4, 
	0x35, 0x5A, 0x63, 0x34, 0x61, 0x28, 0x65, 0xB8, 
	0x37, 0x7C, 0xBD, 0x63, 0xE6, 0xE9, 0x7D, 0xBA, 
	0x44, 0x45, 0x33, 0x4D, 0x43, 0xD4, 0x5C, 0xA9, 
	0xAD, 0x4D, 0xE4, 0x56, 0x29, 0x1C, 0x61, 0x99, 
	0x02, 0xAF, 0x25, 0x8E, 0x00, 0x04, 0x17, 0xA2, 
	0x9A, 0xC2, 0xD5, 0xBF, 0xDF, 0x9C, 0x44, 0x97, 
	0x35, 0x58, 0xDD, 0x4F, 0x37, 0xC9, 0x8C, 0x7F, 
	0x9F, 0xFA, 0xE6, 0xDE, 0x8D, 0x03, 0xE2, 0xF0, 
	0xED, 0x99, 0x2F, 0xDF, 0x66, 0xE0, 0x8B, 0xC6, 
	0xBC, 0x7A, 0x67, 0xE1, 0x71, 0xB2, 0xB8, 0x13, 
	0x2A, 0xD4, 0x56, 0xE8, 0x3D, 0x1F, 0x3D, 0xA2, 
	0xD9, 0x89, 0x8E, 0xA0, 0xD9, 0x2C, 0x27, 0x82, 
	0xF2, 0xF3, 0xFF, 0xD8, 0x4C, 0x8F, 0x00, 0x5B, 
	0x86, 0xA4, 0x13, 0x25, 0x93, 0x1F, 0xB6, 0xA0, 
	0xC5, 0x84, 0x03, 0xBC, 0x12, 0x24, 0xF8, 0x46, 
	0x4B, 0xB3, 0x8F, 0x18, 0xE5, 0xB3, 0x29, 0x60, 
	0x1E, 0x4F, 0x3D, 0x1D, 0xC8, 0xF8, 0x05, 0xA8, 
	0xA5, 0xDD, 0x0C, 0xF4, 0xB4, 0x3F, 0xDD, 0xB7, 
	0x01, 0x63, 0x38, 0x89, 0x46, 0x78, 0x3F, 0xFB, 
	0x63, 0x4A, 0x75, 0x2D, 0x0E, 0x53, 0x03, 0x5B, 
	0xE1, 0x11, 0x14, 0xCD, 0x43, 0xBA, 0xE6, 0x71, 
	0x18, 0x0F, 0x5D, 0x87, 0x2B, 0x97, 0x8C, 0x8E, 
	0xF0, 0x16, 0x38, 0xE1, 0x00, 0x13, 0x3C, 0x7F, 
	0x49, 0x7D, 0xDB, 0xBC, 0x3A, 0xCC, 0xB0, 0xDA, 
	0x82, 0x46, 0xB3, 0x1D, 0x9D, 0x86, 0x60, 0xD7, 
	0x89, 0x21, 0x95, 0x3E, 0x54, 0x66, 0x31, 0xF9, 
	0x5E, 0xDB, 0x3D, 0xEE, 0x14, 0xF0, 0x50, 0x88, 
	0x71, 0x43, 0x20, 0xB2, 0x9E, 0xF0, 0xF0, 0x9D, 
	0xAB, 0xAA, 0xF4, 0xFF, 0x85, 0x9E, 0xBD, 0xB5, 
	0xFA, 0xFC, 0x22, 0xB0, 0xB9, 0xC7, 0x1A, 0x13, 
	0xD1, 0x0D, 0x5D, 0x58, 0xA0, 0xB7, 0x8F, 0x81, 
	0x92, 0xBD, 0xB7, 0x17, 0xDD, 0x59, 0x25, 0x26, 
	0x86, 0x29, 0xF5, 0x8F, 0x12, 0x06, 0x2C, 0xFE, 
	0x1D, 0x2E, 0x98, 0x06, 0x97, 0x1D, 0xCA, 0x58, 
	0x82, 0xD2, 0xCB, 0x96, 0x01, 0xC0, 0x63, 0x79, 
	0xE6, 0xF2, 0xA3, 0x30, 0xBE, 0x6F, 0x44, 0xAA, 
	0x68, 0x05, 0x27, 0x55, 0xB3, 0x2B, 0x63, 0xD1, 
	0x62, 0x61, 0xB7, 0x7D, 0x02, 0x57, 0x6A, 0x48, 
	0xC9, 0xD5, 0xAA, 0x26, 0x77, 0x47, 0x73, 0x23, 
	0xC3, 0x71, 0x3C, 0x43, 0xB5, 0x0B, 0x30, 0xC8, 
	0xC2, 0x36, 0xDE, 0x7D, 0x23, 0xEE, 0x50, 0xF9, 
	0xCB, 0xCE, 0x47, 0x71, 0xAC, 0x3B, 0x7C, 0xC3, 
	0x46, 0x8F, 0xF0, 0x6B, 0xA4, 0x62, 0xE2, 0x18, 
	0xF5, 0xF0, 0xCA, 0x5E, 0x43, 0xFD, 0xD3, 0x2A, 
	0xC1, 0x1C, 0x9F, 0x1D, 0xFF, 0x86, 0xA4, 0x85, 
	0xE4, 0xCF, 0x53, 0x4B, 0xF1, 0x97, 0x38, 0xE7, 
	0x52, 0x89, 0x30, 0xCC, 0x02, 0xCE, 0x4C, 0x2D, 
	0xEE, 0x79, 0x8A, 0x24, 0xCF, 0xB1, 0xE7, 0x65, 
	0x4A, 0x10, 0x0C, 0xDD, 0x77, 0xDF, 0xD7, 0x0C, 
	0x41, 0xD5, 0x16, 0x00, 0x48, 0x02, 0xC4, 0xF6, 
	0xE7, 0x76, 0xFB, 0x18, 0x8F, 0x1C, 0xA7, 0xAE, 
	0xAF, 0x30, 0x34, 0x92, 0x1A, 0x5E, 0xF1, 0x1E, 
	0x28, 0x55, 0xE9, 0xC5, 0xE5, 0x5B, 0x0F, 0x3E, 
	0x9D, 0x31, 0x18, 0xAB, 0x38, 0xC7, 0x69, 0x58, 
	0xAC, 0xE4, 0x69, 0x7C, 0xBD, 0x0F, 0xA9, 0x77, 
	0xEB, 0x0D, 0x00, 0x38, 0xA2, 0xC2, 0x38, 0x20, 
	0x0D, 0xA2, 0x1E, 0xCE, 0x95, 0x35, 0x76, 0x1E, 
	0xB4, 0x19, 0x59, 0x4E, 0x22, 0xA5, 0x96, 0x8B, 
	0xDA, 0x11, 0x6C, 0xBE, 0x9D, 0xE4, 0xE0, 0x6B, 
	0x51, 0xCB, 0x15, 0x97, 0x3A, 0x1A, 0x66, 0xCE, 
	0xCB, 0xE7, 0xDA, 0x5B, 0xD1, 0xFF, 0xB9, 0x9C, 
	0x2D, 0xB1, 0xED, 0xCA, 0xF5, 0x27, 0x35, 0x34, 
	0x25, 0xE6, 0x26, 0x13, 0x4A, 0xE4, 0xBA, 0xFA, 
	0x92, 0x29, 0x9E, 0xDB, 0x71, 0xFD, 0x3C, 0x33, 
	0x0B, 0x48, 0xDB, 0xED, 0x52, 0x83, 0x51, 0xFC, 
	0x45, 0x4E, 0x2D, 0xCA, 0x6D, 0x77, 0x6B, 0x8C, 
	0xC2, 0x3D, 0x46, 0xBB, 0xE1, 0x79, 0x04, 0xCF, 
	0x3D, 0xC4, 0x6D, 0x42, 0x66, 0x11, 0xA0, 0xA9, 
	0x27, 0x23, 0x00, 0xC0, 0x7C, 0x21, 0x93, 0x34, 
	0x9F, 0x75, 0xE9, 0xBD, 0x7E, 0x4B, 0xF0, 0x15, 
	0x36, 0xB6, 0xED, 0x3D, 0xAE, 0xFC, 0x9B, 0x10, 
	0xAB, 0x58, 0x84, 0xF8, 0x45, 0x44, 0x09, 0xC7, 
	0xCE, 0x96, 0xC0, 0xE2, 0x31, 0x5D, 0x69, 0xEA, 
	0x04, 0x86, 0x77, 0x73, 0xC3, 0x7D, 0x3B, 0x85, 
	0xE2, 0x41, 0xD1, 0xFA, 0x07, 0xE0, 0x02, 0x8E, 
	0xC0, 0x21, 0xA9, 0x58, 0xA3, 0xB9, 0xD9, 0xF2, 
	0xC6, 0x75, 0x64, 0x95, 0x6A, 0x90, 0xFF, 0x88, 
	0x49, 0x4A, 0x17, 0xAA, 0x0F, 0xC9, 0xBE, 0xF1, 
	0xC6, 0xDF, 0xDA, 0x0D, 0x69, 0x2B, 0xD1, 0x93, 
	0x48, 0x54, 0x97, 0x3C, 0xED, 0x77, 0x25, 0xC1, 
	0x31, 0x05, 0xD3, 0x6F, 0x9D, 0x71, 0x10, 0x70, 
	0x98, 0x94, 0x1C, 0xB9, 0x17, 0x60, 0x7A, 0x85, 
	0xE3, 0x7E, 0x29, 0x3F, 0xFA, 0xD4, 0xB5, 0xAB, 
	0x1D, 0x18, 0x99, 0x55, 0x3D, 0x38, 0x24, 0x17, 
	0x26, 0x75, 0x82, 0x64, 0x37, 0x11, 0x75, 0x17, 
	0xDA, 0x79, 0x83, 0x9F, 0x31, 0x8D, 0x76, 0xDD, 
	0x3A, 0x4B, 0xAD, 0xF0, 0xE2, 0xA0, 0xF2, 0x9B, 
	0xE0, 0x3E, 0xB6, 0xB2, 0x87, 0xE7, 0x30, 0x75, 
	0x9D, 0x8C, 0x23, 0x8C, 0x0E, 0x66, 0xAC, 0x53, 
	0x96, 0xAC, 0xE0, 0x50, 0xF2, 0xB6, 0x66, 0xEE, 
	0xF0, 0x97, 0x3E, 0x1B, 0x59, 0x0B, 0x60, 0x5C, 
	0x48, 0x14, 0x35, 0x40, 0x0F, 0xA5, 0xCD, 0x73, 
	0xD0, 0x28, 0x65, 0x26, 0xC3, 0xDC, 0x53, 0xFF, 
	0x42, 0x85, 0x8D, 0x81, 0xE0, 0xB9, 0x2D, 0xD0, 
	0xBF, 0xA8, 0x4A, 0x8A, 0x2E, 0x61, 0x42, 0xBE, 
	0x6C, 0x9F, 0x3B, 0x04, 0x5C, 0xD8, 0x7F, 0x65, 
	0xB3, 0x8C, 0x97, 0x26, 0x83, 0x57, 0x06, 0x98, 
	0xAD, 0x07, 0x7C, 0x94, 0xEA, 0x3F, 0x29, 0x44, 
	0xC9, 0x42, 0xFE, 0xD6, 0xC0, 0x3B, 0xEC, 0x7F, 
	0x0C, 0xBB, 0x7C, 0x68, 0xEA, 0x23, 0xC8, 0x10, 
	0x45, 0x43, 0x50, 0x16, 0x81, 0xF0, 0xD8, 0x19, 
	0xC6, 0x34, 0x66, 0x58, 0xE4, 0xD4, 0x26, 0xEC, 
	0x5F, 0xED, 0x00, 0x62, 0x09, 0x37, 0x12, 0xCA, 
	0x1B, 0x8A, 0x47, 0xA9, 0xB3, 0xD5, 0x15, 0xEE, 
	0x96, 0x1B, 0x43, 0xC2, 0x1F, 0x6D, 0xD1, 0x7F, 
	0x41, 0x99, 0x59, 0x5D, 0xAF, 0xB7, 0x82, 0x40, 
	0xD2, 0x7E, 0xE2, 0x18, 0xB8, 0xCA, 0x20, 0x89, 
	0x02, 0xEB, 0xD1, 0x25, 0xC4, 0x86, 0x4B, 0xA3, 
	0xAA, 0x6B, 0x3F, 0xD7, 0x71, 0xBF, 0x39, 0x41, 
	0xFF, 0x4E, 0x0F, 0x90, 0x76, 0x16, 0xC4, 0x5B, 
	0xF7, 0x77, 0xCB, 0x10, 0xC8, 0x60, 0x64, 0x1A, 
	0x95, 0x98, 0x30, 0x17, 0xD0, 0xBD, 0xDB, 0x88, 
	0xEF, 0x31, 0x2D, 0x70, 0x85, 0x57, 0x60, 0xCE, 
	0xD3, 0x50, 0xB0, 0xFD, 0x37, 0x84, 0xBF, 0x75, 
	0x3D, 0x8B, 0xFC, 0x5D, 0x0F, 0x2B, 0x5B, 0x1F, 
	0xA6, 0xEA, 0x4D, 0x83, 0xDC, 0x6B, 0x18, 0xF5, 
	0x59, 0xF7, 0x44, 0xA3, 0x59, 0x63, 0x4F, 0xCF, 
	0xFC, 0x32, 0x84, 0xF7, 0x12, 0xA7, 0x58, 0x45, 
	0xB3, 0x1E, 0xE8, 0xF4, 0xD7, 0xEA, 0x53, 0x8B, 
	0xCB, 0x88, 0x43, 0x4F, 0x49, 0xBA, 0x2B, 0x81, 
	0xE7, 0x46, 0xC2, 0xDB, 0xD7, 0x7C, 0x58, 0x7C, 
	0x61, 0x82, 0x8E, 0xA0, 0x63, 0x23, 0x54, 0xF2, 
	0x95, 0xA0, 0xEE, 0xEC, 0x09, 0x1A, 0xF6, 0xE2, 
	0x0A, 0xE5, 0xF2, 0x07, 0xA6, 0xA4, 0x0D, 0xF8, 
	0xDE, 0x23, 0xC7, 0xCE, 0xD3, 0xCA, 0x87, 0x9D, 
	0xC2, 0xFF, 0xD1, 0x17, 0x25, 0xC3, 0x7C, 0xE6, 
	0xFC, 0x63, 0x0A, 0x89, 0x3D, 0x00, 0xE4, 0xAA, 
	0x6B, 0xE3, 0xA3, 0x49, 0x01, 0x11, 0xDA, 0xDA, 
	0x53, 0x25, 0xA8, 0x4E, 0x37, 0x11, 0xBC, 0x04, 
	0x2B, 0x22, 0xA4, 0x2E, 0x04, 0x60, 0xFD, 0xC2, 
	0x8E, 0xF2, 0x80, 0xED, 0x41, 0xD4, 0x81, 0x21, 
	0x4B, 0xF4, 0xFE, 0xDB, 0xB5, 0x42, 0x50, 0x28, 
	0xA3, 0x3A, 0x53, 0x5A, 0x9A, 0x13, 0x88, 0x93, 
	0x70, 0x4C, 0x80, 0x08, 0x9A, 0x90, 0xFE, 0xAB, 
	0x77, 0x91, 0x52, 0xE4, 0xFA, 0xCF, 0x4B, 0xD4, 
	0x0D, 0x74, 0x9F, 0x85, 0xBC, 0xFF, 0x81, 0x45, 
	0x23, 0x6F, 0xCE, 0xF1, 0x6D, 0x6A, 0x9E, 0xF3, 
	0x8A, 0xC0, 0xF8, 0x77, 0xA8, 0x6E, 0x65, 0x12, 
	0x68, 0x8D, 0x44, 0x79, 0xD3, 0xF7, 0xA0, 0x84, 
	0x5B, 0x42, 0x3D, 0x01, 0xE6, 0x04, 0x5A, 0x8E, 
	0x78, 0x15, 0x85, 0xF4, 0x53, 0xC4, 0xCB, 0x1D, 
	0xA7, 0x1D, 0xFF, 0x0F, 0x5F, 0xA8, 0xD6, 0xD2, 
	0x7A, 0x79, 0x7D, 0x18, 0x6A, 0x5C, 0xA1, 0xC1, 
	0x82, 0x17, 0x5E, 0x0B, 0x44, 0xAB, 0x77, 0xBB, 
	0xA3, 0x4E, 0x2C, 0x96, 0xD3, 0x01, 0x3B, 0x3F, 
	0xA2, 0x82, 0xE1, 0xC6, 0xAE, 0x91, 0x26, 0x39, 
	0x5B, 0xA3, 0x38, 0xD1, 0xDB, 0x4F, 0xA0, 0x90, 
	0x1E, 0x7A, 0x49, 0xA6, 0xE5, 0x2C, 0x03, 0x20, 
	0x83, 0xC6, 0x2F, 0x50, 0x1B, 0xA1, 0xF2, 0x25, 
	0x2F, 0x66, 0x60, 0x50, 0x05, 0x37, 0xCF, 0x24, 
	0x40, 0x7A, 0xE7, 0xDC, 0xCD, 0xE4, 0xC3, 0x7A, 
	0x4C, 0x2F, 0x4B, 0xD3, 0x3E, 0x8A, 0x23, 0x7C, 
	0xB9, 0x75, 0xCA, 0x9B, 0x3D, 0x55, 0x79, 0x92, 
	0x54, 0x27, 0x39, 0x0E, 0x74, 0xE6, 0xE2, 0xA2, 
	0xB1, 0xE2, 0x4E, 0xBA, 0xB3, 0xA9, 0x24, 0x8C, 
	0x46, 0xBB, 0x0C, 0x2E, 0xD1, 0x21, 0xE1, 0xB2, 
	0x75, 0x43, 0x47, 0xAA, 0x43, 0xAA, 0x70, 0xEC, 
	0x45, 0x67, 0xBC, 0xFF, 0x36, 0xE2, 0x34, 0xE0, 
	0xF2, 0x4B, 0x6B, 0xF2, 0x86, 0xDF, 0x1F, 0xEF, 
	0x64, 0xAE, 0x65, 0xFE, 0xAB, 0x79, 0xA3, 0xBE, 
	0x13, 0xDF, 0x2A, 0x14, 0xD2, 0x2E, 0x70, 0x52, 
	0x4F, 0x23, 0xBB, 0xA6, 0x94, 0xE0, 0x8B, 0xAE, 
	0x99, 0xA8, 0xFA, 0x3D, 0xE6, 0x75, 0x4E, 0x54, 
	0x23, 0x31, 0x03, 0x5B, 0xE0, 0xEF, 0xA3, 0xE2, 
	0x3C, 0x37, 0x19, 0xD4, 0xD1, 0xD6, 0xBF, 0xF6, 
	0x55, 0xCF, 0xF2, 0x8F, 0x43, 0x65, 0x0C, 0xC1, 
	0xB5, 0x94, 0xC9, 0xFC, 0x06, 0x61, 0x1D, 0x3C, 
	0x9C, 0x7E, 0x08, 0xC4, 0x95, 0x54, 0x4C, 0x24, 
	0x6C, 0x8B, 0xED, 0xFB, 0x6C, 0xD0, 0xB7, 0x79, 
	0x62, 0x16, 0xC7, 0x18, 0xE7, 0xDE, 0x03, 0xD8, 
	0xD2, 0xFC, 0x7A, 0x95, 0xCB, 0xC7, 0x3C, 0x07, 
	0x18, 0x21, 0x1A, 0x86, 0x2F, 0xC9, 0x08, 0x4E, 
	0x05, 0x57, 0x84, 0xAD, 0xB9, 0xEE, 0xF5, 0x8E, 
	0xA4, 0xAB, 0x1F, 0x4E, 0xFF, 0x24, 0x00, 0x3E, 
	0xAB, 0xEC, 0x57, 0x45, 0xA3, 0xC2, 0x65, 0xFF, 
	0x35, 0xDC, 0xD6, 0x10, 0x4D, 0x56, 0xBA, 0x02, 
	0xD4, 0xB0, 0x6F, 0x56, 0x28, 0x82, 0x1A, 0x62, 
	0x5E, 0x0C, 0xAB, 0x2F, 0x33, 0xE9, 0x4B, 0xB7, 
	0x72, 0xD4, 0xE9, 0x71, 0xA9, 0x8D, 0xA3, 0x9D, 
	0xA4, 0xA4, 0x5B, 0xAC, 0x72, 0x4C, 0x56, 0x54, 
	0x40, 0xA4, 0xC0, 0xFE, 0x39, 0xB6, 0xA8, 0x29, 
	0xB0, 0x25, 0x05, 0xDE, 0x5B, 0xCE, 0xA4, 0x8C, 
	0x5E, 0x2C, 0x53, 0xC7, 0xA8, 0x9B, 0xF6, 0x3E, 
	0x63, 0xF7, 0xA9, 0xF2, 0xD1, 0xEB, 0x9C, 0x1D, 
	0x7C, 0x12, 0x89, 0xBE, 0x2C, 0x9F, 0x3B, 0x13, 
	0x08, 0x70, 0xDD, 0x6B, 0x99, 0xE8, 0xAB, 0xC1, 
	0xE0, 0x4D, 0xDD, 0x80, 0x44, 0x22, 0xD9, 0xC8, 
	0x42, 0x30, 0x71, 0x6F, 0x44, 0xDC, 0xAF, 0x9A, 
	0xB0, 0x5F, 0xD3, 0x1E, 0x40, 0xD4, 0x99, 0x5C, 
	0xFC, 0xDC, 0xEF, 0x39, 0x6C, 0xFF, 0x8A, 0x0F, 
	0x2E, 0x22, 0x2F, 0x9F, 0xD6, 0x7F, 0x6C, 0x72, 
	0x56, 0x3F, 0xD8, 0xA7, 0x88, 0xCF, 0xE2, 0x44, 
	0x57, 0x9E, 0x6F, 0x92, 0xFD, 0xA2, 0xE1, 0x3C, 
	0xED, 0xD0, 0xCD, 0xFD, 0x3C, 0xEB, 0x95, 0xA7, 
	0xEC, 0x89, 0x04, 0x78, 0x87, 0x49, 0x79, 0xAB, 
	0xA3, 0x48, 0x71, 0x82, 0xE8, 0xB5, 0x98, 0x13, 
	0xD5, 0x3C, 0x5B, 0x25, 0x78, 0x58, 0xEB, 0xB6, 
	0xCE, 0x77, 0xED, 0xB0, 0xC4, 0x0E, 0x9A, 0x23, 
	0xAF, 0x95, 0xE2, 0x18, 0x49, 0xA9, 0x23, 0x67, 
	0x99, 0x99, 0x4E, 0xE1, 0x45, 0x50, 0x6F, 0x11, 
	0x9A, 0x39, 0xF3, 0x5D, 0x91, 0x82, 0x68, 0x6F, 
	0x56, 0x98, 0xDC, 0xA6, 0x5B, 0xA2, 0x7F, 0x4C, 
	0x9A, 0xE2, 0xF3, 0xC0, 0x66, 0xB3, 0xA9, 0x67, 
	0xE2, 0x57, 0xB5, 0xDF, 0x57, 0x06, 0x9D, 0x17, 
	0x6A, 0x0D, 0xCF, 0x2E, 0x5C, 0x30, 0xE6, 0xF3, 
	0x9A, 0x35, 0x4D, 0x92, 0xBC, 0x0A, 0xFF, 0x03, 
	0x87, 0x14, 0xE1, 0x3D, 0x0C, 0x1F, 0xF3, 0x12, 
	0x48, 0x78, 0x8F, 0x19, 0xDE, 0xA1, 0x62, 0x2A, 
	0x86, 0x83, 0x7C, 0x48, 0x8F, 0x3C, 0x63, 0x2C, 
	0xF4, 0x10, 0xC9, 0xCC, 0xBE, 0xA7, 0x1E, 0xF1, 
	0xB8, 0xC6, 0x04, 0xAC, 0x83, 0xB3, 0x27, 0x86, 
	0x56, 0x38, 0x8A, 0x26, 0x45, 0xF9, 0xDD, 0x2A, 
	0x57, 0x2B, 0x24, 0x18, 0x43, 0xAB, 0xD6, 0x18, 
	0xFB, 0x08, 0x3D, 0x83, 0x9A, 0xC6, 0x1E, 0x74, 
	0xD0, 0xC6, 0x5B, 0x25, 0x52, 0x8A, 0x22, 0xDC, 
	0xF8, 0x0B, 0x6E, 0xEC, 0x3E, 0x23, 0x2F, 0xB5, 
	0x4A, 0xF5, 0xA7, 0x51, 0xEA, 0xDA, 0x23, 0xAE, 
	0xE0, 0x43, 0x11, 0x50, 0xC1, 0xBF, 0x27, 0x5D, 
	0x6F, 0x76, 0x6C, 0x19, 0xB7, 0xFC, 0x05, 0x75, 
	0xAE, 0x56, 0x5B, 0x3C, 0x79, 0xCF, 0xF6, 0xBA, 
	0x92, 0x82, 0x87, 0xE9, 0xAA, 0xEB, 0x47, 0x9E, 
	0x3A, 0x60, 0x1F, 0x66, 0xA7, 0x42, 0xDA, 0xFF, 
	0x65, 0xE3, 0x60, 0xAB, 0x3E, 0x59, 0x6F, 0xAB, 
	0x97, 0x60, 0xA8, 0xBB, 0x16, 0x1E, 0x67, 0xF2, 
	0xEE, 0xEC, 0x44, 0xEA, 0x20, 0xF7, 0xD1, 0x0C, 
	0xE8, 0x24, 0x40, 0xC5, 0xF0, 0x8A, 0x06, 0x4B, 
	0x20, 0xF8, 0x37, 0x6A, 0xB1, 0x98, 0x2F, 0xD1, 
	0xD1, 0x7D, 0x2A, 0x15, 0x85, 0x71, 0x1F, 0x1D, 
	0xA1, 0x35, 0xD8, 0x9C, 0xC8, 0x08, 0x14, 0x46, 
	0xFA, 0x92, 0x14, 0x8B, 0x71, 0xB5, 0x54, 0xC8, 
	0xEF, 0x48, 0x9D, 0xC2, 0x59, 0x69, 0x73, 0x71, 
	0x52, 0xAC, 0xC1, 0xBC, 0x02, 0xAC, 0xA6, 0x5F, 
	0x5F, 0x1C, 0x34, 0x1C, 0xF4, 0xE8, 0x72, 0x21, 
	0x8D, 0xBB, 0x23, 0x63, 0xD2, 0x65, 0xDA, 0x5E, 
	0x56, 0x3C, 0x2C, 0x0D, 0xB4, 0x47, 0xB1, 0x35, 
	0x39, 0x90, 0x3B, 0x70, 0x6A, 0x2B, 0xF9, 0x92, 
	0x98, 0x9B, 0xFE, 0xE2, 0x02, 0xC0, 0x6D, 0x12, 
	0x9E, 0xBD, 0x4D, 0x88, 0x05, 0x17, 0x74, 0xD3, 

	/* Database Page 10 */

	0xFF, 0x4D, 0x24, 0x17, 0x58, 0xB1, 0xAF, 0x55, 
	0x0E, 0x35, 0x7F, 0xEB, 0x4D, 0x2D, 0x13, 0x90, 
	0x82, 0x16, 0xD7, 0xA6, 0x7E, 0x1F, 0xA3, 0xEC, 
	0xCE, 0x9B, 0x26, 0x39, 0xB1, 0x23, 0x11, 0x8D, 
	0x0A, 0xCE, 0xAC, 0xBE, 0xF3, 0x53, 0xA7, 0xCA, 
	0xA4, 0x66, 0xE5, 0x83, 0xB9, 0xBF, 0xA9, 0xA6, 
	0xF3, 0x7A, 0xD0, 0x93, 0x2B, 0x56, 0x2B, 0x53, 
	0x12, 0x34, 0xAA, 0xA6, 0x57, 0xC4, 0xED, 0xB3, 
	0x75, 0x33, 0x11, 0x84, 0x66, 0x40, 0x41, 0xF2, 
	0x66, 0xBA, 0xF9, 0xAF, 0x6F, 0xE8, 0x6D, 0x67, 
	0xAF, 0xAE, 0x82, 0xBC, 0x96, 0xD4, 0x96, 0x04, 
	0x10, 0xE0, 0x2F, 0x50, 0xB6, 0x52, 0x05, 0x01, 
	0xF4, 0x1C, 0x97, 0xC8, 0xA7, 0x0B, 0x2C, 0xAA, 
	0xE3, 0x75, 0x13, 0x7F, 0x2D, 0x02, 0x8D, 0xF2, 
	0x40, 0x2A, 0xE9, 0xE3, 0xD6, 0x9A, 0xF9, 0xFA, 
	0xD0, 0x1A, 0x89, 0x9B, 0xFA, 0xF7, 0x68, 0xFB, 
	0x76, 0xFF, 0x7B, 0xF2, 0x12, 0x3D, 0xD1, 0x52, 
	0x84, 0xCA, 0x35, 0xB6, 0x0E, 0x96, 0xB5, 0xAA, 
	0x6C, 0xDF, 0xBF, 0xE5, 0x8B, 0x67, 0x25, 0xDA, 
	0x1F, 0xA1, 0x5E, 0xD4, 0xDB, 0xDE, 0xFE, 0xA0, 
	0x4E, 0x3A, 0x45, 0x8D, 0x84, 0x06, 0x19, 0x56, 
	0xC5, 0x4E, 0xAC, 0xA5, 0xAB, 0x59, 0x69, 0x98, 
	0x75, 0x2E, 0xC7, 0x87, 0x4C, 0xA1, 0x64, 0x00, 
	0x51, 0xDC, 0x6D, 0x99, 0x3F, 0xE8, 0x5A, 0xE2, 
	0x31, 0x94, 0x5B, 0x72, 0x60, 0x4F, 0xF2, 0x96, 
	0xF7, 0xD9, 0x65, 0x7C, 0xB8, 0xFC, 0x03, 0x3E, 
	0x79, 0xDF, 0x9C, 0xA4, 0x4A, 0xBD, 0xEB, 0x15, 
	0xBD, 0x0A, 0xB1, 0x5C, 0xF4, 0x59, 0x7F, 0xE0, 
	0x36, 0x8D, 0x64, 0x7F, 0x34, 0x84, 0x66, 0xA3, 
	0x27, 0x64, 0x7B, 0xAF, 0xAF, 0x25, 0xBB, 0x5E, 
	0x89, 0x69, 0xEF, 0x44, 0xAD, 0xA4, 0x82, 0xB6, 
	0x7A, 0xBB, 0x74, 0xD3, 0xEF, 0x19, 0x40, 0xB3, 
	0xC6, 0x6A, 0xFF, 0x11, 0xA5, 0xE5, 0x39, 0x06, 
	0xCD, 0xC1, 0x36, 0xE8, 0x3C, 0x68, 0x15, 0xB3, 
	0x24, 0x83, 0x7D, 0xE3, 0xBD, 0x30, 0x91, 0xFC, 
	0x99, 0x54, 0xB1, 0xBE, 0x27, 0xFF, 0x2E, 0xCE, 
	0xAC, 0xE3, 0xB9, 0x2C, 0xF5, 0xD8, 0x0D, 0x38, 
	0x1B, 0x7A, 0x5A, 0xB1, 0xFD, 0x77, 0x68, 0x61, 
	0xBB, 0x5A, 0x12, 0x3A, 0x39, 0x52, 0xCF, 0x6F, 
	0xD0, 0xA1, 0x92, 0x8F, 0x7B, 0x33, 0x98, 0x8C, 
	0x6A, 0xC7, 0x06, 0xF5, 0xA3, 0x1B, 0x5B, 0x60, 
	0x56, 0x1B, 0xA5, 0xC1, 0x68, 0x63, 0xDD, 0xE9, 
	0x47, 0xC2, 0x10, 0x2D, 0x80, 0x9C, 0xBF, 0xF7, 
	0x3E, 0x30, 0x72, 0x4A, 0x07, 0xE3, 0xCF, 0x2E, 
	0x39, 0xE0, 0x01, 0x68, 0xDD, 0x24, 0xDB, 0xBC, 
	0x28, 0x11, 0x7A, 0xE5, 0x12, 0x2A, 0xF9, 0x08, 
	0x76, 0x29, 0x27, 0x9F, 0x6A, 0x83, 0x98, 0x10, 
	0x06, 0x82, 0x5F, 0xBD, 0x19, 0x4C, 0x74, 0x19, 
	0x0F, 0x7E, 0x05, 0xFF, 0x33, 0x64, 0xB2, 0x87, 
	0x44, 0x7F, 0xBA, 0xA6, 0x70, 0xD6, 0xF2, 0x94, 
	0x2F, 0xD5, 0xAC, 0x7B, 0x69, 0xE5, 0x34, 0xE2, 
	0xE9, 0x66, 0x5D, 0x9B, 0x5B, 0x8E, 0x1F, 0xD8, 
	0xAC, 0xE6, 0x9A, 0x3D, 0x7D, 0x09, 0x96, 0x22, 
	0x6C, 0x1B, 0x88, 0x00, 0x45, 0xCB, 0x16, 0x45, 
	0xC5, 0xC2, 0x72, 0x30, 0x31, 0x74, 0x21, 0xC1, 
	0x48, 0x39, 0x0F, 0x16, 0x1E, 0x6B, 0x13, 0x45, 
	0xEB, 0x0A, 0xFF, 0x9B, 0xFF, 0xE6, 0xD2, 0x75, 
	0x39, 0x25, 0xCF, 0x20, 0x5F, 0x71, 0x33, 0xA3, 
	0x88, 0x44, 0x46, 0x8C, 0xE4, 0x57, 0xE4, 0x84, 
	0x6B, 0x78, 0x82, 0xC2, 0x10, 0xD7, 0xE3, 0x01, 
	0x63, 0x53, 0xD0, 0x72, 0x0A, 0x5D, 0x12, 0x86, 
	0x2D, 0xC2, 0x09, 0x12, 0xB1, 0xA0, 0x74, 0x00, 
	0x70, 0x64, 0x3E, 0xBE, 0x26, 0xE9, 0x5E, 0x85, 
	0x17, 0xD9, 0x62, 0xDA, 0xC4, 0x58, 0x8B, 0x4A, 
	0xDF, 0x9E, 0x6F, 0x54, 0xFF, 0x02, 0x5A, 0x7A, 
	0x66, 0x58, 0x7E, 0xDF, 0x7D, 0x56, 0x5D, 0x82, 
	0xD8, 0x09, 0xA7, 0x91, 0x6D, 0xFA, 0xE5, 0x11, 
	0x6C, 0x4C, 0xBF, 0x4A, 0x3D, 0x50, 0x2D, 0x3A, 
	0xFA, 0xE6, 0x98, 0x64, 0xE5, 0x74, 0xD3, 0x12, 
	0x8B, 0xEA, 0x7C, 0x5A, 0x4C, 0x62, 0xD8, 0x64, 
	0xD2, 0xEB, 0x65, 0xD2, 0x3B, 0x3B, 0x41, 0xEB, 
	0x82, 0x07, 0x4D, 0x51, 0x96, 0x78, 0x3F, 0xDC, 
	0xFD, 0xF2, 0x71, 0xA8, 0x89, 0xE7, 0xC0, 0x2C, 
	0x4C, 0xDF, 0x5B, 0x0C, 0x6D, 0x2B, 0x2F, 0x44, 
	0x7F, 0x0C, 0x51, 0x48, 0xD3, 0xDB, 0x1D, 0x0D, 
	0x98, 0x9F, 0x78, 0x40, 0x50, 0x0B, 0x24, 0x63, 
	0x96, 0x2B, 0x45, 0x0A, 0xC2, 0xFC, 0xDE, 0x3E, 
	0x24, 0x48, 0x13, 0xEE, 0x7F, 0x7E, 0x61, 0x4E, 
	0xA6, 0xF6, 0x7B, 0x84, 0xA5, 0x4C, 0xC1, 0x8B, 
	0xB0, 0x89, 0x0D, 0xAD, 0xF1, 0xA5, 0x2B, 0x77, 
	0xA6, 0x3F, 0x54, 0x1C, 0x08, 0xFF, 0xE7, 0x0A, 
	0x65, 0xDA, 0x7D, 0x39, 0x8D, 0x44, 0xB1, 0xBE, 
	0x81, 0x83, 0x79, 0x8D, 0x85, 0xFF, 0xD9, 0xB4, 
	0x2F, 0x6F, 0x72, 0xDC, 0x90, 0xCE, 0xBA, 0x0F, 
	0xA0, 0x1E, 0x96, 0x95, 0x10, 0x3B, 0xD0, 0xB3, 
	0x94, 0x8F, 0xF4, 0xA7, 0x34, 0x95, 0xAE, 0x44, 
	0xD7, 0xA9, 0x4A, 0xE5, 0xEE, 0x43, 0x9D, 0x8A, 
	0x51, 0xC5, 0x06, 0x92, 0x30, 0xA9, 0x2A, 0x2E, 
	0xA2, 0x28, 0xB5, 0xEF, 0xD5, 0x36, 0xEB, 0x70, 
	0x0E, 0x0E, 0x6C, 0xCB, 0xBC, 0xEC, 0xD6, 0x47, 
	0xBE, 0xBB, 0x86, 0x02, 0xE2, 0xDF, 0xCB, 0xDF, 
	0x95, 0x3D, 0xC3, 0x88, 0x6E, 0xA4, 0x65, 0x65, 
	0xBC, 0xDF, 0x80, 0x72, 0xFB, 0x92, 0xEA, 0x08, 
	0xE8, 0x76, 0xD9, 0x0A, 0x56, 0xBC, 0x04, 0x0D, 
	0x8E, 0x08, 0x5C, 0xB8, 0x85, 0xA6, 0x4F, 0x72, 
	0x1F, 0x06, 0x87, 0xF3, 0x5F, 0x4D, 0xBD, 0xE8, 
	0x0F, 0x68, 0xD0, 0xB6, 0xA8, 0x00, 0xFF, 0x73, 
	0x77, 0xCE, 0xB6, 0xD3, 0x33, 0xAD, 0xBD, 0x00, 
	0x06, 0xC7, 0x35, 0x9E, 0xBC, 0x4E, 0xD7, 0x5A, 
	0xBB, 0x31, 0xA9, 0xF4, 0x71, 0xA6, 0x69, 0x49, 
	0x5B, 0x49, 0x7D, 0x12, 0x06, 0x6C, 0x2E, 0xA6, 
	0x8F, 0xB0, 0x41, 0x82, 0x56, 0xA7, 0x48, 0x47, 
	0xD0, 0xAA, 0x5A, 0x26, 0xD1, 0xBB, 0x25, 0x0A, 
	0x55, 0x6E, 0xFD, 0xAE, 0xA7, 0x84, 0x22, 0x6C, 
	0x72, 0x97, 0xE4, 0x59, 0x7B, 0x2F, 0x53, 0xBC, 
	0x84, 0x6A, 0xD0, 0xF2, 0x93, 0x15, 0x51, 0x74, 
	0x40, 0x89, 0x91, 0x3F, 0xF4, 0xD2, 0x68, 0x18, 
	0xBC, 0x98, 0xE1, 0x15, 0x2D, 0x12, 0x5E, 0xCA, 
	0xD1, 0xEF, 0x3D, 0xF7, 0x5A, 0x74, 0x34, 0xA2, 
	0x4B, 0x36, 0x52, 0x77, 0x61, 0xDC, 0x66, 0x52, 
	0x72, 0x3B, 0x4E, 0xFB, 0x9B, 0xF8, 0x5E, 0x81, 
	0xE7, 0x0A, 0xF6, 0x4B, 0x67, 0x87, 0x96, 0x11, 
	0x7B, 0xF9, 0x9B, 0x4B, 0xD5, 0xD2, 0xDC, 0xFF, 
	0xAF, 0xF7, 0x1D, 0x08, 0xAC, 0xC7, 0x1E, 0x31, 
	0x59, 0x88, 0x32, 0x39, 0xE5, 0x7D, 0x26, 0x57, 
	0xEB, 0x4E, 0x46, 0x54, 0xBD, 0x32, 0xD3, 0xE1, 
	0x40, 0xD6, 0x77, 0xD2, 0x4C, 0x51, 0x4E, 0x2A, 
	0xB3, 0xEF, 0xBA, 0xCE, 0xA4, 0xE7, 0x02, 0xD8, 
	0xDE, 0x00, 0xD8, 0xF2, 0x71, 0x5B, 0xEE, 0x64, 
	0xDD, 0x37, 0xD4, 0xDC, 0xDB, 0xF0, 0xB5, 0xD2, 
	0xE1, 0xD5, 0x2A, 0xB4, 0x9D, 0x45, 0x37, 0xFA, 
	0xAC, 0x9C, 0xAF, 0x60, 0x1D, 0x88, 0xDC, 0xB4, 
	0xBB, 0xF6, 0x2B, 0x2E, 0xDF, 0xCB, 0x46, 0x83, 
	0x21, 0x03, 0x70, 0x8F, 0x30, 0xB8, 0x20, 0x3F, 
	0x7B, 0x94, 0x63, 0xB9, 0xEB, 0xF5, 0xD0, 0xDB, 
	0xC7, 0x28, 0x8A, 0xD3, 0x63, 0x2F, 0x5B, 0xE7, 
	0x47, 0x70, 0x42, 0xBD, 0x4A, 0x60, 0xC6, 0x62, 
	0x81, 0x58, 0x90, 0x5B, 0x20, 0xF8, 0x2C, 0xD1, 
	0x00, 0x51, 0x64, 0x37, 0x8C, 0xC5, 0x31, 0x1B, 
	0xFF, 0x7C, 0xC9, 0xE9, 0x4A, 0x1E, 0xA3, 0xB5, 
	0xD8, 0x99, 0xB0, 0xE5, 0x57, 0xC1, 0x42, 0xDC, 
	0x14, 0xDE, 0x08, 0x74, 0xF9, 0xDB, 0xB6, 0x78, 
	0xEC, 0x0F, 0x97, 0xFC, 0xD8, 0x4F, 0x1F, 0x31, 
	0xA7, 0x96, 0xAB, 0x89, 0x1A, 0xD9, 0x76, 0xA7, 
	0x19, 0xDE, 0xE1, 0x35, 0x84, 0x65, 0x3B, 0x71, 
	0xD7, 0x9A, 0xA9, 0x0D, 0x95, 0x7E, 0x58, 0x53, 
	0x19, 0xC0, 0xB3, 0xE6, 0xC1, 0x52, 0x2E, 0xDD, 
	0x50, 0xED, 0x80, 0xB0, 0x4E, 0xAB, 0x47, 0x31, 
	0x72, 0xE4, 0x21, 0xA7, 0xEB, 0x22, 0x58, 0x6C, 
	0x48, 0x3C, 0x3F, 0xC9, 0x24, 0xC6, 0xF5, 0x29, 
	0xDF, 0xD7, 0x59, 0x83, 0x22, 0xB9, 0xFC, 0xF8, 
	0xAE, 0x32, 0x57, 0x4B, 0x93, 0xD0, 0x3D, 0xB6, 
	0xA7, 0xFB, 0x60, 0x74, 0x7B, 0x9A, 0x64, 0x65, 
	0xDD, 0x85, 0x5C, 0x75, 0x7E, 0x73, 0xCB, 0x18, 
	0x5F, 0xE6, 0x6D, 0xAE, 0xF4, 0xAD, 0xBD, 0xB0, 
	0x55, 0xFF, 0x3B, 0x9A, 0x35, 0xF1, 0x6A, 0xA6, 
	0xB2, 0x15, 0x29, 0xC5, 0xA0, 0xCF, 0x8F, 0xA2, 
	0x5B, 0x92, 0x8D, 0xE7, 0xFD, 0x91, 0xC7, 0xBA, 
	0x15, 0xC8, 0x3F, 0xEB, 0x5B, 0x69, 0x43, 0xBF, 
	0xBA, 0xDC, 0x24, 0x87, 0x4A, 0xC9, 0x66, 0x11, 
	0xB3, 0x35, 0x1F, 0x6C, 0x66, 0x74, 0x8E, 0xA4, 
	0xFA, 0xD0, 0x18, 0x57, 0x13, 0xAF, 0xC4, 0x51, 
	0xC6, 0x66, 0xF2, 0x7F, 0xEB, 0xAE, 0xB1, 0x38, 
	0x2F, 0x34, 0xA8, 0xFB, 0x51, 0x6F, 0xFA, 0xB6, 
	0x83, 0xCD, 0x30, 0x25, 0x06, 0xCE, 0x0E, 0x1E, 
	0x12, 0x33, 0x32, 0x73, 0xD4, 0xF5, 0xBD, 0x3F, 
	0x0A, 0x2B, 0xFC, 0xF3, 0xDC, 0x7B, 0x00, 0x7B, 
	0xF6, 0x34, 0xCB, 0x5A, 0x90, 0xD9, 0x28, 0xC6, 
	0xB2, 0xEC, 0x2E, 0x2A, 0x9D, 0xA5, 0x9A, 0x4C, 
	0xD9, 0xEB, 0x31, 0xC4, 0x90, 0x33, 0xA8, 0xAD, 
	0x8D, 0x4F, 0x6B, 0x1B, 0x52, 0x29, 0xEF, 0x7B, 
	0x47, 0x8A, 0xFF, 0x0E, 0x0F, 0x6D, 0x85, 0x73, 
	0x4B, 0x72, 0x15, 0xA0, 0x28, 0x0A, 0xD2, 0x10, 
	0x24, 0x65, 0x43, 0x5B, 0x95, 0x25, 0xC9, 0x6E, 
	0xD2, 0x93, 0xE8, 0x9D, 0x95, 0x2B, 0x98, 0xB6, 
	0x5A, 0x90, 0xFA, 0x5D, 0xF4, 0x34, 0x57, 0x53, 
	0x4F, 0x40, 0x6C, 0xB9, 0x4D, 0x2C, 0xCE, 0x3F, 
	0xFD, 0x66, 0xF4, 0x5A, 0x95, 0x05, 0x6F, 0x7F, 
	0x81, 0x6B, 0xA8, 0x06, 0x9F, 0xEE, 0xA2, 0xAC, 
	0x09, 0x61, 0xAB, 0xFC, 0xCE, 0xEC, 0xAE, 0x5E, 
	0xA6, 0x09, 0x71, 0xED, 0x3A, 0x5B, 0x49, 0xF8, 
	0x78, 0xAB, 0xCC, 0xC2, 0xEE, 0x5F, 0x06, 0x47, 
	0xF5, 0x20, 0xF8, 0xCE, 0x1C, 0xBB, 0x93, 0xB8, 
	0x39, 0xD8, 0xBD, 0x4E, 0xF0, 0x2F, 0xF3, 0x69, 
	0xC9, 0x72, 0x9E, 0x3C, 0x33, 0xD9, 0xB0, 0x0F, 
	0x4E, 0x5C, 0x92, 0xF2, 0x50, 0x18, 0xB5, 0x8A, 
	0xE5, 0x7B, 0xAE, 0xB3, 0x8B, 0xD8, 0x05, 0x94, 
	0xCB, 0x48, 0x2D, 0xFF, 0x63, 0x67, 0x56, 0xD6, 
	0x9A, 0x7E, 0x26, 0x4B, 0xDA, 0xD3, 0x34, 0xBF, 
	0xC7, 0x35, 0xF5, 0x56, 0xF0, 0x09, 0x94, 0xCF, 
	0xDD, 0xB1, 0xCA, 0xB6, 0x7A, 0xE9, 0x1E, 0x9A, 
	0xEC, 0x8C, 0x81, 0xF2, 0xDC, 0xE1, 0x06, 0xA1, 
	0xF1, 0x09, 0x07, 0x71, 0x27, 0xD1, 0xAD, 0x2F, 
	0xB0, 0xB0, 0xDD, 0xE5, 0x59, 0x5B, 0xE9, 0xA5, 
	0x71, 0x1A, 0x69, 0xD1, 0x72, 0x2A, 0x8F, 0x8C, 
	0x38, 0xBE, 0x02, 0x9B, 0x2F, 0x64, 0xFF, 0x2E, 
	0x71, 0x96, 0x0F, 0xA6, 0x5C, 0x78, 0xE5, 0x81, 
	0x8B, 0x3A, 0x3A, 0x0A, 0x01, 0x96, 0x04, 0x9C, 
	0xBF, 0x96, 0xB1, 0x3C, 0x0D, 0xAA, 0x86, 0x55, 
	0x03, 0x53, 0xD4, 0xEE, 0x4D, 0x52, 0x81, 0x29, 
	0x24, 0xBE, 0x49, 0x5A, 0x6B, 0x1D, 0x81, 0x6A, 
	0x2A, 0xF6, 0x38, 0x83, 0xE3, 0xCC, 0x1D, 0xE9, 
	0x17, 0xD3, 0x91, 0x7A, 0xF9, 0xE3, 0x5F, 0xF7, 
	0x98, 0xA4, 0x47, 0x74, 0xFF, 0x3D, 0x61, 0x95, 
	0x7B, 0x52, 0xB9, 0x15, 0x97, 0x93, 0xA9, 0x6F, 
	0x22, 0xAE, 0x0A, 0x14, 0x7A, 0x8E, 0xB0, 0x41, 
	0xE5, 0x07, 0xE3, 0x08, 0x64, 0x99, 0x45, 0x02, 
	0x2B, 0x7C, 0x66, 0xFF, 0x1A, 0x99, 0xB2, 0x72, 
	0xB8, 0x1A, 0x7E, 0x98, 0x2D, 0x2A, 0xDB, 0xF9, 
	0xFB, 0x30, 0x2E, 0xA2, 0x29, 0x79, 0xFA, 0xC7, 
	0x04, 0x3E, 0xEB, 0x05, 0xEC, 0x2F, 0xE6, 0x8B, 
	0x79, 0xFD, 0x38, 0xF7, 0x19, 0xA2, 0x6E, 0x0A, 
	0x2D, 0x59, 0x61, 0x13, 0x21, 0x54, 0x9C, 0xC5, 
	0x4F, 0x8D, 0xFD, 0xF2, 0xD3, 0xA1, 0x06, 0x59, 
	0xA1, 0xF0, 0xFE, 0x5B, 0xB2, 0xF8, 0x81, 0xD7, 
	0xED, 0x45, 0x5B, 0xF5, 0x22, 0x46, 0x97, 0x87, 
	0x4A, 0x54, 0xBD, 0x04, 0x3B, 0x88, 0x42, 0xCF, 
	0x55, 0x51, 0x6D, 0x7B, 0xD3, 0xE1, 0xF5, 0xE0, 
	0x48, 0xA6, 0x75, 0x9B, 0xFA, 0x55, 0x5E, 0x2E, 
	0xDF, 0xD1, 0xB0, 0xFA, 0xC1, 0xFF, 0x2C, 0x4B, 
	0x8D, 0xE5, 0x93, 0xC2, 0x9A, 0x67, 0x2E, 0xB9, 
	0x83, 0x79, 0x68, 0x51, 0xD7, 0xE7, 0xE3, 0x60, 
	0x9D, 0xF2, 0x56, 0xAA, 0xF4, 0x7F, 0xC6, 0x9E, 
	0xE3, 0x13, 0x16, 0x1A, 0x9A, 0x28, 0xC6, 0xCB, 
	0xAD, 0x61, 0x3F, 0xF7, 0xA9, 0x00, 0xA8, 0xFC, 
	0x1B, 0x38, 0x5C, 0xBC, 0xD7, 0x1F, 0x6E, 0xED, 
	0x41, 0x66, 0x29, 0x5D, 0x26, 0x0B, 0x05, 0x28, 
	0x26, 0x83, 0xAA, 0x1E, 0x35, 0xC8, 0xFB, 0x18, 
	0x17, 0xBD, 0x11, 0x20, 0xAD, 0xAE, 0x0D, 0x06, 
	0xFC, 0x13, 0xD5, 0x57, 0x6B, 0xDE, 0x45, 0xBF, 
	0x6C, 0x4A, 0xF8, 0xA8, 0x41, 0x02, 0xFD, 0xD4, 
	0xE6, 0xC5, 0x2C, 0xAF, 0xFA, 0xAF, 0xCF, 0xDA, 
	0x00, 0x8F, 0x90, 0x3F, 0x94, 0x78, 0x4C, 0xAF, 
	0xAC, 0x70, 0x7C, 0x71, 0x25, 0x84, 0x36, 0xB1, 
	0x60, 0x83, 0xD9, 0xD1, 0x50, 0x4E, 0x30, 0x18, 
	0x48, 0xB4, 0x79, 0x6E, 0x76, 0x48, 0xFF, 0x9A, 
	0xCD, 0x94, 0x52, 0xDB, 0xB3, 0x06, 0xB4, 0x7F, 
	0xCF, 0xB1, 0xC4, 0x73, 0xA1, 0x8D, 0x32, 0x8D, 
	0xF0, 0xFC, 0x2F, 0xBB, 0xB5, 0x95, 0x31, 0x5E, 
	0x8D, 0x77, 0x52, 0x4C, 0x5C, 0x38, 0x00, 0xD3, 
	0x12, 0x0C, 0x36, 0xD5, 0x55, 0xE4, 0x02, 0x02, 
	0x81, 0x8A, 0x0D, 0xA1, 0x62, 0x44, 0xC8, 0x52, 
	0xF4, 0x40, 0xCF, 0xAD, 0x03, 0x17, 0xD9, 0xF6, 
	0xC2, 0xBC, 0x77, 0x63, 0xC5, 0x25, 0xBE, 0x7B, 
	0x71, 0x98, 0x29, 0xCD, 0x29, 0x7B, 0xAE, 0x95, 
	0x20, 0x6D, 0x6A, 0x23, 0xEC, 0x51, 0x87, 0xB0, 
	0xF2, 0xF9, 0x58, 0x5D, 0x80, 0xC1, 0xF3, 0xFE, 
	0x5D, 0x17, 0x02, 0x3B, 0x56, 0x40, 0x74, 0x96, 
	0x15, 0xB6, 0xDD, 0x25, 0x4B, 0xED, 0x84, 0x13, 
	0x37, 0x3E, 0x70, 0xFD, 0x41, 0x3F, 0xFD, 0x5D, 
	0xF1, 0xA4, 0x03, 0xC6, 0xB0, 0x6C, 0xCE, 0x23, 
	0x57, 0x43, 0x8D, 0xD4, 0x0A, 0x40, 0xF8, 0xFF, 
	0xCB, 0x47, 0x2E, 0x46, 0xCA, 0x4B, 0x9C, 0x7F, 
	0x57, 0x19, 0x65, 0xDE, 0x39, 0xC0, 0xA3, 0x8D, 
	0x74, 0x94, 0x11, 0xBB, 0x75, 0xB1, 0x41, 0xE2, 
	0xFB, 0xA4, 0x1A, 0x6C, 0x45, 0x78, 0xDE, 0x1C, 
	0x74, 0x6C, 0xEC, 0x1D, 0x98, 0xE6, 0x94, 0x26, 
	0x7D, 0x77, 0xC0, 0x6C, 0x1C, 0x12, 0xF2, 0xB0, 
	0xA2, 0xF6, 0xE2, 0xA8, 0x28, 0x11, 0x0E, 0x7A, 
	0x81, 0x0E, 0x48, 0x84, 0x54, 0xEB, 0x62, 0x10, 
	0xA5, 0x44, 0xEE, 0x77, 0xC6, 0xCA, 0xAF, 0xC2, 
	0x84, 0xA5, 0x6E, 0x79, 0x39, 0x4D, 0x8F, 0x77, 
	0x01, 0x68, 0x69, 0xA8, 0xAA, 0xB8, 0x89, 0xE9, 
	0x3E, 0xCC, 0x8F, 0x2C, 0x77, 0x6A, 0x62, 0xE4, 
	0x49, 0xF2, 0xD7, 0xAB, 0x89, 0x23, 0x25, 0xF3, 
	0x49, 0xF8, 0xB1, 0xE4, 0x4C, 0x2A, 0xBA, 0x97, 
	0xD3, 0x71, 0x95, 0xC8, 0x8E, 0x80, 0x26, 0x4F, 
	0x7F, 0x22, 0x1D, 0x8F, 0x3F, 0x4D, 0xB2, 0xF3, 

	/* Database Page 11 */

	0xFF, 0xA3, 0xD6, 0x36, 0x7A, 0xB0, 0xB9, 0x83, 
	0xD2, 0xB6, 0x01, 0x2B, 0x37, 0xBC, 0x78, 0x47, 
	0x63, 0x83, 0xC1, 0x39, 0x6C, 0xC0, 0xB4, 0x4E, 
	0xAB, 0x14, 0xD4, 0x9A, 0x71, 0xDF, 0x5F, 0x55, 
	0x2E, 0x5B, 0x38, 0xAB, 0x45, 0x7C, 0x88, 0xCD, 
	0x62, 0x26, 0x3D, 0x2E, 0x2E, 0x34, 0x10, 0x43, 
	0xB2, 0xD8, 0xDF, 0x4C, 0x92, 0xFD, 0xD7, 0x5E, 
	0xE1, 0xB1, 0x24, 0x10, 0x02, 0x3A, 0x29, 0xDC, 
	0x11, 0x48, 0xD3, 0xD9, 0xEA, 0x35, 0x98, 0x7B, 
	0xB5, 0x52, 0x75, 0x43, 0xD8, 0xEA, 0xAC, 0xB0, 
	0x2E, 0x54, 0xDE, 0xB6, 0xB2, 0xCA, 0x7B, 0xF4, 
	0x29, 0x60, 0xA7, 0x85, 0x64, 0x73, 0x41, 0x67, 
	0xEA, 0x61, 0x1E, 0x92, 0x4E, 0x79, 0x18, 0x49, 
	0xD7, 0x00, 0xDA, 0x30, 0x39, 0x20, 0xA5, 0xC0, 
	0x41, 0x22, 0xF4, 0x16, 0x25, 0x20, 0x51, 0x6A, 
	0x27, 0xF1, 0x63, 0x86, 0xC4, 0x7D, 0x37, 0xA0, 
	0x61, 0xFF, 0x8D, 0xA5, 0x35, 0xB7, 0x2D, 0x89, 
	0x8C, 0xBE, 0xEF, 0x11, 0xB4, 0x99, 0x15, 0xBB, 
	0x74, 0x19, 0xAE, 0x07, 0xA4, 0xE4, 0x62, 0xFD, 
	0xCA, 0x57, 0x5B, 0x87, 0x25, 0x62, 0x4B, 0xFE, 
	0x57, 0x54, 0xA3, 0x12, 0x8C, 0xB7, 0xA9, 0x79, 
	0x74, 0x41, 0xF4, 0xF4, 0xC3, 0x62, 0xA7, 0xE5, 
	0x71, 0xED, 0x87, 0x8E, 0x74, 0x0F, 0x30, 0x00, 
	0xDF, 0xB6, 0x0B, 0x53, 0x3D, 0x1A, 0xB4, 0xB9, 
	0xA5, 0x25, 0xC5, 0x03, 0xC0, 0x63, 0xA0, 0xFF, 
	0x27, 0x20, 0x4A, 0x9B, 0x5C, 0xB7, 0xE5, 0xEF, 
	0x1B, 0x2F, 0x3B, 0x25, 0xE1, 0xA7, 0xC8, 0x9B, 
	0xE3, 0xDD, 0x42, 0xA1, 0xBB, 0x9A, 0xB4, 0x7D, 
	0x66, 0x59, 0xD5, 0xF0, 0xFE, 0x7D, 0xD8, 0x22, 
	0x42, 0x03, 0xBF, 0xF4, 0x56, 0xDC, 0xE5, 0x6F, 
	0xF4, 0xB2, 0x42, 0x31, 0x16, 0xFB, 0x36, 0xD4, 
	0xF0, 0x73, 0xA7, 0x3B, 0x4C, 0x36, 0xEA, 0x63, 
	0x44, 0x05, 0xFF, 0x34, 0x8D, 0xBA, 0xFC, 0xBF, 
	0x5D, 0x2C, 0x1D, 0xC0, 0x6E, 0xE4, 0xDA, 0x55, 
	0xBD, 0x74, 0x85, 0xB6, 0x5D, 0x0F, 0x56, 0x64, 
	0xBA, 0xA2, 0xF0, 0xD0, 0x84, 0xDA, 0xDC, 0xB0, 
	0x82, 0xF5, 0x5D, 0xD8, 0x47, 0xBC, 0x80, 0x0B, 
	0xA5, 0x0F, 0xDC, 0xE2, 0xC6, 0xFF, 0x56, 0xF8, 
	0xB5, 0x14, 0x7A, 0xD7, 0xA8, 0xD1, 0x87, 0x9E, 
	0x76, 0xB1, 0x26, 0x67, 0x25, 0xB9, 0x73, 0x74, 
	0xF1, 0xF3, 0x0F, 0xC6, 0xB2, 0xE5, 0x96, 0x8E, 
	0x7B, 0x0F, 0x6D, 0x02, 0x6B, 0x2B, 0xB1, 0xEA, 
	0x62, 0x6D, 0xA8, 0x46, 0x3E, 0xDE, 0x96, 0x79, 
	0xE7, 0x34, 0x51, 0x91, 0x31, 0xB6, 0x1C, 0x17, 
	0x01, 0xF9, 0xA7, 0x97, 0xB1, 0x80, 0x3D, 0x4D, 
	0x2E, 0xCB, 0x04, 0x85, 0xFF, 0x05, 0x2B, 0x18, 
	0xE3, 0x64, 0x2F, 0x41, 0xC2, 0x68, 0x70, 0x9F, 
	0xDC, 0xDB, 0x45, 0x16, 0x5B, 0x13, 0x68, 0x09, 
	0x50, 0x13, 0xDF, 0xFF, 0x7D, 0x88, 0x1B, 0x2A, 
	0x2E, 0x17, 0x60, 0xAB, 0x08, 0x79, 0x6D, 0x75, 
	0xD7, 0x1D, 0x87, 0xE6, 0xAF, 0xA8, 0x25, 0xA1, 
	0x96, 0xDD, 0x77, 0xB0, 0x84, 0xE2, 0xD8, 0xDB, 
	0xC5, 0x2C, 0x96, 0xC2, 0xC9, 0x9F, 0x95, 0xCB, 
	0x65, 0x2A, 0x5C, 0x20, 0x48, 0x02, 0x85, 0x08, 
	0x88, 0x49, 0xC3, 0x8F, 0xF1, 0x2D, 0x4E, 0x49, 
	0x58, 0x6F, 0x3A, 0x53, 0xDA, 0x6F, 0x84, 0x8C, 
	0x03, 0xE6, 0xCB, 0xD9, 0xEB, 0x57, 0xA5, 0x9C, 
	0xA4, 0xF3, 0xB6, 0xC8, 0x70, 0xBA, 0xAB, 0x57, 
	0xAF, 0x61, 0x2B, 0xA6, 0xB1, 0xC4, 0x22, 0x0B, 
	0xFC, 0x7F, 0x61, 0x24, 0x16, 0x7B, 0x35, 0xAB, 
	0xDD, 0x83, 0xF2, 0x76, 0x79, 0xDE, 0x7D, 0x14, 
	0xBB, 0x82, 0xB7, 0x16, 0x08, 0xEA, 0xD4, 0x47, 
	0x48, 0xDE, 0x8E, 0x79, 0x42, 0x5D, 0x82, 0xA0, 
	0xFE, 0x24, 0x7F, 0x1D, 0xB8, 0x24, 0x84, 0xAB, 
	0xEE, 0x4B, 0x79, 0xB8, 0xFF, 0xAD, 0xBE, 0xC5, 
	0x57, 0x4D, 0x76, 0x8E, 0xF9, 0x08, 0xDD, 0xF7, 
	0x1A, 0x5C, 0xFA, 0x08, 0x3B, 0xB6, 0xE0, 0x79, 
	0xAE, 0xFC, 0xC0, 0x16, 0x23, 0x49, 0x94, 0x90, 
	0x26, 0x2E, 0xF9, 0xED, 0x0A, 0xBA, 0x5E, 0x9F, 
	0x38, 0x52, 0x2C, 0xB7, 0x44, 0x8C, 0xFE, 0x44, 
	0x3C, 0x7A, 0x35, 0xF0, 0x55, 0x51, 0xB3, 0x4C, 
	0x77, 0xC6, 0x5B, 0x8C, 0x54, 0xD6, 0xB7, 0xE6, 
	0xF4, 0x36, 0x16, 0xF4, 0xDC, 0xE7, 0xFD, 0xCF, 
	0x5F, 0x30, 0x5A, 0x64, 0xB0, 0x3D, 0x02, 0x35, 
	0x76, 0xD8, 0x5C, 0x3A, 0xC4, 0x7C, 0x95, 0xD1, 
	0x50, 0x7E, 0x1C, 0x21, 0xF0, 0x9E, 0x97, 0x1A, 
	0x07, 0x18, 0xFB, 0x4B, 0xC5, 0x5F, 0xF0, 0x48, 
	0x5B, 0x6B, 0xEF, 0x14, 0x28, 0x39, 0x8E, 0xB9, 
	0xE3, 0xC6, 0xD6, 0x2F, 0x69, 0x77, 0xB8, 0xFE, 
	0xAA, 0xAD, 0x82, 0x9F, 0xA0, 0xC0, 0xDF, 0xED, 
	0xEC, 0xDC, 0x43, 0xB6, 0xD9, 0xFF, 0x83, 0xC9, 
	0x64, 0xDE, 0xD3, 0x10, 0x5E, 0x70, 0xB6, 0x67, 
	0xDD, 0x5D, 0x23, 0xBE, 0xCE, 0x3B, 0xF2, 0x00, 
	0x5F, 0x78, 0xF4, 0x97, 0x2E, 0x3C, 0xB7, 0x95, 
	0x63, 0x00, 0x94, 0xB3, 0x1D, 0x05, 0x64, 0x9F, 
	0xDA, 0x8F, 0x9A, 0x6A, 0x07, 0xD0, 0xC6, 0xD4, 
	0xE0, 0x50, 0xB9, 0xD6, 0x7C, 0x0B, 0x4F, 0xF2, 
	0x8C, 0x6B, 0x4B, 0x73, 0x2E, 0x3A, 0x4F, 0xF9, 
	0x28, 0x39, 0x7E, 0x77, 0xCF, 0x88, 0x58, 0x15, 
	0xF4, 0x22, 0x07, 0x3E, 0xE5, 0xD7, 0xFE, 0x89, 
	0xFB, 0x7C, 0x20, 0x93, 0x49, 0x40, 0x9C, 0x3F, 
	0xB2, 0xF8, 0x51, 0x56, 0xB8, 0xA8, 0xEF, 0xD2, 
	0x65, 0xCD, 0x2C, 0xC5, 0xFB, 0xEE, 0xFF, 0x26, 
	0xB3, 0xFF, 0x42, 0x07, 0xA0, 0xF1, 0x74, 0xB0, 
	0x0F, 0xF4, 0xD1, 0x9D, 0x1A, 0x7C, 0x03, 0x91, 
	0x35, 0xF6, 0x16, 0x26, 0xC9, 0xBB, 0xCA, 0x53, 
	0x0A, 0x47, 0xAF, 0x5E, 0xA4, 0x31, 0xFF, 0x48, 
	0x4C, 0x28, 0xB4, 0x5F, 0x3D, 0xFD, 0x02, 0x09, 
	0xE2, 0xDC, 0x6C, 0xB7, 0x75, 0x1A, 0xEB, 0x87, 
	0xE7, 0x04, 0x06, 0x9F, 0x0E, 0x53, 0xB3, 0x41, 
	0x15, 0x19, 0x9B, 0x6C, 0x42, 0xD5, 0x6F, 0x76, 
	0x66, 0x26, 0x6B, 0x30, 0xA5, 0xC7, 0xA6, 0x2D, 
	0x3C, 0x5E, 0x83, 0x0D, 0x6C, 0x11, 0x2A, 0x06, 
	0x10, 0x2E, 0x07, 0x17, 0x51, 0xDC, 0x7A, 0x42, 
	0x0B, 0x06, 0x9A, 0x37, 0x04, 0x07, 0x61, 0x27, 
	0xAD, 0x09, 0xF9, 0x26, 0xFE, 0x5C, 0x49, 0x8A, 
	0x25, 0x84, 0xFC, 0xD1, 0xA2, 0x07, 0xA7, 0x78, 
	0x84, 0x4D, 0x0A, 0x5E, 0x18, 0xF5, 0x22, 0xE7, 
	0xC1, 0x0E, 0x84, 0xDD, 0x1E, 0xC6, 0xD9, 0x6E, 
	0x59, 0x3A, 0xD6, 0xA2, 0xE8, 0xA9, 0xD3, 0x48, 
	0x37, 0xE5, 0x37, 0x5E, 0xA3, 0x80, 0xB5, 0x91, 
	0x05, 0xAC, 0x7A, 0x25, 0xBB, 0x6A, 0xA1, 0x77, 
	0xB1, 0x70, 0xDD, 0xAD, 0xBD, 0x89, 0x48, 0xFF, 
	0x0A, 0x42, 0x14, 0xEB, 0x48, 0xCC, 0xD8, 0xF2, 
	0xD4, 0x47, 0xE8, 0xBA, 0x9B, 0xBE, 0x53, 0xAD, 
	0xED, 0xA2, 0x82, 0xD2, 0xA3, 0x32, 0x80, 0x33, 
	0x2B, 0x3F, 0xBD, 0xC5, 0xB2, 0x75, 0x11, 0xE4, 
	0x61, 0x4A, 0xC4, 0x0A, 0xCE, 0x71, 0x71, 0xC4, 
	0x8F, 0x5D, 0x11, 0x9D, 0x46, 0xE2, 0x8B, 0x7F, 
	0xED, 0xEA, 0x3A, 0x7A, 0xAE, 0xBD, 0x69, 0xCC, 
	0xBF, 0xCE, 0x24, 0x0B, 0x79, 0xF4, 0xAF, 0x4A, 
	0x6F, 0xEE, 0x8D, 0x75, 0x81, 0x72, 0x30, 0x62, 
	0x68, 0x1F, 0x98, 0x34, 0x32, 0x83, 0x4A, 0xFE, 
	0xF7, 0x99, 0x00, 0x46, 0x40, 0xF9, 0xC0, 0x10, 
	0xB9, 0x38, 0x21, 0xFF, 0x7F, 0x13, 0x48, 0xC4, 
	0x4F, 0xA3, 0x8E, 0xFC, 0x7E, 0x0C, 0x5D, 0xCA, 
	0xE6, 0xE0, 0x42, 0xCA, 0x28, 0xE1, 0x47, 0x71, 
	0xFC, 0xA1, 0x74, 0xF3, 0xFD, 0xD4, 0xFE, 0x70, 
	0x0E, 0xD3, 0x16, 0xEA, 0x82, 0xCD, 0xDF, 0x6C, 
	0xFF, 0xA9, 0xF8, 0x79, 0x4F, 0x74, 0x05, 0x89, 
	0x7F, 0x66, 0xA8, 0xE1, 0x8A, 0xDA, 0x68, 0x3D, 
	0x0F, 0xFE, 0xF4, 0x32, 0x38, 0x4C, 0x26, 0x80, 
	0xBF, 0xCB, 0x53, 0xC2, 0xBE, 0x4E, 0x79, 0x95, 
	0xE1, 0xD2, 0x7E, 0x07, 0xB8, 0xBB, 0xB4, 0x8B, 
	0x86, 0xB3, 0x12, 0xBD, 0x3E, 0x15, 0xAC, 0x45, 
	0x83, 0x43, 0xB9, 0x2C, 0x40, 0x32, 0x9B, 0xB2, 
	0x78, 0x65, 0x44, 0x8A, 0x99, 0xCB, 0x18, 0x37, 
	0x1E, 0x45, 0xEA, 0xB8, 0x14, 0x52, 0xE4, 0x86, 
	0xF3, 0x39, 0xA6, 0xF9, 0x99, 0x74, 0x16, 0x6D, 
	0xB7, 0xCE, 0xC5, 0x0B, 0x07, 0x9B, 0xD3, 0x0D, 
	0x17, 0x1B, 0x38, 0x6C, 0x8C, 0x42, 0xC0, 0x81, 
	0x54, 0x86, 0x42, 0xD8, 0x44, 0x69, 0x20, 0x95, 
	0x09, 0x8F, 0xC3, 0x6B, 0xE4, 0x83, 0x5A, 0x98, 
	0xF6, 0x44, 0xDD, 0xEE, 0x6B, 0x0C, 0xA0, 0x7A, 
	0xB9, 0x55, 0x2C, 0xF9, 0x84, 0x07, 0xB8, 0x64, 
	0xF1, 0xFF, 0xD9, 0xBA, 0x41, 0x61, 0xC5, 0xA4, 
	0x19, 0x43, 0x52, 0x3E, 0xA0, 0xE2, 0x76, 0x0A, 
	0x31, 0x49, 0x97, 0x25, 0xD3, 0xAF, 0x0D, 0xC7, 
	0x5D, 0x86, 0x51, 0x93, 0x79, 0xBE, 0xFB, 0x22, 
	0x52, 0x66, 0x63, 0x51, 0x39, 0xD4, 0x68, 0x83, 
	0x89, 0x7B, 0x72, 0x9B, 0x99, 0x6A, 0x5A, 0x86, 
	0x03, 0xE7, 0x87, 0x0F, 0x1C, 0x05, 0xB2, 0x10, 
	0xE4, 0xD8, 0xB2, 0x22, 0xF6, 0x97, 0x8E, 0x4A, 
	0x4B, 0x47, 0x81, 0xB2, 0x44, 0xD3, 0x0A, 0xDA, 
	0x7C, 0x93, 0x66, 0xE7, 0x77, 0xD6, 0x06, 0xE9, 
	0x42, 0x9B, 0xF1, 0x5E, 0x2F, 0xE7, 0x16, 0xFB, 
	0x05, 0x40, 0x50, 0x0E, 0x85, 0x41, 0xB5, 0xC6, 
	0xE9, 0x84, 0xDD, 0x78, 0xF4, 0xCC, 0xB6, 0x72, 
	0xF3, 0x38, 0xD9, 0x14, 0x56, 0x6C, 0x73, 0x88, 
	0x41, 0x4B, 0x40, 0x06, 0xA3, 0x28, 0x17, 0x41, 
	0x37, 0xB5, 0xA1, 0x94, 0xCE, 0xC8, 0x8A, 0x9B, 
	0x1D, 0x58, 0xFF, 0x51, 0x0C, 0x61, 0x49, 0x81, 
	0xB8, 0xB4, 0x99, 0x22, 0xD9, 0x66, 0x9E, 0x13, 
	0x60, 0x3D, 0xF0, 0x52, 0x79, 0x59, 0x2A, 0x2A, 
	0xB4, 0xC6, 0xB9, 0x47, 0x90, 0xA3, 0xE1, 0xC7, 
	0xB5, 0xB0, 0x57, 0xEB, 0x7A, 0xFF, 0x83, 0xFB, 
	0x5C, 0x2F, 0xF3, 0x4F, 0x82, 0x26, 0xD7, 0xF8, 
	0x4C, 0xF5, 0x8B, 0x9B, 0x4A, 0x0E, 0xD4, 0xD0, 
	0x16, 0x48, 0xAA, 0x16, 0x37, 0xAD, 0x3F, 0x94, 
	0xD6, 0xB0, 0xCC, 0xBE, 0xAB, 0x31, 0x44, 0xBD, 
	0x7C, 0xAF, 0xCD, 0xAE, 0xB9, 0x28, 0xB0, 0x77, 
	0xAE, 0x54, 0x04, 0x65, 0x9E, 0xF7, 0xA8, 0xA6, 
	0x40, 0x9D, 0x2A, 0x53, 0x07, 0x69, 0x7A, 0x52, 
	0x93, 0x6B, 0x8E, 0x0C, 0x05, 0xB3, 0x06, 0x55, 
	0xB0, 0xBD, 0xA6, 0xFD, 0xA3, 0xBE, 0x34, 0x3D, 
	0x1C, 0x07, 0xC3, 0x13, 0xF7, 0x25, 0x85, 0x24, 
	0x55, 0x04, 0xCB, 0xEB, 0x3F, 0x74, 0x3F, 0x22, 
	0x39, 0x43, 0xD6, 0xFF, 0xEA, 0xBA, 0xE7, 0xCF, 
	0x06, 0x55, 0x01, 0xC1, 0xE4, 0x6B, 0x08, 0xF5, 
	0x06, 0x3D, 0x0C, 0xDA, 0xD5, 0xB6, 0x05, 0x8D, 
	0xB3, 0x14, 0x85, 0xFD, 0x9F, 0xB4, 0xF1, 0xFC, 
	0x20, 0x1B, 0x20, 0xD4, 0xCF, 0x81, 0x69, 0x81, 
	0x12, 0xEA, 0xFF, 0x6B, 0x79, 0xEE, 0x96, 0x36, 
	0x3A, 0x3A, 0xD4, 0x02, 0x09, 0xFD, 0xAA, 0xFB, 
	0x2C, 0x66, 0x6F, 0xD6, 0x1E, 0x89, 0xA4, 0x3C, 
	0x7D, 0x4A, 0xAB, 0x2C, 0xA7, 0x3D, 0x25, 0xB2, 
	0xD5, 0x47, 0xD5, 0xB1, 0x16, 0x41, 0xB1, 0x67, 
	0x82, 0x7D, 0x3E, 0xEA, 0x0A, 0xE4, 0xEE, 0x33, 
	0xA5, 0xF3, 0x08, 0xB7, 0x14, 0x47, 0x28, 0x6A, 
	0x6E, 0x5D, 0x55, 0xA3, 0xBA, 0x28, 0x55, 0xAA, 
	0xBC, 0xCA, 0x0E, 0xDB, 0x2B, 0x42, 0xDA, 0x81, 
	0x0E, 0xC6, 0x29, 0xF5, 0x21, 0x88, 0x5D, 0x3D, 
	0x0E, 0x1A, 0x87, 0x9A, 0x87, 0x87, 0x3B, 0x00, 
	0xE7, 0x70, 0xD1, 0x7E, 0xFF, 0xF7, 0x69, 0x74, 
	0x49, 0x04, 0xDA, 0x28, 0xCB, 0xBB, 0x97, 0x08, 
	0x2D, 0x3C, 0x1D, 0x6F, 0x70, 0x62, 0xC1, 0x98, 
	0xF6, 0x1D, 0x88, 0xAB, 0x88, 0x8B, 0x16, 0xEF, 
	0x4A, 0x26, 0xAC, 0xA0, 0xD7, 0x98, 0x65, 0x4D, 
	0x2E, 0xE2, 0x7B, 0x71, 0xA0, 0x29, 0xF0, 0x43, 
	0x4A, 0x78, 0x3C, 0x36, 0x0A, 0x52, 0xD5, 0x20, 
	0xEC, 0x2C, 0xFA, 0xB9, 0xB5, 0x4E, 0xC8, 0xC3, 
	0xCA, 0xED, 0xE5, 0x34, 0x23, 0x5A, 0x50, 0xCB, 
	0xF2, 0xCF, 0x99, 0xA4, 0x8C, 0x91, 0xB7, 0x3E, 
	0x69, 0xBB, 0xB5, 0x29, 0xF5, 0x02, 0xE6, 0x34, 
	0xA3, 0xBA, 0xC7, 0x0F, 0x76, 0x71, 0x9C, 0x9D, 
	0x3C, 0x43, 0x54, 0x40, 0x80, 0x48, 0x1B, 0x86, 
	0x94, 0x33, 0x5E, 0xDD, 0xD6, 0x44, 0xF1, 0x16, 
	0xD0, 0x29, 0x80, 0x8C, 0x53, 0xEC, 0x06, 0xC7, 
	0x1F, 0x49, 0x6A, 0x92, 0x08, 0x39, 0x4C, 0xA2, 
	0xD7, 0x77, 0xA4, 0x76, 0xBD, 0xFF, 0x1E, 0xFB, 
	0xB2, 0xA0, 0x93, 0xD2, 0xE9, 0xCD, 0x6E, 0x91, 
	0x41, 0xF9, 0x08, 0x4F, 0xAD, 0x9D, 0x3E, 0x3D, 
	0xC0, 0x70, 0x90, 0x46, 0xFD, 0x8B, 0x2F, 0x5C, 
	0xAE, 0x05, 0x57, 0x41, 0x7D, 0xB0, 0x5B, 0x36, 
	0xF0, 0xC8, 0x8E, 0x5F, 0x7C, 0x83, 0x3C, 0x9E, 
	0x0D, 0xF9, 0x8C, 0x4D, 0x3F, 0xE3, 0xB3, 0x6F, 
	0x7A, 0xB2, 0xB9, 0x8B, 0x53, 0x6C, 0x55, 0x46, 
	0x54, 0xCA, 0xA5, 0x74, 0x79, 0x8F, 0x5C, 0xB1, 
	0x1F, 0x99, 0xBC, 0x8D, 0xA3, 0xEA, 0xDB, 0x5E, 
	0x0D, 0x4A, 0x1F, 0x9A, 0xC9, 0xC1, 0x86, 0x87, 
	0x69, 0xD4, 0x74, 0xC4, 0x4E, 0x95, 0x71, 0x59, 
	0x7C, 0xCD, 0xDD, 0x4A, 0xEB, 0xC4, 0x51, 0x61, 
	0xAA, 0x90, 0xC0, 0xEE, 0x93, 0x46, 0xC6, 0x8B, 
	0x6A, 0xC0, 0x80, 0xAD, 0xEB, 0x3A, 0xB7, 0xFD, 
	0x19, 0x0B, 0xC2, 0xA0, 0x96, 0xCF, 0xAE, 0x74, 
	0xFC, 0x81, 0x58, 0xBD, 0xF6, 0xE1, 0xFF, 0xE1, 
	0x4F, 0xC3, 0xEF, 0x50, 0x47, 0xF0, 0xA7, 0x4F, 
	0x4B, 0xF8, 0xDF, 0x73, 0x4A, 0x03, 0x6D, 0x47, 
	0x5D, 0x2B, 0xDB, 0xB5, 0x55, 0x1D, 0xE5, 0x0E, 
	0x67, 0x3B, 0x42, 0x83, 0x57, 0xE7, 0xD9, 0xB0, 
	0x51, 0x9C, 0x7A, 0xF3, 0xDD, 0x83, 0x7A, 0x09, 
	0x7A, 0x05, 0xF4, 0x15, 0xAC, 0x81, 0x39, 0x0E, 
	0x47, 0x05, 0x98, 0x57, 0x7F, 0xE1, 0xC1, 0xE9, 
	0xDB, 0xA0, 0x90, 0x01, 0x72, 0xB2, 0x9A, 0xC4, 
	0x46, 0xCF, 0xC6, 0xB6, 0x7B, 0x01, 0xD1, 0x6C, 
	0x8A, 0x4F, 0x3A, 0xA8, 0xFB, 0x9A, 0x90, 0x88, 
	0x0A, 0x02, 0x1E, 0x60, 0xE7, 0x78, 0x3C, 0x58, 
	0xCA, 0xA6, 0x79, 0xD5, 0x0E, 0xED, 0x2C, 0x6C, 
	0x41, 0x18, 0x56, 0x46, 0xFC, 0x59, 0x52, 0x2C, 
	0x22, 0x7C, 0xB0, 0x11, 0x60, 0x8D, 0x2F, 0xD5, 
	0xDB, 0xE6, 0xE5, 0xD1, 0x96, 0x06, 0x8B, 0x26, 
	0x38, 0x48, 0x24, 0xBF, 0x74, 0x97, 0x60, 0xFF, 
	0x64, 0x9D, 0x94, 0xE7, 0xD7, 0xC5, 0x52, 0x27, 
	0x89, 0xFD, 0x0D, 0x33, 0x88, 0x91, 0xFF, 0xA7, 
	0xD6, 0xB7, 0x76, 0xA4, 0x89, 0xA5, 0x52, 0x39, 
	0x5B, 0xC3, 0x53, 0xFB, 0x8C, 0x1C, 0xD9, 0x4D, 
	0x6A, 0x9E, 0x28, 0x7D, 0x68, 0x9E, 0x85, 0x84, 
	0x68, 0xA1, 0xF7, 0xA6, 0x55, 0x85, 0x92, 0x08, 
	0xD4, 0x83, 0x67, 0x6D, 0xF3, 0xE2, 0x25, 0x3C, 
	0x86, 0xF8, 0x16, 0x2B, 0xB6, 0x5F, 0xD2, 0xA5, 
	0x9E, 0x4E, 0x2E, 0x82, 0x55, 0x41, 0xA0, 0x2C, 
	0x92, 0x08, 0x03, 0xCA, 0xD8, 0xA9, 0x02, 0xD4, 
	0x9F, 0x15, 0x2A, 0x78, 0x8E, 0xCB, 0xFE, 0x7C, 
	0x12, 0xF5, 0xF3, 0xA7, 0xF3, 0x73, 0xE0, 0x96, 
	0x7A, 0xAF, 0x67, 0xEE, 0x76, 0xFE, 0xE2, 0x5E, 
	0xB4, 0xAE, 0x6D, 0x79, 0xE4, 0x1A, 0x04, 0xB6, 
	0xDC, 0x13, 0xCC, 0xBC, 0xBB, 0xD1, 0x95, 0x48, 
	0xA1, 0xE6, 0x91, 0x29, 0x93, 0xD7, 0x20, 0x53, 

	/* Database Page 12 */

	0xFF, 0x86, 0x33, 0x74, 0xE9, 0x72, 0x64, 0xD9, 
	0x40, 0xE4, 0x90, 0xC0, 0x67, 0x1C, 0xCD, 0x89, 
	0x96, 0x9C, 0x1B, 0xCE, 0xD2, 0xBE, 0xC8, 0x16, 
	0x07, 0x1D, 0x21, 0x84, 0x5B, 0x12, 0xA4, 0x81, 
	0xB8, 0x09, 0x43, 0x05, 0xFF, 0x85, 0xDF, 0x74, 
	0x3D, 0x62, 0xA3, 0x12, 0x55, 0x46, 0x99, 0x20, 
	0xDA, 0xEE, 0x95, 0xA3, 0x77, 0xFC, 0x7A, 0x15, 
	0x5A, 0x52, 0x6D, 0x69, 0x35, 0xD6, 0xB8, 0x98, 
	0xFD, 0xE2, 0x5A, 0xC6, 0xAE, 0x49, 0x92, 0x65, 
	0x24, 0x43, 0xCD, 0x16, 0x67, 0x4C, 0x95, 0xF9, 
	0xEE, 0x76, 0x39, 0x7A, 0x56, 0x8E, 0xE8, 0xE8, 
	0x04, 0x6E, 0x1F, 0x76, 0xAA, 0x4A, 0xD2, 0xBE, 
	0x64, 0xBE, 0xD3, 0x36, 0x79, 0x77, 0xFC, 0xBE, 
	0xDD, 0x2F, 0xC6, 0x5D, 0x87, 0x1C, 0x8B, 0xA7, 
	0xCD, 0x91, 0x3A, 0x6F, 0x99, 0xF6, 0xB5, 0xA2, 
	0x09, 0x32, 0xE3, 0x2E, 0x35, 0xB4, 0x80, 0x54, 
	0xDF, 0xFF, 0xEA, 0x91, 0xFA, 0x3A, 0xE4, 0x85, 
	0x79, 0x1A, 0xFA, 0x7D, 0xA4, 0x3F, 0xE0, 0x9D, 
	0x15, 0x3F, 0x8D, 0xAB, 0x18, 0x67, 0x12, 0x46, 
	0x6F, 0xB8, 0xC3, 0xFB, 0x97, 0x88, 0x2D, 0xD9, 
	0x45, 0x07, 0x7C, 0x9D, 0xAD, 0xDB, 0xC1, 0x50, 
	0x76, 0x65, 0x7F, 0x65, 0xE6, 0x4D, 0x7E, 0x5F, 
	0x0E, 0x5D, 0x2F, 0xEC, 0x5D, 0x58, 0x9E, 0xEE, 
	0x27, 0xD0, 0x4C, 0xB9, 0x45, 0xBC, 0x71, 0x82, 
	0x97, 0x06, 0x74, 0xE2, 0xF5, 0xE7, 0xA9, 0x09, 
	0xCE, 0x38, 0xF8, 0xC4, 0x54, 0x20, 0x95, 0x58, 
	0xE6, 0x02, 0x2C, 0xC3, 0xB9, 0x4F, 0xE4, 0x08, 
	0x9D, 0xBB, 0xDE, 0xA1, 0xA3, 0xA6, 0xC8, 0x2F, 
	0x26, 0x4F, 0x07, 0xDF, 0x1E, 0xE7, 0x11, 0xC9, 
	0x7E, 0x76, 0x3A, 0x9B, 0xC9, 0xFF, 0xA7, 0x0D, 
	0x6A, 0xB9, 0xEE, 0x97, 0x95, 0xF8, 0x8D, 0x50, 
	0x4D, 0x78, 0xBB, 0xE5, 0x84, 0x95, 0x65, 0x55, 
	0x95, 0xBD, 0xFF, 0xBF, 0xC1, 0xF8, 0xAC, 0x60, 
	0x03, 0xD6, 0x2D, 0xE9, 0x3B, 0x5C, 0x5B, 0xB7, 
	0x42, 0x13, 0x09, 0x72, 0x53, 0xB2, 0x4A, 0xE3, 
	0x44, 0x81, 0x75, 0x8D, 0xDB, 0x1E, 0x46, 0x55, 
	0x04, 0xD9, 0x1B, 0x54, 0x5E, 0x53, 0x8C, 0x95, 
	0xAD, 0x80, 0x16, 0x76, 0xC2, 0x1D, 0xC5, 0x02, 
	0x6B, 0xC3, 0xF8, 0xAD, 0xC3, 0x40, 0x62, 0xFD, 
	0x6A, 0x6F, 0xDE, 0x01, 0x71, 0x81, 0xA0, 0x84, 
	0x73, 0xBB, 0x1B, 0xE9, 0x3D, 0x51, 0xE2, 0x9D, 
	0x2B, 0x16, 0x75, 0xD1, 0xF7, 0x70, 0xA5, 0x75, 
	0xFF, 0x6F, 0xB1, 0x71, 0x9E, 0xDA, 0x32, 0xE3, 
	0x9F, 0xB2, 0xCC, 0x5F, 0x57, 0x77, 0x1E, 0x04, 
	0x3C, 0x07, 0x27, 0xAB, 0x10, 0xBF, 0x91, 0x33, 
	0xE2, 0x0C, 0x01, 0xA7, 0x75, 0xED, 0x4B, 0x83, 
	0x6B, 0x52, 0x94, 0x09, 0xCA, 0xD9, 0x5C, 0x7A, 
	0xDD, 0x2B, 0x49, 0x2E, 0x8D, 0xA8, 0x6C, 0xE4, 
	0x33, 0x41, 0xD6, 0xFF, 0xE5, 0x4C, 0x2B, 0xA1, 
	0x72, 0xEA, 0x0B, 0x5B, 0x1F, 0xC6, 0x56, 0x40, 
	0x01, 0x7D, 0xF1, 0xC7, 0x91, 0xDE, 0x9B, 0x82, 
	0xD7, 0x02, 0xF8, 0x63, 0xE1, 0xC9, 0xEC, 0xDC, 
	0x01, 0x29, 0x2D, 0x2C, 0x03, 0xD3, 0x1F, 0x02, 
	0x67, 0x62, 0x71, 0x67, 0xB3, 0x0D, 0x30, 0x26, 
	0xAB, 0xA9, 0x18, 0x61, 0xCC, 0x51, 0x0D, 0x72, 
	0x74, 0xEB, 0xB1, 0x37, 0xDD, 0xA2, 0xDC, 0xC4, 
	0x2E, 0xB5, 0xCD, 0xF2, 0xAD, 0xD2, 0x49, 0x63, 
	0xBF, 0xEF, 0x6D, 0x7C, 0x6F, 0xF9, 0x56, 0x8C, 
	0xCB, 0x12, 0x18, 0x82, 0x35, 0x62, 0x31, 0x75, 
	0x66, 0xBC, 0x90, 0x1B, 0xEB, 0x41, 0x79, 0xED, 
	0x33, 0x13, 0x72, 0x4A, 0x72, 0xFC, 0x7D, 0x30, 
	0x1C, 0x98, 0xD3, 0x40, 0xA6, 0x7B, 0x0A, 0xC9, 
	0x6A, 0x6C, 0xE6, 0xCA, 0x21, 0x6A, 0xC2, 0x81, 
	0xF2, 0xF2, 0x83, 0xE7, 0x8F, 0x64, 0xAC, 0xF9, 
	0x40, 0xBE, 0x36, 0x1F, 0xFF, 0xE7, 0x48, 0xBF, 
	0xB5, 0x9D, 0xB3, 0xD1, 0x53, 0xE7, 0xBE, 0x99, 
	0x4A, 0xD7, 0x6C, 0x0B, 0xA7, 0xE0, 0xFD, 0xD5, 
	0xC4, 0xCF, 0x93, 0x35, 0xEC, 0xDF, 0x80, 0x72, 
	0x6E, 0x42, 0x56, 0x81, 0x6A, 0x20, 0xD9, 0x29, 
	0x0E, 0x46, 0xB9, 0xD5, 0xB7, 0x93, 0x96, 0x76, 
	0xB1, 0x4B, 0x87, 0x67, 0x53, 0x43, 0x47, 0x2B, 
	0xA1, 0xA6, 0xD7, 0xC3, 0x95, 0xBD, 0xA3, 0x99, 
	0x5B, 0xEE, 0x8A, 0x97, 0x88, 0x29, 0x05, 0xAF, 
	0x6B, 0xD0, 0xF3, 0xD2, 0x06, 0xF9, 0x9A, 0x7D, 
	0xD6, 0xF4, 0xB6, 0x61, 0xA5, 0xE1, 0xDB, 0x07, 
	0xF4, 0x8F, 0x6F, 0x6A, 0x18, 0xEB, 0xCC, 0xFE, 
	0xF0, 0x1A, 0x5C, 0xE4, 0x59, 0x00, 0xAC, 0x70, 
	0xE7, 0x5B, 0x67, 0x66, 0x03, 0xCA, 0x33, 0x69, 
	0x06, 0xC6, 0x91, 0x80, 0x59, 0x09, 0xB5, 0x8B, 
	0xD0, 0xEB, 0x7C, 0xE3, 0x0E, 0xF6, 0x4D, 0xCD, 
	0x1E, 0xA8, 0xC2, 0x8B, 0xB9, 0xFF, 0x2C, 0x50, 
	0xFF, 0x9D, 0x7B, 0x6F, 0x7E, 0x58, 0xCE, 0xD3, 
	0xE5, 0x47, 0x1B, 0x96, 0x7C, 0x1C, 0x7A, 0xF7, 
	0x9A, 0xBA, 0xEF, 0xBF, 0x9C, 0xEA, 0x07, 0xB3, 
	0x79, 0xF5, 0xA8, 0x57, 0x42, 0x24, 0xBD, 0x74, 
	0x87, 0xA7, 0xB1, 0x9D, 0xE4, 0x8C, 0x4B, 0xBB, 
	0xB3, 0xC1, 0x7E, 0x64, 0xD6, 0xD0, 0xC0, 0xF6, 
	0xDF, 0xD6, 0x96, 0x29, 0x15, 0x70, 0x6D, 0x9C, 
	0x15, 0xC4, 0x2B, 0x8D, 0x90, 0xDC, 0xE5, 0xBB, 
	0x44, 0x6E, 0x68, 0x67, 0xE1, 0xF4, 0xF5, 0x67, 
	0x24, 0x00, 0xD1, 0x8C, 0x37, 0x08, 0x0E, 0x74, 
	0xF5, 0xB0, 0x2A, 0xE1, 0xAA, 0x17, 0x6F, 0xC8, 
	0x91, 0x99, 0xE9, 0xC4, 0x24, 0xDA, 0x19, 0xF9, 
	0xC4, 0x21, 0xEC, 0x7C, 0x69, 0xAB, 0x47, 0x63, 
	0x5C, 0x19, 0x99, 0x58, 0x57, 0xA2, 0x86, 0x1C, 
	0x42, 0x6B, 0xCD, 0x4C, 0xDC, 0x56, 0x00, 0x17, 
	0x0B, 0xDE, 0xDD, 0xD9, 0x07, 0xE9, 0xFF, 0x5B, 
	0xBA, 0xBE, 0x19, 0xD8, 0x44, 0xCB, 0xF9, 0xE0, 
	0xB0, 0x19, 0x15, 0x2C, 0x66, 0x5E, 0x76, 0x83, 
	0x28, 0xAF, 0xD7, 0x4A, 0x1D, 0x83, 0x67, 0xEB, 
	0xA1, 0xF9, 0x1C, 0xFC, 0xEA, 0xE1, 0xB7, 0x7A, 
	0xA1, 0x2D, 0xC7, 0x2C, 0x58, 0x90, 0xE5, 0x96, 
	0x6F, 0x18, 0xBB, 0x70, 0x06, 0x6B, 0xD3, 0x05, 
	0x04, 0xAC, 0xB6, 0x4E, 0x39, 0x20, 0xF5, 0xF4, 
	0x4B, 0x4F, 0x23, 0xB2, 0x61, 0xA7, 0x61, 0x9E, 
	0x20, 0x45, 0xEF, 0xD4, 0x77, 0xD2, 0x14, 0x65, 
	0x74, 0x65, 0x8A, 0x3F, 0xB8, 0x82, 0x01, 0x4E, 
	0x85, 0x5F, 0xF6, 0x15, 0xAE, 0xC9, 0x2B, 0x5F, 
	0xE4, 0xD1, 0xC0, 0xD1, 0x7B, 0xFD, 0xE4, 0xEA, 
	0x72, 0x15, 0xA0, 0x1B, 0x88, 0xC6, 0x0E, 0x7D, 
	0x6E, 0xE4, 0xCE, 0xA9, 0x0D, 0x4A, 0x45, 0xC2, 
	0x15, 0x46, 0x0B, 0x4E, 0x72, 0xE3, 0x14, 0x08, 
	0x4B, 0x60, 0xF9, 0x2E, 0x82, 0xF3, 0x14, 0xFF, 
	0x88, 0xFD, 0xBC, 0x56, 0xA6, 0x8B, 0x4D, 0x95, 
	0xBE, 0x93, 0xE2, 0x91, 0xFE, 0x2F, 0x23, 0x64, 
	0xB3, 0x93, 0xAD, 0x25, 0xEB, 0x42, 0xC7, 0x95, 
	0x1A, 0x63, 0xBE, 0x63, 0x5B, 0xFA, 0x5E, 0xB7, 
	0x32, 0x61, 0xC7, 0x18, 0xA3, 0xCF, 0xB9, 0x99, 
	0x11, 0x01, 0x39, 0x51, 0x7F, 0x5E, 0xBB, 0x9E, 
	0x3A, 0xAE, 0xA4, 0xDB, 0x07, 0x38, 0x5F, 0xEE, 
	0xD7, 0x32, 0x4E, 0x2B, 0x46, 0x60, 0xB2, 0x77, 
	0x82, 0xE7, 0x24, 0xF8, 0x34, 0xC4, 0xAB, 0xA9, 
	0x5E, 0xB1, 0x2E, 0xE0, 0xA3, 0xA4, 0x61, 0x3C, 
	0x57, 0x4C, 0x72, 0x17, 0x77, 0x09, 0x86, 0xC2, 
	0xDF, 0xC0, 0x42, 0xE0, 0x8F, 0xBA, 0xE8, 0xCD, 
	0xBA, 0xBC, 0x48, 0xFA, 0xBE, 0x42, 0x25, 0xD5, 
	0x9A, 0x6D, 0x75, 0x45, 0x26, 0x94, 0xEE, 0x1D, 
	0x88, 0x7B, 0xCB, 0x77, 0x64, 0xE7, 0x2A, 0x4F, 
	0xA2, 0x36, 0xFB, 0xC9, 0x12, 0x76, 0x19, 0x4F, 
	0xFF, 0x04, 0x46, 0x36, 0x47, 0x26, 0x10, 0x8D, 
	0x94, 0x33, 0x32, 0x84, 0xC0, 0x45, 0x94, 0xC1, 
	0x0A, 0xBF, 0x9E, 0x30, 0xAE, 0xB6, 0xE2, 0x55, 
	0x77, 0x34, 0x38, 0x4F, 0x63, 0x27, 0x53, 0x78, 
	0xB4, 0xA6, 0xA2, 0x26, 0xE9, 0xFF, 0xE5, 0xFC, 
	0xD1, 0x0C, 0xB7, 0xE2, 0x85, 0xA6, 0x4A, 0xA2, 
	0x49, 0x5B, 0xA4, 0xA7, 0x38, 0xF4, 0xB3, 0x7B, 
	0x6F, 0x2C, 0x6F, 0x59, 0xC4, 0x35, 0x21, 0xFE, 
	0xD6, 0xD6, 0xE5, 0xA8, 0x47, 0xD5, 0x12, 0xAC, 
	0x0A, 0x9D, 0x84, 0x6B, 0x53, 0x6D, 0xCE, 0xF8, 
	0x13, 0x67, 0xAC, 0xAE, 0xB8, 0xC5, 0x4C, 0xFA, 
	0xF7, 0xF5, 0x6C, 0xB8, 0xA1, 0xBB, 0xF4, 0x65, 
	0xDA, 0xB6, 0x22, 0xA9, 0x7F, 0xEB, 0xA7, 0x6D, 
	0x35, 0x26, 0xD2, 0xB8, 0xB6, 0x1A, 0x14, 0x2D, 
	0xEA, 0x0A, 0x9A, 0x4C, 0x9F, 0x16, 0xB9, 0x89, 
	0x76, 0xE3, 0x89, 0xE6, 0xC9, 0x74, 0xF1, 0x6A, 
	0x9F, 0xFF, 0x6A, 0x89, 0xDA, 0x42, 0x97, 0x00, 
	0x07, 0xB6, 0x8D, 0x26, 0xC1, 0x20, 0xE6, 0x23, 
	0x06, 0x7D, 0xC8, 0xEE, 0xAC, 0xF8, 0xDD, 0xEC, 
	0xF2, 0x9B, 0x8F, 0xC9, 0xDC, 0xEC, 0x9C, 0xFF, 
	0xB8, 0x21, 0x82, 0x99, 0x06, 0xD8, 0x48, 0xC8, 
	0xE6, 0x01, 0xA0, 0x4F, 0x3C, 0xE1, 0x19, 0xE1, 
	0x76, 0xE1, 0x2B, 0x5A, 0x1C, 0x87, 0x9F, 0x23, 
	0x99, 0xB5, 0xCB, 0x9E, 0xCF, 0xD8, 0x4B, 0xDD, 
	0x92, 0xB1, 0x60, 0x1B, 0xAC, 0xBB, 0xFE, 0xD9, 
	0x3B, 0x8C, 0xE5, 0x19, 0x9D, 0x38, 0xB8, 0x37, 
	0x19, 0x9C, 0xC7, 0x03, 0x3E, 0x3E, 0x1F, 0x12, 
	0xBE, 0xE2, 0xFC, 0x18, 0x51, 0x64, 0x8E, 0x82, 
	0x04, 0x2A, 0x5E, 0xE3, 0xC9, 0x3C, 0x25, 0xF9, 
	0x44, 0xEF, 0x3F, 0x56, 0xB1, 0x6B, 0x6A, 0xE9, 
	0x2C, 0x1A, 0xC6, 0xF6, 0xEC, 0xB7, 0xEA, 0xFD, 
	0x79, 0x73, 0x97, 0x90, 0x93, 0x29, 0xBB, 0x88, 
	0x1E, 0x47, 0xFF, 0x07, 0x7E, 0x76, 0xB7, 0x08, 
	0xE2, 0x42, 0xCC, 0x91, 0xE1, 0xEA, 0xCB, 0xD6, 
	0x9B, 0xCE, 0x7E, 0x6E, 0x4F, 0x95, 0xD7, 0x92, 
	0x4D, 0x45, 0xE5, 0x64, 0x46, 0x42, 0xF9, 0xDB, 
	0x4C, 0x1A, 0x53, 0x35, 0xDC, 0x9C, 0x07, 0x7A, 
	0x7B, 0xBB, 0x69, 0x28, 0xD6, 0xB0, 0xCF, 0xA9, 
	0x5B, 0x4B, 0xCA, 0xB8, 0x6F, 0x83, 0x3B, 0xCD, 
	0xDD, 0x18, 0x96, 0xA6, 0x2D, 0x0E, 0x4F, 0x53, 
	0xB9, 0x34, 0x9B, 0x00, 0xEA, 0x29, 0x4D, 0x44, 
	0x6A, 0x3D, 0xCD, 0x22, 0x9D, 0xD1, 0x9B, 0x84, 
	0x40, 0x05, 0xE2, 0xCE, 0x39, 0x49, 0x34, 0xDC, 
	0x6C, 0x11, 0xE5, 0x30, 0x6B, 0xEA, 0x60, 0x71, 
	0xE2, 0xEB, 0xF6, 0x2A, 0x6D, 0x67, 0xDD, 0x1A, 
	0x85, 0x16, 0x55, 0x06, 0xD4, 0x60, 0x6C, 0x6C, 
	0x5C, 0xF5, 0xFB, 0x9A, 0x9C, 0xED, 0x5E, 0x88, 
	0x78, 0x12, 0x09, 0x65, 0x60, 0x07, 0x86, 0x10, 
	0x52, 0xF8, 0xE7, 0xFF, 0xBC, 0xCA, 0x95, 0xD3, 
	0x12, 0xA4, 0x2A, 0xE7, 0x22, 0x60, 0xDF, 0x38, 
	0x5B, 0x32, 0xF2, 0xEC, 0x0B, 0x44, 0xBF, 0xFA, 
	0x6C, 0x14, 0x28, 0x53, 0x4B, 0x1B, 0xE2, 0x5D, 
	0x9A, 0x64, 0x0E, 0x17, 0x39, 0x2F, 0x7E, 0x8F, 
	0xEF, 0xE4, 0xF6, 0xAD, 0xFB, 0x4D, 0x20, 0x9D, 
	0x73, 0xB1, 0xBE, 0xB7, 0xB8, 0x91, 0x39, 0x1A, 
	0x5A, 0xD2, 0x96, 0x79, 0xD8, 0xFB, 0x99, 0xC7, 
	0xB0, 0x5D, 0x54, 0xCB, 0x87, 0x10, 0xF6, 0x48, 
	0x83, 0xE8, 0x56, 0xCB, 0xBB, 0x57, 0x47, 0xCB, 
	0xAF, 0x75, 0xD8, 0x62, 0x12, 0x2D, 0xBE, 0x46, 
	0xB2, 0x8B, 0xBA, 0xBC, 0x76, 0x6D, 0xE4, 0x31, 
	0xE8, 0x66, 0x51, 0x00, 0xCB, 0xF6, 0x93, 0x87, 
	0x10, 0x8F, 0x5F, 0x47, 0xDC, 0xED, 0x82, 0x51, 
	0xA0, 0x7C, 0x67, 0x48, 0x8E, 0xC1, 0x53, 0x4E, 
	0xD6, 0xDD, 0x32, 0x59, 0x4A, 0x39, 0x40, 0xE8, 
	0x6F, 0x2A, 0xDE, 0x5C, 0xFF, 0x1D, 0x98, 0x66, 
	0x88, 0xFC, 0x65, 0x49, 0xD1, 0x7B, 0x4E, 0xB4, 
	0xEF, 0x9E, 0x7B, 0xB2, 0x4F, 0xF1, 0x29, 0x1F, 
	0xC4, 0xE2, 0x0E, 0x22, 0x9B, 0x16, 0xA9, 0x22, 
	0xBC, 0xC2, 0xF5, 0xD7, 0xE9, 0x18, 0xC4, 0xA5, 
	0xD4, 0x12, 0x64, 0x6E, 0x60, 0x84, 0x16, 0x3D, 
	0x86, 0x86, 0x34, 0x6F, 0x3D, 0x94, 0x55, 0xEF, 
	0x88, 0xDC, 0xC8, 0xCE, 0x7C, 0x93, 0xA9, 0x89, 
	0x15, 0x1B, 0xC0, 0x9C, 0x3C, 0x18, 0x5D, 0x3D, 
	0x45, 0x0D, 0xDA, 0xE1, 0xD3, 0xB0, 0x34, 0x27, 
	0x93, 0xE6, 0x9F, 0x87, 0x15, 0x32, 0x92, 0x53, 
	0x82, 0x3A, 0xB4, 0x00, 0xC8, 0x46, 0xB9, 0x59, 
	0x3C, 0xCB, 0x2A, 0x9E, 0xF6, 0x75, 0x7B, 0xE5, 
	0xF5, 0x9F, 0x0A, 0x64, 0xEE, 0x4C, 0xAE, 0xF0, 
	0xFE, 0x67, 0x3B, 0xE1, 0x34, 0xCD, 0xA3, 0x49, 
	0xB8, 0x19, 0x6F, 0x4E, 0x1E, 0x59, 0xA3, 0x06, 
	0xA2, 0x64, 0x08, 0xB9, 0x4A, 0xFF, 0xE4, 0xA8, 
	0xD5, 0x07, 0x1E, 0xC3, 0xB0, 0x69, 0x86, 0x1A, 
	0x9D, 0x58, 0x59, 0xA5, 0xB1, 0xC3, 0x47, 0xD1, 
	0x84, 0xA2, 0x76, 0xFC, 0x32, 0x22, 0x65, 0xD0, 
	0x90, 0x98, 0x89, 0x9F, 0xBF, 0x51, 0xA8, 0x58, 
	0x84, 0x1A, 0x90, 0x46, 0xDA, 0x66, 0xB4, 0x68, 
	0x7E, 0xD9, 0x59, 0xFB, 0x30, 0xD9, 0xE6, 0x29, 
	0x67, 0x8F, 0x8C, 0xB6, 0x54, 0xD4, 0x31, 0x83, 
	0xD5, 0x12, 0xC4, 0x75, 0xA9, 0x68, 0x2C, 0x10, 
	0xC4, 0x69, 0x57, 0x5F, 0x9D, 0x44, 0xEE, 0x78, 
	0x33, 0xB0, 0x52, 0x9B, 0x68, 0x30, 0x3E, 0x7C, 
	0x1B, 0xED, 0xD0, 0x42, 0xCA, 0xFF, 0x9E, 0xFB, 
	0x90, 0xCE, 0x46, 0x9C, 0x75, 0x69, 0xD6, 0xE9, 
	0xD8, 0xE2, 0x7A, 0x2B, 0xA9, 0xDB, 0xBC, 0x18, 
	0x84, 0xB4, 0xA7, 0xDA, 0x3D, 0xEF, 0xC2, 0x96, 
	0x47, 0xC1, 0x84, 0x0C, 0x60, 0x99, 0x90, 0xAD, 
	0x94, 0xE7, 0xDB, 0x4F, 0x41, 0xE8, 0xFF, 0x7E, 
	0x48, 0xB8, 0xAE, 0x1E, 0xF2, 0x38, 0x0F, 0x31, 
	0xFC, 0x5A, 0x74, 0x56, 0xD7, 0x79, 0xB1, 0xCB, 
	0x20, 0x11, 0x11, 0x87, 0xA3, 0x48, 0xA2, 0x33, 
	0xD0, 0xCD, 0x7B, 0x50, 0xBF, 0x32, 0x91, 0xFD, 
	0xC3, 0x3C, 0x1C, 0xFB, 0xB1, 0xE2, 0xCE, 0xB0, 
	0xE6, 0x47, 0x4E, 0x6D, 0x53, 0x95, 0xE0, 0x84, 
	0xEC, 0x55, 0x6C, 0xBF, 0x45, 0xB7, 0x52, 0xC8, 
	0x85, 0xA4, 0x46, 0xAB, 0x1A, 0x90, 0x83, 0xC8, 
	0xF7, 0x6E, 0x01, 0x8C, 0x0F, 0x76, 0x42, 0x52, 
	0x1D, 0x8F, 0xEB, 0x5A, 0x5E, 0x81, 0xF3, 0x7C, 
	0xB4, 0xBC, 0xA8, 0x21, 0x40, 0xB7, 0x15, 0x2D, 
	0x09, 0x68, 0x30, 0x7F, 0x87, 0x19, 0x1B, 0xF8, 
	0x73, 0xD5, 0x4B, 0x4D, 0xEE, 0x2A, 0x0F, 0x48, 
	0xC2, 0x95, 0xBA, 0x1A, 0x61, 0x25, 0x43, 0xAD, 
	0x1C, 0xE2, 0xDD, 0xB6, 0xCB, 0x74, 0x1D, 0xEB, 
	0x79, 0x3B, 0x91, 0xFC, 0xFE, 0x30, 0x21, 0xFF, 
	0xC6, 0x42, 0x2F, 0x53, 0xA6, 0x59, 0xAE, 0x5A, 
	0x93, 0x02, 0x15, 0xFC, 0x2D, 0x1F, 0xA6, 0x10, 
	0x1F, 0x79, 0xA8, 0xB8, 0xB7, 0xA2, 0xA5, 0x8B, 
	0x10, 0xDC, 0x7B, 0x97, 0x35, 0x71, 0xE4, 0x5D, 
	0x83, 0xA9, 0x60, 0xBC, 0x4E, 0xDC, 0x97, 0x02, 
	0x96, 0xFE, 0x76, 0x95, 0xE6, 0x08, 0x29, 0xDB, 
	0x85, 0x8F, 0x5E, 0x62, 0x93, 0x99, 0x9C, 0x63, 
	0x0E, 0x44, 0xA0, 0x1C, 0xB1, 0x37, 0x6D, 0x02, 
	0xE0, 0x63, 0x09, 0x5D, 0x40, 0x5B, 0x7E, 0x19, 
	0xB6, 0x87, 0x8F, 0xCF, 0xEC, 0x41, 0x26, 0x0F, 
	0xED, 0x83, 0x09, 0x8C, 0x86, 0x07, 0x3D, 0x68, 
	0x2C, 0x2F, 0xB8, 0x41, 0x8F, 0xA9, 0x50, 0xC1, 
	0x2C, 0xCF, 0x41, 0x0E, 0x88, 0xC2, 0x19, 0x94, 
	0x4E, 0x4B, 0x8E, 0xC2, 0xF8, 0xE8, 0x1B, 0x91, 
	0x3B, 0x92, 0xEB, 0x37, 0xED, 0xFF, 0x31, 0xCF, 
	0x29, 0x79, 0x8C, 0x0F, 0xAD, 0x86, 0x50, 0xA9, 

	/* Database Page 13 */

	0xFF, 0x93, 0x9B, 0xC3, 0x98, 0xA3, 0x56, 0xCF, 
	0xE2, 0x41, 0xF5, 0xEC, 0x1B, 0x69, 0x41, 0xFD, 
	0x2C, 0x92, 0xF0, 0x02, 0x08, 0x69, 0x4B, 0x6D, 
	0x14, 0x2B, 0x50, 0x2D, 0xCE, 0x6A, 0x02, 0x26, 
	0xE2, 0x60, 0x34, 0xA4, 0x36, 0x78, 0xFD, 0xA0, 
	0x0A, 0x21, 0x43, 0xB6, 0x99, 0x42, 0x07, 0xB6, 
	0x07, 0xD2, 0x7C, 0xB8, 0xFA, 0x33, 0x66, 0x06, 
	0xEE, 0x08, 0x7F, 0x67, 0x11, 0x0E, 0x3D, 0xFD, 
	0xB6, 0xF3, 0xC6, 0xEF, 0xE5, 0xC3, 0xB9, 0x6F, 
	0xA9, 0x2D, 0xE9, 0xE9, 0xE0, 0xC2, 0xF9, 0x7D, 
	0x63, 0xC0, 0x9D, 0x99, 0xCC, 0xCE, 0x45, 0xAA, 
	0xA8, 0x26, 0xC2, 0xE2, 0x89, 0x60, 0x1A, 0x7B, 
	0x03, 0x04, 0x85, 0x94, 0xAE, 0xCE, 0xE4, 0xF2, 
	0xDF, 0x65, 0x9A, 0x77, 0xA2, 0x74, 0x2D, 0xA5, 
	0xDC, 0x87, 0x5E, 0x26, 0xAD, 0x7E, 0x45, 0xA0, 
	0xBE, 0xDE, 0x46, 0x19, 0xAD, 0xF1, 0x51, 0xC8, 
	0xD1, 0xFF, 0x93, 0xD8, 0x83, 0xED, 0xDA, 0xC2, 
	0x2D, 0x3E, 0x86, 0xEE, 0x3C, 0xC8, 0x0E, 0x13, 
	0x6D, 0x7D, 0x8A, 0x56, 0x28, 0x2D, 0x8E, 0xB2, 
	0x05, 0x07, 0x4F, 0x9C, 0x41, 0x81, 0xA4, 0x41, 
	0x2C, 0x72, 0xF5, 0xA9, 0xD0, 0x30, 0xA0, 0xE7, 
	0x7F, 0xE9, 0x8C, 0x4A, 0x27, 0x3B, 0x0B, 0x1F, 
	0x37, 0xBB, 0xF1, 0xDB, 0x99, 0xA8, 0x9F, 0x24, 
	0x91, 0x51, 0xC7, 0xBD, 0xFC, 0xD0, 0x36, 0x20, 
	0x73, 0x99, 0x37, 0xCD, 0xEA, 0x30, 0x3B, 0x27, 
	0xAC, 0xF0, 0x48, 0xBD, 0xEC, 0x64, 0x2D, 0x72, 
	0xD7, 0xDB, 0xD4, 0xA4, 0x0B, 0xB1, 0xAB, 0x16, 
	0x77, 0xDA, 0xF5, 0xD8, 0x75, 0x7B, 0xFC, 0x78, 
	0x4D, 0x6D, 0x22, 0x64, 0x7C, 0xD9, 0x10, 0x76, 
	0x96, 0xB6, 0x9D, 0xF4, 0x73, 0x0E, 0x62, 0xBA, 
	0x6B, 0xDB, 0x74, 0x5C, 0x91, 0x83, 0xF8, 0x71, 
	0xBA, 0xED, 0xB9, 0xA7, 0x8E, 0xCE, 0x22, 0xD7, 
	0xD0, 0xF2, 0xFF, 0x5C, 0xF1, 0x74, 0x26, 0x57, 
	0x76, 0x5D, 0x56, 0xE3, 0x18, 0x76, 0x03, 0x46, 
	0x67, 0x51, 0xB8, 0x76, 0x88, 0x1D, 0x38, 0xC2, 
	0xF5, 0xEC, 0x5D, 0xDF, 0x6C, 0x70, 0x28, 0x87, 
	0xEA, 0x71, 0xAE, 0x07, 0x4A, 0xC2, 0x13, 0x32, 
	0xF3, 0x04, 0x9D, 0x07, 0xAF, 0x63, 0x27, 0x1A, 
	0xA7, 0xFF, 0x6A, 0x24, 0x47, 0x71, 0x19, 0x7F, 
	0x86, 0x7F, 0x2F, 0x04, 0x0C, 0xD3, 0x22, 0x67, 
	0xF4, 0x56, 0x51, 0x60, 0x8F, 0x7A, 0xB2, 0x93, 
	0x5F, 0x41, 0xC6, 0x29, 0x12, 0xE3, 0xFC, 0x80, 
	0x0E, 0x66, 0x44, 0x99, 0x71, 0x88, 0x92, 0x10, 
	0xDF, 0x1E, 0x61, 0x09, 0x62, 0x53, 0x0B, 0x33, 
	0xF7, 0x62, 0xB8, 0x77, 0x20, 0xEA, 0x3C, 0x07, 
	0xBC, 0x21, 0xAF, 0x6D, 0x66, 0x80, 0x62, 0xDC, 
	0x60, 0xBC, 0x67, 0x89, 0x6C, 0x99, 0x4C, 0xE6, 
	0x24, 0x66, 0x0C, 0x75, 0x99, 0x0F, 0x62, 0x8B, 
	0xED, 0xDA, 0x96, 0xFF, 0x69, 0xBC, 0x5F, 0xF1, 
	0x53, 0x03, 0xC6, 0x49, 0x86, 0x8F, 0xF9, 0x01, 
	0x8E, 0xB7, 0xB4, 0x93, 0xD1, 0xC9, 0x09, 0xD8, 
	0x97, 0xE7, 0x03, 0x38, 0x8E, 0x4A, 0x97, 0x4C, 
	0x2D, 0x27, 0xE7, 0x3B, 0x3C, 0x2F, 0xF8, 0xCF, 
	0x91, 0x0E, 0xC6, 0x4D, 0x67, 0x20, 0x6D, 0x50, 
	0x7B, 0xDE, 0xE3, 0x67, 0x3D, 0x19, 0x0E, 0x4A, 
	0xC3, 0x5E, 0x19, 0x74, 0xFE, 0x70, 0x89, 0xC1, 
	0xDD, 0xCC, 0x33, 0xB6, 0xBC, 0x89, 0x7C, 0x04, 
	0xF4, 0x2B, 0xE2, 0x31, 0xA6, 0xED, 0x45, 0x7D, 
	0x6E, 0x77, 0xD4, 0x55, 0xE6, 0x97, 0xDF, 0x11, 
	0xA0, 0xCE, 0xD5, 0xD8, 0x29, 0xCC, 0xA3, 0x9C, 
	0x79, 0xFE, 0x9E, 0x0A, 0x4D, 0x6D, 0x0B, 0xE7, 
	0x56, 0xBB, 0x1A, 0x7F, 0x72, 0xEA, 0x16, 0xBA, 
	0xC5, 0xAD, 0x5B, 0x79, 0x37, 0x5F, 0xDB, 0x01, 
	0x6A, 0xE2, 0xA7, 0xDA, 0xC6, 0x78, 0xF7, 0x7D, 
	0xF6, 0xE0, 0x9C, 0x8E, 0xFF, 0x32, 0xD9, 0xDB, 
	0xD0, 0x8C, 0x23, 0x1D, 0x54, 0x09, 0x5A, 0x4C, 
	0xAA, 0x46, 0xB3, 0xDB, 0x2C, 0x16, 0x3D, 0xC3, 
	0xE4, 0x8F, 0x76, 0x05, 0xFA, 0x88, 0x25, 0xF3, 
	0x8E, 0x34, 0xBB, 0x30, 0x92, 0x89, 0xDA, 0x6C, 
	0x6A, 0xAE, 0x42, 0x5A, 0xC8, 0x6F, 0xB7, 0x3A, 
	0x44, 0x8F, 0xBF, 0xCB, 0x8F, 0xDB, 0xB2, 0x66, 
	0xB9, 0xE7, 0xB1, 0x82, 0x74, 0xB8, 0x65, 0x1C, 
	0x88, 0x22, 0x22, 0x0D, 0x04, 0x2D, 0xC7, 0x2D, 
	0x71, 0x3F, 0x14, 0x00, 0xDF, 0xFB, 0x03, 0x0B, 
	0xB5, 0xE5, 0x1E, 0x8B, 0x5C, 0x2A, 0x2E, 0x81, 
	0xC1, 0xC9, 0x95, 0x50, 0xE1, 0xF0, 0x79, 0x28, 
	0x04, 0x1F, 0x79, 0x85, 0x04, 0x55, 0x04, 0xF7, 
	0x98, 0x99, 0x31, 0xE4, 0x37, 0xD0, 0xAA, 0xA0, 
	0xA3, 0xF3, 0x59, 0xA5, 0x09, 0x0C, 0x2B, 0x17, 
	0xC4, 0xF6, 0xBE, 0x27, 0x9B, 0x06, 0xBF, 0x51, 
	0xE1, 0x2A, 0xED, 0x61, 0x65, 0xFF, 0x3C, 0xA2, 
	0x83, 0x41, 0x73, 0xA2, 0xE0, 0x9B, 0x11, 0x41, 
	0xCD, 0x0B, 0x85, 0x2E, 0x90, 0x6B, 0xA3, 0x47, 
	0x88, 0x30, 0xEE, 0x6B, 0x61, 0x16, 0x02, 0x4C, 
	0x66, 0xFA, 0x36, 0x1E, 0x66, 0x1E, 0x68, 0x5D, 
	0x6F, 0x11, 0x84, 0xDC, 0xB6, 0x12, 0x9B, 0x13, 
	0x42, 0x0B, 0x6D, 0xE0, 0x34, 0xDF, 0xD3, 0xA7, 
	0xEB, 0x1C, 0xD0, 0xAA, 0x21, 0x02, 0x55, 0xCA, 
	0x64, 0x89, 0xA6, 0x29, 0x35, 0xE2, 0x9C, 0x35, 
	0x5B, 0x01, 0x6E, 0x98, 0x08, 0xB7, 0xB8, 0xA1, 
	0x9F, 0x5B, 0x63, 0x8A, 0x76, 0x45, 0x4D, 0xC5, 
	0xCD, 0x5B, 0x38, 0x2E, 0xF6, 0x21, 0xC8, 0x62, 
	0x4D, 0x20, 0xE0, 0xE3, 0x41, 0xED, 0x4D, 0x22, 
	0xDA, 0xF5, 0x99, 0xAE, 0x4D, 0x70, 0x56, 0x78, 
	0xD1, 0x97, 0xF1, 0xF1, 0xED, 0x06, 0x85, 0x18, 
	0x21, 0x2F, 0x47, 0x86, 0xC7, 0x4F, 0x30, 0x58, 
	0xDD, 0x2F, 0x65, 0x4C, 0xCC, 0xCF, 0xFF, 0xDF, 
	0xAD, 0x34, 0xA3, 0xA9, 0x62, 0xD3, 0xAF, 0xF9, 
	0x4A, 0x5A, 0x8A, 0xFE, 0x0B, 0x25, 0x45, 0x9B, 
	0x79, 0xF7, 0xFB, 0x8A, 0x4E, 0x52, 0x10, 0x32, 
	0xCB, 0x73, 0xCC, 0x79, 0xEF, 0xE4, 0xDB, 0x13, 
	0xEE, 0xF8, 0x33, 0x1B, 0x9D, 0xC3, 0x2C, 0x70, 
	0xEB, 0xF6, 0x98, 0x75, 0x75, 0xAD, 0x78, 0x61, 
	0xB3, 0x8A, 0x39, 0xE9, 0xB1, 0xF4, 0x93, 0xA5, 
	0xBB, 0x65, 0x4F, 0x2D, 0xA7, 0x70, 0x24, 0x3F, 
	0x4C, 0x56, 0xA5, 0xAF, 0x2F, 0x9D, 0xB7, 0xDF, 
	0x19, 0x71, 0x47, 0x74, 0x42, 0xFF, 0x5A, 0x89, 
	0x69, 0x8B, 0x1B, 0xF8, 0x16, 0x3D, 0x44, 0x54, 
	0xFE, 0xD3, 0xDB, 0x59, 0xB8, 0x3D, 0xBE, 0xF4, 
	0xCE, 0x1C, 0x83, 0x19, 0x59, 0x1B, 0x76, 0xD9, 
	0xEE, 0x84, 0x0C, 0x7E, 0x30, 0xC3, 0xC1, 0x6E, 
	0x41, 0xD6, 0x0E, 0x39, 0xE4, 0x33, 0xB6, 0x4C, 
	0xB0, 0x16, 0x91, 0x8C, 0xC2, 0x02, 0x6C, 0xFF, 
	0x5D, 0xC9, 0xC2, 0xC4, 0x04, 0x73, 0x1C, 0x34, 
	0xB6, 0xC6, 0x31, 0xA0, 0x8C, 0xAC, 0x5C, 0xCA, 
	0xCE, 0x22, 0x74, 0xD2, 0x5F, 0xD9, 0xAE, 0xCD, 
	0xFF, 0x17, 0xD5, 0x96, 0x7D, 0xF7, 0x34, 0xDB, 
	0x7B, 0x26, 0xB3, 0xA7, 0xC9, 0x6B, 0xC4, 0x48, 
	0x23, 0x1A, 0x79, 0xE1, 0xF0, 0x2B, 0x44, 0xB6, 
	0x13, 0x79, 0x9E, 0x76, 0x77, 0x0F, 0x40, 0x8C, 
	0xBE, 0x2F, 0xF3, 0x62, 0xC2, 0xCD, 0xB4, 0x23, 
	0x73, 0x70, 0xF6, 0x6C, 0x59, 0xB3, 0xF3, 0x74, 
	0x50, 0xB2, 0xB1, 0x65, 0x1B, 0x88, 0x5A, 0x37, 
	0x8F, 0xA6, 0x4F, 0xBB, 0x20, 0x5B, 0x47, 0xCB, 
	0x8C, 0xC5, 0x16, 0xCE, 0xE4, 0xA2, 0x06, 0x57, 
	0x3A, 0x9C, 0xAA, 0xBB, 0x3E, 0xFE, 0xE2, 0x4C, 
	0xE7, 0x9B, 0x12, 0x31, 0x35, 0xD8, 0x70, 0xAD, 
	0x61, 0xFA, 0x62, 0x9F, 0xD2, 0x11, 0xD1, 0xF4, 
	0x48, 0x4D, 0x3F, 0x48, 0x0F, 0xB5, 0x61, 0x86, 
	0xFF, 0x93, 0xF2, 0x70, 0x17, 0xB2, 0x7C, 0x82, 
	0xDC, 0x23, 0x07, 0x27, 0xCC, 0x7B, 0xF6, 0x9C, 
	0x01, 0xA2, 0xA7, 0xE6, 0xBC, 0x95, 0x0A, 0xAD, 
	0x8A, 0x5A, 0x67, 0xF1, 0xDD, 0x6C, 0x86, 0xEC, 
	0x38, 0x67, 0x91, 0x5D, 0xE5, 0x30, 0x44, 0xF7, 
	0x45, 0xFB, 0x79, 0x63, 0xEE, 0x1C, 0xF2, 0x17, 
	0x1B, 0xF7, 0x99, 0x7F, 0x2C, 0x53, 0xE3, 0xD8, 
	0x43, 0x7F, 0xE7, 0xE2, 0xB2, 0x7A, 0x20, 0x0E, 
	0x8A, 0xF1, 0x4E, 0x06, 0x94, 0x0C, 0x8D, 0x91, 
	0x65, 0xBC, 0xDC, 0xE2, 0x9A, 0x15, 0x63, 0x69, 
	0xC6, 0x9E, 0x4A, 0x16, 0xE1, 0xCC, 0xBC, 0x54, 
	0x01, 0xA4, 0x61, 0x7B, 0x94, 0xBF, 0x04, 0x40, 
	0x3C, 0x70, 0x44, 0x87, 0x30, 0x89, 0x6F, 0xFB, 
	0xF5, 0xA4, 0x02, 0x91, 0x9B, 0xB4, 0x5E, 0xF4, 
	0x7E, 0xAE, 0x53, 0xE1, 0x82, 0xA4, 0xB4, 0x1E, 
	0x73, 0xFD, 0x87, 0x32, 0x9E, 0x52, 0x82, 0xFD, 
	0xC6, 0xFF, 0xAB, 0xAD, 0xE4, 0x2D, 0xC7, 0xB6, 
	0xAE, 0xC5, 0x7C, 0xF9, 0xFF, 0xF6, 0x90, 0x9E, 
	0x18, 0xD8, 0x79, 0x22, 0x88, 0x4F, 0x96, 0x63, 
	0xE1, 0x63, 0x32, 0x95, 0x9C, 0x2E, 0xCF, 0xD6, 
	0xE1, 0x5C, 0xF0, 0xD3, 0xF3, 0x93, 0x52, 0x9E, 
	0x41, 0x28, 0xB4, 0xFB, 0x50, 0x9D, 0xEA, 0x73, 
	0x5B, 0x27, 0xA6, 0xB6, 0x6B, 0xCC, 0xB2, 0x1C, 
	0xE8, 0xCF, 0xAA, 0x11, 0xBB, 0x94, 0xFF, 0x01, 
	0x7A, 0xB1, 0x58, 0x34, 0x83, 0xD5, 0x7C, 0x34, 
	0x92, 0xD8, 0xE3, 0x9C, 0x5F, 0x15, 0x97, 0x09, 
	0x26, 0xEF, 0x46, 0x59, 0xCD, 0x39, 0x03, 0x13, 
	0xAA, 0xA3, 0xE8, 0xF8, 0x2A, 0x60, 0x19, 0x1B, 
	0x6E, 0x37, 0xD3, 0xAB, 0x9E, 0x2F, 0xC6, 0x8E, 
	0x1E, 0x87, 0x2B, 0x2C, 0xA7, 0xCE, 0xB8, 0x6D, 
	0x22, 0xCE, 0x88, 0xAC, 0x40, 0x7E, 0x06, 0x41, 
	0xFF, 0x91, 0xC9, 0x9F, 0x18, 0xD3, 0x9E, 0x65, 
	0x76, 0xF2, 0xFF, 0x13, 0x88, 0x58, 0xB8, 0xB1, 
	0x43, 0x5F, 0x57, 0x03, 0x6C, 0xB5, 0xCA, 0x4A, 
	0x64, 0xB9, 0x96, 0xED, 0x8C, 0xFE, 0xA6, 0xD2, 
	0xDD, 0x78, 0xFB, 0xFF, 0x99, 0x73, 0x3B, 0x5D, 
	0xB7, 0x98, 0xDE, 0x4D, 0x6B, 0x63, 0xC3, 0x99, 
	0xAE, 0x85, 0x36, 0xFF, 0x24, 0xDA, 0xA6, 0xD9, 
	0xAD, 0xC1, 0xA1, 0x78, 0xDA, 0x23, 0xCD, 0x38, 
	0x81, 0x65, 0xC7, 0x12, 0x1F, 0x76, 0x0F, 0x7F, 
	0xA4, 0x66, 0x2A, 0xEB, 0xF8, 0xB2, 0xB4, 0x1A, 
	0x3B, 0xF0, 0xCA, 0x4A, 0xA2, 0x83, 0x99, 0x60, 
	0x2B, 0x4F, 0x7D, 0x11, 0x7B, 0x12, 0xE9, 0x0F, 
	0x56, 0x8F, 0x22, 0xC1, 0x1A, 0x8A, 0x68, 0x13, 
	0xAF, 0xC7, 0xC0, 0x08, 0xD2, 0x8F, 0xF9, 0xE6, 
	0x08, 0xBD, 0x15, 0x99, 0xC5, 0x32, 0x29, 0xCA, 
	0x89, 0x67, 0x00, 0xDD, 0x98, 0x41, 0x6F, 0xB1, 
	0xC2, 0xF4, 0x31, 0xC5, 0x73, 0xCE, 0x2E, 0x86, 
	0x01, 0xB5, 0x37, 0xFF, 0x19, 0x0D, 0x5C, 0x7F, 
	0xCA, 0xD8, 0xCC, 0x06, 0x7D, 0x2E, 0x51, 0x37, 
	0xEE, 0x79, 0xC2, 0x02, 0x62, 0xF8, 0x00, 0x97, 
	0x52, 0x0F, 0x59, 0xC1, 0x87, 0xF7, 0xA1, 0xE9, 
	0xB2, 0x3B, 0xFC, 0x69, 0xB7, 0xED, 0x82, 0xD9, 
	0x73, 0x37, 0xB9, 0x2D, 0x6B, 0x4A, 0x53, 0x11, 
	0xC7, 0x83, 0x05, 0xA0, 0xE2, 0x4B, 0x19, 0xF0, 
	0x11, 0x6D, 0x28, 0x8F, 0xC7, 0x5D, 0x22, 0x99, 
	0x75, 0x77, 0x32, 0x02, 0xF3, 0x66, 0xF9, 0x65, 
	0x54, 0xD6, 0xFB, 0xB6, 0x04, 0xEB, 0x63, 0x8B, 
	0x44, 0x3E, 0x01, 0x62, 0x45, 0x78, 0xF2, 0x64, 
	0x89, 0x1C, 0xEE, 0xAD, 0x4B, 0xD1, 0xBF, 0x7C, 
	0xB4, 0xB4, 0x4E, 0xCB, 0xE7, 0x69, 0xFF, 0x16, 
	0x83, 0x25, 0xB3, 0x69, 0xBD, 0x75, 0x10, 0x34, 
	0x79, 0xDF, 0xB3, 0xCE, 0xC4, 0x17, 0x34, 0x79, 
	0x47, 0xD2, 0x81, 0x9B, 0xC1, 0xA5, 0x43, 0x7B, 
	0xB0, 0xF5, 0xB3, 0x9D, 0xFF, 0x07, 0xD2, 0x30, 
	0x4C, 0x74, 0xB4, 0xF2, 0x83, 0xC8, 0xBC, 0x78, 
	0x8B, 0x83, 0x41, 0x4C, 0x0F, 0xDD, 0x65, 0xEA, 
	0x89, 0x4E, 0xDD, 0xEA, 0x7E, 0x6D, 0xC3, 0x35, 
	0xD9, 0x16, 0xB7, 0x7C, 0x5A, 0x05, 0x3C, 0xA3, 
	0x7A, 0xF5, 0x70, 0xEA, 0x77, 0x34, 0xD0, 0xD2, 
	0x9A, 0xC3, 0x82, 0x4C, 0x53, 0xAA, 0x49, 0xCD, 
	0xC2, 0xBC, 0x88, 0x9D, 0xC7, 0x27, 0x81, 0xB8, 
	0xC8, 0xC6, 0xC9, 0xEF, 0x8F, 0x24, 0x2B, 0xBA, 
	0x79, 0x1C, 0x60, 0x94, 0xB0, 0xDA, 0xD7, 0x48, 
	0x2C, 0x32, 0x7F, 0x0B, 0x6B, 0xC8, 0x3D, 0x72, 
	0xAD, 0x12, 0xE8, 0x8A, 0x9E, 0x29, 0xBE, 0x9A, 
	0x54, 0x4B, 0x6C, 0x71, 0x6D, 0xC1, 0xB2, 0x4B, 
	0xCB, 0x73, 0x7D, 0x6A, 0xE3, 0xBB, 0xEC, 0xFB, 
	0x91, 0x75, 0x45, 0x2B, 0x3E, 0xC5, 0xAB, 0x28, 
	0x5D, 0xBD, 0x11, 0x8F, 0x2D, 0xDB, 0xAE, 0x95, 
	0x29, 0x45, 0x03, 0xE0, 0x1E, 0xFF, 0x7D, 0x49, 
	0x9B, 0x4E, 0x95, 0xA4, 0x73, 0x31, 0x8A, 0x38, 
	0xC0, 0x43, 0x6A, 0x1D, 0xB6, 0x2A, 0x2C, 0xA8, 
	0x0C, 0xE2, 0xDB, 0x06, 0x2B, 0x07, 0x20, 0x38, 
	0x84, 0x55, 0xCC, 0x81, 0x3B, 0xC1, 0xC7, 0x28, 
	0x5E, 0x83, 0x0E, 0xB6, 0x14, 0x1D, 0x31, 0x7C, 
	0x8E, 0xE2, 0x38, 0x9C, 0xDE, 0x2E, 0x63, 0xF7, 
	0x76, 0xD2, 0xCE, 0xD1, 0x5E, 0x35, 0x40, 0x30, 
	0x98, 0xB5, 0xE4, 0x25, 0xEE, 0x09, 0xE4, 0xDB, 
	0x92, 0xCF, 0x03, 0x84, 0xB5, 0xD0, 0xD7, 0x12, 
	0xA1, 0x7F, 0xBC, 0x7A, 0xA7, 0x8B, 0x56, 0x30, 
	0xBB, 0x43, 0xC0, 0x13, 0x6C, 0xD4, 0x16, 0xD1, 
	0x90, 0x19, 0xF9, 0x90, 0xA6, 0x65, 0x90, 0x23, 
	0x8C, 0x2C, 0xF0, 0x44, 0x98, 0x90, 0x21, 0x19, 
	0xDA, 0x2C, 0x0B, 0x32, 0xFD, 0xE9, 0x01, 0xB4, 
	0x34, 0x8F, 0x05, 0x97, 0x79, 0xD7, 0xE9, 0xB6, 
	0x35, 0x3F, 0x58, 0x95, 0xC8, 0x05, 0xFF, 0x90, 
	0xE4, 0x04, 0xBC, 0x82, 0x6F, 0xDB, 0x11, 0x73, 
	0x2B, 0x3D, 0xD5, 0x37, 0x93, 0x8E, 0x25, 0x63, 
	0xBC, 0x16, 0xBA, 0x69, 0xA6, 0xB2, 0xB7, 0xBE, 
	0x67, 0xC9, 0x61, 0x4D, 0xD8, 0x25, 0xD7, 0x59, 
	0xEC, 0x59, 0x04, 0xA6, 0xC9, 0x35, 0x04, 0xF5, 
	0x61, 0x52, 0x2A, 0x2F, 0xF0, 0x59, 0x59, 0x12, 
	0xAA, 0xBF, 0xDC, 0xCA, 0xEF, 0x68, 0xEE, 0x13, 
	0x5B, 0x99, 0x2B, 0x6D, 0xA0, 0x17, 0xF7, 0x6C, 
	0xFE, 0x4D, 0x48, 0x7A, 0x76, 0xC5, 0x29, 0x9E, 
	0xAA, 0x38, 0x74, 0x13, 0x36, 0x42, 0x38, 0x8C, 
	0x27, 0x75, 0x1B, 0x16, 0xEE, 0x05, 0x5D, 0xAD, 
	0x6A, 0x05, 0x15, 0x6F, 0x0C, 0xC5, 0x8F, 0x47, 
	0x3E, 0x11, 0xCF, 0x73, 0x29, 0x67, 0x6F, 0x35, 
	0x16, 0x70, 0x34, 0x8B, 0xA5, 0xCB, 0x9F, 0xCC, 
	0x43, 0x8C, 0x33, 0x13, 0xA6, 0x68, 0xEF, 0x7C, 
	0x18, 0xB3, 0xA5, 0x7C, 0x49, 0xFF, 0x6F, 0xFF, 
	0x16, 0xD1, 0x83, 0x69, 0x5A, 0x7F, 0x58, 0xF1, 
	0x71, 0x32, 0x27, 0x96, 0xFC, 0xCF, 0x5E, 0xA4, 
	0x4A, 0x8F, 0x52, 0x7C, 0xD7, 0x6E, 0x9D, 0x81, 
	0x14, 0x8E, 0x41, 0x30, 0xB1, 0xDD, 0x4F, 0x30, 
	0x7D, 0xCF, 0x7F, 0x6E, 0x40, 0xF7, 0xC1, 0xA1, 
	0xD0, 0xEA, 0x45, 0x7C, 0xFE, 0xF0, 0x65, 0x75, 
	0x14, 0x81, 0x9D, 0xEE, 0x5B, 0xF3, 0xE3, 0x57, 
	0x5B, 0x45, 0x2C, 0xF9, 0xE8, 0x8C, 0x63, 0xAD, 
	0xB0, 0x06, 0x1E, 0x29, 0xA0, 0x3D, 0x7E, 0x73, 
	0xCB, 0xB4, 0x7A, 0x09, 0x60, 0x60, 0xB9, 0xA2, 
	0x5E, 0x7D, 0xA9, 0xFD, 0xAB, 0xF7, 0x32, 0x7F, 
	0x74, 0x0C, 0xB6, 0xAD, 0x21, 0x6D, 0xD0, 0xF2, 
	0x6D, 0x5C, 0xB7, 0xE2, 0xE5, 0xE1, 0xF3, 0x1D, 
	0x13, 0x4E, 0x09, 0xCD, 0x44, 0xF2, 0x1D, 0x6A, 
	0xA9, 0x29, 0x41, 0xD9, 0x8A, 0x15, 0xC0, 0xA9, 
	0x41, 0x55, 0xC4, 0x89, 0xC2, 0xAF, 0x20, 0x31, 

	/* Database Page 14 */

	0xFF, 0xE0, 0xE2, 0x4C, 0xA1, 0xA0, 0x08, 0xB3, 
	0x56, 0xD8, 0x34, 0x68, 0xAB, 0x1B, 0xF8, 0x68, 
	0x0A, 0x44, 0x70, 0x3A, 0xBD, 0xCE, 0x22, 0x0D, 
	0x29, 0x70, 0xC6, 0x07, 0x42, 0xC3, 0x40, 0xB2, 
	0xDA, 0xB8, 0xB2, 0x21, 0xB1, 0xC1, 0xA9, 0x21, 
	0xE7, 0x97, 0xC9, 0x78, 0xFA, 0x92, 0xF5, 0x09, 
	0xCE, 0x01, 0xA4, 0x33, 0x8C, 0x6B, 0xB5, 0xE1, 
	0x33, 0xE5, 0xF3, 0xFB, 0xC8, 0xA6, 0x11, 0x96, 
	0x3F, 0x89, 0x4E, 0x86, 0xF7, 0xEA, 0xA3, 0x0B, 
	0xDB, 0x9D, 0x7A, 0xDB, 0xA0, 0xC7, 0x60, 0x17, 
	0x67, 0x11, 0xB6, 0x44, 0x2C, 0xC7, 0x56, 0x5E, 
	0x39, 0xE5, 0xF3, 0xE1, 0x0E, 0x9C, 0xBF, 0x37, 
	0x5D, 0x6F, 0x16, 0xEF, 0x2E, 0xA6, 0x13, 0x71, 
	0xAB, 0xAC, 0xBF, 0xC7, 0xB6, 0x44, 0x3B, 0x65, 
	0x5D, 0x23, 0x20, 0xAC, 0xF8, 0x04, 0x3C, 0xAC, 
	0xE5, 0x56, 0x76, 0x7F, 0xC4, 0xBC, 0x98, 0x4C, 
	0xFC, 0xFF, 0xE1, 0xE0, 0xE0, 0x7A, 0xDB, 0x51, 
	0xA5, 0x80, 0x02, 0x37, 0x2E, 0xEB, 0x7C, 0x98, 
	0x91, 0xAD, 0xDE, 0x10, 0xD5, 0x91, 0xD6, 0x15, 
	0x5C, 0x74, 0x5B, 0xA9, 0x3F, 0xB4, 0x87, 0x84, 
	0x6B, 0x5E, 0x4C, 0xC7, 0x2A, 0xBC, 0xDC, 0xF5, 
	0x20, 0x6E, 0xCB, 0x05, 0x4D, 0xD0, 0x37, 0xAD, 
	0x45, 0x77, 0x58, 0xAE, 0xAA, 0x95, 0x47, 0xC3, 
	0x4E, 0x4B, 0xC4, 0xA8, 0x4D, 0xF0, 0x79, 0x97, 
	0x35, 0x14, 0xB7, 0x49, 0x76, 0xA7, 0x90, 0x14, 
	0x5C, 0xA8, 0x96, 0x22, 0xAA, 0x1F, 0x8F, 0x1B, 
	0x7E, 0xFD, 0x05, 0xBC, 0x55, 0x7D, 0x14, 0xE8, 
	0xCF, 0x27, 0x68, 0x81, 0xC7, 0x8B, 0xA4, 0x79, 
	0xBC, 0xE7, 0xFE, 0xE2, 0x27, 0x6B, 0xC7, 0x9B, 
	0x25, 0xAD, 0x57, 0xE4, 0x7F, 0x8C, 0x38, 0x39, 
	0xF3, 0x37, 0x8C, 0x7B, 0xA5, 0x69, 0xDD, 0xA4, 
	0x77, 0xD2, 0x64, 0x3E, 0x84, 0xDB, 0x21, 0x44, 
	0x7B, 0xCA, 0xFF, 0x5B, 0x1D, 0x7A, 0x52, 0x2F, 
	0xD9, 0x94, 0x45, 0x6D, 0x1B, 0x49, 0xB1, 0xD9, 
	0x77, 0xD3, 0x5F, 0x35, 0x51, 0x0A, 0xF6, 0x9A, 
	0x42, 0x02, 0x8E, 0x31, 0xE2, 0xFA, 0x71, 0xF8, 
	0x31, 0x62, 0x6C, 0xB5, 0x3C, 0xCD, 0x33, 0x20, 
	0x23, 0x23, 0xF5, 0xC5, 0x93, 0x32, 0xF4, 0xF3, 
	0x1E, 0x2A, 0x81, 0x40, 0x36, 0x9D, 0xEF, 0xB0, 
	0xC6, 0x04, 0xA4, 0x4E, 0x3F, 0xF1, 0x85, 0x2A, 
	0x7B, 0x9C, 0x8B, 0xF0, 0xDE, 0x10, 0x18, 0xDE, 
	0xB9, 0x75, 0x5F, 0x31, 0x7E, 0x14, 0x18, 0x28, 
	0x39, 0x1E, 0xE6, 0x7C, 0x06, 0xC4, 0x68, 0xAC, 
	0xC8, 0x24, 0x23, 0xAF, 0x2D, 0x3F, 0xAF, 0x4D, 
	0x62, 0xEA, 0x72, 0x48, 0xEF, 0xCE, 0x15, 0xAC, 
	0x88, 0x0C, 0x57, 0xF4, 0x28, 0x73, 0x3F, 0xE8, 
	0x53, 0x92, 0xAD, 0x4A, 0xED, 0xDB, 0x17, 0x54, 
	0x99, 0xFB, 0x1C, 0x87, 0xB1, 0x6D, 0xF9, 0x57, 
	0x57, 0x21, 0xD0, 0xFF, 0x50, 0x5F, 0x19, 0x88, 
	0x60, 0xB8, 0x4B, 0xEE, 0x47, 0x1F, 0x82, 0x65, 
	0x75, 0xE9, 0x91, 0xF4, 0xA8, 0x15, 0xBA, 0xB4, 
	0x11, 0x9B, 0x05, 0xA3, 0x89, 0x89, 0xAA, 0x58, 
	0xB4, 0x8F, 0x11, 0x31, 0x72, 0x85, 0x8D, 0xBA, 
	0xB2, 0xD2, 0x81, 0xBA, 0x34, 0x88, 0xF5, 0x6E, 
	0x92, 0xF8, 0xD6, 0x78, 0xC1, 0x73, 0x62, 0xA6, 
	0x0A, 0x98, 0x2F, 0x05, 0x97, 0x91, 0x95, 0x64, 
	0x43, 0x1B, 0xFC, 0xD7, 0x4A, 0xFF, 0xAD, 0xAD, 
	0x83, 0x4B, 0x39, 0xB1, 0x29, 0x49, 0x9A, 0x39, 
	0x52, 0x9F, 0xED, 0x29, 0xFB, 0xDF, 0xDD, 0x1B, 
	0x73, 0x5C, 0xD3, 0x36, 0xE5, 0xC2, 0x0D, 0x8C, 
	0x93, 0xD6, 0x86, 0x27, 0xE4, 0x58, 0xAE, 0x79, 
	0x47, 0xCF, 0xFF, 0x05, 0xFA, 0x7E, 0xD6, 0x3F, 
	0x99, 0x32, 0x19, 0xC4, 0xD9, 0x30, 0x51, 0xA0, 
	0x39, 0xF1, 0x10, 0x4B, 0x9E, 0x76, 0xAD, 0xFA, 
	0xBC, 0xC8, 0xD0, 0x64, 0xFF, 0xF2, 0xF3, 0x3E, 
	0x5A, 0x37, 0xD5, 0xFE, 0x9B, 0x8A, 0x8B, 0xCB, 
	0xAF, 0x41, 0x72, 0xC3, 0x7B, 0x37, 0xB7, 0x8D, 
	0x2D, 0xF6, 0xB1, 0x76, 0x3E, 0x39, 0xCD, 0xA0, 
	0xA8, 0xC6, 0xB9, 0x80, 0x04, 0xBE, 0x62, 0x23, 
	0x67, 0x8A, 0xE8, 0x67, 0x44, 0x43, 0xD5, 0xEC, 
	0x92, 0x12, 0xE5, 0x80, 0xF7, 0x60, 0x34, 0x2F, 
	0x7C, 0x19, 0xB0, 0xC6, 0xA1, 0xF2, 0x8C, 0x6C, 
	0x28, 0x6C, 0x8D, 0xAD, 0x84, 0x49, 0x91, 0x59, 
	0x9E, 0xD4, 0x32, 0x90, 0x50, 0x30, 0x90, 0x8B, 
	0x12, 0xBB, 0x94, 0x65, 0xDB, 0xAB, 0x05, 0x84, 
	0x6D, 0x61, 0xF6, 0xBD, 0x6A, 0xD3, 0x02, 0xAC, 
	0x1C, 0x05, 0xC8, 0x25, 0x21, 0x3A, 0xFB, 0x9B, 
	0x76, 0x98, 0x30, 0x45, 0x25, 0x45, 0xE2, 0x35, 
	0xBF, 0x54, 0xDF, 0xD7, 0x19, 0x84, 0x81, 0x8E, 
	0x73, 0xC0, 0x5D, 0xBF, 0x28, 0x22, 0xB3, 0x24, 
	0x64, 0xEB, 0x88, 0x07, 0x1B, 0xFF, 0x9C, 0xCD, 
	0xC0, 0x19, 0x8A, 0xA9, 0x07, 0x51, 0x52, 0xAA, 
	0x52, 0x80, 0x22, 0x31, 0xD3, 0x38, 0xF4, 0x07, 
	0x63, 0xE1, 0x8A, 0xBD, 0x87, 0x02, 0xB9, 0x39, 
	0xFF, 0x26, 0x4D, 0x77, 0xB1, 0xB9, 0x30, 0xE2, 
	0xE9, 0x65, 0xBA, 0x94, 0xEA, 0x7E, 0xF1, 0x32, 
	0xF0, 0xDC, 0x3F, 0x94, 0xAF, 0x46, 0x8F, 0xE9, 
	0x73, 0xE4, 0xCB, 0x6E, 0xDA, 0x46, 0x78, 0x39, 
	0x78, 0x71, 0x46, 0x25, 0xED, 0x68, 0x1E, 0x32, 
	0x43, 0xD4, 0xC7, 0x81, 0x83, 0xAE, 0x13, 0x25, 
	0x3B, 0x92, 0xC3, 0xBD, 0x34, 0x13, 0xF2, 0x61, 
	0x39, 0x45, 0xD2, 0x40, 0xE4, 0xE7, 0x2D, 0x56, 
	0x17, 0xA1, 0x31, 0x3E, 0x42, 0x0D, 0x4A, 0x48, 
	0x47, 0x80, 0x1C, 0x06, 0xB8, 0x38, 0x6B, 0x29, 
	0x3D, 0x3D, 0x2A, 0x5E, 0x72, 0xC9, 0x69, 0x01, 
	0xCA, 0x6D, 0x72, 0x9A, 0x22, 0xAC, 0xA0, 0xBD, 
	0x7A, 0x97, 0x47, 0x17, 0xC6, 0xE5, 0xFF, 0x1D, 
	0x8D, 0x25, 0xB7, 0x16, 0xAA, 0x23, 0x09, 0xA3, 
	0x5F, 0x3E, 0x32, 0xD0, 0x46, 0xFF, 0x93, 0x7F, 
	0x00, 0xE0, 0x4E, 0xBF, 0xE8, 0xA9, 0x2E, 0x5D, 
	0x3E, 0xD5, 0xFC, 0xEA, 0x64, 0x9B, 0xE7, 0x77, 
	0x64, 0xB1, 0x20, 0xE3, 0x75, 0x3B, 0x8C, 0xA0, 
	0xBC, 0x39, 0x5F, 0x25, 0x5F, 0x72, 0x84, 0x74, 
	0x50, 0x1A, 0x11, 0xDB, 0xC2, 0x14, 0x82, 0x95, 
	0x00, 0xBB, 0x86, 0xB8, 0xC8, 0xBC, 0x6A, 0x61, 
	0x06, 0x3B, 0xD4, 0xF3, 0x55, 0xC3, 0x95, 0xCF, 
	0x94, 0xE0, 0x3E, 0xEB, 0xF5, 0x5C, 0x21, 0x66, 
	0xB7, 0xEA, 0xEB, 0xFC, 0xF8, 0xF0, 0x72, 0x87, 
	0xAD, 0x52, 0x1B, 0xC0, 0x4E, 0xC4, 0x76, 0xE4, 
	0xAB, 0x78, 0x90, 0xFC, 0xAB, 0xCE, 0xA9, 0xCA, 
	0x98, 0xD8, 0x61, 0x51, 0x04, 0x7D, 0x26, 0x6A, 
	0xFB, 0xBA, 0x6C, 0x23, 0x63, 0x5C, 0x4B, 0xCF, 
	0x97, 0xE7, 0xE5, 0x38, 0x54, 0x86, 0x02, 0xFF, 
	0xBB, 0xC7, 0x8D, 0xB9, 0xA1, 0xAB, 0xCE, 0x31, 
	0x6F, 0xEF, 0xC5, 0x76, 0xE6, 0x1D, 0x51, 0x31, 
	0xD5, 0x33, 0x4D, 0x7F, 0x02, 0xEB, 0x4E, 0x65, 
	0x4D, 0x92, 0x0A, 0x13, 0xF7, 0x55, 0x1F, 0x04, 
	0x15, 0x7D, 0xCC, 0x6B, 0x7C, 0xAE, 0x68, 0x8F, 
	0x0F, 0xF5, 0xF0, 0xB7, 0x0F, 0xEE, 0x76, 0x41, 
	0x8A, 0xD4, 0x93, 0xEB, 0x28, 0x37, 0xF6, 0xB4, 
	0xA0, 0xEF, 0xF4, 0x09, 0x67, 0x9D, 0xB8, 0xBC, 
	0x4F, 0x0A, 0x22, 0x7F, 0xBF, 0x4E, 0x10, 0xBE, 
	0xEC, 0x3F, 0xCA, 0x88, 0x42, 0x5E, 0x6F, 0x3B, 
	0x6F, 0xAB, 0x6A, 0xA1, 0x93, 0x31, 0xD1, 0x98, 
	0x23, 0x11, 0x05, 0xDA, 0x07, 0x30, 0x4E, 0xC7, 
	0xF6, 0x05, 0x9C, 0x11, 0x06, 0xFA, 0x75, 0x86, 
	0xD6, 0xA4, 0x6E, 0x2B, 0x0D, 0x0A, 0x24, 0x5D, 
	0x1B, 0x80, 0x09, 0x8A, 0x70, 0xF1, 0x85, 0x59, 
	0xB2, 0xB2, 0xF8, 0xB0, 0x40, 0xD3, 0xFE, 0xA0, 
	0xFF, 0xFD, 0xD3, 0xB0, 0x7B, 0xBE, 0x44, 0x92, 
	0x9C, 0x3E, 0x11, 0x1A, 0x76, 0x22, 0x68, 0xF6, 
	0x0B, 0xE5, 0xA0, 0x4E, 0xF4, 0x87, 0x02, 0x82, 
	0x09, 0x9D, 0x7D, 0xC8, 0xA1, 0x0F, 0x76, 0x15, 
	0xD8, 0x8C, 0x5E, 0x55, 0x82, 0x76, 0xA8, 0x02, 
	0xAD, 0x7E, 0x93, 0x79, 0x53, 0x63, 0x1A, 0xEF, 
	0x83, 0x9E, 0xE5, 0x12, 0x66, 0xAF, 0x13, 0x86, 
	0xC7, 0x48, 0xB3, 0xD6, 0xA2, 0xD3, 0x36, 0xA1, 
	0x58, 0xF8, 0x93, 0x9D, 0xE4, 0xDC, 0xBC, 0xD8, 
	0x43, 0x03, 0x59, 0x20, 0x3B, 0xB7, 0xEF, 0x84, 
	0x9B, 0x49, 0x51, 0x8E, 0x7F, 0x12, 0xDA, 0x2E, 
	0xD5, 0xC4, 0x2E, 0xFF, 0x7B, 0x3F, 0x88, 0xE1, 
	0x24, 0x42, 0x0F, 0x42, 0x4F, 0x91, 0xB0, 0x7E, 
	0xE6, 0xA3, 0xD4, 0x70, 0xAE, 0xD6, 0xC5, 0xBE, 
	0xDD, 0x22, 0x44, 0xDF, 0x9D, 0x1F, 0x20, 0x1C, 
	0x41, 0x54, 0xC9, 0x01, 0xAD, 0x5A, 0x9E, 0x27, 
	0xE0, 0xFF, 0x5A, 0xE4, 0x71, 0x52, 0x9A, 0x12, 
	0x57, 0x59, 0x0F, 0x46, 0x41, 0x00, 0xC2, 0x7D, 
	0x5D, 0x0C, 0xB2, 0xB1, 0xB2, 0x10, 0xB6, 0x91, 
	0xBF, 0xB2, 0xCF, 0xB9, 0x44, 0x92, 0x9E, 0xF2, 
	0x20, 0x45, 0xFE, 0x16, 0x5B, 0x51, 0xA8, 0xD7, 
	0x99, 0x13, 0x4B, 0xB4, 0x2F, 0x4B, 0x34, 0xE9, 
	0x32, 0x2D, 0x53, 0x02, 0x57, 0x0F, 0x51, 0xE9, 
	0xC1, 0x22, 0x6E, 0x2F, 0x45, 0x95, 0x50, 0xA7, 
	0xAA, 0xA5, 0x8B, 0x3A, 0x46, 0xBB, 0x9F, 0x5F, 
	0xC5, 0xA8, 0xEC, 0x5C, 0x12, 0xF1, 0x10, 0x71, 
	0x4A, 0x3A, 0x01, 0xAA, 0xC7, 0x97, 0x70, 0xA3, 
	0x50, 0x5B, 0x6B, 0xDF, 0x4F, 0x46, 0xE2, 0xE9, 
	0x31, 0x44, 0x61, 0x71, 0x1E, 0x87, 0xC7, 0x6D, 
	0xF7, 0x61, 0xBE, 0xA7, 0xAC, 0x20, 0xE2, 0xC5, 
	0xA9, 0xAC, 0x5E, 0x1F, 0x56, 0x70, 0x0E, 0xDA, 
	0x9B, 0x40, 0x52, 0x33, 0xCA, 0x18, 0x5F, 0x00, 
	0xA0, 0x04, 0xFF, 0x35, 0xC6, 0x12, 0xA7, 0xCD, 
	0xA3, 0x01, 0x89, 0x9B, 0x34, 0x30, 0x5C, 0x83, 
	0xFE, 0xF1, 0x93, 0x46, 0x07, 0xB4, 0x66, 0x1B, 
	0x04, 0x7A, 0x24, 0x87, 0xF2, 0x7D, 0x21, 0xE4, 
	0xD4, 0x74, 0xA3, 0x23, 0x9D, 0x78, 0xB4, 0xE6, 
	0x23, 0xA0, 0x1B, 0x4E, 0xB1, 0x0A, 0x10, 0xDC, 
	0xF5, 0xE1, 0x4F, 0x30, 0xA1, 0x17, 0xE7, 0x1D, 
	0x48, 0xEB, 0x2A, 0x98, 0xE1, 0xAB, 0x7A, 0x84, 
	0x30, 0x08, 0xBD, 0xC4, 0x8B, 0x0A, 0xEB, 0xEC, 
	0xAC, 0xBF, 0xBA, 0x87, 0x95, 0xC3, 0x89, 0x6B, 
	0xE6, 0xAA, 0x1F, 0xF0, 0x2B, 0x33, 0x41, 0xC7, 
	0x4C, 0x29, 0x84, 0x97, 0xE7, 0x59, 0x46, 0x97, 
	0x72, 0x7C, 0x56, 0xD6, 0x31, 0xE1, 0x1A, 0x4D, 
	0x81, 0x5D, 0x8C, 0x91, 0x5E, 0xF4, 0x91, 0x9D, 
	0x8A, 0x7C, 0xD6, 0xCC, 0xDB, 0x19, 0x22, 0xE2, 
	0xE5, 0xC6, 0xA6, 0x6A, 0x23, 0xC7, 0x1B, 0xFA, 
	0x2F, 0xEA, 0x5D, 0xFF, 0x2D, 0x84, 0xC4, 0x91, 
	0x1D, 0xFC, 0x4A, 0x6B, 0x69, 0x12, 0xB6, 0x42, 
	0xF7, 0xCE, 0x49, 0x6C, 0x4C, 0xEF, 0xEF, 0x0D, 
	0x9E, 0x9C, 0xEE, 0x24, 0x92, 0xE4, 0xD0, 0x2D, 
	0x65, 0x85, 0xE9, 0x8E, 0x3E, 0xE6, 0x4C, 0xB4, 
	0x40, 0x57, 0x27, 0x62, 0x08, 0xF3, 0x5F, 0xE1, 
	0x8C, 0xBE, 0xEE, 0xA5, 0x51, 0x16, 0x7A, 0x76, 
	0x48, 0xC4, 0x70, 0xAA, 0x71, 0xF8, 0x92, 0x83, 
	0x39, 0xB3, 0x6B, 0xA2, 0x44, 0x62, 0x7C, 0x44, 
	0x49, 0xAD, 0x43, 0xE6, 0xAB, 0x09, 0x1C, 0x4F, 
	0xE4, 0xC6, 0x67, 0xCD, 0x88, 0x20, 0x6B, 0x8A, 
	0x96, 0x44, 0xD5, 0xF3, 0x36, 0xFD, 0x3C, 0x8A, 
	0xDB, 0xD3, 0xBF, 0x46, 0xCB, 0x81, 0x96, 0x9D, 
	0x03, 0x57, 0xA6, 0x8C, 0xC0, 0x59, 0x9F, 0xCC, 
	0x2B, 0xAF, 0xF2, 0xE5, 0x56, 0x18, 0x84, 0x00, 
	0x40, 0x2C, 0x71, 0x6C, 0x55, 0x66, 0x50, 0x43, 
	0x0F, 0x99, 0x6D, 0x04, 0xFF, 0x3C, 0x3E, 0xF0, 
	0xBB, 0x89, 0x93, 0x47, 0xE9, 0x1C, 0xE1, 0x0A, 
	0xD9, 0x9E, 0x9B, 0x5C, 0x7D, 0x9A, 0xB6, 0x80, 
	0x3B, 0x21, 0x4F, 0x5F, 0x21, 0xB5, 0x6A, 0xA2, 
	0xAE, 0xA5, 0x32, 0x51, 0x6A, 0x28, 0x90, 0x64, 
	0xC7, 0x45, 0x54, 0x44, 0x31, 0x0B, 0x44, 0x61, 
	0x95, 0x8F, 0x10, 0x3F, 0x63, 0xBD, 0xC6, 0x4F, 
	0x01, 0x1B, 0x45, 0xB8, 0x21, 0xE9, 0xC9, 0x63, 
	0xC6, 0x46, 0x58, 0xF9, 0x2E, 0xD8, 0x6A, 0x1D, 
	0x9B, 0x43, 0xDF, 0xB1, 0xFC, 0x27, 0x10, 0x0E, 
	0x71, 0x6E, 0x7B, 0xF0, 0xDB, 0x25, 0x2D, 0x00, 
	0xDD, 0x22, 0x1C, 0x91, 0xDD, 0xB5, 0xF7, 0xC9, 
	0x38, 0x74, 0x5E, 0xAD, 0xE9, 0x56, 0xD7, 0x35, 
	0xCA, 0xAF, 0x51, 0xC0, 0x26, 0x15, 0xF9, 0x84, 
	0x70, 0xCF, 0x0A, 0x49, 0x7B, 0xBD, 0x79, 0x16, 
	0x7E, 0x5C, 0xEC, 0x16, 0x7C, 0x40, 0x1D, 0xCD, 
	0xE3, 0x77, 0x03, 0x5A, 0x0D, 0xFF, 0xAA, 0x4A, 
	0x82, 0x26, 0x3F, 0x57, 0xC2, 0x6B, 0xDB, 0xDB, 
	0xEB, 0xF2, 0x3E, 0xCF, 0x3B, 0xF7, 0xBF, 0xDD, 
	0x21, 0xF8, 0x9E, 0x8C, 0x37, 0x6A, 0x88, 0x10, 
	0xE4, 0x8B, 0x3C, 0x7F, 0x6E, 0x55, 0x2D, 0x67, 
	0xED, 0x01, 0x77, 0xC9, 0x2C, 0x67, 0xE9, 0x59, 
	0x24, 0x75, 0xC9, 0xFA, 0xBA, 0xA5, 0x81, 0x50, 
	0x49, 0x1E, 0x86, 0x03, 0xCB, 0x5B, 0xE2, 0x89, 
	0x9F, 0x31, 0x98, 0x77, 0x2D, 0xF6, 0x47, 0x28, 
	0x22, 0x22, 0x4B, 0x31, 0x0F, 0xAD, 0x50, 0xD7, 
	0x48, 0xE7, 0x7F, 0xE1, 0xFD, 0xE4, 0xB0, 0x99, 
	0x51, 0x88, 0x0C, 0xD4, 0x52, 0x0C, 0x25, 0x11, 
	0x2F, 0xB8, 0x6B, 0x5B, 0x01, 0xAC, 0x93, 0x0E, 
	0x8C, 0x04, 0x2A, 0x1E, 0x35, 0x40, 0x02, 0xCD, 
	0x92, 0xA2, 0xF7, 0xD5, 0x46, 0x61, 0x7D, 0xEB, 
	0xDF, 0xB0, 0xFD, 0x2E, 0x7B, 0x07, 0xA6, 0xB8, 
	0x5D, 0x4D, 0x41, 0xC3, 0x3A, 0x23, 0xFF, 0xF2, 
	0x11, 0x05, 0xD3, 0x91, 0x0E, 0x55, 0xE7, 0x26, 
	0x47, 0x66, 0xD9, 0xE7, 0x29, 0x38, 0xBD, 0xFD, 
	0xDC, 0x08, 0xA0, 0x83, 0x43, 0xE8, 0xB2, 0x18, 
	0x6D, 0x18, 0xE6, 0xDB, 0x9D, 0xC6, 0xE7, 0x5F, 
	0xF7, 0xAA, 0x14, 0xEF, 0x9C, 0x00, 0x36, 0x22, 
	0x80, 0x60, 0x0E, 0xD3, 0xB2, 0x15, 0xC0, 0xE0, 
	0x40, 0x93, 0x6C, 0xB5, 0x83, 0xA8, 0x9A, 0x44, 
	0x85, 0x64, 0x25, 0xF9, 0xEB, 0x92, 0xAF, 0xA9, 
	0x62, 0x0E, 0xA4, 0x92, 0x54, 0x26, 0x1E, 0xF1, 
	0x3C, 0x87, 0x67, 0xFA, 0xEC, 0x40, 0x6D, 0x5C, 
	0xB0, 0xF1, 0xEA, 0x02, 0xCB, 0x40, 0x21, 0x89, 
	0xB2, 0x0A, 0x2F, 0x9E, 0x16, 0xDC, 0x08, 0xFB, 
	0x38, 0x7A, 0xA9, 0x25, 0xCC, 0x3C, 0x6A, 0xCD, 
	0x7C, 0x52, 0x22, 0xC7, 0x32, 0x36, 0xA4, 0x72, 
	0xE5, 0x1F, 0xA0, 0xEC, 0x19, 0x3F, 0xE4, 0xB8, 
	0xED, 0x5D, 0x6B, 0xDD, 0xFE, 0x92, 0xB4, 0xFF, 
	0xD1, 0x15, 0x34, 0x31, 0xBB, 0x5D, 0xD7, 0x9C, 
	0x9F, 0x71, 0x44, 0x08, 0x88, 0x2F, 0x15, 0xE1, 
	0x53, 0x7E, 0x19, 0x1E, 0x84, 0x82, 0x9D, 0x27, 
	0xDB, 0x77, 0x8A, 0x37, 0x09, 0x57, 0x96, 0x23, 
	0xC9, 0xAF, 0x45, 0x5A, 0x68, 0x99, 0x7F, 0xB3, 
	0xDC, 0x55, 0xDC, 0x6C, 0xB3, 0x80, 0x24, 0xA4, 
	0x8D, 0xFC, 0x91, 0x07, 0x69, 0xB4, 0x60, 0x09, 
	0x3B, 0x1F, 0xF9, 0x7B, 0x13, 0x34, 0x2D, 0xB0, 
	0xE6, 0xC3, 0xB3, 0x8E, 0xB3, 0x19, 0xAA, 0x66, 
	0xB4, 0xE9, 0xE2, 0x9C, 0x61, 0x7A, 0xAE, 0x68, 
	0xDC, 0x88, 0xEC, 0x4B, 0xE2, 0xD0, 0x9D, 0x91, 
	0x63, 0xF9, 0x9D, 0x89, 0x49, 0x4B, 0xCB, 0x09, 
	0xEA, 0x71, 0x3D, 0x01, 0x11, 0x8F, 0xF5, 0x40, 
	0xBA, 0x37, 0x54, 0x1B, 0xA8, 0x8B, 0xFE, 0xA4, 
	0x30, 0xEB, 0xA8, 0xA2, 0x72, 0x78, 0x04, 0x56, 
	0x80, 0xB4, 0x78, 0x73, 0x74, 0x3F, 0x22, 0xC7, 

	/* Database Page 15 */

	0xFF, 0x25, 0x6E, 0x32, 0x0C, 0x2E, 0x60, 0x51, 
	0x8E, 0x65, 0x06, 0x4A, 0x69, 0xEC, 0x89, 0x25, 
	0x06, 0x1C, 0xDB, 0xE1, 0x02, 0x0F, 0x98, 0x33, 
	0x94, 0x81, 0x83, 0x6B, 0x0C, 0x43, 0x73, 0x5D, 
	0xA3, 0x55, 0x54, 0xF8, 0x0E, 0xCC, 0x94, 0x21, 
	0xE9, 0x81, 0xDD, 0x33, 0x9B, 0x9C, 0xC3, 0x90, 
	0xC7, 0xB5, 0xF0, 0x71, 0xD3, 0xDD, 0xC5, 0x1C, 
	0x39, 0x65, 0x00, 0x85, 0x8F, 0x43, 0x8E, 0xE0, 
	0xDC, 0xBF, 0x00, 0xA4, 0x14, 0x64, 0x3D, 0x7E, 
	0x78, 0xB2, 0x59, 0xE8, 0xA8, 0xAF, 0x72, 0x50, 
	0x76, 0x1F, 0x1F, 0x13, 0x24, 0x8F, 0x79, 0xE3, 
	0xB4, 0x34, 0xAC, 0x21, 0x40, 0xD7, 0xDF, 0x93, 
	0x82, 0x60, 0xF1, 0xF5, 0x59, 0xBA, 0xBA, 0xDA, 
	0x6B, 0x3F, 0xC5, 0x8C, 0x72, 0x2B, 0xCE, 0xC1, 
	0x43, 0x8C, 0x50, 0x04, 0xCC, 0x52, 0x76, 0x5C, 
	0x2C, 0xD8, 0xA0, 0x23, 0x71, 0xBD, 0xEC, 0x6B, 
	0xC9, 0xFF, 0x72, 0x70, 0xC5, 0xFB, 0x65, 0x65, 
	0x89, 0xED, 0x31, 0x31, 0xAB, 0x53, 0xB6, 0x56, 
	0x80, 0x2E, 0x8B, 0xA8, 0xBB, 0x53, 0x66, 0x60, 
	0x9A, 0x54, 0x46, 0x9C, 0xED, 0x4B, 0x6E, 0x5E, 
	0xE5, 0x92, 0xE4, 0x6B, 0x8B, 0x20, 0x14, 0x57, 
	0x0C, 0x2D, 0xE0, 0x2D, 0xBF, 0x2E, 0x8A, 0x2C, 
	0x97, 0xED, 0xC3, 0xCA, 0x2B, 0xEC, 0x9C, 0x19, 
	0x9C, 0xB4, 0xAD, 0x6C, 0x24, 0x38, 0x84, 0xC8, 
	0x55, 0xB4, 0x7D, 0xAD, 0xD8, 0xA3, 0x2C, 0xF2, 
	0x44, 0xF5, 0xE4, 0xD4, 0xE1, 0xA3, 0x81, 0x00, 
	0x59, 0xB3, 0x41, 0x1C, 0x97, 0xD2, 0x9A, 0x2A, 
	0x8D, 0xBC, 0xBA, 0x42, 0xA7, 0xF1, 0xDF, 0x27, 
	0x1B, 0xF6, 0x21, 0x93, 0x18, 0x57, 0xDF, 0x50, 
	0xB7, 0xE1, 0x2F, 0xA5, 0x63, 0x13, 0x7C, 0x40, 
	0xE3, 0x84, 0x14, 0xC4, 0xD2, 0x9A, 0x6D, 0xEF, 
	0x8F, 0x8E, 0xFB, 0x5E, 0x5C, 0x6C, 0x00, 0x79, 
	0x6B, 0xFF, 0xFF, 0x36, 0xC9, 0x3F, 0xFE, 0xF4, 
	0x1F, 0x9B, 0xCA, 0xA6, 0x2A, 0x81, 0xF2, 0x7A, 
	0x75, 0x9E, 0x19, 0x59, 0xD1, 0x4C, 0xB4, 0xC0, 
	0x19, 0x6D, 0x30, 0x63, 0xA9, 0x4D, 0x90, 0xFF, 
	0x95, 0x7B, 0x45, 0x3F, 0x13, 0x38, 0xDD, 0xD3, 
	0xC2, 0x28, 0x01, 0x67, 0x3D, 0x2A, 0x60, 0x7A, 
	0x57, 0x1E, 0xD6, 0xD3, 0x59, 0x75, 0x98, 0x54, 
	0x7F, 0xDD, 0x84, 0x7A, 0x07, 0x66, 0x63, 0xF0, 
	0xA1, 0x2F, 0x13, 0x2F, 0xE5, 0xDF, 0x1C, 0xA1, 
	0x45, 0xBD, 0x57, 0x67, 0xD5, 0xE5, 0x8C, 0xCE, 
	0x3B, 0xB0, 0x1C, 0xD9, 0xD5, 0x34, 0xAB, 0xD3, 
	0x06, 0xAA, 0x42, 0xCA, 0xCF, 0x46, 0x13, 0x72, 
	0x5A, 0x48, 0xE4, 0xF5, 0xED, 0x62, 0xB7, 0xF9, 
	0x61, 0x00, 0x0D, 0x8F, 0xCF, 0x26, 0x28, 0xBD, 
	0x21, 0xF6, 0x09, 0x55, 0x63, 0x11, 0x33, 0x8C, 
	0xAA, 0xF5, 0xBF, 0x0F, 0x1D, 0x32, 0x5E, 0x3E, 
	0xE1, 0xF8, 0x1E, 0xFF, 0xFD, 0xF0, 0x80, 0x6D, 
	0x3C, 0x37, 0x04, 0x81, 0x81, 0x36, 0x5A, 0x3D, 
	0x32, 0x5E, 0x17, 0xD7, 0xE5, 0xB5, 0x05, 0xB7, 
	0xFF, 0xBD, 0x2B, 0xCF, 0x73, 0xD7, 0xB2, 0x37, 
	0x6F, 0x17, 0x74, 0xCC, 0x76, 0xD0, 0xC4, 0x2C, 
	0xFC, 0xEB, 0x70, 0x52, 0x76, 0xE0, 0xB7, 0x5C, 
	0xE0, 0x66, 0xEF, 0x0B, 0x40, 0x53, 0x21, 0x85, 
	0xDC, 0x9B, 0xDA, 0x0B, 0x91, 0xCD, 0xE8, 0x55, 
	0xCB, 0x1B, 0xD1, 0x09, 0x17, 0x62, 0xA1, 0x1F, 
	0x48, 0x04, 0x2B, 0x1F, 0x61, 0x67, 0xE6, 0x11, 
	0x55, 0xCC, 0x1F, 0xC0, 0x80, 0x39, 0xCB, 0xC8, 
	0x6A, 0xAD, 0xE4, 0x41, 0x23, 0xE9, 0x72, 0x16, 
	0x10, 0xBB, 0x6D, 0x4B, 0xAF, 0xFD, 0x17, 0xB7, 
	0x80, 0x0A, 0xF8, 0x27, 0x95, 0x6F, 0xE3, 0x45, 
	0x68, 0x9F, 0xE8, 0x37, 0xA7, 0x9A, 0xD3, 0xCE, 
	0x6E, 0xCC, 0x32, 0x48, 0xB2, 0x8D, 0xF1, 0x32, 
	0x0B, 0x06, 0xC7, 0x7E, 0xFF, 0xB1, 0x87, 0xE2, 
	0x53, 0xF0, 0x1C, 0x4E, 0xDC, 0x57, 0xA6, 0xD9, 
	0xA0, 0x85, 0x82, 0xB6, 0x5F, 0xA6, 0xF4, 0x6B, 
	0x95, 0x11, 0xCF, 0x76, 0x9A, 0x2E, 0x26, 0x67, 
	0x6D, 0x3B, 0xC4, 0x4B, 0x18, 0xE3, 0x91, 0xDD, 
	0xA8, 0x0B, 0xAD, 0x15, 0x3C, 0x2C, 0xD5, 0x1B, 
	0x3F, 0x29, 0x2E, 0x4F, 0xDA, 0x73, 0x67, 0x64, 
	0x9E, 0x13, 0x17, 0xEC, 0x8E, 0xA3, 0xB8, 0x4C, 
	0x1C, 0xF5, 0xAA, 0x96, 0xDD, 0xAD, 0x84, 0x16, 
	0xF8, 0x01, 0xEE, 0xEC, 0xDA, 0x73, 0xA4, 0x78, 
	0x59, 0x1E, 0x01, 0xAC, 0x8F, 0x45, 0x3B, 0x44, 
	0x11, 0xE5, 0x42, 0x40, 0x9F, 0x21, 0xDC, 0xC8, 
	0x20, 0x6F, 0x19, 0xE2, 0x60, 0xE5, 0x11, 0x6F, 
	0x9E, 0x95, 0x92, 0x05, 0x9F, 0x2C, 0x07, 0xDE, 
	0x76, 0xB3, 0x44, 0xF2, 0x88, 0xA4, 0x2C, 0x9E, 
	0xD6, 0xDB, 0xA6, 0xB6, 0xD5, 0x42, 0xE7, 0x35, 
	0x91, 0x1B, 0xF6, 0x38, 0xD4, 0xFF, 0xC9, 0x28, 
	0x32, 0xD6, 0x52, 0x72, 0x26, 0x8B, 0x46, 0xA9, 
	0x72, 0xEB, 0xA6, 0xAA, 0xF3, 0x51, 0x3C, 0xA6, 
	0x14, 0x31, 0x07, 0xD1, 0xA5, 0xF4, 0xD8, 0xB5, 
	0x2E, 0x4E, 0x37, 0x22, 0x3C, 0xA0, 0x75, 0xE2, 
	0xD0, 0x8F, 0x48, 0xCB, 0x78, 0xC8, 0x85, 0x0B, 
	0xF7, 0x75, 0x9A, 0x97, 0x97, 0xA6, 0xF4, 0x9B, 
	0xA7, 0x77, 0x2F, 0x40, 0xEE, 0x05, 0xF5, 0x11, 
	0xFD, 0xA2, 0x19, 0xD1, 0x59, 0xCA, 0x3D, 0x8B, 
	0x40, 0x1A, 0xB2, 0xEB, 0xCB, 0x6C, 0x38, 0x91, 
	0x7D, 0xFB, 0x25, 0xBA, 0xE9, 0x9B, 0x4F, 0x97, 
	0x49, 0x11, 0x17, 0xF9, 0xC7, 0x7B, 0x1C, 0x66, 
	0x59, 0x53, 0xBD, 0x8F, 0x0F, 0x21, 0xB9, 0xB6, 
	0x2F, 0x18, 0x0A, 0x5B, 0x3F, 0xF7, 0x9F, 0x10, 
	0xF8, 0x34, 0x6B, 0xD7, 0x31, 0x07, 0x38, 0x3C, 
	0xDA, 0x3E, 0x87, 0xFC, 0x67, 0x9F, 0xF2, 0x24, 
	0x80, 0xA2, 0x82, 0x33, 0xC0, 0xBD, 0xFF, 0x6E, 
	0x32, 0xA8, 0x1F, 0x09, 0x3F, 0xDC, 0x3A, 0xD9, 
	0x53, 0x44, 0x28, 0xE6, 0xB0, 0xED, 0x61, 0x72, 
	0x16, 0xDF, 0x62, 0x6E, 0xFC, 0xDA, 0x69, 0xC9, 
	0xF3, 0x3E, 0x6A, 0x8A, 0xF3, 0x25, 0xB0, 0xF8, 
	0xC5, 0x66, 0x10, 0x78, 0x67, 0x21, 0xFC, 0x79, 
	0x7F, 0xDD, 0x6F, 0xA6, 0x79, 0xDD, 0xB6, 0x13, 
	0xEC, 0xBC, 0xC7, 0x00, 0x72, 0xEC, 0x43, 0x59, 
	0x6F, 0x64, 0xE9, 0x0D, 0x56, 0xC7, 0x7B, 0x45, 
	0x12, 0x1E, 0x61, 0x0C, 0xB1, 0xDB, 0x29, 0x9F, 
	0xFC, 0x6E, 0x49, 0x02, 0x71, 0x68, 0x87, 0x72, 
	0x7A, 0xF9, 0x2F, 0xBB, 0x29, 0x4D, 0xE0, 0x2C, 
	0x6E, 0x2A, 0x67, 0x0D, 0x62, 0x70, 0x44, 0xE7, 
	0xC3, 0x8D, 0xC4, 0xBD, 0x0F, 0x0B, 0xC5, 0xCF, 
	0x9D, 0x6E, 0x48, 0xEE, 0x44, 0x53, 0x4F, 0xBF, 
	0x3F, 0x3C, 0x10, 0x32, 0xCC, 0x21, 0x60, 0x3E, 
	0x9D, 0x97, 0x0B, 0x30, 0x6F, 0x8C, 0x6A, 0xFF, 
	0x47, 0xDF, 0x76, 0x59, 0x6F, 0x25, 0xEF, 0xB5, 
	0x58, 0xC1, 0x62, 0x4A, 0x28, 0x3A, 0x0A, 0xA6, 
	0x23, 0x57, 0x07, 0xEE, 0xF5, 0x58, 0x08, 0xF9, 
	0x06, 0x53, 0xBF, 0xC7, 0x1B, 0xD7, 0x00, 0x10, 
	0x26, 0xE7, 0x40, 0xDF, 0x36, 0xD2, 0x3B, 0xBA, 
	0xFA, 0xA4, 0x3D, 0xA9, 0x67, 0xF8, 0x07, 0x7D, 
	0x5F, 0x12, 0x8A, 0x85, 0x6B, 0x12, 0x6B, 0x9A, 
	0xF8, 0x66, 0x08, 0x73, 0x8E, 0x5F, 0xE5, 0xFE, 
	0xD2, 0x91, 0x46, 0xB3, 0x14, 0x75, 0x27, 0x02, 
	0xE2, 0x26, 0x66, 0x75, 0x04, 0x1E, 0xCE, 0x51, 
	0x39, 0xA2, 0xC3, 0x25, 0x1E, 0x2A, 0x31, 0xB9, 
	0x15, 0x5C, 0x3A, 0x90, 0x3A, 0x4B, 0x6A, 0x93, 
	0xFA, 0x44, 0x89, 0x64, 0xCB, 0x54, 0xE2, 0x11, 
	0x74, 0xF1, 0x46, 0x7E, 0x8C, 0x5F, 0x19, 0x49, 
	0x8F, 0x89, 0xB4, 0x83, 0x19, 0x73, 0x22, 0x84, 
	0xBD, 0x2A, 0x9D, 0x53, 0x92, 0xE1, 0xB8, 0xB9, 
	0xFF, 0xC2, 0xEC, 0x76, 0xEF, 0x20, 0x6D, 0x63, 
	0x8F, 0xD1, 0xC4, 0x6B, 0xA0, 0xF3, 0x3E, 0xA7, 
	0x2D, 0x61, 0x7F, 0x04, 0x4E, 0xBC, 0xED, 0x1E, 
	0x51, 0x60, 0xC1, 0xE1, 0xAE, 0x53, 0xB2, 0xD3, 
	0xB0, 0x09, 0x9C, 0x19, 0x91, 0x6F, 0x4B, 0x2F, 
	0x50, 0x7C, 0x72, 0xB3, 0xD8, 0x80, 0x5B, 0xEE, 
	0x95, 0xA4, 0x4D, 0x13, 0x63, 0x02, 0xDB, 0x5E, 
	0xBE, 0x40, 0xDA, 0x4E, 0x7B, 0x4A, 0x95, 0xF3, 
	0x7F, 0x15, 0xA4, 0x98, 0xFC, 0xCC, 0xB6, 0xE9, 
	0x8B, 0xE3, 0x08, 0xF1, 0x77, 0xC0, 0xFB, 0xEC, 
	0x1D, 0x3A, 0x6D, 0x3E, 0x9D, 0x22, 0x53, 0x51, 
	0x24, 0x5D, 0xA1, 0x45, 0xDE, 0x78, 0x55, 0x84, 
	0x49, 0xE3, 0x51, 0xD5, 0xEC, 0xA9, 0x49, 0xBF, 
	0xEE, 0xC5, 0xF9, 0x75, 0xE1, 0xC0, 0xD0, 0x0A, 
	0xCD, 0x9E, 0x21, 0x44, 0xB1, 0x37, 0xAC, 0x19, 
	0x64, 0x48, 0x0D, 0x8B, 0xC5, 0x15, 0x49, 0x24, 
	0xA8, 0xFF, 0xE7, 0xB3, 0x74, 0x47, 0x63, 0x5F, 
	0xBC, 0x82, 0x1D, 0x41, 0xAC, 0x3C, 0x80, 0xB3, 
	0x7E, 0x1C, 0xE4, 0x79, 0x15, 0xD9, 0xC0, 0x49, 
	0x68, 0xB7, 0xB0, 0xEA, 0x19, 0xF1, 0x01, 0xB9, 
	0x21, 0x7A, 0xC4, 0x2B, 0x99, 0x26, 0xCF, 0x00, 
	0x14, 0x88, 0xAB, 0xC1, 0x05, 0x28, 0xB0, 0xD7, 
	0x0A, 0x7B, 0xA4, 0x9F, 0xB4, 0xD7, 0xE0, 0xF8, 
	0x4E, 0xD4, 0x68, 0xF0, 0x5B, 0x6C, 0x7E, 0xD8, 
	0x03, 0x87, 0x09, 0xC6, 0xE5, 0xC8, 0x72, 0x8C, 
	0x1F, 0xDD, 0x94, 0x38, 0xC1, 0x04, 0x93, 0xBA, 
	0x4C, 0xF6, 0x21, 0xE9, 0xCA, 0xFA, 0xA8, 0xE0, 
	0x6F, 0x06, 0x54, 0xAB, 0x27, 0x21, 0x7B, 0x22, 
	0x3A, 0xCE, 0xE1, 0xA3, 0xFF, 0xFB, 0x9E, 0x9D, 
	0x22, 0x8D, 0xDD, 0x66, 0xD0, 0xC1, 0x0C, 0x9F, 
	0x51, 0x05, 0x77, 0xEF, 0x1A, 0xF5, 0x46, 0x59, 
	0x1C, 0x2C, 0x8D, 0x87, 0xEB, 0x6C, 0x28, 0xFF, 
	0xF0, 0x69, 0xFF, 0x40, 0x4F, 0xC9, 0xEF, 0x48, 
	0x42, 0x7F, 0x0E, 0x89, 0xE4, 0x3F, 0xED, 0x42, 
	0xE8, 0x42, 0x9F, 0xEC, 0x88, 0xC2, 0x72, 0xDB, 
	0x71, 0xC0, 0xC6, 0x20, 0x91, 0x3C, 0x1E, 0xBF, 
	0x51, 0x43, 0xAE, 0xBE, 0x1C, 0x13, 0x26, 0x15, 
	0x4E, 0x6F, 0x1B, 0xF7, 0xCD, 0x49, 0xE3, 0x1E, 
	0x4B, 0x62, 0xFF, 0x24, 0x54, 0xB5, 0xFF, 0xB5, 
	0x78, 0xDB, 0xC7, 0xD7, 0x0F, 0x79, 0xE4, 0x09, 
	0x1B, 0x7D, 0x6E, 0x68, 0xE8, 0x53, 0x79, 0x20, 
	0x13, 0x42, 0x43, 0x23, 0xD3, 0x76, 0x48, 0xE7, 
	0xEF, 0xB3, 0x02, 0x26, 0x02, 0x91, 0xA0, 0x2E, 
	0x81, 0x10, 0xC8, 0x9F, 0x3B, 0x58, 0xAE, 0x87, 
	0x7C, 0xCC, 0x1A, 0x20, 0x9F, 0x6A, 0x32, 0x02, 
	0x96, 0x34, 0xFD, 0x59, 0xC9, 0xE7, 0x63, 0x39, 
	0xEB, 0x8D, 0xA9, 0xBF, 0x19, 0xE6, 0x3C, 0x1D, 
	0x95, 0x76, 0x5D, 0xB0, 0xB2, 0x64, 0x08, 0x51, 
	0x15, 0xBF, 0xEF, 0xFF, 0x97, 0x76, 0x98, 0xC5, 
	0x41, 0x34, 0x5B, 0x09, 0xEE, 0x42, 0xC8, 0x95, 
	0x4C, 0xCB, 0x4B, 0xE4, 0xFD, 0x16, 0x21, 0x0E, 
	0x3B, 0x58, 0x82, 0xCB, 0x58, 0x9A, 0xEA, 0x70, 
	0x5D, 0x14, 0x1E, 0xF2, 0xDC, 0xFF, 0x2F, 0xCB, 
	0x21, 0xA8, 0x79, 0x79, 0xEE, 0x77, 0xCA, 0x78, 
	0x0A, 0x9A, 0x54, 0x67, 0xBF, 0x7A, 0x40, 0x89, 
	0x77, 0x20, 0x3A, 0xDC, 0x47, 0xCE, 0xC1, 0x16, 
	0x8D, 0x80, 0x28, 0xB8, 0xC3, 0xF0, 0xE0, 0xEC, 
	0x9D, 0x09, 0x5F, 0xB5, 0x65, 0xCE, 0x84, 0x20, 
	0xA8, 0x1C, 0xCF, 0xCE, 0x2D, 0xB2, 0xEE, 0xFA, 
	0xD3, 0x05, 0x00, 0xD1, 0xEC, 0xF7, 0xAC, 0x7F, 
	0x7D, 0x80, 0x6B, 0x1C, 0x4D, 0xDA, 0x40, 0x4E, 
	0xE6, 0x95, 0xC9, 0x06, 0x0F, 0x5C, 0x69, 0xEE, 
	0x6E, 0xF9, 0x38, 0x96, 0x0F, 0x88, 0x1C, 0xE8, 
	0x75, 0xEA, 0x0E, 0x80, 0x43, 0xB5, 0x54, 0x94, 
	0x9A, 0x8C, 0x3E, 0x15, 0xFF, 0x44, 0x1A, 0x56, 
	0x3A, 0x7B, 0x57, 0x35, 0x09, 0x15, 0xAA, 0x83, 
	0x76, 0x79, 0xDF, 0xE7, 0xB3, 0x15, 0xF9, 0x57, 
	0x8C, 0x07, 0x9A, 0xBE, 0x6D, 0x25, 0x92, 0x58, 
	0x17, 0x7E, 0x08, 0x6E, 0xFB, 0xF0, 0x5F, 0xBC, 
	0x31, 0xBE, 0x9A, 0x62, 0x46, 0x64, 0xFE, 0x76, 
	0x38, 0x22, 0xF5, 0x0F, 0x12, 0x10, 0xC9, 0x2C, 
	0x1B, 0x55, 0x82, 0x85, 0x52, 0x8C, 0x38, 0xDC, 
	0xDB, 0x6B, 0x8B, 0x83, 0xFD, 0xC6, 0xD5, 0xC9, 
	0x40, 0x61, 0xCA, 0x78, 0x30, 0x21, 0xD3, 0xB6, 
	0x6D, 0xDD, 0xD9, 0x63, 0xF0, 0x6A, 0x57, 0x7B, 
	0x85, 0xCE, 0x05, 0x1D, 0x82, 0x4D, 0xDC, 0x9C, 
	0x6A, 0xD9, 0x23, 0x3B, 0x80, 0x8C, 0x92, 0x39, 
	0xA9, 0x5E, 0x83, 0x1C, 0x6B, 0x38, 0x89, 0xE1, 
	0xE6, 0x44, 0xC6, 0xB0, 0x20, 0xE1, 0xFD, 0xF7, 
	0xE7, 0x16, 0xFF, 0x32, 0x98, 0xB7, 0x6D, 0x7B, 
	0x89, 0x30, 0x0D, 0x7B, 0xE4, 0xFF, 0xAE, 0xAF, 
	0x58, 0xAB, 0xB2, 0x84, 0x80, 0x1C, 0x56, 0x35, 
	0xDF, 0xAF, 0x39, 0xD8, 0xB2, 0xEF, 0x69, 0xA2, 
	0xB3, 0x54, 0x00, 0x38, 0x64, 0x6D, 0xC9, 0x35, 
	0x27, 0xEA, 0x81, 0x8A, 0x57, 0xF3, 0x90, 0xE7, 
	0x3D, 0x79, 0x78, 0x18, 0xDA, 0x26, 0x1D, 0x5F, 
	0x0A, 0x4F, 0x24, 0xC0, 0x5A, 0xC3, 0x4B, 0xAD, 
	0x5D, 0xBB, 0xB0, 0x83, 0xB4, 0x5E, 0xB8, 0xEB, 
	0x50, 0xA8, 0x85, 0x53, 0x7B, 0x56, 0x8C, 0x07, 
	0xEA, 0x1C, 0x77, 0x4A, 0x2B, 0xFA, 0x8A, 0x8C, 
	0xB7, 0x17, 0x34, 0xA0, 0x8A, 0x94, 0xCB, 0x98, 
	0xE0, 0xCA, 0x26, 0xEA, 0xDF, 0x5D, 0x85, 0x0F, 
	0x29, 0x3E, 0xCB, 0xAF, 0xE0, 0x33, 0xD2, 0x43, 
	0x5F, 0x50, 0xA5, 0x90, 0x45, 0x19, 0x82, 0x41, 
	0xF4, 0xD0, 0x8F, 0x2F, 0x04, 0x45, 0x5F, 0xF8, 
	0xBB, 0x51, 0x15, 0xE2, 0xA1, 0x4E, 0xB7, 0x0A, 
	0xA2, 0xE4, 0x0F, 0x07, 0x71, 0x6B, 0xFF, 0x65, 
	0x8D, 0xF7, 0xC3, 0x40, 0x83, 0xE4, 0x10, 0xE0, 
	0x00, 0x2A, 0xBB, 0xDD, 0x34, 0xF3, 0x78, 0x8D, 
	0x83, 0xC2, 0x9B, 0xE5, 0xBC, 0xF5, 0x56, 0xAC, 
	0xD4, 0xD0, 0x5A, 0x5B, 0xF2, 0x38, 0x3E, 0xBD, 
	0x32, 0x75, 0x6B, 0x8E, 0x33, 0x94, 0x25, 0x18, 
	0xF7, 0x6A, 0x03, 0x63, 0x11, 0x0A, 0x82, 0x6A, 
	0x38, 0x30, 0x52, 0x70, 0x18, 0x1C, 0x27, 0x77, 
	0x48, 0xC6, 0x26, 0x47, 0xC5, 0xED, 0x46, 0xE0, 
	0x6B, 0x6B, 0xE3, 0xDF, 0x55, 0x45, 0x14, 0xAE, 
	0x2D, 0x84, 0x34, 0xD3, 0x34, 0x35, 0x72, 0x79, 
	0xF1, 0x2E, 0x34, 0x48, 0x4C, 0x6F, 0x20, 0x95, 
	0x2F, 0x5D, 0xB2, 0xF5, 0x8B, 0x73, 0xA3, 0x90, 
	0x26, 0x3E, 0x5C, 0x7E, 0x25, 0x9D, 0xCC, 0x04, 
	0x05, 0x0D, 0xA1, 0xF8, 0x4D, 0xCC, 0xB2, 0x0C, 
	0x43, 0xF6, 0xAF, 0x71, 0x33, 0x8B, 0xF3, 0x03, 
	0x64, 0x1F, 0x29, 0xA7, 0x4C, 0x4B, 0xF8, 0xFF, 
	0x23, 0xBD, 0xA5, 0x5E, 0x15, 0x05, 0x4E, 0x24, 
	0x66, 0xC0, 0xDB, 0x5E, 0xBB, 0x2F, 0xDE, 0x53, 
	0x37, 0xDE, 0x8E, 0xF7, 0xD5, 0xFA, 0xF3, 0x1E, 
	0x77, 0xF1, 0x29, 0x27, 0x72, 0x68, 0x1C, 0xBE, 
	0xE2, 0x7A, 0xE2, 0xA5, 0x6A, 0x4E, 0xDE, 0x0D, 
	0xE1, 0x35, 0xBA, 0x2A, 0x03, 0x3D, 0x02, 0xC0, 
	0x19, 0x6C, 0x4A, 0x7F, 0xC8, 0x7A, 0x9F, 0xEC, 
	0xC0, 0x59, 0xD2, 0xB9, 0x86, 0xAE, 0xBF, 0xD4, 
	0xAD, 0x1F, 0xDC, 0xBC, 0x05, 0xF0, 0x0B, 0x61, 
	0xA5, 0xA8, 0x93, 0xA8, 0xCC, 0xBE, 0x2C, 0xEC, 
	0xDB, 0xA6, 0x81, 0xC9, 0xC7, 0xC3, 0x08, 0x35, 
	0x74, 0xD4, 0xDE, 0xF5, 0x71, 0x86, 0xA1, 0x5A, 
	0x4C, 0x7C, 0xC4, 0x47, 0x5D, 0x22, 0x5E, 0xFB, 
	0xE1, 0x50, 0xAC, 0x3E, 0x6A, 0x8E, 0x24, 0xD4, 
	0x88, 0xD8, 0xC1, 0x51, 0x1B, 0xC9, 0xB3, 0x52, 
	0xAD, 0x24, 0x83, 0xC1, 0xE8, 0x1B, 0x03, 0xC1, 

	/* Database Page 16 */

	0xFF, 0xB6, 0x27, 0x92, 0x1F, 0x9F, 0x7A, 0xDF, 
	0x5B, 0xEB, 0x8F, 0x5D, 0xDD, 0x42, 0x0D, 0x97, 
	0xB6, 0xEF, 0xB0, 0x27, 0x03, 0xC0, 0xF9, 0x85, 
	0x14, 0x4D, 0x51, 0xF4, 0x07, 0x37, 0x23, 0x95, 
	0x6B, 0x20, 0x01, 0x49, 0xFD, 0x1C, 0xD3, 0x00, 
	0x56, 0x0F, 0xE7, 0x47, 0x3C, 0xC6, 0x4A, 0x06, 
	0x8B, 0xB9, 0x18, 0x03, 0x42, 0x69, 0xFD, 0x80, 
	0xB8, 0xE1, 0x29, 0x01, 0x75, 0x67, 0x64, 0xD8, 
	0xA4, 0x61, 0x34, 0xDA, 0x1D, 0xD0, 0xAC, 0xC5, 
	0xD0, 0xCB, 0xE4, 0xC5, 0x04, 0x45, 0x3A, 0xB2, 
	0x1A, 0x45, 0xFC, 0xD8, 0x38, 0xF5, 0x3E, 0xD9, 
	0xEB, 0x72, 0x0B, 0xF0, 0x3F, 0xB5, 0xC2, 0x9B, 
	0x39, 0x5E, 0xDF, 0xC0, 0xFC, 0x32, 0x0A, 0x26, 
	0xA8, 0x15, 0x04, 0xE2, 0x19, 0x73, 0xEA, 0x24, 
	0xAC, 0xAB, 0xD8, 0x1F, 0x06, 0x7B, 0xAE, 0x28, 
	0x39, 0x08, 0xEC, 0x14, 0x9A, 0xC9, 0xF1, 0xBD, 
	0x3C, 0xFF, 0x42, 0x18, 0x67, 0x54, 0xE3, 0x69, 
	0x1B, 0x93, 0x67, 0xB3, 0xB3, 0xCF, 0x78, 0x5C, 
	0x97, 0xC5, 0xCD, 0xBB, 0x7C, 0xFC, 0xD8, 0xF6, 
	0xB2, 0x2C, 0xC6, 0x42, 0x61, 0x46, 0x53, 0x1B, 
	0x02, 0xC6, 0xFE, 0x38, 0xD8, 0x9D, 0x69, 0x1A, 
	0x1D, 0x70, 0xDA, 0xB1, 0x72, 0xCF, 0xB6, 0x52, 
	0xE0, 0x22, 0xB3, 0x1E, 0xCD, 0x7D, 0x96, 0x35, 
	0x05, 0x62, 0x35, 0x57, 0xC0, 0xF2, 0x30, 0x8C, 
	0x23, 0xBA, 0xE0, 0xBC, 0x4E, 0x01, 0x4C, 0x16, 
	0xF7, 0x1C, 0xEB, 0x4C, 0xCF, 0x72, 0x90, 0x30, 
	0x77, 0xF1, 0x45, 0xF0, 0x87, 0xA8, 0xFD, 0x6D, 
	0xE0, 0x1B, 0x6F, 0x67, 0xE1, 0x7F, 0xD7, 0x09, 
	0x92, 0x37, 0x65, 0x25, 0xCB, 0xE9, 0x87, 0xDB, 
	0x7C, 0x4A, 0x2E, 0xB7, 0x9A, 0xC6, 0x83, 0x5F, 
	0x79, 0xAC, 0x6A, 0xD5, 0x6F, 0x13, 0x0E, 0x8D, 
	0x3E, 0x99, 0xA1, 0x83, 0x49, 0xE1, 0xE9, 0x09, 
	0x0F, 0xFA, 0xFF, 0x58, 0x5C, 0xAE, 0x57, 0x92, 
	0x0C, 0x1F, 0x17, 0x71, 0x6D, 0x60, 0xE9, 0x20, 
	0x47, 0x2D, 0x8E, 0x93, 0xB1, 0x1A, 0xD6, 0x99, 
	0x7F, 0x1E, 0x3E, 0x1A, 0x95, 0x14, 0xD6, 0xF8, 
	0x9D, 0x4A, 0xB4, 0xD2, 0x95, 0xDB, 0x31, 0x86, 
	0x40, 0x78, 0x28, 0x9D, 0x9F, 0x9B, 0x97, 0x45, 
	0x79, 0x8C, 0x0E, 0xD1, 0x92, 0x9D, 0xC0, 0x8A, 
	0xF0, 0xD4, 0xBE, 0x96, 0xB0, 0x53, 0x73, 0xB2, 
	0x7D, 0x40, 0x05, 0xC3, 0x15, 0xDA, 0xA3, 0xEF, 
	0xA1, 0xC3, 0x9F, 0x4E, 0x5D, 0x14, 0x29, 0x56, 
	0x9C, 0xF8, 0x0F, 0x36, 0x4C, 0xBF, 0x25, 0x4F, 
	0x55, 0xE8, 0xC2, 0xA8, 0x9B, 0x48, 0xB6, 0x0F, 
	0xB6, 0x25, 0x37, 0x51, 0x8B, 0x45, 0x34, 0x63, 
	0xC8, 0xEF, 0xA8, 0x55, 0x9B, 0xF1, 0x80, 0xD5, 
	0xF6, 0x7E, 0x62, 0xDB, 0x80, 0xFA, 0x76, 0x52, 
	0xDA, 0xDE, 0x9E, 0xA7, 0x70, 0xED, 0x39, 0x8C, 
	0x57, 0x58, 0xE1, 0x88, 0xA8, 0x27, 0x96, 0xE1, 
	0x05, 0x79, 0x44, 0x9C, 0xE3, 0x01, 0xFF, 0xE0, 
	0xEC, 0xCD, 0xF4, 0xE2, 0xC1, 0x34, 0xFF, 0x38, 
	0xC9, 0x18, 0x64, 0x24, 0xE2, 0x73, 0x47, 0x98, 
	0x19, 0x30, 0xE4, 0xCE, 0xCE, 0x2D, 0xF7, 0x35, 
	0xC2, 0xB1, 0x48, 0x87, 0xBF, 0x43, 0xAA, 0x06, 
	0xBB, 0xC3, 0x41, 0x86, 0xE0, 0x60, 0x2F, 0xE9, 
	0x8C, 0x50, 0xC4, 0x3D, 0xEB, 0xF6, 0x25, 0x99, 
	0x89, 0x10, 0xD7, 0xB4, 0xF7, 0x34, 0x28, 0x57, 
	0x3D, 0xE2, 0x64, 0x3C, 0x37, 0x9E, 0x71, 0xCB, 
	0xD3, 0xCB, 0x31, 0x83, 0x4F, 0xBB, 0x25, 0x0E, 
	0xCA, 0x42, 0x71, 0x6B, 0xE7, 0x1B, 0x19, 0x1B, 
	0xD3, 0xD8, 0x21, 0x3A, 0xFB, 0x9A, 0x7E, 0xA4, 
	0x89, 0x85, 0xA3, 0xAF, 0x4B, 0xDD, 0x49, 0xFA, 
	0x90, 0xD3, 0xE3, 0x55, 0x1E, 0xB1, 0x9B, 0x96, 
	0x16, 0xA9, 0xDE, 0x77, 0x7A, 0x25, 0xF9, 0x74, 
	0x03, 0xDD, 0xE4, 0xF2, 0xB6, 0xC7, 0x8A, 0x2F, 
	0xFB, 0xE4, 0xC5, 0x28, 0xF8, 0x8A, 0x5F, 0xFF, 
	0x19, 0x6A, 0xE3, 0x01, 0x76, 0xAA, 0xEF, 0x36, 
	0xE1, 0x55, 0x29, 0xA0, 0x60, 0x35, 0xD1, 0x77, 
	0x6A, 0xBF, 0x4B, 0x5F, 0xC9, 0x27, 0x31, 0xB5, 
	0x71, 0x11, 0x43, 0x2C, 0x6E, 0x1B, 0x18, 0x8A, 
	0x77, 0xC4, 0x43, 0xA0, 0x25, 0xB5, 0x99, 0x0F, 
	0xAC, 0x76, 0x7A, 0x3A, 0x38, 0x40, 0xDA, 0xE0, 
	0x65, 0xC2, 0xED, 0xA7, 0x8E, 0x93, 0xE0, 0xA4, 
	0xB1, 0x72, 0xE3, 0x1C, 0xBD, 0xB1, 0x79, 0x05, 
	0x3D, 0xEE, 0x08, 0xE9, 0x65, 0x2B, 0x84, 0x65, 
	0x7B, 0xBD, 0xA6, 0x0F, 0x4F, 0xAC, 0xB5, 0xFA, 
	0xDD, 0xFC, 0xC5, 0x39, 0xBC, 0x99, 0x57, 0xC8, 
	0x32, 0x49, 0x50, 0xCC, 0xD3, 0x85, 0x25, 0x70, 
	0x8E, 0xE0, 0x94, 0x73, 0xFD, 0x71, 0xFA, 0x66, 
	0x78, 0xC0, 0xB4, 0x6E, 0x04, 0x53, 0x33, 0x1A, 
	0x84, 0x7C, 0x02, 0x7D, 0xFB, 0x02, 0xE1, 0x04, 
	0xB9, 0xD8, 0x08, 0xD4, 0x3C, 0x22, 0xAE, 0x3A, 
	0xFF, 0x80, 0x7F, 0xE0, 0x34, 0x5C, 0x74, 0x2F, 
	0x55, 0x5F, 0xD7, 0x18, 0x50, 0xE3, 0x3F, 0x69, 
	0xC1, 0x1D, 0x86, 0x56, 0x51, 0x27, 0x16, 0x84, 
	0x7A, 0xF5, 0x1A, 0x8F, 0x7E, 0xE6, 0x0F, 0x80, 
	0xE5, 0x07, 0x0A, 0x81, 0x9E, 0xF4, 0x52, 0x3B, 
	0x94, 0x12, 0x55, 0x41, 0xFA, 0xBF, 0x20, 0x3A, 
	0x13, 0x8C, 0x61, 0xA0, 0xBC, 0xBE, 0x09, 0x5E, 
	0x27, 0x8F, 0x01, 0xB3, 0x9E, 0x7E, 0x78, 0xA1, 
	0xDC, 0xE3, 0x8C, 0x89, 0x8F, 0x18, 0x3C, 0xFF, 
	0xB3, 0x28, 0xB0, 0xD0, 0xAB, 0x4B, 0xCF, 0xD9, 
	0xDA, 0x5B, 0xEE, 0xB1, 0x57, 0xC3, 0xCF, 0xF8, 
	0x27, 0xA0, 0x62, 0xF3, 0xFB, 0xAC, 0xFE, 0x1F, 
	0x33, 0x1B, 0x0F, 0x9E, 0x70, 0x25, 0xCB, 0x5F, 
	0x35, 0x7B, 0x46, 0x34, 0x16, 0x45, 0xD8, 0x31, 
	0x6C, 0x9E, 0x0A, 0x1D, 0x5D, 0xA2, 0x8C, 0x74, 
	0x27, 0xC8, 0x24, 0x84, 0xF6, 0xF7, 0x99, 0x67, 
	0x8A, 0xFF, 0xB9, 0x02, 0xBE, 0x88, 0xD5, 0xCE, 
	0x7A, 0xBF, 0x79, 0x5D, 0xB2, 0x5C, 0x8F, 0xA9, 
	0x20, 0xF4, 0x16, 0x81, 0x1E, 0xFA, 0x51, 0x73, 
	0xEE, 0x83, 0x34, 0x80, 0x4E, 0x16, 0x93, 0xDE, 
	0xFD, 0xDA, 0x35, 0x49, 0x55, 0x4D, 0x30, 0x1B, 
	0xB5, 0x6E, 0xCD, 0x3C, 0xD4, 0x8F, 0x27, 0xB8, 
	0xFE, 0x05, 0x40, 0xB5, 0xB5, 0x3E, 0xC3, 0xF4, 
	0x21, 0x49, 0x07, 0x4F, 0x93, 0x0C, 0x6F, 0x31, 
	0x57, 0xBC, 0x4C, 0x02, 0x9C, 0xF7, 0x5A, 0xAC, 
	0xD8, 0x0B, 0xF8, 0xE1, 0xD2, 0xAA, 0x61, 0x84, 
	0x0D, 0x29, 0xA6, 0x83, 0x7B, 0x15, 0x02, 0xE4, 
	0xAD, 0x8C, 0x80, 0xFA, 0xF0, 0xDA, 0x8F, 0x00, 
	0x43, 0x86, 0x37, 0x37, 0x53, 0xAE, 0x62, 0x68, 
	0xB5, 0x64, 0x39, 0xDC, 0x2F, 0x9F, 0xD7, 0xDD, 
	0x97, 0xF6, 0x1D, 0x3F, 0xB9, 0x7D, 0xF7, 0xF4, 
	0xC9, 0x31, 0xEA, 0x85, 0x56, 0x9F, 0x2E, 0x6D, 
	0x29, 0xB1, 0xFF, 0xB1, 0x42, 0x6A, 0x71, 0xBA, 
	0x14, 0x8B, 0x58, 0x4A, 0x2D, 0x91, 0x6D, 0xAE, 
	0xD1, 0xED, 0x9B, 0x64, 0x5F, 0x43, 0x3D, 0x69, 
	0xC1, 0x89, 0xE5, 0xCA, 0x29, 0x93, 0x5B, 0x60, 
	0x3D, 0x79, 0xE7, 0x10, 0x94, 0x41, 0x2B, 0x3F, 
	0x26, 0xB3, 0x0E, 0xBB, 0x9D, 0x9C, 0xB5, 0xAF, 
	0x22, 0x62, 0xAA, 0x16, 0x80, 0xD8, 0x49, 0x15, 
	0xA9, 0x63, 0x07, 0x3C, 0x7C, 0xBB, 0xCA, 0x13, 
	0x41, 0x1C, 0x46, 0xFE, 0x90, 0xF0, 0x28, 0x4B, 
	0x9E, 0x8D, 0xDB, 0xF7, 0x7E, 0xC0, 0x71, 0x43, 
	0xD9, 0x44, 0x5A, 0x4D, 0x0C, 0x48, 0x9B, 0x02, 
	0xF5, 0x7D, 0x99, 0xC7, 0x65, 0x26, 0xF7, 0xE2, 
	0x6D, 0xE7, 0x90, 0xEC, 0xE0, 0xCD, 0x68, 0x5F, 
	0xD0, 0x22, 0x19, 0x78, 0x1C, 0x88, 0xDA, 0xBB, 
	0xDD, 0xD2, 0x86, 0xF7, 0x76, 0x58, 0x2C, 0x3C, 
	0x45, 0xBB, 0x46, 0x32, 0x1C, 0x85, 0x66, 0x8A, 
	0x99, 0x8B, 0x3A, 0xFF, 0xF7, 0x33, 0xC3, 0x18, 
	0xAD, 0xEB, 0x77, 0xFF, 0x3E, 0x66, 0x64, 0xBE, 
	0x84, 0x96, 0x68, 0xD5, 0x66, 0xD4, 0xA9, 0xA7, 
	0x69, 0x87, 0xCD, 0xBD, 0x3C, 0x82, 0x2E, 0x76, 
	0xA0, 0xB1, 0x4B, 0x8A, 0x3C, 0x75, 0x9C, 0xA7, 
	0x36, 0xAE, 0x66, 0x28, 0x91, 0xCF, 0x88, 0x56, 
	0xED, 0x32, 0xC0, 0x59, 0xE5, 0x9B, 0xBB, 0x72, 
	0xB6, 0x7D, 0x74, 0x6E, 0x12, 0x72, 0x36, 0x3B, 
	0xFC, 0x18, 0xCD, 0x20, 0x57, 0xD1, 0xF7, 0x45, 
	0x2F, 0x9D, 0x05, 0x15, 0x45, 0xB7, 0x01, 0x9B, 
	0xE3, 0x1A, 0x09, 0x18, 0x6B, 0x81, 0x33, 0x30, 
	0x7C, 0x14, 0xAD, 0xD5, 0x63, 0x53, 0x1E, 0xBB, 
	0x3E, 0xB5, 0xF4, 0x2D, 0x04, 0x81, 0x0E, 0x94, 
	0x67, 0x13, 0x2D, 0x2F, 0xCC, 0xE6, 0x47, 0x02, 
	0x09, 0xB7, 0xDB, 0xDC, 0x34, 0x33, 0x49, 0x70, 
	0xD5, 0x4A, 0x9C, 0x34, 0xBC, 0xE5, 0x83, 0x72, 
	0xF1, 0xBC, 0xFB, 0xAD, 0xFF, 0xAD, 0xE9, 0xA5, 
	0xC3, 0xC7, 0x79, 0x9C, 0x62, 0xF3, 0x81, 0x6A, 
	0xDF, 0xA1, 0x58, 0x06, 0x9B, 0x07, 0xDC, 0x47, 
	0x31, 0x48, 0x48, 0x71, 0x1D, 0x85, 0x76, 0x7D, 
	0x67, 0x56, 0x7D, 0x11, 0xBA, 0xC8, 0x75, 0x55, 
	0xE4, 0x3F, 0xBC, 0x1D, 0xD5, 0xB2, 0x1A, 0xC4, 
	0x38, 0x87, 0xE7, 0xEC, 0x74, 0xF3, 0x3C, 0xDB, 
	0x5A, 0x99, 0x09, 0x28, 0x87, 0x9C, 0xA2, 0xDA, 
	0x4E, 0x3F, 0xFF, 0xE8, 0x52, 0x92, 0x10, 0x42, 
	0x46, 0x84, 0x6D, 0xF6, 0x2D, 0x65, 0x8A, 0xF6, 
	0xA6, 0xC8, 0x97, 0x23, 0x7B, 0x04, 0x77, 0x89, 
	0x5F, 0xB0, 0x26, 0xC2, 0x49, 0x8E, 0xEA, 0xFF, 
	0x9F, 0x09, 0x51, 0xAE, 0xF9, 0x42, 0x4A, 0x6B, 
	0x93, 0x9A, 0x59, 0x03, 0xF2, 0xE9, 0x7D, 0xD9, 
	0x24, 0x1E, 0x5B, 0xB5, 0x52, 0x35, 0x2D, 0xA5, 
	0x6E, 0x01, 0x7B, 0xC4, 0xE5, 0xDE, 0x52, 0xED, 
	0xAB, 0x9D, 0xC7, 0x29, 0xE0, 0xFF, 0x69, 0xD6, 
	0x65, 0x8A, 0x03, 0x28, 0x11, 0x8F, 0x01, 0xA3, 
	0xCE, 0x93, 0x02, 0x0E, 0x54, 0x5D, 0xA3, 0xBC, 
	0xF4, 0x63, 0xE1, 0xEA, 0x75, 0x7D, 0x17, 0x67, 
	0x75, 0xB9, 0x3D, 0x83, 0xAF, 0x6E, 0x24, 0x5A, 
	0x6A, 0x90, 0xB1, 0x07, 0xBC, 0xAE, 0x2A, 0x78, 
	0x84, 0x60, 0xB2, 0xCB, 0xC2, 0xED, 0xD3, 0xE0, 
	0x3E, 0xF7, 0x7B, 0x71, 0x9F, 0xF7, 0xDA, 0x83, 
	0x2C, 0x4B, 0x33, 0xDA, 0x28, 0xF0, 0x0E, 0xFD, 
	0xF6, 0x6E, 0x87, 0x34, 0x01, 0x7F, 0x44, 0xE6, 
	0xA7, 0x63, 0x1B, 0x51, 0x55, 0xF7, 0x99, 0x03, 
	0x23, 0xFF, 0x56, 0xA5, 0xBD, 0x36, 0x29, 0x16, 
	0x57, 0x0A, 0xF6, 0x28, 0xBC, 0x88, 0x83, 0x41, 
	0x8F, 0xDD, 0x7C, 0x77, 0x42, 0x22, 0xDB, 0xC0, 
	0xF0, 0x31, 0x64, 0x2A, 0xA4, 0xFA, 0x4D, 0x50, 
	0x66, 0x0F, 0x83, 0x67, 0x16, 0x89, 0x30, 0x37, 
	0x39, 0x27, 0x41, 0x78, 0x43, 0x08, 0xFF, 0xA5, 
	0x91, 0x14, 0xFC, 0xF6, 0x7C, 0x58, 0xB5, 0x05, 
	0xB7, 0x1F, 0x67, 0x3F, 0xEE, 0x85, 0x9D, 0xDE, 
	0xE4, 0xC8, 0x77, 0xA0, 0x2C, 0x31, 0xD2, 0x20, 
	0xDF, 0x9F, 0x49, 0xC3, 0xF5, 0xF4, 0x80, 0x55, 
	0xFF, 0x51, 0x90, 0x65, 0x4A, 0xE6, 0xED, 0x74, 
	0xFB, 0xF0, 0x44, 0x72, 0x3F, 0x33, 0xF2, 0x16, 
	0x09, 0x6A, 0x27, 0x2D, 0xAD, 0xBC, 0x8A, 0x2F, 
	0x7D, 0xBC, 0xCD, 0x79, 0x6A, 0xEF, 0xF7, 0x4E, 
	0x5A, 0x1A, 0xD5, 0x27, 0x90, 0x71, 0xE6, 0x59, 
	0x3B, 0x88, 0xF3, 0x90, 0xB5, 0xDE, 0x87, 0xF3, 
	0x18, 0xDE, 0xD8, 0x3C, 0xF5, 0x60, 0x58, 0x60, 
	0xE7, 0x3A, 0xD2, 0x23, 0xE7, 0xB8, 0xA4, 0x7B, 
	0x2C, 0x94, 0x4E, 0xAA, 0x27, 0x9C, 0xF5, 0xF0, 
	0x22, 0xD4, 0xF7, 0x49, 0x03, 0x70, 0xD5, 0xDD, 
	0xD7, 0x72, 0x80, 0x2D, 0x09, 0xA3, 0x0C, 0x5D, 
	0xAA, 0xC8, 0xDE, 0xE5, 0x43, 0xCE, 0x56, 0xFF, 
	0x63, 0x69, 0x26, 0x0A, 0xE2, 0x46, 0x3B, 0x8F, 
	0x4C, 0xB5, 0xA4, 0xCE, 0x10, 0x08, 0x55, 0x71, 
	0x6E, 0xB3, 0x24, 0x5E, 0xD1, 0xC7, 0xE7, 0xA5, 
	0x52, 0x0D, 0x17, 0x8C, 0xAB, 0xA5, 0x20, 0x8A, 
	0x13, 0x28, 0x25, 0x50, 0x21, 0x88, 0x7A, 0x62, 
	0xE4, 0xAA, 0x11, 0xF4, 0x60, 0xDA, 0x78, 0xD3, 
	0x48, 0xD2, 0xF6, 0xBB, 0xAA, 0xB6, 0xB7, 0x92, 
	0xE9, 0xDC, 0x09, 0xB0, 0x1B, 0x63, 0x14, 0x0A, 
	0xA1, 0xDB, 0x45, 0x06, 0x85, 0x80, 0x47, 0x4A, 
	0xFE, 0x42, 0x08, 0xDE, 0xD7, 0x11, 0x2A, 0xAA, 
	0xAB, 0x52, 0x68, 0xC7, 0xFC, 0x61, 0xFB, 0x99, 
	0xEC, 0x8C, 0xD4, 0x97, 0xBA, 0x30, 0x62, 0xDE, 
	0x7C, 0x65, 0x91, 0x46, 0x14, 0x50, 0xFA, 0xDD, 
	0x3E, 0xAF, 0xBE, 0x17, 0x8E, 0x96, 0x0B, 0x59, 
	0xC2, 0xA6, 0xAD, 0xB0, 0x11, 0x1C, 0x36, 0xAB, 
	0xBB, 0x1C, 0x6A, 0x09, 0xC3, 0xAE, 0x9C, 0x77, 
	0xFF, 0xDF, 0x8E, 0xEB, 0x47, 0x22, 0x0A, 0x90, 
	0x7F, 0xE4, 0x52, 0xA0, 0xAA, 0x1C, 0x80, 0x07, 
	0xD2, 0x38, 0x60, 0x3D, 0xB0, 0x48, 0xC6, 0x70, 
	0x3C, 0x74, 0xF9, 0x0F, 0xF0, 0x79, 0xE5, 0x56, 
	0x9C, 0x80, 0x10, 0x3D, 0x75, 0xA3, 0x9E, 0xCB, 
	0xFD, 0x1D, 0x46, 0xC8, 0x7E, 0x4D, 0x06, 0x17, 
	0xE5, 0x02, 0x73, 0x75, 0x44, 0x07, 0xE9, 0x92, 
	0xC7, 0xB8, 0xD4, 0x64, 0x55, 0x9F, 0xBF, 0x12, 
	0x1D, 0x22, 0x99, 0x0C, 0xD9, 0x80, 0x0E, 0x79, 
	0x1F, 0xC9, 0x4B, 0xD9, 0x23, 0xF4, 0x37, 0xB6, 
	0x84, 0x35, 0x33, 0xA0, 0x43, 0xBD, 0x9B, 0x78, 
	0xF0, 0xC7, 0x87, 0xE8, 0xE9, 0x36, 0x7C, 0xFC, 
	0xD2, 0x45, 0x10, 0x95, 0x9A, 0x53, 0x9A, 0x16, 
	0xB8, 0x92, 0xF7, 0x43, 0xE8, 0xAA, 0xD3, 0x9C, 
	0x16, 0x64, 0x9F, 0x42, 0xE8, 0xAD, 0xD4, 0x89, 
	0xD8, 0x44, 0x32, 0x64, 0x9F, 0x7B, 0xAF, 0xEF, 
	0x0A, 0xFF, 0xE3, 0xB9, 0x9B, 0xB8, 0x13, 0x3A, 
	0xDD, 0x97, 0x99, 0xE6, 0x8B, 0x9F, 0x6A, 0xBF, 
	0x2F, 0x78, 0xC9, 0x1F, 0xED, 0x77, 0x14, 0xF4, 
	0xD9, 0xB0, 0x6F, 0xB3, 0x44, 0xFD, 0xAE, 0x7C, 
	0xC7, 0x9A, 0x82, 0x12, 0x14, 0xDF, 0x74, 0x15, 
	0x01, 0x29, 0x6A, 0x1D, 0x00, 0x2D, 0x94, 0x31, 
	0x48, 0x8A, 0x1E, 0x24, 0xC2, 0x2A, 0xC6, 0x5E, 
	0x60, 0x28, 0xBD, 0xB3, 0xF4, 0x02, 0x0E, 0xEC, 
	0xCA, 0xA4, 0x8E, 0x95, 0xC3, 0xCB, 0x9E, 0x57, 
	0x43, 0xED, 0xA4, 0x21, 0xA9, 0xB5, 0x5C, 0x37, 
	0x57, 0x0F, 0x71, 0xC3, 0x76, 0xE6, 0x95, 0xF9, 
	0xD9, 0x99, 0xE2, 0x30, 0x3B, 0x6A, 0xE6, 0x97, 
	0xA5, 0xDD, 0xCD, 0xC8, 0x61, 0x85, 0x1C, 0x97, 
	0x6D, 0x38, 0x02, 0xEC, 0x1A, 0x23, 0x51, 0x72, 
	0x78, 0x69, 0xE4, 0x25, 0x55, 0xD9, 0xA9, 0x98, 
	0xB4, 0x42, 0xE9, 0xBA, 0xB3, 0xEE, 0x44, 0x5D, 
	0xA4, 0xF7, 0xF4, 0x7B, 0x16, 0x94, 0xD9, 0x14, 
	0x29, 0x64, 0x87, 0x24, 0x3C, 0x03, 0x2D, 0xE5, 
	0x4C, 0x96, 0xFE, 0x0B, 0x78, 0x1D, 0x20, 0x98, 
	0xC1, 0x65, 0x40, 0x3A, 0xF6, 0x1F, 0x0F, 0x4A, 
	0x2C, 0xC6, 0x5A, 0x3A, 0x40, 0xB5, 0x58, 0x96, 
	0xA3, 0x3C, 0xC5, 0x21, 0x16, 0x43, 0x64, 0xCA, 
	0x52, 0x38, 0x1D, 0x71, 0x4E, 0x17, 0xC3, 0xC4, 
	0xE9, 0x3B, 0xF0, 0x32, 0xBC, 0x50, 0x63, 0x54, 
	0x21, 0x94, 0x1A, 0x76, 0xD9, 0x45, 0xDB, 0x16, 
	0xCE, 0xEA, 0x2D, 0x82, 0x5E, 0x57, 0x80, 0x12, 
	0xE0, 0x39, 0x0F, 0xF0, 0x20, 0xC5, 0xC8, 0x3F, 
	0xDA, 0xF3, 0x0E, 0x3B, 0x70, 0x9E, 0xED, 0x06, 
	0xB0, 0xAA, 0x7E, 0x3E, 0x0A, 0x11, 0x7B, 0xF5, 
	0x62, 0x34, 0x8D, 0x53, 0xE8, 0x3E, 0x2B, 0x5A, 
	0x0E, 0x14, 0xA7, 0x8C, 0xE5, 0x24, 0xC1, 0xEF, 

	/* Database Page 17 */

	0xFF, 0xAF, 0xB3, 0x81, 0x44, 0xEF, 0xFF, 0xAC, 
	0xC3, 0xCC, 0x11, 0x49, 0xA0, 0x60, 0xC7, 0xDD, 
	0xAD, 0xA7, 0x3B, 0xBA, 0x13, 0x4D, 0x72, 0xBC, 
	0x98, 0xD9, 0x73, 0x24, 0x7A, 0x87, 0xB4, 0x38, 
	0x5F, 0x70, 0x77, 0x0E, 0xE0, 0x65, 0xEB, 0x2D, 
	0x10, 0xFA, 0x47, 0x4A, 0x1D, 0x6A, 0x9D, 0x25, 
	0x25, 0xED, 0x1B, 0xD9, 0x66, 0xB9, 0x7E, 0x60, 
	0x9E, 0xE7, 0x56, 0x3D, 0x0F, 0x09, 0x5E, 0x46, 
	0x65, 0xAA, 0x94, 0x4C, 0x71, 0xD4, 0xA2, 0x9E, 
	0xB1, 0xE9, 0x43, 0x0D, 0x97, 0x13, 0x0F, 0x74, 
	0xE3, 0xC1, 0x07, 0x52, 0xCB, 0xDC, 0x46, 0x37, 
	0x1E, 0x3A, 0xFF, 0xA1, 0x3E, 0x6F, 0x3F, 0x2F, 
	0xD4, 0x20, 0x76, 0x8E, 0x67, 0x9F, 0xA0, 0x60, 
	0x73, 0x6D, 0x43, 0x0E, 0x86, 0x0C, 0x1F, 0x4F, 
	0xAE, 0x85, 0x78, 0xCF, 0x6C, 0xC5, 0x5F, 0x7B, 
	0x08, 0xCF, 0x3E, 0x94, 0xC6, 0x14, 0x27, 0x67, 
	0x54, 0xFF, 0x8B, 0x2F, 0x1C, 0x6D, 0xB4, 0x94, 
	0x3C, 0xEF, 0xB9, 0x27, 0xC2, 0x09, 0x48, 0x04, 
	0x1B, 0x5E, 0xD0, 0x5C, 0x13, 0x4B, 0x59, 0x3C, 
	0xDF, 0x47, 0xBF, 0x26, 0x59, 0x0A, 0x27, 0xE2, 
	0x15, 0xA6, 0xEE, 0x67, 0xCD, 0x9E, 0xD0, 0xA8, 
	0xA8, 0x22, 0xF8, 0x9B, 0xBF, 0x66, 0x26, 0x77, 
	0x61, 0xF6, 0x25, 0x38, 0xA7, 0xB4, 0xBF, 0x8A, 
	0x1D, 0x74, 0xA8, 0x2C, 0xAF, 0x36, 0x33, 0xC9, 
	0xAF, 0x5D, 0xBA, 0x58, 0x03, 0x32, 0x8B, 0x0C, 
	0x86, 0x50, 0x7E, 0x70, 0x1D, 0xFE, 0xB4, 0x81, 
	0x80, 0xE8, 0x18, 0x34, 0x2E, 0x3F, 0xCE, 0x5D, 
	0x96, 0x00, 0x65, 0xA9, 0xF4, 0x29, 0xC0, 0x46, 
	0x44, 0x83, 0xCD, 0xBC, 0xEF, 0x37, 0x50, 0x14, 
	0xD9, 0x54, 0x75, 0xCD, 0xE9, 0xD4, 0xA2, 0x4C, 
	0x1B, 0xE9, 0xBB, 0x03, 0x6C, 0xAA, 0xD9, 0xE3, 
	0xA5, 0x6A, 0xD0, 0x13, 0xBF, 0xDC, 0xDA, 0xAE, 
	0x5C, 0xEE, 0xFF, 0x32, 0x5E, 0x11, 0x61, 0x53, 
	0xCE, 0xFB, 0xEC, 0xE0, 0x28, 0xE4, 0x36, 0x93, 
	0xA3, 0x52, 0x12, 0xAA, 0x31, 0xF7, 0xAD, 0x67, 
	0x31, 0x9F, 0xF8, 0x80, 0xED, 0x8B, 0x24, 0xDD, 
	0x78, 0x4A, 0xB0, 0x45, 0x41, 0x0F, 0x6C, 0x32, 
	0x3B, 0x75, 0xE3, 0xD2, 0x2F, 0xCB, 0x95, 0x40, 
	0x64, 0x42, 0xD1, 0xE4, 0xED, 0x70, 0xAF, 0xAD, 
	0xC8, 0x0F, 0x84, 0x1D, 0xF9, 0xD6, 0x59, 0xA8, 
	0x7F, 0x6F, 0x32, 0xCE, 0x94, 0x62, 0x75, 0xC2, 
	0x14, 0xCD, 0xD2, 0xD5, 0x6C, 0x39, 0x16, 0xB1, 
	0xF8, 0xCC, 0x2D, 0x06, 0x7D, 0xC2, 0x90, 0xDD, 
	0x38, 0xDD, 0x36, 0x59, 0x65, 0x38, 0x19, 0x0E, 
	0x3E, 0xAD, 0xF0, 0x81, 0xC9, 0x8D, 0x9D, 0x35, 
	0x69, 0x9C, 0xE0, 0x36, 0x87, 0x8F, 0x75, 0x5A, 
	0xFC, 0x3F, 0xEA, 0xBE, 0xC5, 0xCE, 0xCF, 0x23, 
	0x2C, 0xBA, 0xE9, 0x48, 0x3E, 0x62, 0x42, 0x79, 
	0x6C, 0x02, 0xE9, 0xFF, 0x29, 0x38, 0x0E, 0x4B, 
	0x7C, 0x24, 0x98, 0x94, 0xD9, 0xD1, 0x75, 0x94, 
	0x6E, 0xD1, 0xF6, 0x16, 0x90, 0xE7, 0xCB, 0x57, 
	0x43, 0x30, 0x15, 0xE9, 0xEA, 0x1B, 0x62, 0x0A, 
	0x0E, 0x17, 0xDC, 0xCC, 0x87, 0xD4, 0x44, 0xED, 
	0xE6, 0x3C, 0x30, 0xC7, 0xA0, 0x94, 0x42, 0x2F, 
	0x2E, 0xA7, 0x40, 0x0F, 0xB9, 0x36, 0x07, 0x6A, 
	0x8C, 0x14, 0x66, 0x43, 0xC8, 0x02, 0xFD, 0x2F, 
	0xFC, 0x33, 0xA3, 0x48, 0x38, 0xA6, 0xE3, 0xB5, 
	0xF8, 0x96, 0xD0, 0x68, 0x74, 0x87, 0xC6, 0xAD, 
	0x47, 0x8D, 0x37, 0xAE, 0x74, 0x25, 0x4D, 0xFD, 
	0x92, 0x3F, 0xB3, 0x49, 0x22, 0xF2, 0x1E, 0x1A, 
	0x70, 0x0D, 0xE5, 0x13, 0xB4, 0x44, 0xBB, 0x57, 
	0x6B, 0x32, 0x5E, 0xDE, 0x5E, 0x50, 0xE9, 0x1B, 
	0xA0, 0xA5, 0x51, 0x94, 0x27, 0x49, 0xB3, 0xAD, 
	0xCC, 0x10, 0xA3, 0x1F, 0x58, 0x74, 0x99, 0x22, 
	0xCB, 0x45, 0x12, 0x54, 0xFF, 0x5A, 0x70, 0x37, 
	0xD5, 0x0E, 0x39, 0x19, 0xC7, 0xC3, 0x4C, 0xFB, 
	0x2C, 0x1F, 0x9D, 0x29, 0xDD, 0xE1, 0xC0, 0xFF, 
	0x4C, 0xAB, 0xEF, 0xA0, 0xD1, 0x73, 0xC1, 0x37, 
	0x32, 0xCA, 0x56, 0x92, 0xE5, 0x3D, 0x81, 0x71, 
	0x50, 0xA2, 0xDF, 0x26, 0x54, 0x23, 0xE4, 0xBD, 
	0xE3, 0x3E, 0x5D, 0x54, 0x36, 0x2E, 0x12, 0x63, 
	0x19, 0x27, 0xBF, 0x1B, 0xAC, 0xA6, 0xE3, 0x28, 
	0x41, 0x0B, 0x6F, 0x5F, 0x9E, 0x10, 0x66, 0x84, 
	0x94, 0x14, 0xC3, 0x48, 0x09, 0x12, 0x29, 0xC0, 
	0x00, 0xCB, 0x97, 0x1A, 0x71, 0x03, 0x12, 0x28, 
	0x51, 0x0E, 0xAC, 0x10, 0x78, 0x7A, 0x56, 0x37, 
	0xE4, 0x2C, 0x6D, 0x6F, 0x7D, 0x81, 0x30, 0x18, 
	0xDC, 0xF1, 0xED, 0x50, 0x77, 0x11, 0x15, 0x62, 
	0x13, 0xEA, 0xB1, 0xE0, 0x60, 0x0D, 0x7D, 0xC5, 
	0x36, 0x49, 0xED, 0x8D, 0xB8, 0xD4, 0x34, 0x24, 
	0xC2, 0x98, 0xE0, 0x0A, 0xB2, 0xFF, 0x98, 0x8F, 
	0x30, 0x66, 0xB0, 0xB5, 0x9B, 0xC6, 0x47, 0xCF, 
	0x66, 0x98, 0x27, 0x9C, 0x55, 0x16, 0xCA, 0xEE, 
	0x08, 0xBC, 0xBE, 0xB8, 0xA0, 0x39, 0xE0, 0x22, 
	0x29, 0x48, 0x77, 0xC4, 0x1B, 0x7B, 0xBA, 0xB6, 
	0xA3, 0x1A, 0xAB, 0x84, 0x6A, 0x88, 0xBE, 0x30, 
	0x60, 0xB4, 0x3C, 0x88, 0x95, 0xC1, 0x98, 0x04, 
	0x45, 0x17, 0x3A, 0xAC, 0x69, 0x2F, 0x3B, 0x9F, 
	0x2D, 0xA8, 0xF6, 0xF4, 0x02, 0x7C, 0x8A, 0x4A, 
	0xDB, 0x36, 0xC9, 0xC2, 0xB3, 0xB6, 0x3D, 0xC4, 
	0xB4, 0xB2, 0xFF, 0x25, 0x93, 0xA4, 0x9A, 0xD9, 
	0x30, 0x03, 0x33, 0x47, 0xF6, 0xD8, 0x09, 0x7B, 
	0x41, 0x84, 0x51, 0xF1, 0x05, 0xA9, 0x70, 0xD0, 
	0x32, 0x14, 0x23, 0x00, 0x23, 0x6C, 0x0B, 0x84, 
	0x26, 0xC9, 0x4D, 0x00, 0x1C, 0x76, 0xC3, 0x4C, 
	0xC3, 0xA9, 0xFC, 0xD7, 0xEC, 0x70, 0xD0, 0xC3, 
	0x58, 0x85, 0xA1, 0xC6, 0x5A, 0x59, 0xFF, 0x4B, 
	0x00, 0xD3, 0x58, 0x34, 0x24, 0xEB, 0x27, 0x33, 
	0x1D, 0x89, 0xD1, 0xBA, 0xEA, 0xC2, 0x35, 0x6E, 
	0xDF, 0x4A, 0x6B, 0x9C, 0x4D, 0x4A, 0x9E, 0xB1, 
	0x72, 0x56, 0x56, 0x38, 0xB3, 0x36, 0x73, 0x6A, 
	0x77, 0x11, 0x64, 0x9F, 0xD4, 0xA1, 0xE3, 0x52, 
	0xDA, 0x01, 0x7D, 0x7F, 0xE4, 0x49, 0xB9, 0xC2, 
	0x8F, 0x0D, 0x9D, 0xC4, 0xF9, 0x6B, 0x4B, 0x51, 
	0x5A, 0x67, 0x42, 0xF8, 0xA3, 0x02, 0x2E, 0x89, 
	0xDD, 0x1C, 0x5F, 0xDA, 0x03, 0x27, 0xA8, 0xD8, 
	0x1F, 0x56, 0xF7, 0x07, 0xD4, 0x89, 0xE7, 0x80, 
	0xD4, 0xD7, 0x93, 0xCA, 0x1F, 0x37, 0xC1, 0x58, 
	0x80, 0x11, 0xA5, 0xEE, 0xDA, 0x3D, 0xDE, 0xF9, 
	0xA1, 0xC0, 0xB7, 0x41, 0x8D, 0x18, 0x93, 0x03, 
	0xE2, 0xBF, 0x20, 0x92, 0xC7, 0x25, 0x32, 0x39, 
	0xCF, 0x6F, 0xC6, 0x0E, 0x5D, 0x01, 0xAC, 0xDB, 
	0xD3, 0x72, 0xE0, 0x5F, 0xEB, 0xBD, 0x86, 0xFF, 
	0x52, 0xBB, 0xA4, 0x72, 0x90, 0x65, 0xC3, 0xEB, 
	0x99, 0xB6, 0x2F, 0xD0, 0x3A, 0x70, 0xEC, 0x2E, 
	0xB2, 0xE9, 0x8E, 0xC3, 0xA1, 0x9E, 0x67, 0x85, 
	0x43, 0x55, 0x37, 0x8F, 0x0F, 0xEE, 0xC8, 0x31, 
	0xA0, 0xD8, 0x54, 0x35, 0x3B, 0x8F, 0xFF, 0xE8, 
	0x78, 0xB4, 0x9D, 0xFD, 0xA2, 0xFF, 0x49, 0x79, 
	0xA5, 0xFB, 0xAE, 0x02, 0x5B, 0x7C, 0xBA, 0x8C, 
	0x3A, 0x16, 0xFB, 0xD3, 0xB0, 0x61, 0x2A, 0x6D, 
	0x29, 0x0A, 0xF1, 0x0D, 0x37, 0x0F, 0x60, 0x11, 
	0xC5, 0x9B, 0xEB, 0x06, 0x27, 0x85, 0xC2, 0x32, 
	0x75, 0xE6, 0xF5, 0x4D, 0x3A, 0xFC, 0xE9, 0xDA, 
	0x01, 0xF4, 0xAB, 0x22, 0xFB, 0xFD, 0xBE, 0x74, 
	0xC8, 0x28, 0x10, 0x20, 0x1C, 0x04, 0xA4, 0x6C, 
	0x3E, 0x5F, 0x81, 0x68, 0x42, 0xCD, 0x07, 0xEC, 
	0xD9, 0x38, 0x17, 0xBF, 0xC9, 0x48, 0x2E, 0xBB, 
	0xF4, 0x7E, 0x60, 0x14, 0x84, 0xB7, 0x04, 0xE5, 
	0xFF, 0xE5, 0xDF, 0xFE, 0x6B, 0xFF, 0xAB, 0xE2, 
	0xA5, 0x06, 0xF3, 0x14, 0x14, 0xA8, 0x66, 0x0B, 
	0xCB, 0x03, 0x8F, 0xE5, 0x7A, 0xC2, 0xC3, 0x1D, 
	0x10, 0xEC, 0x9D, 0x86, 0xC0, 0x66, 0xC7, 0x59, 
	0x18, 0x67, 0xA6, 0x06, 0x0F, 0x2B, 0xBB, 0x49, 
	0xB5, 0x8B, 0xF5, 0xC0, 0x8A, 0x1C, 0x66, 0xC8, 
	0xE1, 0x09, 0x1C, 0x62, 0x61, 0xB9, 0x70, 0x63, 
	0x47, 0x19, 0x1A, 0x18, 0x1E, 0x41, 0x43, 0xC2, 
	0x88, 0x92, 0xA4, 0x69, 0x42, 0x09, 0x85, 0xB6, 
	0xCA, 0x94, 0x45, 0x2F, 0xEA, 0xAF, 0xD7, 0x5A, 
	0xDE, 0xED, 0x5A, 0xC4, 0x7B, 0x66, 0x44, 0x76, 
	0xAF, 0x2C, 0x21, 0x10, 0xF9, 0xD8, 0xDC, 0x17, 
	0x72, 0x0B, 0xF1, 0x97, 0x25, 0x88, 0x70, 0xE8, 
	0x9F, 0x73, 0x13, 0x57, 0x68, 0x79, 0x43, 0xB4, 
	0x72, 0x18, 0xCB, 0xE7, 0x11, 0x9F, 0xB6, 0x99, 
	0x7C, 0xC4, 0x3B, 0xF2, 0x8F, 0x8C, 0xA3, 0x32, 
	0xDA, 0xFF, 0x85, 0x69, 0x92, 0x25, 0x73, 0x2B, 
	0xA8, 0x04, 0xC5, 0xC2, 0x1A, 0xD6, 0x75, 0xDC, 
	0xDC, 0x97, 0xFE, 0x95, 0xAC, 0x90, 0x3D, 0xBF, 
	0x85, 0x83, 0xF6, 0xE9, 0x71, 0x69, 0x96, 0xFC, 
	0x8C, 0x92, 0xD7, 0x27, 0xAC, 0x57, 0xA9, 0x36, 
	0xB5, 0xDE, 0x3B, 0xFF, 0xF4, 0xA4, 0x69, 0xB7, 
	0x73, 0xCD, 0x1A, 0x96, 0xBF, 0xAD, 0xAB, 0xA7, 
	0xB4, 0xB4, 0xE1, 0xCE, 0x67, 0xD6, 0x40, 0xCF, 
	0x2B, 0x3C, 0x3A, 0xE6, 0xC2, 0x75, 0x58, 0xC6, 
	0x0D, 0x69, 0x73, 0x81, 0xFF, 0x42, 0xEC, 0x03, 
	0xCC, 0x69, 0xEB, 0x34, 0x6A, 0xDD, 0xB1, 0xE9, 
	0x96, 0x6A, 0x9E, 0x81, 0xFA, 0x35, 0xD2, 0x30, 
	0x3E, 0xE8, 0x1E, 0xFA, 0x46, 0x80, 0xAB, 0x0C, 
	0xCB, 0x58, 0x88, 0x09, 0x61, 0x59, 0xE9, 0xC5, 
	0x34, 0x89, 0x56, 0x80, 0x49, 0x5F, 0x12, 0x02, 
	0xAB, 0x0E, 0x71, 0x34, 0x81, 0x6F, 0x23, 0x8F, 
	0x89, 0xDB, 0xFF, 0x4F, 0x85, 0x03, 0x32, 0x00, 
	0xF1, 0x0C, 0xC3, 0xD9, 0xEC, 0xEE, 0xFD, 0xF1, 
	0xC3, 0x31, 0xC8, 0x4E, 0x2B, 0x5F, 0x76, 0x29, 
	0xF1, 0x6A, 0x23, 0x8B, 0xE4, 0x1A, 0xDA, 0xD3, 
	0x80, 0xE6, 0xC6, 0x41, 0x3B, 0x56, 0x13, 0x3C, 
	0xEE, 0x34, 0x2B, 0x2C, 0xCE, 0xE9, 0x28, 0xC3, 
	0x48, 0x29, 0x60, 0xD5, 0xFC, 0xAE, 0x4E, 0x85, 
	0x49, 0xED, 0xF8, 0x3F, 0xA1, 0x4B, 0xBB, 0x68, 
	0x73, 0xF6, 0x62, 0xE6, 0x83, 0x82, 0xA0, 0x99, 
	0x9E, 0x90, 0x34, 0xB1, 0xBD, 0x5A, 0x3A, 0xF9, 
	0x05, 0xCC, 0xA5, 0x09, 0x94, 0x96, 0xD8, 0x0F, 
	0x4E, 0x97, 0x2B, 0xB2, 0x1F, 0xA3, 0x75, 0xC2, 
	0x07, 0x2C, 0xF9, 0x9F, 0x70, 0xEB, 0x4B, 0xDA, 
	0x60, 0xFB, 0x38, 0x9C, 0xE1, 0xAF, 0xBB, 0x43, 
	0xB0, 0xB1, 0x0F, 0x21, 0xBB, 0x4F, 0x8C, 0x38, 
	0xFC, 0x95, 0x08, 0x2F, 0xF1, 0x9F, 0x52, 0x2F, 
	0x2D, 0x83, 0xA1, 0xFF, 0x41, 0x7B, 0xE0, 0xA1, 
	0x46, 0xA0, 0xD4, 0x0B, 0x14, 0x35, 0x3C, 0xED, 
	0xA8, 0x83, 0xCF, 0xC6, 0xA6, 0x22, 0x7B, 0x8A, 
	0xCE, 0xB1, 0xB5, 0x10, 0x61, 0x1F, 0xEC, 0x99, 
	0xBD, 0xB6, 0xA6, 0x6F, 0x8F, 0x6A, 0x69, 0xAD, 
	0x42, 0x78, 0xAD, 0x0A, 0xD5, 0x30, 0xAF, 0x8A, 
	0xED, 0xDA, 0x34, 0x74, 0x79, 0x47, 0xDB, 0xC9, 
	0x0E, 0xF2, 0x67, 0x25, 0x20, 0xF9, 0x6F, 0x9A, 
	0x3C, 0x3F, 0x59, 0x9E, 0xC3, 0x36, 0xB1, 0xA5, 
	0x32, 0xAF, 0x69, 0x59, 0x37, 0x99, 0x5D, 0xDA, 
	0x46, 0x78, 0xFB, 0x46, 0xCA, 0xB6, 0xA7, 0x58, 
	0xA8, 0x3B, 0x4B, 0x98, 0x01, 0xC2, 0x50, 0xCA, 
	0x88, 0x9C, 0xD2, 0x43, 0x60, 0xBC, 0x0F, 0xAA, 
	0xFC, 0x54, 0xC2, 0xAA, 0xB7, 0x31, 0x55, 0x1B, 
	0x70, 0x8B, 0xF8, 0x26, 0xCA, 0xA9, 0xC4, 0x1C, 
	0xB0, 0xE0, 0x4B, 0x6B, 0x87, 0xD1, 0xB5, 0xA1, 
	0xFB, 0xB2, 0x24, 0xD4, 0xFF, 0x05, 0xFE, 0x6B, 
	0xF4, 0x2A, 0x22, 0x38, 0x39, 0x59, 0x1D, 0x12, 
	0x92, 0xEA, 0x7C, 0xA7, 0x9A, 0x8F, 0xDC, 0x8B, 
	0x5A, 0x5E, 0xE5, 0x29, 0xEC, 0xD4, 0x83, 0x0A, 
	0x33, 0x8B, 0x5A, 0x30, 0xB6, 0x70, 0xB7, 0x29, 
	0x5F, 0x02, 0x41, 0xDF, 0x37, 0xD5, 0x3F, 0x32, 
	0x31, 0xAD, 0xA7, 0x25, 0x08, 0x81, 0x34, 0xF8, 
	0x5E, 0x6C, 0xF4, 0x9F, 0xA5, 0x3B, 0xA3, 0xD1, 
	0x80, 0x37, 0x37, 0x98, 0x27, 0x5E, 0x6F, 0x36, 
	0xD4, 0x9A, 0x2C, 0x1C, 0xAF, 0x65, 0xCE, 0xF5, 
	0xCC, 0xCA, 0x56, 0x3B, 0xE3, 0x07, 0x0E, 0xCE, 
	0x03, 0x0D, 0x0D, 0x1A, 0xD3, 0x06, 0x63, 0x8F, 
	0xEC, 0xC4, 0x49, 0xF5, 0xCF, 0xCA, 0x4B, 0x11, 
	0xF2, 0x0F, 0xBE, 0xE1, 0x98, 0xB6, 0x5D, 0xB2, 
	0x02, 0xEB, 0xB6, 0x09, 0x3C, 0x16, 0xAA, 0x47, 
	0x88, 0x2D, 0x7B, 0x37, 0xED, 0x73, 0x3E, 0x15, 
	0xF1, 0x20, 0x24, 0xBF, 0x65, 0xFF, 0xD0, 0xE6, 
	0x20, 0xB7, 0xD6, 0x87, 0xB7, 0x34, 0x0A, 0x57, 
	0x87, 0xEF, 0x73, 0x2B, 0x64, 0x5B, 0x1A, 0x4D, 
	0x56, 0x35, 0x93, 0x7E, 0xE1, 0x4A, 0x27, 0xE9, 
	0xBA, 0x2F, 0x8D, 0xCE, 0xAB, 0xCF, 0x29, 0x7E, 
	0x8C, 0xE9, 0x82, 0x25, 0xC9, 0x72, 0x09, 0x13, 
	0x9D, 0x37, 0x32, 0x64, 0xB5, 0x28, 0x83, 0x9E, 
	0x8F, 0x9E, 0x84, 0x6B, 0xB7, 0xBC, 0x9C, 0x68, 
	0x2B, 0x1B, 0x82, 0xA4, 0x19, 0xCF, 0xC5, 0x92, 
	0xE8, 0xF0, 0xCC, 0xDD, 0x63, 0x56, 0xF5, 0x66, 
	0xBD, 0x5B, 0x0F, 0x3E, 0xDC, 0x64, 0x8B, 0xC9, 
	0xFE, 0x45, 0xB1, 0x0B, 0x89, 0x34, 0x4C, 0xC5, 
	0xDD, 0x36, 0x3D, 0x0F, 0x84, 0x32, 0xA4, 0x4F, 
	0xDB, 0x34, 0xC9, 0x15, 0xCB, 0x0A, 0x49, 0x04, 
	0xF4, 0xF7, 0xC4, 0xB1, 0x42, 0x35, 0x28, 0xA9, 
	0xBB, 0x52, 0x69, 0x76, 0x7B, 0xC1, 0xEB, 0xAD, 
	0xB0, 0x4A, 0x40, 0x6E, 0x89, 0x75, 0xFF, 0x13, 
	0x49, 0x87, 0x4C, 0xF5, 0x41, 0x60, 0x29, 0x68, 
	0xFC, 0xCD, 0x65, 0x42, 0x98, 0xD8, 0x32, 0x9A, 
	0xCE, 0xBD, 0x0C, 0xC4, 0xDA, 0x64, 0xE3, 0xA6, 
	0xD7, 0xC5, 0x2F, 0x77, 0xB7, 0x08, 0x77, 0xD4, 
	0x67, 0xB1, 0xED, 0x2B, 0xA9, 0x76, 0x46, 0xDF, 
	0x22, 0xBA, 0x50, 0xDA, 0x4E, 0x6A, 0x29, 0x92, 
	0xE6, 0x3F, 0x4B, 0xED, 0xAF, 0x23, 0x01, 0xD6, 
	0x17, 0x31, 0x0E, 0xE1, 0x2B, 0xC2, 0x38, 0x3E, 
	0x1F, 0x65, 0xFC, 0xB1, 0x7D, 0xAE, 0x9D, 0xD7, 
	0x43, 0x0A, 0x4C, 0x18, 0x92, 0xBA, 0x62, 0xDA, 
	0x30, 0xFB, 0xB4, 0x96, 0x6F, 0xB0, 0xC7, 0x0F, 
	0x99, 0x19, 0xF2, 0x6A, 0x78, 0x62, 0x2F, 0xC6, 
	0x5B, 0xE9, 0x62, 0x67, 0x90, 0xCE, 0x0C, 0x1A, 
	0xE2, 0x2C, 0x72, 0x0C, 0xE5, 0xE1, 0xB9, 0x30, 
	0x06, 0x51, 0xCE, 0xC4, 0x28, 0xA7, 0xDE, 0x5A, 
	0x10, 0x15, 0x2E, 0x95, 0x93, 0xE5, 0x1C, 0xFF, 
	0x82, 0xF4, 0x4A, 0x19, 0x7F, 0xDF, 0xF1, 0x10, 
	0x44, 0x99, 0x37, 0x3F, 0x54, 0xBE, 0xE9, 0x77, 
	0x15, 0x08, 0xF2, 0x6B, 0xE5, 0x74, 0x05, 0x1A, 
	0xEA, 0xEA, 0xAD, 0x54, 0x99, 0x43, 0x0F, 0x4A, 
	0x5C, 0xFB, 0x6E, 0x79, 0x64, 0xD3, 0x09, 0x14, 
	0xAE, 0x34, 0x76, 0xF1, 0x5C, 0xC0, 0xDA, 0xF4, 
	0x5B, 0x86, 0xFA, 0x11, 0x69, 0x60, 0x08, 0xC9, 
	0x9E, 0xCA, 0x85, 0xAC, 0x67, 0x04, 0x8E, 0x93, 
	0xE0, 0xFB, 0x50, 0x7C, 0xA2, 0xAE, 0xCF, 0xE2, 
	0xE1, 0xE3, 0x0D, 0xFF, 0x16, 0x68, 0x57, 0x3D, 
	0x24, 0x31, 0xE1, 0xD2, 0x48, 0xF0, 0x2C, 0x95, 
	0x17, 0x46, 0xCC, 0x62, 0x89, 0x9B, 0x1D, 0xF7, 
	0x0A, 0x5E, 0xE5, 0x68, 0x73, 0x91, 0x7B, 0x26, 
	0x9F, 0xC5, 0x17, 0xF9, 0xE7, 0x0B, 0x2E, 0x9B, 
	0xDF, 0x84, 0xEA, 0x66, 0x5B, 0xBA, 0x82, 0xDA, 
	0x8A, 0xC7, 0x85, 0xD9, 0x72, 0x24, 0x0D, 0xC8, 

	/* Database Page 18 */

	0xFF, 0x32, 0x2E, 0x16, 0x7D, 0xE8, 0x67, 0x09, 
	0x2D, 0xFB, 0xCA, 0xE5, 0xFD, 0xBD, 0x3F, 0x20, 
	0x35, 0x7F, 0x71, 0xDA, 0x7C, 0xF5, 0x8C, 0xB1, 
	0xE7, 0xD8, 0x0E, 0x24, 0x46, 0x93, 0x3E, 0x63, 
	0x5B, 0x18, 0xC9, 0xB7, 0x38, 0xDD, 0x34, 0x15, 
	0x68, 0x75, 0xD3, 0xF3, 0x3C, 0xE7, 0x90, 0x46, 
	0x1C, 0x71, 0x69, 0x6B, 0xD1, 0xD6, 0x46, 0x03, 
	0x5E, 0x96, 0x71, 0x2B, 0x86, 0x33, 0x84, 0x4C, 
	0x62, 0xB4, 0x46, 0x55, 0xB7, 0xB0, 0x4A, 0x0D, 
	0xF1, 0x0C, 0x19, 0x8E, 0xEE, 0x6C, 0xA2, 0x72, 
	0xBF, 0x62, 0xA2, 0x01, 0x6F, 0xD7, 0xC0, 0x54, 
	0x81, 0x69, 0x55, 0x0D, 0x23, 0x8C, 0x8F, 0x12, 
	0x09, 0xCB, 0x0A, 0x59, 0x6C, 0xED, 0x35, 0x31, 
	0x4B, 0x98, 0x00, 0x97, 0xDD, 0xDC, 0xDF, 0x17, 
	0xD8, 0x8B, 0x5F, 0xD6, 0xB7, 0x0D, 0x93, 0x95, 
	0xAE, 0x57, 0x4F, 0x41, 0xFD, 0x01, 0x79, 0xFF, 
	0xF0, 0xFF, 0x2C, 0xA3, 0xC9, 0x90, 0x0B, 0x76, 
	0xB9, 0xC2, 0x49, 0x49, 0xA4, 0xD7, 0xC5, 0x81, 
	0x3B, 0x7C, 0xD2, 0x56, 0xC5, 0x5B, 0x88, 0x68, 
	0xA3, 0x3B, 0x82, 0x44, 0xB2, 0xE7, 0xA2, 0x57, 
	0x12, 0x7C, 0xBC, 0x89, 0x1E, 0x67, 0xAF, 0x8E, 
	0x0F, 0x86, 0x75, 0xD2, 0x56, 0x4E, 0x89, 0xF5, 
	0x1B, 0x0C, 0xC8, 0xE3, 0xA5, 0x31, 0x15, 0x2C, 
	0x1D, 0x21, 0xEC, 0x74, 0x60, 0x35, 0x8C, 0x8A, 
	0xF3, 0xC2, 0x57, 0xB3, 0x04, 0x2A, 0x59, 0xCE, 
	0x01, 0x2A, 0x85, 0xB7, 0x3C, 0x97, 0x50, 0x86, 
	0xDE, 0x88, 0x61, 0xB6, 0xD2, 0x3B, 0x21, 0x47, 
	0xCD, 0x6E, 0x5C, 0xC1, 0xBC, 0xF2, 0x73, 0xFA, 
	0xAD, 0x3C, 0xC7, 0x4C, 0x39, 0x9F, 0xC1, 0x9F, 
	0xBF, 0x64, 0x3C, 0xA4, 0xA8, 0xB4, 0x05, 0x38, 
	0xA0, 0x73, 0x09, 0xB8, 0xDB, 0x93, 0xCD, 0xA9, 
	0x8B, 0x7A, 0x1E, 0xDB, 0xD1, 0x65, 0xFF, 0x24, 
	0xF6, 0x99, 0xFF, 0x21, 0xDE, 0x77, 0xB9, 0x23, 
	0x2C, 0x34, 0xFB, 0x98, 0x83, 0xF4, 0xD3, 0x60, 
	0x7A, 0x46, 0xB5, 0xE8, 0x83, 0xC0, 0x43, 0x7C, 
	0x3E, 0x87, 0x23, 0x63, 0x66, 0xBE, 0x5A, 0x0D, 
	0x27, 0xCB, 0x5B, 0x17, 0x4E, 0x1D, 0xDF, 0x7F, 
	0xBF, 0xBD, 0x02, 0x1A, 0x1F, 0xF6, 0x36, 0xCB, 
	0x6C, 0x8F, 0x7F, 0x8C, 0x37, 0x6A, 0xA5, 0x8F, 
	0x42, 0x94, 0x9E, 0xAB, 0xDF, 0xFD, 0x4E, 0x4F, 
	0x9C, 0xA1, 0x66, 0xE5, 0x9F, 0x44, 0xC1, 0x7F, 
	0x3C, 0xE3, 0xDD, 0x79, 0x62, 0xCE, 0xED, 0xDE, 
	0x90, 0x35, 0x18, 0xCA, 0x33, 0x0A, 0xB0, 0x39, 
	0xFB, 0x28, 0x0F, 0x3D, 0x29, 0x40, 0x04, 0x29, 
	0xA1, 0x08, 0x91, 0xD9, 0x97, 0xF1, 0x45, 0x5E, 
	0x5F, 0xF8, 0x21, 0xC7, 0x08, 0x0E, 0xDA, 0x4E, 
	0xE1, 0x5C, 0x0C, 0x4D, 0xCB, 0x34, 0xA0, 0x5E, 
	0x6C, 0x17, 0x21, 0xC8, 0xE5, 0x1A, 0x76, 0x96, 
	0x5C, 0xD7, 0x78, 0xFF, 0xB5, 0xB7, 0x67, 0xF1, 
	0xD4, 0x50, 0xD8, 0x6E, 0x44, 0xD5, 0x6E, 0x9B, 
	0x49, 0xBF, 0x43, 0xFF, 0x93, 0xC1, 0x27, 0xDA, 
	0x78, 0xA0, 0x67, 0xA1, 0x21, 0x60, 0xF7, 0xE8, 
	0xEB, 0xB5, 0x2E, 0x70, 0x28, 0x03, 0xE7, 0x3E, 
	0x54, 0x46, 0xC0, 0x4C, 0xE6, 0x1B, 0x27, 0xB6, 
	0xE2, 0x6C, 0x99, 0x03, 0xAE, 0x90, 0x1C, 0x7B, 
	0x0F, 0x2E, 0xEC, 0xA4, 0x24, 0xF8, 0x3E, 0xDB, 
	0x66, 0xD8, 0x02, 0x12, 0x92, 0xD6, 0x68, 0x51, 
	0x33, 0xBC, 0x9E, 0x0C, 0x13, 0xEC, 0x79, 0xD7, 
	0x42, 0x0D, 0xD2, 0x73, 0xCA, 0x4D, 0xB3, 0x7D, 
	0x5B, 0x10, 0x55, 0x93, 0xC6, 0x66, 0x44, 0x7E, 
	0xEA, 0xAA, 0x1B, 0xE3, 0x49, 0xB5, 0xAB, 0x0B, 
	0x62, 0x3B, 0x13, 0xCA, 0x84, 0x21, 0x03, 0xFA, 
	0x52, 0x84, 0x74, 0x49, 0x55, 0xBB, 0x0A, 0xB0, 
	0x23, 0xC7, 0xF8, 0xD8, 0x80, 0x08, 0x0C, 0x7D, 
	0x0F, 0xEE, 0xFB, 0xB4, 0xFF, 0x2F, 0x96, 0x9A, 
	0x18, 0x83, 0x15, 0x97, 0x15, 0x57, 0xCA, 0x68, 
	0xB1, 0xDE, 0xBD, 0x6D, 0x29, 0xA2, 0x29, 0xF5, 
	0xE6, 0x24, 0xAE, 0x0E, 0x55, 0xED, 0x56, 0x68, 
	0xE4, 0xC1, 0xB1, 0xDF, 0x4B, 0x2D, 0xB9, 0xD8, 
	0x88, 0x34, 0x25, 0x42, 0xE7, 0x67, 0xC8, 0xD0, 
	0x84, 0xF7, 0xED, 0x6E, 0x22, 0x0E, 0xBC, 0x9F, 
	0xF5, 0xE4, 0x5C, 0x8F, 0x16, 0x56, 0x84, 0x34, 
	0x1B, 0x4B, 0x8F, 0xBD, 0x13, 0x83, 0x80, 0x48, 
	0x3A, 0x54, 0x0D, 0xFA, 0xF7, 0x9B, 0xF7, 0xB2, 
	0xBD, 0x36, 0xF4, 0x53, 0x22, 0x63, 0x3B, 0xF5, 
	0x4F, 0x48, 0x53, 0x2D, 0x39, 0x13, 0xCC, 0xA6, 
	0x02, 0x6D, 0x58, 0x58, 0x7B, 0x7F, 0xCB, 0x76, 
	0x87, 0x3E, 0x93, 0x3C, 0x45, 0x6D, 0x9D, 0x9B, 
	0xAB, 0xF5, 0xF1, 0x90, 0x4B, 0x73, 0x47, 0x48, 
	0xE4, 0xDD, 0xD9, 0x04, 0x5D, 0x60, 0x71, 0x70, 
	0x93, 0x4B, 0x6D, 0x05, 0xB4, 0xFF, 0x70, 0x69, 
	0xA0, 0x12, 0xC2, 0xCE, 0x85, 0x90, 0xAE, 0x22, 
	0x18, 0x81, 0x4B, 0x54, 0x0E, 0xB9, 0x6F, 0xB7, 
	0x04, 0x87, 0xCB, 0x8B, 0x34, 0xE2, 0x07, 0x40, 
	0xB2, 0x25, 0xA6, 0x4E, 0x98, 0x75, 0x04, 0x77, 
	0x14, 0x9B, 0x29, 0xDC, 0x61, 0x7F, 0x95, 0x4F, 
	0xF6, 0xA4, 0xF5, 0x84, 0xA5, 0x8A, 0xCF, 0xED, 
	0xCF, 0x0C, 0x2B, 0xFD, 0x69, 0xE3, 0xD3, 0x79, 
	0x86, 0xA3, 0x4E, 0x08, 0x46, 0xE2, 0x6A, 0xED, 
	0xF6, 0x96, 0xDC, 0x36, 0x48, 0x43, 0x49, 0xCC, 
	0x99, 0x51, 0x5E, 0xFF, 0x49, 0x7A, 0x67, 0xFD, 
	0x7F, 0x0E, 0x4E, 0x26, 0x22, 0xB4, 0xFE, 0x93, 
	0x28, 0xBC, 0xC1, 0x00, 0x17, 0x0A, 0xEC, 0xD1, 
	0x3F, 0x47, 0xA7, 0x11, 0xF5, 0xE8, 0xCB, 0xFF, 
	0xE5, 0x91, 0xDA, 0x0E, 0x0A, 0x70, 0x91, 0x8F, 
	0x9A, 0xAC, 0x40, 0x99, 0xF2, 0x43, 0xC2, 0x25, 
	0x3B, 0x72, 0x4F, 0xAF, 0x30, 0x1C, 0xFF, 0x4F, 
	0xFC, 0xA9, 0xD5, 0xE5, 0x58, 0xA3, 0x67, 0x05, 
	0xC0, 0xA4, 0x6A, 0x18, 0xE0, 0xE5, 0x24, 0xB4, 
	0x8E, 0x02, 0xE2, 0x8A, 0xD0, 0x78, 0x08, 0x62, 
	0x96, 0x6F, 0xD8, 0xAE, 0x31, 0x50, 0xAB, 0x62, 
	0x3A, 0x70, 0xE7, 0x19, 0xD4, 0x03, 0x0E, 0x12, 
	0xCE, 0x89, 0xDC, 0xFC, 0x1D, 0x88, 0xEB, 0xC9, 
	0x5F, 0xD1, 0xFC, 0x68, 0x52, 0xAC, 0x40, 0xBE, 
	0x10, 0x40, 0xC4, 0xA3, 0x08, 0x32, 0x65, 0xC8, 
	0x11, 0x4F, 0x53, 0xAF, 0xFF, 0x79, 0xDD, 0x2B, 
	0x66, 0x26, 0xE3, 0xD6, 0x3D, 0x2D, 0xC6, 0xDC, 
	0x44, 0x29, 0xC5, 0xD9, 0x28, 0x63, 0x90, 0x6E, 
	0x5F, 0x13, 0xB1, 0xB9, 0x33, 0x1E, 0xCC, 0xBD, 
	0xBF, 0xFB, 0x80, 0xF5, 0xFF, 0x31, 0x19, 0x6B, 
	0xFC, 0x90, 0xE7, 0xDD, 0x8C, 0xEF, 0xC3, 0x81, 
	0x19, 0xFF, 0x34, 0x11, 0x32, 0x87, 0xE5, 0x08, 
	0xC5, 0x3F, 0x98, 0x0F, 0x94, 0xDF, 0x73, 0xFF, 
	0xA6, 0xF3, 0x6D, 0x9C, 0xA0, 0x19, 0xDE, 0x09, 
	0x45, 0x21, 0xE1, 0x67, 0x8A, 0x98, 0xE0, 0x29, 
	0x14, 0x57, 0x23, 0xD8, 0xB5, 0xA6, 0x7D, 0x33, 
	0x01, 0x4A, 0xE5, 0xFA, 0x4B, 0xD5, 0x46, 0xFB, 
	0x21, 0x7A, 0xB8, 0x7E, 0x25, 0x58, 0xF3, 0xFD, 
	0x2D, 0xAF, 0x0B, 0x87, 0xDD, 0x10, 0x1F, 0x51, 
	0x69, 0x9B, 0x37, 0x8D, 0xD6, 0x9A, 0x47, 0x33, 
	0xCE, 0x40, 0x87, 0x93, 0xB7, 0x59, 0x4A, 0xB5, 
	0x46, 0xFC, 0xEB, 0xF5, 0x1A, 0xC5, 0x8F, 0xF9, 
	0x16, 0xA8, 0x06, 0xD0, 0xA8, 0x80, 0x24, 0x70, 
	0x0D, 0x59, 0x1D, 0x29, 0xD7, 0x16, 0xDF, 0x85, 
	0x83, 0xD8, 0x79, 0xE0, 0xEA, 0x8D, 0xBF, 0x5E, 
	0xBE, 0x6E, 0x5D, 0xF5, 0x2D, 0x0D, 0x41, 0x6A, 
	0x5F, 0x8E, 0xB5, 0x90, 0x34, 0x40, 0xE1, 0x67, 
	0xB0, 0xB4, 0xCA, 0x05, 0xFD, 0x8F, 0xBA, 0x4F, 
	0xE4, 0xFD, 0xDF, 0x77, 0x07, 0x1C, 0x97, 0xE9, 
	0xFF, 0x13, 0xA3, 0xB6, 0xEF, 0xB0, 0x9C, 0x26, 
	0x6B, 0x99, 0x21, 0x7D, 0x48, 0x29, 0x36, 0x2A, 
	0x97, 0xA5, 0xD7, 0x16, 0x82, 0x93, 0x25, 0xB5, 
	0x7A, 0xBF, 0x9B, 0x6F, 0x0D, 0x64, 0xCA, 0x96, 
	0x2C, 0x73, 0x65, 0xAB, 0x04, 0x41, 0x4E, 0x07, 
	0xE9, 0x08, 0x5C, 0xE7, 0x96, 0x70, 0x28, 0x9A, 
	0xF4, 0xFA, 0x7B, 0xE1, 0x67, 0xFB, 0x71, 0x84, 
	0x5A, 0x0C, 0x2F, 0xC9, 0x5A, 0xFB, 0x1D, 0x05, 
	0x6F, 0x21, 0x2D, 0xE2, 0x26, 0xA7, 0x7B, 0x45, 
	0xB6, 0x3F, 0xD6, 0xC3, 0x1E, 0x0F, 0x3B, 0xA3, 
	0x47, 0xE8, 0x32, 0x9B, 0x73, 0x78, 0xB4, 0xF1, 
	0xDD, 0xC7, 0x59, 0xD5, 0xC2, 0x94, 0x1D, 0x9A, 
	0xC9, 0x2B, 0x89, 0xA9, 0x8A, 0xEF, 0xBA, 0xB3, 
	0xB5, 0x26, 0x87, 0x88, 0x66, 0xA4, 0xAC, 0x73, 
	0x0A, 0x0F, 0xAF, 0xAB, 0xBF, 0x2D, 0x37, 0xEA, 
	0xCC, 0x3D, 0x8D, 0xCD, 0xEA, 0x31, 0xC9, 0xE9, 
	0xA5, 0xFF, 0x34, 0x85, 0x28, 0xA7, 0x8C, 0x70, 
	0x4B, 0x01, 0xD0, 0xFB, 0xA6, 0xCE, 0x82, 0xBC, 
	0x8E, 0xA4, 0xDC, 0x81, 0x78, 0x92, 0x19, 0x48, 
	0x30, 0xDA, 0x86, 0x17, 0x0A, 0xBC, 0x9A, 0xFB, 
	0x60, 0xD3, 0x13, 0x57, 0x47, 0x62, 0xF2, 0x3F, 
	0x7D, 0x37, 0xE8, 0xA6, 0x29, 0x0B, 0x95, 0xB0, 
	0x05, 0x51, 0xE3, 0x41, 0x4E, 0x30, 0xA0, 0x6D, 
	0x0B, 0xE5, 0x84, 0xF1, 0x79, 0x69, 0xE7, 0xA2, 
	0x9C, 0xFA, 0x2C, 0x13, 0xC6, 0xD8, 0xFC, 0x20, 
	0x5F, 0xBB, 0xE6, 0xDC, 0x94, 0x61, 0xDA, 0x1B, 
	0x77, 0xAA, 0x64, 0x43, 0x93, 0x9A, 0xF6, 0xE2, 
	0x78, 0x31, 0xFD, 0x47, 0x44, 0xA1, 0x7A, 0x82, 
	0x2A, 0x00, 0xB1, 0xFC, 0xCF, 0x71, 0x4F, 0xDA, 
	0x0F, 0x20, 0x9F, 0x74, 0xDB, 0xC3, 0x17, 0x1B, 
	0x21, 0xB3, 0x6F, 0x6F, 0x2D, 0x9A, 0xFF, 0x80, 
	0x8F, 0x00, 0xBD, 0x3F, 0x51, 0x1C, 0x74, 0x2C, 
	0xC0, 0x3F, 0xFF, 0xFB, 0xA3, 0xDE, 0xD4, 0x7A, 
	0x6F, 0x8B, 0x04, 0xDE, 0xFD, 0xD3, 0xF3, 0xB2, 
	0xCA, 0xBE, 0xA7, 0x1D, 0xF0, 0xC8, 0x90, 0xA2, 
	0xEC, 0x7F, 0x3C, 0x7A, 0xBF, 0xE9, 0x50, 0xC1, 
	0x72, 0xBE, 0xB1, 0x16, 0x9C, 0x5B, 0xB4, 0x95, 
	0xAB, 0x8C, 0x97, 0x5D, 0x7C, 0xD6, 0x2D, 0xA0, 
	0x9D, 0xC7, 0xA1, 0x51, 0x1B, 0xE2, 0x9C, 0x9E, 
	0x0D, 0xC6, 0xE8, 0x10, 0x90, 0xCF, 0x27, 0xE7, 
	0x06, 0x07, 0xFA, 0xA8, 0xCC, 0x4C, 0xFE, 0xC7, 
	0xE4, 0x9E, 0x6F, 0xF8, 0x03, 0x19, 0x0F, 0xA2, 
	0x21, 0x9A, 0xBF, 0xAC, 0x6F, 0xAC, 0x53, 0x7D, 
	0x7A, 0x43, 0x03, 0x04, 0xA4, 0x31, 0x92, 0x58, 
	0x33, 0xD5, 0xC2, 0x75, 0xDD, 0xE4, 0x05, 0x92, 
	0x00, 0x03, 0x68, 0x7A, 0xF1, 0x54, 0x58, 0xC6, 
	0x6A, 0x41, 0xD5, 0xAF, 0x88, 0x07, 0x86, 0x3B, 
	0x36, 0x6A, 0x11, 0xEF, 0x5A, 0x3D, 0x45, 0x41, 
	0xFF, 0xD1, 0x56, 0xFF, 0x8D, 0xCF, 0x2C, 0x57, 
	0xF6, 0x6D, 0x9E, 0x5C, 0x9C, 0xBB, 0x31, 0x95, 
	0xBB, 0xAE, 0x25, 0x0E, 0xFD, 0xB8, 0xF6, 0x6C, 
	0x9A, 0x59, 0x51, 0xEC, 0xE3, 0xEE, 0x3B, 0x74, 
	0x2C, 0x81, 0xB0, 0x35, 0x26, 0xE8, 0x21, 0xE4, 
	0xC1, 0xEC, 0xFE, 0x5D, 0x2E, 0x9F, 0x9B, 0x9F, 
	0xDA, 0xF7, 0xCB, 0xA5, 0x0C, 0x05, 0x0E, 0x60, 
	0x9E, 0x69, 0x41, 0x53, 0x49, 0xE6, 0x48, 0x0A, 
	0xE0, 0xED, 0x1B, 0x1A, 0xE7, 0xDB, 0xF7, 0x79, 
	0xC5, 0xB8, 0x92, 0xBE, 0xC2, 0xFC, 0x1B, 0xD7, 
	0xEF, 0x98, 0x01, 0x65, 0xCA, 0xEE, 0x26, 0xD5, 
	0x39, 0x1B, 0x3B, 0xE0, 0x4F, 0xBA, 0x0F, 0xDC, 
	0x6D, 0xC5, 0xB9, 0x63, 0x59, 0x93, 0x6A, 0xAD, 
	0xA3, 0x38, 0xC8, 0xD7, 0x23, 0xC9, 0x89, 0xE9, 
	0x4E, 0x6B, 0x3A, 0x90, 0x1E, 0x92, 0x82, 0x21, 
	0x78, 0xA1, 0x14, 0x19, 0xA2, 0x00, 0xBE, 0x2F, 
	0x52, 0xC9, 0xE8, 0x01, 0xFF, 0x55, 0xDD, 0xC8, 
	0xBD, 0x94, 0x5C, 0x65, 0xBB, 0xB6, 0xF3, 0xC9, 
	0x78, 0x5D, 0xAC, 0xFF, 0x2D, 0x0F, 0xE2, 0x1C, 
	0xE1, 0xD7, 0xCB, 0x53, 0xDD, 0xB7, 0x8F, 0x87, 
	0x96, 0x8E, 0x63, 0x16, 0x88, 0xD9, 0x39, 0x60, 
	0x2D, 0x35, 0x22, 0xB7, 0xF1, 0xBB, 0x7D, 0x3F, 
	0x56, 0x38, 0x3B, 0x6F, 0x15, 0xBC, 0x46, 0xC4, 
	0xA8, 0x0C, 0x03, 0xF6, 0xE4, 0x2A, 0x34, 0xDA, 
	0xB0, 0xDF, 0x91, 0xB7, 0xD7, 0xB4, 0x15, 0xD8, 
	0x99, 0xDB, 0x09, 0xA4, 0x25, 0xCE, 0xC7, 0xF2, 
	0xDD, 0xC4, 0x43, 0x3F, 0xA3, 0x3E, 0xE9, 0x5D, 
	0x00, 0x28, 0x2B, 0x71, 0x25, 0x47, 0x69, 0xEF, 
	0x26, 0xFE, 0xA1, 0x68, 0x68, 0x4F, 0x09, 0x5B, 
	0x92, 0xE2, 0x54, 0x66, 0xD6, 0x20, 0x0F, 0x1D, 
	0x0C, 0x2D, 0x20, 0x20, 0xAA, 0x76, 0x03, 0x30, 
	0x72, 0x00, 0xD0, 0x60, 0x95, 0xB9, 0xFA, 0x98, 
	0x56, 0xBD, 0x3A, 0xAD, 0xF3, 0xFF, 0xD2, 0x4A, 
	0x2A, 0x10, 0x6D, 0xC0, 0xBD, 0x20, 0xB4, 0x47, 
	0x97, 0xC7, 0x3F, 0x47, 0xED, 0xA4, 0x08, 0x91, 
	0xA3, 0x96, 0xDC, 0x27, 0x9A, 0xCB, 0x8D, 0x5E, 
	0xBB, 0xC7, 0x28, 0x1C, 0x66, 0x08, 0x35, 0xE1, 
	0x6D, 0x7F, 0xE4, 0x82, 0x7D, 0xA2, 0x7D, 0xF4, 
	0x02, 0x80, 0x62, 0x03, 0x88, 0x0B, 0x53, 0x51, 
	0xA0, 0x16, 0x03, 0xFE, 0x71, 0xB7, 0xEB, 0x80, 
	0x89, 0x26, 0xD7, 0x4E, 0xA8, 0x10, 0x74, 0x79, 
	0x16, 0x9C, 0x8A, 0xF9, 0x81, 0x3B, 0x26, 0xAF, 
	0xF4, 0xFE, 0x59, 0xB9, 0x70, 0xBC, 0xEC, 0xF6, 
	0xFB, 0x85, 0x06, 0xD8, 0xAF, 0x14, 0x4B, 0xA6, 
	0xC5, 0xA9, 0x15, 0xB5, 0x2C, 0xFA, 0xFC, 0x3F, 
	0x58, 0x08, 0xB4, 0x00, 0x19, 0xD9, 0x8D, 0x27, 
	0x0F, 0x17, 0xF5, 0x43, 0xC3, 0xF4, 0xAE, 0x8F, 
	0x82, 0x03, 0x9A, 0xFE, 0xCC, 0xE2, 0x07, 0x72, 
	0x0A, 0x86, 0x5C, 0xF6, 0x98, 0xBB, 0xFF, 0xE2, 
	0xB7, 0x9C, 0x7D, 0xF9, 0x36, 0xA8, 0x84, 0x7B, 
	0x08, 0xD2, 0xE2, 0xFA, 0x66, 0x72, 0x5E, 0x6E, 
	0x00, 0x8A, 0x53, 0x2B, 0xF4, 0x67, 0x88, 0x13, 
	0xF0, 0x0D, 0xAE, 0x21, 0x93, 0x95, 0x5D, 0x08, 
	0x22, 0xED, 0x28, 0x20, 0xEE, 0xCE, 0xA6, 0xAD, 
	0xA2, 0x18, 0x92, 0x49, 0x09, 0xC3, 0x88, 0x51, 
	0x99, 0x7F, 0x64, 0x3E, 0x77, 0x2E, 0xF8, 0x1F, 
	0x11, 0x05, 0xB8, 0x10, 0xCB, 0x55, 0xA0, 0x96, 
	0x26, 0xCE, 0xDB, 0x43, 0x55, 0xBB, 0x0B, 0x5D, 
	0x0C, 0xDD, 0x3C, 0x00, 0xA7, 0x18, 0x6E, 0x23, 
	0xD8, 0xFE, 0xCC, 0x49, 0x6D, 0x4D, 0xE9, 0xDF, 
	0x5D, 0x90, 0x5D, 0x31, 0xE6, 0x27, 0x1E, 0xC6, 
	0x2E, 0x15, 0xE4, 0x49, 0xAC, 0x85, 0x63, 0xDF, 
	0xD5, 0x0A, 0xDA, 0x3B, 0xA7, 0xAB, 0x17, 0x02, 
	0xBF, 0xC8, 0x81, 0xB0, 0xA8, 0x3A, 0x9C, 0x3C, 
	0xCE, 0x0F, 0x21, 0x8C, 0x25, 0xB5, 0xD5, 0xFF, 
	0x01, 0x91, 0xFE, 0xB4, 0x75, 0x5C, 0x09, 0xBA, 
	0xF7, 0x7C, 0x8D, 0xB9, 0x11, 0x93, 0xE5, 0x68, 
	0xB9, 0x7F, 0x30, 0x13, 0x98, 0xBD, 0x5D, 0x6A, 
	0xB7, 0x04, 0x7C, 0x53, 0x70, 0x2C, 0xEC, 0xA0, 
	0x99, 0x95, 0x49, 0x1A, 0x68, 0xA7, 0x8D, 0x12, 
	0xFC, 0x67, 0x29, 0x86, 0x5E, 0x76, 0x50, 0x98, 
	0xE4, 0x1D, 0xA8, 0x30, 0x0E, 0x08, 0xB3, 0x27, 
	0x80, 0xD4, 0x73, 0x85, 0x65, 0x43, 0xEF, 0xCF, 
	0x77, 0x1A, 0xC3, 0x63, 0x38, 0xE4, 0xEB, 0x0A, 
	0x12, 0x0D, 0x5E, 0xF1, 0x33, 0x17, 0x72, 0x91, 
	0x23, 0xC9, 0xD3, 0x08, 0xD4, 0x67, 0xE3, 0xF0, 
	0x99, 0xB4, 0xE9, 0xBB, 0x35, 0x0F, 0x5D, 0x45, 
	0x64, 0xA5, 0x71, 0x3D, 0xEC, 0x2F, 0x3A, 0x9D, 
	0x04, 0x2C, 0xC7, 0xEB, 0x36, 0xB6, 0x7A, 0xFC, 
	0x6C, 0x23, 0xF3, 0x28, 0x94, 0x79, 0xE1, 0xBF, 
	0xDB, 0x38, 0xCD, 0x8E, 0xA4, 0x2B, 0xE8, 0xBE, 

	/* Database Page 19 */

	0xFF, 0x9B, 0xDA, 0x03, 0xAA, 0x79, 0x50, 0xC3, 
	0x0E, 0xD0, 0x9B, 0x5B, 0x04, 0xE9, 0xFC, 0x52, 
	0xAD, 0xC9, 0x7D, 0xAD, 0x1A, 0x5C, 0x1E, 0xE9, 
	0xFD, 0xB1, 0x65, 0x2E, 0x29, 0x7E, 0xF8, 0x51, 
	0x20, 0x13, 0x76, 0x9E, 0xD7, 0x0E, 0x27, 0x75, 
	0x62, 0xC3, 0x21, 0x07, 0xAF, 0x0F, 0x53, 0x3B, 
	0xE5, 0x1F, 0xC0, 0xF4, 0x2B, 0x77, 0xF5, 0x33, 
	0x5C, 0xB1, 0xD7, 0x04, 0xA9, 0xC2, 0x6F, 0xD7, 
	0xBB, 0x8E, 0xEB, 0x97, 0x12, 0x6F, 0x56, 0xDB, 
	0xF2, 0xE3, 0xFC, 0xBD, 0xB8, 0xD5, 0xCE, 0x84, 
	0x52, 0x70, 0x96, 0x2E, 0x41, 0x95, 0x13, 0x4E, 
	0xE2, 0xB9, 0x6F, 0x9C, 0xE9, 0xA4, 0xB0, 0xEA, 
	0x1A, 0x7C, 0x12, 0xB7, 0xEC, 0xB8, 0x6B, 0xD9, 
	0x23, 0x46, 0x93, 0x6F, 0xBD, 0x75, 0x15, 0xD4, 
	0xD2, 0xA8, 0x23, 0x13, 0xFA, 0xC0, 0xDF, 0xB7, 
	0xEB, 0x57, 0x38, 0xCF, 0x8D, 0x0F, 0xD7, 0x9F, 
	0x62, 0xFF, 0x0A, 0xC9, 0xF1, 0x7E, 0x58, 0x3A, 
	0x00, 0xB2, 0x1A, 0x5A, 0x06, 0xC1, 0x3E, 0x42, 
	0x2A, 0x1F, 0x6C, 0x4A, 0xEE, 0x94, 0x26, 0x84, 
	0x5D, 0x2C, 0xA4, 0xD9, 0x84, 0x63, 0x29, 0xB1, 
	0xB1, 0x7F, 0x86, 0xB6, 0x58, 0x05, 0x57, 0x69, 
	0x54, 0x94, 0xEF, 0xDD, 0x50, 0xE0, 0x13, 0x71, 
	0xCD, 0x9F, 0x9D, 0x8D, 0xE2, 0xDB, 0x91, 0x76, 
	0x60, 0xF1, 0xB2, 0xC6, 0x57, 0xA5, 0x06, 0x49, 
	0x1F, 0xC7, 0x9B, 0x79, 0xE8, 0xEE, 0xB2, 0x67, 
	0x52, 0x0C, 0x11, 0x51, 0x72, 0xE1, 0x34, 0x32, 
	0x56, 0x7B, 0x37, 0x08, 0xD0, 0x3D, 0x21, 0xFA, 
	0xB9, 0x76, 0x19, 0x94, 0x7B, 0x64, 0x99, 0x0F, 
	0x08, 0xDA, 0xBB, 0xEC, 0x65, 0xD1, 0x76, 0x1C, 
	0x41, 0xBB, 0xA6, 0xBF, 0x47, 0xB0, 0x48, 0xBE, 
	0x83, 0xA7, 0x99, 0x00, 0x7F, 0x30, 0x6D, 0x3C, 
	0xC8, 0xE8, 0x74, 0x61, 0x32, 0x39, 0x16, 0xF9, 
	0xFA, 0x77, 0xFF, 0xD3, 0x23, 0x8A, 0x37, 0xE0, 
	0x52, 0x6D, 0x24, 0x99, 0xE1, 0x3A, 0x9F, 0xDC, 
	0x56, 0xC2, 0xFA, 0xD4, 0xD6, 0xE1, 0x76, 0x06, 
	0xFA, 0xB4, 0x71, 0xDE, 0x67, 0x9D, 0x11, 0x52, 
	0xB3, 0xC2, 0x07, 0x63, 0x26, 0x50, 0xC7, 0x94, 
	0x2A, 0xF3, 0xF7, 0x30, 0x42, 0x81, 0xA0, 0xFD, 
	0xD0, 0x81, 0xCC, 0x34, 0xEC, 0xD3, 0xFF, 0xBB, 
	0xDC, 0x70, 0x41, 0x8B, 0x51, 0x62, 0xED, 0xD7, 
	0xA9, 0xB5, 0xB5, 0x3C, 0x8D, 0xE7, 0x8E, 0x27, 
	0xB1, 0x05, 0xFE, 0xE3, 0xDA, 0x3D, 0x6C, 0x2C, 
	0x99, 0xA8, 0x86, 0x5B, 0x0B, 0x03, 0xEA, 0x8C, 
	0x3C, 0xFC, 0xF4, 0x90, 0x12, 0xAA, 0xF7, 0x6F, 
	0x82, 0xB6, 0x34, 0x2B, 0x57, 0x38, 0xCE, 0xB0, 
	0xA4, 0xE4, 0x0E, 0xA4, 0xAE, 0x62, 0xAE, 0x65, 
	0xD7, 0x11, 0x05, 0x16, 0x21, 0x8D, 0xCF, 0xDD, 
	0x52, 0x1B, 0x86, 0xDA, 0x2B, 0xB9, 0x20, 0x08, 
	0x60, 0x38, 0xC3, 0xFF, 0x70, 0xE7, 0xE6, 0xF6, 
	0x36, 0xCC, 0xAF, 0x14, 0x2F, 0x03, 0xD0, 0x1F, 
	0xBA, 0x99, 0x40, 0x48, 0x35, 0x02, 0x14, 0xC8, 
	0x04, 0xAB, 0x5E, 0x6B, 0x6C, 0xFF, 0xB9, 0x7B, 
	0x52, 0xCE, 0x20, 0x40, 0x45, 0x6A, 0x59, 0x3B, 
	0xBD, 0x64, 0x6C, 0xCA, 0x8C, 0xC6, 0x12, 0x34, 
	0x9E, 0xD9, 0x81, 0x55, 0x02, 0xC3, 0xFF, 0x6C, 
	0xD1, 0xF0, 0x61, 0xB1, 0x80, 0x88, 0x1E, 0xFB, 
	0xD6, 0x12, 0x34, 0x74, 0xDB, 0x49, 0x79, 0xB1, 
	0xD6, 0xFE, 0x89, 0x83, 0x18, 0x63, 0xA3, 0x27, 
	0xAD, 0x5D, 0x53, 0xBC, 0xE3, 0xB9, 0x51, 0x5E, 
	0x70, 0xC7, 0x93, 0x17, 0x98, 0x82, 0xDE, 0x29, 
	0x96, 0x45, 0x04, 0x81, 0x04, 0x2C, 0xB8, 0x57, 
	0x61, 0x91, 0x8E, 0x0B, 0xA4, 0x98, 0xCC, 0xB2, 
	0xAC, 0x2E, 0x3B, 0x5C, 0x7D, 0x0C, 0xDC, 0xDF, 
	0x9D, 0x42, 0x3A, 0xA7, 0x84, 0xF7, 0x6D, 0x0A, 
	0x1B, 0xE5, 0xB4, 0xDF, 0xFF, 0x80, 0x9E, 0x31, 
	0x3D, 0x3F, 0xEE, 0x2A, 0x00, 0xF2, 0xB8, 0x0F, 
	0xE0, 0xE7, 0x41, 0xBD, 0x4C, 0xAC, 0x63, 0x67, 
	0x63, 0xED, 0x71, 0xE5, 0x94, 0xB8, 0xBE, 0xB7, 
	0x5B, 0x0C, 0x88, 0x61, 0xAE, 0xBB, 0x9A, 0xAD, 
	0x9C, 0x70, 0x5A, 0xE4, 0xEB, 0x9C, 0x01, 0x42, 
	0x62, 0xA5, 0x07, 0xE6, 0x9C, 0x46, 0x74, 0x0B, 
	0xAC, 0x4E, 0x70, 0xFC, 0xF8, 0xD5, 0xF1, 0x94, 
	0x60, 0x83, 0x88, 0x41, 0x35, 0x6A, 0x70, 0x7D, 
	0xBF, 0xC9, 0x07, 0x10, 0x91, 0x89, 0x98, 0x4D, 
	0x53, 0xB0, 0x53, 0xAD, 0x91, 0x23, 0xEE, 0x12, 
	0xC5, 0x7C, 0x9C, 0xD4, 0xDE, 0x8B, 0xBB, 0xB9, 
	0x7D, 0x72, 0xCB, 0x20, 0x28, 0x27, 0xA1, 0x4B, 
	0x67, 0x7A, 0x84, 0x0F, 0xF9, 0xA3, 0x9D, 0x96, 
	0xAD, 0x33, 0x73, 0x74, 0x23, 0x37, 0x13, 0x97, 
	0xE7, 0xE1, 0xD1, 0x0D, 0xF4, 0xF2, 0x0F, 0xB0, 
	0x73, 0xD6, 0xDC, 0xBF, 0x04, 0xFF, 0x73, 0xC3, 
	0x2F, 0xE2, 0x79, 0x4B, 0x01, 0xB8, 0xD3, 0x37, 
	0xF0, 0x6B, 0x8B, 0x21, 0x1F, 0xA0, 0x2C, 0x3B, 
	0xFF, 0x60, 0xC5, 0x13, 0x41, 0xFF, 0x66, 0x8A, 
	0x26, 0xB3, 0xA7, 0xC7, 0xAD, 0x68, 0x83, 0xD8, 
	0x65, 0xDB, 0x65, 0x0E, 0x37, 0x12, 0x6B, 0x82, 
	0x87, 0x5F, 0xD8, 0x7E, 0x01, 0xBC, 0xDE, 0x6D, 
	0xEF, 0x6B, 0x4F, 0x18, 0x6B, 0x0C, 0x44, 0x30, 
	0x62, 0xFF, 0x21, 0x8F, 0xFD, 0x94, 0x4C, 0x7B, 
	0x6F, 0x0C, 0x51, 0xC1, 0xA5, 0xF7, 0x03, 0x96, 
	0xC7, 0xF3, 0xF7, 0xE0, 0x68, 0x81, 0xFB, 0x39, 
	0xF3, 0x94, 0xFD, 0xC2, 0xFB, 0x27, 0x1B, 0x33, 
	0xB7, 0x96, 0xDB, 0xE2, 0xA9, 0x31, 0x58, 0x14, 
	0x8C, 0x2A, 0xA0, 0x0B, 0xEB, 0x28, 0xF1, 0xBF, 
	0x09, 0x65, 0x01, 0xFC, 0x27, 0x63, 0x26, 0x04, 
	0x96, 0x40, 0x5A, 0x63, 0x0E, 0x96, 0x5B, 0x4A, 
	0x97, 0xAA, 0xEA, 0x1E, 0xCA, 0xE0, 0xFF, 0x91, 
	0xE9, 0x61, 0xB5, 0x44, 0xFF, 0x2F, 0x1F, 0x92, 
	0xE5, 0xCF, 0xAB, 0x38, 0xCE, 0x80, 0x4A, 0x8C, 
	0x98, 0x39, 0x2A, 0xAF, 0xF9, 0xB0, 0xDC, 0xC6, 
	0x29, 0x6A, 0xD2, 0x1A, 0xE7, 0xBE, 0x67, 0x17, 
	0xBE, 0x8A, 0x79, 0xC6, 0x65, 0xCA, 0x26, 0x88, 
	0x68, 0x26, 0x31, 0x09, 0xA2, 0xDC, 0xC5, 0xF1, 
	0x86, 0x12, 0x66, 0xA5, 0xAB, 0xDB, 0x20, 0x03, 
	0x37, 0xFD, 0xD4, 0xFD, 0x4A, 0x3D, 0xF4, 0xDE, 
	0xD7, 0x3C, 0x26, 0x7F, 0xB9, 0x19, 0xBC, 0x8B, 
	0xE9, 0x45, 0x2C, 0xF1, 0x68, 0x91, 0x68, 0x15, 
	0x8E, 0xDE, 0xA9, 0xEB, 0xC9, 0x16, 0x6A, 0xA2, 
	0x25, 0x23, 0x97, 0x0B, 0xCC, 0xD8, 0x84, 0x0A, 
	0x51, 0x29, 0x70, 0x24, 0xE8, 0x7D, 0x0E, 0xE1, 
	0x41, 0xA4, 0xAE, 0xBF, 0xFC, 0x5C, 0x43, 0xD2, 
	0xC8, 0x05, 0xB7, 0xD2, 0xC3, 0x79, 0x84, 0xF4, 
	0x29, 0x70, 0xF2, 0x48, 0x06, 0xFD, 0x4F, 0xFF, 
	0x6B, 0x5B, 0xDD, 0x2D, 0xED, 0xA1, 0xD0, 0xD1, 
	0xAE, 0x74, 0x81, 0xF3, 0x21, 0xD7, 0x4D, 0xE9, 
	0xA5, 0xAB, 0x3D, 0xAF, 0xC5, 0x68, 0x31, 0xAB, 
	0x23, 0x5D, 0x5B, 0x08, 0xBF, 0x91, 0x43, 0x37, 
	0x0E, 0x9E, 0xE4, 0x1D, 0xED, 0x05, 0xF9, 0x05, 
	0x6A, 0x0B, 0xDA, 0x75, 0x04, 0x60, 0x06, 0x57, 
	0x13, 0xF3, 0xE8, 0x72, 0x29, 0x70, 0xD6, 0x22, 
	0xF2, 0xCD, 0x6C, 0x51, 0x10, 0x9C, 0xCB, 0x59, 
	0xED, 0xF2, 0x86, 0x75, 0x21, 0xD5, 0x05, 0x67, 
	0x89, 0xEC, 0x30, 0x85, 0x01, 0x59, 0x88, 0xDB, 
	0x2C, 0x10, 0xA6, 0x9D, 0xEB, 0x67, 0x3E, 0x37, 
	0x58, 0xEA, 0x69, 0x69, 0x3A, 0x86, 0xB9, 0x2B, 
	0x82, 0x24, 0xF5, 0x5A, 0x2D, 0xFB, 0x49, 0xC8, 
	0xBC, 0xBA, 0xD4, 0x49, 0xA8, 0x28, 0xEE, 0x47, 
	0xEE, 0x5E, 0x27, 0x14, 0x43, 0x5A, 0xD7, 0x76, 
	0xBF, 0x6A, 0x64, 0xBA, 0x60, 0x45, 0xC1, 0x0F, 
	0xFF, 0x2E, 0x73, 0xCC, 0x73, 0x6E, 0x06, 0xD6, 
	0x64, 0x22, 0xFB, 0xA8, 0x40, 0x75, 0x4A, 0x75, 
	0x19, 0x35, 0x78, 0x78, 0x48, 0x70, 0x5D, 0x10, 
	0x99, 0x68, 0x17, 0x42, 0xEC, 0x9C, 0xF5, 0x10, 
	0x9E, 0x65, 0x1D, 0x56, 0xE8, 0xBA, 0xAE, 0xA7, 
	0x6A, 0x17, 0x52, 0xE8, 0x55, 0xC3, 0x4A, 0x9E, 
	0xBC, 0x6F, 0xA8, 0x2F, 0xD6, 0xCF, 0xBA, 0x33, 
	0xFD, 0x8E, 0xE0, 0x46, 0x11, 0xDD, 0x74, 0x57, 
	0x22, 0x09, 0x10, 0xC2, 0xA3, 0x5C, 0xA7, 0x0C, 
	0xFE, 0x06, 0x12, 0x95, 0xF2, 0x17, 0x14, 0x76, 
	0x1A, 0x18, 0x7E, 0xEA, 0xFD, 0xFC, 0x7C, 0x1E, 
	0x60, 0x7F, 0xA3, 0x12, 0x73, 0x06, 0xD8, 0x8C, 
	0x84, 0x68, 0x79, 0x00, 0x3E, 0x0B, 0xD5, 0xA4, 
	0xC6, 0xB5, 0xC5, 0x8D, 0xE7, 0x3D, 0xB5, 0x0A, 
	0x8A, 0x9C, 0x82, 0x25, 0x25, 0xAB, 0xA4, 0x06, 
	0x80, 0xF9, 0x58, 0xB1, 0x44, 0x64, 0x74, 0x3D, 
	0xAF, 0xFF, 0x50, 0xD5, 0xE3, 0xDC, 0x73, 0xFC, 
	0x1C, 0x42, 0x41, 0x9E, 0xC6, 0x41, 0x62, 0xFA, 
	0x8D, 0xB4, 0xEB, 0xA8, 0xEC, 0xF2, 0x6F, 0xB9, 
	0x87, 0x10, 0xA3, 0x93, 0xCE, 0x17, 0xFA, 0x55, 
	0xFC, 0x05, 0xF5, 0x39, 0x19, 0x24, 0x58, 0x53, 
	0xF1, 0xD1, 0x17, 0x01, 0xD8, 0x37, 0xC2, 0x9F, 
	0xB3, 0x59, 0x78, 0x72, 0xD8, 0x44, 0x9F, 0x28, 
	0xAB, 0x0E, 0x03, 0x19, 0xCF, 0x29, 0x7D, 0xE2, 
	0xD7, 0xDB, 0x17, 0x74, 0x66, 0x04, 0x8F, 0x85, 
	0xB1, 0x48, 0x4B, 0xFB, 0x17, 0xCE, 0x85, 0x92, 
	0xE1, 0x22, 0xFA, 0xDB, 0xA8, 0x05, 0xC0, 0x0B, 
	0xE3, 0xB4, 0x28, 0x89, 0x49, 0xCA, 0x43, 0x59, 
	0x8C, 0xCE, 0x2A, 0x2E, 0x62, 0x27, 0xC0, 0xFD, 
	0xB7, 0xFC, 0xD4, 0xF6, 0x7F, 0xA2, 0x10, 0xA5, 
	0x63, 0x22, 0xD1, 0x7D, 0x5C, 0xCA, 0x58, 0x6C, 
	0x9B, 0x42, 0x13, 0x03, 0x26, 0xF0, 0x30, 0x3B, 
	0x9D, 0x63, 0xFF, 0xCB, 0x42, 0xE7, 0x77, 0x3B, 
	0x94, 0xDC, 0x43, 0x28, 0xCC, 0x27, 0xE0, 0xD6, 
	0x14, 0x91, 0x44, 0x84, 0x99, 0x92, 0x19, 0x70, 
	0x2E, 0x53, 0x4E, 0x9D, 0x66, 0x56, 0x6A, 0x38, 
	0xBA, 0x91, 0x8F, 0x48, 0x65, 0x9F, 0x69, 0x99, 
	0x46, 0xC6, 0x83, 0x34, 0xAD, 0xE4, 0x2E, 0xD1, 
	0x0A, 0x28, 0x2D, 0xB5, 0xCA, 0xA8, 0x04, 0x50, 
	0x78, 0x46, 0x18, 0xCD, 0x9F, 0x16, 0xF2, 0xB4, 
	0x85, 0xB0, 0xDE, 0xF4, 0xBE, 0x95, 0x6B, 0x83, 
	0xA8, 0x2B, 0x4A, 0x24, 0x40, 0xB1, 0x81, 0x55, 
	0x64, 0x54, 0xCF, 0xD0, 0xE0, 0x5F, 0x85, 0xD1, 
	0xEE, 0x74, 0x24, 0xD8, 0x50, 0xB7, 0x79, 0x30, 
	0xFC, 0x8F, 0x36, 0x52, 0x90, 0x9B, 0xC8, 0x3B, 
	0xD0, 0x98, 0x5B, 0x0B, 0xA2, 0x9D, 0x63, 0xF4, 
	0x60, 0xE3, 0x68, 0x82, 0x9B, 0x43, 0x3A, 0x0C, 
	0x10, 0x36, 0xF0, 0xD9, 0x9F, 0x32, 0x22, 0xCA, 
	0x58, 0x68, 0x08, 0xFF, 0x96, 0x60, 0x7A, 0x76, 
	0x75, 0x15, 0x1E, 0x3E, 0xE4, 0x36, 0xB3, 0x47, 
	0x73, 0xD4, 0x49, 0x48, 0xBD, 0xCF, 0x4E, 0xFD, 
	0x2B, 0xB3, 0x1C, 0x33, 0x9F, 0xD8, 0x64, 0x31, 
	0x0B, 0xFF, 0x37, 0xD1, 0x7F, 0x92, 0x39, 0xBA, 
	0xB6, 0x9C, 0xCB, 0xBA, 0x79, 0x1A, 0x2E, 0x4E, 
	0x12, 0xB5, 0x99, 0xFC, 0xF5, 0xA4, 0x16, 0xCE, 
	0x80, 0xC4, 0x81, 0x30, 0x78, 0x47, 0x61, 0xA1, 
	0x08, 0xFC, 0xCD, 0xBF, 0x0A, 0x7C, 0x83, 0x87, 
	0x56, 0x07, 0xA6, 0x02, 0xA1, 0xE9, 0x77, 0x85, 
	0x4E, 0xCC, 0x58, 0x89, 0xB4, 0x62, 0x1F, 0x01, 
	0x5F, 0x42, 0x69, 0xE6, 0x33, 0x69, 0x0F, 0x0B, 
	0xD3, 0xF8, 0x56, 0x5D, 0x3E, 0x14, 0xCC, 0x8F, 
	0x0E, 0xE0, 0x72, 0x8A, 0x4D, 0x0F, 0xE4, 0xCB, 
	0x3C, 0x38, 0xB1, 0x1C, 0xA4, 0x42, 0x54, 0xD8, 
	0x8F, 0x19, 0xAB, 0xAD, 0x0D, 0xEC, 0x47, 0xAB, 
	0x7B, 0xF9, 0x1D, 0xE2, 0xFF, 0xFE, 0x24, 0xBA, 
	0x7F, 0x4E, 0xB3, 0x55, 0xCA, 0xE6, 0x6D, 0x02, 
	0x8B, 0xEB, 0xE4, 0x5F, 0x79, 0xC8, 0xB0, 0x6D, 
	0x4C, 0xD0, 0x5B, 0xC4, 0x87, 0xD9, 0x3D, 0xB6, 
	0xDB, 0xC6, 0x97, 0xC9, 0x1F, 0xD4, 0x98, 0xE1, 
	0x08, 0x96, 0x56, 0x96, 0x06, 0x99, 0x83, 0xA5, 
	0x65, 0x18, 0x39, 0x1E, 0x85, 0x5C, 0xAA, 0xF9, 
	0xB4, 0x48, 0x7B, 0xA8, 0x86, 0x64, 0x1D, 0x56, 
	0xE0, 0x8E, 0x13, 0x62, 0x0B, 0xF2, 0x2E, 0x7F, 
	0x9B, 0xD9, 0xFE, 0xD8, 0x61, 0x36, 0x9C, 0xC3, 
	0x1D, 0xCF, 0x96, 0xE2, 0x26, 0x65, 0x53, 0xFF, 
	0xEB, 0x6D, 0x66, 0x8A, 0xB2, 0x6A, 0x21, 0x4A, 
	0x6E, 0xBC, 0x9E, 0x19, 0xC9, 0x9E, 0xA6, 0x36, 
	0xF2, 0xE5, 0xB9, 0xCA, 0xE8, 0xDA, 0xF8, 0xCD, 
	0x07, 0x02, 0xB8, 0x3C, 0xEC, 0x0C, 0x6A, 0xB2, 
	0x8B, 0x6A, 0xAF, 0x6B, 0x00, 0xE3, 0x06, 0x16, 
	0xA2, 0x1F, 0x00, 0x7F, 0x95, 0xFF, 0xDB, 0x0F, 
	0xBD, 0xD0, 0xCC, 0x0A, 0xCC, 0x77, 0x1B, 0xFC, 
	0x6F, 0x70, 0x65, 0x14, 0x79, 0xE0, 0x80, 0x84, 
	0x93, 0x76, 0x72, 0x46, 0x75, 0xF0, 0x9B, 0x04, 
	0xFF, 0x89, 0x9F, 0x44, 0x39, 0xC8, 0xC9, 0x94, 
	0x5A, 0x36, 0xFD, 0x94, 0x00, 0x37, 0xD2, 0xCD, 
	0xAC, 0xEB, 0xEE, 0x69, 0x52, 0x36, 0x45, 0x27, 
	0x79, 0xFD, 0xA2, 0xD3, 0xD4, 0xDF, 0x08, 0x30, 
	0x7A, 0x19, 0xD5, 0x16, 0x51, 0xB3, 0x83, 0x01, 
	0xC5, 0x1D, 0x74, 0x60, 0x43, 0x62, 0x6F, 0x3B, 
	0x2A, 0x1E, 0x72, 0x73, 0x6A, 0xB8, 0xB3, 0xA2, 
	0x5F, 0xEA, 0x0F, 0x71, 0x46, 0x9E, 0xD8, 0x5F, 
	0xB3, 0xBC, 0x53, 0x0B, 0x53, 0xF1, 0x5A, 0xFC, 
	0x31, 0x3E, 0x1A, 0x67, 0x2A, 0x6C, 0x7B, 0xB1, 
	0x88, 0x36, 0xDE, 0xC8, 0x40, 0xCA, 0x45, 0x7D, 
	0x87, 0xB6, 0x7D, 0xA8, 0x8E, 0x4C, 0xD9, 0x55, 
	0xFD, 0x92, 0x2C, 0x0C, 0x2A, 0x05, 0xFF, 0xE5, 
	0x0F, 0x2E, 0x2A, 0x9D, 0xC5, 0x63, 0x39, 0x50, 
	0x56, 0xB2, 0xC1, 0x11, 0xAB, 0xEC, 0xA5, 0xDE, 
	0x09, 0xD0, 0x7B, 0x55, 0x55, 0x39, 0xCB, 0x41, 
	0xF0, 0x99, 0x9C, 0xCB, 0x98, 0x69, 0xDC, 0x9F, 
	0x76, 0x4C, 0x07, 0xB8, 0x54, 0x8F, 0x0D, 0x71, 
	0x92, 0xDD, 0x0A, 0x6B, 0xAE, 0x93, 0x3A, 0x50, 
	0x55, 0xA2, 0x37, 0x7F, 0x29, 0xD7, 0xE5, 0x46, 
	0xA6, 0x53, 0xAD, 0x4F, 0x59, 0x8B, 0x36, 0xDC, 
	0x4E, 0xD1, 0x11, 0x94, 0x98, 0xAC, 0xDF, 0x0B, 
	0x80, 0xF4, 0xCB, 0x07, 0x92, 0xE8, 0x2A, 0x48, 
	0xEF, 0x60, 0xC0, 0xB3, 0x5C, 0xE2, 0x20, 0x34, 
	0xA0, 0x06, 0x66, 0x0C, 0xEE, 0xCA, 0xCE, 0x8F, 
	0xF2, 0x3A, 0x27, 0x21, 0x88, 0x6B, 0xCF, 0x82, 
	0x3C, 0x72, 0x11, 0x73, 0x0F, 0x3C, 0x11, 0xCE, 
	0xAF, 0x60, 0xF4, 0xDB, 0xC5, 0x58, 0xB9, 0xD9, 
	0xC0, 0xA3, 0xB2, 0xD0, 0xBF, 0x4D, 0x1D, 0xFF, 
	0x51, 0xCC, 0xA6, 0x33, 0x5C, 0x2B, 0xD0, 0x42, 
	0xBC, 0x01, 0x27, 0x02, 0xA8, 0x55, 0xD8, 0x5A, 
	0x6C, 0x11, 0x89, 0xCB, 0xF7, 0xCF, 0x83, 0x1C, 
	0x02, 0x59, 0x88, 0x51, 0x05, 0x95, 0xF4, 0x19, 
	0xC9, 0xFD, 0x68, 0x36, 0xA5, 0xA9, 0x53, 0xBE, 
	0xFF, 0x4C, 0x01, 0x3F, 0x7F, 0x52, 0xF1, 0xDB, 
	0x6F, 0x43, 0x84, 0x71, 0xD1, 0x95, 0x82, 0x7C, 
	0x6F, 0xE5, 0xC0, 0xB8, 0xE4, 0x9C, 0xF0, 0x1A, 
	0x49, 0x18, 0xFD, 0x6D, 0x5C, 0xB1, 0x38, 0x33, 
	0x0E, 0x2C, 0xF6, 0x6C, 0xEF, 0xCA, 0xE2, 0x9D, 
	0x57, 0xB1, 0xA5, 0x96, 0x73, 0xF0, 0xEE, 0xA8, 
	0x22, 0x8B, 0x02, 0xAD, 0x72, 0x96, 0x2A, 0x51, 
	0x2F, 0x77, 0x9F, 0x10, 0x8F, 0xD4, 0xF4, 0xFE, 
	0xE2, 0x46, 0x65, 0xD7, 0x98, 0x60, 0xAC, 0xAE, 
	0xD4, 0x77, 0x59, 0x3D, 0x33, 0x6B, 0x44, 0x75, 
	0x74, 0xFB, 0xDC, 0xF7, 0xA0, 0xC1, 0x16, 0x65, 

	/* Database Page 20 */

	0xFF, 0x38, 0x6B, 0xBB, 0x16, 0xF3, 0x8B, 0x44, 
	0xB2, 0x47, 0x84, 0x72, 0x7A, 0x77, 0x2B, 0xD8, 
	0xBF, 0x43, 0x58, 0x88, 0xA5, 0xAF, 0x7B, 0x06, 
	0x42, 0xDE, 0xA9, 0xFF, 0x26, 0x9F, 0xE6, 0x81, 
	0x25, 0xB9, 0x4A, 0x31, 0xAE, 0x70, 0xBF, 0xC3, 
	0x59, 0x21, 0x37, 0x10, 0x56, 0x0C, 0xA5, 0x3B, 
	0xF6, 0xFD, 0x90, 0xC2, 0xA3, 0x08, 0xDB, 0x0E, 
	0xC7, 0xC6, 0x6C, 0xC0, 0xFD, 0xAE, 0xD1, 0x5B, 
	0x93, 0x10, 0xA8, 0x0B, 0x76, 0x96, 0x0E, 0xD4, 
	0x1E, 0x53, 0xB8, 0x87, 0x3A, 0x5E, 0x8C, 0xCA, 
	0xC5, 0x65, 0xDB, 0x5F, 0xEF, 0x69, 0x51, 0x7B, 
	0xDB, 0x62, 0xE2, 0xA9, 0x7B, 0x4B, 0x3E, 0x00, 
	0x17, 0x3F, 0xB6, 0x69, 0xE1, 0xEF, 0xDF, 0x88, 
	0x4A, 0x92, 0xC1, 0xA0, 0x78, 0x78, 0x55, 0xDE, 
	0xF0, 0x0E, 0x63, 0x07, 0x58, 0x96, 0x59, 0xEB, 
	0x50, 0x2A, 0x1C, 0x5D, 0x42, 0x0F, 0x4C, 0x3F, 
	0xF9, 0xFF, 0x51, 0xD6, 0xC3, 0x69, 0x10, 0x0E, 
	0x3A, 0x24, 0xE1, 0x40, 0xF5, 0x12, 0xDC, 0x55, 
	0xA3, 0x0A, 0x12, 0xD8, 0x30, 0x71, 0x8E, 0x1C, 
	0x6F, 0xB1, 0xF1, 0xB2, 0x4D, 0x46, 0xAA, 0xD0, 
	0x36, 0x66, 0xEA, 0x96, 0xD3, 0x18, 0xD4, 0xA1, 
	0x51, 0x6A, 0x06, 0xFC, 0x7A, 0xB5, 0x0C, 0xED, 
	0x56, 0x3A, 0xE2, 0x09, 0x14, 0x19, 0x6F, 0x48, 
	0x9F, 0x66, 0x26, 0x34, 0x78, 0x26, 0xE6, 0xB4, 
	0x73, 0xBB, 0x8A, 0xB7, 0x74, 0x54, 0xA8, 0x34, 
	0x04, 0x1C, 0xA3, 0x4E, 0x98, 0x43, 0x16, 0x53, 
	0x64, 0x08, 0x8C, 0xFE, 0xBE, 0x5A, 0xAA, 0xE9, 
	0x6E, 0xF5, 0xA2, 0xD7, 0x4D, 0xA3, 0x2B, 0x8E, 
	0x9E, 0xEF, 0x58, 0xF1, 0x0D, 0x85, 0xBF, 0x74, 
	0x28, 0x39, 0x75, 0x49, 0xC8, 0x00, 0xF2, 0xBD, 
	0x96, 0x02, 0x6A, 0xDC, 0x8C, 0x34, 0xA4, 0x34, 
	0xDC, 0x4C, 0xE0, 0x4D, 0x6E, 0x79, 0x56, 0x5F, 
	0xD1, 0xBB, 0xFF, 0x82, 0xD6, 0x97, 0xF3, 0x99, 
	0x2F, 0x16, 0x41, 0x7F, 0xAA, 0xA3, 0xDE, 0x82, 
	0x8B, 0xF3, 0x72, 0xE5, 0xFE, 0x4B, 0xB7, 0xFB, 
	0xFA, 0x25, 0x91, 0xA7, 0x44, 0xF0, 0x7B, 0x40, 
	0x8D, 0xDC, 0xDB, 0x4E, 0xB8, 0xE5, 0x2A, 0xD1, 
	0xB6, 0x3B, 0xFF, 0xA0, 0x66, 0x92, 0xCB, 0x71, 
	0x1F, 0xC3, 0x03, 0x9E, 0x44, 0x01, 0x03, 0x73, 
	0x92, 0x73, 0x94, 0x1D, 0x8F, 0xB9, 0x1D, 0x59, 
	0x5D, 0xEA, 0xB2, 0x97, 0x2F, 0xAA, 0x05, 0x47, 
	0x76, 0x21, 0x65, 0x5F, 0xCA, 0x36, 0x4E, 0xD3, 
	0x5C, 0x37, 0x53, 0x8F, 0x81, 0x92, 0x4A, 0x48, 
	0x27, 0x50, 0x5B, 0x91, 0x1A, 0x9F, 0x44, 0xED, 
	0x2B, 0xA2, 0x45, 0xDE, 0x71, 0x4C, 0x69, 0x57, 
	0x5E, 0xF9, 0x5F, 0xF0, 0x31, 0x08, 0x67, 0x5F, 
	0x09, 0x8A, 0xB5, 0x19, 0x29, 0xE7, 0x67, 0x8C, 
	0x57, 0x21, 0x48, 0xE0, 0xA2, 0x51, 0xEF, 0xBE, 
	0x56, 0x11, 0x67, 0xFF, 0x5A, 0xA7, 0x96, 0x7E, 
	0x78, 0xF1, 0x09, 0x83, 0xD3, 0x3A, 0xA0, 0x5D, 
	0x2C, 0x75, 0x5D, 0xA1, 0x6B, 0x6F, 0x43, 0x0D, 
	0x96, 0xDB, 0x74, 0x4D, 0x67, 0xD4, 0xF7, 0x7F, 
	0xCA, 0x78, 0x79, 0x6D, 0x7E, 0xC6, 0xEF, 0x4D, 
	0xD3, 0xC9, 0x3B, 0x4F, 0x7B, 0xD3, 0x5B, 0x30, 
	0x07, 0x89, 0xA2, 0x5F, 0x48, 0x31, 0x5C, 0xE7, 
	0x77, 0x65, 0x1C, 0x6D, 0xD6, 0x22, 0x08, 0x67, 
	0x32, 0x36, 0x59, 0x37, 0xE8, 0xDD, 0xCB, 0x70, 
	0x55, 0x19, 0xBD, 0xE7, 0xE1, 0x94, 0x09, 0xF5, 
	0xE6, 0x51, 0x25, 0xA2, 0xAC, 0x50, 0xAA, 0xDF, 
	0x8C, 0x82, 0x0C, 0x11, 0x6B, 0xF4, 0xC9, 0x76, 
	0xD6, 0xBA, 0xCF, 0x47, 0x5A, 0x6D, 0x3F, 0xAD, 
	0x2E, 0x3D, 0x6C, 0xE1, 0xA7, 0x2F, 0x5F, 0x3B, 
	0x0E, 0xC0, 0xA9, 0x12, 0xCE, 0xFC, 0x33, 0xE2, 
	0xCD, 0xBF, 0x27, 0x90, 0x35, 0x7A, 0x9F, 0x1E, 
	0xD6, 0x9B, 0x80, 0x7B, 0xFF, 0x33, 0xC7, 0x6D, 
	0xA0, 0x5A, 0xB8, 0xD0, 0x0E, 0x38, 0xC3, 0x7E, 
	0x7D, 0xEA, 0x55, 0x44, 0x4C, 0xC6, 0xE6, 0xA6, 
	0xF6, 0x50, 0xB4, 0x40, 0x7B, 0x72, 0xD1, 0xAE, 
	0xED, 0xF4, 0xD9, 0x2A, 0x28, 0x6C, 0x8B, 0x2C, 
	0xD2, 0xBA, 0xDD, 0x12, 0xE6, 0x39, 0xC8, 0x26, 
	0x16, 0x37, 0xAF, 0x3C, 0x06, 0x2F, 0x57, 0xE7, 
	0x61, 0x10, 0xA0, 0x58, 0x0C, 0xAA, 0x97, 0xFD, 
	0x42, 0x10, 0x75, 0x22, 0x52, 0xA1, 0x84, 0xE4, 
	0x68, 0x1B, 0x4A, 0xE4, 0x77, 0xF2, 0xD9, 0xE7, 
	0x91, 0xD6, 0x2F, 0x56, 0x03, 0x18, 0x74, 0x47, 
	0xCD, 0x33, 0x25, 0x96, 0xDD, 0xB3, 0x87, 0x53, 
	0x1E, 0xA7, 0xF0, 0xC1, 0xB5, 0x72, 0x88, 0x08, 
	0xCB, 0x25, 0x8E, 0x2A, 0x49, 0xC2, 0x04, 0xF5, 
	0x49, 0x5A, 0x63, 0x89, 0x61, 0xAC, 0x86, 0xB8, 
	0xE6, 0x98, 0x0E, 0x9E, 0x86, 0x06, 0x4E, 0x28, 
	0x51, 0xE4, 0xE9, 0x1B, 0x5D, 0xFF, 0xEF, 0xCD, 
	0xF9, 0x3C, 0xDF, 0xED, 0xBB, 0x7E, 0x10, 0xBF, 
	0x12, 0xA8, 0xBC, 0xEC, 0x14, 0x34, 0xC1, 0x9D, 
	0x47, 0xB9, 0x3F, 0xFD, 0xF2, 0xC9, 0xD5, 0x6A, 
	0x82, 0x1D, 0xE5, 0x5A, 0x1C, 0xF2, 0x3A, 0x6E, 
	0x1B, 0x1B, 0x5F, 0xE3, 0x3E, 0xB5, 0x18, 0x15, 
	0x62, 0x4B, 0x24, 0x30, 0x8D, 0x31, 0x8C, 0x6D, 
	0x7D, 0xAB, 0x24, 0x06, 0xC3, 0x16, 0xB0, 0x96, 
	0x2C, 0x0F, 0x46, 0xF4, 0x6E, 0x59, 0xC6, 0x8D, 
	0xA2, 0x3B, 0x37, 0x3D, 0x99, 0x0A, 0xF7, 0x07, 
	0x55, 0x11, 0x57, 0x31, 0x1A, 0x3F, 0x30, 0xCA, 
	0xC9, 0x35, 0xDE, 0xEB, 0x82, 0x79, 0xE3, 0x80, 
	0xB3, 0xB5, 0x46, 0x85, 0x15, 0x50, 0x5E, 0xB4, 
	0xD6, 0x32, 0x2F, 0x7C, 0x6C, 0x12, 0x69, 0x58, 
	0xEF, 0x97, 0x14, 0x6E, 0x60, 0x20, 0x8D, 0xE0, 
	0xD9, 0x7E, 0x26, 0x5E, 0x80, 0xDF, 0x80, 0x86, 
	0x93, 0x20, 0x48, 0x24, 0x8F, 0x9E, 0xFF, 0xEA, 
	0x76, 0x4D, 0x90, 0xA1, 0xB9, 0x2D, 0xFE, 0xC0, 
	0xC0, 0x4A, 0x0A, 0x35, 0xC1, 0x3F, 0x21, 0x2E, 
	0xA3, 0x0E, 0x20, 0xAA, 0x03, 0x91, 0x98, 0xCD, 
	0x97, 0x89, 0xDC, 0x6D, 0xF9, 0x56, 0xB0, 0xF0, 
	0x53, 0x02, 0x97, 0x13, 0xA4, 0x22, 0x2A, 0x63, 
	0x88, 0x1A, 0xF1, 0x0F, 0x85, 0x11, 0xB1, 0x51, 
	0xA4, 0x8D, 0x44, 0x82, 0x15, 0x31, 0x89, 0x99, 
	0x1F, 0x89, 0x7B, 0xE2, 0x77, 0xA2, 0xAE, 0xDC, 
	0x24, 0x22, 0x8D, 0x2B, 0xDD, 0x32, 0xDF, 0x4B, 
	0x52, 0xD2, 0xB4, 0x9D, 0x99, 0x9B, 0xD4, 0xE6, 
	0xFF, 0x95, 0xCD, 0x69, 0x1E, 0xEB, 0x30, 0x8B, 
	0x8B, 0xA8, 0xEA, 0x1C, 0xDC, 0xEF, 0xF9, 0xD5, 
	0xA5, 0xF8, 0xD9, 0x11, 0xAC, 0x4E, 0x9D, 0x44, 
	0x10, 0x87, 0xD3, 0x12, 0xB3, 0x6B, 0x2F, 0xE4, 
	0x9E, 0xBD, 0x8C, 0xA3, 0x54, 0x50, 0x33, 0x94, 
	0x29, 0x0C, 0xFA, 0x9E, 0x67, 0xAC, 0xC6, 0xFF, 
	0xAA, 0x24, 0x17, 0xD5, 0xE0, 0xA4, 0xB6, 0x0F, 
	0xC1, 0x32, 0xD9, 0x86, 0x90, 0xF2, 0x0D, 0xA2, 
	0xC3, 0x56, 0x96, 0x2C, 0xC3, 0x61, 0x6C, 0x11, 
	0x87, 0x9B, 0x60, 0x84, 0xB8, 0xBD, 0xA8, 0x77, 
	0x5B, 0x2C, 0x99, 0x5D, 0xF9, 0x61, 0x7E, 0x78, 
	0x90, 0x94, 0x7B, 0x9A, 0x1E, 0xB5, 0xC5, 0x09, 
	0x4D, 0x88, 0xD2, 0xA8, 0xA5, 0x84, 0xDA, 0x9D, 
	0x5E, 0xF5, 0x63, 0x4C, 0xC3, 0x7A, 0x82, 0xC2, 
	0xD1, 0x94, 0x93, 0xAE, 0x42, 0x25, 0x86, 0xED, 
	0x7C, 0xFE, 0x2E, 0xBE, 0x0B, 0xF5, 0x39, 0xB8, 
	0x0F, 0xA4, 0x77, 0x77, 0xE5, 0xFB, 0x94, 0x00, 
	0x2D, 0xE4, 0xAA, 0x08, 0xDD, 0x5C, 0x0F, 0xF4, 
	0xB5, 0x9C, 0xD4, 0x3A, 0x32, 0xFD, 0x20, 0xCA, 
	0xAE, 0xD6, 0x0D, 0x26, 0xBA, 0xB9, 0xE8, 0xE4, 
	0x96, 0x76, 0x61, 0x64, 0x61, 0x05, 0x2B, 0x45, 
	0x64, 0x9B, 0xFD, 0x00, 0x33, 0xBC, 0x0C, 0xFC, 
	0xFF, 0x67, 0x90, 0x4B, 0xA2, 0x8E, 0x56, 0xE2, 
	0xBC, 0xB1, 0x4C, 0xCE, 0x1B, 0xC8, 0x69, 0x5D, 
	0x3D, 0xFA, 0x48, 0xC0, 0x59, 0xF4, 0xAF, 0x52, 
	0xC2, 0x87, 0xB2, 0x6B, 0x51, 0x9A, 0x30, 0xAC, 
	0x25, 0xB9, 0x0C, 0xEA, 0x3F, 0xD7, 0x7C, 0x6E, 
	0xD2, 0x0E, 0xBC, 0x1F, 0x86, 0xC9, 0x7E, 0x2B, 
	0x51, 0x4C, 0xED, 0x3E, 0x85, 0x94, 0xC8, 0xB1, 
	0x4F, 0x31, 0xD2, 0x91, 0xD3, 0xE9, 0x52, 0x50, 
	0x1E, 0x27, 0x5C, 0xBE, 0x77, 0x33, 0xC1, 0xA6, 
	0x89, 0x7A, 0xC4, 0x8D, 0x5E, 0x14, 0x6D, 0x47, 
	0x40, 0x7F, 0x38, 0x30, 0x53, 0x1E, 0x81, 0xC0, 
	0x17, 0xF5, 0x4A, 0x2C, 0x3B, 0x3D, 0x2C, 0xBA, 
	0x64, 0xE2, 0x3C, 0xFC, 0xA1, 0xB8, 0xC9, 0x57, 
	0x6D, 0xAD, 0x1F, 0x9F, 0x2C, 0x20, 0x89, 0x3A, 
	0x35, 0xC7, 0x65, 0x72, 0xCF, 0x79, 0x03, 0x5A, 
	0xB9, 0xBC, 0xB7, 0xB4, 0x38, 0x89, 0x88, 0x6F, 
	0x63, 0xFF, 0x94, 0x16, 0x39, 0xA2, 0x49, 0x92, 
	0xE1, 0x2E, 0x53, 0xC3, 0xF1, 0x0B, 0x57, 0x0D, 
	0x13, 0x88, 0x04, 0x6A, 0xD6, 0x8F, 0xB9, 0xCE, 
	0x40, 0xF9, 0x86, 0xEF, 0x9F, 0x8F, 0xC1, 0xCC, 
	0x61, 0x42, 0x95, 0x55, 0xC4, 0xA6, 0x97, 0x8C, 
	0x2A, 0x87, 0xE0, 0xE4, 0x95, 0x92, 0xDF, 0x9A, 
	0x3D, 0xAD, 0x24, 0x64, 0xCD, 0xFD, 0x9D, 0xB0, 
	0x70, 0xF0, 0x0A, 0xBF, 0xC0, 0x79, 0x58, 0x56, 
	0x43, 0x95, 0x5A, 0x54, 0x49, 0x57, 0x9E, 0x5C, 
	0xB6, 0xB1, 0x69, 0x1B, 0x49, 0x5E, 0x52, 0x17, 
	0x91, 0x9F, 0x7E, 0xCE, 0x06, 0x4E, 0xE7, 0x1C, 
	0xD2, 0x27, 0xF2, 0x22, 0x6F, 0x9F, 0x4F, 0x96, 
	0x45, 0xE0, 0x5A, 0xED, 0x81, 0xB4, 0x96, 0xDE, 
	0xED, 0xBA, 0x6D, 0x3C, 0xA8, 0xC2, 0xF9, 0x67, 
	0x43, 0x3C, 0x87, 0xEF, 0xA9, 0x76, 0x14, 0xAB, 
	0xC4, 0xD7, 0x69, 0x8A, 0xFF, 0x6F, 0x65, 0x8C, 
	0x1E, 0x80, 0xFF, 0x5E, 0xC2, 0x24, 0xBF, 0x20, 
	0x12, 0x31, 0x35, 0xB6, 0x3D, 0x8C, 0x5A, 0xD8, 
	0xF7, 0x14, 0x3D, 0xA8, 0x12, 0xB9, 0xC4, 0x36, 
	0x1F, 0xF5, 0xBA, 0xBA, 0x3F, 0x33, 0x55, 0x2F, 
	0xF2, 0x6D, 0x17, 0xE7, 0x80, 0x6D, 0x51, 0xC9, 
	0x6F, 0x5C, 0x2D, 0x9F, 0xEC, 0x4D, 0x75, 0x90, 
	0x13, 0xAC, 0x94, 0xF0, 0x52, 0xB7, 0xC7, 0xD1, 
	0x71, 0x35, 0x09, 0xF6, 0x13, 0x74, 0xCC, 0x43, 
	0xEA, 0x57, 0x3A, 0xB8, 0x7B, 0x21, 0x15, 0x44, 
	0xC7, 0xD6, 0x84, 0x13, 0xB9, 0xF5, 0x84, 0xDD, 
	0x3B, 0x25, 0xDD, 0x23, 0x71, 0x78, 0x1D, 0x60, 
	0xCC, 0xD6, 0xA1, 0xBA, 0x20, 0x13, 0x60, 0x9A, 
	0x00, 0x09, 0xC3, 0xE5, 0xB5, 0xA9, 0x8F, 0x1F, 
	0x09, 0x52, 0xA5, 0x5F, 0x75, 0xC6, 0xF9, 0x44, 
	0xB0, 0x8D, 0xBD, 0x28, 0x23, 0x6B, 0x8C, 0x32, 
	0x1A, 0xC0, 0x8C, 0x53, 0x7A, 0xDE, 0x84, 0x05, 
	0x89, 0x7D, 0x3F, 0xFF, 0x7F, 0x1C, 0x71, 0x3E, 
	0x75, 0xF1, 0x57, 0x27, 0x39, 0xDF, 0x5F, 0x42, 
	0x2D, 0x94, 0x19, 0x99, 0x4A, 0x13, 0x29, 0x18, 
	0xF7, 0xE0, 0x0D, 0xE6, 0xA2, 0xDC, 0x2F, 0xF7, 
	0x06, 0x82, 0xDA, 0xB8, 0xBF, 0x86, 0x68, 0xDF, 
	0x58, 0x92, 0x68, 0x17, 0x17, 0x9E, 0xB0, 0xD6, 
	0xDD, 0xE6, 0x16, 0x5D, 0x90, 0x2D, 0x73, 0x23, 
	0x5B, 0x17, 0xE2, 0x5D, 0x47, 0xDC, 0xB4, 0xCD, 
	0xF4, 0x98, 0xF0, 0xFF, 0xDB, 0x93, 0xFB, 0x4B, 
	0xE9, 0x28, 0x1D, 0x90, 0x75, 0xE0, 0x67, 0xC8, 
	0x8F, 0xA7, 0x7A, 0x06, 0xD4, 0x15, 0x89, 0xE0, 
	0xBD, 0x60, 0x6F, 0x49, 0x9A, 0xE8, 0x9B, 0xAC, 
	0x9A, 0x94, 0x43, 0x7C, 0x60, 0x98, 0x66, 0x33, 
	0x98, 0xDD, 0xBC, 0x49, 0x44, 0x17, 0x54, 0xFC, 
	0x3D, 0x56, 0xCD, 0x85, 0x0A, 0xD3, 0x15, 0x45, 
	0xCA, 0xA6, 0x39, 0x23, 0x59, 0xF9, 0xA1, 0x78, 
	0x43, 0x93, 0x6F, 0x49, 0xFF, 0xE5, 0x2A, 0xCD, 
	0xA0, 0xFA, 0x97, 0x53, 0xF5, 0x6C, 0x15, 0x4C, 
	0xF5, 0x87, 0x0B, 0xB0, 0xD8, 0x14, 0x3A, 0xC8, 
	0x00, 0x72, 0x3E, 0x0A, 0xB6, 0x27, 0x5A, 0xD0, 
	0x85, 0xE0, 0x0C, 0xD5, 0xEF, 0xEF, 0xB6, 0x99, 
	0xB3, 0xF7, 0x1E, 0x24, 0x8F, 0x6C, 0x84, 0xFE, 
	0x15, 0xFD, 0x9D, 0x25, 0x93, 0x4A, 0x5E, 0x18, 
	0x1B, 0xCE, 0x7A, 0x47, 0x72, 0x47, 0xFC, 0x52, 
	0xE5, 0xBB, 0xA8, 0xB0, 0xEF, 0xC0, 0xCD, 0xC8, 
	0x81, 0x5D, 0xB3, 0x47, 0x60, 0x89, 0xB1, 0x34, 
	0x84, 0xB4, 0x69, 0x11, 0xA3, 0x88, 0x93, 0xEA, 
	0x6B, 0x2C, 0x2A, 0xA8, 0x94, 0xAA, 0xB1, 0x1E, 
	0x05, 0x71, 0x58, 0x32, 0x37, 0x8E, 0x44, 0x79, 
	0xE6, 0xB3, 0xE7, 0x7D, 0x47, 0x90, 0xCB, 0x74, 
	0x14, 0xE8, 0x19, 0x1F, 0x14, 0xF6, 0xE9, 0x73, 
	0xF8, 0xA6, 0x74, 0x68, 0xB8, 0xCB, 0x57, 0xBA, 
	0x61, 0xEA, 0x1B, 0xD7, 0x9D, 0xFF, 0x16, 0xE8, 
	0x01, 0xDC, 0xCB, 0x0E, 0x9E, 0x70, 0x0C, 0x32, 
	0xAA, 0x27, 0xEB, 0x69, 0x4D, 0xBA, 0xCD, 0x5C, 
	0x83, 0x1C, 0x01, 0x3E, 0x76, 0xE5, 0x7D, 0xA1, 
	0x71, 0x23, 0xFD, 0x55, 0x28, 0xEA, 0xF4, 0xC6, 
	0xAA, 0x08, 0x4F, 0x3F, 0x97, 0x46, 0x17, 0xD5, 
	0xB2, 0xD1, 0x6C, 0xFA, 0x9B, 0x1D, 0x0F, 0x04, 
	0xE6, 0x22, 0x7C, 0xA5, 0x4D, 0x61, 0xC7, 0x3A, 
	0xEF, 0x67, 0x97, 0xBC, 0xE0, 0x1B, 0xCE, 0xF3, 
	0x6B, 0xF4, 0xC0, 0xFF, 0x2F, 0xFC, 0x64, 0x3B, 
	0x22, 0x86, 0xDF, 0x3F, 0x97, 0x16, 0x3E, 0x10, 
	0xC7, 0xC4, 0xD0, 0xF7, 0xAA, 0x68, 0xA5, 0x80, 
	0xEA, 0x46, 0x13, 0x22, 0x1E, 0xB0, 0x02, 0xB0, 
	0x87, 0xB6, 0xA8, 0x9C, 0x45, 0x8F, 0x23, 0xFE, 
	0x33, 0x63, 0xA5, 0xE3, 0x1C, 0x64, 0x65, 0x8E, 
	0x6C, 0x89, 0x41, 0x32, 0x41, 0x17, 0xED, 0x64, 
	0xD1, 0xCC, 0x57, 0x22, 0xA2, 0x84, 0xFF, 0x4B, 
	0xDD, 0x97, 0x10, 0x9F, 0xF0, 0x87, 0x29, 0xE9, 
	0xD0, 0x61, 0x98, 0x96, 0x7F, 0x08, 0xBD, 0x53, 
	0xE6, 0x76, 0xBF, 0xEA, 0x96, 0x8B, 0x3D, 0x20, 
	0x6F, 0x65, 0x0D, 0xB3, 0x5C, 0x7B, 0x05, 0x50, 
	0xED, 0x63, 0x43, 0x0B, 0x5E, 0x43, 0xA0, 0xD0, 
	0xB2, 0x42, 0xB7, 0xD3, 0x62, 0x0D, 0xEB, 0x6C, 
	0x82, 0x4E, 0x2B, 0xAB, 0xF0, 0x2C, 0xBB, 0x19, 
	0x90, 0x2B, 0x31, 0x28, 0xBE, 0x60, 0x9D, 0xAF, 
	0x94, 0x7F, 0xF2, 0xE1, 0xCE, 0x97, 0xCF, 0x03, 
	0x30, 0x3C, 0xBB, 0x78, 0x8E, 0x14, 0xE4, 0xAC, 
	0x3A, 0x0A, 0xB4, 0xCA, 0x23, 0x16, 0x9D, 0x2D, 
	0xC4, 0xED, 0xA4, 0xEA, 0x05, 0xB2, 0xEC, 0xA3, 
	0x1D, 0xD7, 0xF0, 0xA5, 0x37, 0xA0, 0xA5, 0x64, 
	0xDC, 0xAF, 0x60, 0x73, 0xAA, 0x19, 0x00, 0x7A, 
	0x12, 0xC9, 0x38, 0xE3, 0xDB, 0xFA, 0x88, 0xFC, 
	0x8B, 0x06, 0x8B, 0x7A, 0x37, 0xA7, 0x26, 0xFF, 
	0x99, 0x32, 0xDE, 0x81, 0xA8, 0x7B, 0x39, 0xE5, 
	0x7E, 0x79, 0x8F, 0x85, 0xC3, 0x75, 0x16, 0xFE, 
	0x18, 0x08, 0x77, 0xAA, 0xD8, 0x27, 0x4D, 0x1F, 
	0x75, 0xBC, 0x8A, 0xD4, 0xFD, 0xB1, 0x5C, 0x65, 
	0xCC, 0x3F, 0x49, 0x02, 0x7B, 0xD6, 0x84, 0x8E, 
	0x1B, 0x9A, 0x1B, 0x24, 0xF1, 0x56, 0xF0, 0xB4, 
	0xE8, 0x04, 0x9A, 0xC5, 0x71, 0x05, 0x9D, 0xC1, 
	0x6B, 0x7D, 0x49, 0x6E, 0xA0, 0xBC, 0x2D, 0x97, 
	0x76, 0xB6, 0x8B, 0x88, 0x95, 0x14, 0xF6, 0x31, 
	0x96, 0xCD, 0x80, 0x70, 0xA1, 0x22, 0xE5, 0xE1, 
	0xDB, 0xDF, 0x5C, 0x39, 0xAA, 0x2F, 0x23, 0x6E, 
	0x69, 0xC4, 0xA3, 0xB8, 0xB6, 0xD9, 0xE3, 0x8A, 
	0x0D, 0x91, 0x0A, 0x73, 0x02, 0xB8, 0x16, 0x26, 
	0xCF, 0xA2, 0xA2, 0x71, 0x65, 0x2D, 0xA8, 0x93, 
	0xDB, 0xAD, 0x94, 0xB6, 0xDB, 0xE7, 0xAD, 0x00, 
	0x5B, 0x2B, 0x22, 0x1E, 0xED, 0xB3, 0x14, 0x4B, 

	/* Database Page 21 */

	0xFF, 0xD3, 0xA5, 0x77, 0x0A, 0x5E, 0x84, 0x78, 
	0xB4, 0x04, 0xC6, 0xEF, 0x12, 0xED, 0x35, 0x2A, 
	0x19, 0xFD, 0x05, 0x07, 0x09, 0x2D, 0xA7, 0xB8, 
	0x59, 0x88, 0x01, 0x07, 0x09, 0x98, 0x7D, 0x01, 
	0x38, 0x6F, 0xC9, 0x30, 0x76, 0x06, 0x16, 0x70, 
	0x93, 0xCF, 0x65, 0x49, 0xB6, 0x91, 0xBF, 0x4C, 
	0xCB, 0x3F, 0xFD, 0x67, 0x46, 0x9E, 0x3B, 0x2A, 
	0xC7, 0x3E, 0xAF, 0x36, 0xF6, 0x18, 0x74, 0x85, 
	0x4D, 0x77, 0x70, 0x0D, 0x61, 0x2B, 0xCA, 0xF4, 
	0x16, 0x03, 0x32, 0xBD, 0xBF, 0x72, 0x03, 0x0E, 
	0xC5, 0xB5, 0xD9, 0xCF, 0x02, 0xDE, 0x02, 0x06, 
	0xB3, 0xF1, 0x3A, 0xBB, 0x06, 0x09, 0x47, 0x26, 
	0x01, 0xA0, 0xDA, 0x41, 0xEC, 0x90, 0x34, 0x30, 
	0xDB, 0xC5, 0x98, 0x0C, 0xCF, 0x1E, 0xA5, 0xBF, 
	0x58, 0xD4, 0xF2, 0xEA, 0x14, 0x83, 0xC7, 0x84, 
	0xEB, 0xAC, 0x6A, 0x3B, 0x9B, 0x56, 0x1F, 0xD8, 
	0x39, 0xFF, 0xAC, 0x20, 0xCF, 0x43, 0x0B, 0x46, 
	0x2B, 0x18, 0xBC, 0x7F, 0xCB, 0x3F, 0x54, 0x36, 
	0x0E, 0x1A, 0xF8, 0x49, 0xAF, 0x42, 0x84, 0x36, 
	0xC4, 0x0F, 0xFA, 0xEB, 0xA3, 0xC0, 0x72, 0x10, 
	0x08, 0xFA, 0x49, 0x64, 0x6E, 0xDA, 0xFD, 0x63, 
	0x23, 0x8C, 0x82, 0xBF, 0x5E, 0x95, 0x6D, 0xBB, 
	0xE0, 0xF5, 0xDF, 0x4F, 0x5F, 0x9F, 0x39, 0x63, 
	0x4C, 0x05, 0x0F, 0x18, 0xC9, 0x24, 0xB7, 0x63, 
	0xDA, 0x09, 0x83, 0x55, 0xBF, 0xE1, 0x03, 0x8E, 
	0x56, 0x71, 0xEF, 0xF1, 0x19, 0xB2, 0x56, 0x6A, 
	0x2D, 0x99, 0xC8, 0x36, 0xF1, 0xFC, 0x6F, 0xFC, 
	0xAC, 0x2C, 0xFA, 0xC2, 0x7B, 0xCE, 0x22, 0x5F, 
	0x31, 0x92, 0x9A, 0x5B, 0x55, 0xF1, 0x22, 0x5E, 
	0xF6, 0x38, 0x1C, 0x92, 0x06, 0x86, 0x84, 0xFD, 
	0x42, 0xD6, 0x4D, 0x13, 0x9A, 0x1E, 0xB1, 0xD7, 
	0x05, 0xC6, 0x1F, 0xB1, 0xF0, 0x23, 0xBA, 0xF6, 
	0xD9, 0xF8, 0xFF, 0x15, 0xDF, 0xB6, 0xF9, 0xEC, 
	0x18, 0x61, 0xC8, 0xBB, 0xB8, 0x69, 0x3E, 0x74, 
	0xB2, 0x6D, 0x4A, 0x00, 0x1C, 0xFB, 0x48, 0x01, 
	0x76, 0x04, 0xC7, 0x45, 0x1D, 0x6A, 0x26, 0x3F, 
	0x52, 0x2E, 0xD6, 0xC0, 0x84, 0x72, 0xC7, 0x0A, 
	0x7E, 0x45, 0x70, 0x12, 0x96, 0x74, 0xD9, 0x82, 
	0xB4, 0xF3, 0x01, 0xE3, 0x48, 0x99, 0x90, 0xFB, 
	0x1B, 0x0C, 0x6F, 0x80, 0x7F, 0x08, 0x40, 0x55, 
	0xCB, 0xD8, 0x26, 0xA8, 0xCF, 0x4A, 0xCC, 0x2B, 
	0x9B, 0x86, 0x45, 0x0B, 0xAC, 0x5B, 0xDE, 0x9B, 
	0x8D, 0xFB, 0x11, 0x21, 0x3B, 0x67, 0x83, 0x6D, 
	0xF9, 0x17, 0x34, 0x2E, 0x80, 0x07, 0x22, 0x02, 
	0x84, 0x45, 0x9D, 0x11, 0x1B, 0x54, 0x06, 0x85, 
	0x22, 0x0D, 0x59, 0x33, 0x7B, 0x09, 0x0E, 0x2D, 
	0x88, 0xE2, 0x06, 0xE9, 0xB9, 0x68, 0x80, 0xF6, 
	0x68, 0xF0, 0x27, 0xE8, 0x7B, 0xDE, 0x45, 0xC1, 
	0x15, 0xB2, 0xE2, 0xFF, 0x72, 0xF5, 0xF5, 0xBF, 
	0xAF, 0xBE, 0xF3, 0x42, 0xF0, 0x50, 0x15, 0x66, 
	0x2D, 0x46, 0xEE, 0xE1, 0x78, 0x81, 0x37, 0x19, 
	0x21, 0x52, 0x76, 0x7D, 0x6F, 0x67, 0xC6, 0xB8, 
	0xF4, 0x3F, 0xED, 0x03, 0x81, 0xB7, 0x65, 0x3F, 
	0x6C, 0x26, 0xC6, 0x51, 0xA1, 0x9E, 0xC6, 0x97, 
	0xD3, 0x29, 0x62, 0xC0, 0xFA, 0xFD, 0x9A, 0x61, 
	0xF0, 0xE1, 0x7D, 0x13, 0x46, 0x14, 0x5F, 0xFD, 
	0x76, 0x9B, 0xE7, 0xB8, 0x28, 0x8D, 0xBA, 0x6E, 
	0xF4, 0x78, 0xD9, 0xAB, 0xD2, 0x3C, 0x25, 0x1D, 
	0x52, 0xBE, 0xC8, 0x2D, 0x04, 0x17, 0x9E, 0xAE, 
	0x0D, 0x2D, 0xBF, 0xDB, 0x4C, 0xFE, 0x77, 0x1A, 
	0xB6, 0xD6, 0x35, 0x15, 0xBD, 0xDF, 0x88, 0xF5, 
	0xFC, 0xD8, 0x05, 0x63, 0xF0, 0xB1, 0x0F, 0xF1, 
	0x3B, 0x0A, 0xA4, 0xBB, 0xAC, 0x42, 0x86, 0x05, 
	0xA9, 0x35, 0xED, 0xA8, 0x9D, 0xAB, 0x2D, 0xDF, 
	0x9D, 0x1A, 0x9B, 0xEF, 0xFF, 0xA0, 0x02, 0x83, 
	0xA8, 0xDA, 0xBE, 0x62, 0xD2, 0xC9, 0x40, 0xCD, 
	0x99, 0x26, 0x4B, 0x53, 0xD9, 0x55, 0x29, 0x03, 
	0xC6, 0x88, 0x20, 0xF2, 0xAE, 0x3A, 0x62, 0x0C, 
	0xB4, 0xC6, 0x26, 0xEF, 0xD2, 0xB9, 0x8D, 0xA2, 
	0xD2, 0x53, 0xD6, 0x3F, 0x07, 0xE2, 0x08, 0xAA, 
	0x60, 0x2E, 0xCF, 0xB0, 0xCC, 0x15, 0x07, 0x0C, 
	0xB5, 0xCA, 0x25, 0x37, 0x30, 0x88, 0xAB, 0x08, 
	0x55, 0xA8, 0xA5, 0xDE, 0xD8, 0x9C, 0x9D, 0xAB, 
	0xAC, 0xD8, 0x3F, 0x87, 0x93, 0xAD, 0x7D, 0x03, 
	0xAC, 0x43, 0x9F, 0x9A, 0xD7, 0xDF, 0x76, 0x94, 
	0xB4, 0x47, 0x4B, 0x14, 0x1E, 0xCE, 0x45, 0xF6, 
	0xAE, 0xED, 0x73, 0x4E, 0xC8, 0x5F, 0xD7, 0x77, 
	0x8D, 0x1F, 0x6F, 0x23, 0x4C, 0x16, 0x87, 0xD6, 
	0xD6, 0x59, 0x49, 0x85, 0xD9, 0xA2, 0xA1, 0xC7, 
	0x5F, 0x82, 0xFA, 0x9D, 0x8D, 0x07, 0x86, 0xDF, 
	0x55, 0x2F, 0x9A, 0x67, 0x07, 0xFF, 0x4C, 0xC1, 
	0x2B, 0x3A, 0x00, 0xFE, 0xDC, 0x5E, 0x33, 0xA1, 
	0x21, 0xA0, 0xD7, 0x57, 0x4D, 0xBD, 0xCF, 0xA2, 
	0x1E, 0x65, 0x96, 0x3F, 0x24, 0xAE, 0xAA, 0x86, 
	0x6D, 0xBB, 0xD6, 0x22, 0xB1, 0xB5, 0xE2, 0xA3, 
	0xDC, 0x29, 0x64, 0x59, 0x72, 0xE4, 0x89, 0xDE, 
	0x54, 0x3A, 0x50, 0x27, 0x49, 0x92, 0x11, 0x8C, 
	0x68, 0x9C, 0x52, 0x10, 0xB7, 0xD4, 0x8D, 0xC0, 
	0xB2, 0xE9, 0x54, 0x4D, 0x25, 0x95, 0xBA, 0x29, 
	0x88, 0x3A, 0x14, 0x49, 0xE1, 0x5C, 0x3D, 0x1F, 
	0xBB, 0x6B, 0x99, 0x6A, 0xB3, 0x8A, 0xC5, 0x4C, 
	0x65, 0x8E, 0xEE, 0x42, 0xBA, 0xAA, 0xBC, 0xBA, 
	0xB5, 0x3D, 0x5C, 0xED, 0x5D, 0x31, 0xBF, 0xFF, 
	0xE7, 0xB8, 0xF9, 0x10, 0x85, 0x24, 0x11, 0x77, 
	0xBD, 0xF1, 0x8A, 0x3A, 0xF4, 0xEC, 0x25, 0xC2, 
	0x9B, 0x6C, 0xF4, 0xAD, 0xDE, 0x6B, 0x63, 0x64, 
	0x40, 0xED, 0x78, 0xA4, 0x0A, 0x10, 0xFF, 0xC7, 
	0xBF, 0xCC, 0xA9, 0xC1, 0xC7, 0x56, 0x38, 0x67, 
	0xDD, 0x9B, 0x0E, 0xBE, 0x1A, 0x37, 0xB8, 0xEB, 
	0x86, 0xBF, 0x04, 0xF4, 0x07, 0xEB, 0x0F, 0x25, 
	0x23, 0x5E, 0x48, 0x38, 0xBF, 0x69, 0x38, 0xB3, 
	0x4E, 0x0F, 0x30, 0xA2, 0xBD, 0xF3, 0xE0, 0x7A, 
	0x56, 0x6D, 0xB2, 0x1F, 0xD4, 0x1C, 0x58, 0x9E, 
	0xBA, 0x43, 0x9B, 0x63, 0xD1, 0xCC, 0x69, 0x44, 
	0xBF, 0x46, 0x73, 0x0A, 0x54, 0xFC, 0x3D, 0xE4, 
	0xE2, 0xAE, 0xEF, 0xE2, 0xA7, 0x1D, 0x98, 0xD0, 
	0x6E, 0xB4, 0x2F, 0x52, 0xB5, 0xB9, 0xD3, 0x40, 
	0xDC, 0x4C, 0x34, 0xAA, 0x99, 0x81, 0x7C, 0x04, 
	0xC8, 0x12, 0xCE, 0x60, 0x5B, 0xC8, 0xDD, 0xEF, 
	0x15, 0x65, 0xEB, 0x77, 0x4D, 0x06, 0xB8, 0xC9, 
	0x6A, 0xC1, 0xE8, 0x03, 0x8A, 0x63, 0xAA, 0x03, 
	0xAC, 0x9C, 0x5C, 0x1A, 0x10, 0xA1, 0xF0, 0xD5, 
	0x0A, 0xF0, 0x69, 0x99, 0x82, 0x49, 0xD1, 0xFF, 
	0x81, 0x5C, 0x69, 0x18, 0x9A, 0xDF, 0x4F, 0xB3, 
	0xF9, 0xBF, 0x8A, 0xA8, 0xB7, 0x53, 0x98, 0xFA, 
	0x6F, 0x22, 0x9D, 0xB7, 0x91, 0xC6, 0x2D, 0xB3, 
	0x87, 0x59, 0x78, 0x3D, 0x5D, 0x16, 0x8C, 0xC3, 
	0x83, 0xF9, 0xC6, 0x2A, 0x32, 0x65, 0x7E, 0xA2, 
	0x7C, 0x97, 0x2E, 0x78, 0x18, 0x12, 0x08, 0xCD, 
	0x29, 0x89, 0xC4, 0xA9, 0x19, 0x5A, 0xCD, 0x47, 
	0x21, 0x43, 0x8E, 0x4B, 0xF7, 0xFD, 0x5E, 0x11, 
	0x0B, 0xF0, 0xD6, 0x2C, 0x69, 0x1F, 0xDB, 0x9C, 
	0x75, 0x67, 0xD7, 0x21, 0xDA, 0x52, 0xED, 0x71, 
	0xBE, 0x57, 0x4C, 0x4A, 0x58, 0x26, 0x30, 0x04, 
	0x93, 0x4D, 0x0D, 0x98, 0x1D, 0x8F, 0xEC, 0xF8, 
	0x45, 0xD5, 0x6B, 0x01, 0x83, 0x83, 0x93, 0xCD, 
	0x22, 0xA9, 0x58, 0x1A, 0xDE, 0xE3, 0x64, 0x4A, 
	0xAD, 0x8D, 0xEC, 0xC9, 0x22, 0xD6, 0xB5, 0xBB, 
	0xFB, 0x60, 0xE8, 0xD6, 0x5C, 0xB1, 0xA6, 0x19, 
	0xFF, 0x07, 0xBD, 0xEF, 0x3D, 0x7B, 0x40, 0xC0, 
	0x8D, 0xB6, 0x8F, 0x0F, 0x3B, 0x41, 0x4E, 0x32, 
	0x21, 0x75, 0x94, 0x57, 0x1F, 0xC0, 0x11, 0x7B, 
	0xC2, 0x9F, 0xFD, 0x75, 0x3D, 0xCD, 0xE1, 0x8C, 
	0xAA, 0x10, 0xF1, 0xF4, 0xCB, 0xA7, 0xBB, 0x76, 
	0xDB, 0x32, 0x68, 0x67, 0x76, 0xD0, 0xBD, 0x11, 
	0x41, 0xCB, 0x2A, 0x69, 0xB1, 0xE0, 0x82, 0xC1, 
	0x1E, 0x28, 0x67, 0x66, 0x0C, 0x2D, 0xB1, 0x2B, 
	0x3B, 0xE2, 0x8E, 0xB9, 0xD4, 0x48, 0xCB, 0xFD, 
	0xBD, 0xB7, 0x03, 0x0F, 0x07, 0x77, 0xA9, 0x38, 
	0x9D, 0x18, 0xB6, 0x58, 0xFD, 0x57, 0xB9, 0x34, 
	0xA9, 0x4F, 0x63, 0xD7, 0x20, 0xBA, 0x60, 0xB5, 
	0x57, 0x4D, 0x31, 0x2E, 0x89, 0x4C, 0x25, 0xC8, 
	0x39, 0xA5, 0x1A, 0x1A, 0x7C, 0x4D, 0x31, 0x8C, 
	0xEC, 0xD3, 0x1A, 0x9C, 0xE9, 0xE1, 0xA9, 0xF8, 
	0xDF, 0x2A, 0x3F, 0xCF, 0xED, 0xA2, 0x2E, 0x91, 
	0xF5, 0xFF, 0x8E, 0xE7, 0xAF, 0xEB, 0xE1, 0xFC, 
	0x31, 0x24, 0x35, 0xD0, 0xAE, 0x9A, 0xCD, 0x38, 
	0x8C, 0x54, 0x46, 0xB4, 0x05, 0x82, 0x44, 0xA7, 
	0xCA, 0x06, 0xFD, 0xA1, 0x9F, 0xCC, 0x0B, 0xF7, 
	0xB1, 0x92, 0x8F, 0xC4, 0x0E, 0xD2, 0xFC, 0x38, 
	0x1A, 0x89, 0x83, 0xA0, 0x2A, 0xC2, 0x69, 0x1A, 
	0xEA, 0xD7, 0xBA, 0x55, 0x98, 0xD9, 0xB3, 0xBC, 
	0x75, 0x87, 0x2E, 0xF2, 0x13, 0xC8, 0x09, 0xA0, 
	0xA5, 0xC0, 0x3E, 0x0B, 0xFA, 0xB7, 0x2A, 0xFF, 
	0x7C, 0x95, 0x57, 0x41, 0xFC, 0xC7, 0x23, 0xBA, 
	0x7B, 0xB3, 0xA9, 0x46, 0x45, 0x15, 0xED, 0x63, 
	0xA8, 0x21, 0x9C, 0x86, 0x3C, 0xD4, 0x3B, 0xE7, 
	0x53, 0xE9, 0x22, 0xAB, 0x37, 0x54, 0xD2, 0x46, 
	0xF2, 0x9D, 0x4E, 0x23, 0xF9, 0x23, 0xC4, 0xFE, 
	0x51, 0x37, 0x8E, 0x2C, 0xC6, 0x64, 0xE6, 0x9F, 
	0x76, 0x92, 0x6F, 0xD8, 0x48, 0x28, 0xAF, 0xD4, 
	0x56, 0x09, 0xFF, 0xAF, 0x92, 0x2E, 0x61, 0x40, 
	0xA5, 0xB3, 0xBE, 0x1D, 0x12, 0x12, 0x48, 0xB9, 
	0x1E, 0x55, 0x6E, 0xF2, 0x05, 0x52, 0x5A, 0x88, 
	0x36, 0x6D, 0x79, 0x53, 0x82, 0xAB, 0x04, 0xDB, 
	0xA5, 0x16, 0x80, 0x15, 0x89, 0x83, 0x1F, 0x87, 
	0x6D, 0xF1, 0xFB, 0xFB, 0xE9, 0x32, 0xEE, 0xEF, 
	0xF7, 0x1B, 0x47, 0x81, 0x0A, 0x71, 0x27, 0x8E, 
	0x06, 0x59, 0xB2, 0x68, 0xB7, 0x13, 0x5D, 0x05, 
	0x21, 0x5A, 0xCF, 0x3F, 0x37, 0x8A, 0x00, 0x3B, 
	0x28, 0x83, 0x96, 0x40, 0xD7, 0x4F, 0x68, 0x62, 
	0xB5, 0x66, 0x36, 0xFD, 0x3A, 0xC2, 0xE0, 0xD7, 
	0xC6, 0x31, 0x11, 0xD5, 0xA1, 0xD1, 0x1F, 0x6E, 
	0x56, 0x87, 0x72, 0x0E, 0x57, 0xCE, 0x09, 0x2A, 
	0xA5, 0x0D, 0x96, 0x17, 0x47, 0x6A, 0xE4, 0x75, 
	0x2B, 0x34, 0xE8, 0x16, 0x47, 0xC3, 0xB9, 0x6E, 
	0x19, 0x41, 0xA7, 0x2D, 0xDA, 0x07, 0x9A, 0xD1, 
	0x8A, 0xE2, 0x20, 0xFF, 0xE7, 0x90, 0xB4, 0x74, 
	0x69, 0x74, 0x1D, 0xAF, 0x0B, 0xAB, 0x4F, 0x7D, 
	0xE5, 0xAD, 0x05, 0x5D, 0xBF, 0xCB, 0xCA, 0x50, 
	0x5C, 0xB4, 0x5F, 0xF6, 0x80, 0x31, 0xAE, 0x99, 
	0x60, 0xBB, 0xEA, 0x97, 0xB4, 0x51, 0x67, 0xF4, 
	0x3A, 0x2A, 0x83, 0xD2, 0x6F, 0x3D, 0xF4, 0xFF, 
	0x0A, 0x5F, 0xB8, 0x94, 0x58, 0x12, 0x41, 0x19, 
	0x90, 0x59, 0xBA, 0x5C, 0xA6, 0x96, 0x9B, 0x18, 
	0xF2, 0xC4, 0x82, 0x2B, 0x35, 0x85, 0x21, 0x44, 
	0x70, 0x5B, 0xF1, 0xCC, 0xCB, 0xC8, 0x84, 0xDB, 
	0xBD, 0x9D, 0x54, 0x78, 0xCC, 0x15, 0x02, 0xFD, 
	0xA0, 0x52, 0xA4, 0xB0, 0x24, 0x2B, 0xA3, 0xA0, 
	0x7C, 0x53, 0x12, 0x1C, 0x28, 0x34, 0x83, 0xD0, 
	0x3D, 0xF7, 0x7F, 0x19, 0xC6, 0xB9, 0x6D, 0xF0, 
	0x9F, 0x0C, 0xF9, 0xBC, 0x77, 0x2D, 0x1D, 0x59, 
	0x72, 0x59, 0xB7, 0xB9, 0x48, 0x78, 0xB4, 0x47, 
	0xEF, 0x33, 0x87, 0x8D, 0xFF, 0x1E, 0x84, 0xAE, 
	0x63, 0xCD, 0x0C, 0x08, 0x10, 0x22, 0x23, 0x25, 
	0x8B, 0x45, 0x5C, 0x3D, 0x5B, 0xDA, 0x82, 0x9B, 
	0x6E, 0xF0, 0x91, 0xD2, 0xC8, 0x30, 0x38, 0x0C, 
	0xEC, 0xE1, 0x05, 0x65, 0x88, 0xB7, 0x49, 0xE7, 
	0xAC, 0xB6, 0x94, 0xB3, 0x9D, 0xFC, 0xCE, 0x9F, 
	0x2C, 0xB5, 0xC2, 0x69, 0x26, 0x29, 0xA6, 0x21, 
	0x8F, 0xE0, 0x64, 0x98, 0x4E, 0x1B, 0xF8, 0xD9, 
	0x38, 0x35, 0x4E, 0x72, 0x5D, 0x77, 0x15, 0x08, 
	0x61, 0xBF, 0x35, 0x14, 0xEB, 0x55, 0x61, 0x6F, 
	0x91, 0xA4, 0x85, 0xD1, 0xA2, 0x45, 0xA5, 0x4B, 
	0x8A, 0x45, 0xA6, 0x18, 0x50, 0xFC, 0x68, 0x8D, 
	0x2E, 0xFF, 0xCA, 0xF2, 0xC1, 0xF9, 0x4E, 0xFF, 
	0x95, 0x7D, 0x9E, 0xA5, 0x0B, 0x0B, 0x31, 0x73, 
	0xEF, 0x69, 0x1F, 0xF1, 0x74, 0xC7, 0x5D, 0x8D, 
	0x7A, 0x20, 0x25, 0x09, 0x9B, 0x82, 0x55, 0x10, 
	0xD7, 0x8B, 0x0E, 0xD7, 0x4D, 0xFF, 0x02, 0xAA, 
	0x39, 0x50, 0xE3, 0x31, 0xCA, 0x4D, 0x0E, 0x75, 
	0xA6, 0x01, 0x16, 0x8C, 0xB4, 0x23, 0x25, 0xF8, 
	0x75, 0x05, 0x4D, 0xAA, 0x1F, 0x8F, 0x30, 0x4C, 
	0xDE, 0x35, 0x81, 0x83, 0xE6, 0x7D, 0x88, 0xB3, 
	0xA6, 0xED, 0x3E, 0xC5, 0x3B, 0xB0, 0x56, 0x0C, 
	0xDE, 0x76, 0xF1, 0x95, 0xA2, 0xAF, 0x98, 0xC9, 
	0xF5, 0x19, 0xA1, 0x46, 0x24, 0x44, 0x67, 0x43, 
	0xAF, 0xD5, 0x2A, 0xC6, 0x7E, 0x6F, 0x6A, 0xD3, 
	0x79, 0xDF, 0x98, 0x2E, 0x17, 0xBC, 0x6C, 0xB4, 
	0x5F, 0xCF, 0xC7, 0x49, 0x96, 0x30, 0x66, 0x76, 
	0x60, 0xA0, 0xEB, 0x16, 0x96, 0x1D, 0xBF, 0x9D, 
	0x0F, 0xC2, 0x1E, 0x7C, 0x70, 0x2F, 0xF3, 0x3D, 
	0x5B, 0xBE, 0xCF, 0x2A, 0x67, 0x33, 0xC2, 0x06, 
	0x82, 0xE1, 0x04, 0x08, 0x9F, 0x03, 0x6F, 0xDE, 
	0x1C, 0x0E, 0x03, 0x7E, 0x47, 0xD8, 0x5B, 0x25, 
	0x19, 0x9B, 0xED, 0xD4, 0x13, 0xED, 0xFF, 0xF5, 
	0x6F, 0xD8, 0x56, 0x11, 0x0C, 0x32, 0xDB, 0x71, 
	0xFE, 0x35, 0x63, 0xA1, 0xE7, 0xF9, 0x4B, 0xE9, 
	0x33, 0xE2, 0x02, 0x8B, 0x60, 0x38, 0xBF, 0x95, 
	0xB1, 0x42, 0xC1, 0xD6, 0xA4, 0x9D, 0x36, 0xC5, 
	0xDC, 0x09, 0xD8, 0x02, 0x64, 0x80, 0x48, 0x67, 
	0xED, 0xC7, 0x5B, 0xBD, 0x8C, 0x0C, 0xAD, 0x01, 
	0x55, 0xB3, 0x4D, 0x01, 0xC2, 0xA0, 0xD8, 0xB9, 
	0x8E, 0x6E, 0xA6, 0xF5, 0xD3, 0x33, 0x6B, 0xCC, 
	0xD6, 0x66, 0x41, 0x08, 0x52, 0x41, 0x68, 0xB9, 
	0x73, 0x7F, 0xF9, 0xF7, 0x61, 0x60, 0x35, 0xEC, 
	0x26, 0x65, 0xB6, 0xD0, 0x62, 0x49, 0x4A, 0x9B, 
	0x79, 0xDF, 0x62, 0x85, 0xC0, 0x5B, 0xAD, 0x2A, 
	0x54, 0x9A, 0x15, 0xBF, 0xDA, 0x54, 0xF3, 0x6C, 
	0x7F, 0x08, 0x3D, 0x35, 0xCC, 0x31, 0x16, 0xCF, 
	0x38, 0xB9, 0x0E, 0xF2, 0xED, 0x21, 0x10, 0xB7, 
	0x2F, 0x53, 0x4B, 0x04, 0xE9, 0x64, 0xF3, 0xFF, 
	0xD4, 0xC2, 0x44, 0x0B, 0x4A, 0x24, 0x86, 0x0F, 
	0xDE, 0x59, 0x6C, 0x0D, 0x30, 0x10, 0x87, 0x92, 
	0x53, 0xE1, 0x4C, 0x78, 0x18, 0x26, 0xFB, 0x8D, 
	0xB4, 0xF0, 0xDD, 0xEE, 0x41, 0xED, 0x0C, 0x5C, 
	0xB4, 0x35, 0x47, 0x9F, 0x19, 0x4A, 0xC1, 0x99, 
	0xB0, 0xC9, 0xFD, 0x94, 0x4E, 0xAE, 0x43, 0x59, 
	0x00, 0xE9, 0x90, 0x8B, 0xED, 0x0F, 0x55, 0x49, 
	0xCF, 0xFC, 0xA3, 0x23, 0x22, 0x5A, 0x56, 0x64, 
	0x9B, 0x6B, 0x08, 0x3C, 0x27, 0xEB, 0xB9, 0x14, 
	0xE3, 0xDA, 0x96, 0xD0, 0x8E, 0x5A, 0x6E, 0x0C, 
	0x2D, 0xC1, 0xE5, 0x65, 0x22, 0xE3, 0x58, 0x7A, 
	0x09, 0xBB, 0xDC, 0x62, 0x0B, 0x42, 0x58, 0xAD, 
	0x0A, 0x7D, 0x3F, 0x67, 0xB3, 0x2B, 0xC8, 0x97, 
	0x5C, 0xD1, 0xA2, 0x97, 0xF1, 0x23, 0x2D, 0x06, 
	0x76, 0x84, 0x42, 0x14, 0x5F, 0xBB, 0x83, 0xA8, 
	0xD1, 0x5B, 0xC3, 0x67, 0xCD, 0x25, 0xB7, 0x95, 

	/* Database Page 22 */

	0xFF, 0x14, 0x4B, 0xDB, 0xD5, 0xF2, 0x17, 0xF6, 
	0x90, 0x58, 0x3E, 0xCF, 0x64, 0xB2, 0x4A, 0x59, 
	0xAD, 0x0A, 0xCC, 0x08, 0x22, 0xB3, 0x33, 0x7D, 
	0xAD, 0x22, 0xE6, 0x33, 0x55, 0xAA, 0x16, 0x33, 
	0x85, 0xB0, 0x1D, 0x99, 0xF9, 0x5B, 0xA0, 0xFF, 
	0x23, 0xEC, 0x79, 0x48, 0x0F, 0x97, 0x87, 0xF2, 
	0x15, 0xBD, 0x6A, 0x9A, 0xD0, 0x73, 0xE4, 0x50, 
	0xF7, 0x5B, 0x7C, 0x68, 0x07, 0xFC, 0xCF, 0xCE, 
	0xD3, 0x9D, 0x71, 0x79, 0x57, 0xA7, 0x0D, 0xA0, 
	0x3B, 0xA8, 0xC7, 0xC8, 0x27, 0xC5, 0x61, 0x24, 
	0x7E, 0xC2, 0x9D, 0x99, 0x35, 0xB4, 0x81, 0x78, 
	0x64, 0x04, 0x52, 0xF7, 0xA3, 0xD9, 0xBF, 0x01, 
	0x4B, 0x09, 0xB8, 0xA5, 0x5B, 0xC4, 0x50, 0xFF, 
	0x7A, 0x4C, 0x37, 0xBD, 0x4E, 0x7C, 0x19, 0xFF, 
	0xCE, 0x9D, 0xCA, 0xBD, 0x0C, 0xCB, 0x11, 0xA4, 
	0xD2, 0x05, 0x77, 0x22, 0x8A, 0x15, 0x3F, 0xF2, 
	0x4D, 0xFF, 0xF5, 0xCF, 0x7F, 0x7C, 0x7D, 0xF5, 
	0xF6, 0x90, 0x01, 0x8F, 0x21, 0x22, 0x39, 0x49, 
	0xEF, 0x60, 0xA9, 0x02, 0xC7, 0xCF, 0xFF, 0xB1, 
	0x0A, 0x3C, 0xC9, 0x53, 0x05, 0x78, 0x13, 0x99, 
	0x8D, 0x94, 0x08, 0x23, 0x77, 0x9A, 0x19, 0x66, 
	0x37, 0x37, 0x15, 0x21, 0xEC, 0x4B, 0x6E, 0x9A, 
	0x01, 0x62, 0x40, 0x31, 0x08, 0xBE, 0x5F, 0x05, 
	0x11, 0xB1, 0x28, 0xB8, 0x3F, 0x9C, 0x0D, 0x62, 
	0x35, 0xB6, 0x32, 0x9F, 0x32, 0x96, 0x26, 0xBF, 
	0x79, 0xD5, 0x5D, 0x78, 0x53, 0x03, 0xDB, 0x73, 
	0x45, 0xB5, 0x5A, 0xFD, 0xA7, 0x78, 0xC1, 0x91, 
	0x2E, 0x03, 0xE3, 0x55, 0x61, 0xA8, 0xBF, 0xFC, 
	0x8B, 0x43, 0x5C, 0xF7, 0xCA, 0x96, 0x1E, 0x5F, 
	0xA8, 0x29, 0x87, 0xDE, 0x14, 0xD5, 0x29, 0x04, 
	0xA3, 0x47, 0xD6, 0xF3, 0x61, 0xB1, 0xF0, 0x0D, 
	0xA6, 0xEC, 0xDD, 0x30, 0x2A, 0xDA, 0xA8, 0x7C, 
	0x9F, 0xAB, 0xFF, 0x58, 0x42, 0xF9, 0xD3, 0xA3, 
	0xAC, 0xEA, 0x19, 0x10, 0x2E, 0xA6, 0xF9, 0x3C, 
	0xB7, 0x2D, 0x1F, 0x32, 0xF6, 0x11, 0x99, 0x47, 
	0xF4, 0xFF, 0x6C, 0xEA, 0x49, 0x08, 0x79, 0x54, 
	0x4B, 0x2E, 0xD6, 0x4F, 0xC0, 0x6D, 0x53, 0x48, 
	0x62, 0xF2, 0xCF, 0x3C, 0x97, 0x5D, 0x53, 0xDB, 
	0xF3, 0xCD, 0xA7, 0xDC, 0x15, 0x79, 0xD0, 0x70, 
	0x0F, 0x3E, 0xC5, 0x34, 0x5F, 0xDB, 0x33, 0xB6, 
	0x11, 0xA8, 0xE8, 0x55, 0x44, 0xF2, 0x2C, 0x6C, 
	0xB7, 0xD7, 0x58, 0x6F, 0x79, 0xEF, 0xAC, 0x45, 
	0xDC, 0x4A, 0x4C, 0xDA, 0xF9, 0xA5, 0x9F, 0x84, 
	0x13, 0x68, 0xF9, 0x15, 0xDB, 0x65, 0x79, 0x63, 
	0xC5, 0x05, 0xA9, 0x8B, 0x8C, 0x04, 0xF8, 0x40, 
	0xCD, 0xA2, 0x55, 0x48, 0x4B, 0xB8, 0x2A, 0x41, 
	0x13, 0x6E, 0x7A, 0x3C, 0x89, 0x47, 0x9E, 0x51, 
	0x93, 0x5E, 0xE2, 0xF1, 0xBC, 0x4B, 0xAB, 0x22, 
	0x00, 0xFA, 0x5B, 0xFF, 0x8A, 0xDF, 0x96, 0x84, 
	0xBB, 0x5B, 0x5A, 0xC0, 0xB2, 0x55, 0xD7, 0xE6, 
	0x30, 0xD7, 0x4D, 0xF4, 0x25, 0x09, 0x58, 0x69, 
	0x21, 0x9C, 0x99, 0xF8, 0x50, 0x5F, 0xF9, 0x03, 
	0x94, 0xF9, 0xA1, 0x08, 0xED, 0x2D, 0x0F, 0xA9, 
	0x80, 0xCD, 0x86, 0x2F, 0x3B, 0x05, 0x0A, 0xB0, 
	0xAD, 0x12, 0xAF, 0xDD, 0x67, 0x00, 0x32, 0x7A, 
	0xBB, 0xAA, 0x85, 0xD7, 0x2B, 0x76, 0x1F, 0x50, 
	0x9D, 0xD8, 0x59, 0xF5, 0x4D, 0x3D, 0x9E, 0x89, 
	0x06, 0x58, 0x3A, 0x43, 0xB7, 0x4D, 0xD0, 0xFB, 
	0x38, 0xC2, 0x3D, 0xAD, 0x33, 0x94, 0x20, 0xEF, 
	0x24, 0x7D, 0x8C, 0x8F, 0x6F, 0xAD, 0xA5, 0x14, 
	0x30, 0x21, 0x13, 0x82, 0x4C, 0x37, 0xB3, 0x3F, 
	0x0B, 0x61, 0x85, 0x2F, 0x10, 0x6E, 0xF7, 0x60, 
	0x92, 0x89, 0x55, 0xDE, 0xA3, 0x49, 0x70, 0x0E, 
	0xC2, 0xA5, 0x3B, 0x80, 0xF2, 0x30, 0xDC, 0xA5, 
	0x0A, 0x29, 0x5E, 0xB0, 0xFF, 0xE6, 0x8B, 0x17, 
	0x26, 0x55, 0xB3, 0xE7, 0x06, 0x76, 0xDF, 0xC5, 
	0x16, 0xC8, 0xCB, 0x63, 0xC5, 0x70, 0xC5, 0x57, 
	0x8B, 0x1C, 0x9C, 0x20, 0x9A, 0x48, 0x39, 0xE6, 
	0xFF, 0x60, 0x23, 0xF5, 0x1B, 0x2A, 0xB5, 0x62, 
	0xC8, 0x85, 0xFD, 0x1D, 0xB0, 0x1A, 0x05, 0x4D, 
	0x81, 0x1E, 0x30, 0x1F, 0x56, 0x9C, 0xC4, 0x9E, 
	0xB8, 0xC4, 0x8A, 0x24, 0x04, 0xB6, 0xA9, 0x3E, 
	0x21, 0xCA, 0xC7, 0x0F, 0xEA, 0xB3, 0x26, 0xF0, 
	0xC0, 0x9B, 0x08, 0x02, 0x48, 0x9E, 0x95, 0x2B, 
	0xA3, 0xC6, 0x3A, 0x3A, 0xD5, 0x56, 0xEF, 0xE3, 
	0xA0, 0x82, 0x84, 0x5F, 0x9C, 0x02, 0x11, 0xD4, 
	0x51, 0xB1, 0x6B, 0xA7, 0x80, 0x39, 0xF8, 0xB1, 
	0xF4, 0x24, 0x66, 0xE6, 0xD1, 0x87, 0xF3, 0x4E, 
	0xD1, 0x8F, 0x21, 0x34, 0x65, 0x89, 0x04, 0x03, 
	0xD5, 0x7E, 0xA6, 0x2A, 0x08, 0x22, 0xFD, 0xB2, 
	0x87, 0x67, 0xFE, 0x95, 0xC2, 0xFF, 0x0C, 0xF2, 
	0x3F, 0x79, 0x39, 0x3D, 0x64, 0xAC, 0x53, 0x1A, 
	0x01, 0x95, 0xE3, 0x7C, 0x95, 0x68, 0x46, 0x5D, 
	0xB5, 0x81, 0x4E, 0x29, 0x20, 0x24, 0xA9, 0x4B, 
	0x78, 0x55, 0x8A, 0xC2, 0x70, 0x47, 0x8B, 0x37, 
	0x5C, 0xE5, 0x8A, 0x56, 0x87, 0xF3, 0xA4, 0x63, 
	0xE0, 0x67, 0x94, 0x14, 0xCC, 0x39, 0x48, 0x68, 
	0xEF, 0xF0, 0x4D, 0xA9, 0xFB, 0x1E, 0x3A, 0x5E, 
	0xA8, 0x66, 0x83, 0x92, 0xBD, 0xF4, 0x0C, 0x86, 
	0x1B, 0x7C, 0xA9, 0xE1, 0x34, 0x99, 0x8A, 0x14, 
	0xE4, 0x16, 0x93, 0xE4, 0x38, 0x82, 0x6D, 0x95, 
	0x88, 0x54, 0xB3, 0x3A, 0x1E, 0xDC, 0xA6, 0xE3, 
	0xB0, 0x48, 0x65, 0x60, 0x7C, 0x12, 0xB0, 0xF2, 
	0x17, 0x64, 0xA4, 0xE6, 0x32, 0x6E, 0x97, 0x46, 
	0x8B, 0xAD, 0xB0, 0xCE, 0xFB, 0xA1, 0x87, 0x49, 
	0xE2, 0x58, 0xCB, 0x22, 0xB8, 0x27, 0x67, 0x8D, 
	0x53, 0x99, 0x4A, 0xF2, 0x42, 0x9E, 0xFF, 0x60, 
	0xB9, 0x77, 0xE2, 0xC1, 0x7C, 0x78, 0x5E, 0x88, 
	0x32, 0x20, 0xF5, 0xEF, 0x7C, 0x41, 0xCA, 0xC2, 
	0x9D, 0x8A, 0x94, 0x06, 0xE4, 0xCD, 0xE2, 0x4C, 
	0x1A, 0x29, 0xD1, 0x80, 0x8E, 0xFD, 0xA1, 0x0C, 
	0x0E, 0xCB, 0x75, 0x90, 0x41, 0xB8, 0xF8, 0x28, 
	0x04, 0x10, 0x6E, 0x39, 0x03, 0x4B, 0x70, 0x2B, 
	0xE4, 0x69, 0x25, 0x4B, 0x02, 0x69, 0x14, 0x76, 
	0x07, 0xFD, 0x2B, 0xAF, 0x27, 0x71, 0x22, 0xCB, 
	0x36, 0xB1, 0x3E, 0x0F, 0xC6, 0x15, 0xA0, 0xE4, 
	0x63, 0x20, 0x6F, 0x7B, 0xC8, 0x01, 0xA9, 0x3A, 
	0xFC, 0xFA, 0x4C, 0xC0, 0x36, 0xC8, 0x86, 0x9C, 
	0x40, 0xB2, 0x2C, 0xE0, 0x5C, 0xE4, 0x69, 0xBE, 
	0x0F, 0x5F, 0xF9, 0xC2, 0xA2, 0x89, 0xDF, 0xA0, 
	0x1A, 0xCF, 0x2D, 0x9A, 0x93, 0x93, 0x73, 0xB4, 
	0x5D, 0xA4, 0xB0, 0x40, 0x87, 0x5D, 0xCF, 0x64, 
	0xE8, 0xE4, 0xD4, 0x83, 0x2D, 0xD5, 0x23, 0xFF, 
	0x1D, 0x73, 0x7F, 0xE8, 0x38, 0xC9, 0x53, 0xAE, 
	0xEA, 0x57, 0x12, 0xDE, 0x29, 0x36, 0x75, 0xB0, 
	0xEA, 0x56, 0x91, 0x1E, 0x8E, 0x50, 0x2D, 0x42, 
	0xBF, 0xEF, 0xEA, 0x08, 0xFD, 0x74, 0xFC, 0x3E, 
	0x1F, 0xE7, 0x10, 0x84, 0x53, 0x0A, 0x48, 0xB2, 
	0x50, 0x8A, 0x93, 0x2D, 0x3E, 0x11, 0x78, 0xFF, 
	0xA0, 0x4F, 0xAD, 0x6E, 0xE4, 0x0B, 0x6C, 0xB2, 
	0x13, 0xD3, 0x24, 0x59, 0xDC, 0x2B, 0x13, 0x85, 
	0xAA, 0xBC, 0x31, 0x71, 0x72, 0xA2, 0xBF, 0x84, 
	0x10, 0x4C, 0x99, 0x8B, 0xF9, 0xB7, 0xD0, 0x36, 
	0x4F, 0x06, 0x7F, 0x58, 0xBF, 0x10, 0xB2, 0x2F, 
	0xBD, 0xF7, 0xDB, 0x37, 0xF0, 0xFF, 0xB8, 0x87, 
	0xE4, 0x8E, 0x90, 0x11, 0x99, 0x4A, 0x00, 0x23, 
	0x61, 0x08, 0xA6, 0xE8, 0x51, 0xD1, 0x7B, 0xFA, 
	0x6B, 0x2C, 0x4B, 0x89, 0x6D, 0xF7, 0x4F, 0xB9, 
	0xDE, 0x1E, 0xC9, 0xFF, 0x14, 0xC2, 0x0F, 0x04, 
	0xFF, 0x77, 0x06, 0x08, 0xA1, 0xD2, 0x81, 0x3B, 
	0x10, 0xE7, 0x41, 0x5B, 0x7A, 0x05, 0xDB, 0x79, 
	0x4F, 0x0A, 0xC3, 0xCA, 0x50, 0x1C, 0x35, 0x6C, 
	0x91, 0x51, 0xA8, 0xD9, 0xDE, 0xB3, 0x6B, 0x92, 
	0x50, 0x82, 0x3C, 0x13, 0x38, 0x04, 0xD5, 0x46, 
	0xCD, 0xE3, 0xE3, 0x79, 0xFB, 0x80, 0x28, 0x23, 
	0x67, 0x43, 0x8F, 0x12, 0x9C, 0xD4, 0x7D, 0xA7, 
	0xD7, 0x30, 0x27, 0x24, 0x8C, 0x7B, 0xCF, 0xEF, 
	0xCD, 0xEC, 0xE5, 0xA3, 0x21, 0xB6, 0x8F, 0x6A, 
	0xF8, 0xAB, 0x24, 0x4C, 0x6C, 0xD5, 0x2A, 0x2A, 
	0x2A, 0x5F, 0x10, 0x25, 0xC2, 0x86, 0xBF, 0x71, 
	0x39, 0xEB, 0xEB, 0x5D, 0x47, 0xF7, 0xDD, 0x85, 
	0x38, 0xA2, 0xAE, 0xDE, 0x10, 0x09, 0x4E, 0x2E, 
	0xEE, 0x33, 0x55, 0x9D, 0xD2, 0x9B, 0x42, 0xAB, 
	0x62, 0x9B, 0xDC, 0xB8, 0x6A, 0x5D, 0xCA, 0x6B, 
	0x14, 0xB5, 0x20, 0x96, 0xCC, 0xD2, 0xE5, 0x22, 
	0x89, 0xFF, 0x39, 0xB0, 0xE8, 0x49, 0xE3, 0x5B, 
	0xC7, 0x21, 0x6A, 0x61, 0x84, 0xDE, 0x4D, 0x1E, 
	0xB5, 0x14, 0x97, 0xD6, 0x8D, 0x8E, 0x90, 0x54, 
	0xCB, 0x98, 0xFA, 0x48, 0xA8, 0xA1, 0xB9, 0xC6, 
	0x47, 0x6F, 0xEF, 0x7D, 0x45, 0x6F, 0xE6, 0xCB, 
	0xB3, 0x05, 0x0E, 0x06, 0xBF, 0x7F, 0x80, 0xC1, 
	0xDE, 0x4E, 0x28, 0xA3, 0x2D, 0x90, 0x75, 0x40, 
	0x4B, 0xB8, 0xA3, 0xD0, 0x9D, 0x88, 0x07, 0x99, 
	0x9F, 0x43, 0x91, 0xDA, 0x84, 0xBB, 0xFB, 0x2D, 
	0x82, 0x40, 0xDA, 0x2C, 0x58, 0x60, 0x9E, 0x60, 
	0x73, 0xE3, 0x90, 0xE0, 0x6A, 0x08, 0x1D, 0xCB, 
	0x8B, 0xBD, 0xEE, 0x71, 0x89, 0x1F, 0x44, 0x69, 
	0x8E, 0x80, 0x93, 0xA5, 0x66, 0x2C, 0x66, 0xF9, 
	0x31, 0x5B, 0x4C, 0xFA, 0x50, 0x9E, 0x4E, 0xD3, 
	0x4E, 0x88, 0x6D, 0x77, 0xD1, 0x1A, 0xFA, 0x1A, 
	0x93, 0xF2, 0x7E, 0x5C, 0x9F, 0x9C, 0xF9, 0xD1, 
	0xEF, 0x15, 0xFF, 0x57, 0xB9, 0x3E, 0x46, 0x7A, 
	0xC0, 0x02, 0x16, 0x69, 0xD2, 0x99, 0xC8, 0x9F, 
	0x5F, 0x00, 0x7C, 0xA8, 0xFF, 0x3E, 0x09, 0xB3, 
	0xCE, 0x56, 0x0E, 0x21, 0x34, 0x1D, 0x5E, 0xD5, 
	0x0D, 0x67, 0x88, 0x42, 0xD2, 0xCE, 0xD9, 0xB5, 
	0xB2, 0x50, 0x0A, 0xBE, 0x99, 0x72, 0xA6, 0xA4, 
	0x68, 0xEB, 0x8A, 0xAB, 0xAB, 0x5B, 0x9D, 0x12, 
	0xCE, 0x2D, 0x14, 0xE5, 0xFF, 0x91, 0x81, 0xAA, 
	0x27, 0x81, 0xF2, 0xDE, 0x57, 0x11, 0x7B, 0xC5, 
	0x22, 0xEF, 0xAC, 0xCB, 0xCF, 0xBA, 0xE1, 0xFC, 
	0x60, 0x27, 0xC6, 0xCF, 0x04, 0x48, 0xE5, 0x12, 
	0x65, 0x61, 0xD9, 0x8A, 0xF7, 0xD8, 0xB7, 0x4E, 
	0xFC, 0x66, 0x69, 0x48, 0x3A, 0xC1, 0x72, 0x13, 
	0x83, 0x9D, 0xDD, 0xAE, 0xD4, 0xEA, 0x01, 0x44, 
	0x7E, 0x13, 0xB1, 0x28, 0x2E, 0x92, 0x2C, 0x8A, 
	0xAF, 0x32, 0x19, 0xDE, 0x17, 0x26, 0xFC, 0x56, 
	0x1F, 0xEC, 0x43, 0xFF, 0x38, 0x49, 0x35, 0x0C, 
	0x34, 0xB4, 0x84, 0x2E, 0xF6, 0x24, 0x10, 0xFA, 
	0xF0, 0xAE, 0xA9, 0xFF, 0xE8, 0x40, 0xB4, 0x6F, 
	0x23, 0x4C, 0x86, 0x81, 0x01, 0x84, 0xC8, 0xFF, 
	0x12, 0xFA, 0x03, 0x72, 0x0C, 0x84, 0xFC, 0x91, 
	0x27, 0xC5, 0x9A, 0x6F, 0x5E, 0x90, 0x90, 0x51, 
	0x32, 0x22, 0x3F, 0x9E, 0xBC, 0x36, 0xDE, 0x66, 
	0xA9, 0x0C, 0x3D, 0xAC, 0x86, 0x92, 0x09, 0xDD, 
	0x58, 0xF3, 0xF5, 0xD5, 0x10, 0x1F, 0x4C, 0xC9, 
	0x30, 0x98, 0x4A, 0xBE, 0xC6, 0x23, 0x7B, 0xA6, 
	0x0C, 0xAD, 0x98, 0x5C, 0xDE, 0xD1, 0x1C, 0x09, 
	0xC5, 0x40, 0x02, 0xF1, 0xBA, 0xAD, 0x38, 0xDD, 
	0xC1, 0xD3, 0x38, 0xFB, 0x6B, 0x05, 0x04, 0xA0, 
	0x39, 0x61, 0x6E, 0x14, 0xB2, 0xF4, 0x0B, 0xF7, 
	0xBC, 0x81, 0xE6, 0x44, 0xF1, 0xA7, 0x53, 0xAC, 
	0xE7, 0xD6, 0xC3, 0xA7, 0x21, 0x8B, 0x6E, 0x11, 
	0xF8, 0xB9, 0x6E, 0xA6, 0xFF, 0xE9, 0x8C, 0xB1, 
	0x30, 0x9A, 0x52, 0x1A, 0xDB, 0x6D, 0xED, 0x43, 
	0x70, 0x96, 0x95, 0x23, 0xE9, 0x5A, 0x15, 0x57, 
	0x45, 0x5F, 0x73, 0xBB, 0x2B, 0xBB, 0xD9, 0xB6, 
	0x95, 0xD7, 0x2F, 0x37, 0x6B, 0x2D, 0x87, 0xFF, 
	0x2D, 0x1C, 0x4A, 0x28, 0x32, 0x09, 0x85, 0x83, 
	0xB2, 0xBC, 0x65, 0x84, 0x88, 0xBE, 0xC2, 0x76, 
	0x57, 0x79, 0x1A, 0x09, 0x92, 0xD1, 0x0A, 0x0D, 
	0x0D, 0x5D, 0x0E, 0xBC, 0x7F, 0x67, 0xD3, 0x9A, 
	0xBE, 0x94, 0xCB, 0xC8, 0x79, 0x62, 0x0A, 0xA4, 
	0x95, 0x6B, 0x6C, 0x0B, 0x6A, 0x0D, 0x3E, 0x92, 
	0x16, 0x2C, 0x2D, 0xC3, 0xA2, 0xE9, 0x90, 0xB2, 
	0x53, 0x70, 0x98, 0xEE, 0xF3, 0xD7, 0x0C, 0x68, 
	0x91, 0x97, 0x87, 0x24, 0x80, 0xB7, 0xCB, 0xDD, 
	0x48, 0x4A, 0xDC, 0x65, 0xF5, 0x22, 0xC0, 0x78, 
	0xF9, 0xA5, 0xE0, 0x98, 0x32, 0x45, 0x25, 0xED, 
	0x53, 0xA3, 0x87, 0xB4, 0xEB, 0xFF, 0xCD, 0x7F, 
	0x69, 0xD0, 0x84, 0x32, 0xE8, 0x53, 0x99, 0xAA, 
	0xD4, 0x39, 0x27, 0xAD, 0x61, 0x48, 0x50, 0xA1, 
	0x8C, 0x45, 0x55, 0x9C, 0x45, 0x3F, 0x3A, 0x59, 
	0x2D, 0xA4, 0x44, 0x9F, 0x72, 0xA1, 0x24, 0x92, 
	0x05, 0xB7, 0x94, 0xAB, 0xD4, 0x39, 0x49, 0x5C, 
	0x5A, 0x30, 0xBA, 0x0B, 0x1C, 0xF1, 0xD3, 0xBA, 
	0x0F, 0x37, 0xA3, 0x6B, 0x51, 0x5F, 0x46, 0x59, 
	0xC5, 0x71, 0xB1, 0x04, 0xCE, 0x31, 0xF4, 0x3E, 
	0xC4, 0xB8, 0x3A, 0x08, 0x3F, 0xE7, 0x64, 0x68, 
	0x69, 0xA2, 0x46, 0xDD, 0xCE, 0x90, 0x93, 0x43, 
	0x59, 0x93, 0x0C, 0x60, 0x99, 0xE3, 0x28, 0x6A, 
	0xBB, 0x0E, 0x42, 0x7E, 0x8A, 0x28, 0xDD, 0x95, 
	0x4B, 0x93, 0x12, 0x1D, 0xBC, 0xF0, 0x82, 0x26, 
	0x0C, 0xF4, 0xF1, 0x7F, 0xD2, 0x05, 0x88, 0x46, 
	0x66, 0xE7, 0xAA, 0x05, 0x33, 0xDE, 0xBA, 0x27, 
	0xB8, 0x30, 0xCB, 0x95, 0x85, 0x6D, 0xFF, 0x8B, 
	0x5E, 0x00, 0x63, 0x26, 0x88, 0x71, 0x54, 0x86, 
	0x68, 0xFB, 0x2D, 0x9B, 0x63, 0x06, 0xCB, 0xFF, 
	0x81, 0xE2, 0x19, 0xEA, 0xEA, 0x7B, 0x51, 0x34, 
	0xF0, 0x35, 0x1F, 0xCE, 0x5D, 0x36, 0x28, 0x52, 
	0xB9, 0xE1, 0x5D, 0x94, 0xD4, 0x19, 0xC2, 0xE2, 
	0x30, 0xD9, 0x9F, 0xAD, 0x99, 0x1E, 0xA8, 0x84, 
	0x90, 0x61, 0x7C, 0x3B, 0x70, 0x63, 0xC1, 0x60, 
	0x61, 0x29, 0x69, 0x64, 0x8A, 0x2A, 0x00, 0xC3, 
	0x5E, 0x35, 0xDB, 0x42, 0xEB, 0xC1, 0x88, 0xEB, 
	0xB7, 0x95, 0x49, 0x50, 0xB7, 0x3E, 0x4C, 0x95, 
	0x74, 0x0D, 0x23, 0x0B, 0x56, 0x7F, 0x39, 0x97, 
	0x95, 0xEF, 0xCD, 0x50, 0xF5, 0x32, 0x4E, 0x34, 
	0xFB, 0x3C, 0x99, 0x5A, 0x00, 0x5F, 0x5A, 0x37, 
	0x89, 0xB4, 0xB0, 0x1B, 0x7E, 0xCB, 0x17, 0xF7, 
	0xE8, 0xE9, 0x94, 0x0A, 0xC3, 0xD6, 0xB7, 0x9D, 
	0x50, 0xE2, 0xD2, 0x73, 0x62, 0x05, 0x33, 0xFF, 
	0xFF, 0x72, 0xE2, 0x0E, 0xDC, 0xB4, 0xEB, 0xE6, 
	0x55, 0xD3, 0x5D, 0x39, 0xFE, 0xDB, 0x57, 0x27, 
	0x3A, 0xA1, 0x1C, 0xD7, 0x83, 0xB5, 0x43, 0xF6, 
	0xB8, 0x4E, 0x53, 0x8A, 0x36, 0x57, 0x6C, 0xF8, 
	0x4F, 0x0A, 0x64, 0xD7, 0x61, 0x44, 0x2C, 0x5B, 
	0x66, 0xB3, 0x47, 0x5A, 0xFB, 0xB9, 0x4B, 0x96, 
	0x42, 0x58, 0x79, 0x39, 0x9B, 0xFC, 0xF0, 0x00, 
	0x3A, 0xEE, 0x22, 0x35, 0x99, 0x0F, 0x9D, 0xCA, 
	0x20, 0x3A, 0x2E, 0xDA, 0x61, 0x1E, 0xB1, 0x05, 
	0xD2, 0xFF, 0xB5, 0xB0, 0x30, 0xAC, 0x8B, 0x7E, 
	0x27, 0x70, 0x44, 0x6A, 0x08, 0x9A, 0x52, 0x36, 
	0x45, 0x0C, 0x8C, 0x4E, 0x51, 0xD5, 0xA4, 0xFE, 
	0x4B, 0xAD, 0x47, 0x35, 0xC3, 0x6E, 0x8E, 0x0F, 
	0x9C, 0x5A, 0x88, 0xE3, 0xEE, 0x5B, 0x60, 0x77, 
	0xEE, 0x17, 0xB6, 0x3D, 0x35, 0xF8, 0xC6, 0xB9, 
	0xF3, 0x57, 0xCB, 0xCC, 0xB6, 0xFE, 0x3B, 0x03, 

	/* Database Page 23 */

	0xFF, 0x93, 0xD8, 0xB8, 0x8F, 0xDE, 0xD1, 0xAB, 
	0x89, 0x55, 0xD0, 0xFB, 0x5A, 0xB0, 0xC4, 0x35, 
	0x46, 0x9F, 0x5F, 0x68, 0xEC, 0x57, 0xFA, 0x68, 
	0x80, 0xCC, 0xC1, 0xD0, 0xDC, 0xF2, 0x44, 0x76, 
	0xCB, 0x6A, 0xCE, 0x02, 0xBD, 0x0D, 0x4A, 0x30, 
	0x3E, 0xB3, 0xCA, 0x9D, 0xE2, 0xE3, 0x02, 0x72, 
	0x1D, 0x59, 0x66, 0xD5, 0xE7, 0x9A, 0x74, 0xAD, 
	0xE5, 0x81, 0x26, 0x47, 0x65, 0x42, 0x20, 0x73, 
	0x6D, 0x06, 0x30, 0x1C, 0x7A, 0xC1, 0x1E, 0x4E, 
	0xCE, 0xFF, 0x77, 0xAB, 0x21, 0xA7, 0xB1, 0x7C, 
	0xFA, 0x9E, 0x74, 0x57, 0x68, 0xA9, 0xD1, 0xDE, 
	0xDB, 0xF9, 0x5B, 0x07, 0xFD, 0x4E, 0x90, 0xD5, 
	0xF1, 0x61, 0x6B, 0x06, 0xFC, 0x02, 0x13, 0xD6, 
	0xE6, 0xE7, 0x5D, 0xC4, 0x86, 0x62, 0x2E, 0x8A, 
	0x1B, 0x34, 0x1A, 0x2B, 0xF0, 0xF3, 0x5D, 0x5E, 
	0x5F, 0x44, 0xEF, 0x2F, 0xA1, 0xFD, 0x9E, 0x56, 
	0xAF, 0xFF, 0xB2, 0xF0, 0x3E, 0xBB, 0x29, 0xFC, 
	0xAC, 0xD0, 0x3A, 0x44, 0x13, 0x39, 0x17, 0x27, 
	0x35, 0x19, 0x95, 0x03, 0x01, 0x20, 0xE9, 0xE8, 
	0x22, 0xE2, 0x40, 0x1A, 0xF7, 0xD5, 0x3E, 0xB1, 
	0xD9, 0x63, 0x11, 0x38, 0x06, 0x9A, 0x93, 0x5B, 
	0xB3, 0xB7, 0xD2, 0xDD, 0x4D, 0x5F, 0xFC, 0x40, 
	0x7A, 0xA3, 0x58, 0x12, 0x44, 0xEC, 0x04, 0x58, 
	0xBE, 0x28, 0x7D, 0x5E, 0x0B, 0x91, 0xEB, 0x8D, 
	0x4C, 0x61, 0x06, 0xF8, 0x1A, 0xB8, 0x03, 0x1F, 
	0xE2, 0x5D, 0x66, 0xBF, 0x01, 0x9A, 0x48, 0x75, 
	0x60, 0x4B, 0x22, 0x33, 0x30, 0x09, 0xD1, 0x81, 
	0x38, 0x7D, 0x2F, 0xCD, 0x3F, 0x1B, 0xE1, 0xDD, 
	0xB6, 0x23, 0xFA, 0x85, 0xF7, 0x52, 0x86, 0xBA, 
	0x89, 0xB3, 0xDA, 0xDB, 0x86, 0x3A, 0x60, 0x46, 
	0x6E, 0x16, 0xAE, 0x18, 0x92, 0x9C, 0x60, 0xC0, 
	0xD4, 0x1C, 0x25, 0x19, 0xE7, 0x8F, 0x0B, 0x05, 
	0xFD, 0x9B, 0xFF, 0x9B, 0x89, 0x59, 0x15, 0x3A, 
	0x1C, 0x47, 0x8B, 0x64, 0x99, 0x55, 0x82, 0xEB, 
	0x57, 0x64, 0xF7, 0x7C, 0xE5, 0xC4, 0xC1, 0x5D, 
	0x57, 0x88, 0xCF, 0xBA, 0xDC, 0x97, 0xFE, 0xDC, 
	0xC0, 0x14, 0xAF, 0x3B, 0x8E, 0x26, 0x1B, 0x0B, 
	0xE7, 0x78, 0xBA, 0x97, 0xB5, 0x29, 0xB4, 0xD4, 
	0x33, 0x4D, 0x9A, 0x1E, 0x4A, 0xBA, 0x24, 0xFA, 
	0xB6, 0x6F, 0x26, 0xED, 0xE7, 0xC4, 0xC1, 0x65, 
	0xBE, 0x27, 0xF8, 0x40, 0x6F, 0x59, 0x9B, 0x6B, 
	0xE1, 0x1E, 0x66, 0xBF, 0x3E, 0xD0, 0x0E, 0x32, 
	0xC5, 0x1D, 0xDD, 0x9F, 0xBA, 0x8D, 0xDD, 0x4D, 
	0x43, 0x57, 0x3E, 0x17, 0x27, 0xFF, 0xB3, 0x37, 
	0x11, 0x1A, 0x72, 0xCE, 0xEC, 0x86, 0x5D, 0x7F, 
	0x6E, 0x07, 0x8B, 0x27, 0x7E, 0x13, 0x22, 0x3C, 
	0x4A, 0x58, 0xB5, 0xAC, 0xE0, 0x67, 0xD3, 0x05, 
	0x9A, 0x1A, 0x97, 0xD6, 0x32, 0x96, 0xD1, 0x8D, 
	0xB2, 0xFF, 0x3B, 0xFF, 0xB5, 0xB1, 0xFA, 0x6D, 
	0xBC, 0xA7, 0xB1, 0x3A, 0x96, 0xD9, 0xD3, 0x18, 
	0xE5, 0xBD, 0xC2, 0x28, 0xB6, 0x7A, 0xFA, 0x9A, 
	0xDB, 0xE9, 0xAC, 0xF5, 0x38, 0xBC, 0x4A, 0x1E, 
	0x11, 0xD1, 0x0C, 0x86, 0xED, 0xC7, 0x17, 0xAA, 
	0xD6, 0x1B, 0xE8, 0xBF, 0x4F, 0x51, 0xF8, 0x98, 
	0xC4, 0x18, 0x3C, 0x1C, 0xBA, 0x3B, 0xD4, 0x9E, 
	0x9D, 0x5E, 0xDC, 0x99, 0xB5, 0xD4, 0xB9, 0xAE, 
	0x3A, 0x0F, 0x66, 0x7C, 0x02, 0xC7, 0xE3, 0x20, 
	0x64, 0x79, 0xE4, 0x65, 0xE4, 0x7D, 0xBC, 0x51, 
	0x92, 0x9A, 0x90, 0x96, 0xB2, 0x63, 0xA7, 0xA7, 
	0x24, 0xE5, 0x19, 0x4F, 0x64, 0xFA, 0xFC, 0x91, 
	0xD6, 0x60, 0x62, 0x9F, 0x25, 0xAB, 0xF0, 0xFD, 
	0x3A, 0x5E, 0x25, 0x4A, 0xC6, 0x51, 0x44, 0xEE, 
	0xE1, 0x32, 0x64, 0xC8, 0x8D, 0x70, 0x64, 0xB3, 
	0x6F, 0xC5, 0xEF, 0xFD, 0x52, 0x3C, 0x2D, 0xCB, 
	0xE1, 0x5A, 0xB2, 0xE3, 0xFF, 0xF1, 0x36, 0x6F, 
	0x6A, 0xF0, 0xC6, 0xCA, 0xA5, 0xCC, 0xAB, 0xC6, 
	0xB7, 0x03, 0xE7, 0x16, 0x28, 0x12, 0x57, 0x4C, 
	0x45, 0x2F, 0x31, 0xF9, 0xAB, 0x22, 0xD4, 0xE7, 
	0x73, 0xB7, 0xD7, 0xCB, 0x7A, 0xBE, 0x97, 0x67, 
	0xAA, 0x6E, 0x1E, 0xEB, 0x32, 0xC5, 0xA9, 0x84, 
	0x74, 0xF5, 0xB3, 0x8B, 0xC8, 0x56, 0x43, 0x2B, 
	0x56, 0x49, 0x8D, 0x76, 0x04, 0xD6, 0x28, 0x5E, 
	0x01, 0x0C, 0x51, 0x07, 0xC3, 0x93, 0x68, 0xB1, 
	0xC5, 0xCC, 0x10, 0xCA, 0xB4, 0x48, 0x4B, 0x9C, 
	0x00, 0xC8, 0xC3, 0x0D, 0xE9, 0x33, 0x8E, 0xBE, 
	0x03, 0x5A, 0x11, 0x3D, 0x67, 0x70, 0xA5, 0x8B, 
	0xC7, 0xF8, 0x1E, 0xD4, 0x31, 0xA7, 0xB2, 0xAE, 
	0x24, 0x5A, 0x03, 0x2D, 0xF3, 0x36, 0x26, 0xBC, 
	0xB3, 0xBA, 0x6F, 0x1C, 0x11, 0x54, 0xD1, 0xAC, 
	0x0B, 0xCD, 0xAB, 0x90, 0xF2, 0xAB, 0x7F, 0x4E, 
	0xEA, 0x92, 0x69, 0x93, 0xB5, 0xFF, 0x72, 0x34, 
	0x92, 0x8C, 0xB0, 0x6B, 0xF3, 0xD4, 0x9C, 0x83, 
	0xB8, 0xA7, 0x0D, 0x7E, 0xDA, 0xC9, 0xF4, 0x4C, 
	0xFF, 0x46, 0x9C, 0xFA, 0x81, 0x0D, 0xCA, 0x67, 
	0xED, 0x80, 0x61, 0xAD, 0xA1, 0x5E, 0x8B, 0x1A, 
	0x54, 0x9C, 0x14, 0x1A, 0x1D, 0x97, 0x34, 0x4D, 
	0x41, 0xA9, 0x29, 0x0D, 0x87, 0x24, 0x55, 0x5B, 
	0x6A, 0x1B, 0xAF, 0x0F, 0x09, 0x01, 0x3F, 0xD2, 
	0x82, 0x1B, 0xC6, 0x25, 0x56, 0xBF, 0xEF, 0xB9, 
	0xE6, 0x94, 0x70, 0xCE, 0xB4, 0x9A, 0x1B, 0xF7, 
	0xDB, 0xDA, 0xC0, 0xBF, 0x77, 0xFB, 0x95, 0x58, 
	0xE9, 0x23, 0x04, 0x8D, 0x39, 0x27, 0xC3, 0x76, 
	0x63, 0x51, 0x2F, 0x20, 0x28, 0x57, 0x1F, 0xDB, 
	0x36, 0xC7, 0x0F, 0xFB, 0x91, 0xFE, 0x86, 0x20, 
	0x7D, 0x3E, 0x2F, 0x66, 0x82, 0x6D, 0xC1, 0x49, 
	0xEA, 0x3B, 0x54, 0x1D, 0x5E, 0xD2, 0xC0, 0x88, 
	0x41, 0x59, 0x69, 0x62, 0x1A, 0x7F, 0xFF, 0xC6, 
	0x97, 0xFC, 0x8E, 0xCE, 0x5F, 0x9D, 0x2C, 0x74, 
	0x08, 0xDF, 0xB0, 0x9C, 0x0D, 0x3A, 0xB8, 0xBA, 
	0x53, 0xB2, 0x7D, 0x79, 0xE4, 0x04, 0x6E, 0x11, 
	0x06, 0xBE, 0x7C, 0xC9, 0x5C, 0x5B, 0xA1, 0x75, 
	0xFF, 0x74, 0x5D, 0x56, 0xB2, 0x08, 0xF9, 0x3E, 
	0xD0, 0x44, 0xCE, 0x9A, 0x12, 0x23, 0x9B, 0x23, 
	0x42, 0x34, 0xCB, 0x50, 0x2D, 0x4C, 0x68, 0x7E, 
	0x87, 0x9C, 0xB0, 0x97, 0x31, 0xE9, 0x8A, 0x35, 
	0xD6, 0x5C, 0xC5, 0x00, 0x78, 0x1E, 0x3B, 0x45, 
	0x87, 0xE6, 0xEF, 0xF2, 0x06, 0x42, 0xED, 0x51, 
	0x64, 0x9A, 0xB9, 0x02, 0x53, 0x03, 0x12, 0xAC, 
	0x51, 0x78, 0x08, 0xA0, 0x10, 0x9D, 0x59, 0x1D, 
	0xCD, 0xDC, 0x1F, 0x4B, 0x6F, 0x4F, 0x0B, 0x84, 
	0x9C, 0x1F, 0x41, 0xB1, 0xFD, 0x5D, 0x56, 0x46, 
	0x8E, 0xDB, 0x87, 0xBD, 0x43, 0x26, 0x05, 0x15, 
	0xD6, 0x1E, 0xCD, 0x99, 0x86, 0x6A, 0xB1, 0xFF, 
	0x2A, 0x5D, 0x93, 0x3E, 0x7F, 0x3E, 0x84, 0x13, 
	0x61, 0x3A, 0x89, 0xCC, 0x08, 0xE5, 0x5C, 0x57, 
	0x5A, 0x0B, 0x96, 0x05, 0xBF, 0x6F, 0xAE, 0x76, 
	0x16, 0x3D, 0x14, 0x85, 0xCA, 0x40, 0x40, 0xE1, 
	0x39, 0xCF, 0x24, 0xF2, 0xFC, 0x7B, 0x6A, 0x6E, 
	0x56, 0x13, 0xB9, 0xB5, 0xA9, 0x32, 0x2C, 0x23, 
	0xB3, 0x6D, 0xF5, 0xBA, 0xD1, 0x46, 0x56, 0x8D, 
	0x20, 0x94, 0xA4, 0xA1, 0xF7, 0x88, 0x5C, 0xC0, 
	0xBC, 0xD1, 0xB4, 0xBF, 0x31, 0x1C, 0x61, 0x46, 
	0x80, 0xA8, 0xC8, 0xF0, 0x2C, 0xA0, 0x86, 0x86, 
	0x6F, 0xD6, 0x8C, 0xF6, 0xFC, 0xD0, 0x7F, 0xEA, 
	0x73, 0x94, 0xE9, 0xE0, 0x77, 0xBA, 0xD8, 0x09, 
	0xDB, 0xC7, 0x2F, 0xD4, 0xE6, 0xA7, 0xC8, 0x1A, 
	0x58, 0xB9, 0xFE, 0x0D, 0x3A, 0x61, 0x13, 0xCF, 
	0x20, 0x9F, 0x3C, 0x5D, 0x80, 0xE6, 0xB6, 0x37, 
	0x70, 0x69, 0xAF, 0x90, 0x4E, 0xDC, 0x59, 0xDC, 
	0xFF, 0xAD, 0xB4, 0xE1, 0xF8, 0x8B, 0x88, 0x47, 
	0x98, 0x99, 0x6B, 0x3E, 0x42, 0x4A, 0x70, 0x42, 
	0xE7, 0xCA, 0x5E, 0x1B, 0xFD, 0xA1, 0xCA, 0x41, 
	0xB2, 0xB0, 0x6F, 0xB0, 0x43, 0xE8, 0x06, 0x49, 
	0xDB, 0x90, 0x02, 0xBD, 0x7E, 0x73, 0x51, 0x6A, 
	0x81, 0x3A, 0x27, 0xC7, 0x4D, 0x76, 0x24, 0xF0, 
	0x91, 0x6D, 0x98, 0x58, 0x42, 0xEA, 0x9F, 0xB0, 
	0x1D, 0x98, 0xF2, 0x20, 0x13, 0x4B, 0xCB, 0x8D, 
	0xE3, 0x80, 0x46, 0x04, 0x2D, 0x70, 0xB8, 0xE5, 
	0x3A, 0x4E, 0x3C, 0x59, 0x20, 0xFA, 0x8A, 0xF8, 
	0x1F, 0xBF, 0x70, 0x7B, 0xCF, 0x0A, 0xE5, 0x13, 
	0x6B, 0xFC, 0x00, 0x42, 0xAB, 0xC6, 0xF2, 0xFC, 
	0x0E, 0x91, 0xE9, 0x13, 0x7E, 0x95, 0x37, 0x08, 
	0x3E, 0xB4, 0xDD, 0x83, 0x81, 0x5F, 0x81, 0x30, 
	0x48, 0xA5, 0x1D, 0x05, 0x62, 0x09, 0xC7, 0x74, 
	0xFB, 0x78, 0x56, 0xFC, 0xE5, 0x29, 0x87, 0xA9, 
	0xE1, 0xFF, 0xA4, 0xA8, 0xEC, 0x81, 0xD0, 0x55, 
	0xF6, 0x6E, 0x82, 0x50, 0xA8, 0x0F, 0xBB, 0x86, 
	0x88, 0x84, 0x03, 0xA3, 0x43, 0x1A, 0x97, 0x87, 
	0xA2, 0xF6, 0x61, 0xF2, 0x98, 0xDA, 0x5F, 0x71, 
	0x34, 0xA2, 0xEE, 0x6C, 0x4E, 0x4C, 0x7A, 0x51, 
	0x2A, 0x04, 0xF3, 0x59, 0x63, 0x53, 0xE5, 0xAC, 
	0x40, 0x6F, 0xB1, 0x9C, 0xFA, 0x49, 0xF2, 0x43, 
	0x2C, 0x43, 0x3D, 0x03, 0xE9, 0x0B, 0x8D, 0xD8, 
	0x86, 0x03, 0xBF, 0x98, 0x38, 0x6E, 0x3D, 0x15, 
	0xA6, 0xE4, 0x1C, 0xC7, 0x1E, 0xC8, 0xDA, 0x16, 
	0x16, 0x50, 0x37, 0xB7, 0x7B, 0xDA, 0x06, 0x7D, 
	0xB4, 0x31, 0xDE, 0x2A, 0xA8, 0x25, 0xD9, 0x94, 
	0x1A, 0x10, 0x42, 0x66, 0x3A, 0xC3, 0xBA, 0x7B, 
	0x94, 0xB3, 0x0B, 0x3A, 0x31, 0xA4, 0x48, 0xB8, 
	0x8B, 0xE7, 0x31, 0x33, 0x47, 0x95, 0x44, 0x12, 
	0x36, 0x7F, 0xA4, 0x19, 0xEE, 0x85, 0x20, 0x0F, 
	0x3A, 0xE9, 0xFF, 0x82, 0x11, 0xBD, 0x6F, 0x40, 
	0x28, 0xCB, 0x21, 0x9B, 0x22, 0xE1, 0x9C, 0x1F, 
	0xA7, 0xAD, 0x48, 0x60, 0xE4, 0xC0, 0x17, 0xC1, 
	0xB7, 0x90, 0x85, 0x8A, 0x12, 0xF5, 0x2E, 0x17, 
	0x56, 0xF0, 0x1C, 0x0D, 0x61, 0xD5, 0x08, 0x3C, 
	0x11, 0x99, 0x23, 0x1B, 0x71, 0xA7, 0xB2, 0xF7, 
	0xF4, 0x68, 0x87, 0x5A, 0x12, 0x93, 0xC0, 0x8B, 
	0x06, 0xF8, 0xDD, 0x3A, 0xCF, 0x04, 0x68, 0x95, 
	0xAE, 0xC6, 0xC3, 0x14, 0xD7, 0x7C, 0x1E, 0x29, 
	0x83, 0x61, 0xD1, 0x93, 0x46, 0xD2, 0x24, 0x01, 
	0xA1, 0xD1, 0x17, 0x29, 0x3B, 0x06, 0xCD, 0xB5, 
	0x28, 0xAF, 0xDC, 0x09, 0xFA, 0x7A, 0x1E, 0xCC, 
	0x4C, 0x05, 0x37, 0x31, 0x98, 0xF1, 0xCF, 0x4A, 
	0x18, 0xC1, 0x7B, 0xD8, 0x88, 0xB8, 0x94, 0xB8, 
	0x17, 0xF2, 0x26, 0x7B, 0x9B, 0xED, 0x8E, 0x9F, 
	0xE4, 0xE6, 0xA6, 0xEB, 0x8A, 0xFF, 0x07, 0x32, 
	0xC8, 0x58, 0x38, 0xFF, 0x95, 0x87, 0xB0, 0xE5, 
	0xE6, 0x35, 0xDE, 0xDE, 0x54, 0xCB, 0x3D, 0x3B, 
	0xF1, 0xCA, 0x53, 0x83, 0xDF, 0x19, 0x37, 0x32, 
	0x2C, 0xC4, 0x27, 0xEA, 0xD2, 0x0B, 0x6B, 0xCB, 
	0x37, 0x41, 0x0C, 0x0E, 0xCF, 0x4C, 0x78, 0x82, 
	0x04, 0xFC, 0x96, 0x77, 0x1B, 0xE7, 0x4C, 0x96, 
	0xC3, 0xC6, 0x56, 0x7C, 0x22, 0x03, 0xD7, 0x01, 
	0x78, 0x3F, 0x17, 0x31, 0x3D, 0xC3, 0xFC, 0x21, 
	0xAB, 0x0C, 0x94, 0xFC, 0xA7, 0xEB, 0xC4, 0x01, 
	0x0F, 0x4C, 0x6D, 0x50, 0x27, 0x61, 0x57, 0x77, 
	0xF8, 0x53, 0x70, 0x63, 0xDC, 0x99, 0x84, 0x29, 
	0x83, 0x40, 0x4A, 0x66, 0xA7, 0xAF, 0x91, 0xE9, 
	0xB2, 0xA1, 0x41, 0x18, 0xD2, 0x0A, 0xE2, 0xC8, 
	0x8A, 0x5C, 0x4E, 0xC5, 0x75, 0x41, 0x42, 0x1E, 
	0xB9, 0x5D, 0x49, 0x19, 0xFF, 0x3D, 0xD0, 0xD2, 
	0x29, 0x41, 0xB7, 0xDF, 0x93, 0x9F, 0xE0, 0x63, 
	0x30, 0x56, 0xE1, 0x97, 0xFF, 0x56, 0xB4, 0xA7, 
	0xDC, 0xF0, 0x19, 0x9B, 0x18, 0xDC, 0xAE, 0x7B, 
	0xE8, 0x4F, 0x9B, 0x9F, 0x42, 0x69, 0xF5, 0x7C, 
	0x9C, 0x80, 0x97, 0x79, 0x14, 0xA6, 0x73, 0x4B, 
	0xD8, 0xFF, 0x0A, 0xEB, 0x49, 0x54, 0xF9, 0x75, 
	0x8F, 0x4B, 0x0D, 0xB6, 0x79, 0x36, 0x10, 0xA0, 
	0xC1, 0xCA, 0xAF, 0xC1, 0xCD, 0x73, 0x77, 0xFE, 
	0xEF, 0x81, 0x5D, 0xFB, 0x7B, 0x78, 0x18, 0x60, 
	0xBF, 0xD5, 0x07, 0x85, 0xBA, 0xC4, 0x76, 0xE5, 
	0x71, 0x05, 0x60, 0x16, 0x3D, 0x4D, 0xDD, 0xBB, 
	0x44, 0xD1, 0xC1, 0x76, 0x18, 0x93, 0xD2, 0x4C, 
	0x84, 0x73, 0xF4, 0x9F, 0xED, 0x8C, 0x22, 0xA5, 
	0x9C, 0xC0, 0xAE, 0x7E, 0x95, 0xA7, 0x0E, 0x5A, 
	0x72, 0xBC, 0xEE, 0x4B, 0x83, 0xB2, 0x5D, 0xAA, 
	0x8E, 0xC4, 0x75, 0x6A, 0x01, 0x99, 0x34, 0xB1, 
	0x92, 0x73, 0xC8, 0xEF, 0x2E, 0x06, 0xE6, 0xB1, 
	0xCB, 0xD7, 0xEA, 0x76, 0xE8, 0xFF, 0xE3, 0x64, 
	0x2B, 0x67, 0x0E, 0xB1, 0x18, 0x99, 0xF6, 0x60, 
	0x9F, 0x56, 0x39, 0x28, 0xD5, 0x77, 0x54, 0xE0, 
	0xEA, 0x7E, 0xD5, 0xE8, 0x53, 0x97, 0x3B, 0x67, 
	0xEF, 0xA5, 0x55, 0xD6, 0x67, 0xCF, 0xDE, 0x21, 
	0x40, 0xE9, 0x3F, 0xE7, 0x19, 0x6E, 0xFC, 0xB4, 
	0xF2, 0x33, 0xD9, 0xF7, 0x7A, 0x98, 0xF3, 0x56, 
	0x9F, 0xE6, 0x95, 0x6E, 0x59, 0x2B, 0x13, 0x62, 
	0x86, 0x78, 0xAB, 0x11, 0xA1, 0x26, 0x40, 0xBF, 
	0x54, 0x71, 0x40, 0xAB, 0xC9, 0x8B, 0xB9, 0xB7, 
	0x77, 0x8A, 0x1C, 0x2D, 0x97, 0xE9, 0xE5, 0xFD, 
	0xDA, 0x27, 0x84, 0xE0, 0x05, 0x77, 0xFB, 0xE7, 
	0x84, 0xF2, 0xF9, 0xBB, 0xA4, 0x84, 0x09, 0xD0, 
	0xB5, 0x85, 0xE1, 0x51, 0xF5, 0x9E, 0xCA, 0x6B, 
	0xB8, 0x3B, 0x06, 0x45, 0x80, 0x91, 0xC7, 0xEB, 
	0x2D, 0xB1, 0x1A, 0x6B, 0xC5, 0x34, 0xCA, 0x7C, 
	0xCE, 0x99, 0x72, 0x4B, 0x01, 0x49, 0xFF, 0x54, 
	0xAF, 0xCF, 0xCF, 0x80, 0x4E, 0x1B, 0x66, 0xBB, 
	0x34, 0x36, 0x29, 0x71, 0xA8, 0xD8, 0xD5, 0xA1, 
	0x62, 0x9D, 0x60, 0xD8, 0x43, 0x3E, 0x3C, 0x00, 
	0x5C, 0xF6, 0x9B, 0x7F, 0xD3, 0x76, 0x79, 0x33, 
	0x84, 0xEE, 0xFA, 0x87, 0x01, 0x99, 0xE0, 0x0D, 
	0xE8, 0x55, 0x21, 0xE8, 0x23, 0x50, 0x81, 0x11, 
	0xE9, 0x56, 0x9A, 0x09, 0x76, 0x70, 0x65, 0xCD, 
	0x04, 0x13, 0x7B, 0xC8, 0x02, 0x1A, 0xF8, 0xFC, 
	0x49, 0x08, 0x78, 0x0F, 0x7C, 0x9F, 0xFC, 0x4B, 
	0x03, 0xCA, 0x36, 0x03, 0x07, 0xC0, 0x48, 0xD1, 
	0xA6, 0x6A, 0x96, 0xE6, 0xD0, 0xE2, 0xB4, 0x0E, 
	0xC9, 0xAF, 0x21, 0x5B, 0x85, 0x7E, 0x66, 0xFB, 
	0x65, 0x93, 0x6E, 0x66, 0xC3, 0x5D, 0x1A, 0x92, 
	0xAF, 0x61, 0xEC, 0xD7, 0xF9, 0xAC, 0x93, 0xA8, 
	0x67, 0x14, 0x0C, 0x16, 0x2B, 0xF3, 0x48, 0x23, 
	0x08, 0xA2, 0xBA, 0x9C, 0xBC, 0x0C, 0x6E, 0xFF, 
	0x7D, 0x93, 0xFC, 0x22, 0x1B, 0xD6, 0xDA, 0xF6, 
	0x1F, 0xD6, 0xC7, 0xCF, 0xE2, 0xBF, 0xAF, 0x3F, 
	0x43, 0x9D, 0x34, 0xE3, 0xA1, 0x10, 0x32, 0xFE, 
	0xBD, 0x38, 0x0B, 0xA2, 0x65, 0xB3, 0x2C, 0x55, 
	0x16, 0xCF, 0x91, 0x62, 0x96, 0xBA, 0x8D, 0x57, 
	0xD1, 0xDC, 0xDF, 0x77, 0x85, 0x13, 0xE3, 0xD5, 
	0x29, 0xD8, 0x76, 0x00, 0x99, 0xCC, 0xEB, 0x77, 
	0x5E, 0x4E, 0xC8, 0xD9, 0xF3, 0xA0, 0xCE, 0x3C, 
	0x63, 0xDB, 0xAF, 0xDA, 0x8A, 0x14, 0xEA, 0x5F, 
	0x7E, 0x5A, 0xB6, 0x03, 0x79, 0x76, 0x9B, 0xAC, 
	0xB3, 0xEC, 0xF2, 0xA5, 0xE3, 0xF1, 0xE4, 0x85, 
	0xD5, 0xBA, 0x23, 0x24, 0x4C, 0x2D, 0x03, 0x83, 
	0x3C, 0x75, 0x76, 0x78, 0x6A, 0x17, 0xB1, 0xE5, 
	0xA3, 0xF8, 0x1A, 0x6C, 0xE9, 0x81, 0xD1, 0xC4, 
	0x45, 0x92, 0xEA, 0x52, 0x4F, 0xD0, 0x7B, 0x59, 
	0x1C, 0x6B, 0x77, 0x6C, 0xE2, 0x99, 0xD7, 0xC8, 

	/* Database Page 24 */

	0xFF, 0xD7, 0x9E, 0x22, 0x1A, 0x51, 0xB6, 0x7D, 
	0x85, 0x43, 0xDA, 0x7C, 0xCE, 0x5B, 0xA3, 0x14, 
	0x96, 0xEB, 0xC6, 0x4B, 0x67, 0x2B, 0x1C, 0x06, 
	0x18, 0x1A, 0x1A, 0x8C, 0xA4, 0x73, 0x6B, 0x00, 
	0xA8, 0x58, 0x44, 0x48, 0x07, 0x09, 0x6D, 0x84, 
	0x7A, 0xF4, 0x10, 0x4B, 0x8C, 0x44, 0x9E, 0x6C, 
	0x28, 0xB0, 0x2F, 0x47, 0xA5, 0xCD, 0x5F, 0x31, 
	0xEC, 0xAB, 0xB0, 0x29, 0x0C, 0x1A, 0x90, 0x2C, 
	0xF3, 0x70, 0x2A, 0x29, 0x69, 0x47, 0xF4, 0xBF, 
	0x09, 0x65, 0xCE, 0x58, 0xF3, 0x4C, 0x68, 0xDD, 
	0xE2, 0xFA, 0x3F, 0xA1, 0xCA, 0x92, 0x28, 0x21, 
	0x11, 0xF7, 0x3F, 0x2F, 0xF2, 0x5B, 0x65, 0x72, 
	0xC1, 0x40, 0x91, 0xF8, 0x8F, 0x37, 0xCC, 0xA9, 
	0xFB, 0x6B, 0x5D, 0x49, 0x4B, 0x70, 0x6A, 0x50, 
	0x3E, 0x8C, 0x75, 0xD8, 0x3E, 0xB0, 0x13, 0xB0, 
	0xD2, 0x94, 0xF9, 0x05, 0x6D, 0x1B, 0x78, 0xAD, 
	0xB8, 0xFF, 0x14, 0x33, 0x07, 0x95, 0x11, 0x1F, 
	0x73, 0x47, 0xCB, 0x4E, 0x0D, 0x26, 0x55, 0x39, 
	0x72, 0x07, 0x53, 0x4F, 0x71, 0xE3, 0xB7, 0xC7, 
	0x72, 0x3F, 0x7D, 0x04, 0xD1, 0x80, 0x0E, 0x05, 
	0x44, 0xB6, 0xA2, 0x9A, 0xD9, 0x34, 0xEE, 0xA9, 
	0x2B, 0x7A, 0xA5, 0x38, 0xDC, 0x96, 0x04, 0xA2, 
	0xA8, 0x90, 0xF8, 0x95, 0x9C, 0x86, 0xBD, 0x92, 
	0x15, 0x70, 0xF8, 0xA8, 0xD1, 0x63, 0xBA, 0xBC, 
	0x9D, 0x50, 0xEB, 0xB9, 0x98, 0xC9, 0x19, 0x0C, 
	0xBA, 0xF5, 0xE4, 0x9C, 0x5D, 0x20, 0x59, 0x93, 
	0x06, 0x29, 0xB4, 0x47, 0x2F, 0x0F, 0x55, 0x63, 
	0x77, 0x4F, 0xF8, 0x70, 0xA6, 0x0D, 0x77, 0x78, 
	0x01, 0x56, 0xE8, 0x50, 0xED, 0x34, 0xF8, 0x18, 
	0xB7, 0x66, 0x64, 0xF0, 0xE5, 0xCB, 0x48, 0x63, 
	0xBF, 0x03, 0x0A, 0x0B, 0x74, 0xAD, 0x1D, 0xE1, 
	0x99, 0x84, 0x7A, 0x7B, 0x60, 0xE4, 0xC8, 0x11, 
	0x49, 0xC7, 0xFF, 0xC5, 0x8A, 0xB6, 0x01, 0x5A, 
	0xD3, 0xA8, 0x5D, 0x39, 0x6C, 0xF3, 0x5A, 0x3B, 
	0xFE, 0x9E, 0xEC, 0xD9, 0xEF, 0xA4, 0xF9, 0x2E, 
	0x8A, 0x01, 0xC0, 0xBB, 0xC2, 0xC4, 0xB5, 0x59, 
	0xFA, 0x70, 0x52, 0x7F, 0x66, 0xDA, 0x0A, 0xF4, 
	0x6F, 0x1C, 0xB5, 0xC1, 0x1A, 0x90, 0xA2, 0x06, 
	0x62, 0x20, 0x8B, 0x9C, 0xCA, 0xA7, 0xAD, 0x65, 
	0x02, 0x1F, 0x31, 0xD6, 0x7B, 0x59, 0x85, 0x42, 
	0x65, 0x1C, 0xF5, 0x76, 0xBE, 0x42, 0x1D, 0x4F, 
	0xDC, 0x5A, 0x80, 0x71, 0x5C, 0xAF, 0x9E, 0x92, 
	0x5F, 0xD9, 0x3B, 0x58, 0xAF, 0xA5, 0x7F, 0xD7, 
	0x50, 0xBA, 0xE1, 0x3B, 0x5D, 0x5E, 0x86, 0xD2, 
	0x96, 0xDF, 0x21, 0xCC, 0xA2, 0x68, 0x06, 0x9A, 
	0xFC, 0xE1, 0x14, 0x14, 0x7D, 0x7E, 0xCB, 0xCB, 
	0x0B, 0x9A, 0x51, 0x2D, 0x6D, 0xD7, 0x13, 0xA9, 
	0xE9, 0x8B, 0x79, 0x26, 0xA5, 0xE7, 0x6B, 0x5F, 
	0x04, 0x23, 0x3D, 0xFF, 0xAC, 0x0A, 0xCA, 0xD1, 
	0xB5, 0xD1, 0x45, 0xF5, 0xDB, 0xB7, 0x43, 0x4A, 
	0x8B, 0x56, 0x42, 0x49, 0x82, 0x28, 0xC2, 0xBA, 
	0x6F, 0xCD, 0x42, 0xFD, 0x4A, 0xFE, 0x9E, 0xDF, 
	0xE1, 0x63, 0x14, 0xC7, 0xCD, 0x13, 0x6B, 0x7C, 
	0xD5, 0x7F, 0xF0, 0xC0, 0x67, 0x07, 0xFD, 0x1B, 
	0x5D, 0x65, 0x39, 0x4B, 0x6C, 0x19, 0xB5, 0x0F, 
	0x65, 0x1C, 0x1C, 0x14, 0x8F, 0xC1, 0xD7, 0x3E, 
	0x2A, 0x6C, 0xFF, 0xD8, 0x71, 0xDC, 0x8D, 0xC6, 
	0x27, 0x27, 0xAA, 0x35, 0x20, 0x56, 0xA9, 0xDF, 
	0x82, 0x2E, 0xE2, 0xC1, 0x82, 0x95, 0x43, 0xB1, 
	0xF9, 0xD3, 0x23, 0xFD, 0x70, 0xAA, 0x16, 0x3D, 
	0xE2, 0xC5, 0xC9, 0x2A, 0x75, 0x34, 0xAB, 0x05, 
	0x17, 0x7C, 0xB5, 0xC3, 0x1E, 0x4F, 0x51, 0x08, 
	0x84, 0x76, 0x5F, 0xDF, 0x48, 0x01, 0x89, 0x37, 
	0xA9, 0xA0, 0xF3, 0x24, 0xDF, 0x3E, 0xE8, 0x7C, 
	0xFA, 0xEB, 0xFC, 0x89, 0xFF, 0x1A, 0x97, 0xB9, 
	0x04, 0x3C, 0x5E, 0x1A, 0x2A, 0x9C, 0x14, 0xDC, 
	0xDF, 0x82, 0x69, 0x79, 0xF3, 0x28, 0xAC, 0x98, 
	0xFE, 0xB1, 0x6E, 0xE4, 0x95, 0x0B, 0x30, 0xAC, 
	0x4E, 0xDC, 0x45, 0xEF, 0x12, 0x18, 0x79, 0x14, 
	0x59, 0x68, 0xFE, 0x0E, 0x4A, 0x0E, 0xC8, 0x8D, 
	0x17, 0xF4, 0x53, 0x26, 0xFB, 0xA1, 0xD3, 0x6E, 
	0xB8, 0xB0, 0xBD, 0xA8, 0x6C, 0xAE, 0x83, 0x93, 
	0xED, 0xC9, 0x14, 0x51, 0xE2, 0x36, 0xEC, 0x15, 
	0x06, 0x35, 0x83, 0xD3, 0xA0, 0x3A, 0x5D, 0x18, 
	0xBB, 0x1B, 0xCF, 0x12, 0xBE, 0x51, 0x2B, 0x23, 
	0x62, 0x4F, 0x1D, 0xED, 0x4D, 0xEE, 0x48, 0xED, 
	0xC4, 0x92, 0xD9, 0xA9, 0x1F, 0x08, 0xD4, 0x98, 
	0x6A, 0x8E, 0x09, 0xCD, 0x11, 0x24, 0xE5, 0x7C, 
	0xC9, 0xCD, 0x49, 0x16, 0x13, 0xF9, 0xDC, 0x72, 
	0xBE, 0x3D, 0xD0, 0x4A, 0x71, 0x8C, 0x39, 0x79, 
	0x3B, 0x36, 0xC5, 0xFD, 0x9E, 0xFF, 0xE3, 0x56, 
	0xB4, 0xC2, 0x05, 0xC0, 0xEE, 0xE8, 0x8A, 0x4E, 
	0x13, 0x00, 0x19, 0xF4, 0x4C, 0x5C, 0x2A, 0xE5, 
	0x0A, 0x5F, 0x93, 0xFB, 0xDC, 0x77, 0xBD, 0x4D, 
	0x6B, 0x0C, 0xA9, 0xFE, 0x7C, 0xBA, 0xF2, 0x29, 
	0xF3, 0xC0, 0x4B, 0x6B, 0xE6, 0xE2, 0xBF, 0xF1, 
	0x5D, 0x15, 0x8A, 0x3F, 0x1B, 0x53, 0x63, 0x09, 
	0x3B, 0x27, 0x51, 0x19, 0x0F, 0xA2, 0x9E, 0xB8, 
	0x39, 0xE8, 0xBC, 0x59, 0x99, 0x67, 0xF9, 0x60, 
	0x7E, 0xED, 0x5C, 0x76, 0xD7, 0x15, 0x2A, 0xBA, 
	0x65, 0x20, 0xCC, 0x91, 0x57, 0x05, 0xD6, 0xD5, 
	0x97, 0x8D, 0xD0, 0x31, 0x33, 0x4E, 0xA0, 0x74, 
	0x17, 0xBF, 0xF6, 0x25, 0xE4, 0x07, 0xEA, 0x05, 
	0x95, 0x24, 0x28, 0x94, 0xD2, 0x99, 0x66, 0x18, 
	0x5A, 0x04, 0xE6, 0x97, 0x2E, 0xCD, 0xAE, 0x56, 
	0x67, 0x6C, 0x2D, 0x3B, 0x12, 0x10, 0xE3, 0x39, 
	0x81, 0x58, 0xBB, 0x57, 0x0E, 0xC1, 0xFF, 0x53, 
	0x6D, 0x5B, 0x39, 0xE7, 0xEB, 0xCD, 0x56, 0x8B, 
	0x63, 0x31, 0x96, 0xBF, 0xB0, 0xCE, 0x9C, 0xF0, 
	0x83, 0xF8, 0x7A, 0x85, 0x56, 0xF5, 0x09, 0x7E, 
	0x07, 0xEA, 0xFC, 0x85, 0xED, 0x9C, 0x7D, 0x2E, 
	0xF2, 0x98, 0xD2, 0x01, 0x69, 0x8B, 0x39, 0xDA, 
	0xD6, 0x34, 0xC8, 0xA0, 0x36, 0x7A, 0x52, 0xD8, 
	0x82, 0xEE, 0x80, 0x36, 0x78, 0xF2, 0x75, 0x1D, 
	0x4D, 0x2D, 0xFB, 0x81, 0x88, 0xCA, 0x32, 0xEC, 
	0x7F, 0xDA, 0x66, 0x33, 0x6C, 0x4F, 0xDE, 0x18, 
	0xB7, 0x2D, 0x6A, 0xA1, 0xC3, 0x57, 0x7D, 0xE2, 
	0xA6, 0x76, 0x4D, 0x22, 0xE3, 0x0C, 0xE1, 0xC4, 
	0x7B, 0x7C, 0xE9, 0x13, 0x6D, 0xE4, 0xD9, 0xC8, 
	0xC7, 0xCF, 0x8A, 0x49, 0xB0, 0xA0, 0x3E, 0xDC, 
	0x9A, 0x85, 0x95, 0x11, 0xEC, 0x32, 0x6B, 0x90, 
	0x72, 0x91, 0xA1, 0x67, 0xCB, 0x34, 0x55, 0x4B, 
	0xA2, 0x56, 0x3E, 0x64, 0xDD, 0x8B, 0x7D, 0xFF, 
	0xA2, 0x9C, 0x78, 0x06, 0x7F, 0x44, 0x75, 0x21, 
	0x4F, 0xBA, 0x6B, 0x4C, 0x93, 0x37, 0xDB, 0x9E, 
	0xCB, 0xC2, 0x26, 0x83, 0xB1, 0xEA, 0xD3, 0xB7, 
	0x69, 0x81, 0x12, 0x7F, 0xE3, 0xF6, 0xB4, 0x9D, 
	0xD1, 0x15, 0x32, 0x62, 0x49, 0xD7, 0xBC, 0x06, 
	0x9D, 0xC7, 0x9D, 0x4B, 0x32, 0x9B, 0xE7, 0x15, 
	0x7B, 0x25, 0x16, 0x1B, 0x99, 0x81, 0x8B, 0xF9, 
	0x9C, 0xFE, 0x5C, 0x7A, 0x29, 0x78, 0x43, 0x2F, 
	0x55, 0xC3, 0x23, 0x71, 0x4A, 0x66, 0xA0, 0xFF, 
	0xC2, 0x17, 0xC4, 0xAE, 0xD4, 0xB0, 0x24, 0x84, 
	0xFA, 0x72, 0x77, 0x50, 0x8E, 0xA3, 0x43, 0x93, 
	0xA1, 0x52, 0xDA, 0x96, 0x84, 0x57, 0x74, 0xC7, 
	0x91, 0x9A, 0x6B, 0x6A, 0x01, 0xB9, 0x84, 0x3A, 
	0xA7, 0xAC, 0xB6, 0x15, 0x57, 0xBD, 0x5A, 0xFE, 
	0x75, 0x12, 0xA8, 0xFD, 0xCB, 0x99, 0x07, 0x25, 
	0xA5, 0xF3, 0x1F, 0xE0, 0x28, 0xA2, 0x11, 0x0B, 
	0xFF, 0xED, 0xBF, 0x8B, 0x5A, 0x50, 0x42, 0x11, 
	0x54, 0xD2, 0xB8, 0xA0, 0x2F, 0x00, 0x6A, 0x1D, 
	0xF5, 0x53, 0xDC, 0xD7, 0x40, 0xD2, 0xCD, 0xAE, 
	0x90, 0xAD, 0x83, 0xA9, 0x2E, 0xEB, 0x61, 0x7F, 
	0x02, 0x5B, 0xAC, 0xD7, 0x29, 0x41, 0x02, 0xFF, 
	0xB6, 0x9B, 0xFB, 0xC0, 0xCD, 0x59, 0x09, 0x49, 
	0x56, 0xE6, 0x0D, 0x50, 0xD2, 0x8C, 0x9C, 0xB8, 
	0x36, 0xDC, 0x43, 0x44, 0x44, 0xAE, 0x75, 0xAE, 
	0xDE, 0xE4, 0x49, 0x5C, 0x78, 0x76, 0x89, 0xA6, 
	0x06, 0x53, 0xCE, 0x97, 0x2F, 0x6A, 0x02, 0x15, 
	0xE1, 0xD7, 0x7F, 0x9A, 0xE8, 0xA4, 0xDF, 0x82, 
	0xF6, 0x3E, 0xE9, 0xC3, 0x73, 0x8C, 0xC4, 0x5D, 
	0x72, 0x1C, 0x02, 0x42, 0x89, 0xDF, 0xCD, 0xE0, 
	0x87, 0x62, 0xFE, 0xCF, 0x47, 0x12, 0x57, 0xBE, 
	0x67, 0xEA, 0x32, 0x6A, 0xD5, 0x28, 0xF1, 0xF3, 
	0x15, 0x83, 0x55, 0xD3, 0x69, 0x9B, 0x9F, 0xC1, 
	0xD2, 0xFF, 0x41, 0xB5, 0x0E, 0x63, 0x1E, 0x14, 
	0xCC, 0x44, 0xD5, 0xAC, 0xA5, 0x81, 0x58, 0xE1, 
	0x49, 0x80, 0xFC, 0x70, 0x3A, 0x10, 0x08, 0xCA, 
	0x28, 0x0A, 0x07, 0xC6, 0x6F, 0xDC, 0xD9, 0x92, 
	0xBD, 0x65, 0x6F, 0xE8, 0xFE, 0xC1, 0xFD, 0xB4, 
	0xE4, 0x35, 0x42, 0xBF, 0x0E, 0xFB, 0x05, 0x31, 
	0x47, 0xDF, 0xA2, 0x0D, 0x7A, 0xE4, 0x8B, 0x98, 
	0xC7, 0xF8, 0x96, 0xAC, 0x55, 0x5C, 0xF8, 0xDC, 
	0x29, 0x6C, 0x63, 0x6C, 0xD4, 0x24, 0x18, 0x86, 
	0xFD, 0x80, 0x18, 0x05, 0xF4, 0x5B, 0xA2, 0xDC, 
	0x77, 0x99, 0xE0, 0x74, 0x31, 0x64, 0x27, 0x1F, 
	0xD3, 0x39, 0x20, 0xF5, 0x67, 0x91, 0xEA, 0x91, 
	0x95, 0x3D, 0x2F, 0x1E, 0xE0, 0x41, 0x1F, 0x38, 
	0xA7, 0xC0, 0x64, 0xA5, 0x07, 0x63, 0x68, 0x45, 
	0x03, 0x2D, 0x0C, 0x6B, 0x72, 0x49, 0x38, 0x7E, 
	0x5E, 0x59, 0x93, 0x0C, 0xF1, 0x6A, 0xAB, 0x47, 
	0x05, 0x09, 0xFF, 0x73, 0x5C, 0xE3, 0x11, 0x8C, 
	0xC9, 0x56, 0x66, 0x8D, 0x97, 0x0F, 0x05, 0x72, 
	0x5C, 0xAE, 0x70, 0x84, 0xC7, 0x4A, 0xC3, 0x61, 
	0xF9, 0x7A, 0x96, 0xED, 0xD4, 0x64, 0xA6, 0xD6, 
	0x62, 0xFF, 0xB7, 0xFF, 0xF5, 0xF8, 0x7A, 0x64, 
	0x72, 0x7F, 0xD3, 0x4D, 0x0E, 0x77, 0xEF, 0x18, 
	0xEB, 0xA5, 0xDE, 0x6C, 0x03, 0x8D, 0x60, 0x96, 
	0x5A, 0xAB, 0x68, 0xD2, 0xDF, 0x92, 0x38, 0x7E, 
	0x46, 0xC6, 0x05, 0xBF, 0xFF, 0xC3, 0x54, 0xC5, 
	0x9E, 0xB1, 0x86, 0x3F, 0xD7, 0xDB, 0x97, 0x2A, 
	0x6B, 0xE0, 0x6D, 0x50, 0xF4, 0x94, 0x84, 0x13, 
	0xBB, 0x83, 0x4F, 0x90, 0x77, 0xEE, 0x9B, 0xE6, 
	0xC1, 0x76, 0x18, 0xD9, 0x79, 0xB6, 0x14, 0x81, 
	0x2F, 0xC1, 0x6E, 0x60, 0x7D, 0x59, 0x25, 0xDF, 
	0x08, 0xC0, 0xF5, 0x0E, 0x09, 0x0F, 0x95, 0x68, 
	0x1A, 0x3A, 0x57, 0xF7, 0xD2, 0x0C, 0xB3, 0xFA, 
	0xB4, 0x72, 0x08, 0xFF, 0xB2, 0x7F, 0x5F, 0xD4, 
	0xAE, 0x30, 0x7C, 0xDF, 0x6F, 0xCA, 0x4C, 0x78, 
	0x73, 0xD7, 0xED, 0xE4, 0x7F, 0x60, 0x46, 0xEF, 
	0x99, 0xFF, 0xDB, 0x47, 0x7A, 0x07, 0xA3, 0x90, 
	0x85, 0x53, 0x01, 0x38, 0x8E, 0xC9, 0x9B, 0x4E, 
	0x6F, 0x5C, 0x09, 0x1C, 0x4A, 0xDD, 0xF0, 0xA0, 
	0xAF, 0x3C, 0x68, 0xFA, 0xFB, 0x31, 0xC3, 0x80, 
	0x04, 0x23, 0x2F, 0xAF, 0x43, 0x97, 0x4A, 0x86, 
	0x6B, 0x0A, 0x33, 0xA3, 0x77, 0xC5, 0x6B, 0x7E, 
	0xD5, 0xFE, 0x85, 0xCC, 0x61, 0x2C, 0xDC, 0x73, 
	0x0D, 0xBC, 0xC8, 0xD0, 0x43, 0xF4, 0xA8, 0x12, 
	0x57, 0xE2, 0x16, 0x28, 0x9A, 0x81, 0xA2, 0xD2, 
	0x85, 0x7E, 0x64, 0x34, 0x6C, 0xDC, 0x58, 0x54, 
	0x4D, 0x7E, 0x18, 0x92, 0x96, 0x47, 0xBD, 0xB1, 
	0x2C, 0xDA, 0x79, 0x86, 0x49, 0x38, 0x5C, 0x02, 
	0x52, 0xC0, 0xD4, 0x8F, 0x82, 0xB8, 0x84, 0x6F, 
	0x34, 0xCF, 0x96, 0x99, 0xFF, 0xC9, 0xB2, 0xA2, 
	0xF7, 0x9C, 0x68, 0xF0, 0xD2, 0x3A, 0x9C, 0x34, 
	0xBE, 0x1D, 0xD0, 0x7B, 0x2C, 0xC7, 0x58, 0xBD, 
	0x7A, 0x79, 0x7D, 0xBF, 0xFD, 0x38, 0xD4, 0x03, 
	0xF2, 0x44, 0xBA, 0xC1, 0x06, 0xCE, 0xE3, 0x36, 
	0xDC, 0x4D, 0xE3, 0x42, 0x20, 0xFD, 0xE8, 0xBF, 
	0x81, 0x8E, 0xE2, 0xB7, 0x3C, 0x10, 0x6F, 0xCF, 
	0x47, 0x82, 0x0C, 0x53, 0x60, 0x1A, 0x9A, 0x90, 
	0x74, 0x7B, 0xE4, 0xC4, 0x1F, 0xEE, 0x51, 0x44, 
	0x7F, 0xAD, 0xAC, 0xBB, 0x79, 0xCE, 0xB9, 0xFD, 
	0xF4, 0x40, 0x0B, 0xDC, 0xA0, 0xE5, 0x4A, 0x29, 
	0x84, 0xCA, 0x2B, 0xB3, 0xEC, 0xDF, 0x57, 0x33, 
	0x95, 0x88, 0x43, 0x80, 0x0A, 0x30, 0x6D, 0x71, 
	0xA5, 0x20, 0x2B, 0xCA, 0x40, 0x1B, 0x39, 0xCD, 
	0xB0, 0x44, 0xDD, 0x39, 0xDF, 0xE4, 0x63, 0xB9, 
	0x35, 0xB8, 0x19, 0xCE, 0x56, 0x23, 0x92, 0xFB, 
	0x1F, 0xA2, 0x3B, 0x06, 0x03, 0xFF, 0x4F, 0x02, 
	0x9B, 0x3D, 0x3A, 0x82, 0x68, 0xA2, 0x30, 0x95, 
	0x58, 0x5B, 0xF5, 0x46, 0x99, 0xE2, 0x3B, 0x97, 
	0x07, 0x18, 0xB3, 0x5B, 0xE2, 0x06, 0xE1, 0xDF, 
	0x30, 0x81, 0x9E, 0x57, 0x93, 0x75, 0xFB, 0x69, 
	0x74, 0x6B, 0xF8, 0x28, 0x77, 0x1C, 0xD7, 0xE2, 
	0xDC, 0xBC, 0xF7, 0x8F, 0xD3, 0x24, 0x10, 0x93, 
	0xC3, 0x05, 0xE1, 0xE9, 0xDF, 0x23, 0x6B, 0xE2, 
	0xDC, 0x54, 0x45, 0xD3, 0x4F, 0xFD, 0xB7, 0x3A, 
	0xF7, 0xEA, 0xD5, 0xBF, 0x40, 0x66, 0x94, 0x24, 
	0x90, 0x10, 0xF8, 0x12, 0x23, 0x9B, 0xAC, 0x87, 
	0x9F, 0xB0, 0xBF, 0x0E, 0x1F, 0x36, 0xD2, 0x2C, 
	0x34, 0x5C, 0xFF, 0x89, 0x13, 0xB9, 0x79, 0x36, 
	0xF3, 0x9C, 0x30, 0xFC, 0x86, 0x9F, 0xBB, 0x50, 
	0x11, 0x3D, 0xF8, 0x4F, 0x40, 0xC7, 0x4C, 0x97, 
	0x98, 0x0B, 0xBD, 0xD2, 0x5D, 0x24, 0xBD, 0x54, 
	0x3C, 0x68, 0x6B, 0x28, 0xB3, 0xED, 0xFF, 0x70, 
	0x26, 0x5B, 0x42, 0xE2, 0xFA, 0x6F, 0xC8, 0xC9, 
	0x1E, 0x01, 0x04, 0xFB, 0x17, 0x5D, 0xC9, 0x72, 
	0x41, 0x92, 0x17, 0xD2, 0x75, 0xA5, 0xCA, 0x63, 
	0xD9, 0xBB, 0x42, 0x8E, 0xF3, 0x53, 0x8C, 0xBE, 
	0x85, 0x26, 0xDC, 0x1A, 0x25, 0x5F, 0xA6, 0xAF, 
	0x22, 0x64, 0x6D, 0x90, 0x0B, 0x6F, 0x8A, 0xE3, 
	0xD6, 0x2E, 0x24, 0xD8, 0xA5, 0xF4, 0x1D, 0x26, 
	0x23, 0xC6, 0xDC, 0x3F, 0x99, 0x3F, 0xC8, 0x71, 
	0xDB, 0xB5, 0xA7, 0xDE, 0xDF, 0x52, 0x13, 0xB7, 
	0xE1, 0xAD, 0xDC, 0x15, 0x7A, 0xFE, 0xA0, 0x0C, 
	0x09, 0x54, 0x8B, 0x78, 0x47, 0x92, 0x58, 0x49, 
	0x9D, 0x52, 0x59, 0xE9, 0xBD, 0xB1, 0xE5, 0xE2, 
	0x90, 0x89, 0xA8, 0xD0, 0x5C, 0xDB, 0x1D, 0x8A, 
	0x85, 0x8E, 0x9D, 0x57, 0xBE, 0x24, 0xF0, 0x9B, 
	0x55, 0xD7, 0xA4, 0x75, 0x12, 0xD9, 0x27, 0x74, 
	0x0F, 0xC1, 0x28, 0x34, 0xFF, 0x63, 0x57, 0xFF, 
	0xFE, 0x44, 0x7E, 0xCB, 0x13, 0xD1, 0x5D, 0x27, 
	0x6C, 0x83, 0xE2, 0x4B, 0x10, 0x01, 0x21, 0xC7, 
	0x7E, 0x36, 0xEE, 0x53, 0xC5, 0x22, 0x05, 0x1B, 
	0x99, 0xD1, 0x95, 0x6C, 0x68, 0xDE, 0x95, 0xCA, 
	0x35, 0xFD, 0x51, 0x36, 0x0A, 0x35, 0x87, 0x5E, 
	0xF9, 0xF5, 0x22, 0x0E, 0x75, 0x65, 0x3D, 0x4B, 
	0x10, 0xDE, 0xDD, 0x45, 0x91, 0x29, 0x80, 0xA4, 
	0xEE, 0x83, 0x75, 0x0C, 0x4B, 0x3D, 0x00, 0x60, 
	0x25, 0xEB, 0xA3, 0xC8, 0x3B, 0x05, 0xB4, 0x14, 
	0xA2, 0x72, 0x97, 0x66, 0x0B, 0xA4, 0xA6, 0x9F, 
	0xFC, 0xD3, 0x5C, 0x18, 0x51, 0xBA, 0x24, 0x3B, 
	0xA2, 0x3C, 0x2C, 0x34, 0x24, 0x20, 0x25, 0xB1, 
	0x99, 0x57, 0x92, 0xEE, 0x23, 0xCC, 0x52, 0x21, 
	0x89, 0x8C, 0xA6, 0xE1, 0xEA, 0x9C, 0x0E, 0x5D, 
	0x05, 0xFC, 0x47, 0xCB, 0xC3, 0x50, 0xB6, 0x4C, 
	0xC3, 0x52, 0x21, 0xE3, 0x22, 0xD2, 0xA3, 0x7A, 

	/* Database Page 25 */

	0xFF, 0x8E, 0xFB, 0x3C, 0x6D, 0x37, 0xA2, 0x89, 
	0x22, 0x5C, 0xBB, 0x57, 0x68, 0xEF, 0x17, 0xD0, 
	0x45, 0xC6, 0x2F, 0xE8, 0x58, 0xEB, 0x1E, 0x07, 
	0x54, 0x65, 0xF5, 0x2D, 0x95, 0xCD, 0xD4, 0x1E, 
	0x49, 0x74, 0x9B, 0x50, 0xC4, 0xE5, 0xFB, 0x98, 
	0x7D, 0xA9, 0x29, 0x37, 0xAF, 0x38, 0xB3, 0xA2, 
	0x04, 0x22, 0xF3, 0x23, 0xDE, 0xC0, 0xE1, 0x6B, 
	0x74, 0x11, 0x1A, 0x61, 0x36, 0x4B, 0xA8, 0x7A, 
	0x3E, 0xEB, 0x4F, 0x89, 0x9F, 0x2D, 0x21, 0x08, 
	0xC2, 0x5D, 0xC7, 0x66, 0x02, 0xAD, 0x5A, 0x18, 
	0xE2, 0xAC, 0x5E, 0x19, 0xA9, 0xF8, 0x91, 0xF3, 
	0x71, 0xE4, 0x7E, 0x8E, 0x8E, 0xED, 0xDF, 0xDC, 
	0x2D, 0x62, 0xF6, 0x49, 0xD9, 0x9A, 0x10, 0xA2, 
	0xA5, 0xD7, 0x68, 0x54, 0x99, 0xC1, 0x3D, 0x32, 
	0x6C, 0xA6, 0xF4, 0x16, 0x9D, 0x50, 0xE8, 0xC8, 
	0x0F, 0xB4, 0x1F, 0x9F, 0x7D, 0x25, 0x67, 0xC6, 
	0x0C, 0xFF, 0xD8, 0x96, 0xAB, 0xCD, 0xF8, 0xF8, 
	0xBC, 0x13, 0x9A, 0x47, 0xC8, 0x57, 0x41, 0x03, 
	0x23, 0xCC, 0x97, 0x1B, 0x43, 0x1A, 0xBE, 0xC2, 
	0xD6, 0x69, 0x5E, 0xBB, 0x1A, 0x9D, 0x82, 0x92, 
	0xF5, 0x6A, 0x37, 0x80, 0x14, 0x50, 0x7E, 0x44, 
	0x15, 0xBE, 0x2A, 0x51, 0x8B, 0xBB, 0xD0, 0x67, 
	0x71, 0xCD, 0x57, 0xFF, 0xEF, 0xB8, 0x30, 0x07, 
	0xD4, 0x9B, 0x42, 0xF5, 0xDE, 0xCE, 0x09, 0xBC, 
	0xC4, 0x13, 0x6B, 0x3F, 0x92, 0x34, 0x1D, 0xC2, 
	0xAD, 0x34, 0xA6, 0xAC, 0x37, 0x79, 0x1A, 0xA6, 
	0xC9, 0xD4, 0xA8, 0xA5, 0x62, 0xB6, 0x87, 0x55, 
	0x9F, 0x16, 0x85, 0xAF, 0xF2, 0xD4, 0xCD, 0x89, 
	0xE4, 0x08, 0x0D, 0xE3, 0x0E, 0xDC, 0xB3, 0xD7, 
	0xB7, 0xEE, 0xC1, 0x98, 0x2A, 0xE6, 0xE9, 0xF0, 
	0x9B, 0xBD, 0x1C, 0xF3, 0xB0, 0x8F, 0x64, 0xAC, 
	0xD1, 0xE5, 0x26, 0xDC, 0x7E, 0xD8, 0xB2, 0xFA, 
	0xA6, 0x89, 0xFF, 0xCA, 0xE2, 0x31, 0xF0, 0xCB, 
	0x6C, 0x71, 0xE8, 0xE6, 0x6B, 0xC3, 0x60, 0xC3, 
	0x71, 0xE4, 0x1E, 0xE6, 0xC8, 0x1D, 0x66, 0x0D, 
	0x62, 0x75, 0xCF, 0x88, 0x05, 0x4B, 0xE6, 0x6D, 
	0x86, 0x34, 0x6D, 0xF8, 0x9B, 0xFB, 0x6F, 0x65, 
	0x2D, 0x94, 0x44, 0x70, 0x0A, 0x01, 0x31, 0x47, 
	0x4A, 0xD0, 0x0E, 0x7B, 0xDE, 0x14, 0xB1, 0x23, 
	0x0C, 0x87, 0xE6, 0xC8, 0x34, 0x7D, 0x98, 0xBC, 
	0xBF, 0xAD, 0x17, 0x53, 0x1B, 0xB4, 0xE4, 0x9F, 
	0xBF, 0x24, 0xC9, 0x54, 0x67, 0x49, 0x08, 0x3C, 
	0xEB, 0x47, 0x65, 0x7B, 0xB9, 0x27, 0x3D, 0x35, 
	0x7C, 0x8C, 0xDF, 0xCC, 0xD6, 0xD9, 0xAA, 0x6E, 
	0x80, 0xB7, 0x32, 0xD3, 0xA3, 0xF7, 0x70, 0x58, 
	0xF9, 0x05, 0x02, 0xF5, 0x7A, 0x07, 0x02, 0xC8, 
	0xC4, 0x1A, 0x59, 0x3A, 0x13, 0x3C, 0x75, 0xB2, 
	0x78, 0x82, 0x42, 0xAE, 0x90, 0x05, 0xDB, 0xCD, 
	0x48, 0x60, 0x6E, 0xFF, 0xB9, 0x66, 0x86, 0x07, 
	0x47, 0xB7, 0xD1, 0xDE, 0x40, 0x1B, 0x35, 0x7B, 
	0x1F, 0xD7, 0x13, 0x10, 0xA1, 0x75, 0xC2, 0xB4, 
	0x6D, 0x84, 0x81, 0x66, 0x8D, 0x12, 0x9F, 0xB9, 
	0x25, 0x63, 0x50, 0xDC, 0xB3, 0x9C, 0xCC, 0x8D, 
	0x09, 0x99, 0xA5, 0x61, 0x54, 0x72, 0x59, 0x56, 
	0xBC, 0x95, 0x8C, 0x7E, 0x0C, 0xB6, 0x11, 0x61, 
	0xE1, 0x00, 0x8B, 0x37, 0xBE, 0x22, 0x54, 0x9F, 
	0x5F, 0x36, 0xDB, 0x79, 0x17, 0x15, 0x28, 0xDC, 
	0xC2, 0xD6, 0x42, 0xDC, 0x00, 0x80, 0x14, 0x6F, 
	0x53, 0xD1, 0xAB, 0x16, 0x5A, 0xF0, 0x68, 0x24, 
	0xB2, 0x92, 0x79, 0x18, 0x65, 0xD8, 0x0A, 0x13, 
	0xAB, 0x7D, 0x56, 0xDC, 0x20, 0xA3, 0x08, 0x92, 
	0x70, 0xD9, 0x86, 0x80, 0x89, 0x11, 0xEF, 0xBC, 
	0x77, 0x46, 0xD3, 0xC6, 0x8D, 0x35, 0x13, 0xAD, 
	0x99, 0x7F, 0x78, 0xD5, 0xD4, 0xE9, 0x7A, 0x97, 
	0x16, 0xFF, 0xD1, 0xAA, 0xFF, 0xE5, 0x83, 0xA5, 
	0xB7, 0xB5, 0x3C, 0x99, 0x9C, 0x7B, 0xD9, 0xD7, 
	0x2C, 0x7A, 0x0C, 0xE3, 0x72, 0xE0, 0x6D, 0x4A, 
	0x6F, 0x40, 0xC0, 0xEB, 0xBF, 0xE0, 0x50, 0xEA, 
	0xC5, 0x5B, 0x15, 0x9B, 0x0E, 0x56, 0xA9, 0x53, 
	0x39, 0x33, 0xE3, 0xA4, 0xF5, 0x7A, 0x82, 0xA0, 
	0x0E, 0x47, 0x1B, 0xF0, 0x8B, 0x2E, 0xA1, 0x0F, 
	0x21, 0x4C, 0xD3, 0x59, 0x98, 0xCD, 0x7B, 0x68, 
	0x2F, 0xEC, 0xE6, 0x45, 0x13, 0x72, 0xBE, 0x42, 
	0xA7, 0x7D, 0x83, 0xF7, 0x29, 0xF1, 0x0C, 0xDA, 
	0x71, 0xB5, 0x54, 0xBB, 0x51, 0xA9, 0xB7, 0xEA, 
	0x47, 0xD5, 0x0D, 0x65, 0x99, 0x58, 0xD3, 0x6C, 
	0xEC, 0x14, 0xF3, 0xCB, 0x15, 0x54, 0x97, 0x8D, 
	0x6B, 0x15, 0x24, 0x42, 0xB6, 0x04, 0x32, 0xAD, 
	0x56, 0x58, 0x61, 0x62, 0x9A, 0xF2, 0x30, 0x22, 
	0x0A, 0xB4, 0x3C, 0xEE, 0x16, 0xDD, 0x62, 0x83, 
	0x93, 0xE3, 0xFF, 0xD7, 0xCC, 0xFF, 0x0C, 0xD0, 
	0xF2, 0x87, 0x12, 0x68, 0x7C, 0xDE, 0x9E, 0xE3, 
	0xED, 0x32, 0x71, 0xCC, 0x19, 0x3B, 0x23, 0xB6, 
	0xAC, 0xDC, 0x9D, 0x11, 0x1E, 0x81, 0x4B, 0xD8, 
	0x95, 0x79, 0xDE, 0xE6, 0xB0, 0x44, 0x68, 0x60, 
	0x9A, 0x46, 0x87, 0x3D, 0x8C, 0x3A, 0xDA, 0xC2, 
	0xD2, 0xEF, 0xC7, 0xA1, 0x34, 0xB5, 0xB6, 0x49, 
	0x83, 0xDF, 0x02, 0x80, 0x6B, 0x6D, 0x52, 0x4D, 
	0x50, 0xB4, 0x80, 0x0A, 0x30, 0xC6, 0x0E, 0xA2, 
	0x86, 0x19, 0xB1, 0x68, 0xD9, 0xA7, 0x53, 0x94, 
	0x35, 0xB5, 0x98, 0x97, 0x69, 0xE3, 0x91, 0xBA, 
	0x0A, 0x1A, 0x5D, 0x51, 0x0F, 0x3A, 0xD9, 0xB3, 
	0xD6, 0x2B, 0x5D, 0x06, 0x45, 0x40, 0xBB, 0x63, 
	0xE4, 0x40, 0x34, 0xDA, 0xDB, 0x7B, 0x55, 0x30, 
	0x68, 0xE8, 0x48, 0x74, 0xF1, 0xFD, 0x2B, 0xC1, 
	0xD5, 0x06, 0x13, 0xA3, 0x64, 0xF2, 0xED, 0xBC, 
	0xE1, 0x3A, 0x4D, 0x31, 0xAA, 0xDA, 0xFF, 0x39, 
	0x4A, 0xA1, 0x71, 0x28, 0x21, 0xF3, 0x5A, 0x2C, 
	0xF9, 0x98, 0x7B, 0x5D, 0x0B, 0xAC, 0x2A, 0x1D, 
	0x0D, 0x76, 0x1A, 0xA8, 0x27, 0x67, 0xD9, 0x29, 
	0x34, 0x09, 0x5C, 0xFB, 0xE9, 0x56, 0x06, 0xC7, 
	0x42, 0x6F, 0x67, 0xF4, 0x47, 0x40, 0xFF, 0x5C, 
	0xCD, 0x9C, 0x3C, 0x20, 0x6F, 0x4D, 0x8F, 0x1B, 
	0xD4, 0x32, 0x60, 0x85, 0x1A, 0x7C, 0x8F, 0x49, 
	0x19, 0x36, 0x69, 0x79, 0xE4, 0x7E, 0xC7, 0x46, 
	0xAE, 0x65, 0x0A, 0xDB, 0xE4, 0xC5, 0x6F, 0x8E, 
	0xBF, 0x27, 0x8F, 0x7B, 0xCB, 0xCB, 0x06, 0x53, 
	0x8F, 0x23, 0xD2, 0xCD, 0x02, 0xC1, 0x82, 0x20, 
	0x11, 0xD7, 0x9F, 0x7A, 0x0A, 0x4B, 0x69, 0x3A, 
	0x41, 0x19, 0xE5, 0xA7, 0x36, 0xF5, 0x86, 0xDC, 
	0xA8, 0xFB, 0x6D, 0x76, 0x29, 0x06, 0x4C, 0xB1, 
	0xA7, 0xAD, 0x1A, 0x7B, 0x8F, 0x59, 0x12, 0x92, 
	0x67, 0xD9, 0xE2, 0x12, 0x2E, 0x25, 0xC8, 0xFF, 
	0x6C, 0xC8, 0x12, 0xDB, 0x79, 0xD8, 0x76, 0x7C, 
	0xA0, 0xEB, 0xE5, 0x53, 0x6B, 0x47, 0xBB, 0x5C, 
	0x0B, 0xEC, 0x9B, 0x7C, 0x4A, 0x7E, 0xC3, 0x27, 
	0x15, 0x8B, 0xB0, 0xFE, 0x23, 0xC1, 0x4C, 0xFE, 
	0x10, 0xB4, 0xAB, 0x09, 0x51, 0x04, 0xE2, 0xAF, 
	0x62, 0x0A, 0xE5, 0x3D, 0xB9, 0x41, 0x62, 0xA6, 
	0xB3, 0x77, 0xCF, 0xF6, 0x6F, 0xE2, 0x9C, 0x07, 
	0x86, 0x41, 0x78, 0xF8, 0xBC, 0xD1, 0xD4, 0x29, 
	0x3D, 0xB9, 0x1B, 0x86, 0xF9, 0x34, 0x8B, 0xE9, 
	0x59, 0x26, 0x8A, 0x7D, 0xA9, 0xC6, 0x9C, 0xEC, 
	0xFC, 0x8B, 0x0C, 0xDE, 0x4C, 0x22, 0xE3, 0x61, 
	0xF4, 0xA9, 0xA5, 0xF9, 0x0E, 0x28, 0xA6, 0x8F, 
	0x93, 0x52, 0xC7, 0x3B, 0xF7, 0xD4, 0xA7, 0xDD, 
	0xDB, 0x9D, 0xDB, 0x5C, 0xAD, 0x12, 0xAC, 0x4B, 
	0xD8, 0xA6, 0xE6, 0x4F, 0xAE, 0xCA, 0xE5, 0x5E, 
	0x1E, 0x5D, 0x04, 0xAC, 0x50, 0xDF, 0xBD, 0xF4, 
	0xFF, 0xAC, 0x8D, 0x9D, 0x7F, 0xF2, 0x85, 0xE5, 
	0x35, 0xF7, 0x95, 0xCA, 0xBB, 0xB1, 0xE9, 0x86, 
	0xD4, 0x3C, 0xFD, 0xA1, 0xD7, 0x4E, 0x6F, 0xA0, 
	0xB7, 0xAC, 0x89, 0x7C, 0x76, 0xEE, 0xC7, 0x13, 
	0x00, 0x5F, 0x25, 0xE1, 0x00, 0x12, 0xAD, 0xD0, 
	0x7B, 0x9C, 0x25, 0x3D, 0xA9, 0x4D, 0xB4, 0x13, 
	0x96, 0x25, 0x33, 0xC8, 0x3C, 0xE6, 0xB7, 0x50, 
	0x5A, 0xD6, 0x58, 0xC5, 0x85, 0x9B, 0x43, 0x4A, 
	0x26, 0xFA, 0x13, 0xFC, 0x8F, 0x69, 0x1F, 0xC5, 
	0x10, 0x6A, 0xD3, 0xA4, 0x05, 0xAC, 0xB0, 0x22, 
	0xDE, 0x0D, 0x2A, 0x14, 0x3E, 0x3D, 0xBA, 0xDD, 
	0x85, 0x87, 0x4C, 0x7F, 0x8B, 0x77, 0xBC, 0x5E, 
	0xA3, 0x3D, 0x6A, 0xDE, 0x7D, 0x3E, 0x56, 0x54, 
	0xFB, 0x54, 0xBB, 0xBB, 0x64, 0xA3, 0x0F, 0x14, 
	0x63, 0x45, 0x38, 0xCE, 0xFD, 0x9A, 0xBB, 0x6A, 
	0x37, 0xB9, 0xD8, 0xE0, 0x36, 0x07, 0xF3, 0x72, 
	0x48, 0xFF, 0x6E, 0x51, 0xA7, 0xCA, 0xEF, 0x87, 
	0xE4, 0xAA, 0x79, 0x8A, 0xCD, 0x83, 0x40, 0xE0, 
	0x2F, 0x7F, 0x50, 0x05, 0x69, 0x12, 0xCB, 0xDC, 
	0xC1, 0x5A, 0x18, 0x5D, 0x94, 0x7E, 0x00, 0x8C, 
	0x3A, 0xD7, 0x40, 0xF6, 0x3C, 0x3F, 0x8C, 0xB2, 
	0x57, 0x4F, 0x71, 0x3F, 0xCD, 0x7C, 0xB2, 0x46, 
	0x57, 0x22, 0x95, 0x40, 0x8B, 0x76, 0xEB, 0xEE, 
	0x90, 0x83, 0x8E, 0xE3, 0xD8, 0x88, 0xC8, 0x96, 
	0x37, 0x7E, 0xFB, 0xE1, 0x10, 0x03, 0x1E, 0x98, 
	0xFE, 0xAF, 0x04, 0x59, 0x8E, 0x22, 0x66, 0x36, 
	0xC6, 0xBD, 0x52, 0x5D, 0xD9, 0xE7, 0x6A, 0x70, 
	0x32, 0x5F, 0x7B, 0xBA, 0xE8, 0x0B, 0x9E, 0x88, 
	0xC8, 0x69, 0x5A, 0x7E, 0xAF, 0x34, 0x8B, 0x05, 
	0x95, 0x34, 0x7A, 0x42, 0x38, 0x4C, 0x31, 0x3D, 
	0x9F, 0x02, 0x82, 0x85, 0xEB, 0x0E, 0xDA, 0x25, 
	0xBF, 0x69, 0xF8, 0x4D, 0xDB, 0x1F, 0xA5, 0x0B, 
	0xF2, 0xF6, 0xFF, 0x1B, 0x2F, 0xCC, 0x12, 0xD1, 
	0x1F, 0x62, 0xEB, 0xC9, 0xC7, 0x33, 0x93, 0x16, 
	0xA5, 0x7D, 0xAD, 0x62, 0xB6, 0x35, 0xBD, 0x90, 
	0xDF, 0x72, 0x22, 0xA8, 0xF2, 0x96, 0x59, 0x21, 
	0x82, 0xE5, 0xEE, 0x51, 0x85, 0x0E, 0x5E, 0x1A, 
	0x33, 0x8A, 0x80, 0x51, 0x14, 0x2B, 0xB7, 0xF3, 
	0x17, 0xC7, 0x94, 0x53, 0x63, 0x94, 0xD2, 0x54, 
	0xEF, 0xAE, 0x4F, 0x92, 0xF7, 0xB4, 0x20, 0x25, 
	0xC1, 0xE9, 0x0A, 0xAA, 0x12, 0xA2, 0x93, 0x23, 
	0xD7, 0xD2, 0x60, 0xF3, 0x98, 0x16, 0x1D, 0xFE, 
	0xFC, 0x76, 0x34, 0xEE, 0x86, 0xE0, 0xFE, 0x49, 
	0x4C, 0x99, 0xE9, 0x9E, 0xC1, 0x9A, 0xEC, 0x9E, 
	0xFE, 0x8C, 0x3A, 0x88, 0x8E, 0xA3, 0x14, 0x87, 
	0x63, 0x6C, 0x9B, 0x8E, 0x12, 0xF0, 0xDA, 0xC0, 
	0x6F, 0x3E, 0x97, 0x33, 0x11, 0x0C, 0xD1, 0xA1, 
	0x7D, 0x8E, 0x84, 0x2B, 0x00, 0x05, 0x7C, 0xFE, 
	0x7A, 0x2A, 0x09, 0xFF, 0x6D, 0xCE, 0xB9, 0x39, 
	0x40, 0xB2, 0x59, 0xBA, 0x43, 0x89, 0xE0, 0xE5, 
	0xAD, 0xBA, 0xB9, 0x82, 0x03, 0xFB, 0xC6, 0x68, 
	0x21, 0x92, 0xD3, 0x59, 0xEE, 0x85, 0x60, 0x25, 
	0xF5, 0x7B, 0xA6, 0x3E, 0x67, 0x5F, 0x4C, 0x17, 
	0xD8, 0xA2, 0xBF, 0xA3, 0x26, 0xE8, 0x1F, 0xE9, 
	0x9F, 0xF5, 0x13, 0xAA, 0xB1, 0x26, 0xF8, 0xB1, 
	0xC7, 0x4E, 0xB9, 0x88, 0x7E, 0x6B, 0x2A, 0x2C, 
	0x90, 0xEB, 0xCB, 0x20, 0x46, 0x56, 0x30, 0x82, 
	0x1C, 0x08, 0xB6, 0x4D, 0xCA, 0x30, 0x51, 0x57, 
	0x45, 0x02, 0x4F, 0xBA, 0x2A, 0x5E, 0xCF, 0x8E, 
	0x8D, 0x4A, 0xC4, 0x69, 0x2A, 0x1C, 0x3B, 0x16, 
	0x4E, 0x4F, 0x2D, 0x28, 0x8E, 0x85, 0xFD, 0x43, 
	0xE1, 0x94, 0x2B, 0x8E, 0xB8, 0x3F, 0xDA, 0x53, 
	0x7C, 0xF3, 0x94, 0x53, 0x22, 0xEF, 0xEC, 0xEE, 
	0x2E, 0x56, 0x69, 0x6E, 0x58, 0xC3, 0xC7, 0xCF, 
	0xF4, 0xB6, 0x13, 0xF8, 0xFF, 0xE8, 0xD7, 0x00, 
	0xF7, 0xA7, 0x1A, 0x71, 0x3C, 0x53, 0x14, 0x28, 
	0xBA, 0xFB, 0x99, 0x9E, 0x80, 0xE4, 0x31, 0xB1, 
	0xB2, 0xC1, 0x8B, 0xDE, 0xD2, 0x11, 0x0D, 0xE4, 
	0xA4, 0xCB, 0xEF, 0x4E, 0x8B, 0x19, 0x34, 0xF1, 
	0x79, 0x1A, 0x61, 0x38, 0x2C, 0xB5, 0xE2, 0x00, 
	0x85, 0x77, 0x18, 0x13, 0xE7, 0x21, 0x60, 0xF9, 
	0x3B, 0x80, 0xB8, 0xC9, 0x54, 0x9F, 0xFF, 0x9C, 
	0xC4, 0xD3, 0xDC, 0x57, 0xE8, 0xCA, 0x83, 0xD5, 
	0x3C, 0x84, 0x4D, 0x87, 0x4E, 0x3D, 0x58, 0x95, 
	0x3B, 0x4F, 0xC0, 0xC9, 0xE1, 0xDC, 0x7C, 0x09, 
	0x24, 0x14, 0x64, 0x8C, 0x5B, 0x2A, 0x17, 0xF3, 
	0x50, 0x2B, 0xEF, 0xA3, 0x65, 0x5C, 0xF9, 0x2B, 
	0xCB, 0xB9, 0x7F, 0x59, 0x79, 0xCC, 0xE6, 0x93, 
	0x92, 0x9E, 0x63, 0x27, 0x1D, 0x2B, 0x3C, 0xAD, 
	0x4B, 0x0B, 0x7B, 0xBF, 0x7D, 0x62, 0x99, 0x86, 
	0xED, 0x11, 0xA9, 0xAB, 0xE3, 0xFF, 0x18, 0xB1, 
	0xE6, 0x0E, 0x63, 0x3A, 0x70, 0x53, 0xE6, 0x0E, 
	0x46, 0xD9, 0xE0, 0x93, 0x86, 0x02, 0xA0, 0xD1, 
	0x14, 0x5E, 0x1B, 0x5B, 0x93, 0x2C, 0x69, 0x8E, 
	0x55, 0x3F, 0xFC, 0x5F, 0xFB, 0x70, 0x51, 0x3D, 
	0xCC, 0xE3, 0x01, 0x4C, 0x7A, 0x61, 0xC1, 0xE5, 
	0xD1, 0x94, 0x38, 0x83, 0x29, 0xEC, 0x1F, 0xBC, 
	0xCC, 0xEF, 0xEF, 0x71, 0x40, 0x5F, 0x7A, 0x06, 
	0xA9, 0xD0, 0x3E, 0xB9, 0x88, 0x7E, 0xBF, 0x31, 
	0x35, 0x50, 0xB5, 0x72, 0xE5, 0x46, 0xB5, 0xF5, 
	0xDE, 0x7A, 0x44, 0x70, 0x6E, 0x0B, 0x9D, 0x74, 
	0xAA, 0x4B, 0xF1, 0x5F, 0x0A, 0x04, 0x8F, 0x50, 
	0x16, 0xBD, 0x4C, 0x19, 0x65, 0xCA, 0x86, 0x65, 
	0xCF, 0x9B, 0x53, 0x46, 0x6C, 0xC1, 0x37, 0xB5, 
	0xA5, 0xAB, 0x76, 0x77, 0x46, 0x9C, 0x18, 0xE3, 
	0x5D, 0xCF, 0xF5, 0x37, 0xCC, 0x31, 0xCD, 0xBA, 
	0x92, 0x5E, 0xB1, 0x18, 0x66, 0x4A, 0xFF, 0xF9, 
	0xF4, 0x8D, 0x1F, 0xE9, 0x63, 0x4B, 0xDE, 0xAF, 
	0x1E, 0x0C, 0xA2, 0x1F, 0x1C, 0xF7, 0x5A, 0x63, 
	0x1F, 0x64, 0x13, 0x35, 0x54, 0x1A, 0xFE, 0x1A, 
	0x48, 0xCF, 0xB1, 0x2C, 0x76, 0xE9, 0xEB, 0x65, 
	0x73, 0x2F, 0xA4, 0x2A, 0x29, 0xFB, 0xDA, 0x31, 
	0x0A, 0xE2, 0x3C, 0xD1, 0x3E, 0xC4, 0x9C, 0x40, 
	0x76, 0x2C, 0xE8, 0x28, 0x35, 0x90, 0xA5, 0xF8, 
	0x00, 0x1D, 0x48, 0xE8, 0x1B, 0x07, 0xD6, 0xCC, 
	0xE0, 0x80, 0x6C, 0x3A, 0xF9, 0x17, 0x7B, 0xC2, 
	0x01, 0x93, 0xBF, 0x47, 0x1F, 0x01, 0x57, 0x72, 
	0x2F, 0x32, 0x6E, 0x5F, 0x9D, 0x03, 0x0E, 0x4D, 
	0xA9, 0x09, 0x10, 0x85, 0xB5, 0xA9, 0x4F, 0xA8, 
	0x2A, 0x2A, 0x4F, 0x22, 0x10, 0x85, 0xA7, 0x0F, 
	0xDF, 0xE0, 0x06, 0xAD, 0x3C, 0x5D, 0xDA, 0xF9, 
	0xD6, 0xFB, 0xA8, 0xFB, 0x66, 0x24, 0x36, 0x4C, 
	0xBF, 0x0E, 0x93, 0xE8, 0x8B, 0x4C, 0x07, 0xFF, 
	0xD7, 0x6E, 0x40, 0xB6, 0x1A, 0xE9, 0x3D, 0x6F, 
	0xC8, 0x5D, 0x74, 0x31, 0xF4, 0x7D, 0xD2, 0x59, 
	0x46, 0xCA, 0x4B, 0x26, 0xF8, 0xF3, 0x86, 0x0D, 
	0x0D, 0x97, 0xD4, 0x8F, 0xCB, 0x11, 0xEB, 0x24, 
	0x17, 0xDC, 0xFC, 0x18, 0x14, 0x75, 0xC4, 0x65, 
	0x7C, 0xAF, 0x27, 0xFE, 0x6C, 0xE5, 0x79, 0x0E, 
	0x15, 0xB0, 0x3D, 0xA6, 0x6C, 0x57, 0xF1, 0xF0, 
	0x20, 0xDC, 0x1F, 0xDD, 0x1F, 0x39, 0x4F, 0x8C, 
	0x7C, 0xEE, 0x5D, 0x93, 0xE8, 0xFB, 0x35, 0x3F, 
	0x6A, 0x81, 0x5F, 0xE5, 0x35, 0xF1, 0xC7, 0x98, 
	0xF6, 0xF3, 0x09, 0x52, 0x29, 0xCE, 0x91, 0xBB, 
	0xE4, 0x9C, 0x48, 0x31, 0x35, 0x4A, 0x7A, 0x78, 
	0x40, 0x4F, 0xBA, 0x80, 0x72, 0x4E, 0x8A, 0x9B, 
	0xBE, 0x0C, 0xC7, 0x89, 0x52, 0x6C, 0xBB, 0x55, 
	0x6E, 0x21, 0x95, 0xAD, 0xD9, 0x2A, 0x53, 0x63, 
	0xE6, 0x00, 0xDD, 0x3C, 0xCD, 0x54, 0x46, 0xB3, 

	/* Database Page 26 */

	0xFF, 0x01, 0x0B, 0x2E, 0x93, 0x33, 0x2F, 0x94, 
	0x9D, 0x10, 0x8C, 0x4B, 0x82, 0x1B, 0x56, 0xE7, 
	0x33, 0x01, 0xA9, 0x50, 0xB2, 0xBA, 0xF4, 0x3E, 
	0xDE, 0x5C, 0xC0, 0x63, 0x68, 0xCF, 0xA3, 0xF1, 
	0x7B, 0x2C, 0xC1, 0xFD, 0x7B, 0xA7, 0x5C, 0xC6, 
	0xB2, 0x1C, 0x9D, 0xEB, 0xF1, 0x10, 0xC8, 0x52, 
	0xD3, 0xDB, 0x34, 0x44, 0x56, 0xA6, 0x43, 0x16, 
	0x45, 0xA9, 0x42, 0x26, 0x6B, 0xA8, 0xAD, 0xC9, 
	0x1D, 0xF9, 0x2B, 0x3F, 0x40, 0x12, 0x56, 0x92, 
	0x7E, 0x8F, 0xE0, 0x10, 0x09, 0x87, 0x6C, 0xA6, 
	0x12, 0xEA, 0xA9, 0x4B, 0x32, 0x15, 0xB4, 0x7C, 
	0x59, 0x03, 0x69, 0xD0, 0xC7, 0xA4, 0x2A, 0x84, 
	0xF2, 0x02, 0xEC, 0xA5, 0x26, 0xE0, 0x77, 0x6A, 
	0x5D, 0x66, 0xD0, 0x23, 0xAB, 0x1B, 0x1B, 0x10, 
	0x1D, 0x7A, 0x41, 0x72, 0x11, 0x99, 0x1E, 0xA9, 
	0x92, 0x37, 0x96, 0x57, 0xA1, 0x04, 0xF5, 0x29, 
	0xF7, 0xFF, 0xE5, 0x1D, 0x50, 0xAB, 0x04, 0x48, 
	0x0C, 0xB0, 0xE0, 0x12, 0x57, 0xD3, 0xF9, 0x10, 
	0x46, 0x27, 0x34, 0xF1, 0xE4, 0x14, 0xB7, 0x79, 
	0xEC, 0x6B, 0x18, 0x46, 0x2E, 0xAC, 0x12, 0xA9, 
	0xB2, 0x17, 0xDB, 0xF3, 0x9C, 0x0F, 0xE8, 0xAD, 
	0xAB, 0x62, 0xD9, 0xED, 0xA9, 0x8B, 0x57, 0xB3, 
	0x6C, 0x74, 0xA4, 0x70, 0x36, 0xFA, 0x19, 0x54, 
	0x13, 0x7C, 0x10, 0x86, 0xB6, 0x9E, 0x6F, 0x96, 
	0x60, 0x5D, 0x23, 0x88, 0xEC, 0x2F, 0x30, 0xEC, 
	0x00, 0x4D, 0x29, 0xAA, 0x0E, 0x1C, 0xE3, 0x78, 
	0x01, 0x5A, 0x9D, 0xA3, 0xAB, 0xB6, 0x36, 0xA7, 
	0x3C, 0x46, 0x7A, 0xFB, 0x16, 0xD6, 0x8A, 0xA0, 
	0xDA, 0x36, 0x4F, 0xC9, 0xE7, 0xB2, 0xAC, 0x68, 
	0xF9, 0x4E, 0x7C, 0x4A, 0x59, 0xC2, 0x65, 0x10, 
	0x12, 0x3C, 0x1F, 0x0E, 0x7D, 0x3F, 0x02, 0xC6, 
	0xA9, 0xB9, 0x71, 0x2C, 0xB9, 0x97, 0x3C, 0xE9, 
	0x7D, 0xD1, 0xFF, 0x56, 0x7F, 0x39, 0xA8, 0xA3, 
	0x0B, 0xFB, 0x41, 0xC1, 0x8E, 0x03, 0x13, 0xA1, 
	0xB7, 0xB9, 0x03, 0xCC, 0xE5, 0x72, 0xC1, 0x2F, 
	0x5E, 0xCD, 0xC0, 0x31, 0x8A, 0xB1, 0xD8, 0xE5, 
	0x68, 0x26, 0x6A, 0x38, 0xCA, 0x10, 0x0C, 0x5B, 
	0xA0, 0x32, 0x56, 0x1E, 0xCA, 0x94, 0x59, 0x7A, 
	0x06, 0xC7, 0x48, 0x8C, 0x9A, 0x4F, 0xBE, 0x7A, 
	0x1A, 0x1A, 0x66, 0x69, 0x14, 0x0A, 0x3F, 0x09, 
	0xCC, 0x76, 0xBA, 0x5E, 0x7C, 0xBB, 0xBA, 0x1B, 
	0x90, 0x15, 0xB7, 0x6C, 0x18, 0x44, 0x3D, 0x41, 
	0xE3, 0x3B, 0xAC, 0x7C, 0x68, 0x34, 0x6A, 0xF1, 
	0x64, 0x08, 0x45, 0x22, 0x8D, 0x2E, 0x03, 0x81, 
	0x86, 0x94, 0xC4, 0xD8, 0xDC, 0x64, 0x7F, 0x3C, 
	0xB8, 0x89, 0xE1, 0xFD, 0xB7, 0x65, 0x37, 0x4F, 
	0x14, 0x6B, 0x0D, 0x2A, 0xD9, 0x90, 0x7F, 0xB7, 
	0xF2, 0x05, 0x6B, 0x72, 0xE0, 0x09, 0x08, 0xB5, 
	0x34, 0xC8, 0x5A, 0xFF, 0xD7, 0xAC, 0x27, 0x46, 
	0xE2, 0xE8, 0xFE, 0x40, 0xE6, 0xCC, 0x1A, 0x5F, 
	0xE5, 0x4A, 0xB3, 0x5F, 0xA8, 0x23, 0x39, 0x47, 
	0xB3, 0xEB, 0xA6, 0x3C, 0xDB, 0x3E, 0xEE, 0xFA, 
	0x3E, 0x51, 0x81, 0xF9, 0x5F, 0x19, 0xF8, 0x55, 
	0xC6, 0x3E, 0xEE, 0x65, 0x8E, 0xCB, 0xBB, 0x22, 
	0x37, 0x44, 0xAF, 0xC6, 0x8D, 0xC0, 0x8C, 0x01, 
	0xE1, 0xA7, 0x1A, 0xA9, 0xC5, 0x77, 0xB1, 0x79, 
	0xA5, 0x9B, 0x11, 0xFB, 0x55, 0xB6, 0xF1, 0xA4, 
	0x14, 0x62, 0x75, 0x9A, 0x37, 0xBA, 0xFC, 0x0A, 
	0xF4, 0xDF, 0x57, 0xC6, 0xA6, 0x7A, 0x19, 0x22, 
	0x5E, 0x62, 0x4E, 0x95, 0xDF, 0x2A, 0x4E, 0xD0, 
	0xD2, 0x41, 0xB4, 0xEC, 0x37, 0xA1, 0xE9, 0x14, 
	0x73, 0x46, 0x58, 0xB7, 0x6F, 0x5F, 0x6D, 0x86, 
	0x02, 0xF5, 0xF3, 0x7F, 0xCF, 0x0D, 0xC8, 0x47, 
	0xE4, 0x6A, 0x7A, 0xC0, 0x72, 0x0F, 0x83, 0x64, 
	0x60, 0x14, 0x75, 0x7A, 0xFF, 0x1F, 0x41, 0xCC, 
	0xF3, 0x46, 0xB8, 0x2F, 0xF9, 0x34, 0xD1, 0xDF, 
	0x65, 0xA0, 0x7E, 0xED, 0xBD, 0xB4, 0xFD, 0x61, 
	0x1B, 0x07, 0x7C, 0x02, 0xBF, 0x5B, 0xB3, 0x1D, 
	0xAE, 0x92, 0xB0, 0x13, 0x07, 0xF4, 0xFB, 0x0C, 
	0x9C, 0x43, 0x94, 0x0D, 0x7F, 0xC7, 0x63, 0xA1, 
	0xF6, 0xEB, 0x69, 0x82, 0x98, 0x1C, 0x28, 0xA5, 
	0x37, 0xE3, 0xAA, 0xA6, 0xD0, 0x3A, 0xDE, 0xB2, 
	0x27, 0x26, 0xE3, 0x31, 0x3C, 0x54, 0x4A, 0x82, 
	0x79, 0x4E, 0xDA, 0x6E, 0x2F, 0x21, 0x76, 0x40, 
	0x7B, 0x69, 0xC1, 0x33, 0xCB, 0xE9, 0xCD, 0xF1, 
	0x33, 0xD3, 0x13, 0x7E, 0x92, 0xA3, 0xA1, 0x3C, 
	0x71, 0xCC, 0xD8, 0x8B, 0xBC, 0x2F, 0x1E, 0x13, 
	0x59, 0x98, 0xD5, 0xF4, 0xC4, 0x36, 0x64, 0x40, 
	0x3D, 0x01, 0x50, 0xBF, 0x17, 0x26, 0xAF, 0x1A, 
	0x8D, 0xEA, 0x21, 0xA6, 0x12, 0x0D, 0x38, 0xB9, 
	0x3B, 0xA7, 0x85, 0xFA, 0xB9, 0xFF, 0x5E, 0xCD, 
	0xA7, 0x81, 0xFA, 0xC2, 0x87, 0xBD, 0xD8, 0x5E, 
	0xB4, 0x28, 0xF5, 0x05, 0x72, 0xC3, 0x52, 0x5A, 
	0xD5, 0x5A, 0x87, 0x1F, 0xA8, 0x17, 0xE0, 0xB4, 
	0x3B, 0xDF, 0xED, 0x17, 0xEC, 0xA1, 0x03, 0x7B, 
	0x6E, 0xAA, 0x95, 0x70, 0x33, 0xA0, 0x16, 0x80, 
	0xDE, 0xB2, 0x35, 0xE4, 0x73, 0x80, 0x1A, 0x01, 
	0xA3, 0xC6, 0x4C, 0x63, 0xA4, 0xDC, 0x90, 0x1E, 
	0x69, 0xD0, 0x60, 0x10, 0xEF, 0x8C, 0x77, 0x5C, 
	0xC7, 0x30, 0x3B, 0x69, 0xF0, 0xCD, 0x47, 0xDA, 
	0xCA, 0x4A, 0x5D, 0xCA, 0x5C, 0x21, 0xCC, 0xDD, 
	0xD0, 0x6A, 0x36, 0xFF, 0x9D, 0xFD, 0xDC, 0x79, 
	0xC5, 0x01, 0xEC, 0x39, 0x49, 0xCE, 0xF5, 0xD3, 
	0x41, 0x56, 0xF9, 0xB0, 0x34, 0xA1, 0x2E, 0x04, 
	0x96, 0xF1, 0xCD, 0x92, 0x29, 0x67, 0x43, 0x93, 
	0x9D, 0xA2, 0xCE, 0x5B, 0x89, 0xB7, 0x99, 0xC7, 
	0x49, 0x3B, 0x85, 0x27, 0x82, 0x9E, 0xFF, 0x22, 
	0xD4, 0x36, 0x62, 0x1B, 0xBE, 0x7A, 0xAC, 0xDF, 
	0x89, 0x1D, 0x6A, 0x0A, 0xCD, 0xD3, 0xF1, 0xE3, 
	0x88, 0x72, 0x1F, 0xAC, 0x56, 0xA6, 0xDF, 0xA9, 
	0x92, 0x0E, 0x54, 0x8C, 0x90, 0xC7, 0x93, 0x55, 
	0x31, 0xDE, 0x08, 0x1D, 0xC2, 0x15, 0xF9, 0x99, 
	0x65, 0x1E, 0x7B, 0x1D, 0x2F, 0x90, 0xDE, 0x69, 
	0x3E, 0xBA, 0xBE, 0xC7, 0xE6, 0x8D, 0x6E, 0x8D, 
	0x27, 0xE6, 0xC3, 0x44, 0xF2, 0xC5, 0x3E, 0xB1, 
	0x95, 0xE0, 0x5C, 0x70, 0xE3, 0x29, 0x9D, 0x48, 
	0x0C, 0xE1, 0xE2, 0xAF, 0x37, 0xB9, 0x02, 0x55, 
	0xCA, 0xA3, 0x72, 0x15, 0xFF, 0x6C, 0x54, 0x26, 
	0x3B, 0xC7, 0xFA, 0x55, 0xE8, 0x26, 0x75, 0x04, 
	0x6E, 0xF0, 0xF3, 0xA5, 0xDF, 0x04, 0xA9, 0x2E, 
	0xF7, 0xBA, 0xEF, 0x22, 0xAA, 0x3F, 0x1B, 0x75, 
	0x87, 0xD0, 0xD7, 0xEA, 0xC6, 0xD7, 0xEF, 0x9B, 
	0xC4, 0x5B, 0x20, 0x73, 0x65, 0x42, 0xA3, 0xFF, 
	0x2A, 0x2C, 0x83, 0x6B, 0x1D, 0x62, 0x01, 0x1C, 
	0x68, 0x52, 0x1D, 0x73, 0x0A, 0x7C, 0xC0, 0xC9, 
	0x52, 0xA7, 0x58, 0x64, 0x22, 0xD8, 0x7F, 0xC5, 
	0x95, 0xEA, 0x6C, 0x09, 0xA4, 0xF7, 0x28, 0x81, 
	0x16, 0xCB, 0xFC, 0x01, 0x99, 0xD9, 0x14, 0xF9, 
	0x23, 0xB1, 0x17, 0x08, 0x0D, 0x79, 0xD2, 0x3B, 
	0xC7, 0xD8, 0x81, 0x75, 0x5E, 0x8D, 0x3B, 0x25, 
	0x85, 0xEB, 0x93, 0xC4, 0xAB, 0x35, 0xF6, 0x66, 
	0x69, 0x27, 0xC0, 0x87, 0x66, 0x16, 0x81, 0xCD, 
	0x07, 0x02, 0x8F, 0x77, 0xE7, 0xE3, 0xE6, 0xBD, 
	0xC1, 0xFC, 0x80, 0xF0, 0xBF, 0xD9, 0x30, 0x88, 
	0x61, 0xCA, 0xEE, 0x40, 0x32, 0x11, 0x5F, 0xBB, 
	0xE3, 0x55, 0x67, 0x15, 0x13, 0xF6, 0xB9, 0x85, 
	0x88, 0x08, 0x7B, 0x75, 0xF6, 0x93, 0x64, 0x01, 
	0x38, 0xBE, 0x1E, 0xD1, 0xC9, 0x34, 0x9E, 0x2E, 
	0xC0, 0xB3, 0xB7, 0xAC, 0xF6, 0xAA, 0xCA, 0xC0, 
	0xFF, 0x67, 0xD3, 0x02, 0x91, 0x37, 0xCA, 0x93, 
	0x7D, 0x02, 0xF2, 0xB5, 0x20, 0x7C, 0x9B, 0x48, 
	0xE7, 0x2B, 0x37, 0x48, 0xB9, 0xE5, 0x6A, 0x49, 
	0x5F, 0xE7, 0x0B, 0x3B, 0xC3, 0x4C, 0x54, 0xAD, 
	0x79, 0xFA, 0xBF, 0x71, 0x82, 0x37, 0x28, 0x8C, 
	0xDD, 0xB2, 0x0B, 0x5E, 0xBE, 0x86, 0xF6, 0xEB, 
	0x93, 0x7E, 0xEE, 0x21, 0x58, 0x31, 0x5B, 0xAD, 
	0x92, 0x27, 0x23, 0x9F, 0x52, 0xD9, 0x49, 0x69, 
	0x36, 0x8F, 0xB4, 0x34, 0x20, 0xF6, 0x0E, 0xD0, 
	0xFA, 0x65, 0xEE, 0x7A, 0xA9, 0x58, 0xB8, 0xDB, 
	0x3C, 0xBE, 0x4E, 0xFF, 0x8F, 0x74, 0x63, 0x78, 
	0x30, 0xB3, 0xC2, 0xBA, 0x1C, 0x2B, 0xD6, 0x69, 
	0x77, 0x00, 0x84, 0x4E, 0x76, 0x7F, 0x98, 0xAD, 
	0xB1, 0x08, 0x91, 0x34, 0x87, 0xE9, 0xEA, 0x86, 
	0xE0, 0x4C, 0x96, 0x56, 0x7E, 0xDA, 0xBF, 0x21, 
	0x53, 0xF6, 0xD0, 0xBF, 0x5F, 0x40, 0x64, 0xCF, 
	0x14, 0xFF, 0x76, 0x5B, 0x51, 0xA5, 0xFA, 0xF9, 
	0x82, 0x52, 0x8E, 0x52, 0x3E, 0x05, 0xE6, 0x83, 
	0x4E, 0x65, 0xE9, 0x78, 0x3C, 0x57, 0x70, 0xB5, 
	0x54, 0xEC, 0x55, 0xBC, 0xCE, 0xB9, 0x1C, 0xF6, 
	0xCD, 0xF1, 0x33, 0x5A, 0xAC, 0xCA, 0x3C, 0x78, 
	0x3B, 0x83, 0x64, 0x84, 0x6E, 0x2E, 0x86, 0x25, 
	0xF5, 0x8E, 0xAE, 0x3B, 0x55, 0xD6, 0x66, 0x4D, 
	0x5A, 0x99, 0x70, 0x50, 0xA2, 0x35, 0xB3, 0xDA, 
	0x9A, 0x58, 0x3B, 0xD6, 0x47, 0xA2, 0x1B, 0x74, 
	0x9D, 0x4E, 0xDB, 0x76, 0xC0, 0xB6, 0xF5, 0x29, 
	0xBB, 0x25, 0xA4, 0xA6, 0x91, 0x83, 0x39, 0x36, 
	0x4E, 0x78, 0x0E, 0x13, 0x33, 0x26, 0xFC, 0xCE, 
	0x65, 0x62, 0x2E, 0xB4, 0xEF, 0x72, 0x59, 0x1D, 
	0x3F, 0x5E, 0x0E, 0x21, 0x75, 0x56, 0x6D, 0x7E, 
	0x5E, 0x07, 0x0B, 0x80, 0xAD, 0x9A, 0x72, 0x4D, 
	0x7C, 0x83, 0x63, 0x1F, 0x8F, 0x06, 0x28, 0x40, 
	0x59, 0xF2, 0xFF, 0x7E, 0xDE, 0x2B, 0x1E, 0x19, 
	0x44, 0xE3, 0x95, 0x96, 0x65, 0x4F, 0x7A, 0x59, 
	0x3B, 0x84, 0x2C, 0xA7, 0xD4, 0xCB, 0xF2, 0x9A, 
	0x62, 0x05, 0x9B, 0xF5, 0x0B, 0x5B, 0xCA, 0x6D, 
	0x71, 0x95, 0xCA, 0xDF, 0x3E, 0xAB, 0x10, 0x5A, 
	0x95, 0xB0, 0x53, 0xC2, 0x4F, 0x90, 0x20, 0x2D, 
	0x4F, 0x2B, 0xEC, 0xB9, 0xF0, 0xA1, 0x48, 0xA3, 
	0x82, 0x18, 0x10, 0xF6, 0xF5, 0xB0, 0x56, 0x11, 
	0x27, 0x85, 0x4E, 0x01, 0x81, 0x35, 0x98, 0x41, 
	0x20, 0x69, 0x84, 0xB4, 0x93, 0x2B, 0xC4, 0x39, 
	0xB1, 0xE8, 0x11, 0xEC, 0x7E, 0x54, 0x82, 0x74, 
	0x08, 0xD3, 0x24, 0xAA, 0xC5, 0x8B, 0xD6, 0xD3, 
	0x70, 0x20, 0xDB, 0x4E, 0x2A, 0x85, 0x60, 0xD7, 
	0x03, 0xE0, 0xBE, 0x8B, 0x8D, 0xFF, 0x5B, 0x69, 
	0x4C, 0x1C, 0x57, 0xC2, 0xC0, 0x06, 0x58, 0x3B, 
	0xB7, 0x77, 0xCF, 0x9E, 0x57, 0xC5, 0xD7, 0x31, 
	0x59, 0xE9, 0x58, 0xFF, 0xDE, 0xE0, 0xE3, 0xBA, 
	0xED, 0xC9, 0x82, 0x31, 0xD6, 0x6A, 0x93, 0x2C, 
	0x56, 0x27, 0x07, 0xF9, 0x3B, 0x83, 0xBC, 0xFE, 
	0x41, 0x9E, 0xFB, 0xEC, 0x9F, 0xF1, 0x1D, 0xE5, 
	0x4F, 0x35, 0x18, 0x02, 0xD5, 0x98, 0xEB, 0x1A, 
	0x31, 0x73, 0xAE, 0xA7, 0x7C, 0x6B, 0xF6, 0xB5, 
	0xD6, 0x14, 0xCC, 0x1B, 0x3B, 0xE0, 0x2F, 0x0D, 
	0xAD, 0x33, 0x0C, 0x31, 0xD2, 0xBF, 0xA4, 0xB9, 
	0xE7, 0xE3, 0xFE, 0x1F, 0x1D, 0x42, 0x72, 0x72, 
	0x57, 0x83, 0x3E, 0x00, 0x6B, 0xB7, 0x56, 0x9D, 
	0x9F, 0x12, 0x86, 0x8F, 0xF9, 0xF3, 0x27, 0x74, 
	0xB1, 0xE9, 0xD7, 0xC0, 0x1B, 0xE4, 0x7B, 0xAF, 
	0x25, 0xD8, 0xE6, 0x7A, 0xD8, 0x2B, 0x6E, 0x20, 
	0x79, 0x90, 0x1A, 0x49, 0x53, 0xEE, 0x2C, 0xCA, 
	0x0F, 0x6C, 0xC1, 0xDF, 0xE8, 0x4A, 0xFC, 0x10, 
	0x9E, 0x41, 0x60, 0xD0, 0x36, 0x9D, 0x58, 0xFF, 
	0x32, 0xBE, 0xEC, 0x56, 0xFF, 0xFE, 0xD1, 0x37, 
	0x6A, 0xDC, 0xB4, 0x89, 0xF9, 0x89, 0x3D, 0xDE, 
	0x94, 0x26, 0x3D, 0x67, 0x02, 0x5A, 0x63, 0x0B, 
	0xBF, 0x1C, 0x1B, 0x5B, 0x45, 0x28, 0x42, 0xEA, 
	0x1B, 0xF2, 0xC8, 0x4F, 0x60, 0x82, 0xD0, 0xC5, 
	0x35, 0xDF, 0x89, 0xD7, 0x15, 0x3B, 0x76, 0xE4, 
	0x86, 0xA9, 0x8C, 0x19, 0xEC, 0x66, 0x14, 0x3A, 
	0xF2, 0x3F, 0x9A, 0xD5, 0x77, 0x5D, 0x79, 0x52, 
	0xBB, 0xC7, 0x27, 0x5A, 0xB1, 0xF2, 0x7B, 0x31, 
	0x2C, 0x65, 0x52, 0x65, 0xD8, 0xC8, 0x93, 0xBB, 
	0xB9, 0x48, 0x4F, 0xB3, 0xA3, 0xA8, 0x62, 0x64, 
	0xB3, 0x74, 0x4C, 0x0A, 0x3F, 0xD3, 0x73, 0xBC, 
	0xB3, 0x8B, 0x2B, 0xAE, 0x7F, 0x03, 0x53, 0xD2, 
	0xF1, 0x40, 0xC0, 0x40, 0x98, 0xA7, 0xD3, 0x88, 
	0x5B, 0x44, 0x64, 0xB0, 0xC1, 0xA9, 0x0D, 0x83, 
	0x5D, 0xCE, 0x27, 0xA1, 0xA3, 0x16, 0x3E, 0xDB, 
	0x15, 0x6A, 0x0C, 0x46, 0xE7, 0xFF, 0xAB, 0xDB, 
	0x89, 0xCE, 0x2D, 0x75, 0x75, 0xCB, 0xBE, 0x7F, 
	0x92, 0xC9, 0x85, 0x58, 0x57, 0x93, 0xAD, 0xD8, 
	0x73, 0xAA, 0xFC, 0x88, 0xFD, 0x8A, 0x1C, 0xA2, 
	0xFD, 0xD6, 0x0C, 0x25, 0x62, 0xC2, 0xEF, 0xAF, 
	0x78, 0xE9, 0x48, 0x12, 0x9C, 0x3B, 0x4B, 0xEA, 
	0x6D, 0xA7, 0xF9, 0xE0, 0x37, 0xAE, 0xD7, 0xEF, 
	0xD0, 0xBD, 0xB3, 0xDD, 0x1A, 0x82, 0x10, 0xA9, 
	0x03, 0x2B, 0x17, 0x83, 0x99, 0xDE, 0x51, 0x61, 
	0x49, 0xAA, 0xC6, 0xAC, 0x96, 0x95, 0x40, 0x72, 
	0xCD, 0xE3, 0x10, 0x1C, 0xA6, 0x88, 0xD9, 0x4D, 
	0x98, 0x76, 0x15, 0xAA, 0x63, 0x6C, 0x90, 0x8B, 
	0x81, 0xE1, 0x93, 0x4A, 0xBB, 0x89, 0xBD, 0xCB, 
	0x4E, 0xF0, 0xE8, 0xA0, 0xFE, 0xB0, 0x46, 0x01, 
	0x85, 0x92, 0xB7, 0x00, 0x9C, 0x68, 0x14, 0xE6, 
	0xE3, 0x3F, 0x23, 0x6A, 0xDB, 0x56, 0xFC, 0xB6, 
	0xA2, 0x36, 0xB1, 0x25, 0x87, 0xE5, 0xFF, 0xC6, 
	0x01, 0xB5, 0xDA, 0xE4, 0xA6, 0xAC, 0x1E, 0x29, 
	0xEE, 0x1D, 0xA7, 0xCA, 0xA3, 0x25, 0x84, 0x64, 
	0x8A, 0x50, 0x6A, 0x8D, 0x6D, 0x2B, 0x69, 0x3B, 
	0x8A, 0xFF, 0x7E, 0x69, 0x7A, 0x49, 0x08, 0xB4, 
	0xCA, 0x28, 0x6F, 0x5D, 0x1F, 0xD9, 0xA1, 0xE4, 
	0xB5, 0x18, 0xB3, 0x88, 0xA5, 0x52, 0xB7, 0x84, 
	0x39, 0xFF, 0xFD, 0x34, 0x0D, 0xE0, 0x62, 0x89, 
	0xF2, 0xCB, 0xAA, 0xC9, 0x1B, 0x41, 0x88, 0x3A, 
	0xF7, 0x91, 0xD1, 0x34, 0xD1, 0xD7, 0x76, 0xA7, 
	0x38, 0x61, 0x22, 0x8D, 0x7A, 0x02, 0x29, 0xE4, 
	0xE0, 0x09, 0xFE, 0x22, 0x92, 0x65, 0x71, 0x9A, 
	0xFA, 0xFB, 0x9D, 0x6E, 0x35, 0x30, 0x5F, 0x98, 
	0x05, 0x4A, 0xF8, 0x2C, 0xF9, 0x22, 0xA7, 0x84, 
	0x35, 0x06, 0x75, 0x3A, 0x59, 0x25, 0x1C, 0x05, 
	0x59, 0x41, 0x8F, 0x54, 0xBD, 0x61, 0xB0, 0xBD, 
	0x6C, 0xEB, 0x46, 0xDB, 0xB7, 0xC4, 0x52, 0xFF, 
	0xAF, 0x81, 0xF8, 0xB1, 0xA4, 0x02, 0x26, 0xBE, 
	0x92, 0x32, 0x47, 0x45, 0xD5, 0x59, 0xFD, 0x52, 
	0xDF, 0x92, 0xCC, 0x60, 0x22, 0x46, 0x80, 0x0E, 
	0x1C, 0x07, 0x29, 0xA0, 0x00, 0x19, 0x1C, 0x40, 
	0xBF, 0x12, 0x4A, 0xD8, 0x57, 0x2F, 0x3B, 0x55, 
	0xE6, 0x27, 0xC2, 0x8A, 0x06, 0x7F, 0x7F, 0x7E, 
	0x57, 0xD2, 0xEF, 0x44, 0x7F, 0xDC, 0x6B, 0x59, 
	0x52, 0xE8, 0x9C, 0xBA, 0x2B, 0xB4, 0x3C, 0xBC, 
	0x99, 0xF9, 0x46, 0x15, 0xA4, 0xDE, 0x6E, 0x94, 
	0xBE, 0x8C, 0x54, 0x61, 0x5E, 0x08, 0x6F, 0x7A, 
	0xD4, 0xCC, 0xB6, 0x29, 0x66, 0x1C, 0xFF, 0x4C, 
	0x44, 0xDE, 0x63, 0x4B, 0x0E, 0x91, 0x90, 0x81, 
	0x9D, 0xFB, 0x71, 0xAD, 0x41, 0xB9, 0x49, 0x8E, 
	0x11, 0x33, 0xD7, 0x01, 0xEC, 0x7B, 0xCD, 0x28, 
	0x59, 0xCD, 0xF8, 0x83, 0x2F, 0xB6, 0x29, 0xC4, 
	0x97, 0x25, 0x1B, 0x4F, 0x29, 0x16, 0xA7, 0x3D, 

	/* Database Page 27 */

	0xFF, 0x45, 0xD8, 0xB4, 0xB9, 0xF1, 0xC4, 0x8E, 
	0x4E, 0x6F, 0x71, 0x31, 0x2D, 0x10, 0x29, 0xB6, 
	0xD2, 0x01, 0xE7, 0x91, 0x64, 0x07, 0x56, 0xB9, 
	0x39, 0xF9, 0xF3, 0x45, 0x1A, 0x96, 0x3A, 0x80, 
	0x4E, 0xDC, 0x20, 0xD4, 0xA6, 0x3D, 0x45, 0xEB, 
	0x7F, 0xCE, 0x53, 0x07, 0xC4, 0x46, 0x28, 0x1A, 
	0xD9, 0x39, 0xD5, 0xB9, 0x74, 0x85, 0xF3, 0x12, 
	0xC3, 0x28, 0xE1, 0x3A, 0x7F, 0x0F, 0x97, 0xFD, 
	0xB4, 0x1F, 0x3D, 0xF3, 0x15, 0xBD, 0xFF, 0xBA, 
	0xF6, 0x23, 0xF5, 0x2A, 0x5E, 0x01, 0x23, 0x9A, 
	0xA9, 0xAE, 0xB7, 0xFF, 0xB5, 0x30, 0x91, 0xD2, 
	0x15, 0xD5, 0xB4, 0x21, 0x69, 0x7B, 0x09, 0x37, 
	0x4E, 0x51, 0x3D, 0x03, 0xD2, 0x76, 0x80, 0xF3, 
	0x7E, 0xDA, 0x2D, 0xAF, 0x78, 0xFB, 0xC4, 0x56, 
	0xED, 0x2A, 0x9B, 0x61, 0xE2, 0x3E, 0xBF, 0x2C, 
	0x39, 0x94, 0x4B, 0xA7, 0x8C, 0xB3, 0x02, 0x89, 
	0xEB, 0xFF, 0x49, 0xFF, 0x36, 0xF7, 0xB7, 0x9A, 
	0x0C, 0xE5, 0xFE, 0x43, 0x69, 0xD6, 0x60, 0x9E, 
	0x2D, 0x68, 0x37, 0x63, 0x2A, 0xB5, 0xF5, 0xBF, 
	0xDC, 0x1A, 0x21, 0x41, 0x6C, 0xE1, 0x74, 0x6C, 
	0x90, 0xA1, 0x35, 0x39, 0x41, 0xAB, 0x55, 0x0E, 
	0xFB, 0x0A, 0xF3, 0x61, 0x9E, 0x54, 0x5D, 0xC2, 
	0x74, 0x53, 0x8D, 0x9A, 0xE6, 0x70, 0x73, 0xFB, 
	0x33, 0x28, 0x74, 0x74, 0x2B, 0x30, 0x28, 0xF6, 
	0x75, 0x50, 0x4B, 0x17, 0xE0, 0xEE, 0xBD, 0xAF, 
	0xBB, 0xA0, 0xBB, 0x32, 0xF1, 0x21, 0x65, 0x8D, 
	0xF1, 0x85, 0xDB, 0xE3, 0xD4, 0x6A, 0x20, 0x10, 
	0x65, 0xD1, 0xD6, 0x45, 0x43, 0x9C, 0x06, 0xFA, 
	0x0F, 0x1C, 0x37, 0x48, 0x17, 0x6F, 0x19, 0x78, 
	0xF4, 0xB0, 0x7F, 0xB2, 0xEC, 0x72, 0xC3, 0xB2, 
	0x71, 0xCD, 0x27, 0x86, 0xA4, 0x44, 0x64, 0x15, 
	0x35, 0x0D, 0x45, 0x31, 0x54, 0xE8, 0x18, 0x97, 
	0xCB, 0x62, 0xFF, 0xF1, 0xAA, 0xCC, 0x5D, 0x3A, 
	0x7E, 0x61, 0x47, 0x20, 0xEF, 0xFB, 0xE9, 0x7B, 
	0x83, 0x9C, 0x52, 0x91, 0xB5, 0x3C, 0xCB, 0xF5, 
	0x03, 0xB5, 0xB1, 0x59, 0x81, 0x39, 0x29, 0xBD, 
	0xC6, 0x01, 0x00, 0xE0, 0x95, 0x19, 0xC0, 0x45, 
	0xD6, 0x8D, 0x9D, 0x4D, 0xDB, 0x56, 0x02, 0xB0, 
	0xEB, 0x24, 0xDC, 0xF9, 0x1D, 0xF6, 0x22, 0x73, 
	0x2B, 0x49, 0x39, 0x1C, 0xC0, 0xB3, 0x6B, 0x91, 
	0x1E, 0xDD, 0x2A, 0xF9, 0x66, 0x9C, 0x9A, 0x79, 
	0x41, 0x0F, 0x4F, 0x38, 0x57, 0x99, 0x9C, 0xBF, 
	0xD3, 0xA5, 0xAC, 0x1C, 0x54, 0xCD, 0x36, 0xAD, 
	0x18, 0x8B, 0x35, 0x19, 0xFA, 0x01, 0xAA, 0xC8, 
	0x93, 0xFD, 0xBA, 0xDF, 0xC8, 0x02, 0xB2, 0xDE, 
	0x2F, 0x47, 0xDE, 0x7C, 0x4E, 0xE8, 0x00, 0xD7, 
	0x8E, 0xE2, 0x7C, 0xEE, 0xED, 0x78, 0x9A, 0xED, 
	0x4E, 0x6D, 0x06, 0x45, 0x79, 0x86, 0x49, 0x90, 
	0xC8, 0x2B, 0xAA, 0xFF, 0xD5, 0x9C, 0xB1, 0xB0, 
	0x23, 0xAC, 0x1C, 0x9A, 0xB9, 0x55, 0x1D, 0xE6, 
	0xAE, 0x21, 0x0A, 0x83, 0xD7, 0x0C, 0xDA, 0x58, 
	0x45, 0xCF, 0xE1, 0x8F, 0x69, 0x58, 0x32, 0x64, 
	0x7A, 0x27, 0xA9, 0xF3, 0xCA, 0x1B, 0xC1, 0x23, 
	0x94, 0xEB, 0x0C, 0xF3, 0x30, 0x27, 0x33, 0x0E, 
	0x70, 0x53, 0xD3, 0x8E, 0x43, 0x85, 0xB9, 0xD5, 
	0xB2, 0x18, 0x59, 0x20, 0x2F, 0x42, 0x41, 0x76, 
	0x9D, 0x4F, 0x88, 0x71, 0xED, 0x5A, 0x58, 0xED, 
	0x60, 0x09, 0x59, 0xAF, 0x4F, 0x1F, 0x2A, 0x35, 
	0x05, 0xD6, 0x45, 0xB9, 0x22, 0x6F, 0x0A, 0xF1, 
	0xCC, 0x29, 0xAC, 0x10, 0x63, 0x7C, 0xF4, 0xA4, 
	0xE4, 0x95, 0x81, 0xA4, 0xBA, 0x54, 0x05, 0x5D, 
	0x9B, 0x0E, 0x3B, 0xDE, 0xF5, 0xBD, 0xC7, 0x97, 
	0x90, 0xCE, 0x61, 0xF2, 0x6A, 0x95, 0xE3, 0x5D, 
	0x8F, 0x54, 0x28, 0x56, 0xE5, 0x5A, 0xD8, 0xFB, 
	0xA5, 0xB6, 0xB9, 0xA8, 0xFF, 0x1B, 0x12, 0xC8, 
	0xDE, 0x36, 0x78, 0xC8, 0x66, 0x7E, 0x8A, 0xE7, 
	0x92, 0x3E, 0xA5, 0xF4, 0x24, 0xC8, 0x8F, 0x6A, 
	0x59, 0xC0, 0x1D, 0x7B, 0xB8, 0x2E, 0x0C, 0x29, 
	0x44, 0x05, 0x37, 0xB4, 0x4B, 0xB5, 0x2E, 0x19, 
	0x69, 0x1F, 0x5A, 0x04, 0x74, 0x64, 0xEC, 0xEE, 
	0x15, 0x64, 0xB3, 0x5E, 0x6C, 0x41, 0x74, 0x0F, 
	0x02, 0xCC, 0x64, 0x9A, 0x61, 0xA1, 0x75, 0xBA, 
	0x4C, 0xA1, 0x14, 0xC0, 0x33, 0xEC, 0x4F, 0x73, 
	0xE4, 0xA7, 0x2F, 0x4A, 0x9B, 0x0B, 0x9E, 0xA0, 
	0xB5, 0x7E, 0xD2, 0x7C, 0xED, 0xE3, 0x1D, 0xA3, 
	0x98, 0xBF, 0xBB, 0x22, 0xF0, 0xCD, 0xE9, 0xF9, 
	0x8A, 0xC0, 0xDF, 0xC7, 0xE4, 0x4C, 0x7E, 0x5E, 
	0x06, 0x00, 0xA2, 0xD9, 0xB9, 0xB5, 0xD6, 0x27, 
	0xE9, 0x46, 0x3B, 0x6B, 0x42, 0x3D, 0x46, 0x7A, 
	0x54, 0xF7, 0xAE, 0x20, 0xAB, 0x2C, 0x60, 0x8B, 
	0x9E, 0x76, 0x69, 0x44, 0xA3, 0xFF, 0xCD, 0xC3, 
	0x10, 0xBC, 0x61, 0x70, 0x91, 0x53, 0xE8, 0x74, 
	0xDF, 0xE8, 0x38, 0x53, 0x17, 0x8E, 0xCD, 0x68, 
	0x2F, 0x05, 0xA7, 0x0C, 0x2D, 0x9B, 0x40, 0x7D, 
	0x03, 0xBF, 0x3A, 0xE1, 0x81, 0xB9, 0x20, 0x75, 
	0x46, 0x15, 0xEA, 0xC3, 0x64, 0xAB, 0xA8, 0xAF, 
	0xC9, 0x1C, 0xA1, 0xB4, 0x96, 0x83, 0xAB, 0x21, 
	0xEB, 0x9B, 0xF6, 0xD5, 0x91, 0xF3, 0x82, 0x70, 
	0x8D, 0x98, 0x38, 0x5C, 0x81, 0x65, 0xDE, 0x09, 
	0xCC, 0x64, 0x75, 0x7F, 0x6A, 0xDB, 0x22, 0x2A, 
	0x29, 0x34, 0x58, 0x06, 0xEE, 0x51, 0x77, 0x81, 
	0x09, 0x48, 0xE0, 0x9C, 0xFB, 0x1B, 0xFF, 0x00, 
	0xFB, 0xF6, 0x66, 0xC3, 0x09, 0x11, 0x28, 0xE4, 
	0x53, 0xFE, 0x4E, 0x39, 0x94, 0xBC, 0xCC, 0xBC, 
	0x08, 0x91, 0x01, 0x70, 0x99, 0x79, 0xA4, 0xB7, 
	0x8E, 0xAE, 0xF8, 0x09, 0x7E, 0xCE, 0x0B, 0x93, 
	0x82, 0x3A, 0xB2, 0x45, 0x35, 0x37, 0xFF, 0x81, 
	0xC6, 0x10, 0x75, 0xD1, 0x6D, 0x01, 0x61, 0xB6, 
	0xF8, 0x36, 0x8D, 0x61, 0x17, 0x82, 0xDD, 0xBE, 
	0x7E, 0x00, 0xDB, 0xF5, 0x89, 0x5D, 0x1C, 0xC7, 
	0x4E, 0x6D, 0xFE, 0xED, 0x47, 0x52, 0xA0, 0x27, 
	0x35, 0x88, 0x90, 0x1D, 0x63, 0xE2, 0x5C, 0x72, 
	0xA9, 0x1D, 0x14, 0xBD, 0x97, 0x2C, 0x57, 0xC9, 
	0x1F, 0x89, 0x6F, 0x8A, 0x1C, 0xCA, 0x9A, 0xCE, 
	0x09, 0x5B, 0x11, 0x00, 0xE7, 0x3F, 0x6B, 0x5F, 
	0xD9, 0x6B, 0xF5, 0x53, 0x5A, 0xB4, 0x15, 0x37, 
	0xD5, 0xE8, 0x27, 0x6D, 0x8E, 0x69, 0x87, 0x6A, 
	0xEA, 0x71, 0xE1, 0x51, 0x06, 0xDF, 0x6E, 0xDB, 
	0xAC, 0xB1, 0x6A, 0x36, 0x37, 0xAF, 0x6B, 0xB5, 
	0x06, 0x2F, 0xC4, 0xC3, 0x7D, 0xA6, 0x01, 0xC3, 
	0xAC, 0x96, 0x8B, 0xE6, 0x4C, 0x5B, 0x78, 0xC7, 
	0x4C, 0x3E, 0xFF, 0x35, 0x44, 0x90, 0x5D, 0x3E, 
	0x11, 0x20, 0x5E, 0xEE, 0xDC, 0x18, 0x87, 0xFF, 
	0xE5, 0xB9, 0x9C, 0xBD, 0xDD, 0xCC, 0x10, 0x95, 
	0xA0, 0xCA, 0xDD, 0x5C, 0xCE, 0x53, 0x53, 0xB3, 
	0x6C, 0x81, 0x7F, 0xB2, 0xD1, 0x81, 0x0E, 0xA8, 
	0xE1, 0xA1, 0xB8, 0x06, 0x9A, 0xD0, 0xF3, 0x3B, 
	0xB4, 0xF9, 0xE8, 0xE8, 0x3F, 0x34, 0xA8, 0xD8, 
	0x2B, 0x22, 0xDB, 0xBD, 0x6F, 0x56, 0x75, 0x09, 
	0xB0, 0x32, 0xB4, 0xDD, 0x67, 0xC0, 0x64, 0x3E, 
	0x72, 0x5F, 0x12, 0x50, 0x08, 0x8C, 0x0B, 0x70, 
	0xA9, 0xCC, 0xCE, 0xC6, 0xD4, 0xF2, 0x5C, 0x12, 
	0xA6, 0x9C, 0xFB, 0x1D, 0xF6, 0xE6, 0x49, 0xD4, 
	0x69, 0xDC, 0x17, 0xA4, 0x4F, 0xB4, 0xAB, 0x9C, 
	0xED, 0x40, 0xD5, 0x34, 0x20, 0x74, 0x4C, 0xA9, 
	0x39, 0x64, 0x48, 0x53, 0x2D, 0x34, 0x25, 0x1D, 
	0xC6, 0xC0, 0xE7, 0x53, 0x74, 0x82, 0xBB, 0xB0, 
	0x0F, 0x22, 0xD1, 0xE1, 0x46, 0x5A, 0xB9, 0x48, 
	0x6E, 0x75, 0xD5, 0x4E, 0x3E, 0xAD, 0x93, 0xCC, 
	0xFF, 0xF4, 0xD6, 0x14, 0x48, 0xE6, 0xEA, 0x86, 
	0xF3, 0xE6, 0x8A, 0xAC, 0x6B, 0xE4, 0xC1, 0x15, 
	0xF6, 0xDB, 0x46, 0x4D, 0x51, 0x0C, 0x79, 0x21, 
	0xC1, 0x7B, 0xFF, 0x20, 0xFA, 0xC8, 0x83, 0xEC, 
	0xFD, 0x75, 0x9D, 0x0E, 0x43, 0x37, 0x34, 0x4A, 
	0x12, 0x1B, 0x1E, 0x33, 0x49, 0x7D, 0x1D, 0xCF, 
	0xB8, 0x62, 0xC5, 0xBA, 0x37, 0x9C, 0x58, 0x0B, 
	0x99, 0xCA, 0x1F, 0x88, 0xB5, 0x7E, 0xA5, 0xF0, 
	0xC2, 0xE4, 0x05, 0x18, 0x7F, 0xE9, 0xB0, 0xB8, 
	0x1A, 0xB8, 0x28, 0x9E, 0x51, 0x95, 0x33, 0xE2, 
	0xE1, 0x73, 0x61, 0xA9, 0x6F, 0x60, 0xC0, 0xFB, 
	0x8E, 0x33, 0x77, 0x5F, 0xB4, 0x1B, 0x68, 0x80, 
	0x73, 0xA8, 0xD1, 0xE0, 0x3B, 0xA8, 0xA3, 0xF0, 
	0xF8, 0xB7, 0xA4, 0xC1, 0xEF, 0x3B, 0x0A, 0x52, 
	0x0D, 0x13, 0xF0, 0x37, 0x47, 0xD4, 0x0C, 0x56, 
	0x25, 0xE8, 0x50, 0xF5, 0x38, 0x3C, 0xBB, 0x37, 
	0xC8, 0xFF, 0x59, 0x1E, 0x04, 0xD6, 0xAE, 0x45, 
	0xE4, 0xB8, 0xF6, 0x1D, 0x34, 0x95, 0x00, 0x35, 
	0x17, 0xDD, 0xF5, 0x75, 0x26, 0x68, 0xEB, 0x20, 
	0x20, 0x7A, 0xF3, 0x43, 0x04, 0xEF, 0xF2, 0x8B, 
	0x2D, 0xCE, 0x74, 0x3F, 0x5B, 0x94, 0x2A, 0x55, 
	0xCD, 0x81, 0xC0, 0x1E, 0xC5, 0x80, 0x9C, 0xF7, 
	0xC8, 0x26, 0x1B, 0xD4, 0x80, 0x45, 0xD8, 0x76, 
	0x96, 0xB2, 0x27, 0x26, 0x20, 0x27, 0x79, 0xCB, 
	0xB9, 0x45, 0x3A, 0x22, 0xE3, 0xD7, 0x7F, 0x6A, 
	0xA0, 0xE1, 0x00, 0x4F, 0x00, 0x0B, 0xC0, 0xF5, 
	0x66, 0x0E, 0x84, 0xC6, 0x6A, 0x6E, 0x11, 0x29, 
	0x86, 0xE0, 0x33, 0x15, 0xB9, 0x83, 0x69, 0x32, 
	0xBD, 0xA6, 0xA4, 0xB0, 0xBF, 0x44, 0xC0, 0xEB, 
	0x6D, 0x02, 0x3B, 0xE6, 0x9A, 0x75, 0xBD, 0x8A, 
	0xE7, 0x49, 0x74, 0x1F, 0x92, 0xFD, 0xF0, 0xC4, 
	0x8A, 0xB1, 0xE9, 0x11, 0xEC, 0xD8, 0xE7, 0x9D, 
	0xC2, 0x7D, 0xFF, 0x5D, 0x20, 0x6C, 0xAA, 0xF7, 
	0x36, 0x66, 0x17, 0x72, 0xE1, 0x40, 0xC5, 0x0D, 
	0xB0, 0xA9, 0x9D, 0x62, 0xBD, 0xC3, 0x2C, 0xC8, 
	0xB9, 0xB8, 0xD3, 0xAF, 0x82, 0x17, 0xF7, 0xB3, 
	0x5F, 0x3E, 0xF7, 0x34, 0x13, 0xA7, 0xA3, 0x3F, 
	0xDF, 0x48, 0x3B, 0x07, 0x42, 0x5C, 0xCF, 0x1B, 
	0x78, 0x25, 0x6B, 0x2E, 0x6A, 0x42, 0x1C, 0x0B, 
	0xBB, 0xFA, 0x1D, 0x3E, 0x31, 0xAD, 0x35, 0x8D, 
	0x6B, 0x71, 0x25, 0x14, 0x21, 0x6F, 0xAC, 0x7E, 
	0x8D, 0x19, 0xEB, 0xDE, 0x56, 0x9B, 0x47, 0xB9, 
	0xEC, 0x51, 0xD5, 0x8A, 0x61, 0x37, 0x13, 0x1D, 
	0xE9, 0xD3, 0xC3, 0x93, 0x19, 0xAC, 0x55, 0xCE, 
	0x01, 0x3F, 0x0F, 0x0A, 0xD4, 0xB0, 0xD7, 0x93, 
	0xFF, 0x09, 0x97, 0xC1, 0xF4, 0x17, 0x2B, 0xE4, 
	0x1A, 0xED, 0x26, 0x7B, 0x2E, 0x30, 0x94, 0x1D, 
	0x65, 0x9B, 0xCF, 0x52, 0x69, 0xCF, 0x0A, 0x26, 
	0x0A, 0xE8, 0x46, 0xFF, 0xD0, 0x51, 0x1A, 0xAC, 
	0x15, 0xE7, 0xC8, 0x0F, 0xED, 0x4F, 0xF2, 0x05, 
	0xED, 0xA0, 0xE4, 0x07, 0x9E, 0xA5, 0xD1, 0xAB, 
	0x90, 0xC1, 0xE5, 0x0C, 0x8B, 0xDE, 0x67, 0x1C, 
	0x49, 0xD6, 0x7B, 0xF4, 0x06, 0xEE, 0x6A, 0x77, 
	0xB9, 0x99, 0xBF, 0xE8, 0x9D, 0x7B, 0x77, 0xE8, 
	0x5D, 0x2A, 0xA8, 0xA9, 0x91, 0x8E, 0x68, 0x50, 
	0xCC, 0xBA, 0xC8, 0x65, 0x73, 0x4A, 0xD2, 0x3B, 
	0xB4, 0xBB, 0x9E, 0xAB, 0xC9, 0x7E, 0x2F, 0xE2, 
	0xFD, 0x73, 0x60, 0x42, 0x91, 0x3E, 0x87, 0xCC, 
	0xD5, 0xF7, 0xB3, 0x6B, 0xE2, 0xFE, 0x42, 0xA5, 
	0x41, 0x8D, 0x51, 0x5C, 0xA9, 0x8E, 0x57, 0xD7, 
	0x06, 0xB8, 0x69, 0x41, 0x59, 0xD9, 0x5A, 0x93, 
	0xEC, 0x76, 0x54, 0x20, 0x06, 0xF1, 0x2A, 0x8E, 
	0xB8, 0x94, 0xF0, 0xCB, 0x7D, 0xBC, 0xF2, 0xCF, 
	0xA1, 0xB9, 0x92, 0xF4, 0xDD, 0xF2, 0x34, 0xC5, 
	0x91, 0xF2, 0xE8, 0x35, 0xFF, 0x47, 0x9A, 0xB9, 
	0x39, 0x6F, 0xB5, 0xCF, 0x8D, 0xE7, 0x59, 0xD1, 
	0x6C, 0xD2, 0xB8, 0xA9, 0x29, 0xE2, 0xBC, 0x12, 
	0x58, 0x18, 0xE6, 0xA7, 0x17, 0xDD, 0x0E, 0x2D, 
	0x1A, 0xA1, 0xB0, 0x82, 0x18, 0xEB, 0xF2, 0x15, 
	0xFA, 0x89, 0x34, 0x4B, 0x24, 0xC6, 0xC8, 0x65, 
	0x0E, 0x65, 0x10, 0x1B, 0xC9, 0x19, 0xDC, 0x01, 
	0x48, 0x00, 0x0F, 0x49, 0xB5, 0x72, 0x0F, 0x9C, 
	0xE2, 0x33, 0x84, 0x59, 0x40, 0xAA, 0x55, 0x6D, 
	0x63, 0x8C, 0x1C, 0x95, 0xD9, 0x93, 0x09, 0xBD, 
	0x71, 0x72, 0x43, 0x97, 0xA1, 0x96, 0xE8, 0xD2, 
	0x97, 0x48, 0x92, 0x2F, 0x90, 0xF1, 0xDB, 0x69, 
	0x17, 0x1A, 0xF0, 0xCB, 0x12, 0x1B, 0x0E, 0x26, 
	0xBF, 0x74, 0xD1, 0xAC, 0x71, 0xD0, 0x7C, 0x8D, 
	0xCA, 0xCD, 0x26, 0xE5, 0x50, 0x47, 0x4D, 0x0A, 
	0x09, 0x99, 0x1E, 0x18, 0xF6, 0xBE, 0x5D, 0xC2, 
	0xBF, 0x27, 0x61, 0x51, 0xA0, 0xFF, 0xC4, 0x79, 
	0x5F, 0x28, 0x49, 0xB2, 0xFF, 0x6F, 0xD7, 0x21, 
	0xC2, 0x6D, 0x7C, 0x49, 0xB3, 0x3A, 0x00, 0x9C, 
	0x6A, 0x04, 0xD8, 0x9E, 0xE5, 0x1D, 0xB9, 0xFE, 
	0xFC, 0x83, 0x5B, 0xBF, 0x29, 0xEC, 0x90, 0xDE, 
	0x09, 0x98, 0xBC, 0xDA, 0x0F, 0x94, 0xF1, 0x28, 
	0x70, 0x87, 0x4C, 0xF0, 0x09, 0x1F, 0x10, 0x8E, 
	0xE2, 0xF4, 0x92, 0x23, 0x70, 0xEC, 0xEF, 0xD6, 
	0x15, 0xD9, 0x95, 0x20, 0x92, 0x2B, 0x57, 0x10, 
	0x04, 0x27, 0x17, 0xE6, 0xBF, 0xE3, 0x4A, 0x28, 
	0x38, 0x89, 0xEC, 0xF6, 0xEE, 0xBD, 0x36, 0x29, 
	0x22, 0xAF, 0x3C, 0x9D, 0x2F, 0x6C, 0xAD, 0xE2, 
	0xA7, 0x97, 0xA2, 0x10, 0xA9, 0xBF, 0xBD, 0xDC, 
	0x91, 0x24, 0x2B, 0x87, 0x8E, 0x5B, 0xB2, 0xED, 
	0x9E, 0xBC, 0xBF, 0x9F, 0x0A, 0xCC, 0xC0, 0xAA, 
	0xD3, 0x1B, 0xD3, 0x5E, 0x97, 0x32, 0x3A, 0x4B, 
	0x56, 0xF8, 0x6B, 0x50, 0xC4, 0xB5, 0xFF, 0x1F, 
	0x4F, 0x20, 0x46, 0xB1, 0xCE, 0xDC, 0x80, 0x41, 
	0xAC, 0x9D, 0x12, 0xD3, 0xCD, 0xAB, 0x9A, 0x57, 
	0x85, 0xCC, 0x06, 0xD9, 0xA6, 0x07, 0x4C, 0x2B, 
	0x62, 0x65, 0x19, 0x72, 0xDB, 0x97, 0x1E, 0x27, 
	0x65, 0x82, 0x2A, 0xCA, 0x61, 0x0D, 0x16, 0x72, 
	0xC8, 0x11, 0xB2, 0x95, 0x4B, 0x75, 0xDA, 0xA9, 
	0x00, 0x0C, 0xE1, 0xA4, 0xAC, 0x0B, 0x8D, 0xB1, 
	0xDC, 0x35, 0x98, 0x86, 0xE9, 0xDD, 0x95, 0x71, 
	0x71, 0x76, 0xE7, 0x92, 0x1A, 0x41, 0x7D, 0xB9, 
	0x74, 0x4D, 0x06, 0x0C, 0x3F, 0xED, 0xE6, 0x21, 
	0x43, 0x44, 0x75, 0x0C, 0xBF, 0xDB, 0x8A, 0x3F, 
	0x6B, 0xEF, 0xE6, 0x1D, 0x50, 0xBA, 0x21, 0x78, 
	0x3D, 0x6C, 0x29, 0xE9, 0x78, 0x6E, 0xCF, 0x84, 
	0x52, 0xC0, 0xD9, 0x81, 0x66, 0x65, 0xA8, 0xD2, 
	0x9D, 0xF7, 0xE6, 0xAD, 0x6D, 0x31, 0xCB, 0xB2, 
	0x3E, 0xBB, 0xB7, 0x64, 0xB0, 0xE1, 0x17, 0xFF, 
	0x84, 0x59, 0xA4, 0x08, 0xE7, 0xEB, 0xF0, 0xA5, 
	0x4A, 0x8C, 0x03, 0x46, 0x91, 0x32, 0xAB, 0xE1, 
	0x15, 0x5D, 0x22, 0x09, 0x18, 0x48, 0x0C, 0xBB, 
	0xD3, 0x29, 0x43, 0xDD, 0x43, 0x31, 0x3F, 0x77, 
	0x79, 0xD5, 0x88, 0xD4, 0x96, 0x85, 0xF4, 0x54, 
	0xA8, 0xBD, 0xCE, 0x20, 0x14, 0xFF, 0xB0, 0xEC, 
	0xAE, 0x9E, 0xA1, 0x56, 0x74, 0x56, 0x45, 0xC7, 
	0x9B, 0xE8, 0xD7, 0x29, 0xC2, 0x05, 0xBF, 0xDA, 
	0xE7, 0x26, 0xD4, 0xD6, 0x74, 0xE9, 0x63, 0x1F, 
	0xC4, 0x24, 0x27, 0x01, 0x43, 0xFB, 0x89, 0xFC, 
	0xA3, 0x5C, 0x7E, 0xB8, 0xA8, 0x63, 0x7C, 0xC1, 
	0x29, 0x36, 0x0F, 0xA9, 0x23, 0x7F, 0x6D, 0xE0, 
	0x69, 0xEC, 0xDC, 0xC9, 0xA6, 0x05, 0x0E, 0x68, 
	0x48, 0x47, 0x78, 0x6B, 0x56, 0x87, 0x05, 0xEF, 
	0x32, 0xC3, 0x9A, 0x89, 0x5F, 0x7D, 0x4F, 0xC4, 
	0x8F, 0x79, 0xD7, 0x81, 0xFA, 0x94, 0xC4, 0xF2, 

	/* Database Page 28 */

	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 

	/* Database Page 29 */

	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 

	/* Database Page 30 */

	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 

	/* Database Page 31 */

	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 
	};

unsigned char far *rgbEngSysDb = rgbEngSysDbDef;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\space.c ===
#include "daestd.h"

#ifdef DEBUG
//#define SPACECHECK
//#define TRACE
#endif

DeclAssertFile;				/* Declare file name for assert macros */

extern CRIT  		critSplit;
extern LONG			cpgSESysMin;	// minimum secondary extent size, default is 16
LONG				lPageFragment;
CODECONST(ULONG)	autoincInit = 1;


LOCAL ERR ErrSPIAddExt( FUCB *pfucb, PGNO pgnoLast, CPG *pcpgSize, const INT fExtent );
LOCAL ERR ErrSPIGetSE( PIB *ppib, FUCB *pfucb, PGNO pgnoFirst, CPG const cpgReq, CPG const cpgMin );
LOCAL ERR ErrSPIWasAlloc( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize );
LOCAL ERR ErrSPIValidFDP( DBID dbid, PGNO pgnoFDP, PIB *ppib );


ERR ErrSPInitFDPWithExt( FUCB *pfucb, PGNO pgnoFDPFrom, PGNO pgnoFirst, INT cpgReqRet, INT cpgReqWish )
	{
	ERR		err;
	LINE	line;
	KEY		key;
	SSIB	*pssib = &pfucb->ssib;
	BYTE	rgbKey[sizeof(PGNO)];
	BOOL	fBeginTransactionWasDone = fFalse;
	LINE	lineNull = { 0, NULL };

	/*	logging aggregate operation
	/**/

	/*	set pgno to initialize in current CSR pgno
	/**/
	PcsrCurrent( pfucb )->pgno = pgnoFirst;
	CallJ( ErrNDNewPage( pfucb, pgnoFirst, pgnoFirst, pgtypFDP, fTrue ), DontUnpin );

	BFPin( pfucb->ssib.pbf );

	/*	goto FDP root
	/**/
	DIRGotoPgnoItag( pfucb, pgnoFirst, itagFOP )

	/*	build OwnExt tree with primary extent request size, not
	/*	actual secondary extent size returned from parent FDP.
	/*	Since the actual primary extent size is stored in an entry of
	/*	OwnExt the prefered primary extent size may be stored as requested
	/*	thus allowing future secondary extents which are fractions of
	/*	the prefered primary extent size to be requested as initially
	/*	expected.
	/**/
	/* must store cpgReq, initial request, as primary extent size
	/**/
	line.pb = (BYTE *)&cpgReqWish;
	line.cb = sizeof(PGNO);

	/*	insert Owned extents node
	/**/
	Call( ErrDIRInsert( pfucb, &line, pkeyOwnExt,
		fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	insert Available extents node
	/**/
	line.pb = (BYTE *)&pgnoFDPFrom;
	Assert( line.cb == sizeof(PGNO) );
	Call( ErrDIRInsert( pfucb, &line, pkeyAvailExt,
		fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	insert DATA node
	/**/
	Call( ErrDIRInsert( pfucb, &lineNull, pkeyData,
		fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	insert LONG node
	/**/
	Call( ErrDIRInsert( pfucb, &lineNull, pkeyLong,
		fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	insert AUTOINCREMENT node
	/**/
	line.pb = (BYTE *)&autoincInit;
	line.cb = sizeof(autoincInit);
	Call( ErrDIRInsert( pfucb, &line, pkeyAutoInc,
		fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	goto Owned extents node
	/**/
	DIRGotoPgnoItag( pfucb, pgnoFirst, itagOWNEXT );

	/*	add owned extent
	/**/
	KeyFromLong( rgbKey, pgnoFirst + cpgReqRet - 1 );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	line.pb = (BYTE *)&cpgReqRet;
	line.cb = sizeof(PGNO);
	Call( ErrDIRInsert( pfucb, &line, &key,
			fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	Add availext entry if extent less FDP page is one or more pages.
	/*	Decrement the page count to show that the first page was used for
	/*	the FDP.  *ppgnoFirst does not need to be incremented as the
	/*	AvailExt entry is keyed with pgnoLast which remains unchanged and
	/*	the page number of the FDP is the desired return in *ppgnoFirst.
	/**/
	if ( --cpgReqRet > 0 )
		{
		/*	goto Available extents node
		/**/
		DIRGotoPgnoItag( pfucb, pgnoFirst, itagAVAILEXT );

		/*	rgbKey should contain pgnoLast
		/**/
		Assert( key.cb == sizeof(PGNO) );
		Assert( key.pb == (BYTE *)rgbKey );
		Assert( line.pb == (BYTE *)&cpgReqRet );
		Assert( line.cb == sizeof(PGNO) );
		Call( ErrDIRInsert( pfucb, &line, &key,
				fDIRNoLog | fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );
		}

	if ( pfucb->dbid != dbidTemp )
		{
		/*	the FDP page is initialized
		/**/

		/*	recovery assume InitFDP always occur in transaction.
		 */
		if ( pfucb->ppib->level == 0 )
			{
			Call( ErrDIRBeginTransaction( pfucb->ppib ) );
			fBeginTransactionWasDone = fTrue;
			}

		Call( ErrLGInitFDP(
			pfucb,
			pgnoFDPFrom,
			PnOfDbidPgno( pfucb->dbid, pgnoFirst ),
			cpgReqRet,
			cpgReqWish ) );
		}

	err = JET_errSuccess;

HandleError:
	if ( fBeginTransactionWasDone )
		CallS( ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush ) );
		
	BFUnpin( pfucb->ssib.pbf );
DontUnpin:
	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPGetExt
//	========================================================================
//	ERR ErrSPGetExt( ppib, dbid, pgnoFDP, pcpgReq, cpgMin, ppgnoFirst, fNewFDP )
//		PIB		*ppib;				 // IN
//		DBID	dbid;	   			 // IN
//		PGNO	pgnoFDP;   			 // IN
//		LONG	*pcpgReq;			 // INOUT
//		CPG		cpgMin;				 // IN
//		PGNO	*ppgnoFirst;		 // OUT
//		BOOL	fNewFDP;   			 // IN
//
//	Allocates an extent of at least cpgMin, and as much as cpgReq + lPageFragment.
//	The allocated extent is removed from the AvailExt tree.	 If the minimum
//	extent size cannot be allocated from the AvailExt tree at the time of the
//	call, secondary extents are allocated from the parent FDP, or OS/2 for
//	the device level FDP, until an extent of at least cpgMin can be allocated.
//	If fNewFDP is set, the first page of the allocated extent, pgnoFirst, is
//	setup as an FDP, with built AvailExt and OwnExt trees.	The allocated extent
//	is added to the OwnExt tree and the available portion of the extent is
//	added to AvailExt.
//
// PARAMETERS		ppib		   process identification block
//					pgnoFDP	   page number of FDP to allocate from
//					pcpgReq	   requested extent size
//					cpgMin	   minimum acceptable extent size
//					ppgnoFirst  first page of allocated extent
//					fNewFDP		Various flags:
//						VALUE				  MEANING
//						========================================
//						fTrue	   Setup first page of extent as FDP.
//						fFalse   Do not setup first page of extent as FDP.
//
// RETURNS
//		JET_errSuccess, or error code from failing routine, or one
//		of the following "local" errors:
//			-JET_errDiskFull	no space in FDP or parent to satisfy
//								minimum extent size
//		  +errSPFewer			allocated extent smaller than requested
//		  +errSPMore			allocated extent larger than requested
//
//	FAILS ON
//		given extent size less than 0
//		given minimum size greater than requested size
//
// SIDE EFFECTS
// COMMENTS
//-

ERR ErrSPIGetExt(
	FUCB	*pfucbTable,
	PGNO	pgnoFDP,
	CPG		*pcpgReq,
	CPG		cpgMin,
	PGNO	*ppgnoFirst,
	BOOL	fNewFDP )
	{
	ERR 	err;
	CPG 	cpgReq = *pcpgReq;
	FUCB 	*pfucb;
	DIB 	dib;
	LINE	line;
	CPG		cpgAvailExt;
	PGNO	pgnoAELast;
	BYTE	rgbKey[sizeof(PGNO)];
	KEY		key;

	AssertCriticalSection( critSplit );

	/*	check parameters.  If setting up new FDP, increment requested number of
	/*	pages to account for consumption of first page to make FDP.
	/**/
	Assert( *pcpgReq > 0 || ( fNewFDP && *pcpgReq == 0 ) );
	Assert( *pcpgReq >= cpgMin );
#ifdef SPACECHECK
	Assert( !( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) < 0 ) );
#endif

	/*	if a new FDP is requested, increment the request count so a page
	/*	may be provided for the new FDP.  The available page request remains
	/*	the same, as the first page will be removed.  A comparison will be
	/*	made of the available page request against the available pages
	/*	received to generate the return code.
	/**/
	if ( fNewFDP )
		{
		++*pcpgReq;
		}

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallR( ErrDIROpen( pfucbTable->ppib,
		PgnoFDPOfPfucb( pfucbTable ) == pgnoFDP ?
			pfucbTable->u.pfcb :
			PfcbFCBGet( pfucbTable->dbid, pgnoFDP ),
			pfucbTable->dbid, &pfucb ) );
	Assert( PgnoFDPOfPfucb( pfucb ) == pgnoFDP );
	FUCBSetIndex( pfucb );

	/*	For secondary extent allocation, only the normal DIR operations
	/*	are logged. For allocating a new FDP, a special CreateFDP
	/*	record is logged instead (since the new FDP page needs to be
	/*	initialized as part of Redo).
	/**/

	/*	move to Available extents.
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

	/*	begin search for first extent with size greater than request, allocate
	/*	secondary extent recursively until satisfactory extent found
	/**/
	KeyFromLong( rgbKey, *ppgnoFirst );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIRNull;
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
			goto GetFromSecondaryExtent;
			}
		#ifdef DEBUG
			FPrintF2( "ErrSPGetExt could not down into AvailExt.\n" );
		#endif
		goto HandleError;
		}

	/*	need to go next. If pgnoFirst is not pgnoNull, then backup is
	 *	going on, we if err == FoundLess, the we have to move next to go
	 *	to some page > pgnoFirst. If err == Found Greater, then we have
	 *	to move next to adjust csrstat from beforeCur to OnCur.
	 */
	if ( ErrDIRNext( pfucb, &dib ) < 0 )
		{
		DIRUp( pfucb, 1 );
		goto GetFromSecondaryExtent;
		}
		
	/*	loop through extents looking for one large enough for allocation
	/**/
	Assert( dib.fFlags == fDIRNull );
	do
		{
		Assert( pfucb->lineData.cb == sizeof(PGNO) );
		cpgAvailExt = *(PGNO UNALIGNED *)pfucb->lineData.pb;
		if ( cpgAvailExt == 0 )
			{
			/*	Skip the 0 sized avail node. Delete current node and try next one.
			 */
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			}
		else if ( cpgAvailExt >= cpgMin )
			{
			goto AllocateCurrent;
			}
		err = ErrDIRNext( pfucb, &dib );
		}
	while ( err >= 0 );

	if ( err != JET_errNoCurrentRecord )
		{
		#ifdef DEBUG
			FPrintF2( "ErrSPGetExt could not scan AvailExt.\n" );
		#endif
		Assert( err < 0 );
		goto HandleError;
		}

	DIRUp( pfucb, 1 );

GetFromSecondaryExtent:
	/*	get secondary extents until request can be satisfied.  Setup
	/*	FUCB work area prior to adding extent to OwnExt.
	/**/

	/* do not loop here if the db is being extended, instead, loop
	 * on SPGetExt. See SPGetExt function.
	 */
	Call( ErrSPIGetSE( pfucbTable->ppib, pfucb, pgnoNull, *pcpgReq, cpgMin ) );
	Assert( pfucb->lineData.cb == sizeof( PGNO ) );
	cpgAvailExt = *(PGNO UNALIGNED *)pfucb->lineData.pb;
	Assert( cpgAvailExt > 0 );

AllocateCurrent:
	Assert( pfucb->keyNode.cb == sizeof(PGNO) );
	LongFromKey( &pgnoAELast, pfucb->keyNode.pb );
	*ppgnoFirst = pgnoAELast - cpgAvailExt + 1;
	if ( cpgAvailExt > *pcpgReq && ( *pcpgReq < lPageFragment || cpgAvailExt > *pcpgReq + lPageFragment ) )
		{
		CPG		cpgT;

		/*	*pcpgReq is already set to the return value
		/**/
		Assert( cpgAvailExt > *pcpgReq );
		cpgT = cpgAvailExt - *pcpgReq;
		line.cb = sizeof(PGNO);
		line.pb = (BYTE *)&cpgT;
		Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
		err = JET_errSuccess;
		}
	else
		{
		*pcpgReq = cpgAvailExt;
		Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
		}

	/*	if extent is to be setup as a new FDP, setup the first page of the extent
	/*	as an FDP page and build OwnExt and AvailExt trees.	 Add extent to OwnExt,
	/*	add extent less first page to AvailExt.
	/**/
	if ( fNewFDP )
		{
		VEREXT	verext;

		Assert( pgnoFDP != *ppgnoFirst );
		verext.pgnoFDP = pgnoFDP;
		verext.pgnoChildFDP = *ppgnoFirst;
		verext.pgnoFirst = *ppgnoFirst;
		verext.cpgSize = *pcpgReq;

		DIRUp( pfucb, 1 );
		Call( ErrSPInitFDPWithExt( pfucb, pgnoFDP, *ppgnoFirst, *pcpgReq, cpgReq ) );
		/* decremented since one of it is FDP page
		/**/
		(*pcpgReq)--;
		Assert( pfucbTable->ppib->level > 0 );
		if ( *ppgnoFirst != pgnoSystemRoot )
			{
			Call( ErrVERFlag( pfucb, operAllocExt, &verext, sizeof(verext) ) );
			}
		}

	/* assign error
	/**/
	err = JET_errSuccess;

#ifdef TRACE
	if ( fNewFDP )
		{
//		INT cpg = 0;
//		for ( ; cpg < *pcpgReq + 1; cpg++ )
//			FPrintF2( "get space 1 at %lu from FDP %d.%lu\n", *ppgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
		FPrintF2( "get space %lu at %lu from FDP %d.%lu\n", *pcpgReq + 1, *ppgnoFirst, pfucbTable->dbid, pgnoFDP );
		}
	else
		{
//		INT cpg = 0;
//		for ( ; cpg < *pcpgReq; cpg++ )
//			FPrintF2( "get space 1 at %lu from %d.%lu \n", *ppgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
		FPrintF2( "get space %lu at %lu from %d.%lu\n", *pcpgReq, *ppgnoFirst, pfucbTable->dbid, pgnoFDP );
		}
#endif

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		INT cpg = 0;
		for ( ; cpg < ( fNewFDP ? *pcpgReq + 1 : *pcpgReq ); cpg++ )
			{
			char sz[256];
			sprintf( sz, "ALLOC ONE PAGE (%d:%ld) %d:%ld",
					pfucbTable->dbid, pgnoFDP,
					pfucbTable->dbid, *ppgnoFirst + cpg );
			CallS( ErrLGTrace( pfucb->ppib, sz ) );
			}
		}
#endif

HandleError:
	DIRClose( pfucb );
	return err;
	}

ERR ErrSPGetExt(
	FUCB	*pfucbTable,
	PGNO	pgnoFDP,
	CPG		*pcpgReq,
	CPG		cpgMin,
	PGNO	*ppgnoFirst,
	BOOL	fNewFDP )
	{
	ERR 	err;

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* try to get Ext. If the database file is being extended,
	/* try again until it is done.
	/**/
	while ( ( err = ErrSPIGetExt( pfucbTable,
		pgnoFDP,
		pcpgReq,
		cpgMin,
		ppgnoFirst,
		fNewFDP ) ) == errSPConflict )
		{
		BFSleep( cmsecWaitGeneric );
		}

	LeaveNestableCriticalSection( critSplit );

	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPGetPage
//	========================================================================
//	ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig )
//
//	Allocates page from AvailExt.  If AvailExt is empty, a secondary extent is
//	allocated from the parent FDP to satisfy the page request.  The caller
//	may set the fContig flag to allocate a page following one that has
//	already been allocated.	If the page following the page number given cannot
//	be allocated, the first available page is allocated.
//
//	PARAMETERS	
//		pfucb  		FUCB providing FDP page number and process identifier block
//		ppgnoLast   may contain page number of last allocated page on
//		   			input, on output contains the page number of the allocated page
//		fContig		Various flags:
//		 			VALUE				  MEANING
//			 		========================================
//			 		fTrue		allocate the page following pgnoLast, or if
//			 			   		not available, allocate any page
//			 		fFalse	allocate any available page
//
//	RETURNS		JET_errSuccess, or error code from failing routine, or one
//		   		of the following "local" errors:
// 		-JET_errDiskFull		no space FDP and secondary extent could
// 					   			not be allocated
// 		+errSPNotContig			page allocated does not follow pgnoLast
// 		-errSPSecExtEmpty  		secondary extent in FUCB work area has been
// 	 				   			fully allocated during add of secondary extent to OwnExt
// 	 				   			and AvailExt trees, and page request cannot be satisfied
//								as infinite recursion may result from normal allocation
//
//	FAILS ON	NULL last page pointer
//		invalid FDP page
//		allocating contiguous page to unowned last page
//		allocating contiguous page to unallocated last page
//
//-
ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig )
	{
	ERR		err;
	FUCB 	*pfucbT;
	DIB		dib;
	KEY		key;
	LINE	line;
	CPG		cpgAvailExt;
	PGNO	pgnoAvailLast;

	/*	search for next contiguous page
	/**/
#ifdef DEBUG
	PGNO	pgnoSave = *ppgnoLast;
#endif
	BYTE	rgbKey[sizeof(PGNO)];

	/*	check for valid input
	/**/
	Assert( ppgnoLast != NULL );
	Assert( *ppgnoLast != pgnoNull );
	NotUsed( fContig );
	
	/*	check FUCB work area for active extent and allocate first available
	/*	page of active extent
	/**/
	Assert( pfucb->fExtent != fFreed || pfucb->cpgAvail >= 0 );
	Assert( pfucb->fExtent != fSecondary || pfucb->cpgAvail >= 0 );

	if ( pfucb->fExtent == fSecondary )
		{
		Assert( pfucb->cpgAvail > 0 );

		/*	The following check serves 2 purpose:
		 *	If space to free is 1, then we may use it for new page in avail ext split,
		 *	which then has nothing to insert and BM will clean this page again. This will
		 *	cause infinite loop .
		 *	Also to avoid case where we clean a page and emtpy the page and free this page
		 *	and during freeing, we split in avail extent and try to reuse this page. But
		 *	this page is latched by clean, we may simply allow to write latched page?
		 */
		if ( pfucb->cpgAvail > 1 )
			{
			*ppgnoLast = pfucb->pgnoLast - --pfucb->cpgAvail;
			return JET_errSuccess;
			}
		}

	if ( pfucb->fExtent == fFreed && pfucb->cpgAvail > 0 )
		{
		if ( pfucb->cpgAvail > 1 )
			{
			*ppgnoLast = pfucb->pgnoLast - --pfucb->cpgAvail;
			return JET_errSuccess;
			}
		}

	/* check for valid input when alocating page from FDP
	/**/
#ifdef SPACECHECK
	Assert( !( ErrSPIValidFDP( pfucb->dbid, PgnoFDPOfPfucb( pfucb ), pfucb->ppib ) < 0 ) );
	Assert( !fContig ||
		*ppgnoLast == 0 ||
		( ErrSPIWasAlloc(
			pfucb->ppib,
			pfucb->dbid,
			PgnoFDPOfPfucb( pfucb ),
			*ppgnoLast,
			(CPG) 1 ) == JET_errSuccess )	);
#endif

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallJ( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ), HandleError2 );
	FUCBSetIndex( pfucbT );

SeekNode:
	/*	move to Available extents
	/**/
	DIRGotoAVAILEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

	/* get node of next contiguous page if requested
	/**/
	KeyFromLong( rgbKey, *ppgnoLast );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIRNull;

	if ( ( err = ErrDIRDown( pfucbT, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
#if NoReusePageDuringBackup
Get2ndExt:
#endif
			Assert( pgnoSave == *ppgnoLast );
			while ( ( err = ErrSPIGetSE( pfucbT->ppib,
				pfucbT,
#if NoReusePageDuringBackup
				*ppgnoLast,	/* used if backup is going on */
#else
				pgnoNull,
#endif
				(CPG)1,
				(CPG)1 ) ) == errSPConflict )
				{
				BFSleep( cmsecWaitGeneric );
				}
			Call( err );
			}
		else
			{
			#ifdef DEBUG
				FPrintF2( "ErrSPGetPage could not go down into AvailExt.\n" );
			#endif
			goto HandleError;
			}
		}
#if 0
	else if ( fContig )
		{
		/*	preferentially allocate page of higher page number
		/**/
		if ( err == wrnNDFoundGreater )
			{
			Call( ErrDIRNext( pfucbT, &dib ) );
			}
		else if ( err == wrnNDFoundLess )
			{
			Call( ErrDIRPrev( pfucbT, &dib ) );
			}
		}
#endif
	else
		{
		/*	keep locality of reference
		/*	get closest page to *ppgnoLast
		/**/
		PGNO	pgnoPrev, pgnoNext;
		
		if ( err == wrnNDFoundGreater || err == wrnNDFoundLess )
			{
NextNode:
			err = ErrDIRNext( pfucbT, &dib );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	goto last AvailExt node
				/**/
				DIRUp( pfucbT, 1 );
#if NoReusePageDuringBackup
				/*	Check if backup is in progress. No page that is less than pgnoLast
				 *	should be used, we must get page > pgnoLast.
				 *	So get from secondary extend.
				 */
				if ( fBackupInProgress )
					{
					goto Get2ndExt;
					}
#endif
				dib.pos = posLast;
				dib.pkey = pkeyNil;
				Call( ErrDIRDown( pfucbT, &dib ) );
				goto AllocFirst;
				}
			Call( err );
#if NoReusePageDuringBackup
			/*	if Backup is going on, we can only allocate page > than pgnoLast.
			 */
			if ( fBackupInProgress )
				goto AllocFirst;
#endif
			/*	we are on some extend > *ppgnoLast, put in gpnoNext
			 */
			Assert( pfucbT->keyNode.cb == sizeof( PGNO ) );
			LongFromKey( &pgnoNext, pfucbT->keyNode.pb );

			Assert( pfucbT->lineData.cb == sizeof(PGNO) );
			cpgAvailExt = *(PGNO UNALIGNED *)pfucbT->lineData.pb;
			if ( cpgAvailExt == 0 )
				{
				/*	Skip the 0 sized avail node. Delete current node and try next one.
				 */
				Call( ErrDIRDelete( pfucbT, fDIRNoVersion ) );
				goto NextNode;
				}

			pgnoNext = pgnoNext - cpgAvailExt + 1;
PrevNode:
			err = ErrDIRPrev( pfucbT, &dib );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	goto last AvailExt node
				/**/
				DIRUp( pfucbT, 1 );
				
				dib.pos = posFirst;
				dib.pkey = pkeyNil;
				Call( ErrDIRDown( pfucbT, &dib ) );
				goto AllocFirst;
				}

			Call( err );

			/*	we are on some extend < *ppgnoLast, put in gpnoPrev
			 */
			Assert( pfucbT->keyNode.cb == sizeof( PGNO ) );
			LongFromKey( &pgnoPrev, pfucbT->keyNode.pb );

			Assert( pfucbT->lineData.cb == sizeof(PGNO) );
			cpgAvailExt = *(PGNO UNALIGNED *)pfucbT->lineData.pb;
			if ( cpgAvailExt == 0 )
				{
				/*	Skip the 0 sized avail node. Delete current node and try next one.
				 */
				Call( ErrDIRDelete( pfucbT, fDIRNoVersion ) );
				goto PrevNode;
				}

			pgnoPrev = pgnoPrev - cpgAvailExt + 1;

			Assert( *ppgnoLast == pgnoSave );
			if ( absdiff( pgnoPrev, *ppgnoLast ) < absdiff( *ppgnoLast, pgnoNext ) )
				{
				/*	pgnoPrev is closer
				/**/
				goto AllocFirst;
				}
				
			Call( ErrDIRNext( pfucbT, &dib ) );
			goto AllocFirst;
			}
		else
			{
			Assert( fFalse );
			}
		}

	/* allocate first page in node and return code
	/**/
AllocFirst:
	Assert( !( err < 0 ) );
	Assert( pfucbT->lineData.cb == sizeof(PGNO) );
	cpgAvailExt = *(PGNO UNALIGNED *)pfucbT->lineData.pb;
	if ( cpgAvailExt == 0 )
		{
		/*	Skip the 0 sized avail node. Delete current node and try next one.
		 */
		Call( ErrDIRDelete( pfucbT, fDIRNoVersion ) );
		DIRUp( pfucbT, 1 );
		goto SeekNode;
		}

	Assert( pfucbT->keyNode.cb == sizeof( PGNO ) );
	LongFromKey( &pgnoAvailLast, pfucbT->keyNode.pb );

	*ppgnoLast = pgnoAvailLast - cpgAvailExt + 1;

	/*	do not return the same page
	/**/
	Assert( *ppgnoLast != pgnoSave );

	if ( --cpgAvailExt == 0 )
		{
		Call( ErrDIRDelete( pfucbT, fDIRNoVersion ) );
		}
	else
		{
		line.cb = sizeof(PGNO);
		line.pb = (BYTE *)&cpgAvailExt;
		Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
		}

	err = JET_errSuccess;
//	if ( fContig && *ppgnoLast != pgnoSave + 1 )
//		err = errSPNotContig;

#ifdef TRACE
	FPrintF2( "get space 1 at %lu from %d.%lu\n", *ppgnoLast, pfucb->dbid, PgnoFDPOfPfucb( pfucb ) );
#endif

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		char sz[256];
		sprintf( sz, "ALLOC ONE PAGE (%d:%ld) %d:%ld",
				pfucb->dbid, pfucb->u.pfcb->pgnoFDP,
				pfucb->dbid, *ppgnoLast );
		CallS( ErrLGTrace( pfucb->ppib, sz ) );
		}
#endif

HandleError:
	DIRClose( pfucbT );
	
HandleError2:
	LeaveNestableCriticalSection( critSplit );
	
	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPFreeExt
//	========================================================================
//	ERR ErrSPFreeExt( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
//
//	Frees an extent to an FDP.	The extent, starting at page pgnoFirst
//	and cpgSize pages long, is added to AvailExt of the FDP.  If the
//	extent freed is a complete secondary extent of the FDP, or can be
//	coalesced with other available extents to form a complete secondary
//	extent, the complete secondary extent is freed to the parent FDP.
//
//	PARAMETERS	ppib			process identifier block of user process
// 				pgnoFDP			page number of FDP extent is to be freed
// 				pgnoFirst  		page number of first page in extent to be freed
// 				cpgSize			number of pages in extent to be freed
//
//	RETURNS		JET_errSuccess, or error code from failing routine.
//
//	FAILS ON	invalid FDP page
//			   	extent to be freed not fully owned by FDP
//			   	extent to be freed not fully allocated from FDP
//
//
//	SIDE EFFECTS
//	COMMENTS
//-
INLINE LOCAL VOID SPDeferFreeExt( FUCB *pfucbTable, PGNO pgnoFDP, PGNO pgnoChildFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR			err;
	VEREXT		verext;

	Assert( pgnoFDP != pgnoChildFDP );
	Assert( pgnoFDP != pgnoFirst );
	verext.pgnoFDP = pgnoFDP;
	verext.pgnoChildFDP = pgnoChildFDP;
	verext.pgnoFirst = pgnoFirst;
	verext.cpgSize = cpgSize;

	forever
		{
		err = ErrVERFlag( pfucbTable,
			operDeferFreeExt,
			&verext,
			sizeof(verext) );
		if ( err != errDIRNotSynchronous )
			break;
		BFSleep( cmsecWaitGeneric );
		}

	/*	we may lose space due to an error, but will retry until
	/*	error occurs.
	/**/
	Assert( err != errDIRNotSynchronous );

	return;
	}


ERR ErrSPFreeExt( FUCB *pfucbTable, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR		err;
	PGNO  	pgnoLast = pgnoFirst + cpgSize - 1;

	/* FDP AvailExt and OwnExt operation variables
	/**/
	FUCB 	*pfucb;
	DIB 	dib;
	KEY 	key;
	LINE 	line;

	/* owned extent and avail extent variables
	/**/
	PGNO	pgnoOELast;
	CPG		cpgOESize;
	PGNO	pgnoAELast;
	CPG		cpgAESize;

	/* recursive free to parent FDP variables
	/**/
	PGNO	pgnoParentFDP;
	BYTE	rgbKey[sizeof(PGNO)];
	
	/* check for valid input
	/**/
	Assert( cpgSize > 0 && cpgSize < ( 1L<<18 ) );
#ifdef SPACECHECK
	Assert( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) == JET_errSuccess );
	Assert( ErrSPIWasAlloc( pfucbTable->ppib, pfucbTable->dbid, pgnoFDP, pgnoFirst, cpgSize ) == JET_errSuccess );
#endif

	MPLPurgePgno( pfucbTable->dbid, pgnoFirst, pgnoLast );
	
#ifdef DEBUG
	if ( pfucbTable->ppib != ppibBMClean )
		AssertNotInMPL( pfucbTable->dbid, pgnoFirst, pgnoLast );
#endif

	/*	to avoid redundantly freeing space when split frees unneeded pages, short circuit pages
	/*	allocate from FUCB page cache back to FUCB page cache.
	/**/
	if ( ( pfucbTable->fExtent == fFreed || pfucbTable->fExtent == fSecondary ) &&
		cpgSize == 1 &&
		pgnoFirst == pfucbTable->pgnoLast - pfucbTable->cpgAvail )
		{
		++pfucbTable->cpgAvail;
		return JET_errSuccess;
		}
	
	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/*	make temporary cursor for parent FDP
	/**/
	CallJ( ErrDIROpen( pfucbTable->ppib,
		PgnoFDPOfPfucb( pfucbTable ) == pgnoFDP ?
			pfucbTable->u.pfcb :
			PfcbFCBGet( pfucbTable->dbid, pgnoFDP ), 0, &pfucb ),
		HandleError2 );
	Assert( PgnoFDPOfPfucb( pfucb ) == pgnoFDP );
	FUCBSetIndex( pfucb );

	/*	move to Owned extents
	/**/
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

	/*	find bounds of owned extent which contains the extent to be freed
	/**/
	KeyFromLong( rgbKey, pgnoFirst );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof(PGNO) );
	LongFromKey( &pgnoOELast, pfucb->keyNode.pb );
	Assert( pfucb->lineData.cb == sizeof(PGNO) );
	cpgOESize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
	DIRUp( pfucb, 1 );

	/*	if AvailExt empty, add extent to be freed.	Otherwise, coalesce with
	/*	left extents by deleting left extents and augmenting size.	Coalesce
	/*	right extent replacing size of right extent.  Otherwise add extent.
	/*	Record parent page number for use later with secondary extent free to
	/*	parent.
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	pgnoParentFDP = *(PGNO UNALIGNED *)pfucb->lineData.pb;

	KeyFromLong( rgbKey, pgnoFirst - 1 );
	Assert( key.cb == sizeof(PGNO) );
	Assert( key.pb == (BYTE *)rgbKey );
	Assert( dib.pos == posDown );
	Assert( dib.pkey == (KEY *)&key );
	Assert( dib.fFlags == fDIRNull );

SeekNode:
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
			Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
			}
		else
			{
			#ifdef DEBUG
				FPrintF2( "ErrSPFreeExt could not go down into nonempty AvailExt.\n" );
			#endif
			goto HandleError;
			}
		}
	else
		{
		cpgAESize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
		if ( cpgAESize == 0 )
			{
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			DIRUp( pfucb, 1 );
			goto SeekNode;
			}

		if ( pgnoFirst > pgnoOELast - cpgOESize + 1 && err == JET_errSuccess )
			{
			cpgAESize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
			cpgSize += cpgAESize;
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			}
NextNode:
		err = ErrDIRNext( pfucb, &dib );
		if ( err >= 0 )
			{
			cpgAESize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
			if ( cpgAESize == 0 )
				{
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
				goto NextNode;
				}
			LongFromKey( &pgnoAELast, pfucb->keyNode.pb );
			if ( pgnoLast == pgnoAELast - cpgAESize && pgnoAELast <= pgnoOELast )
				{
				CPG		cpgT = cpgAESize + cpgSize;
				line.pb = (BYTE *)&cpgT;
				line.cb = sizeof(PGNO);
				Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
				}
			else
				{
				DIRUp( pfucb, 1 );
				Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
				}
			}
		else
			{
			if ( err != JET_errNoCurrentRecord )
				goto HandleError;
			DIRUp( pfucb, 1 );
			Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
			}
		}

	/*	if extent freed coalesced with available extents within the same
	/*	owned extent form a complete secondary extent, remove the secondary
	/*	extent from the FDP and free it to the parent FDP.	Since FDP is
	/*	first page of primary extent, do not have to guard against freeing
	/*	primary extents.  If parent FDP is NULL, FDP is device level and
	/*	complete secondary extents are freed to device.
	/**/

	LongFromKey( &pgnoAELast, pfucb->keyNode.pb );
	cpgAESize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
	if ( pgnoAELast == pgnoOELast && cpgAESize == cpgOESize )
		{
		FCB		*pfcbT;
		FCB		*pfcbParentT;
		FCB		*pfcbTableT;
		
		if ( pgnoParentFDP == pgnoNull )
			{
			//	UNDONE:	free secondary extents to device
			}
		else
			{
			/*	parent must always be in memory
			/**/
			pfcbT = pfucbTable->u.pfcb;
			pfcbTableT = pfcbT->pfcbTable == pfcbNil ? pfcbT : pfcbT->pfcbTable;

			pfcbParentT = PfcbFCBGet( pfucbTable->dbid, pgnoParentFDP );
			Assert( pfcbT != pfcbNil && pfcbParentT != pfcbNil );

			/*	note that we cannot free space to parent FDP if current FDP
			/*	is pending deletion since this space has already been defer
			/*	freed.
			/**/
			if ( !FFCBDeletePending( pfcbT ) &&
				 !FFCBDeletePending( pfcbParentT ) &&
				 !FFCBDeletePending( pfcbTableT ) &&
				 !FFCBWriteLatch( pfcbTableT, pfucbTable->ppib ) &&
				 !FFCBWriteLatch( pfcbParentT, pfucbTable->ppib ) )
				{
				/*	CONSIDER: using different latches to block only delete-table/index
				/*	and not other DDL
				/**/
				
				/*	block delete table
				/**/
				FCBSetReadLatch( pfcbTableT );
				FCBSetReadLatch( pfcbParentT );
				Assert( !FFCBWriteLatch( pfcbT, pfucbTable->ppib ) );
				
				CallJ( ErrDIRDelete( pfucb, fDIRNoVersion ), ResetReadLatch );
				DIRUp( pfucb, 1 );
				DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
				KeyFromLong( rgbKey, pgnoOELast );
				Assert( key.cb == sizeof(PGNO) );
				Assert( key.pb == (BYTE *)rgbKey );
				Assert( dib.pos == posDown );
				Assert( dib.pkey == (KEY *)&key );
				Assert( dib.fFlags == fDIRNull );
				CallJ( ErrDIRDown( pfucb, &dib ), ResetReadLatch );
				Assert( err == JET_errSuccess );
				CallJ( ErrDIRDelete( pfucb, fDIRNoVersion ), ResetReadLatch );

				CallJ( ErrSPFreeExt( pfucbTable, pgnoParentFDP, pgnoAELast-cpgAESize+1, cpgAESize ),
					   ResetReadLatch );

ResetReadLatch:
				FCBResetReadLatch( pfcbTableT );
				FCBResetReadLatch( pfcbParentT );
				Call( err );
				}
			}
		}

HandleError:
	DIRClose( pfucb );

#ifdef TRACE
//		{
//		INT cpg = 0;
//
//		Assert( err >= 0 );
//		for ( ; cpg < cpgSize; cpg++ )
//			FPrintF2( "free space 1 at %lu to FDP %d.%lu\n", pgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
//		}
	FPrintF2( "free space %lu at %lu to FDP %d.%lu\n", cpgSize, pgnoFirst, pfucbTable->dbid, pgnoFDP );
#endif

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		INT cpg = 0;

		Assert( err >= 0 );
		for ( ; cpg < cpgSize; cpg++ )
			{
			char sz[256];
			sprintf( sz, "FREE (%d:%ld) %d:%ld",
					pfucbTable->dbid, pgnoFDP,
					pfucbTable->dbid, pgnoFirst + cpg );
			CallS( ErrLGTrace( pfucbTable->ppib, sz ) );
			}
		}
#endif

	Assert( err != JET_errKeyDuplicate );

HandleError2:
	LeaveNestableCriticalSection( critSplit );

	return err;
	}


//+api--------------------------------------------------------------------------
// ErrSPFreeFDP
// ========================================================================
// ERR ErrSPFreeFDP( FUCB *pfucbTable, PGNO pgnoFDP )
//
//	Frees all owned extents of an FDP to its parent FDP.  The FDP page is freed
//	with the owned extents to the parent FDP.
//
// PARAMETERS  	pfucbTable		table file use currency block
//				pgnoFDP			page number of FDP to be freed
//
//
// RETURNS
//		JET_errSuccess, or error code from failing routine, or one
//		of the following "local" errors:
//
// SIDE EFFECTS
// COMMENTS
//-
ERR ErrSPFreeFDP( FUCB *pfucbTable, PGNO pgnoFDP )
	{
	ERR			err;
	FUCB  		*pfucb = pfucbNil;
	DIB			dib;
	PGNO  		pgnoParentFDP;
	CPG			cpgSize;
	PGNO  		pgnoLast;
	PGNO  		pgnoFirst;
	PGNO		pgnoPrimary = pgnoNull;
	CPG			cpgPrimary = 0;

	/* check for valid parameters.
	/**/
#ifdef SPACECHECK
	Assert( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) == JET_errSuccess );
	Assert( ErrSPIWasAlloc( pfucbTable->ppib, pfucbTable->dbid, pgnoFDP, pgnoFDP, ( CPG ) 1 ) == JET_errSuccess );
#endif

#ifdef TRACE
	FPrintF2( "free space FDP at %d.%lu\n", pfucbTable->dbid, pgnoFDP );
#endif
	
#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		char sz[256];

		sprintf( sz, "FREE FDP (%d:%ld)", pfucbTable->dbid, pgnoFDP );
		CallS( ErrLGTrace( pfucbTable->ppib, sz ) );
		}
#endif

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallJ( ErrDIROpen( pfucbTable->ppib, pfucbTable->u.pfcb, 0, &pfucb ),
			HandleError2 );
	FUCBSetIndex( pfucb );

	/*	move to Available extents.
	/**/
	DIRGotoAVAILEXT( pfucb, pgnoFDP );

	/*	Get page number of parent FDP, to which all owned extents will be
	/*	freed.	If the parent FDP is Null, the FDP to be freed is the device
	/*	level FDP which cannot be freed.
	/**/
	Call( ErrDIRGet( pfucb ) );
	pgnoParentFDP = *(PGNO UNALIGNED *)pfucb->lineData.pb;
	Assert( pgnoParentFDP != pgnoNull );

	/*	go down to first owned extent.	Free each extent in OwnExt to the
	/*	the parent FDP.
	/**/
	DIRGotoOWNEXT( pfucb, pgnoFDP );
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	Assert( err == JET_errSuccess );
	do {
		cpgSize = *(PGNO UNALIGNED *)pfucb->lineData.pb;
		if ( cpgSize == 0 )
			{
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			goto NextNode;
			}
			
		LongFromKey( &pgnoLast, pfucb->keyNode.pb );
		pgnoFirst = pgnoLast - cpgSize + 1;

		if ( pgnoFirst == pgnoFDP )
			{
			pgnoPrimary = pgnoFirst;
			cpgPrimary = cpgSize;
			}
		else
			{
			SPDeferFreeExt( pfucbTable, pgnoParentFDP, pgnoPrimary, pgnoFirst, cpgSize );
			}
NextNode:
		err = ErrDIRNext( pfucb, &dib );
		}
	while ( err >= 0 );
	if ( err != JET_errNoCurrentRecord )
		{
		Assert( err < 0 );
		goto HandleError;
		}

	/*	defer free primary extent must be last, so that
	/*	RCECleanUp does not free FCB until all extents
	/*	cleaned.  Pass pgnoFDP with primary extent to have
	/*	FCB flushed.
	/**/
	Assert( pgnoPrimary != pgnoNull );
	Assert( cpgPrimary != 0 );
	SPDeferFreeExt( pfucbTable, pgnoParentFDP, pgnoFDP, pgnoPrimary, cpgPrimary );

	/* UNDONE: either each OWNEXT node should be deleted (and logged)
	/* prior to releasing to father FDP, or the son FDP pointer node
	/* should be deleted. We risk having it marked deleted in father but
	/* still present in son.
	/**/

	err = JET_errSuccess;

HandleError:
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	
HandleError2:
	LeaveNestableCriticalSection( critSplit );
	
	return err;
	}


LOCAL ERR ErrSPIAddExt( FUCB *pfucb, PGNO pgnoLast, CPG *pcpgSize, const INT fExtent )
	{
	ERR		err;
	KEY		key;
	LINE	line;
	BYTE	rgbKey[sizeof(PGNO)];
	CPG		cpgAESizeCoalesce;

#ifdef TRACE
//	{
//	INT cpg = 0;
//	for ( ; cpg < *pcpgSize; cpg++ )
//		FPrintF2( "add space 1 at %lu to FDP %d.%lu\n", pgnoLast - *pcpgSize + 1 + cpg, pfucb->dbid, pfucb->u.pfcb->pgnoFDP );
//	}
	FPrintF2( "add space %lu at %lu to FDP %d.%lu\n", *pcpgSize, pgnoLast - *pcpgSize + 1, pfucb->dbid, pfucb->u.pfcb->pgnoFDP );
#endif
	
#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		INT cpg = 0;
		for ( ; cpg < *pcpgSize; cpg++ )
			{
			char sz[256];
			sprintf( sz, "ALLOC ONE PAGE (%d:%ld) %d:%ld",
					pfucb->dbid, pfucb->u.pfcb->pgnoFDP,
					pfucb->dbid, pgnoLast - *pcpgSize + 1 + cpg );
			CallS( ErrLGTrace( pfucb->ppib, sz ) );
			}
		}
#endif

	AssertCriticalSection( critSplit );

	pfucb->fExtent = fExtent;
	pfucb->pgnoLast = pgnoLast;
	pfucb->cpgAvail = *pcpgSize;
	cpgAESizeCoalesce = 0;

	KeyFromLong( rgbKey, pgnoLast );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	line.cb = sizeof(PGNO);

	/* if this is a secondary extent, insert the new extent into OWNEXT and
	/* AVAILEXT, coalescing with an existing extent to the right, if possible.
	/**/
	if ( fExtent == fSecondary )
		{
		BYTE	rgbKeySeek[sizeof( PGNO )];
		KEY		keySeek;
		DIB		dib;
		CPG		cpgOESize;

		/*	Set up general variables for coalescing.
		 */
		keySeek.cb	= sizeof( PGNO );
		keySeek.pb	= (BYTE *) rgbKeySeek;

		/*	Set up seek key, default own extent size, and line.pb to OwnExt Size.
		 */
		KeyFromLong( rgbKeySeek, pgnoLast - *pcpgSize );
		cpgOESize = *pcpgSize;
		line.pb = (BYTE *) &cpgOESize;

		DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

		/*	Coalecing OWNEXT only for database without log on. We may not
		 *	be able to recover the following operations, so we only
		 *	coalecing the database without log.
		 */

		if ( !FDBIDLogOn( pfucb->dbid ) )
			{
#ifdef DEBUG
			PGNO	pgnoOELast;
#endif

			/* look for extent that ends at pgnoLast - *pcpgSize, the only extent we can
			/* coalesce with
			/**/
			dib.pos		= posDown;
			dib.pkey	= &keySeek;
			dib.fFlags	= fDIRNull;
			err = ErrDIRDown( pfucb, &dib );

			/*  we found a match, so get the old extent's size, delete the old extent,
			/*  and add it's size to the new extent to insert
			/**/
			if ( err == JET_errSuccess )
				{
				CPG		cpgOESizeCoalesce;

				Assert( pfucb->keyNode.cb == sizeof(PGNO) );
#ifdef DEBUG
				LongFromKey( &pgnoOELast, pfucb->keyNode.pb );
#endif
				Assert( pgnoOELast == pgnoLast - *pcpgSize );
				Assert( pfucb->lineData.cb == sizeof(PGNO) );
				cpgOESizeCoalesce = *(PGNO UNALIGNED *)pfucb->lineData.pb;
			
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			
				cpgOESize += cpgOESizeCoalesce;
				DIRUp( pfucb, 1 );
				}
			else if ( err > 0 )
				{
				DIRUp( pfucb, 1 );
				}
			}

		/*  add new extent to OWNEXT
		/**/
		Assert( line.pb == (BYTE *) &cpgOESize );
		Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

		/*	Set up seek key, line.pb to Avail Size.
		 *	Note the real avail ext size is in pfucb->cpgAvail.
		 */
		KeyFromLong( rgbKeySeek, pgnoLast - pfucb->cpgAvail );
//		line.pb = (BYTE *) &pfucb->cpgAvail;

		/*  Goto AVAILEXT
		/**/
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

		if ( !FDBIDLogOn( pfucb->dbid ) )
			{
			/* look for extent that ends at pgnoLast - pfucb->cpgAvail, the only extent we can
			/* coalesce with
			/**/
			dib.pos		= posDown;
			dib.pkey	= &keySeek;
			dib.fFlags	= fDIRNull;
			err = ErrDIRDown( pfucb, &dib );

			/*  we found a match, so get the old extent's size, delete the old extent,
			/*  and add it's size to the new extent to insert
			/**/

			cpgAESizeCoalesce = 0;

			if ( err == JET_errSuccess )
				{
#ifdef DEBUG
				PGNO	pgnoAELast;

				Assert( pfucb->keyNode.cb == sizeof(PGNO) );
				LongFromKey( &pgnoAELast, pfucb->keyNode.pb );
#endif
				Assert( pgnoAELast == pgnoLast - *pcpgSize );
				Assert( pfucb->lineData.cb == sizeof(PGNO) );
				cpgAESizeCoalesce = *(PGNO UNALIGNED *)pfucb->lineData.pb;
			
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			
				pfucb->cpgAvail += cpgAESizeCoalesce;

				DIRUp( pfucb, 1 );
				}
			else if ( err > 0 )
				{
				DIRUp( pfucb, 1 );
				}
			}
		}

	/*  add new extent to AVAILEXT. Set to 0 and then correct it later.
	 *	Need to do insert first to guarrantee that when crash, we will
	 *	have a consistent space tree. We may loose space after recover.
	 */
		{
		LINE lineSize0;
		PGNO pgno0 = 0;

		lineSize0.pb = (BYTE *) &pgno0;
		lineSize0.cb = sizeof(PGNO);
	
		Call( ErrDIRInsert( pfucb, &lineSize0, &key, fDIRNoVersion | fDIRSpace ) );
		}

	Call( ErrDIRGet( pfucb ) );

	/* correct page count with remaining number of pages
	/**/
	if ( pfucb->cpgAvail == 0 )
		{
		Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
		}
	else
		{
		/*	no page used during DIRInsert above, or used but still
		 *	some page left.
		 */
		Assert( pfucb->cpgAvail == *pcpgSize + cpgAESizeCoalesce ||
				pfucb->cpgAvail > 0 );
		Assert( line.cb == sizeof(PGNO) );
		line.pb = (BYTE *)&pfucb->cpgAvail;
		Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
		Call( ErrDIRGet( pfucb ) );
		}

	*pcpgSize = pfucb->cpgAvail;

HandleError:
	/* return fExtent to initial fNone value.	Only necessary for
	/*	path GetPage GetSE as in all other cases fucb is temporary and
	/*	released before subsequent space allocating DIR call.
	/**/
	pfucb->fExtent = fNone;
	return err;
	}


LOCAL ERR ErrSPIGetSE(
			PIB *ppib,
			FUCB *pfucb,
			PGNO pgnoFirst,
			CPG const cpgReq,
			CPG const cpgMin )
	{
	ERR		err;
	PGNO   	pgnoParentFDP;
	CPG		cpgPrimary;
	PGNO   	pgnoSEFirst;
	PGNO   	pgnoSELast;
	CPG		cpgOwned;
	CPG		cpgSEReq;
	CPG		cpgSEMin;
	CPG		cpgAvailExt;
	DIB		dib;
	BOOL   	fBeingExtend;
	BOOL   	fDBIDExtendingDB = fFalse;

	AssertCriticalSection( critSplit );
	
	/*	get parent FDP page number
	/*	should be at head of AvailExt
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	pgnoParentFDP = *(PGNO UNALIGNED *)pfucb->lineData.pb;

	/* store primary extent size
	/**/
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	cpgPrimary = *(UNALIGNED PGNO *)pfucb->lineData.pb;

	/*	pages of allocated extent may be used to split Owned extents and
	/*	AVAILEXT trees.  If this happens, then subsequent added
	/*	extent will not have to split and will be able to satisfy
	/*	requested allocation.
	/**/

	if ( pgnoParentFDP != pgnoNull )
		{
		/*  determine if this FDP owns a lot of space
		/*  (hopefully will only walk OWNEXT root page)
		/**/
		dib.pos = posFirst;
		dib.fFlags = fDIRNull;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
			{
			Assert( err != JET_errNoCurrentRecord );
			Assert( err != JET_errRecordNotFound );
			goto HandleError;
			}

		Assert( dib.fFlags == fDIRNull );
		cpgOwned = 0;
		do	{
			CPG cpgAvail = *(PGNO UNALIGNED *)pfucb->lineData.pb;

			Assert( pfucb->lineData.cb == sizeof( PGNO ) );
			if ( cpgAvail == 0 )
				{
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
				}
			else
				{
				cpgOwned += cpgAvail;
				}
			err = ErrDIRNext( pfucb, &dib );
			}
		while ( err >= 0 && cpgOwned <= cpgSmallFDP );

		if ( err < 0 && err != JET_errNoCurrentRecord )
			goto HandleError;

		DIRUp( pfucb, 1 );
		
		Assert( cpgOwned > 0 );

		/*  if this FDP owns a lot of space, allocate a fraction of the primary
		/*  extent (or more if requested), but at least a given minimum amount
		/**/
		if ( cpgOwned > cpgSmallFDP )
			{
			cpgSEMin = max( cpgMin, cpageSEDefault );
			cpgSEReq = max( cpgReq, max( cpgPrimary/cSecFrac, cpgSEMin ) );
			}

		/*  if this FDP owns just a little space, add a very small constant amount
		/*  of space (or more if requested) in order to optimize space allocation
		/*  for small tables, indexes, etc.
		/**/
		else
			{
			cpgSEMin = max( cpgMin, cpgSmallGrow );
			cpgSEReq = max( cpgReq, cpgSEMin );
			}
		
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		forever
			{
			cpgAvailExt = cpgSEReq;
		
			/* try to get Ext. If the database file is being extended,
			/* try again until it is done.
			/**/
			pgnoSEFirst = pgnoFirst;
			while ( ( err = ErrSPIGetExt( pfucb,
				pgnoParentFDP,
				&cpgAvailExt,
				cpgSEMin,
				&pgnoSEFirst,
				0 ) ) == errSPConflict )
				{
				BFSleep( cmsecWaitGeneric );
				}
			Call( err );

			pgnoSELast = pgnoSEFirst + cpgAvailExt - 1;
			Call( ErrSPIAddExt( pfucb, pgnoSELast, &cpgAvailExt, fSecondary ));

			if ( cpgAvailExt >= cpgMin )
				{
				goto HandleError;
				}

			/* move to head of Avail/Own Ext trees for next insert
			/**/
			DIRUp( pfucb, 1 );
			}
		}
	else
		{
		/*	allocate a secondary extent from the operating system
		/*	by getting page number of last owned page, extending the
		/*	file as possible and adding the sized secondary extent
		/*	NOTE: only one user can do this at one time. Protect it
		/*	NOTE: with critical section.
		/**/
		
		if ( pfucb->dbid == dbidTemp )
			cpgSEMin = max( cpgMin, cpageSEDefault );
		else			
			cpgSEMin = max( cpgMin, cpgSESysMin );

		cpgSEReq = max( cpgReq, max( cpgPrimary/cSecFrac, cpgSEMin ) );
		
		EnterCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		if ( FDBIDExtendingDB( pfucb->dbid ) )
			{
			fBeingExtend = fTrue;
			}
		else
			{
			DBIDSetExtendingDB( pfucb->dbid );
			fDBIDExtendingDB = fTrue;
			fBeingExtend = fFalse;
			}
		LeaveCriticalSection( rgfmp[pfucb->dbid].critExtendDB );

		if ( fBeingExtend )
			{
			Error( ErrERRCheck( errSPConflict ), HandleError );
			}

		dib.pos = posLast;
		dib.fFlags = fDIRNull;
		Call( ErrDIRDown( pfucb, &dib ) );
		Assert( pfucb->keyNode.cb == sizeof( PGNO ) );
		LongFromKey( &pgnoSELast, pfucb->keyNode.pb );
		DIRUp( pfucb, 1 );

		/*	allocate more space from device.
		/**/
		if ( pgnoSELast + cpgSEMin > pgnoSysMax )
			{
			err = ErrERRCheck( JET_errOutOfDatabaseSpace );
			goto HandleError;
			}
		cpgSEReq = min( cpgSEReq, (CPG)(pgnoSysMax - pgnoSELast) );
		Assert( pfucb->dbid == dbidTemp || cpgSEMin <= cpgSEReq && cpgSEMin >= cpgSESysMin );

		err = ErrIONewSize( pfucb->dbid, pgnoSELast + cpgSEReq + cpageDBReserved );
		if ( err < 0 )
			{
			Call( ErrIONewSize( pfucb->dbid, pgnoSELast + cpgSEMin + cpageDBReserved ) );
			//	UNDONE:	reorganize code to IO routine
			rgfmp[pfucb->dbid].ulFileSizeLow = (pgnoSELast + cpgSEMin ) << 12;
			rgfmp[pfucb->dbid].ulFileSizeHigh = (pgnoSELast + cpgSEMin ) >> 20;
			cpgSEReq = cpgSEMin;
			}
		else
			{
			//	UNDONE:	reorganize code to IO routine
			rgfmp[pfucb->dbid].ulFileSizeLow = (pgnoSELast + cpgSEReq ) << 12;
			rgfmp[pfucb->dbid].ulFileSizeHigh = (pgnoSELast + cpgSEReq ) >> 20;
			}

		/* calculate last page of device level secondary extent
		/**/
		pgnoSELast += cpgSEReq;
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

		/*	allocation may not satisfy requested allocation if Owned extents
		/*	or AVAILEXT had to be split during the extent insertion.  As
		/*	a result, we may have to allocate more than one secondary
		/*	extent for a given space requirement.
		/**/
		err = ErrSPIAddExt( pfucb, pgnoSELast, &cpgSEReq, fSecondary );
		}

HandleError:
	if ( fDBIDExtendingDB )
		{
		EnterCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		Assert( FDBIDExtendingDB( pfucb->dbid ) );
		DBIDResetExtendingDB( pfucb->dbid );
		LeaveCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		}
	return err;
	}


#ifdef SPACECHECK

LOCAL ERR ErrSPIValidFDP( DBID dbid, PGNO pgnoFDP, PIB *ppib )
	{
	ERR		err;
	FUCB	*pfucb = pfucbNil;
	DIB		dib;
	KEY		keyFDPPage;
	PGNO	pgnoOELast;
	CPG		cpgOESize;
	BYTE	rgbKey[sizeof(PGNO)];

	Assert( pgnoFDP != pgnoNull );

	/*	get temporary FUCB, set currency pointers to OwnExt and use to
	/*	search OwnExt for pgnoFDP
	/**/
	Call( ErrDIROpen( ppib, PfcbFCBGet( dbid, pgnoFDP ), dbid, &pfucb ) );
	DIRGotoOWNEXT( pfucb, pgnoFDP );

	/* validate head of OwnExt
	/**/
	Call( ErrDIRGet( pfucb ) );
	Assert( pfucb->keyNode.cb == ( *( (KEY *) pkeyOwnExt ) ).cb &&
		memcmp( pfucb->keyNode.pb, ((KEY *) pkeyOwnExt)->pb, pfucb->keyNode.cb ) == 0 );

	/* search for pgnoFDP in OwnExt tree
	/**/
	KeyFromLong( rgbKey, pgnoFDP );
	keyFDPPage.pb = (BYTE *)rgbKey;
	keyFDPPage.cb = sizeof(PGNO);
	dib.pos = posDown;
	dib.pkey = &keyFDPPage;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof( PGNO ) );
	LongFromKey( &pgnoOELast, pfucb->keyNode.pb );

	Assert( pfucb->lineData.cb == sizeof(PGNO) );
	cpgOESize = *(UNALIGNED PGNO *)pfucb->lineData.pb;

	/* FDP page should be first page of primary extent
	/**/
	Assert( pgnoFDP == pgnoOELast - cpgOESize + 1 );

HandleError:
	DIRClose( pfucb );
	return JET_errSuccess;
	}


LOCAL ERR ErrSPIWasAlloc( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR		err;
	FUCB	*pfucb;
	DIB		dib;
	KEY		key;
	PGNO	pgnoOwnLast;
	CPG		cpgOwnExt;
	PGNO	pgnoAvailLast;
	CPG  	cpgAvailExt;
	BYTE	rgbKey[sizeof(PGNO)];

	/*	get temporary FUCB, setup and use to search AvailExt for page
	/**/
	pfucb = pfucbNil;
	Call( ErrDIROpen( ppib, PfcbFCBGet( dbid, pgnoFDP ), 0, &pfucb ) );
	DIRGotoOWNEXT( pfucb, pgnoFDP );

	/*	check that the given extent is owned by the given FDP but not
	/*	available in the FDP AvailExt.
	/**/
	KeyFromLong( rgbKey, pgnoFirst + cpgSize - 1 );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIRNull;
	Assert( PcsrCurrent( pfucb )->itag == itagOWNEXT );
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof(PGNO) );
	LongFromKey( &pgnoOwnLast, pfucb->keyNode.pb );
	Assert( pfucb->lineData.cb == sizeof(PGNO) );
	cpgOwnExt = *(UNALIGNED PGNO *)pfucb->lineData.pb;
	Assert( pgnoFirst >= pgnoOwnLast - cpgOwnExt + 1 );
	DIRUp( pfucb, 1 );

	/* check that the extent is not still in AvailExt.  Since the DIR search
		is keyed with the last page of the extent to be freed, it is sufficient
		to check that the last page of the extent to be freed is in the found
		extent to determine the full extent has not been allocated.  Since that
		last page of the extent should not be the key of a tree node, csrstat
		correction may be required after the search via Next.  If AvailExt is
		empty then the extent cannot be in AvailExt and has been allocated.
		*/
	DIRGotoAVAILEXT( pfucb, pgnoFDP );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto CleanUp;
			}
		goto HandleError;
		}
	if ( err == wrnNDFoundGreater )
		{
NextNode:
		Call( ErrDIRNext( pfucb, &dib ) );

		Assert( pfucb->keyNode.cb == sizeof(PGNO) );
		LongFromKey( &pgnoAvailLast, pfucb->keyNode.pb );
		Assert( pfucb->lineData.cb == sizeof(PGNO) );
		cpgAvailExt = *(UNALIGNED PGNO *)pfucb->lineData.pb;
		if ( cpgAvailExt == 0 )
			{
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			goto NextNode;
			}
		else
			Assert( pgnoFirst + cpgSize - 1 < pgnoAvailLast - cpgAvailExt + 1 );
		}
HandleError:
CleanUp:
	DIRClose( pfucb );
	return JET_errSuccess;
	}

#endif


// Check that the buffer passed to ErrSPGetInfo() is big enough to accommodate
// the information requested
INLINE LOCAL ERR ErrSPCheckInfoBuf( INT cbBufSize, BYTE fSPExtents )
	{
	INT cbUnchecked = cbBufSize;

	if ( FSPOwnedExtent( fSPExtents ) )
		{
		if ( cbUnchecked < sizeof(CPG) )
			{
			return ErrERRCheck( JET_errBufferTooSmall );
			}
		cbUnchecked -= sizeof(CPG);

		// If list needed, ensure enough space for list sentinel.
		if ( FSPExtentLists( fSPExtents ) )
			{
			if ( cbUnchecked < sizeof(EXTENTINFO) )
				{
				return ErrERRCheck( JET_errBufferTooSmall );
				}
			cbUnchecked -= sizeof(EXTENTINFO);
			}
		}

	if ( FSPAvailExtent( fSPExtents ) )
		{
		if ( cbUnchecked < sizeof(CPG) )
			{
			return ErrERRCheck( JET_errBufferTooSmall );
			}
		cbUnchecked -= sizeof(CPG);

		// If list needed, ensure enough space for list sentinel.
		if ( FSPExtentLists( fSPExtents ) )
			{
			if ( cbUnchecked < sizeof(EXTENTINFO) )
				{
				return ErrERRCheck( JET_errBufferTooSmall );
				}
			cbUnchecked -= sizeof(EXTENTINFO);
			}
		}

	Assert( cbUnchecked >= 0 );

	return JET_errSuccess;
	}


LOCAL ERR ErrSPGetExtentInfo(
	FUCB		*pfucb,
	INT			*cpgExtTotal,
	INT			*piExtent,
	INT			cExtents,
	EXTENTINFO	*rgextentinfo,
	INT			cListSentinels,
	BOOL		fBuildExtentLists )
	{
	ERR			err;
	DIB			dib;
	INT			iExtent = *piExtent;

	*cpgExtTotal = 0;

	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );

	if ( err != JET_errRecordNotFound )
		{
		if ( err < 0 )
			goto HandleError;

		forever
			{
			Assert( iExtent < cExtents );
			Assert( pfucb->keyNode.cb == sizeof(PGNO) );
			LongFromKey( &rgextentinfo[iExtent].pgnoLastInExtent, pfucb->keyNode.pb );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			rgextentinfo[iExtent].cpgExtent = *(UNALIGNED PGNO *)pfucb->lineData.pb;
			
			*cpgExtTotal += rgextentinfo[iExtent].cpgExtent;

			if ( fBuildExtentLists )
				{
				// Be sure to leave space for the sentinels.
				if ( iExtent + cListSentinels < cExtents )
					iExtent++;
				else
					break;
				}

			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					goto HandleError;
				break;
				}
			}

		}

	if ( fBuildExtentLists )
		{
		Assert( iExtent < cExtents );

		rgextentinfo[iExtent].pgnoLastInExtent = 0;
		rgextentinfo[iExtent].cpgExtent = 0;
		iExtent++;
		}

	err = JET_errSuccess;

HandleError:
	*piExtent = iExtent;
	return err;
	}



ERR ErrSPGetInfo( PIB *ppib, DBID dbid, FUCB *pfucb, BYTE *pbResult, INT cbMax, BYTE fSPExtents )
	{
	ERR			err = JET_errSuccess;
	CPG			*pcpgOwnExtTotal;
	CPG			*pcpgAvailExtTotal;
	EXTENTINFO	*rgextentinfo;
	EXTENTINFO	extentinfo;
	FUCB 		*pfucbT = pfucbNil;
	INT			iExtent;
	INT			cExtents;
	BOOL		fBuildExtentLists = FSPExtentLists( fSPExtents );

	// Must specify either OwnExt or AvailExt (or both) to retrieve.
	if ( !( FSPOwnedExtent( fSPExtents )  ||  FSPAvailExtent( fSPExtents ) ) )
		return ErrERRCheck( JET_errInvalidParameter );

	CallR( ErrSPCheckInfoBuf( cbMax, fSPExtents ) );

	memset( pbResult, '\0', cbMax );

	// Setup up return information.  OwnExt is followed by AvailExt.  Extent list
	// for both then follows.
	if ( FSPOwnedExtent( fSPExtents ) )
		{
		pcpgOwnExtTotal = (CPG *)pbResult;
		if ( FSPAvailExtent( fSPExtents ) )
			{
			pcpgAvailExtTotal = pcpgOwnExtTotal + 1;
			rgextentinfo = (EXTENTINFO *)( pcpgAvailExtTotal + 1 );
			}
		else
			{
			pcpgAvailExtTotal = NULL;
			rgextentinfo = (EXTENTINFO *)( pcpgOwnExtTotal + 1 );
			}
		}
	else
		{
		Assert( FSPAvailExtent( fSPExtents ) );
		pcpgOwnExtTotal = NULL;
		pcpgAvailExtTotal = (CPG *)pbResult;
		rgextentinfo = (EXTENTINFO *)( pcpgAvailExtTotal + 1 );
		}

	cExtents = (INT)( ( pbResult + cbMax ) - ( (BYTE *)rgextentinfo ) ) / sizeof(EXTENTINFO);

	if ( fBuildExtentLists )
		{
		// If one list, need one sentinel.  If two lists, need two sentinels.
		Assert( FSPOwnedExtent( fSPExtents )  &&  FSPAvailExtent( fSPExtents ) ?
			cExtents >= 2 :
			cExtents >= 1 );
		}
	else
		{
		rgextentinfo = &extentinfo;
		cExtents = 1;			// Use a dummy EXTENTINFO structure.
		}

	/* get temporary FUCB, setup and use to search OwnExt/AvailExt
	/**/
	Call( ErrDIROpen(
		ppib,
		pfucb == pfucbNil ? pfcbNil : pfucb->u.pfcb,
		dbid,
		&pfucbT ) );
	FUCBSetIndex( pfucbT );

	// Initialise number of extent list entries.
	iExtent = 0;

	if ( FSPOwnedExtent( fSPExtents ) )
		{
		/*	move to Owned extents node
		/**/
		DIRGotoOWNEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

		Assert( pcpgOwnExtTotal );
		Call( ErrSPGetExtentInfo(
			pfucbT,
			pcpgOwnExtTotal,
			&iExtent,
			cExtents,
			rgextentinfo,
			( FSPAvailExtent( fSPExtents ) ? 2 : 1 ),
			fBuildExtentLists ) );

		DIRUp( pfucbT, 1 );
		}


	if ( FSPAvailExtent( fSPExtents ) )
		{
		/*	move to Available extents node
		/**/
		DIRGotoAVAILEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

		Assert( pcpgAvailExtTotal );
		Call( ErrSPGetExtentInfo(
			pfucbT,
			pcpgAvailExtTotal,
			&iExtent,
			cExtents,
			rgextentinfo,
			1,
			fBuildExtentLists ) );

		Assert( FSPOwnedExtent( fSPExtents ) ?
			*pcpgAvailExtTotal <= *pcpgOwnExtTotal : fTrue );
		}

HandleError:
	DIRClose( pfucbT );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\util.c ===
#include "std.h"

#ifndef RETAIL
#include <stdarg.h>
#endif

DeclAssertFile;


CODECONST(unsigned char) mpcoltypcb[] =
	{
	0,					/* JET_coltypNil (coltypNil is used for vltUninit parms) */
	sizeof(char),		/* JET_coltypBit */
	sizeof(char),		/* JET_coltypUnsignedByte */
	sizeof(short),		/* JET_coltypShort */
	sizeof(long),		/* JET_coltypLong */
	sizeof(long)*2,		/* JET_coltypCurrency */
	sizeof(float),		/* JET_coltypIEEESingle */
	sizeof(double),		/* JET_coltypIEEEDouble */
	sizeof(double),		/* JET_coltypDateTime */
	0,					/* JET_coltypBinary */
	0,					/* JET_coltypText */
	sizeof(long),		/* JET_coltypLongBinary */
	sizeof(long),		/* JET_coltypLongText */
	0,					/* JET_coltypDatabase */
	sizeof(JET_TABLEID)	/* JET_coltypTableid */
	};


static CODECONST(unsigned char) rgbValidName[16] = {
	0xff,			       /* 00-07 No control characters */
	0xff,			       /* 08-0F No control characters */
	0xff,			       /* 10-17 No control characters */
	0xff,			       /* 18-1F No control characters */
	0x02,			       /* 20-27 No ! */
	0x40,			       /* 28-2F No . */
	0x00,			       /* 30-37 */
	0x00,			       /* 38-3F */
	0x00,			       /* 40-47 */
	0x00,			       /* 48-4F */
	0x00,			       /* 50-57 */
	0x28,			       /* 58-5F No [ or ] */
	0x00,			       /* 60-67 */
	0x00,			       /* 68-6F */
	0x00,			       /* 70-77 */
	0x00,			       /* 78-7F */
	};


unsigned CchUTILIValidateName(char  *pchName, const char  *lpchName, unsigned cchName)
	{
	char			*pch;
	unsigned		cch;
	char			*pchLast;
	unsigned char	ch;

	/* A name may not begin with a space */
	if ( *lpchName == ' ' )
		return(0);
	pch = pchName;
	cch = 0;
	/* To detect zero length names */
	pchLast = pchName;

	while (((ch = (unsigned char) *lpchName++) != '\0') && (cch < cchName))
		{
		/*	The name too long check is inside the loop to prevent
		/*	overflowing the output buffer which is only JET_cbNameMost
		/*	characters long.  This means than insignificant trailing
		/*	spaces will trigger an error.
		/**/
		/* Name too long */
		if ( ++cch > JET_cbNameMost )
			return(0);

		/* Extended characters always valid */
		if (ch < 0x80)
			{
			if ((rgbValidName[ch >> 3] >> (ch & 0x7)) & 1)
				return(0);
			}

		*pch++ = (char) ch;

		/* Last significant character */
		if (ch != ' ')
			pchLast = pch;
		}

	/* Length of significant portion */
	cch = (unsigned)(pchLast - pchName);

	return(cch);
	}


ERR ErrUTILCheckName( char *szNewName, const char *szName, int cchName )
	{
	unsigned int	cch;

	cch = CchUTILIValidateName( szNewName, szName, cchName );

	if ( cch == 0 )
		{
		return ErrERRCheck( JET_errInvalidName );
		}
	else
		{
		szNewName[cch] = '\0';
		}

	return JET_errSuccess;
	}


#ifndef RETAIL

typedef void ( *PFNvprintf)(const char  *, va_list);

struct {
	PFNvprintf pfnvprintf;
	}  pfn = { NULL };


void VARARG DebugPrintf(const char  *szFmt, ...)
	{
	va_list arg_ptr;

	if (pfn.pfnvprintf == NULL)	       /* No op if no callback registered */
		return;

	va_start(arg_ptr, szFmt);
	(*pfn.pfnvprintf)(szFmt, arg_ptr);
	va_end(arg_ptr);
	}


	/*	The following pragma affects the code generated by the C
	/*	compiler for all FAR functions.  Do NOT place any non-API
	/*	functions beyond this point in this file.
	/**/

void JET_API JetDBGSetPrintFn(JET_SESID sesid, PFNvprintf pfnParm)
	{
	pfn.pfnvprintf = pfnParm;
	}

/*
 *	level 0 - all log s.
 *	level 1 - log read and update operations.
 *	level 2 - log update operations only.
 */

static CODECONST(unsigned char) mpopLogLevel[opMax] = {
/*							0	*/		0,
/*  opIdle					1	*/		2,
/*	opGetTableIndexInfo		2	*/		1,
/*	opGetIndexInfo			3	*/		1,
/*	opGetObjectInfo			4	*/		1,
/*	opGetTableInfo			5	*/		1,
/*	opCreateObject			6	*/		2,
/*	opDeleteObject			7	*/		2,
/*	opRenameObject			8	*/		2,
/*	opBeginTransaction		9	*/		2,
/*	opCommitTransaction		10	*/		2,
/*	opRollback				11	*/		2,
/*	opOpenTable				12	*/		1,
/*	opDupCursor				13	*/		1,
/*	opCloseTable			14	*/		1,
/*	opGetTableColumnInfo	15	*/		1,
/*	opGetColumnInfo			16	*/		1,
/*	opRetrieveColumn		17	*/		1,
/*	opRetrieveColumns		18	*/		1,
/*	opSetColumn				19	*/		2,
/*	opSetColumns			20	*/		2,
/*	opPrepareUpdate			21	*/		2,
/*	opUpdate				22	*/		2,
/*	opDelete				23	*/		2,
/*	opGetCursorInfo			24	*/		1,
/*	opGetCurrentIndex		25	*/		1,
/*	opSetCurrentIndex		26	*/		1,
/*	opMove					27	*/		1,
/*	opMakeKey				28	*/		1,
/*	opSeek					29	*/		1,
/*	opGetBookmark			30	*/		1,
/*	opGotoBookmark			31	*/		1,
/*	opGetRecordPosition		32	*/		1,
/*	opGotoPosition			33	*/		1,
/*	opRetrieveKey			34	*/		1,
/*	opCreateDatabase		35	*/		2,
/*	opOpenDatabase			36	*/		1,
/*	opGetDatabaseInfo		37	*/		1,
/*	opCloseDatabase			38	*/		1,
/*	opCapability			39	*/		1,
/*	opCreateTable			40	*/		2,
/*	opRenameTable			41	*/		2,
/*	opDeleteTable			42	*/		2,
/*	opAddColumn				43	*/		2,
/*	opRenameColumn			44	*/		2,
/*	opDeleteColumn			45	*/		2,
/*	opCreateIndex			46	*/		2,
/*	opRenameIndex			47	*/		2,
/*	opDeleteIndex			48	*/		2,
/*	opComputeStats			49	*/		2,
/*	opAttachDatabase		50	*/		2,
/*	opDetachDatabase		51	*/		2,
/*	opOpenTempTable			52	*/		2,
/*	opSetIndexRange			53	*/		1,
/*	opIndexRecordCount		54	*/		1,
/*	opGetChecksum			55	*/		1,
/*	opGetObjidFromName		56	*/		1,
};

/* function in logapi to store jetapi calls */
extern void LGJetOp( JET_SESID sesid, int op );

void DebugLogJetOp( JET_SESID sesid, int op )
	{
	// UNDONE: should be controlled by a system parameter to decide
	// UNDONE: which log level it should be.

	/* log level 2 operations */
	if ( mpopLogLevel[ op ] >= lAPICallLogLevel )
		LGJetOp( sesid, op );
	}

#endif	/* !RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\tm.c ===
#include "daestd.h"
#include "version.h"

DeclAssertFile;						/* Declare file name for assert macros */

INT itibGlobal = 0;

extern CHAR szRecovery[];
extern ULONG cMPLTotalEntries;

/*  monitoring statistics
/**/
unsigned long cUserCommitsTo0 = 0;

PM_CEF_PROC LUserCommitsTo0CEFLPpv;

long LUserCommitsTo0CEFLPpv(long iInstance,void *pvBuf)
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cUserCommitsTo0;
		}
		
	return 0;
	}

unsigned long cUserRollbacksTo0 = 0;

PM_CEF_PROC LUserRollbacksTo0CEFLPpv;

long LUserRollbacksTo0CEFLPpv(long iInstance,void *pvBuf)
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cUserRollbacksTo0;
		}
		
	return 0;
	}


//+api
//	ErrIsamBeginSession
//	========================================================
//	ERR ErrIsamBeginSession( PIB **pppib )
//
//	Begins a session with DAE.  Creates and initializes a PIB for the
//	user and returns a pointer to it.  Calls system initialization.
//
//	PARAMETERS	pppib			Address of a PIB pointer.  On return, *pppib
//		   						will point to the new PIB.
//
//	RETURNS		Error code, one of:
//					JET_errSuccess
//					JET_errTooManyActiveUsers
//
//	SEE ALSO		ErrIsamEndSession
//-
ERR ISAMAPI ErrIsamBeginSession( JET_SESID *psesid )
	{
	ERR			err;
	JET_SESID	sesid = *psesid;
	PIB			**pppib;

	Assert( psesid != NULL );
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	pppib = (PIB **)psesid;

	SgEnterCriticalSection( critUserPIB );

	/*	alllocate process information block
	/**/
	Call( ErrPIBBeginSession( pppib, procidNil ) );
	(*pppib)->grbitsCommitDefault = lCommitDefault;    /* set default commit flags */
	(*pppib)->fUserSession = fTrue;

	SgLeaveCriticalSection( critUserPIB );

	/*	store session id in pib.  If passes JET_sesidNil, then
	/*	store ppib in place of sesid.
	/**/
	if ( sesid != JET_sesidNil )
		{
		(*pppib)->sesid = sesid;
		}
	else
		{
		(*pppib)->sesid = (JET_SESID)(*pppib);
		}

HandleError:
	return err;
	}


//+api
//	ErrIsamEndSession
//	=========================================================
//	ERR ErrIsamEndSession( PIB *ppib, JET_GRBIT grbit )
//
//	Ends the session associated with a PIB.
//
//	PARAMETERS	ppib		Pointer to PIB for ending session.
//
//	RETURNS		JET_errSuccess
//
//	SIDE EFFECTS
//		Rolls back all transaction levels active for this PIB.
//		Closes all FUCBs for files and sorts open for this PIB.
//
//	SEE ALSO 	ErrIsamBeginSession
//-
ERR ISAMAPI ErrIsamEndSession( JET_SESID sesid, JET_GRBIT grbit )
	{		
	ERR	 	err;
	DBID  	dbid;
	PIB	 	*ppib = (PIB *)sesid;
	
	CallR( ErrPIBCheck( ppib ) );

	NotUsed( grbit );

	/*	rollback all transactions
	/**/
	while( ppib->level > 0 )
		{
		Assert( sizeof(JET_VSESID) == sizeof(ppib) );
		CallR( ErrIsamRollback( (JET_VSESID)ppib, JET_bitRollbackAll ) );
		}

	/*	close all databases for this PIB
	/**/
	CallR( ErrDABCloseAllDBs( ppib ) );
	
	/*	close all open databases for this PIB
	/**/
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		if ( FUserOpenedDatabase( ppib, dbid ) )
			{
			/* if not for recovering, ErrDABCloseAllDBs has closed all others
			/**/
			Assert( fRecovering );
			CallR( ErrDBCloseDatabase( ppib, dbid, 0 ) );
			}
		}

	/*	close all cursors still open
	/*	should only be sort and temporary file cursors
	/**/
	while( ppib->pfucb != pfucbNil )
		{
		FUCB	*pfucb	= ppib->pfucb;

		/*	close materialized or unmaterialized temporary tables
		/**/
		if ( FFUCBSort( pfucb ) )
			{
			Assert( !( FFUCBIndex( pfucb ) ) );
			CallR( ErrIsamSortClose( ppib, pfucb ) );
			}
		else if ( fRecovering || FFUCBNonClustered( pfucb ) )
			{
			/*  If the fucb is used for redo (recovering), then it is
			/*  always being opened as a cluster fucb with no index.
			/*  use DIRClose to close such a fucb.
			/*  Else, it is not for recovering, cursor is on index fucb,
			/*  main fucb may still be ahead. Close this index fucb.
			/**/
			DIRClose( pfucb );
			}
		else
			{
			while ( FFUCBNonClustered( pfucb ) )
				{
				pfucb = pfucb->pfucbNext;
				}
			
			Assert( FFUCBIndex( pfucb ) );
			
			if( pfucb->fVtid )
				{
				CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
				}
			else
				{
				Assert( pfucb->tableid == JET_tableidNil );
				CallS( ErrFILECloseTable( ppib, pfucb ) );
				}
			}
		}
	Assert( ppib->pfucb == pfucbNil );

	PIBEndSession( ppib );

	return JET_errSuccess;
	}


ERR	ISAMAPI ErrIsamInvalidateCursors( JET_SESID sesid )
	{
	PIB	 	*ppib = (PIB *) sesid;
	FUCB	*pfucb;
	
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( PcsrCurrent( pfucb ) != pcsrNil )
			{
			Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
			PcsrCurrent( pfucb )->pgno = pgnoNull;
			PcsrCurrent( pfucb )->itag = itagNil;
			PcsrCurrent( pfucb )->itagFather = itagNil;
			PcsrCurrent( pfucb )->bm = sridNull;
			PcsrCurrent( pfucb )->item = sridNull;
			}
		pfucb->bmStore = sridNull;
		pfucb->itemStore = sridNull;
		pfucb->sridFather = sridNull;
		}
		
	return JET_errSuccess;
	}
	

/*	ErrIsamSetSessionInfo  =================================
	
Description:

	Sets cursor isolation model to valid JET_CIM value.

Parameters:
	sesid		session id
	grbit		grbit

==========================================================*/
ERR ISAMAPI ErrIsamSetSessionInfo( JET_SESID sesid, JET_GRBIT grbit )
	{
	( (PIB *)sesid )->grbit = grbit;
	return JET_errSuccess;
	}


/*	ErrIsamGetSessionInfo  =================================
	
Description:

	Gets cursor isolation model value.

==========================================================*/
ERR ISAMAPI ErrIsamGetSessionInfo( JET_SESID sesid, JET_GRBIT *pgrbit )
	{
	ERR		err;
	PIB		*ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );
	*pgrbit = ppib->grbit;
	return JET_errSuccess;
	}


ERR ISAMAPI ErrIsamIdle( JET_SESID sesid, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	ERR		wrn = JET_errSuccess;
	PIB		*ppib = (PIB *)sesid;
	ULONG	icall;

	CallR( ErrPIBCheck( ppib ) );

	/*	return error code for status
	/**/
	if ( grbit & JET_bitIdleStatus )
		{
		if ( grbit & JET_bitIdleCompact )
			{
			err = ErrMPLStatus();
			}
		else
			err = JET_errInvalidParameter;

		return err;
		}

	/*	idle status not in grbit
	/**/
	Assert( !(grbit & JET_bitIdleStatus) );

	/*	clean all version buckets
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleCompact )
		{
		Call( ErrRCECleanAllPIB() );
		if ( wrn == JET_errSuccess )
			wrn = err;
		}

	/*	clean all modified pages
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleCompact )
		{
		BOOL	fBMAllNullOps = fTrue;
		
		icall = 0;
		do
			{
			Assert( ppib != ppibBMClean );
			Call( ErrBMClean( ppibBMClean ) );

			if ( err != wrnBMCleanNullOp )
				{
				fBMAllNullOps = fFalse;
				}
				
			if ( wrn == JET_errSuccess && err == JET_wrnNoIdleActivity )
				{
				wrn = err;
				}
				
			if ( err < 0 )
				break;
  			} while ( ++icall < icallIdleBMCleanMax &&
  					  icall < cMPLTotalEntries &&
  					  err != JET_wrnNoIdleActivity );

  		if ( fBMAllNullOps && err >= 0 )
  			{
  			wrn = JET_wrnNoIdleActivity;
  			}
		}

	/*	flush some dirty buffers
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleFlushBuffers )
		{
		Call( ErrBFFlushBuffers( 0, fBFFlushSome ) );
		if ( wrn == JET_errSuccess )
			wrn = err;
		}

HandleError:
	return err == JET_errSuccess ? wrn : err;
	}


ERR VTAPI ErrIsamCapability( JET_VSESID vsesid,
	JET_VDBID vdbid,
	ULONG ulArea,
	ULONG ulFunction,
	ULONG *pgrbitFeature )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = (PIB *)vsesid;

	CallR( ErrPIBCheck( ppib ) );

	NotUsed( vdbid );
	NotUsed( ulArea );
	NotUsed( ulFunction );
	NotUsed( pgrbitFeature );

	return JET_errFeatureNotAvailable;
	}


extern BOOL fOLCompact;
BOOL fGlobalRepair = fFalse;
BOOL fGlobalSimulatedRestore = fFalse;

ERR ISAMAPI ErrIsamInit( unsigned long iinstance )
	{
	ERR		err;
	BOOL	fLGInitIsDone = fFalse;
	BOOL	fJetLogGeneratedDuringSoftStart = fFalse;
	BOOL	fNewCheckpointFile;
	BYTE	szT[3][32];
	char	*rgszT[3];

	CallR( ErrITSetConstants( ) );

	/*	set log disable state
	/**/
	if ( _strnicmp( szRecovery, "repair", 6 ) == 0 )
		{
		// If szRecovery is exactly "repair", then enable logging.  If anything
		// follows "repair", then disable logging.
		fGlobalRepair = fTrue;
		if ( szRecovery[6] == 0 )
			{
			fLogDisabled = fFalse;
//			fDoNotOverWriteLogFilePath = fTrue;
			}
		else
			{
			fLogDisabled = fTrue;
//			fDoNotOverWriteLogFilePath = fFalse;	// This flag is irrelevant with logging disabled.
			}
		}
	else
		{
		fLogDisabled = ( szRecovery[0] == '\0' || _stricmp ( szRecovery, szOn ) != 0 );
		}

	/*	write jet start event
	/**/
	sprintf( szT[0], "%02d", rmj );
	rgszT[0] = szT[0];
	sprintf( szT[1], "%02d", rmm );
	rgszT[1] = szT[1];
	sprintf( szT[2], "%04d", rup );
	rgszT[2] = szT[2];
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, GENERAL_CATEGORY, START_ID, 3, rgszT );

	/*	initialize file map
	/**/
	CallR( ErrFMPInit() );

	/*	initialize system according to logging disabled
	/**/
	if ( !fLogDisabled )
		{
		DBMS_PARAM dbms_param;

		/*	initialize log manager, and	check the last generation
		/*	of log files to determine if recovery needed.
		/**/
		CallJ( ErrLGInit( &fNewCheckpointFile ), TermFMP );
		fLGInitIsDone = fTrue;

		/*	store the system parameters
		 */
		LGSetDBMSParam( &dbms_param );

		/*	recover attached databases to consistent state
		/*	if recovery is successful, then we should have
		/*	a proper edbchk.sys file
		/**/
		CallJ( ErrLGSoftStart( fFalse, fNewCheckpointFile, &fJetLogGeneratedDuringSoftStart ), TermLG );

		/*	initialize constants again.
		/**/
		LGRestoreDBMSParam( &dbms_param );

		/*  add the first log record
		/**/
		err = ErrLGStart();

		CallJ( ErrITSetConstants( ), TermLG );
		}

	/*  initialize remaining system
	/**/
	CallJ( ErrITInit(), TermLG );

	/*	set up FMP from checkpoint.
	/**/
	if ( !fLogDisabled && !fRecovering )
		{
		BYTE	szPathJetChkLog[_MAX_PATH + 1];
		
		LGFullNameCheckpoint( szPathJetChkLog );
		err = ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointGlobal );
		/*	if checkpoint could not be read, then leave FMP empty.
		/**/
		if ( err >= 0 )
			{
			AssertCriticalSection( critJet );
			err = ErrLGLoadFMPFromAttachments( pcheckpointGlobal->rgbAttach );
			logtimeFullBackup = pcheckpointGlobal->logtimeFullBackup;
			lgposFullBackup = pcheckpointGlobal->lgposFullBackup;
			logtimeIncBackup = pcheckpointGlobal->logtimeIncBackup;
			lgposIncBackup = pcheckpointGlobal->lgposIncBackup;

			CallJ( ErrDBSetupAttachedDB(), TermIT );
			}
		err = JET_errSuccess;
		fGlobalFMPLoaded = fTrue;
		}

	if ( fJetLogGeneratedDuringSoftStart )
		{
		/*	set proper attachment
		/**/
		LeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fTrue );
		EnterCriticalSection( critJet );
		
		/*	rewrite logfile header. This is the only place we rewrite
		/*	log file header and only for first generation. This is because
		/*	when the log file is generated, the fmp is not initialized yet.
		/*	This can only happen a user turn the log off and do some database
		/*	work and later on turn the log on and continue to work.
		/**/
		Assert( plgfilehdrGlobal->lGeneration == 1 );
		LGLoadAttachmentsFromFMP( plgfilehdrGlobal->rgbAttach,
			(INT)(((BYTE *)(plgfilehdrGlobal + 1)) - plgfilehdrGlobal->rgbAttach) );
		CallJ( ErrLGWriteFileHdr( plgfilehdrGlobal ), TermIT );

		// Reset flag in case JetInit() invoked again.
		fJetLogGeneratedDuringSoftStart = fFalse;
		}

	return err;

TermIT:
	CallS( ErrITTerm( fTermError ) );
	
TermLG:
	if ( fLGInitIsDone )
		{
		(VOID)ErrLGTerm( fFalse /* do not flush log */ );
		}
	
	if ( fJetLogGeneratedDuringSoftStart )
		{
		(VOID)ErrUtilDeleteFile( szLogName );
		}

TermFMP:
	FMPTerm();
	
	return err;
	}


ERR ISAMAPI ErrIsamTerm( JET_GRBIT grbit )
	{
	ERR		err;
	INT		fTerm = grbit & JET_bitTermAbrupt ? fTermNoCleanUp : fTermCleanUp;

	err = ErrITTerm( fTerm );
	if ( fSTInit != fSTInitNotDone )
		{
		/*	before getting an error before reaching no-returning point in ITTerm().
		 */
		Assert( err < 0 );
		return err;
		}

	/*	write jet stop event
	/**/
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, GENERAL_CATEGORY, STOP_ID, 0, NULL );

	(VOID)ErrLGTerm( fTrue );
	
	FMPTerm();

#ifdef DEBUG
	MEMCheck();
#endif

	return err;
	}


#ifdef DEBUG
ERR ISAMAPI ErrIsamGetTransaction( JET_VSESID vsesid, unsigned long *plevel )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = (PIB *)vsesid;

	CallR( ErrPIBCheck( ppib ) );

	*plevel = (LONG)ppib->level;
	return err;
	}
#endif


//+api
//	ErrIsamBeginTransaction
//	=========================================================
//	ERR ErrIsamBeginTransaction( PIB *ppib )
//
//	Starts a transaction for the current user.  The user's transaction
//	level increases by one.
//
//	PARAMETERS	ppib 			pointer to PIB for user
//
//	RETURNS		JET_errSuccess
//
//	SIDE EFFECTS	
//		The CSR stack for each active FUCB of this user is copied
//		to the new transaction level.
//
// SEE ALSO		ErrIsamCommitTransaction, ErrIsamRollback
//-
ERR ISAMAPI ErrIsamBeginTransaction( JET_VSESID vsesid )
	{
	PIB		*ppib = (PIB *)vsesid;
	ERR		err;

	CallR( ErrPIBCheck( ppib ) );
	Assert( ppib != ppibNil );

	Assert( ppib->level <= levelUserMost );
	if ( ppib->level == levelUserMost )
		{
		err = ErrERRCheck( JET_errTransTooDeep );
		}
	else
		{
		err = ErrDIRBeginTransaction( ppib );
		}

	return err;
	}


//+api
//	ErrIsamCommitTransaction
//	========================================================
//	ERR ErrIsamCommitTransaction( JET_VSESID vsesid, JET_GRBIT grbit )
//
//	Commits the current transaction for this user.  The transaction level
//	for this user is decreased by the number of levels committed.
//
//	PARAMETERS	
//
//	RETURNS		JET_errSuccess
//
//	SIDE EFFECTS
//		The CSR stack for each active FUCB of this user is copied
//		from the old ( higher ) transaction level to the new ( lower )
//		transaction level.
//
//	SEE ALSO	ErrIsamBeginTransaction, ErrIsamRollback
//-
ERR ISAMAPI ErrIsamCommitTransaction( JET_VSESID vsesid, JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib = (PIB *)vsesid;

	CallR( ErrPIBCheck( ppib ) );

	/*	may not be in a transaction, but wait for flush of previous
	/*	lazy committed transactions.
	/**/
	if ( grbit & JET_bitWaitLastLevel0Commit )
		{
		if ( grbit & ~JET_bitWaitLastLevel0Commit )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		/*	wait for last level 0 commit and rely on good user behavior
		/**/
		if ( CmpLgpos( &ppib->lgposPrecommit0, &lgposMax ) == 0 )
			{
			return JET_errSuccess;
			}

		LeaveCriticalSection( critJet );
		err = ErrLGWaitPrecommit0Flush( ppib );
		EnterCriticalSection( critJet );
		Assert( err >= 0 || fLGNoMoreLogWrite );
		
		return err;
		}

	if ( ppib->level == 0 )
		{
		return ErrERRCheck( JET_errNotInTransaction );
		}

#ifdef DEBUG
	/*	disable lazy flush for debug build
	/**/
	grbit &= ~JET_bitCommitLazyFlush;
#endif

	err = ErrDIRCommitTransaction( ppib, grbit );

	/*	keep stats for monitoring
	/**/
	if ( !ppib->level )
		{
		cUserCommitsTo0++;
		}

	return err;
	}


//+api
//	ErrIsamRollback
//	========================================================
//	ERR ErrIsamRollback( PIB *ppib, JET_GRBIT grbit )
//
//	Rolls back transactions for the current user.  The transaction level of
//	the current user is decreased by the number of levels aborted.
//
//	PARAMETERS	ppib		pointer to PIB for user
//				grbit		unused
//
//	RETURNS		
//		JET_errSuccess
//-
ERR ISAMAPI ErrIsamRollback( JET_VSESID vsesid, JET_GRBIT grbit )
	{
	ERR    	err;
	PIB    	*ppib = (PIB *)vsesid;
	FUCB   	*pfucb;
	FUCB   	*pfucbNext;
	LEVEL  	levelRollbackTo;

	/*	check session id before using it
	/**/
	CallR( ErrPIBCheck( ppib ) );

	if ( ppib->level == 0 )
		{
		return ErrERRCheck( JET_errNotInTransaction );
		}

	do
		{
		levelRollbackTo = ppib->level - 1;

		/*	get first clustered index cusor
		/**/
		for ( pfucb = ppib->pfucb;
			pfucb != pfucbNil && FFUCBNonClustered( pfucb );
			pfucb = pfucb->pfucbNext )
			NULL;

		/*	LOOP 1 -- first go through all open cursors, and close them
		/*	or reset	non-clustered index cursors, if opened in transaction
		/*	rolled back.  Reset copy buffer status and move before first.
		/*	Some cursors will be fully closed, if they have not performed any
		/*	updates.  This will include non-clustered index cursors
		/*	attached to clustered index cursors, so pfucbNext must
		/*	always be a clustered index cursor, to ensure that it will
		/*	be valid for the next loop iteration.  Note that no information
		/*	necessary for subsequent rollback processing is lost, since
		/*	the cursors will only be released if they have performed no
		/*	updates including DDL.
		/**/
		for ( ; pfucb != pfucbNil; pfucb = pfucbNext )
			{
			/*	get next clustered index cusor
			/**/
			for ( pfucbNext = pfucb->pfucbNext;
			  	pfucbNext != pfucbNil && FFUCBNonClustered( pfucbNext );
			  	pfucbNext = pfucbNext->pfucbNext )
				NULL;

			/*	if defer closed then continue
			/**/
			if ( FFUCBDeferClosed( pfucb ) )
				continue;

			/*	reset copy buffer status for each cursor on rollback
			/**/
			if ( FFUCBUpdatePreparedLevel( pfucb, pfucb->ppib->level - 1 ) )
				{
				FUCBResetDeferredChecksum( pfucb );
				FUCBResetUpdateSeparateLV( pfucb );
				FUCBResetCbstat( pfucb );
				FLDFreeLVBuf( pfucb );
				Assert( pfucb->pLVBuf == NULL );
				}
		
			/*	if current cursor is a table, and was opened in rolled back
			/*	transaction, then close cursor.
			/**/
			if ( FFUCBIndex( pfucb ) && FFCBClusteredIndex( pfucb->u.pfcb ) )
				{
				if ( pfucb->levelOpen > levelRollbackTo )
					{
					if ( pfucb->fVtid )
						{
						CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
						}
					else
						{
						Assert( pfucb->tableid == JET_tableidNil );
						CallS( ErrFILECloseTable( ppib, pfucb ) );
						}
					continue;
					}

				/*	if clustered index cursor, and non-clustered index set
				/*	in rolled back transaction, then change index to clustered
				/*	index.  This must be done, since non-clustered index
				/*	definition may be rolled back, if the index was created
				/*	in the rolled back transaction.
				/**/
				if ( pfucb->pfucbCurIndex != pfucbNil )
					{
					if ( pfucb->pfucbCurIndex->levelOpen > levelRollbackTo )
						{
						CallS( ErrRECSetCurrentIndex( pfucb, NULL ) );
						}
					}
				}

			/*	if current cursor is a sort, and was opened in rolled back
			/*	transaction, then close cursor.
			/**/
			if ( FFUCBSort( pfucb ) )
				{
				if ( pfucb->levelOpen > levelRollbackTo )
					{
					if ( TableidOfVtid( pfucb ) != JET_tableidNil )
						{
						CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
						}
					else
						{
						CallS( ErrSORTClose( pfucb ) );
						}
					continue;
					}
				}

			/*	if not sort and not index, and was opened in rolled back
			/*	transaction, then close DIR cursor directly.
			/**/
			if ( pfucb->levelOpen > levelRollbackTo )
				{
				DIRClose( pfucb );
				continue;
				}
			}

		/*	call lower level abort routine
		/**/
		CallR( ErrDIRRollback( ppib ) );
		}
	while ( ( grbit & JET_bitRollbackAll ) != 0 && ppib->level > 0 );

	if ( ppib->level == 0 )
		cUserRollbacksTo0++;

	err = JET_errSuccess;

	return err;
	}


/*	ErrIsamQuiesce  =================================
	
Description:

	Quiesce can be used for single user mode, by specifying a
	session is allowed to continue normally.

	Quiesce can also be used to bring databases to a consistent
	state, so that they may be file copied for backup, or so that
	a subsequent termination can be very fast, during reversion to
	stand-by mode in a server process.  Calling quiesce before
	termination also allows a graceful termination, in which active
	transactions are allowed to complete.

	Quiesce system for single user mode by

	1) suspending new transactions
	
	or quiesce system for pretermination by

	1) suspending new transactions
	2) suspending background processes including on-line compaction
	   and version clean up
	3) flush dirty buffers

	A quiescent mode can be left, by calling ErrIsamQuiesce
	with the JET_bitLeave grbit.

Parameters:
	sesid		session id exempt from quiesce restrictions
	grbit		flags
				-------------------------------------------
				JET_bitEnterPreTermination
				JET_bitEnterSingleUserMode
				JET_bitLeave

==========================================================*/
#if 0
BOOL	fQuiesce = fFalse;

ERR ISAMAPI ErrIsamQuiesce( JET_VSESID vsesid, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = (PIB *)vsesid;

	if ( (grbit & ~( JET_bitEnterPreTermination |
		JET_bitEnterSingleUserMode |
		JET_bitLeave) )
		{
		Error( ErrERRCheck( JET_errInvalidParameter ), HandleError );
		}

	if ( (grbit & JET_bitLeave) && !fQuiesce )
		{
		Error( ErrERRCheck( JET_errNotQuiescing ), HandleError );
		}
	else if ( fQuiesce )
		{
		Error( ErrERRCheck( JET_errAlreadyQuiescing ), HandleError );
		}

	if ( grbit & JET_bitLeave )
		{
		ppibQuiesce = ppibNil;
   		fQuiesce = fFalse;
		}
	else
		{
		ULONG	ulmsec = ulStartTimeOutPeriod;

		/*	prevent transactions from beginning from level 0
		/**/
		fQuiesce = fTrue;
		ppibQuiesce = ppib;
		cpib = ( ppib == ppibNil ? 0 : ppib->level > 0 );
		Assert( cpib == 0 || cpib == 1 );

		while ( CppibTMActive() > cpib )
			{
			BFSleep( ulmsec );
			ulmsec *= 2;
			if ( ulmsec > ulMaxTimeOutPeriod )
				{
				ulmsec = ulMaxTimeOutPeriod;
				}
			}

		Assert( CppibTMActive() == cpib );

		/*	done for single user mode, but if preterm then
		/*	must suspend background processes and flush
		/*	dirty buffers.
		/**/
		if ( grbit & JET_bitPreTerm )
			{
			//	UNDONE:	suspend bookmark clean up and version clean up

			/*	flush all buffers
			/**/
			Call( ErrBFFlushBuffers( 0, fBFFlushAll ) );
			}
		}

HandleError:
	return err;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\ver.c ===
#include "daestd.h"

#include <stdio.h>
#include <stdarg.h>

DeclAssertFile;                                 /* Declare file name for assert macros */

#define FCB_STATS	1
#ifdef FCB_STATS
extern ULONG	cfcbVer; /* delete index in progress */
#endif

/*	transaction counters
/**/
TRX			trxOldest = trxMax;
TRX			trxNewest = 0;
CRIT		critCommit0;

/*	thread control variables.
/**/
HANDLE	handleRCECleanProc = 0;
BOOL   	fRCECleanProcTerm = fFalse;

/*	RCE clean signal
/**/
SIG		sigRCECleanProc;
CRIT   	critRCEClean;
CRIT   	critBMClean;
extern CRIT critSplit;

/*	global bucket chain
/**/
BUCKET	*pbucketGlobal = pbucketNil;

/*	session opened by VERClean
/**/
PIB		*ppibRCECleanGlobal = ppibNil;

#ifdef DEBUG
INT	cVersion = 0;
#endif

/*	The space for version buckets is reserved in memory at startup.
/*	Memory is committed and decommitted in chunks of cBucketChunk
/*	as buckets are allocated or released
/**/

/*	number of buckets in one chunk of allocation
/**/
#define cbucketChunk	4

/*	structure to maintain bucket resource
/**/
struct _resVerPages
	{
	INT		iblockCommit;
	INT		cblockCommit;
	INT		cblockAlloc;
	BYTE	*pbAlloc;
	BOOL	fAvailOldest[cbucketChunk];
	BOOL	fAvailNewest[cbucketChunk];
	} resVerPagesGlobal;


/****************** Bucket Layer ***************************
/***********************************************************

A bucket is a contiguous block of memory used to hold versions.

************************************************************
***********************************************************/

#define IbDoubleWordBoundary(ib)                                                                \
	( (INT) ( ((DWORD_PTR) (ib) + 3) & ~3 ) )

#define PbDoubleWordBoundary(pb)                                                                \
	( (BYTE *) ( ((DWORD_PTR) (pb) + 3) & ~3 ) )

/*	to align an RCE in a bucket
/**/
#define IbAlignRCE(ib)  IbDoubleWordBoundary(ib)
#define PbAlignRCE(pb)  PbDoubleWordBoundary(pb)

#define FBUNew(pbucket)                                                                     \
	( (pbucket)->ibNewestRCE == 0 )

#define IbBUOfPrce( prce, pbucket )        ( (BYTE *)prce - (BYTE *)pbucket )

#define IbBUFree(pbucket)											\
	( FBUNew(pbucket) ? IbAlignRCE( cbBucketHeader )				\
		: IbAlignRCE(												\
			(pbucket)->ibNewestRCE                                  \
			+ sizeof(RCE)											\
			+ (PrceRCENewest(pbucket))->cbData ) )

/*	the cast to (INT) below is necessary to catch the negative case
/**/
#define CbBUFree(pbucket)											\
	( ( (pbucket == pbucketNil) ?									\
		0 : ((INT) sizeof(BUCKET) - (INT) IbBUFree(pbucket) ) ) )

#define PrceRCENewest(pbucket)                                                          \
	( (RCE *) ( (BYTE *) (pbucket) + (pbucket)->ibNewestRCE ) )

#define FRCENoVersion( prce )										\
	( PrceRCEGet( prce->dbid, prce->bm ) == prceNil )

/*	given prce == prceNil, return the first RCE in bucket
/**/
INLINE LOCAL RCE *PrceRCENextOldest( BUCKET *pbucket, RCE *prce )
	{
	Assert( pbucket == NULL || prce != PrceRCENewest(pbucket) );

	return (RCE *) PbAlignRCE (
		(BYTE *) ( prce == prceNil ?
		(BYTE *) pbucket + cbBucketHeader :
		(BYTE *) prce + sizeof(RCE) + prce->cbData ) );
	}


//+local
//	PrcePIBOldest( ppib )
//	returns pointer to oldest RCE for given session
//	
INLINE LOCAL RCE *PrcePIBOldest( PIB *ppib )
	{
	RCE *prce = ppib->prceNewest;

	if ( prce == prceNil )
		{
		return prceNil;
		}
		
	forever
		{
		if ( prce->prcePrevOfSession == prceNil )
			{
			return prce;
			}
			
		prce = prce->prcePrevOfSession;
		}
		
	return prce;
	}


#ifdef DEBUG
VOID CheckResVerPages( )
	{
	Assert( resVerPagesGlobal.cblockAlloc >= 0 );
	Assert( resVerPagesGlobal.cblockCommit >= 0 );
	Assert( resVerPagesGlobal.iblockCommit >= 0 );

	Assert( resVerPagesGlobal.cblockAlloc >= resVerPagesGlobal.cblockCommit );
	Assert( resVerPagesGlobal.cblockAlloc >= resVerPagesGlobal.iblockCommit );
	Assert( resVerPagesGlobal.cblockCommit % cbucketChunk == 0 );
	}
#else
#define CheckResVerPages( )		0
#endif

//+local
//	PBucketMEMAlloc( )
//	Allocates a bucket of memory
//	CONSIDER: allocating buckets in a block
//
LOCAL BUCKET *PbucketMEMAlloc( )
	{
	BUCKET	*pbucket;
	INT		iBucket;
	INT 	cBucketAvail;

	CheckResVerPages( );	

	/*	signal RCECleanup if last bucket to be allocated from
	/*	bucket chunk
	/**/
	for ( cBucketAvail = 0, iBucket = 0; iBucket < cbucketChunk; iBucket++ )
		{
		if ( resVerPagesGlobal.fAvailNewest[iBucket] )
			cBucketAvail++;
		}

	if ( cBucketAvail <= cbucketLowerThreshold )
		{
		SignalSend( sigRCECleanProc );
		}

	/*	try to allocate bucket from already committed memory
	/**/
	for ( iBucket = 0;
		  !resVerPagesGlobal.fAvailNewest[iBucket] && iBucket < cbucketChunk;
		  iBucket++ );

	if ( iBucket < cbucketChunk )
		{
		INT		iblockLastChunk = ( resVerPagesGlobal.iblockCommit +
									resVerPagesGlobal.cblockCommit -
									cbucketChunk ) %
							   	  resVerPagesGlobal.cblockAlloc;
							
		pbucket = (BUCKET *) resVerPagesGlobal.pbAlloc + iblockLastChunk + iBucket;

		resVerPagesGlobal.fAvailNewest[iBucket] = fFalse;

		if ( resVerPagesGlobal.cblockCommit <= cbucketChunk )
			{
			resVerPagesGlobal.fAvailOldest[iBucket] = fFalse;
			}
			
		goto Done;
		}

	/*	need to commit more memory
	/**/
	Assert( iBucket == cbucketChunk );

	if ( resVerPagesGlobal.cblockCommit == resVerPagesGlobal.cblockAlloc )
		{
		/*	used up all the allocated version store pages
		/**/
		pbucket = pbucketNil;
		goto Done;
		}
	else
		{
		/*	reserved space is used in a wrap-around fashion for allocation of buckets
		/**/
		INT		iblockCommit = ( resVerPagesGlobal.iblockCommit + resVerPagesGlobal.cblockCommit )
							   % resVerPagesGlobal.cblockAlloc;
						
		BYTE	*pbCommit = resVerPagesGlobal.pbAlloc + iblockCommit * sizeof ( BUCKET );

		pbucket = (BUCKET *) PvUtilCommit( (VOID *) pbCommit,
										   cbucketChunk * sizeof( BUCKET ) );
									
		if ( pbucket != NULL )
			{
			memset( (void *) resVerPagesGlobal.fAvailNewest, 0xff, sizeof( resVerPagesGlobal.fAvailOldest ) );
			resVerPagesGlobal.fAvailNewest[0] = fFalse;
			resVerPagesGlobal.cblockCommit += cbucketChunk;
			if ( resVerPagesGlobal.cblockCommit == cbucketChunk )
				{
				memcpy( resVerPagesGlobal.fAvailOldest,
						resVerPagesGlobal.fAvailNewest,
						sizeof( resVerPagesGlobal.fAvailOldest ) );
				}
			}
		}

Done:
	CheckResVerPages( );	
	return pbucket;
	}


LOCAL VOID MEMReleasePbucket( BUCKET *pbucket, BOOL fNewest )
	{
	INT	iBucket = (INT)( pbucket - (BUCKET *) resVerPagesGlobal.pbAlloc ) % cbucketChunk;
	
	CheckResVerPages( );
	Assert( iBucket < cbucketChunk );

#ifdef DEBUG
	memset( (void *) pbucket, 0xff, sizeof( BUCKET ) );
#endif

	/* make bucket available
	/**/
	if ( fNewest )
		{
		resVerPagesGlobal.fAvailNewest[iBucket] = fTrue;

		if ( resVerPagesGlobal.cblockCommit <= cbucketChunk )
			{
			Assert( resVerPagesGlobal.cblockCommit == cbucketChunk );
			resVerPagesGlobal.fAvailOldest[iBucket] = fTrue;
			}

		/*	do not decommit chunk, even if free
		/**/
		goto Done;
		}

	Assert( !fNewest );
	Assert( pbucket >= (BUCKET *) resVerPagesGlobal.pbAlloc +
					   resVerPagesGlobal.iblockCommit );
	Assert( pbucket <= (BUCKET *) resVerPagesGlobal.pbAlloc +
					   resVerPagesGlobal.iblockCommit +
					   cbucketChunk );
	
	resVerPagesGlobal.fAvailOldest[iBucket] = fTrue;

	if ( resVerPagesGlobal.cblockCommit <= cbucketChunk )
		{
		Assert( resVerPagesGlobal.cblockCommit == cbucketChunk );
		resVerPagesGlobal.fAvailNewest[iBucket] = fTrue;
		}
		
	/*	release buckets if a chunk is freed
	/*	do not release last chunk unless fRCECleanProcTerm is true
	/**/
	for ( iBucket = 0; iBucket < cbucketChunk && resVerPagesGlobal.fAvailOldest[iBucket]; iBucket++ );

	if ( iBucket < cbucketChunk )
		{
		goto Done;
		}
	else if ( !fRCECleanProcTerm && resVerPagesGlobal.cblockCommit != cbucketChunk )
		{
		/*	all bucket in this chunk are free
		/*	decommit chunk
		/**/
		UtilDecommit( (void *) ( (BUCKET *) resVerPagesGlobal.pbAlloc + resVerPagesGlobal.iblockCommit ),
					  cbucketChunk * sizeof( BUCKET ) );

		Assert( resVerPagesGlobal.cblockCommit >= cbucketChunk );
		resVerPagesGlobal.cblockCommit -= cbucketChunk;
		resVerPagesGlobal.iblockCommit = ( resVerPagesGlobal.iblockCommit + cbucketChunk ) %
										 resVerPagesGlobal.cblockAlloc;

		if ( resVerPagesGlobal.cblockCommit == 0 )
			{
			/*	no committed chunks
			/**/
			Assert( fRCECleanProcTerm );
			memset( (void *) resVerPagesGlobal.fAvailOldest, 0, sizeof( resVerPagesGlobal.fAvailOldest ) );
			memset( (void *) resVerPagesGlobal.fAvailNewest, 0, sizeof( resVerPagesGlobal.fAvailNewest ) );
			}
		else if ( resVerPagesGlobal.cblockCommit <= cbucketChunk )
			{
			/*	newest and oldest chunk are the same
			/**/
			memcpy( resVerPagesGlobal.fAvailOldest,
					resVerPagesGlobal.fAvailNewest,
					sizeof( resVerPagesGlobal.fAvailOldest ) );
			}
		else
			{
			/*	no bucket is available
			/**/
			memset( resVerPagesGlobal.fAvailOldest, 0, sizeof( resVerPagesGlobal.fAvailOldest ) );
			}
		}

Done:
#ifdef DEBUG
	CheckResVerPages( );	
	pbucket = pbucketNil;
#endif
	return;
	}

	
//+local
//	ErrBUAllocBucket( )
//	========================================================
//	Inserts a bucket to the top of the bucket chain, so that new RCEs
//	can be inserted.  Note that the caller must set ibNewestRCE himself.
//-
INLINE LOCAL ERR ErrBUAllocBucket( )
	{
	BUCKET	*pbucket = PbucketMEMAlloc();

	SignalSend( sigRCECleanProc );

	/*	if no bucket available, then try to free one by
	/*	cleanning all PIBs.
	/**/
	if ( pbucket == pbucketNil )
		{
		(VOID)ErrRCECleanAllPIB();

		pbucket = PbucketMEMAlloc();
		if ( pbucket == pbucketNil )
			{
			BFSleep( cmsecWaitGeneric );
			(VOID) ErrRCECleanAllPIB();
	
			pbucket = PbucketMEMAlloc();
			}

		if ( pbucket == pbucketNil )
			{
			return ErrERRCheck( JET_errVersionStoreOutOfMemory );
			}
	
		MEMReleasePbucket( pbucket, fTrue );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	Assert( pbucket != NULL );

	if ( pbucketGlobal != pbucketNil )
		{
		pbucket->pbucketNext = pbucketNil;
		pbucket->pbucketPrev = pbucketGlobal;
		pbucketGlobal->pbucketNext = pbucket;
		pbucketGlobal = pbucket;
		pbucket->ibNewestRCE = 0;
		}
	else
		{
		pbucket->pbucketNext = pbucketNil;
		pbucket->pbucketPrev = pbucketNil;
		pbucketGlobal = pbucket;
		pbucket->ibNewestRCE = 0;
//		Assert( ppib->prceOldest == prceNil && ppib->prceNewest == prceNil );
		}

	return JET_errSuccess;
	}


#if 0
//+local
//	BUFreeNewestBucket( PIB *ppib )
//	==========================================================================
//	Delete the newest bucket of a bucket chain.
//
//-
INLINE LOCAL VOID BUFreeNewestBucket( PIB *ppib )
	{
	BUCKET *pbucket = (BUCKET *)ppib->pbucket;

	Assert( pbucket != pbucketNil );
	Assert( pbucket->pbucketNext == pbucketNil );

	if ( pbucket->pbucketPrev != pbucketNil )
		{
		ppib->pbucket = pbucket->pbucketPrev;
		ppib->pbucket->pbucketNext = pbucketNil;
		}
	else
		{
		ppib->pbucket = pbucketNil;
		ppib->ibOldestRCE = 0;
		}

	MEMReleasePbucket( pbucket );
	return;
	}
#endif


//+local
//	PbucketBUOldest( )
//	==========================================================================
//	find the oldest bucket in the bucket chain.
//
//-
INLINE LOCAL BUCKET *PbucketBUOldest( )
	{
	BUCKET  *pbucket = pbucketGlobal;

	if ( pbucket != pbucketNil )
		{
		while ( pbucket->pbucketPrev != pbucketNil )
			{
			pbucket = pbucket->pbucketPrev;
			}
		}

	return pbucket;
	}


//+local
//	BUFreeOldestBucket( )
//	==========================================================================
//	Delete the bottom (oldest) bucket of bucket chain.
//
//-
INLINE LOCAL VOID BUFreeOldestBucket( )
	{
	BUCKET *pbucket = PbucketBUOldest( );

	Assert( pbucket != pbucketNil );
	Assert( pbucket->pbucketPrev == pbucketNil );

	/*	unlink bucket from bucket chain and free.
	/**/
	if ( pbucket->pbucketNext != pbucketNil )
		{
		pbucket->pbucketNext->pbucketPrev = pbucketNil;
		Assert( pbucketGlobal != pbucket );
		}
	else
		{
		Assert( pbucketGlobal == pbucket );
		pbucketGlobal = pbucketNil;
		}

	MEMReleasePbucket( pbucket, fFalse );
	return;
	}


/****************** RCE Layer ******************************
/***********************************************************

A single hash table is used to access RCEs.  Typical hash
overflow is supported.  The method of hashing takes into account
pgno and itag properties to ensure that once hashed, if pgno
compares equal then itag must be equal.

************************************************************
***********************************************************/

/*	RCE hash table size
/**/
#define cprceGlobalHashTable              4096

/*	RCE hash table is an array of pointers to RCEHEAD
/**/
RCE *rgprceGlobalHashTable[cprceGlobalHashTable];

/*	XOR the lower byte of the page number and the itag.
/**/
#define UiRCHashFunc( bm )      (UINT) ( (((UINT)ItagOfSrid(bm)) << 4) ^ (PgnoOfSrid(bm) & 0x00000fff) )


VOID AssertRCEValid( RCE *prce )
	{
	Assert( prce->oper == operReplace ||
		prce->oper == operReplaceWithDeferredBI ||
		prce->oper == operInsert ||
		prce->oper == operFlagDelete ||
		prce->oper == operNull ||
		prce->oper == operDelta ||
		prce->oper == operInsertItem ||
		prce->oper == operFlagDeleteItem ||
		prce->oper == operFlagInsertItem );
	Assert( prce->level <= levelMax );
	Assert( prce->ibPrev < sizeof(BUCKET) );
	}


	/*  monitoring statistics  */

//unsigned long cRCEHashEntries;
//
//PM_CEF_PROC LRCEHashEntriesCEFLPpv;
//
//long LRCEHashEntriesCEFLPpv(long iInstance,void *pvBuf)
//{
//	if (pvBuf)
//		*((unsigned long *)pvBuf) = cRCEHashEntries;
//		
//	return 0;
//}
//
//unsigned long rgcRCEHashChainLengths[cprceGlobalHashTable];
//
//PM_CEF_PROC LRCEMaxHashChainCEFLPpv;
//
//long LRCEMaxHashChainCEFLPpv(long iInstance,void *pvBuf)
//{
//	unsigned long iprce;
//	unsigned long cMaxLen = 0;
//	
//	if (pvBuf)
//	{
//			/*  find max hash chain length  */
//
//		for (iprce = 0; iprce < cprceGlobalHashTable; iprce++)
//			cMaxLen = max(cMaxLen,rgcRCEHashChainLengths[iprce]);
//
//			/*  return max chain length * table size  */
//			
//		*((unsigned long *)pvBuf) = cMaxLen * cprceGlobalHashTable;
//	}
//		
//	return 0;
//}


//+local
//	FRCECorrect( DBID dbid1, SRID srid1, DBID dbid2, SRID srid2 )
//	==========================================================================
//	Checks whether two node are the same after hashing.  Since two
//	bookmarks with same pgno but different itag would hash to different
//	RCHashTable entry, if they hash to same entry and has same pgno, then
//	their itag must be the same.  A && ~B => ~C,  C && A => B.
//	(Where A == same pgno.  B == same itag.  C == same hash value.)
//-
#ifdef DEBUG
LOCAL BOOL FRCECorrect( DBID dbid1, SRID srid1, DBID dbid2, SRID srid2 )
	{
	Assert( PgnoOfSrid( srid1 ) != PgnoOfSrid( srid2 ) ||
		ItagOfSrid( srid1 ) == ItagOfSrid( srid2 ) );
	return ( srid1 == srid2 && dbid1 == dbid2 );
	}
#else
#define FRCECorrect( dbid1, srid1, dbid2, srid2 )       \
	( srid1 == srid2 && dbid1 == dbid2 )
#endif


//+local
//	PrceRCEGet( DBID dbid, SRID srid )
//	==========================================================================
//	Given a DBID and SRID, get the correct hash chain of RCEs.
//-
RCE *PrceRCEGet( DBID dbid, SRID bm )
	{
	RCE *prceChain;

	SgEnterCriticalSection( critVer );

	prceChain = rgprceGlobalHashTable[ UiRCHashFunc( bm ) ];

	while( prceChain != prceNil )
		{
		if ( FRCECorrect( dbid, bm, prceChain->dbid, prceChain->bm ) )
			{
			/*	assert hash chain not prceNil since empty chains are
			/*	removed from hash table.
			/**/
			SgLeaveCriticalSection( critVer );
			return prceChain;
			}
		prceChain = prceChain->prceHashOverflow;
		}

	SgLeaveCriticalSection( critVer );

	/*	no such node found
	/**/
	return prceNil;
	}


//+local
//	PprceRCEChainGet(DBID dbid, SRID bm )
//	==========================================================================
//	Given a SRID, get the correct RCEHEAD.
//-
INLINE LOCAL RCE **PprceRCEChainGet( DBID dbid, SRID bm )
	{
	RCE **pprceChain;

	SgAssertCriticalSection( critVer );

	pprceChain = &rgprceGlobalHashTable[ UiRCHashFunc( bm ) ];
	while ( *pprceChain != prceNil )
		{
		RCE *prceT = *pprceChain;

		if ( FRCECorrect( dbid, bm, prceT->dbid, prceT->bm ) )
			{
			return pprceChain;
			}
		pprceChain = &prceT->prceHashOverflow;
		}

	/*	no version chain found for node
	/**/
	return pNil;
	}


//+local
//	VERInsertRce( DBID dbid, SRID bm, RCE *prce )
//	==========================================================================
//	Inserts an RCE to hash table
//-
INLINE LOCAL VOID VERInsertRce( DBID dbid, SRID bm, RCE *prce )
	{
	RCE	**pprceChain;

	SgEnterCriticalSection( critVer );

	pprceChain = PprceRCEChainGet( dbid, bm );

	if ( pprceChain )
		{
		/*	hash chain for node already exists
		/**/
		RCE *prcePrevChain = *pprceChain;

		Assert( *pprceChain != prceNil );

		/* adjust head links
		/**/
		*pprceChain = prce;
		prce->prceHashOverflow = prcePrevChain->prceHashOverflow;
		prcePrevChain->prceHashOverflow = prceNil;

		/* adjust RCE links
		/**/
		prce->prcePrevOfNode = prcePrevChain;
		}
	else
		{
		/*	hash chain for node does not yet exist
		/**/
		UINT    uiRCHashValue = UiRCHashFunc( bm );

		/*	create new rce chain
		/**/
		prce->prceHashOverflow = rgprceGlobalHashTable[ uiRCHashValue ];
		rgprceGlobalHashTable[ uiRCHashValue ] = prce;

		/*	chain new RCE
		/**/
		prce->prcePrevOfNode = prceNil;
		}

	/*  monitor statistics  */

//	cRCEHashEntries++;
//	rgcRCEHashChainLengths[UiRCHashFunc(bm)]++;

	SgLeaveCriticalSection( critVer );
	}


//+local
//	VOID VERDeleteRce( RCE *prce )
//	==========================================================================
//	Deletes RCE from hashtable/RCE chain, and may set hash table entry to
//	prceNil.
//-
VOID VERDeleteRce( RCE *prce )
	{
	RCE	**pprce;

	Assert( prce != prceNil );
	Assert( prce->pbfDeferredBI == pbfNil );
	Assert( prce->prceDeferredBINext == prceNil );

	SgEnterCriticalSection( critVer );

	pprce = PprceRCEChainGet( prce->dbid, prce->bm );
	Assert( pprce != pNil );

	if ( *pprce == prce )
		{
		if ( prce->prcePrevOfNode )
			{
			*pprce = prce->prcePrevOfNode;
			(*pprce)->prceHashOverflow = prce->prceHashOverflow;
			}
		else
			*pprce = prce->prceHashOverflow;
		}
	else
		{
		/* search for the entry in the rce list
		/**/
		RCE *prceT = *pprce;

		while ( prceT->prcePrevOfNode != prce )
			{
			prceT = prceT->prcePrevOfNode;

			/* must be found
			/**/
			Assert( prceT != prceNil );
			}

		prceT->prcePrevOfNode = prce->prcePrevOfNode;
		}

	/*	set prcePrevOfNode to prceNil to prevent it from
	/*	being deleted again by commit/rollback.
	/**/
	prce->prcePrevOfNode = prceNil;

	/*  monitor statistics  */

//	cRCEHashEntries--;
//	rgcRCEHashChainLengths[UiRCHashFunc(prce->bm)]--;

	SgLeaveCriticalSection( critVer );
	return;
	}


/****************** Version Layer *************************
/**********************************************************
/**/

LOCAL ULONG RCECleanProc( VOID );


//+API
//	ErrVERInit( VOID )
//	=========================================================
//	Creates background version bucket clean up thread.
//-
ERR ErrVERInit( VOID )
	{
	ERR     err = JET_errSuccess;

 	/*	initialize critTrx used to protect trx used by version store.
	/**/
	CallR( ErrInitializeCriticalSection( &critCommit0 ) );

	/*	initialize version store hash table.
	/**/	
	memset( rgprceGlobalHashTable, 0, sizeof(rgprceGlobalHashTable) );

	/*	initialize global variables
	 */
	trxOldest = trxMax;
	trxNewest = 0;
#ifdef DEBUG
	cVersion = 0;
#endif

	/*  initialize monitoring statistics
	/**/
//	cRCEHashEntries = 0;
//	memset((void *)rgcRCEHashChainLengths,0,sizeof(rgcRCEHashChainLengths));

	/*	initialize resVerPagesGlobal
	/*	reserve memory for version store
	/*	number of buckets reserved must be a multiple of cbucketChunk
	/**/
	memset( (void *) &resVerPagesGlobal, 0, sizeof( resVerPagesGlobal ) );
	resVerPagesGlobal.cblockAlloc = rgres[iresVER].cblockAlloc / cbucketChunk * cbucketChunk;
	resVerPagesGlobal.pbAlloc = (BYTE *) PvUtilAlloc( resVerPagesGlobal.cblockAlloc * sizeof( BUCKET ) );
	if ( resVerPagesGlobal.pbAlloc == NULL )
		{
		resVerPagesGlobal.cblockAlloc = 0;
		return ErrERRCheck( JET_errVersionStoreOutOfMemory );
		}

	CallR( ErrInitializeCriticalSection( &critRCEClean ) );
	CallR( ErrInitializeCriticalSection( &critBMClean ) );

	CallR( ErrSignalCreateAutoReset( &sigRCECleanProc, NULL ) );

	Assert( ppibRCECleanGlobal == ppibNil );
	if ( !fRecovering )
		{
		CallR( ErrPIBBeginSession( &ppibRCECleanGlobal, procidNil ) );
		}

	fRCECleanProcTerm = fFalse;
	err = ErrUtilCreateThread( RCECleanProc, cbRCECleanStack,
		THREAD_PRIORITY_HIGHEST, &handleRCECleanProc );
	Call( err );

HandleError:
	return err;
	}


//+API
//	VOID VERTerm( BOOL fNormal )
//	=========================================================
//	Terminates background thread and releases version store
//	resources.
//-
VOID VERTerm( BOOL fNormal )
	{
	DeleteCriticalSection( critCommit0 );

	/*	terminate RCECleanProc
	/**/
	if ( handleRCECleanProc != 0 )
		{
		fRCECleanProcTerm = fTrue;
		LgLeaveCriticalSection( critJet );
		UtilEndThread( handleRCECleanProc, sigRCECleanProc );
		LgEnterCriticalSection( critJet );
		CallS( ErrUtilCloseHandle( handleRCECleanProc ) );
		handleRCECleanProc = 0;
		}

	if ( fNormal )
		{
		Assert( trxOldest == trxMax );
		CallS( ErrRCECleanAllPIB() );
		}

	if ( ppibRCECleanGlobal != ppibNil )
		{
		PIBEndSession( ppibRCECleanGlobal );
		ppibRCECleanGlobal = ppibNil;
		}
	
	SignalClose( sigRCECleanProc );

	DeleteCriticalSection( critBMClean );
	DeleteCriticalSection( critRCEClean );

	/*	deallocate resVerPagesGlobal
	/**/
	UtilFree( resVerPagesGlobal.pbAlloc );
	Assert( !fNormal || cVersion == 0 );
	return;
	}


//+API
//	FVERNoVersion
//	==========================================================================
//	Used by asynchronous clean process to reset version bits orphaned
//	by system crash.  Returns fTrue if no version exists for
//	given dbid:bm.
//
BOOL FVERNoVersion( DBID dbid, SRID bm )
	{
	return PrceRCEGet( dbid, bm ) == prceNil;
	}


//+API
//	FVERItemVersion
//	==========================================================================
//	Used by BMCleanup process to check if there any versions for item
//	bm is bookmark of itemlist [bookmark of first item]
//	
BOOL FVERItemVersion( DBID dbid, SRID bm, ITEM item )
	{
	RCE 	*prce = PrceRCEGet( dbid, bm );

	while ( prce != prceNil )
		{
		if ( FOperItem( prce->oper ) )
			{
			Assert( prce->cbData == sizeof( ITEM ) );
			Assert( *(SRID UNALIGNED *)prce->rgbData == BmNDOfItem( *(SRID *)prce->rgbData ) );
			if ( BmNDOfItem( item ) == *(SRID *) prce->rgbData )
				{
				return fTrue;
				}
			}
		prce = prce->prcePrevOfNode;
		}
	return fFalse;	
	}

	
//+API
//	VsVERCheck( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Given a SRID, returns the version status
//
//	RETURN VALUE
//		vsCommitted
//		vsUncommittedByCaller
//		vsUncommittedByOther
//
//-
VS VsVERCheck( FUCB *pfucb, SRID bm )
	{
	RCE *prce;

	/*	get the RCE of node from hash table
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );

	Assert( prce == prceNil || prce->oper != operNull);

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDResetNodeVersion( pfucb );
		return vsCommitted;
		}
	else if ( prce->trxCommitted != trxMax )
		{
		/*	committed
		/**/
		return vsCommitted;
		}
	else if ( prce->pfucb->ppib != pfucb->ppib )
		{
		/*	not modifier (uncommitted)
		/**/
		return vsUncommittedByOther;
		}
	else
		{
		/*	modifier (uncommitted)
		/**/
		Assert( prce->trxCommitted == trxMax );
		return vsUncommittedByCaller;
		}

	/*	invalid function return
	/**/
	Assert( fFalse );
	}


//+API
//	NsVERAccessNode( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Finds the correct version of a node.
//
//	PARAMETERS
//		pfucb			various fields used/returned.
//		pfucb->line		the returned prce or NULL to tell caller to
//						use the node in the DB page.
//
//	RETURN VALUE
//		nsVersion
//		nsDatabase
//		nsInvalid
//-
NS NsVERAccessNode( FUCB *pfucb, SRID bm )
	{
	RCE		*prce;
	TRX		trxSession;
	NS		nsStatus;

	/*	session with dirty cursor isolation model should never
	/*	call NsVERAccessNode.
	/**/
	Assert( !FPIBDirty( pfucb->ppib ) );

	/*	get trx for session.  Set to trxSession to trxMax if session
	/*	has committed or dirty cursor isolation model.
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trxBegin0;
	else
		trxSession = trxMax;

	SgEnterCriticalSection( critVER );

	/*	get first version for node
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );
	Assert( prce == prceNil ||
		prce->oper == operReplace ||
		prce->oper == operReplaceWithDeferredBI ||
		prce->oper == operInsert ||
		prce->oper == operFlagDelete ||
		prce->oper == operDelta );

	while ( prce != NULL && prce->oper == operDelta )
		prce = prce->prcePrevOfNode;

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDDeferResetNodeVersion( pfucb );
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted == trxMax &&
			  prce->pfucb->ppib == pfucb->ppib )
		{
		/*	if caller is modifier of uncommitted version then database
		/**/
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted < trxSession )
		{
		/*	if committed version
		/*	younger than our transaction then database
		/**/
		Assert( prce->trxPrev != trxMax );
		nsStatus = nsDatabase;
		}
	else
		{
		/*	look for correct version.  If caller is not in a transaction
		/*	then find the newest committed version.
		/**/
		if ( trxSession == trxMax )
			{
			/*	caller at transaction level 0
			/**/
			RCE *prcePrev;

			/*	loop finds newest committed version
			/**/
			for ( prcePrev = prce->prcePrevOfNode;
		 		  prce->trxPrev == trxMax;
				  prce = prcePrev, prcePrev = prce->prcePrevOfNode )
				{
				Assert( prce->oper == operReplace ||
					prce->oper == operReplaceWithDeferredBI ||
					prce->oper == operInsert ||
					prce->oper == operFlagDelete );
				while ( prcePrev != prceNil && prcePrev->oper == operDelta )
					prcePrev = prcePrev->prcePrevOfNode;
				if ( prcePrev == prceNil )
					break;
				}
			}
		else
			{
			/*	caller in a transaction
			/**/

			/*	loop will set prce to the RCE whose before image was committed
			/*	before this transaction began.
			/**/
			while ( prce->prcePrevOfNode != prceNil &&
				( prce->oper == operDelta ||
				prce->trxPrev >= trxSession ) )
				{
				Assert( prce->oper == operReplace ||
					prce->oper == operReplaceWithDeferredBI ||
					prce->oper == operInsert ||
					prce->oper == operFlagDelete );
				prce = prce->prcePrevOfNode;
				}
			}

		/*	during recovery, we never access before image of data that
		 *	was updated.
		 */
		Assert( prce->oper != operReplaceWithDeferredBI );

		if ( prce->oper == operReplace )
			{
			nsStatus = nsVersion;

			Assert( prce->cbData >= 4 );
			pfucb->lineData.pb = prce->rgbData + cbReplaceRCEOverhead;
			pfucb->lineData.cb = prce->cbData - cbReplaceRCEOverhead;
			}
		else if ( prce->oper == operInsert )
			{
			nsStatus = nsInvalid;
			}
		else
			{
			Assert( prce->oper == operFlagDelete );
			nsStatus = nsVerInDB;
			}
		}

	SgLeaveCriticalSection( critVer );
	return nsStatus;
	}


/*	returns fTrue if uncommitted increment or decrement version
/**/
BOOL FVERMostRecent( FUCB *pfucb, SRID bm )
	{
	RCE		*prce;
	TRX		trxSession;
	BOOL	fMostRecent;

	/*	session with dirty cursor isolation model should never
	/*	call NsVERAccessNode.
	/**/
	Assert( !FPIBDirty( pfucb->ppib ) );

	/*	get trx for session.  Set to trxSession to trxMax if session
	/*	has committed or dirty cursor isolation model.
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trxBegin0;
	else
		trxSession = trxMax;

	SgEnterCriticalSection( critVER );

	/*	get first version for node
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );
	Assert( prce == prceNil ||
		prce->oper == operReplace ||
		prce->oper == operReplaceWithDeferredBI ||
		prce->oper == operInsert ||
		prce->oper == operFlagDelete ||
		prce->oper == operDelta );

	while ( prce != NULL && prce->oper == operDelta )
		prce = prce->prcePrevOfNode;

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		fMostRecent = fTrue;
		}
	else if ( prce->trxCommitted == trxMax &&
  		prce->pfucb->ppib == pfucb->ppib )
		{
		fMostRecent = fTrue;
		}
	else if ( prce->trxCommitted < trxSession )
		{
		/*	if committed version
		/*	younger than our transaction then database
		/**/
		Assert( prce->trxPrev != trxMax );
		fMostRecent = fTrue;
		}
	else
		{
		fMostRecent = fFalse;
		}

	SgLeaveCriticalSection( critVer );
	return fMostRecent;
	}


BOOL FVERDelta( FUCB *pfucb, SRID bm )
	{
	RCE     *prce;
	BOOL    fUncommittedVersion = fFalse;

	/*	get prce for node and look for uncommitted increment/decrement
	/*	versions.  Note that these versions can only exist in
	/*	uncommitted state.
	/**/
	SgEnterCriticalSection( critVer );

	prce = PrceRCEGet( pfucb->dbid, bm );
	if ( prce != prceNil && prce->trxCommitted == trxMax )
		{
		forever
			{
			Assert( prce->level > 0 );
			if ( prce->oper == operDelta )
				{
				fUncommittedVersion = fTrue;
				break;
				}
			prce = prce->prcePrevOfNode;
			if ( prce == prceNil || prce->trxCommitted != trxMax )
				{
				Assert( fUncommittedVersion == fFalse );
				break;
				}
			}
		}

	SgLeaveCriticalSection( critVer );
	return fUncommittedVersion;
	}


//+API
//	ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
//	==========================================================================
//	Creates an RCE in a bucket and chain it up in the hash chain
//
//-
ERR ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
	{
	ERR		err = JET_errSuccess;
	RCE		*prce;
	INT		cbNewRCE;
	INT		ibFreeInBucket;
	BUCKET	*pbucket;

	Assert( PgnoOfSrid( bm ) != pgnoNull );
	Assert( bm != sridNull );
	Assert( pfucb->ppib->level > 0 );
	Assert( pfucb->u.pfcb != pfcbNil );

	Assert( !FDBIDVersioningOff( pfucb->dbid ) );

#ifdef DEBUG
	/*	assert correct bookmark
	/**/
	if ( !fRecovering && ( oper == operReplace || oper == operFlagDelete ) )
		{
		SRID	bmT;

		NDGetBookmark( pfucb, &bmT );
		Assert( bm == bmT );

		Assert( !FNDDeleted( *pfucb->ssib.line.pb ) );
		}
#endif

	/* set default return value
	/**/
	if ( pprce )
		*pprce = prceNil;

	if ( pfucb->ppib->level == 0 )
		return JET_errSuccess;

	SgEnterCriticalSection( critVer );

	/*	get bucket pointer
	/**/
	pbucket = pbucketGlobal;

	/*	find the starting point of the RCE in the bucket.
	/*	make sure the DBID with SRID is starting on a double-word boundary.
	/*	calculate the length of the RCE in the bucket.
	/*	if updating node, set cbData in RCE to length of data. (w/o the key).
	/*	set cbNewRCE as well.
	/**/
	if ( oper == operReplace || oper == operReplaceWithDeferredBI )
		{
		cbNewRCE = sizeof(RCE) + cbReplaceRCEOverhead + pfucb->lineData.cb;
		}
	else if ( FOperItem( oper ) )
		{
		cbNewRCE = sizeof(RCE) + sizeof(SRID);
		}
	else if ( oper == operDelta )
		{
	  	cbNewRCE = sizeof(RCE) + sizeof(LONG);
		}
	else
		{
		Assert( oper == operInsert || oper == operFlagDelete );
		cbNewRCE = sizeof(RCE);
		}

	/*	if insufficient bucket space, then allocate new bucket.
	/**/
	Assert( CbBUFree( pbucket ) >= 0 &&
		CbBUFree( pbucket ) < sizeof(BUCKET) );
	if ( cbNewRCE > CbBUFree( pbucket ) )
		{
		/*	ensure that buffer is not overlayed during
		/*	bucket allocation.
		/**/
		Call( ErrBUAllocBucket( ) );
		pbucket = pbucketGlobal;
		}
	Assert( cbNewRCE <= CbBUFree( pbucket ) );
	/*	pbucket always on double-word boundary
	/**/
	Assert( (BYTE *) pbucket == (BYTE *) PbAlignRCE ( (BYTE *) pbucket ));

	ibFreeInBucket = IbBUFree( pbucket );
	Assert( ibFreeInBucket < sizeof(BUCKET) );

	/*	set prce to next RCE location, and assert aligned
	/**/
	prce = (RCE *)( (BYTE *) pbucket + ibFreeInBucket );
	Assert( prce == (RCE *) PbAlignRCE( (BYTE *) pbucket + ibFreeInBucket ) );

	/*	set cbData
	/**/
	if ( oper == operReplace || oper == operReplaceWithDeferredBI )
		{
		prce->cbData = (WORD) ( cbReplaceRCEOverhead + pfucb->lineData.cb );
		}
	else if ( FOperItem( oper ) )
		{
		prce->cbData = sizeof(SRID);
		}
	else if ( oper == operDelta )
		{
		prce->cbData = sizeof(LONG);
		}
	else
		{
		prce->cbData = 0;
		}

	/*	oper must be set prior to calling VERInsertRce
	/**/
	prce->oper = oper;

	/*	if RCE for this operation should be chained to the
	/*	hash table then chain it.  Do this prior to setting version
	/*	bit in node, and incrementing page version count to simply
	/*	clean up.
	/**/
	Assert( prce->oper != operNull &&
		prce->oper != operDeferFreeExt &&
		prce->oper != operAllocExt &&
		!FOperDDL( prce->oper ) );

	/*	check RCE
	/**/
	Assert( prce == (RCE *) PbAlignRCE ( (BYTE *) prce ) );
	Assert( (BYTE *)prce - (BYTE *)pbucket == ibFreeInBucket );

	/*	set trx to max, to indicate RCE is uncommitted.  If previous RCE
	/*	then copy its trx into trxCommitted.  Later trxCommitted will
	/*	be updated with the commit time of this RCE, so that it may supply
	/*	this trx to subsequent RCEs on this node.
	/**/
	prce->dbid = pfucb->dbid;
	prce->bm = bm;
	prce->trxCommitted = trxMax;
	prce->pfucb = pfucb;
	prce->pfcb = pfcbNil;

	/* null bookmark
	/**/
	prce->bmTarget = sridNull;

	/*	reset rce deferred before image
	/**/
	prce->prceDeferredBINext = prceNil;
	prce->pbfDeferredBI = pbfNil;
#ifdef DEBUG
	prce->qwDBTimeDeferredBIRemoved = 0;
#endif

	/* pfucb must be assigned before InsertRce is called
	/**/
	VERInsertRce( pfucb->dbid, bm, prce );

	/*	if previous version then set trx to commit time
	/*	of previous version.  When this version commits, this time
	/*	will be moved to trx, and the commit time of this version will
	/*	be stored in the trx for subsequent version.
	/*	If there is no previous version, then store trxMax in trx.
	/**/
	if ( prce->prcePrevOfNode != prceNil )
		prce->trxPrev = prce->prcePrevOfNode->trxCommitted;
	else
		prce->trxPrev = trxMax;

	prce->level = pfucb->ppib->level;

	/*	If replacing node, rather than inserting or deleting node,
	/*	copy the data to RCE for before image for version readers.
	/*	Data size may be 0.
	/**/
		
	if ( oper == operReplace || oper == operReplaceWithDeferredBI )
		{
		SHORT *ps = (SHORT *)prce->rgbData;
		SHORT cbOldData;

		cbOldData = (WORD) pfucb->lineData.cb;
	
		/* set cbMax
		/**/
		if ( prce->prcePrevOfNode != prceNil &&
			 prce->prcePrevOfNode->level > 0 &&
			 ( prce->prcePrevOfNode->oper == operReplace ||
			   prce->prcePrevOfNode->oper == operReplaceWithDeferredBI )
		   )
			{
			RCE		*prcePrev = prce->prcePrevOfNode;
			SHORT	*psPrev = (SHORT *)prcePrev->rgbData;

			psPrev = (SHORT *)prcePrev->rgbData;
			*ps = max( (*psPrev), cbOldData );
			}
		else
			{
			/* set cbMax
			/**/
			*ps = cbOldData;
			}

		/* initialize cbDelta. Caller will correct it later.
		/**/
		ps++;
		*ps = 0;

		Assert( prce->cbData >= cbReplaceRCEOverhead );

		if ( oper == operReplace )
			{
			BF *pbf = pfucb->ssib.pbf;

			AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
			AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

			/* move to data byte and copy old data (before image)
			/**/
			ps++;
			memcpy( (BYTE *)ps, pfucb->lineData.pb, pfucb->lineData.cb );

			/*	attach to defer BI links.
			 */
			if ( !fLogDisabled &&
				 FDBIDLogOn( DbidOfPn( pbf->pn ) ) )
				{
				Assert( prce->cbData > cbReplaceRCEOverhead );
				BFEnterCriticalSection( pbf );
				prce->pbfDeferredBI = pbf;
				prce->prceDeferredBINext = pbf->prceDeferredBINext;
				pbf->prceDeferredBINext = prce;
#ifdef DEBUG
				{
				RCE **pprceNext = &pbf->prceDeferredBINext;
				while( *pprceNext != prceNil )
					{
					Assert( (*pprceNext)->pbfDeferredBI == pbf );
					pprceNext = &(*pprceNext)->prceDeferredBINext;
					}
				}
#endif
				BFLeaveCriticalSection( pbf );
				}
			}
#ifdef DEBUG
		else
			{
		    Assert( oper == operReplaceWithDeferredBI );
			ps++;
			memset( (BYTE *)ps, '*', pfucb->lineData.cb );
			}
#endif
		}

	else if ( FOperItem( oper ) )
		{
		*(SRID *)prce->rgbData = BmNDOfItem( PcsrCurrent(pfucb)->item );
		}

	else if ( oper == operDelta )
		{
		Assert( pfucb->lineData.cb == sizeof(LONG) );
		*(LONG *)prce->rgbData = *(LONG UNALIGNED *)pfucb->lineData.pb;
		}

	/*	set index to last RCE in bucket, and set new last RCE in bucket.
	/*	If this is the first RCE in bucket, then set index to 0.
	/**/
	prce->ibPrev = (USHORT)pbucket->ibNewestRCE;
	Assert( prce->ibPrev < sizeof(BUCKET) );
	pbucket->ibNewestRCE = ibFreeInBucket;

	/*	set RCE pointers for session
	/**/
	prce->prcePrevOfSession = pfucb->ppib->prceNewest;
	if ( prce->prcePrevOfSession != prceNil )
		{
		Assert( prce->prcePrevOfSession->prceNextOfSession == prceNil );
		prce->prcePrevOfSession->prceNextOfSession = prce;
		}
	PIBSetPrceNewest( pfucb->ppib, prce );
	prce->prceNextOfSession = prceNil;

	Assert( prce->oper != operNull );

	if ( pprce )
		*pprce = prce;

	/*	no RCE follows delete in regular run.
	/*  BM clean up check the old version is not there before
	/*  starting, but in redo we do not know when to clean up old
	/*  versions. So ignore the following assert for redo.
	/**/
	Assert( fRecovering ||
		prce->prcePrevOfNode == prceNil ||
		prce->prcePrevOfNode->oper != operFlagDelete );

#ifdef DEBUG
	if ( FOperItem( prce->oper ) )
		{
		Assert( prce->oper == operFlagDeleteItem ||
			prce->oper == operInsertItem ||
			prce->oper == operFlagInsertItem );
		}

	/*	no RCE at same level unless belong to same user.  Note that
	/*	item delete item operations may have operations on
	/*	other items as the prev RCE.
	/*
	/*	Note that this assert is only applicable for non-item operations,
	/*	since item operations on different items are keyed with the same
	/*	bookmark, i.e. first item list node bookmark.
	/**/
	if ( !fRecovering &&
		prce->prcePrevOfNode != prceNil &&
		!FOperItem( prce->oper ) &&
		prce->oper != operDelta &&
		prce->prcePrevOfNode->level > 0 )
		{
		/*	check FOperItem filter
		/**/
		Assert( prce->oper != operFlagDeleteItem &&
			prce->oper != operFlagInsertItem );
		Assert( prce->oper != operDelta );
		Assert( prce->level > 0 && prce->prcePrevOfNode->level > 0 );
		Assert( prce->prcePrevOfNode->pfucb->ppib == prce->pfucb->ppib );
		}
#endif	// DEBUG

	Assert( err == JET_errSuccess );

	/*	flag FUCB version
	/**/
	FUCBSetVersioned( pfucb );

	Assert( prce->oper != operDeferFreeExt );
	Assert( pfucb->u.pfcb != pfcbNil );
	prce->pfcb = pfucb->u.pfcb;
	FCBVersionIncrement( pfucb->u.pfcb );
	Assert( ++cVersion > 0 );

HandleError:
	SgLeaveCriticalSection( critVer );
	return err;
	}


/*	adjust delta of version with new delta from same session at
/*	same transaction level, or from version committed to same
/*	transaction level as version.
/**/
#define VERAdjustDelta( prce, lDelta )				\
	{												\
	Assert( (prce)->oper == operDelta );			\
	Assert( (prce)->cbData == sizeof(LONG) );		\
	*(LONG *)(prce)->rgbData += (lDelta);			\
	}


//+API
//	ErrVERModify( FUCB *pfucb, OPER oper, RCE **pprce )
//	=======================================================
//	Create an RCE for the modification for session.
//
//	RETURN VALUE
//		Jet_errWriteConflict for two cases:
//			-for any committed node, caller's transaction begin time
//			is less than node's level 0 commit time.
//			-for any uncommitted node at all by another session
//-
ERR ErrVERModify( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
	{
	ERR     err = JET_errSuccess;
	RCE     *prce;
	TRX     trxSession;

	/* set default return value
	/**/
	if ( pprce )
		*pprce= prceNil;

	Assert( !FDBIDVersioningOff( pfucb->dbid ) );

	/*	set trxSession based on cim model
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trxBegin0;
	else
		trxSession = trxMax;

	/*	get RCE
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );

	/*	if it is for item operation, need go down further to the
	/*	RCE for item list node and for item if present.  Note that
	/*	this search does not have to be done for operInsertItem
	/*	versions since no previous item can exist when an item is
	/*	being inserted.
	/**/
	if ( prce != prceNil && ( oper == operFlagInsertItem || oper == operFlagDeleteItem ) )
		{
		while ( *(SRID *)prce->rgbData != PcsrCurrent( pfucb )->item )
			{
			Assert( oper == operFlagInsertItem ||
				oper == operFlagDeleteItem );
			prce = prce->prcePrevOfNode;
			if ( prce == prceNil )
				break;
			}
		}

	Assert( prce == prceNil || prce->oper != operNull);

	if ( prce == prceNil )
		{
#ifdef DEBUG
		if ( !fRecovering && ( oper == operReplace || oper == operFlagDelete ))
			{
			if ( !fRecovering )
				{
				AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
				Assert( !( FNDDeleted( *pfucb->ssib.line.pb ) ) );
				}
			}
#endif
		Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
		}
	else
		{
		if ( prce->trxCommitted == trxMax &&
			 prce->pfucb->ppib == pfucb->ppib )
			{
			/* BM clean up check the old version is not there before
			/* starting, but in redo we do not know when to clean up old
			/* versions. So ignore the following assert for redo.
			/**/
			Assert( fRecovering || prce->oper != operFlagDelete );

			/*	if this RCE was created by the requestor
			/*	If no RCE exists for this user at this Xact level.
			/**/
			Assert ( prce->level <= pfucb->ppib->level );
			if ( prce->level != pfucb->ppib->level )
				{
				/*	RCE not exists at this level
				/**/
				Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
				}
			else
				{
				//	RCE exists at this level
				//-------------------------------------------------
				//	Action table.  Nine cases, all within same Xact level:
				//	the table reduces to create RCE if operDelete
				//-------------------------------------------------
				//	Situation			Action
				//-------------------------------------------------
				//	Del after Del		impossible
				//	Del after Ins		create another RCE
				//	Del after Rep		create another RCE
				//	Ins after Del		impossible
				//	Ins after Rep		impossible
				//	Ins after Ins		impossible
				//	Rep after Del		impossible
				//	Rep after Ins		do nothing
				//	Rep after Rep		do nothing
				//-------------------------------------------------
				if ( oper == operReplace || oper == operReplaceWithDeferredBI )
					{
					//	UNDONE:	fix handling of prceLast so
					//	that in place updates are efficient but
					//	still logged as undoable.
					if ( pprce != NULL )
						{
						*pprce = prce;
						Assert( err == JET_errSuccess );
						}
					}
				else if ( oper == operDelta && prce->oper == operDelta )
					{
					Assert( pfucb->lineData.cb == sizeof(LONG) );
					Assert( prce->pfucb->ppib == pfucb->ppib );
					VERAdjustDelta( prce, *( (LONG UNALIGNED *)pfucb->lineData.pb ) );
					}
				else
					{
					Assert( oper == operFlagDelete ||
						oper == operFlagDeleteItem ||
						oper == operFlagInsertItem ||
						oper == operDelta );
					Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
					}
				}
			}
		else
			{
			/*	RCE was not created by requestor
			/*	If RCE committed and is older than caller's Xact begin
			/**/
			if ( prce->trxCommitted < trxSession )
				{
				/*	if previous RCE is at level 0, then flag insert
				/*	item may have been committed and cleaned up
				/*	out of order to the flag delete item version
				/**/
				Assert( fRecovering || prce->oper != operFlagDelete );
				Assert( oper == operFlagInsertItem ||
					prce->level == 0 ||
					prce->oper != operFlagDeleteItem );
				Assert( (ULONG)prce->trxCommitted < trxSession );

				/*	if prce->trxPrev is less than transaction trx then
				/*	it must be committed.
				/**/
				Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
				}
			else
				{
				/*	caller is looking at a versioned node in an RCE, so
				/*	disallow any modification/delete
				/**/
				err = ErrERRCheck( JET_errWriteConflict );
				}
			}
		}

HandleError:
	Assert( err < 0 || pprce == NULL || *pprce != prceNil );
	return err;
	}


// Space which has been freed, but must be reserved in case of rollback is called
// "uncommitted freed" (essentially, cbUncommittedFreed is just a count of the
// total reserved node space on a page).  This function is called whenever
// a node shrinks, or whenever node growth is rolled back and reserved node space
// is reallocated.
INLINE LOCAL VOID VERAddUncommittedFreed( PAGE *ppage, INT cbToAdd )
	{
	Assert( cbToAdd > 0 );
	Assert( (INT)ppage->cbFree >= cbToAdd );	// cbFree should already have been adjusted.
	ppage->cbUncommittedFreed += (SHORT)cbToAdd;
	Assert( ppage->cbFree >= ppage->cbUncommittedFreed );

	return;
	}


// Reclaim space originally freed when a node shrunk during this transaction.
// This function is used when the same node is now growing, or when the node shrinkage
// is being rolled back.
INLINE LOCAL VOID VERReclaimUncommittedFreed( PAGE *ppage, INT cbToReclaim )
	{
	Assert( cbToReclaim > 0 );
	Assert( ppage->cbFree >= ppage->cbUncommittedFreed );
	Assert( (INT)ppage->cbUncommittedFreed >= cbToReclaim );
	ppage->cbUncommittedFreed -= (SHORT)cbToReclaim;

	return;
	}



VOID VERSetCbAdjust( FUCB *pfucb, RCE *prce, INT cbDataNew, INT cbData, BOOL fUpdatePage )
	{
	SHORT 	*ps;
	INT		cbMax;
	INT		cbDelta = cbDataNew - cbData;

	Assert( prce != prceNil );
	Assert( prce->bm == PcsrCurrent( pfucb )->bm );
	Assert( ( prce->oper != operReplace && prce->oper != operReplaceWithDeferredBI )
			|| *(SHORT *)prce->rgbData >= 0 );
	Assert( cbDelta != 0 );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( prce->oper != operReplace && prce->oper != operReplaceWithDeferredBI )
		return;

	ps = (SHORT *)prce->rgbData;
	cbMax = *ps;

	/*	set new node maximum size.
	/**/
	if ( cbDataNew > cbMax )
		*ps = (SHORT)cbDataNew;
	ps++;


	// WARNING:  The following comments explain how a Replace RCE's delta field
	// (ie. the second SHORT stored in rgbData) is used.  The semantics can get
	// pretty confusing, so PLEASE DO NOT REMOVE THESE COMMENTS.  -- JL

	/*  *ps records how much the operation contributes to deferred node
	 *  space reservation. A positive cbDelta here means the node is growing,
	 *	so we will use up space which may have been reserved (ie. *ps will
	 *	decrease).  A negative cbDelta here means the node is shrinking,
	 *	so we must add abs(cbDelta) to the *ps to reflect how much more node
	 *	space must be reserved.
	 *
	 *	This is how to interpret the value of *ps:
	 *		- if *ps is positive, then *ps == reserved node space.  *ps can only
	 *		  be positive after a node shrinkage.
	 *		- if *ps is negative, then abs(*ps) is the reserved node space that
	 *		  was consumed during a node growth.  *ps can only become negative
	 *		  after a node shrinkage (which sets aside some reserved node space)
	 *		  followed by a node growth (which consumes some/all of that
	 *		  reserved node space).
	 */

	if ( cbDelta > 0 )
		{
		/*	node is enlarged.  Free any allocated free space.
		/**/
		Assert( cbData <= cbMax );
	
		/*  check if cbDelta is greater then the reserved bytes so far,
		 *  if so, then free all the reserved space.
		 */
 		if ( cbDelta > cbMax - cbData )
			{
			/* new data is largest one, free all previous reserved space */
			cbDelta = cbMax - cbData;
			}

		Assert( cbDelta >= 0 );

		if ( fUpdatePage  &&  cbDelta > 0 )
			{
			// If, during this transaction, we've shrunk the node.  There will be
			// some uncommitted freed space.  Reclaim as much of this as needed to
			// satisfy the new node growth.  Note that we can update cbUncommittedFreed
			// in this fashion because the subsequent call to ErrPMReplace() is
			// guaranteed to succeed (ie. the node is guaranteed to grow).
			VERReclaimUncommittedFreed( pfucb->ssib.pbf->ppage, cbDelta );
			}
		}

	else if ( fUpdatePage )
		{
		Assert( cbDelta < 0 );

		// Node has decreased in size.  The page header's cbFree has already
		// been increased to reflect this.  But we must also increase
		// cbUncommittedFreed to indicate that the increase in cbFree is
		// contingent on commit of this operation.
		VERAddUncommittedFreed( pfucb->ssib.pbf->ppage, -cbDelta );
		}

	*ps -= (SHORT)cbDelta;

/*
#ifdef DEBUG
	{
	INT cb = CbVERGetCbReserved( prce );
	Assert( cb == 0 || cb == (*(SHORT *)prce->rgbData) - cbDataNew );
	}
#endif
*/

	return;
	}


INT CbVERGetNodeMax( DBID dbid, SRID bm )
	{
	RCE	*prce;

	// Look for any replace RCE's.
	for ( prce = PrceRCEGet( dbid, bm );
		prce != prceNil  &&  prce->trxCommitted == trxMax;
		prce = prce->prcePrevOfNode )	
		{
		if ( prce->oper == operReplace || prce->oper == operReplaceWithDeferredBI )
			return *(SHORT *)prce->rgbData;
		}

	return 0;
	}


INT CbVERGetNodeReserve( PIB *ppib, DBID dbid, SRID bm, INT cbCurrentData )
	{
	RCE		*prce;
	PIB		*ppibCurr;
	BOOL	fIgnorePIB = ( ppib == ppibNil );
	INT		cbReserved = 0;

	Assert( cbCurrentData >= 0 );
	
	// Find all uncommitted RCE's for this node.
	prce = PrceRCEGet( dbid, bm );

	if ( prce != prceNil )
		{
		if ( fIgnorePIB || prce->pfucb->ppib == ppib )
			{
			ppibCurr = prce->pfucb->ppib;
			for( ; prce != prceNil && prce->trxCommitted == trxMax; prce = prce->prcePrevOfNode )
				{
				Assert( prce->bm == bm );
				Assert( prce->pfucb->ppib == ppibCurr );
				if ( prce->oper == operReplace  ||  prce->oper == operReplaceWithDeferredBI )
					cbReserved += *( (SHORT *)prce->rgbData + 1 );
				}

			// The deltas should always net out to a positive value.
			Assert( cbReserved >= 0 );

			Assert(	cbReserved == 0  ||
					cbReserved == CbVERGetNodeMax( dbid, bm ) - (INT)cbCurrentData );
			}

#ifdef DEBUG
		else
			{
			// This RCE wasn't ours.  Verify that other RCE's for this node were
			// not ours as well.
			Assert( ppib != ppibNil );
			for( ; prce != prceNil && prce->trxCommitted == trxMax; prce = prce->prcePrevOfNode )
				{
				Assert( prce->pfucb->ppib != ppib );
				}
			}
#endif
		}

	return cbReserved;
	}


INT CbVERUncommittedFreed( BF *pbf )
	{
	DBID	dbid = DbidOfPn( pbf->pn );
	PGNO	pgnoThisPage = PgnoOfPn( pbf->pn );
	PAGE	*ppage = pbf->ppage;
	INT		itag;
	TAG		*ptag;
	BYTE	*pnode;
	INT		cbActualUncommitted = 0;
	SRID	bm;

	SgEnterCriticalSection( critVer );

	for ( itag = 0; itag < ppage->ctagMac; itag++ )
		{
		// Only care about those itags that are not on the freed list.
		if ( TsPMTagstatus( ppage, itag ) == tsLine )
			{
			ptag = ppage->rgtag + itag;
			Assert( ptag->cb > 0 );

			// Look for versioned nodes.
			pnode = (BYTE *)ppage + ptag->ib;
			if ( FNDVersion( *pnode ) )
				{
				bm = ( FNDBackLink( *pnode ) ?
					*( (SRID UNALIGNED *)PbNDBackLink( pnode ) ) :
					SridOfPgnoItag( pgnoThisPage, itag ) );

				cbActualUncommitted +=
					CbVERGetNodeReserve( ppibNil, dbid, bm, CbNDData( pnode, ptag->cb ) );
				}
			}
		}

	SgLeaveCriticalSection( critVer );

	// The actual amount of space currently uncommitted should be less than the
	// total amount of space that was possibly uncommitted.
	// The caller of this function will likely update the page header accordingly.
	Assert( cbActualUncommitted <= ppage->cbUncommittedFreed );

	return cbActualUncommitted;
	}


// This function is called after it has been determined that cbFree will satisfy
// cbReq. We now check that cbReq doesn't use up any uncommitted freed space.
BOOL FVERCheckUncommittedFreedSpace( BF *pbf, INT cbReq )
	{
	PAGE	*ppage = pbf->ppage;
	BOOL	fEnoughPageSpace = fTrue;

	SgEnterCriticalSection( critPage );

	ppage = pbf->ppage;

	// We should already have performed the check against cbFree only (in other
	// words, this function is only called from within FNDFreePageSpace(),
	// or something that simulates its function).  This tells us that if all
	// currently-uncommitted transactions eventually commit, we should have
	// enough space to satisfy this request.
	Assert( cbReq <= ppage->cbFree );

	// The amount of space freed but possibly uncommitted should be a subset of
	// the total amount of free space for this page.
	Assert( ppage->cbUncommittedFreed >= 0 );
	Assert( ppage->cbFree >= ppage->cbUncommittedFreed );

	// In the worst case, all transactions that freed space on this page will
	// rollback, causing the space freed to be reclaimed.  If the space
	// required can be satisfied even in the worst case, then we're okay;
	// otherwise, we have to do more checking.
	if ( cbReq > ( ppage->cbFree - ppage->cbUncommittedFreed ) )
		{
		// Try updating cbUncommittedFreed, in case some freed space was committed.
		ppage->cbUncommittedFreed = (SHORT)CbVERUncommittedFreed( pbf );

		// The amount of space freed but possibly uncommitted should be a subset of
		// the total amount of free space for this page.
		Assert( ppage->cbUncommittedFreed >= 0 );
		Assert( ppage->cbFree >= ppage->cbUncommittedFreed );

		fEnoughPageSpace =
			( cbReq <= ( ppage->cbFree - ppage->cbUncommittedFreed ) );
		}

	SgLeaveCriticalSection( critPage );

	return fEnoughPageSpace;
	}



//+API
//	NS NsVERAccessItem( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Finds the correct version of an item.
//
//	PARAMETERS
//		pfucb			various fields used/returned.
//		bm				bookmark of first node in item list
//		pnsStatus		code to indicate the right place for the node.
//
//	RETURN VALUE
//		nsVersion
//		nsDatabase
//		nsInvalid
//-
NS NsVERAccessItem( FUCB *pfucb, SRID bm )
	{
	RCE		*prce;
	SRID	bmT = BmNDOfItem( PcsrCurrent(pfucb)->item );
	TRX		trxSession;
	NS		nsStatus;

	/*	session with dirty cursor isolation model should never
	/*	call ErrVERAccess*.
	/**/
	Assert( !FPIBDirty( pfucb->ppib ) );

	/*	get trx for session.  Set to trxSession to trxMax if session
	/*	has committed or dirty cursor isolation model.
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trxBegin0;
	else
		trxSession = trxMax;

	SgEnterCriticalSection( critVer );

	/*	get first version for node.
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );
	Assert( prce == prceNil || FOperItem( prce->oper ) );

	/*	if this RCE is not for fucb index, then move back in
	/*	RCE chain until prceNil or until latest RCE for item and
	/*	current index found.
	/**/
	while ( prce != prceNil &&
			( !FOperItem( prce->oper ) || *(SRID *)prce->rgbData != bmT ) )
		{
		prce = prce->prcePrevOfNode;
		}
	Assert( prce == prceNil || FOperItem( prce->oper ) );

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDResetItemVersion( pfucb );
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted == trxMax &&
			  prce->pfucb->ppib == pfucb->ppib )
		{
		/*	if caller is modifier of uncommitted version then database
		/**/
		Assert( prce->trxCommitted == trxMax );
		nsStatus = nsDatabase;
		}
	else if ( trxSession > prce->trxCommitted )
		{
		/*	if no uncommitted version and committed version
		/*	younger than our transaction then database
		/**/
		Assert( prce->trxPrev != trxMax || prce->trxCommitted == trxMax );
		nsStatus = nsDatabase;
		}
	else
		{
		/*	get correct RCE for this item and session trx.
		/**/
		if ( trxSession == trxMax )
			{
			/*	caller at transaction level 0
			/**/
			RCE     *prcePrev;

			/*	loop finds newest committed version
			/**/
			for ( prcePrev = prce->prcePrevOfNode;
				prce->trxPrev == trxMax;
				prce = prcePrev, prcePrev = prce->prcePrevOfNode )
				{
				/*	get next RCE for this item.
				/**/
				while ( prcePrev != prceNil &&
					  ( !FOperItem( prcePrev->oper ) || *(SRID *)prcePrev->rgbData != bmT ) )
					{
					prcePrev = prcePrev->prcePrevOfNode;
					}
				Assert( prcePrev == prceNil || FOperItem( prcePrev->oper ) );

				/*	if no more RCE then break;
				/**/
				if ( prcePrev == prceNil )
					break;
				}
			}
		else
			{
			/*	caller is in a transaction
			/**/
			RCE     *prcePrev;

			/*	loop will set prce to the RCE whose before image was committed
			/*	before this transaction began.
			/**/
			for ( prcePrev = prce->prcePrevOfNode;
				prce->trxPrev >= trxSession;
				prce = prcePrev, prcePrev = prce->prcePrevOfNode )
				{
				/*	get next RCE for this item.
				/**/
				while ( prcePrev != prceNil &&
					  ( !FOperItem( prcePrev->oper ) || *(SRID *)prcePrev->rgbData != bmT ) )
					{
					prcePrev = prcePrev->prcePrevOfNode;
					}
				Assert( prcePrev == prceNil || FOperItem( prcePrev->oper ) );

				/*	if no more RCE then break;
				/**/
				if ( prcePrev == prceNil )
					break;
				}
			}

		Assert( prce != prceNil );
		Assert( *(SRID *)prce->rgbData == bmT );

		/*	if RCE is uncommitted without previous committed RCE or
		/*	RCE was committed before session transcation start or
		/*	RCE is not committed then if not insert then the item is there.
		/*	otherwise it is not there.
		/*	Note that >= must be used when comparing trxCommitted to trxSession
		/*	so that case of trxCommitted == trxMax is handled properly.
		/**/
		if ( ( prce->trxPrev == trxMax || prce->trxCommitted >= trxSession ) ^ ( prce->oper == operInsertItem ) )
			nsStatus = nsVersion;
		else
			nsStatus = nsInvalid;
		}

	SgLeaveCriticalSection( critVer );
	return nsStatus;
	}


ERR ErrVERFlag( FUCB *pfucb, OPER oper, VOID *pv, INT cb )
	{
	ERR		err = JET_errSuccess;
	BUCKET	*pbucket;
	INT		cbT;
	INT		ibFreeInBucket;
	RCE		*prce;

	Assert( pfucb->ppib->level > 0 );
	Assert( oper == operAllocExt ||
		oper == operDeferFreeExt ||
		FOperDDL( oper ) );

	if ( FDBIDVersioningOff(pfucb->dbid) )
		{
		Assert( !FDBIDLogOn(pfucb->dbid) );
		Assert( !fRecovering );
		return JET_errSuccess;
		}

	SgEnterCriticalSection( critVer );

	pbucket = pbucketGlobal;
	cbT = sizeof(RCE) + cb;

	/*	if insufficient bucket space, then allocate new bucket.
	/**/
	Assert( CbBUFree( pbucket ) >= 0 &&
		CbBUFree( pbucket ) < sizeof(BUCKET) );
	if ( cbT > CbBUFree( pbucket ) )
		{
		Call( ErrBUAllocBucket( ) );
		pbucket = pbucketGlobal;
		}
	Assert( cbT <= CbBUFree( pbucket ) );

	/*	pbucket always on double-word boundary
	/**/
	Assert( (BYTE *) pbucket == (BYTE *) PbAlignRCE ( (BYTE *) pbucket ) );
	ibFreeInBucket = IbBUFree( pbucket );
	Assert( ibFreeInBucket < sizeof(BUCKET) );

	/*	set prce to next RCE location, and assert aligned
	/**/
	prce = (RCE *)( (BYTE *) pbucket + ibFreeInBucket );
	Assert( prce == (RCE *) PbAlignRCE( (BYTE *) pbucket + ibFreeInBucket ) );
	prce->prcePrevOfNode = prceNil;
	prce->dbid = pfucb->dbid;
	prce->bm = sridNull;
	prce->trxPrev = trxMax;
	prce->trxCommitted = trxMax;
	prce->oper = oper;
	prce->level = pfucb->ppib->level;
	prce->pfucb = pfucb;
	prce->pfcb = pfcbNil;
	prce->bmTarget = sridNull;
	prce->prceDeferredBINext = prceNil;
	prce->pbfDeferredBI = pbfNil;
#ifdef DEBUG
	prce->qwDBTimeDeferredBIRemoved = 0;
#endif
	prce->cbData = (USHORT)cb;
	memcpy( prce->rgbData, pv, cb );

	/*	set RCE pointers for session
	/**/
	prce->prcePrevOfSession = pfucb->ppib->prceNewest;
	if ( prce->prcePrevOfSession != prceNil )
		{
		Assert( prce->prcePrevOfSession->prceNextOfSession == prceNil );
		prce->prcePrevOfSession->prceNextOfSession = prce;
		}
	PIBSetPrceNewest( pfucb->ppib, prce );
	prce->prceNextOfSession = prceNil;

	/*	set index to last RCE in bucket, and set new last RCE in bucket.
	/*	If this is the first RCE in bucket, then set index to 0.
	/**/
	prce->ibPrev = (USHORT)pbucket->ibNewestRCE;
	Assert( prce->ibPrev < sizeof(BUCKET) );
	pbucket->ibNewestRCE = ibFreeInBucket;

	/*	flag FUCB version
	/**/
	FUCBSetVersioned( pfucb );

	if ( prce->oper == operDeferFreeExt )
		{
		/*	increment reference version against parent domain FCB
		/*	and reference space operation against domain
		/**/
		FCB *pfcbT = PfcbFCBGet( prce->dbid, ((VEREXT *)prce->rgbData)->pgnoFDP );
		Assert( pfcbT != NULL );

		prce->pfcb = pfcbT;
		FCBVersionIncrement( pfcbT );
		Assert( ++cVersion > 0 );
		}
	else
		{
		Assert( prce->oper != operDeleteTable ||
			( cb == sizeof( PGNO )  &&  pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot ) );
		prce->pfcb = pfucb->u.pfcb;
		FCBVersionIncrement( pfucb->u.pfcb );
		Assert( ++cVersion > 0 );
		}

HandleError:
	SgLeaveCriticalSection( critVer );
	return err;
	}


/********************* RCE CLEANUP ************************
/**********************************************************
/**/
INLINE LOCAL VOID VERFreeExt( FCB *pfcb, PGNO pgnoFirst, CPG cpg )
	{
	ERR     err;
	FUCB    *pfucb = pfucbNil;

	Assert( !fRecovering );
	LeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	EnterNestableCriticalSection( critRCEClean );
	EnterCriticalSection( critJet );

	Call( ErrDBOpenDatabaseByDbid( ppibRCECleanGlobal, pfcb->dbid ) );
	Call( ErrDIROpen( ppibRCECleanGlobal, pfcb, pfcb->dbid, &pfucb ) );
	Call( ErrDIRBeginTransaction( ppibRCECleanGlobal ) );
	(VOID)ErrSPFreeExt( pfucb, pfcb->pgnoFDP, pgnoFirst, cpg );
	err = ErrDIRCommitTransaction( ppibRCECleanGlobal, JET_bitCommitLazyFlush );
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( ppibRCECleanGlobal ) );
		}

HandleError:
	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		}

	(VOID)ErrDBCloseDatabase( ppibRCECleanGlobal, pfcb->dbid, 0 );

	LeaveNestableCriticalSection( critRCEClean );
	LeaveNestableCriticalSection( critSplit );

	return;
	}


//+API
//	ERR ErrRCEClean( PIB *ppib, BOOL fCleanSession )
//	==========================================================================
//	Cleans RCEs in bucket chain.
//	We only clean up the RCEs that has a commit timestamp older
//	that the oldest XactBegin of any user.
//	If fCleanSession is set, it cleans all RCE's of the given session
//	
//	PARAMETER
//-
ERR ErrRCEClean( PIB *ppib, BOOL fCleanSession )
	{
	ERR     err = JET_errSuccess;
	BUCKET  *pbucket;
	RCE     *prce;
	TRX     trxMic;

	Assert( ppib != ppibNil || !fCleanSession );
	
	/*	clean PIB in critical section held across IO operations
	/**/
	LeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	EnterNestableCriticalSection( critRCEClean );
	EnterCriticalSection( critJet );

	/*	if fCleanSession is clean all then clean all
	/*	RCEs outside of transaction semantics.  This
	/*	will be called from bookmark clean up
	/*	to make rollbackable changes coincide with
	/*	unversioned expunge operations.
	/**/
	if ( fCleanSession )
		{
		Assert( ppib != ppibNil );
		trxMic = trxMax;
		pbucket = pbucketNil;
		prce = PrcePIBOldest( ppib );
		}
	else
		{
		Assert( ppib == ppibNil );
		SgEnterCriticalSection( critVer );
		trxMic = trxOldest;
		SgLeaveCriticalSection( critVer );
		
		/*	get oldest bucket and clean RCEs from oldest to youngest
		/**/
		pbucket = PbucketBUOldest( );

		/*	return if no buckets, or if oldest bucket has RCE
		/*	younger than oldest transaction.
		/**/
		if ( pbucket == pbucketNil )
			{
			Assert( pbucketGlobal == pbucketNil );
			Assert( err == JET_errSuccess );
			goto HandleError;
			}

		prce = PrceRCENewest( pbucket );
		if ( prce->trxCommitted > trxMic )
			{
			Assert( err == JET_errSuccess );
			goto HandleError;
			}
	
		/*	get oldest RCE in bucket
		/**/
		prce = PrceRCENextOldest( pbucket, prceNil );
		}

	/*	loop through buckets, oldest to newest, and check the trx of
	/*	the PrceRCENewest in each bucket.  We can clean the bucket
	/*	if the PrceRCENewest has a trx less than trxMic.
	/**/
	while ( !fCleanSession && pbucket != pbucketNil &&
		PrceRCENewest( pbucket )->trxCommitted < trxMic ||
			fCleanSession && prce != prceNil )
		{
		Assert( fCleanSession || pbucket->pbucketPrev == pbucketNil );
		Assert( fCleanSession || PrceRCENewest( pbucket )->level == 0 );

		/*	for each RCE which has no successor, delete hash table
		/*	head for version chain and reset node version bit.
		/*	If can complete these operations without error for
		/*	each such RCE, then free bucket.
		/**/
		forever
			{
			OPER operSave = prce->oper;

			if ( prce->oper != operNull &&
				prce->trxCommitted >= trxMic )
				goto Done;
			Assert( prce->oper == operNull || prce->trxCommitted != trxMax );
			Assert( prce->oper == operNull || prce->level == 0 );
			Assert( fCleanSession || prce <= PrceRCENewest( pbucket ) );

			//	CONSIDER: remove all posibility of access of RCE older
			//	than trxOldest, and only delete RCE head
			//	structures when this RCE has no subsequent RCEs

			/*********************************************/
			/*	BEFORE FCB decrement processing
			/*	this clean up code needs the FCB
			/*********************************************/

			if ( prce->oper == operDeleteIndex )
				{
				/*	if index has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/

				FCB *pfcbT = (*(FCB **)prce->rgbData);
				
				if ( pfcbT->cVersion > 0 )
					{
					goto Done;
					}
				}
			else if ( prce->oper == operDeleteTable )
				{
				FCB	*pfcbT;

				/*	if index has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/

				/*	may be pfcbNil if sentinel
				/**/
				pfcbT = PfcbFCBGet( prce->dbid, *(PGNO *)prce->rgbData );
				if ( pfcbT != pfcbNil && pfcbT->cVersion > 0 )
					{
					goto Done;
					}
				}
			else if ( prce->oper == operDeferFreeExt )
				{
				/*	free defer freed space must be done
				/*	before FCB version reference count on parent FDP
				/*	is released, since parent FCB must be in memory
				/*	for space operation.
				/**/
				Assert( prce->pfcb != pfcbNil );
#ifdef DEBUG
				{
				FCB		*pfcbT;

				/*	if child FDP FCB has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/
				pfcbT = PfcbFCBGet( prce->dbid, ((VEREXT *)prce->rgbData)->pgnoChildFDP );
				Assert( pfcbT == pfcbNil );
				}
#endif

				/*	free child FDP space to parent FDP
				/**/
				Assert( prce->cbData == sizeof(VEREXT) );
				Assert( prce->pfcb->pgnoFDP == ((VEREXT *)prce->rgbData)->pgnoFDP );
				VERFreeExt( prce->pfcb,
					((VEREXT *)prce->rgbData)->pgnoFirst,
					((VEREXT *)prce->rgbData)->cpgSize );

				Assert( prce->oper != operNull && prce->level == 0 );
				prce->oper = operNull;
//				PIBUpdatePrceNewest( prce->pfucb->ppib, prce );
				}
//			else if ( prce->oper == operFlagDeleteItem )
//				{
//				/* delete item [cleanup]
//				/**/
//				if ( fOLCompact)
//					{
//					Call( ErrVERDeleteItem( ppibAccess, prce ) );
//					}
//
//				/* delete RCE from hash chain.
//				/**/
//				Assert( prce->oper != operNull && prce->level == 0 );
//				prce->oper = operNull;
//				VERDeleteRce( prce );
//				}

			/*********************************************/
			/*	FCB DECREMENT
			/*********************************************/

			/*	finished processing version for FCB
			/**/
			FCBVersionDecrement( prce->pfcb );

			/*********************************************/
			/*	AFTER FCB decrement processing
			/*	this clean up code does not need the FCB
			/*********************************************/

			/*	handle special case of delete index and
			/*	remaining outstanding versions.  Must clean
			/*	other buckets first.
			/**/
			if ( prce->oper == operDeleteIndex )
				{
				Assert( (*(FCB **)prce->rgbData)->cVersion == 0 );
				Assert( (*(FCB **)prce->rgbData)->pfcbNextIndex == pfcbNil );

				/*	free in-memory structure
				/**/
				RECFreeIDB( (*(FCB **)prce->rgbData)->pidb );
				Assert( (*(FCB **)prce->rgbData)->cVersion == 0 );
				MEMReleasePfcb( (*(FCB **)prce->rgbData) );
#ifdef FCB_STATS
				cfcbVer--;
#endif
				Assert( prce->oper != operNull && prce->level == 0 );
				}
			else if ( prce->oper == operDeleteTable )
				{
				Assert( (PGNO *)prce->rgbData != pgnoNull );
				/*	FCB may be either sentinel or table FCB
				/**/
				FCBPurgeTable( prce->dbid, *(PGNO *)prce->rgbData );
				}
			else if ( prce->oper != operNull &&
				prce->oper != operAllocExt &&
				!FOperDDL( prce->oper ) )
				{
				/*	delete RCE from hash chain.
				/**/
				Assert( prce->oper != operNull && prce->level == 0 );
				VERDeleteRce( prce );
				}
			
			/*	RCE has been processed -- set oper to Null
			/**/
			prce->oper = operNull;

			/*	update RCE pointers of next RCE of same session
			/**/
			Assert( prce->prcePrevOfSession == prceNil );
			if ( prce->prceNextOfSession != prceNil )
				{
				prce->prceNextOfSession->prcePrevOfSession = prceNil;
				}
			else
				{
				if ( fCleanSession )
					{
					Assert( ppib->prceNewest == prce );
					PIBSetPrceNewest( ppib, prceNil );
					}
				else
					{
					if ( prce->trxCommitted == trxMax )
						{
						/*	find the right ppib that has PrceNewest points to prce.
						 */
						PIB *ppibT = ppibGlobal;
						for ( ; ppibT != ppibNil; ppibT = ppibT->ppibNext )
							{
							if ( ppibT->prceNewest == prce )
								break;
							}
						if ( ppibT != ppibNil )
							{
							PIBSetPrceNewest( ppibT, prceNil );
							}
						}
					}
				prce->prceNextOfSession = prceNil;
				}
				
			/*	if RCE unlinked was newest in bucket then free bucket.
			/**/
			if ( !fCleanSession && prce == PrceRCENewest( pbucket ) )
				{
				break;
				}

			/*	not newest RCE in bucket
			/**/
			if ( !fCleanSession )
				{
				prce = PrceRCENextOldest( pbucket, prce );
				Assert( prce != prceNil );
				}
			else
				{
				prce = prce->prceNextOfSession;
				
				if ( prce == prceNil )
					{
					goto Done;
					}
				}
			}

		/*	all RCEs in bucket cleaned.  Now get next bucket and free
		/*	cleaned bucket.
		/**/
		Assert( pbucket->pbucketPrev == pbucketNil );
		pbucket = pbucket->pbucketNext;
		BUFreeOldestBucket( );
		
		/*	get RCE in next bucket
		/**/
		prce = PrceRCENextOldest( pbucket, prceNil );
		}

	/*	stop as soon as find RCE commit time younger than oldest
	/*	transaction.  If bucket left then set ibOldestRCE and
	/*	unlink back offset of last remaining RCE.
	/*	If no error then set warning code if some buckets could
	/*	not be cleaned.
	/**/
	if ( pbucket != pbucketNil || fCleanSession )
		{
Done:
		if ( !fCleanSession )
			{
			Assert( pbucket != pbucketNil );
			prce->ibPrev = 0;
			err = ErrERRCheck( JET_wrnRemainingVersions );
			}
		else
			{
			prce = prceNil;
			err = JET_errSuccess;
			}
		}
	else
		{
		Assert( pbucketGlobal == pbucketNil );
		}

HandleError:
	/*	return warning if remaining versions
	/**/
	if ( err == JET_errSuccess && pbucketGlobal != pbucketNil && !fCleanSession )
		err = ErrERRCheck( JET_wrnRemainingVersions );
	LeaveNestableCriticalSection( critRCEClean );
	LeaveNestableCriticalSection( critSplit );
	return err;
	}


/*==========================================================
	ULONG RCECleanProc( VOID )

	Go through all sessions, cleaning buckets as versions are
	no longer needed.  Only those versions older than oldest
	transaction are cleaned up.

	Returns:
		0

	Side Effects:
		frees buckets.

==========================================================*/
ULONG RCECleanProc( VOID )
	{
	forever
		{
		SignalWait( sigRCECleanProc, 30 * 1000 );
		EnterCriticalSection( critJet );
		(VOID) ErrRCECleanAllPIB();
		LeaveCriticalSection( critJet );

		if ( fRCECleanProcTerm )
			{
			break;
			}
		}

	return 0;
	}


//+local----------------------------------------------------
//	UpdateTrxOldest
//	========================================================
//
//	LOCAL VOID UpdateTrxOldest( PIB *ppib )
//
//	finds the oldest transaction among all transactions
//	other than ppib->trx [this is the one being deleted]
//----------------------------------------------------------
INLINE LOCAL VOID UpdateTrxOldest( PIB *ppib )
	{
	TRX		trxMinTmp = trxMax;
	PIB		*ppibT = ppibGlobal;

	SgAssertCriticalSection( critVer );
	Assert( ppib->trxBegin0 == trxOldest );
	for ( ; ppibT ; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->trxBegin0 < trxMinTmp && ppibT->trxBegin0 != ppib->trxBegin0 )
			trxMinTmp = ppibT->trxBegin0;
		}

	trxOldest = trxMinTmp;
	}


//+api------------------------------------------------------
//	ErrVERBeginTransaction
//	========================================================
//
//	ERR ErrVERBeginTransaction( PIB *ppib )
//
//	Increment the session transaction level.
//----------------------------------------------------------
ERR ErrVERBeginTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;

	/*	increment session transaction level.
	/**/
	ppib->level++;
	Assert( ppib->level < levelMax );
	if ( ppib->level == 1 )
		{
// Moved to caller function - in dir.c and redo.c
//		SgEnterCriticalSection( critVer );
//		ppib->trxBegin0 = ++trxNewest;
//		if ( trxOldest == trxMax )
//			trxOldest = ppib->trxBegin0;
//		SgLeaveCriticalSection( critVer );

		if ( !( fLogDisabled || fRecovering ) )
			{
			EnterCriticalSection(critLGBuf);
			GetLgposOfPbEntry( &ppib->lgposStart );
			LeaveCriticalSection(critLGBuf);
			}
		}

	Assert( err == JET_errSuccess );
	return err;
	}


VOID VERDeleteFromDeferredBIChain( RCE *prce )
	{
	BF		*pbfT;
	RCE		**pprceNext;

//	AssertCriticalSection( critVer );
	AssertCriticalSection( critJet );

	pbfT = prce->pbfDeferredBI;
	if ( pbfT == pbfNil	)
		return;

CheckBF:
	BFEnterCriticalSection( pbfT );
	if ( prce->pbfDeferredBI != pbfT )
		{
		/*	someone has cleaned it up!
		/**/
		Assert( prce->pbfDeferredBI == pbfNil );
		BFLeaveCriticalSection( pbfT );
		return;
		}

	if ( pbfT->fSyncWrite )
		{
		/*	SyncWrite is going on. We do not know which stage the sync
		/*	write is. Simply wait till synch write is completed.
		/*	Note that asynch write is not a problem since we always
		/*	write out the log BI and set up the page for async write
		/*	and no others can access the page till the async write is done.
		/**/
		BFLeaveCriticalSection( pbfT );
		BFSleep( cmsecWaitIOComplete );
		pbfT = prce->pbfDeferredBI;
		if ( pbfT == pbfNil )
			return;

		/*	check if we still need to delete from BI chain
		/**/
		goto CheckBF;
		}

	Assert( pbfT->fSyncRead == fFalse );
	Assert( pbfT->fAsyncRead == fFalse );
	Assert( pbfT->fAsyncWrite == fFalse );
	Assert(	pbfT->fDirty );

	pprceNext = &pbfT->prceDeferredBINext;
	while( *pprceNext != prce )
		{
		Assert( *pprceNext );
		Assert( (*pprceNext)->pbfDeferredBI == pbfT );
		pprceNext = &(*pprceNext)->prceDeferredBINext;
		}
	*pprceNext = prce->prceDeferredBINext;

	prce->prceDeferredBINext = prceNil;

	/*	if no for recovery, pin it and release later.
	 */
	if ( fRecovering )
		prce->pbfDeferredBI = pbfNil;
	else
		pbfT->cPin++;
	
#ifdef DEBUG
	prce->qwDBTimeDeferredBIRemoved = 0;
#endif

#ifdef DEBUG
	pprceNext = &pbfT->prceDeferredBINext;
	while( *pprceNext != prceNil )
		{
		Assert( (*pprceNext)->pbfDeferredBI == pbfT );
		pprceNext = &(*pprceNext)->prceDeferredBINext;
		}
#endif

	BFLeaveCriticalSection( pbfT );
	return;
	}


VOID VERPrecommitTransaction( PIB *ppib )
	{
	LEVEL	level = ppib->level;
	RCE		*prce;

	/*	must be in a transaction in order to commit
	/**/
	SgEnterCriticalSection( critVer );

	/*	get newest RCE for this session. remove BI in
	/*	reverse chronological order.
	/**/
	prce = ppib->prceNewest;

	while( prce != prceNil )
		{
		/*	if this RCE is from a previous transaction, then
		/*	terminate commit processing.  All RCEs from committed
		/*	transaction must already have been committed.
		/**/
		Assert( prce->level <= level );
		if ( prce->level != level )
			{
			Assert( level == 1 && prce->trxCommitted != trxMax ||
					level > 1 && prce->trxCommitted == trxMax );
			goto Done;
			}

		if ( prce->oper == operReplace &&
			 prce->pbfDeferredBI != pbfNil )
			{
			if ( prce->level == 1
				||
				 prce->prcePrevOfNode != prceNil &&
				 prce->prcePrevOfNode->trxCommitted == trxMax &&
				 prce->prcePrevOfNode->level == prce->level - 1 )
				{
				/*	backout from the deferred BI chain.
				/**/
				VERDeleteFromDeferredBIChain( prce );
				}
			}

		/*	get previous RCE of session
		/**/
		prce = prce->prcePrevOfSession;
		}

Done:
	SgLeaveCriticalSection( critVer );
	return;
	}


LOCAL VOID VERCommit0DeleteTable( PIB *ppib, RCE *prce )
	{
	FCB	*pfcbT;

	/*	pfcb should always be found, even if sentinel
	/**/
	pfcbT = PfcbFCBGet( prce->dbid, *(PGNO *)prce->rgbData );
	Assert( pfcbT != pfcbNil );
	if ( pfcbT != pfcbNil )
		{
		/*	reset Deny DDL flag
		/**/
		Assert( FFCBWriteLatchByUs( pfcbT, ppib ) );
		FCBResetWriteLatch( pfcbT, ppib );

		/*	remove sentinel
		/**/
		Assert( FFCBDomainDenyReadByUs( pfcbT, ppib ) );
		FCBResetDeleteTable( pfcbT );

		// Nothing left to prevent access to this FCB except
		// for DeletePending.
		Assert( FFCBDeletePending( pfcbT ) );
		}

	return;
   	}


VOID VERCommitTransaction( PIB *ppib, BOOL fCleanSession )
	{
	LEVEL	level = ppib->level;
	RCE		*prce;

	/*	must be in a transaction in order to commit
	/**/
	Assert( level > 0 );

	SgEnterCriticalSection( critVer );

//	Moved to caller - in dir.c redo.c
//	ppib->trxCommit0 = ++trxNewest;

	/*	timestamp RCEs with commit time.  Preincrement trxNewest so
	/*	that all transaction timestamps and commit timestamps are
	/*	unique.  Commit MUST be done in MUTEX.
	/**/
#ifdef UNLIKELY_RECLAIM
NextBucket:
#endif
	/*	get newest RCE for this session. Commit RCEs in
	/*	reverse chronological order.
	/**/
	prce = ppib->prceNewest;

	/*	handle commit to intermediate transaction level and
	/*	commit to transaction level 0 differently.
	/**/
	if ( level > 1 )
		{
		while( prce != prceNil )
			{
			/*	if this RCE is from a previous transaction, then
			/*	terminate commit processing.  All RCEs from committed
			/*	transaction must already have been committed.
			/**/
			Assert( prce->level <= level );
			if ( prce->level != level )
				{
				goto Done;
				}

			/*	merge replace RCEs with previous level RCEs if exist
			/**/
			Assert( prce->trxCommitted == trxMax );

			if ( prce->prcePrevOfNode != prceNil &&
				 prce->prcePrevOfNode->trxCommitted == trxMax &&
				 prce->prcePrevOfNode->level == prce->level - 1 )
				{
				Assert( prce->prcePrevOfNode->trxCommitted == trxMax );

				if ( prce->oper == operDelta &&
				     prce->prcePrevOfNode->oper == operDelta
				   )
					{
					/*	merge delta with previous delta
					/**/
					Assert( prce->prcePrevOfNode->level > 0 );
					Assert( prce->prcePrevOfNode->pfucb->ppib == prce->pfucb->ppib );
					Assert( prce->cbData == sizeof(LONG) );
					Assert( prce->pfucb->ppib == prce->prcePrevOfNode->pfucb->ppib );
					VERAdjustDelta( prce->prcePrevOfNode, *((LONG *)prce->rgbData) );
					prce->oper = operNull;
					VERDeleteRce( prce );
					}

				else if ( prce->oper == operReplace ||
						  prce->oper == operReplaceWithDeferredBI
						)
					{
					Assert( prce->prcePrevOfNode->oper == operReplace ||
							prce->prcePrevOfNode->oper == operReplaceWithDeferredBI ||
							prce->prcePrevOfNode->oper == operInsert );

					Assert( prce->prcePrevOfNode->level > 0 );
					Assert( prce->prcePrevOfNode->pfucb->ppib == prce->pfucb->ppib );
					Assert( prce->bm == prce->prcePrevOfNode->bm );

					/*	This is commit. No rollback on this level. If there is a previous
					 *	level before image on previous version. Then no need to log before
					 *	image of this version. Take out the rce from the deferred before
					 *	image chain of pbf.
					 */
					Assert( prce->oper != operReplaceWithDeferredBI ||
						prce->pbfDeferredBI == pbfNil );

					if ( prce->oper == operReplace &&
						 prce->pbfDeferredBI != pbfNil )
						{
						BF *pbfT = prce->pbfDeferredBI;
						Assert( prce->prceDeferredBINext == prceNil );
						BFUnpin( pbfT );
						prce->pbfDeferredBI = pbfNil;
						
//						/*	backout from the deferred BI chain.
//						/**/
//						VERIDeleteFromDeferredBIChain( prce );
						}

					/*	if previous version is also a replace, propagate max
					/**/
					if ( prce->prcePrevOfNode->oper == operReplace ||
						 prce->prcePrevOfNode->oper == operReplaceWithDeferredBI
					   )
						{
						Assert( prce->prcePrevOfNode->level > 0 );
						Assert( prce->prcePrevOfNode->pfucb->ppib == prce->pfucb->ppib );

						/*	propagate maximum to previous RCE
						/**/
						*(SHORT *)prce->prcePrevOfNode->rgbData = max(
							*(SHORT *)prce->prcePrevOfNode->rgbData,
							*(SHORT *)prce->rgbData );

						/*	merge reserved node space
						/**/
						*( (SHORT *)prce->prcePrevOfNode->rgbData + 1) =
							*( (SHORT *)prce->prcePrevOfNode->rgbData + 1) +
							*( (SHORT *)prce->rgbData + 1);
						}

					prce->oper = operNull;
					VERDeleteRce( prce );
					}
				}
			Assert( prce->level > 1 );
			prce->level--;

			/*	get previous RCE of session
			/**/
			prce = prce->prcePrevOfSession;
			}
		}
	else
		{
		while( prce != prceNil )
			{
			/*	if this RCE is from a previous transaction, then
			/*	terminate commit processing.  All RCEs from committed
			/*	transaction must already have been committed.
			/**/
			Assert( prce->level <= level );
			if ( prce->level != level )
				{
				Assert( prce->trxCommitted != trxMax );
				goto Done;
				}

			Assert( prce->trxCommitted == trxMax );

			/*	if version for DDL operation then reset deny DDL
			/*	and perform special handling
			/**/
			if ( FOperDDL( prce->oper ) )
				{
				switch( prce->oper )
					{
					case operAddColumn:
						Assert( prce->cbData == sizeof(FID) );

						/* Reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );

						prce->oper = operNull;
						break;

					case operDeleteColumn:
						{
						FDB		*pfdb = (FDB *)prce->pfcb->pfdb;

						Assert( prce->cbData == sizeof(VERCOLUMN) );

						/*	delete the column name from the FDB buffer
						/**/
						MEMDelete( pfdb->rgb, PfieldFDBFromFid( pfdb, ( (VERCOLUMN *)prce->rgbData )->fid )->itagFieldName );

						/*	reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );
							
						prce->oper = operNull;
						break;
						}

					case operCreateIndex:
						/*	reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );
	
						prce->oper = operNull;
						break;

					case operDeleteIndex:
						/*	unlink index FCB from index list
						/**/
#ifdef FCB_STATS
						cfcbVer++;
#endif
						FCBUnlinkIndex( prce->pfcb, (*(FCB **)prce->rgbData) );

						/*	reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );
						break;
		
					case operRenameTable:
						Assert( prce->cbData == sizeof(BYTE *) );
						SFree( *((BYTE **)prce->rgbData));

						/*	reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );

						break;

					case operDeleteTable:
						VERCommit0DeleteTable( ppib, prce );
						break;
						
					default:
						Assert( prce->oper == operCreateTable ||
							prce->oper == operRenameTable ||
							prce->oper == operRenameColumn ||
							prce->oper == operRenameIndex );

						/*	reset Deny DDL flag
						/**/
						FCBResetWriteLatch( prce->pfcb, ppib );

						break;
					}
				}
			else
				{
				Assert( prce->oper != operCreateTable &&
					prce->oper != operDeleteTable &&
					prce->oper != operRenameTable &&
					prce->oper != operAddColumn &&
					prce->oper != operDeleteColumn &&
					prce->oper != operRenameColumn &&
					prce->oper != operCreateIndex &&
					prce->oper != operDeleteIndex &&
					prce->oper != operRenameIndex );

					/*	take out the rce from the deferred before image chain of pbf.
					/**/
					Assert( prce->oper != operReplaceWithDeferredBI ||
						prce->pbfDeferredBI == pbfNil );

					if ( prce->oper == operReplace &&
						prce->pbfDeferredBI != pbfNil )
						{
						BF *pbfT = prce->pbfDeferredBI;
						Assert( prce->prceDeferredBINext == prceNil );
						BFUnpin( pbfT );
						prce->pbfDeferredBI = pbfNil;

//						/*	backout from the deferred BI chain.
//						/**/
//						VERIDeleteFromDeferredBIChain( prce );
						}
			
					/*	RCEs for flag delete/delete item/insert item
					/*	must be retained even if there are previous RCEs
					/*	at the same transaction level.
					/**/
					if ( prce->oper == operDelta )
						{
						/*	discard uneeded increment and decrement RCEs
						/**/
						prce->oper = operNull;
						VERDeleteRce( prce );
						}
					else if ( ( prce->oper == operReplace ||
								prce->oper == operReplaceWithDeferredBI ) &&
							  prce->prcePrevOfNode != prceNil &&
							  prce->prcePrevOfNode->level == prce->level )
						{
						/*	discard uneeded RCEs. If there are 2 replace on the same
						 *	node, we only need one for other users to see.
						/**/
						prce->oper = operNull;
						VERDeleteRce( prce );
						}
				}

				/*	set trx of committed RCE for proper access.
			/**/
			Assert( level == 1 );
			Assert( prce->level == 1 );
			prce->level = 0;
			if ( prce->trxPrev == trxMax )
				prce->trxPrev = trxMin;
			Assert( prce->trxCommitted == trxMax );
			prce->trxCommitted = ppib->trxCommit0;

			/*	get previous RCE of session
			/**/
			prce = prce->prcePrevOfSession;
			}
		}

Done:
	/*	adjust session transaction level and system oldest transaction.
	/**/
	if ( ppib->level == 1 )
		{
		if ( ppib->trxBegin0 == trxOldest )
			{
			UpdateTrxOldest( ppib );
			}

		/* set the session as having no transaction
		/**/
		ppib->trxBegin0 = trxMax;
		ppib->lgposStart = lgposMax;
		}

	Assert( ppib->level > 0 );
	--ppib->level;

	/*	called from BM cleanup, to fix indexes atomically
	/**/
	if ( fCleanSession )
		{
		CallS( ErrRCEClean( ppib, fTrue ) );
		}

	/*	prceNewest not needed anymore
	/**/
	if ( ppib->level == 0 )
		{
		PIBSetPrceNewest( ppib, prceNil );
		}

	/*	trxNewest should not have changed during commmit.
	/**/
	Assert( ppib->trxCommit0 <= trxNewest );
	SgLeaveCriticalSection( critVer );
	return;
	}


/*	purges all FUCBs on given index FCB
/**/
INLINE LOCAL VOID FUCBPurgeIndex( PIB *ppib, FCB *pfcb )
	{
	FUCB	*pfucbT;
	FUCB	*pfucbNext;

	for ( pfucbT = ppib->pfucb; pfucbT != pfucbNil; pfucbT = pfucbNext )
		{
		pfucbNext = pfucbT->pfucbNext;
		/*	close cursor if it is opened on same table
		/**/
		if ( pfucbT->u.pfcb == pfcb )
			{
			/*	no other session could be on index being rolled back.
			/**/
			Assert( pfucbT->ppib == ppib );
			FCBUnlink( pfucbT );
			Assert( pfucbT->tableid == JET_tableidNil );
			Assert( pfucbT->fVtid == fFalse );
			FUCBClose( pfucbT );
			}
		}

	return;
	}


/*	purges all FUCBs on given table FCB.
/**/
INLINE LOCAL VOID FUCBPurgeTable( PIB *ppib, FCB *pfcb )
	{
	FCB		*pfcbT;

	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( pfcbT->wRefCnt > 0 )
			{
			FUCBPurgeIndex( ppib, pfcbT );
			}
		}

	return;
	}


INLINE LOCAL ERR ErrVERUndoReplace( RCE *prce )
	{
	ERR		err = JET_errSuccess;
	LINE  	line;
	BOOL  	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL  	fRedoUndo = prce->bmTarget != sridNull;
	PIB		*ppib;
	FUCB	*pfucb = prce->pfucb;
	BYTE	*pbAlloc = NULL;
	SHORT	*ps;


	Assert( prce->oper == operReplace );
	Assert( prce->trxCommitted == trxMax );
	
	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( pfucb );
	
GotoPage:
	DIRGotoBookmark( pfucb, fRedoUndo ? prce->bmTarget : prce->bm );
	err = ErrDIRGet( pfucb );
	Assert( err != JET_errRecordDeleted );

	CallJ( err, HandleError2 );

	line.pb = prce->rgbData + cbReplaceRCEOverhead;
	line.cb = prce->cbData - cbReplaceRCEOverhead;

	/*	if this is replace RCE with deferred BI, then the BI must be set already.
	 */
	Assert( prce->cbData != cbReplaceRCEOverhead || *line.pb != '*' );

	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	if ( prce->pbfDeferredBI != pbfNil )
		{
		if ( !fRedoUndo )
			{
			BF *pbf = prce->pbfDeferredBI;

			Assert( prce->pbfDeferredBI == pbf );
			BFPin( pbf );
			/*	ignore error code from logging, since rollback
			/*	will ultimately be accomplished in a subsequent
			/*	restart.
			/**/
			err = ErrLGDeferredBI( prce );
			BFUnpin( pbf );
			}

		/*	backout from the deferred BI chain.
		/**/
		VERDeleteFromDeferredBIChain( prce );
		}

	/*	replace should not fail since splits are avoided at undo
	/*	time via deferred page space release.  This refers to space
	/*	within a page and not pages freed when indexes and tables
	/*	are deleted.
	/**/
	Assert( fRecovering && prce->bmTarget == PcsrCurrent( pfucb )->bm ||
		prce->bm == PcsrCurrent( pfucb )->bm );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( prce->oper == operReplace || prce->oper == operReplaceWithDeferredBI );

	ps = (SHORT *)prce->rgbData + 1;

	if ( *ps > 0 )
		{
		// Rolling back a replace that shrunk the node.  To satisfy the rollback,
		// we will consume the reserved node space, but first we must remove this
		// reserved node space from the uncommitted freed count so that DIRReplace()
		// can see it.
		// (This complements the call to AddUncommittedFreed() in SetCbAdjust()).
		VERReclaimUncommittedFreed( pfucb->ssib.pbf->ppage, *ps );
		}

	ppib = pfucb->ppib;
	CallS( ErrDIRReplace( pfucb, &line, fDIRNoVersion | fDIRNoLog ) );

	if ( *ps < 0 )
		{
		// Rolling back a replace that grew the node.  Add to uncommitted freed
		// count the amount of reserved node space, if any, that we must restore.
		// (This complements the call to ReclaimUncommittedFreed in SetCbAdjust()).
		VERAddUncommittedFreed( pfucb->ssib.pbf->ppage, -(*ps) );
		}

	AssertBFDirty( pfucb->ssib.pbf );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit(pbf);
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	if ( prce->pbfDeferredBI != pbfNil )
		{
		BF *pbfT = prce->pbfDeferredBI;
		Assert( prce->prceDeferredBINext == prceNil );
		BFUnpin( pbfT );
		prce->pbfDeferredBI = pbfNil;
		}

HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );

	if ( pbAlloc )
		SFree( pbAlloc );

	return err;
	}


/*	set delete bit in node header and let bookmark clean up
/*	remove the node later.
/**/
INLINE LOCAL ERR ErrVERUndoInsert( RCE *prce )
	{
	ERR		err;
	BOOL	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL	fRedoUndo = prce->bmTarget != sridNull;
	FUCB	*pfucb = prce->pfucb;

	Assert( prce->oper == operInsert );
	Assert( prce->trxCommitted == trxMax );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( pfucb );

GotoPage:
	DIRGotoBookmark( pfucb, fRedoUndo ? prce->bmTarget : prce->bm );
	err = ErrDIRGet( pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	Assert( err == JET_errRecordDeleted || err == JET_errSuccess );
	
	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );
	NDSetDeleted( *pfucb->ssib.line.pb );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit(pbf);
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );
	
	return err;
	}


/*	reset delete bit
/**/
INLINE LOCAL ERR ErrVERUndoFlagDelete(RCE *prce)
	{
	ERR     err;
	BOOL    fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;
	FUCB	*pfucb = prce->pfucb;

	Assert( prce->oper == operFlagDelete );
	Assert( prce->trxCommitted == trxMax );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( pfucb );

GotoPage:
	DIRGotoBookmark( pfucb, fRedoUndo ? prce->bmTarget : prce->bm );
	err = ErrDIRGet( pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	Assert( err == JET_errRecordDeleted || err == JET_errSuccess );
	
	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );
	NDResetNodeDeleted( pfucb );
	Assert( pfucb->ssib.pbf->fDirty );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit(pbf);
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );
	
	return err;
	}


INLINE LOCAL ERR ErrVERUndoInsertItem( RCE *prce )
	{
	ERR     err;
	BOOL    fClustered = !FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;
	FUCB	*pfucb = prce->pfucb;

	Assert( prce->oper == operInsertItem ||
		prce->oper == operFlagInsertItem );
	Assert( prce->trxCommitted == trxMax );

	/*	set to non-clustered index cursor
	/**/
	FUCBSetNonClustered( pfucb );

	/*	set currency to bookmark of item list and item.
	/**/
GotoPage:
	DIRGotoBookmarkItem( pfucb,
		fRedoUndo ? prce->bmTarget : prce->bm,
		*(SRID *)prce->rgbData );
	err = ErrDIRGet( pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	/* since we do not log item, so the pfucb->pcsr->item is bogus for redo
	/**/
	Assert( fRecovering ||
		BmNDOfItem(((SRID UNALIGNED *)pfucb->lineData.pb)[pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );
	NDSetItemDelete( pfucb );
	if ( prce->prcePrevOfNode == prceNil )
		NDResetItemVersion( pfucb );
	Assert( pfucb->ssib.pbf->fDirty );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit( pbf );
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, prce->pfucb->ppib );

HandleError2:
	if ( fClustered )
		FUCBResetNonClustered( pfucb );
	
	return err;
	}


INLINE LOCAL ERR ErrVERUndoFlagDeleteItem( RCE *prce )
	{
	ERR     err;
	BOOL    fClustered = !FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;
	FUCB	*pfucb = prce->pfucb;

	Assert( prce->oper == operFlagDeleteItem );
	Assert( prce->trxCommitted == trxMax );

	/*	set to non-clustered index cursor
	/**/
	FUCBSetNonClustered( pfucb );

	/*	set currency to bookmark of item list and item
	/**/
GotoPage:
	DIRGotoBookmarkItem( pfucb,
		fRedoUndo ? prce->bmTarget : prce->bm,
		*(SRID *)prce->rgbData );
	err = ErrDIRGet( pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}

	/* since we do not log item, so the pfucb->pcsr->item is bogus for redo
	/**/
	Assert( fRecovering ||
		BmNDOfItem(((SRID UNALIGNED *)pfucb->lineData.pb)[pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );
	
	Assert( fRecovering ||
		BmNDOfItem(((SRID UNALIGNED *)pfucb->lineData.pb)[pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	NDResetItemDelete( pfucb );
	if ( prce->prcePrevOfNode == prceNil )
		NDResetItemVersion( pfucb );
	Assert( pfucb->ssib.pbf->fDirty );

	Assert( fRecovering ||
		BmNDOfItem(((SRID UNALIGNED *)pfucb->lineData.pb)[pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit( pbf );
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError2:
	if ( fClustered )
		FUCBResetNonClustered( pfucb );
	
	return err;
	}


/*	undo delta change
/**/
INLINE LOCAL ERR ErrVERUndoDelta( RCE *prce )
	{
	ERR		err;
	BOOL  	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL  	fRedoUndo = prce->bmTarget != sridNull;
	PIB	  	*ppib;
	FUCB	*pfucb = prce->pfucb;

	Assert( prce->oper == operDelta );
	Assert( prce->trxCommitted == trxMax );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( pfucb );

GotoPage:
	DIRGotoBookmark( pfucb, fRedoUndo ? prce->bmTarget : prce->bm );
	err = ErrDIRGet( pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
		
	/*  latch the page for log manager to set LGDepend
	/**/
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto GotoPage;
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	ppib = pfucb->ppib;
	NDGetNode( pfucb );
	
	Call( ErrNDDeltaNoCheckLog( pfucb, -*((LONG *)prce->rgbData), fDIRNoVersion | fDIRNoLog ) );
	
	AssertBFDirty( pfucb->ssib.pbf );

	if ( fRedoUndo )
		{
		BF *pbf = pfucb->ssib.pbf;
		
		Assert( prce->qwDBTime != qwDBTimeNull );
		BFSetDirtyBit( pbf );
		PMSetDBTime( pbf->ppage, prce->qwDBTime );
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );
	
	return err;
	}


VOID VERUndoCreateTable( RCE *prce )
	{
	FUCB  	*pfucb = prce->pfucb;
	PIB		*ppib = pfucb->ppib;
	FUCB  	*pfucbT;
	PGNO  	pgno = pfucb->u.pfcb->pgnoFDP;
	DBID  	dbid = pfucb->dbid;
	FCB		*pfcb = pfucb->u.pfcb;

	Assert( prce->oper == operCreateTable );
	Assert( prce->trxCommitted == trxMax );

	Assert( !FFUCBNonClustered( pfucb ) );

	/*	close all cursors on this table
	/**/
	pfucb = pfcb->pfucb;
	for ( pfucb = pfcb->pfucb; pfucb != pfucbNil; pfucb = pfucbT )
		{
		pfucbT = pfucb->pfucbNextInstance;

		/*	if defer closed then continue
		/**/
		if ( FFUCBDeferClosed( pfucb ) )
			continue;

		if( pfucb->fVtid )
			{
			CallS( ErrDispCloseTable( (JET_SESID)pfucb->ppib, TableidOfVtid( pfucb ) ) );
			}
		else
			{
			Assert( pfucb->tableid == JET_tableidNil );
			CallS( ErrFILECloseTable( pfucb->ppib, pfucb ) );
			}
		pfucb = pfucbT;
		}

	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );

	/*	cursors may have been deferred closed so force close them and
	/*	purge table FCBs.
	/**/
	FUCBPurgeTable( ppib, pfcb );
	FCBPurgeTable( dbid, pgno );
	
	return;
	}


INLINE LOCAL VOID VERResetFDBFlags( FDB *pfdb, FIELD *pfield, FID fidSet, FID fidReset )
	{
	/*	reset version/autoinc flags if set.  If set, these flags are mutually
	/*	exclusive, i.e. one or the other, but not both.
	/**/
	Assert( pfdb->fidVersion != pfdb->fidAutoInc || pfdb->fidVersion == 0 );
	if ( FFIELDVersion( pfield->ffield ) )
		{
		Assert( pfdb->fidVersion == fidSet );
		pfdb->fidVersion = fidReset;
		}
	else if ( FFIELDAutoInc( pfield->ffield ) )
		{
		Assert( pfdb->fidAutoInc == fidSet );
		pfdb->fidAutoInc = fidReset;
		}
	Assert( pfdb->fidVersion != pfdb->fidAutoInc || pfdb->fidVersion == 0 );
	return;
	}


INLINE LOCAL VOID VERUndoAddColumn( RCE *prce )
	{
	FDB		*pfdb;
	FID		fid;
	FIELD	*pfield;
	BOOL	fRollbackNeeded;

	Assert( prce->oper == operAddColumn );
	Assert( prce->trxCommitted == trxMax );

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FID) );

	pfdb = (FDB *)prce->pfucb->u.pfcb->pfdb;
	fid = *( (FID *)prce->rgbData );

	if ( FTaggedFid( fid ) )
		{
		fRollbackNeeded = ( fid <= pfdb->fidTaggedLast );
		}
	else if ( FVarFid( fid ) )
		{
		fRollbackNeeded = ( fid <= pfdb->fidVarLast );
		}
	else
		{
		Assert( FFixedFid( fid ) );
		fRollbackNeeded = ( fid <= pfdb->fidFixedLast );
		}

	if ( fRollbackNeeded )
		{
		pfield = PfieldFDBFromFid( pfdb, fid );

		/*	we do not rollback the added column but mark it as deleted
		/**/
		pfield->coltyp = JET_coltypNil;

		VERResetFDBFlags( pfdb, pfield, fid, 0 );

		/*	itag 0 in the FDB is reserved for the FIELD structures.  We
		/*	cannibalise it for itags of field names to indicate that a name
		/*	has not been added to the buffer.
		/**/
		if ( pfield->itagFieldName != 0 )
			{
			/*	remove the column name from the FDB name space
			/**/
			MEMDelete( pfdb->rgb, pfield->itagFieldName );
			}
		}

	/*	if we modified the default record, the changes will be invisible,
	/*	since pfield->coltyp is now set to JET_coltypNil.  The space will be
	/*	reclaimed by a subsequent call to the add column function.
	/**/
	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );

	return;
	}


INLINE LOCAL VOID VERUndoDeleteColumn( RCE *prce )
	{
	FDB 		*pfdb;
	FIELD		*pfield;
	VERCOLUMN	*pvercol;

	Assert( prce->oper == operDeleteColumn);
	Assert( prce->trxCommitted == trxMax );

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(VERCOLUMN) );

	pfdb = (FDB *)prce->pfucb->u.pfcb->pfdb;
	pvercol = (VERCOLUMN *)prce->rgbData;
	pfield = PfieldFDBFromFid( pfdb, pvercol->fid );

	/*	only undo if delete column was successful
	/**/
	if ( pfield->coltyp == JET_coltypNil )
		{	
		pfield->coltyp = pvercol->coltyp;

		//	UNDONE: on concurrent DDL, if we mark a column for deletion,
		//	removing its version/autoinc flags, then another thread adds a
		//	column with version/autoinc flags, then if we rollback the delete
		//	column, we will get a conflict when we try to reset the original
		//	version/autoinc status.
		VERResetFDBFlags( pfdb, pfield, 0, pvercol->fid );
		}

	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );

	return;
	}



VOID VERUndoDeleteTable( RCE *prce )
	{
	FCB	*pfcbT;

	Assert( prce->oper == operDeleteTable );
	Assert( prce->trxCommitted == trxMax );

	/*	may be pfcbNil if sentinel
	/**/
	pfcbT = PfcbFCBGet( prce->dbid, *(PGNO *)prce->rgbData );
	Assert( pfcbT != pfcbNil );
	if ( pfcbT != pfcbNil )
		{
		FCB *pfcbCur = pfcbT;

		for ( ; pfcbCur != pfcbNil; pfcbCur = pfcbCur->pfcbNextIndex )
			FCBResetDeletePending( pfcbCur );

		/*	reset Deny DDL flag
		/**/
		FCBResetWriteLatch( pfcbT, prce->pfucb->ppib );
	
		/*	remove sentinel
		/**/
		FCBResetDeleteTable( pfcbT );
		}

	return;
	}


INLINE LOCAL VOID VERUndoRenameTable( RCE *prce )
	{
	BYTE *szNameOld;

	Assert( prce->oper == operRenameTable );
	Assert( prce->trxCommitted == trxMax );
	Assert( prce->cbData == sizeof(BYTE *) );

	szNameOld = *((BYTE **)prce->rgbData);

	// We may be rolling back before the new name was actually copied into our
	// in-memory structure, in which case we should do nothing.
	if ( szNameOld != prce->pfucb->u.pfcb->szFileName )
		{
		// Assert that the name changed.
		Assert( strcmp( szNameOld, prce->pfucb->u.pfcb->szFileName ) != 0 );

		SFree( prce->pfucb->u.pfcb->szFileName );
		prce->pfucb->u.pfcb->szFileName = szNameOld;
		}

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );
	
	return;
	}


INLINE LOCAL VOID VERUndoCreateIndex( RCE *prce )
	{
	/*	pfcb of non-clustered index FCB or pfcbNil for clustered
	/*	index creation
	/**/
	FCB	*pfcb = *(FCB **)prce->rgbData;

	Assert( prce->oper == operCreateIndex );
	Assert( prce->trxCommitted == trxMax );
	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );

	/*	if non-clustered index then close all cursors on index
	/*	and purge index FCB, else free IDB for clustered index.
	/**/
	if ( pfcb != pfcbNil )
		{
		/*	close all cursors on defunct index
		/**/
		while ( pfcb->pfucb )
			{
			FUCB	*pfucbT = pfcb->pfucb;

			FCBUnlink( pfucbT );
			Assert(	pfucbT->tableid == JET_tableidNil );
			Assert( pfucbT->fVtid == fFalse );
			FUCBClose( pfucbT );
			}

		// This can't be the clustered index, because we would not have allocated
		// an FCB for it.
		Assert( prce->pfucb->u.pfcb != pfcb );

		// The FCB may or may not have been linked in.
		FFCBUnlinkIndexIfFound( prce->pfucb->u.pfcb, pfcb );
		if ( pfcb->pidb != NULL )
			{
			RECFreeIDB( pfcb->pidb );
			}
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		if ( prce->pfucb->u.pfcb->pidb != NULL )
			{
			RECFreeIDB( prce->pfucb->u.pfcb->pidb );
			prce->pfucb->u.pfcb->pidb = NULL;
			}
		}

	/*	update all index mask
	/**/
	FILESetAllIndexMask( prce->pfucb->u.pfcb );

	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );
	
	return;
	}


INLINE LOCAL VOID VERUndoDeleteIndex( RCE *prce )
	{
	Assert( prce->oper == operDeleteIndex );
	Assert( prce->trxCommitted == trxMax );

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );

	FCBResetDeleteIndex( *(FCB **)prce->rgbData );
	
	/*	update all index mask
	/**/
	FILESetAllIndexMask( prce->pfucb->u.pfcb );

	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );
	
	return;
	}


INLINE LOCAL ERR ErrVERUndoRenameColumn( RCE *prce )
	{
	ERR		err;
	CHAR	*szNameNew;
	CHAR	*szName;

	Assert( prce->oper == operRenameColumn );
	Assert( prce->trxCommitted == trxMax );

	szName = (CHAR *)((VERRENAME *)prce->rgbData)->szName;
	szNameNew = (CHAR *)((VERRENAME *)prce->rgbData)->szNameNew;
	err = ErrMEMReplace( prce->pfucb->u.pfcb->pfdb->rgb,
		PfieldFCBFromColumnName( prce->pfucb->u.pfcb, szNameNew )->itagFieldName,
		szName, strlen( szName ) + 1 );

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );
	
	return err;
	}


INLINE LOCAL VOID VERUndoRenameIndex( RCE *prce )
	{
	CHAR	*szNameNew;
	CHAR	*szName;
	FCB		*pfcb;

	Assert( prce->oper == operRenameIndex );
	Assert( prce->trxCommitted == trxMax );

	szName = (CHAR *)((VERRENAME *)prce->rgbData)->szName;
	szNameNew = (CHAR *)((VERRENAME *)prce->rgbData)->szNameNew;
	pfcb = PfcbFCBFromIndexName( prce->pfucb->u.pfcb, szNameNew );
	Assert( pfcb != NULL );
	strcpy( pfcb->pidb->szName, szName );

	Assert( FFCBWriteLatchByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	FCBResetWriteLatch( prce->pfucb->u.pfcb, prce->pfucb->ppib );
	
	return;
	}


ERR ErrVERUndo( RCE *prce )
	{
	ERR err;
	
	switch( prce->oper )
		{
		case operReplace:
			{
			err = ErrVERUndoReplace( prce );
			break;
			}
		case operInsert:
			{
			err = ErrVERUndoInsert( prce );
			break;
			}
		case operFlagDelete:
			{
			err = ErrVERUndoFlagDelete( prce );
			break;
			}
		case operInsertItem:
		case operFlagInsertItem:
			{
			err = ErrVERUndoInsertItem( prce );
			break;
			}
		case operFlagDeleteItem:
			{
			err = ErrVERUndoFlagDeleteItem( prce );
			break;
			}
		case operDelta:
			{
			err = ErrVERUndoDelta( prce );
			break;
			}
		}
	return err;
	}
					

#define FVERRollback( prce )									\
	( ( prce->oper != operDeleteTable							\
		&& prce->oper != operDeferFreeExt )						\
	|| prce->pfcb->dbid != dbidTemp )


LOCAL BOOL FVERIRollbackCreateTableIndex( RCE *prce, PGNO pgnoFDP  )
	{
	LEVEL	level = prce->level;
	RCE		*prceT = prce->prcePrevOfSession;

	Assert( level > 0 && level < levelMax );
	/*	this routine should, currently, only be used for
	/*	temporary database table close, i.e. delete operations.
	/**/
	Assert( prce->dbid == dbidTemp );

	for( ; prceT != prceNil; prceT = prceT->prcePrevOfSession )
		{
		Assert( prceT->level <= level );
		Assert( prceT->trxCommitted == trxMax );
		if ( prceT->level != level )
			{
			Assert( prceT->level < level );
			break;
			}
		if ( FOperDDL( prceT->oper ) && prceT->dbid == prce->dbid )
			{
			if ( prceT->oper == operCreateTable )
				{
				if ( prceT->pfcb->pgnoFDP == pgnoFDP )
					return fTrue;
				}
			else if ( prceT->oper == operCreateIndex )
				{
				if ( (*(FCB **)prceT->rgbData)->pgnoFDP == pgnoFDP )
					return fTrue;
				}
			}
		}

	return fFalse;
	}


ERR ErrVERRollback( PIB *ppib )
	{
	ERR		err;
	LEVEL  	level;
	RCE		*prce;
	TRX		trxAbort;

VERRollback:
	err = JET_errSuccess;
	level = ppib->level;

	/*	must be in a transaction in order to rollback
	/*	Rollback is done in 2 phase. 1st phase is to undo the versioned
	 *	operation and may involve IO. 2nd phase is nullify the undone
	 *	RCE. 2 phases are needed so that the version will be hold till all
	 *	IO is done, then wipe them all. If it is mixed, then once we undo
	 *	a RCE, the record become writable to other session. This may screw
	 *	up recovery where we may get write conflict since we have not guarrantee
	 *	that the log for operations on undone record won't be logged before
	 *	Rollback record is logged.
	 *	UNDONE: rollback should behave the same as commit, and need two phase log.
	/**/
	Assert( level > 0 );

	prce = ppib->prceNewest;

	while ( prce != prceNil )
		{
		Assert( prce->level <= level );
		if ( prce->level != level )
			{
			/*	polymorph warnings to JET_errSuccess.
			/**/
			err = JET_errSuccess;
			goto DeleteRCE;
			}

		Assert( err == JET_errSuccess );
		Assert( prce->trxCommitted == trxMax );

		/*	after we undo an operation on a page, let us
		/*	remember it in log file. Use prce to pass
		/*	prce->pfucb, prce->bm, and prce->rgdata for item if it
		/*	is item operations.
		/**/
		Assert( prce->oper == operNull || prce->pfcb != pfcbNil );

		/*	By the time rollback happen, all deferredBI replace should
		 *	have been patched up.
		 */
		Assert(	prce->oper != operReplaceWithDeferredBI );

		switch( prce->oper )
			{
			case operReplace:
			case operInsert:
			case operFlagDelete:
			case operInsertItem:
			case operFlagInsertItem:
			case operFlagDeleteItem:
			case operDelta:
				{
				Assert( FVERUndoLoggedOper( prce ) );
				err = ErrVERUndo( prce );
				break;
				}
			case operNull:
				{
				break;
				}
			case operExpungeLink:
			case operExpungeBackLink:
			case operWriteLock:
				{
				break;
				}
			case operDeferFreeExt:
				{
				/*	if defer free extent is for table or index, whose creation
				/*	is being rolled back in this transaction, then rollback
				/*	defer free ext, as rollback of alloc extent will free the
				/*	extent.  This must be done to avoid doubly freed space.
				/**/
				if ( prce->pfcb->dbid == dbidTemp
					&& FVERIRollbackCreateTableIndex( prce, ((VEREXT *)prce->rgbData)->pgnoChildFDP ) )
					{
					prce->oper = operNull;
					}
				break;
				}
			case operAllocExt:
				{
				Assert( prce->cbData == sizeof(VEREXT) );
				Assert( prce->pfcb->pgnoFDP == ((VEREXT *)prce->rgbData)->pgnoFDP );
				VERFreeExt( prce->pfcb,
					((VEREXT *)prce->rgbData)->pgnoFirst,
					((VEREXT *)prce->rgbData)->cpgSize );
				break;
				}
			case operCreateTable:
				{
				/*	decrement version count since about to purge
				/**/
				FCBVersionDecrement( prce->pfcb );
				VERUndoCreateTable( prce );
				break;
				}
			case operDeleteTable:
				{
				if ( prce->pfcb->dbid != dbidTemp || FVERIRollbackCreateTableIndex( prce, *(PGNO *)prce->rgbData ) )
					{
					VERUndoDeleteTable( prce );
					if ( prce->pfcb->dbid == dbidTemp )
						prce->oper = operNull;
					}
				else if ( prce->pfcb->dbid == dbidTemp && ppib->level == 1 )
					{
					/*	if rolling back close temporary table, i.e. delete
					/*	table, to level 0, then must perform commit to level 0
					/*	processing on temporary table.
					/**/
					VERCommit0DeleteTable( ppib, prce );
					}
				break;
				}
			case operRenameTable:
				{
				VERUndoRenameTable( prce );
				break;
				}
			case operAddColumn:
				{
				VERUndoAddColumn( prce );
				break;
				}
			case operDeleteColumn:
				{
				VERUndoDeleteColumn( prce );
				break;
				}
			case operRenameColumn:
				{
				err = ErrVERUndoRenameColumn( prce );
				break;
				}
			case operCreateIndex:
				{
				VERUndoCreateIndex( prce );
				break;
				}
			case operDeleteIndex:
				{
				VERUndoDeleteIndex( prce );
				break;
				}
			default:
				{
				Assert( prce->oper == operRenameIndex );
				VERUndoRenameIndex( prce );
				break;
				}
			}

		/*  handle errors
		/**/
		if ( err < 0 )
			{
			/*  if rollback fails due to an error, then we will disable
			/*  logging in order to force the system down (we are in
			/*  an uncontinuable state).  Recover to restart the database.
			/**/
			if (	err == JET_errLogWriteFail ||
					err == JET_errDiskFull ||
					err == JET_errDiskIO ||
					err == JET_errReadVerifyFailure )
				{
				/*  flush and halt the log
				/**/
				SignalSend( sigLogFlush );
				BFSleep( cmsecWaitLogFlush );
				fLGNoMoreLogWrite = fTrue;

				/*  if there is a BF with a before image, ensure
				/*  it is never written to disk and remove BI chain
				/**/
				if ( prce->pbfDeferredBI != pbfNil )
					{
					BFEnterCriticalSection( prce->pbfDeferredBI );
					prce->pbfDeferredBI->lgposModify = lgposMax;
					BFLeaveCriticalSection( prce->pbfDeferredBI );
					VERDeleteFromDeferredBIChain( prce );

					// Check again in case someone else cleaned up.
					if ( prce->pbfDeferredBI != pbfNil )
						{
						BF *pbfT = prce->pbfDeferredBI;
						Assert( prce->prceDeferredBINext == prceNil );
						BFUnpin( pbfT );
						prce->pbfDeferredBI = pbfNil;
						}
					}

				/*  continue rollback
				/**/
				err = JET_errSuccess;
				}

			/*  any other error, try again
			/**/
			else
				{
				goto HandleError;
				}
			}

		Assert( err == JET_errSuccess );

		if ( prce->oper != operNull &&
			FVERRollback( prce ) )
			{
			if ( !FOperDDL( prce->oper ) &&
				prce->oper != operDeferFreeExt &&
				prce->oper != operAllocExt )
				{
				prce->oper = operNull;
				VERDeleteRce( prce );
				}
			
			prce->oper = operNull;
			}
		
		if ( prce->oper == operNull )
			{
			/*	finished processing version for FCB
			/**/
			FCBVersionDecrement( prce->pfcb );
			}

		/*	get previous RCE of same session
		/**/
		do
			{
			prce = prce->prcePrevOfSession;
			if ( prce == prceNil )
				{
				goto DeleteRCE;
				}
				
			if ( prce->oper == operNull )
				{
				FCBVersionDecrement( prce->pfcb );
				}
			}
		while ( prce->oper == operNull );
		}

DeleteRCE:

	if ( ppib->level == 1 )
		trxAbort = ++trxNewest;

	Assert( level == ppib->level );
	Assert( err == JET_errSuccess );

	prce = ppib->prceNewest;

	while( prce != prceNil )
		{
		Assert( prce->level <= level );
		if ( prce->level != level )
			{
			/*	polymorph warnings to JET_errSuccess.
			/**/
			err = JET_errSuccess;
			goto Done;
			}

		Assert( err == JET_errSuccess );
		Assert( prce->trxCommitted == trxMax );

		/*	after we undo an operation on a page, let us
		/*	remember it in log file. Use prce to pass
		/*	prce->pfucb, prce->bm, and prce->rgdata for item if it
		/*	is item operations.
		/**/
		Assert( err == JET_errSuccess );

		if ( prce->oper != operNull &&
			 prce->oper != operDeferFreeExt &&
			 prce->oper != operAllocExt &&
			 FVERRollback( prce ) )
			{
			if ( !FOperDDL( prce->oper ) )
				{
				/*	although RCE will be deallocated, set
				/*	oper to operNull in case error in rollback
				/*	causes premature termination and does not
				/*	set ibNewestRce above this RCE.
				/**/
				prce->oper = operNull;

				/*	delete RCE from Version store and make the record accessible
				 */
				VERDeleteRce( prce );
				}
			/*	although RCE will be deallocated, set
			/*	oper to operNull in case error in rollback
			/*	causes premature termination and does not
			/*	set ibNewestRce above this RCE.
			/**/
			prce->oper = operNull;
			}

		/*	get next RCE. Skip operNull RCEs.
		/**/
		do
			{
			/*	Let alloce ext/free ext behave just like commit to level 0
			 *	even the rce's oper is Null, set it such that when clean up
			 *	it can compare if all bucket contains committed or aborted
			 *	elements.
			 */
			prce->level = ppib->level - 1;
			if ( prce->level == 0 )
				prce->trxCommitted = trxAbort;

			prce = prce->prcePrevOfSession;
			}
		while ( prce != prceNil && prce->oper == operNull );
		}

Done:
	/*	decrement session transaction level
	/**/
	if ( ppib->level == 1 )
		{
		SgEnterCriticalSection( critVer );

		if ( ppib->trxBegin0 == trxOldest )
			UpdateTrxOldest( ppib );

		/* set the session as having no transaction
		/**/
		ppib->trxBegin0 = trxMax;
		ppib->lgposStart = lgposMax;

//		PIBResetDeferFreeNodeSpace( ppib );

		SgLeaveCriticalSection( critVer );
		}

	Assert( ppib->level > 0 );
	--ppib->level;

	/*	prceNewest not needed anymore
	/**/
	if ( ppib->level == 0 )
		{
		PIBSetPrceNewest( ppib, prceNil );
		}

HandleError:
	Assert( err == JET_errOutOfBuffers || err == JET_errSuccess );
	if ( err < 0 )
		{
		BFSleep( cmsecWaitGeneric );
		goto VERRollback;
		}

	/*	rollback always succeeds
	/**/
	Assert( err == JET_errSuccess );
	return err;
	}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\makefile.inc ===
eapolmsg.mc: eapollog.h
    mapmsg EAPOL EAPOL_LOG_BASE eapollog.h > eapolmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\vtdispc.c ===
#include "std.h"

DeclAssertFile;


extern VTFNAddColumn				ErrInvalidAddColumn;
extern VTFNCloseTable				ErrInvalidCloseTable;
extern VTFNComputeStats 			ErrInvalidComputeStats;
extern VTFNCopyBookmarks			ErrInvalidCopyBookmarks;
extern VTFNCreateIndex				ErrInvalidCreateIndex;
extern VTFNCreateReference			ErrInvalidCreateReference;
extern VTFNDelete					ErrInvalidDelete;
extern VTFNDeleteColumn 			ErrInvalidDeleteColumn;
extern VTFNDeleteIndex				ErrInvalidDeleteIndex;
extern VTFNDeleteReference			ErrInvalidDeleteReference;
extern VTFNDupCursor				ErrInvalidDupCursor;
extern VTFNCloseTable				ErrInvalidEmptyTable;
extern VTFNGetBookmark				ErrInvalidGetBookmark;
extern VTFNGetChecksum				ErrInvalidGetChecksum;
extern VTFNGetCurrentIndex			ErrInvalidGetCurrentIndex;
extern VTFNGetCursorInfo			ErrInvalidGetCursorInfo;
extern VTFNGetRecordPosition		ErrInvalidGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrInvalidGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrInvalidGetTableIndexInfo;
extern VTFNGetTableInfo 			ErrInvalidGetTableInfo;
extern VTFNGetTableReferenceInfo	ErrInvalidGetTableReferenceInfo;
extern VTFNGotoBookmark 			ErrInvalidGotoBookmark;
extern VTFNGotoPosition 			ErrInvalidGotoPosition;
extern VTFNVtIdle					ErrInvalidVtIdle;
extern VTFNMakeKey					ErrInvalidMakeKey;
extern VTFNMove 					ErrInvalidMove;
extern VTFNNotifyBeginTrans			ErrInvalidNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrInvalidNotifyCommitTrans;
extern VTFNNotifyRollback			ErrInvalidNotifyRollback;
extern VTFNNotifyUpdateUfn			ErrInvalidNotifyUpdateUfn;
extern VTFNPrepareUpdate			ErrInvalidPrepareUpdate;
extern VTFNRenameColumn 			ErrInvalidRenameColumn;
extern VTFNRenameIndex				ErrInvalidRenameIndex;
extern VTFNRenameReference			ErrInvalidRenameReference;
extern VTFNRetrieveColumn			ErrInvalidRetrieveColumn;
extern VTFNRetrieveKey				ErrInvalidRetrieveKey;
extern VTFNSeek 					ErrInvalidSeek;
extern VTFNSetCurrentIndex			ErrInvalidSetCurrentIndex;
extern VTFNSetColumn				ErrInvalidSetColumn;
extern VTFNSetIndexRange			ErrInvalidSetIndexRange;
extern VTFNUpdate					ErrInvalidUpdate;


#ifndef RETAIL
CODECONST(VTDBGDEF) vtdbgdefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
	"Invalid Tableid",
	0,
	{
		0,
		0,
		0,
		0,
	},
	};
#endif	/* !RETAIL */

CODECONST(VTFNDEF) EXPORT vtfndefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
#ifdef	RETAIL
	NULL,
#else	/* !RETAIL */
	&vtdbgdefInvalidTableid,
#endif	/* !RETAIL */
	ErrInvalidAddColumn,
	ErrInvalidCloseTable,
	ErrInvalidComputeStats,
	ErrInvalidCopyBookmarks,
	ErrInvalidCreateIndex,
	ErrInvalidCreateReference,
	ErrInvalidDelete,
	ErrInvalidDeleteColumn,
	ErrInvalidDeleteIndex,
	ErrInvalidDeleteReference,
	ErrInvalidDupCursor,
	ErrInvalidGetBookmark,
	ErrInvalidGetChecksum,
	ErrInvalidGetCurrentIndex,
	ErrInvalidGetCursorInfo,
	ErrInvalidGetRecordPosition,
	ErrInvalidGetTableColumnInfo,
	ErrInvalidGetTableIndexInfo,
	ErrInvalidGetTableInfo,
	ErrInvalidGetTableReferenceInfo,
	ErrInvalidGotoBookmark,
	ErrInvalidGotoPosition,
	ErrInvalidVtIdle,
	ErrInvalidMakeKey,
	ErrInvalidMove,
	ErrInvalidNotifyBeginTrans,
	ErrInvalidNotifyCommitTrans,
	ErrInvalidNotifyRollback,
	ErrInvalidNotifyUpdateUfn,
	ErrInvalidPrepareUpdate,
	ErrInvalidRenameColumn,
	ErrInvalidRenameIndex,
	ErrInvalidRenameReference,
	ErrInvalidRetrieveColumn,
	ErrInvalidRetrieveKey,
	ErrInvalidSeek,
	ErrInvalidSetCurrentIndex,
	ErrInvalidSetColumn,
	ErrInvalidSetIndexRange,
	ErrInvalidUpdate,
	ErrInvalidEmptyTable,
	};


ERR VTAPI ErrDispAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pcolumnid, sizeof(JET_COLUMNID));

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);
	
	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;
	
	err = (*rgvtdef[tableid].pvtfndef->pfnAddColumn)(vsesid, vtid,
		szColumn, pcolumndef, pvDefault, cbDefault, pcolumnid);
	
	return(err);
	}


JET_VSESID UtilGetVSesidOfSesidTableid( JET_SESID sesid, JET_TABLEID tableid )
	{
	JET_VSESID	  vsesid;

	Assert( tableid <= tableidMax);

	vsesid = rgvtdef[tableid].vsesid;
	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	return vsesid;
	}


ERR VTAPI ErrDispCloseTable(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	/*	The check rfs call was removed. Currently ErrIsamCloseTable()
	/*	does not return an error.  If this changes, the disp may want
	/*	to call the check rfs function again.  If the close table
	/*	functions return errors rfs testing will not pass, so you'll
	/*	be turning off the bit anyways.
	/**/

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnCloseTable)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispComputeStats(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return JET_errInvalidTableId;

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnComputeStats)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispCopyBookmarks(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableidSrc > tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableidSrc].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableidSrc].vtid;

	err = (*rgvtdef[tableidSrc].pvtfndef->pfnCopyBookmarks)(vsesid, vtid,
		tableidDest, columnidDest, crecMax);

	return(err);
	}

ERR VTAPI ErrDispCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName, JET_GRBIT grbit,
	const char  *szKey, unsigned long cbKey, unsigned long lDensity)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnCreateIndex)(vsesid, vtid,
		szIndexName, grbit, szKey, cbKey, lDensity);

	return(err);
	}


ERR VTAPI ErrDispDelete(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnDelete)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumn)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnDeleteColumn)( vsesid, vtid, szColumn );

	return(err);
	}


ERR VTAPI ErrDispDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnDeleteIndex)(vsesid, vtid, szIndexName);

	return err;
	}


ERR VTAPI ErrDispDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(ptableid, sizeof(JET_TABLEID));

	if ( tableid >= tableidMax )
		return JET_errInvalidTableId;

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnDupCursor)( vsesid, vtid, ptableid, grbit );

	return err;
	}


ERR VTAPI ErrDispGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvBookmark, cbMax);
	FillClientBuffer(pcbActual, sizeof(unsigned long));

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetBookmark)(vsesid, vtid,
		pvBookmark, cbMax, pcbActual);

	return(err);
	}


ERR VTAPI ErrDispGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(szIndexName, cchIndexName);

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetCurrentIndex)(vsesid, vtid, szIndexName, cchIndexName);

	return(err);
	}


ERR VTAPI ErrDispGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvResult, cbMax);

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetCursorInfo)(vsesid, vtid, pvResult, cbMax, InfoLevel);

	return(err);
	}


ERR VTAPI ErrDispGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pkeypos, cbKeypos);

	if ( tableid >= tableidMax )
		return JET_errInvalidTableId ;

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetRecordPosition)(vsesid, vtid,
		pkeypos, cbKeypos);

	return err;
	}


ERR VTAPI ErrDispGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumnName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvResult, cbMax);

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetTableColumnInfo)(vsesid, vtid,
		szColumnName, pvResult, cbMax, InfoLevel);

	return(err);
	}


ERR VTAPI ErrDispGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvResult, cbMax);

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetTableIndexInfo)(vsesid, vtid,
		szIndexName, pvResult, cbMax, InfoLevel);

	return(err);
	}


ERR VTAPI ErrDispGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvResult, cbMax);

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetTableInfo)(vsesid, vtid,
		pvResult, cbMax, InfoLevel);

	return(err);
	}


ERR VTAPI ErrDispGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbBookmark)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
	 	vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = ( *rgvtdef[tableid].pvtfndef->pfnGotoBookmark )( vsesid, vtid, pvBookmark, cbBookmark );

	return(err);
	}


ERR VTAPI ErrDispGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGotoPosition)( vsesid, vtid, precpos );

	return(err);
	}


ERR VTAPI ErrDispMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void  *pvData, unsigned long cbData, JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnMakeKey)( vsesid, vtid, pvData, cbData, grbit );

	return(err);
	}


ERR VTAPI ErrDispMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnMove)(vsesid, vtid, cRow, grbit);

	return(err);
	}


ERR VTAPI ErrDispPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnPrepareUpdate)(vsesid, vtid, prep);

	return(err);
	}


ERR VTAPI ErrDispRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumn, const char  *szColumnNew)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnRenameColumn)(vsesid, vtid, szColumn, szColumnNew);

	return(err);
	}


ERR VTAPI ErrDispRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndex, const char  *szIndexNew)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnRenameIndex)(vsesid, vtid, szIndex, szIndexNew);

	return(err);
	}


ERR VTAPI ErrDispRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
	unsigned long  *pcbActual, JET_GRBIT grbit,
	JET_RETINFO  *pretinfo)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvData, cbData);
	FillClientBuffer(pcbActual, sizeof(unsigned long));

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnRetrieveColumn)(vsesid, vtid,
		columnid, pvData, cbData, pcbActual, grbit, pretinfo);

	return(err);
	}


ERR VTAPI ErrDispRetrieveKey(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvKey, unsigned long cbMax,
	unsigned long  *pcbActual, JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvKey, cbMax);
	FillClientBuffer(pcbActual, sizeof(unsigned long));

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnRetrieveKey)(vsesid, vtid,
		pvKey, cbMax, pcbActual, grbit);

	return(err);
	}


ERR VTAPI ErrDispSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnSeek)(vsesid, vtid, grbit);

	return(err);
	}


ERR VTAPI ErrDispSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnSetCurrentIndex)(vsesid, vtid, szIndexName);

	return(err);
	}


ERR VTAPI ErrDispSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void  *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO  *psetinfo)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnSetColumn)(vsesid, vtid,
		columnid, pvData, cbData, grbit, psetinfo);

	return(err);
	}


ERR VTAPI ErrDispSetIndexRange(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnSetIndexRange)(vsesid, vtid, grbit);

	return(err);
	}


ERR VTAPI ErrDispUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pvBookmark, cbBookmark);
	FillClientBuffer(pcbActual, sizeof(unsigned long));

	if ( tableid >= tableidMax )
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnUpdate)(vsesid, vtid,
		pvBookmark, cbBookmark, pcbActual);

	return(err);
	}


#pragma warning(disable: 4100)			 /* Suppress Unreferenced parameter */


ERR VTAPI ErrIllegalAddColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalCloseTable(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalComputeStats(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}

ERR VTAPI ErrIllegalCopyBookmarks(JET_VSESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return(JET_errIllegalOperation);
	}

ERR VTAPI ErrIllegalCreateIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName, JET_GRBIT grbit,
	const char  *szKey, unsigned long cbKey, unsigned long lDensity)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalCreateReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName, const char  *szColumns,
	const char  *szReferencedTable,
	const char  *szReferencedColumns, JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalDelete(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalDeleteColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalDeleteIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalDeleteReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalDupCursor(JET_VSESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalEmptyTable(JET_VSESID sesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetChecksum(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetCursorInfo(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetRecordPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetTableColumnInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumnName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetTableIndexInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetTableInfo(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGetTableReferenceInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGotoBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalGotoPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalVtIdle(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalMakeKey(JET_VSESID vsesid, JET_VTID vtid,
	const void  *pvData, unsigned long cbData, JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalMove(JET_VSESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalNotifyBeginTrans(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalNotifyCommitTrans(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalNotifyRollback(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalNotifyUpdateUfn(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalPrepareUpdate(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalRenameColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalRenameIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalRenameReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReference, const char  *szReferenceNew)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalRetrieveColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
	unsigned long  *pcbActual, JET_GRBIT grbit,
	JET_RETINFO  *pretinfo)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalRetrieveKey(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvKey, unsigned long cbMax,
	unsigned long  *pcbActual, JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalSeek(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalSetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalSetColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void  *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO  *psetinfo)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalSetIndexRange(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrIllegalUpdate(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual)
	{
	return(JET_errIllegalOperation);
	}


ERR VTAPI ErrInvalidAddColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidCloseTable(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidComputeStats(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}

ERR VTAPI ErrInvalidCopyBookmarks(JET_VSESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidCreateIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName, JET_GRBIT grbit,
	const char  *szKey, unsigned long cbKey, unsigned long lDensity)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidCreateReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName, const char  *szColumns,
	const char  *szReferencedTable,
	const char  *szReferencedColumns, JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidDelete(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidDeleteColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidDeleteIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidDeleteReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidDupCursor(JET_VSESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidEmptyTable(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetChecksum(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetCursorInfo(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetRecordPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetTableColumnInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumnName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetTableIndexInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetTableInfo(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGetTableReferenceInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReferenceName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGotoBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidGotoPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidVtIdle(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidMakeKey(JET_VSESID vsesid, JET_VTID vtid,
	const void  *pvData, unsigned long cbData, JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidMove(JET_VSESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidNotifyBeginTrans(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidNotifyCommitTrans(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidNotifyRollback(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidNotifyUpdateUfn(JET_VSESID vsesid, JET_VTID vtid)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidPrepareUpdate(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidRenameColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidRenameIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidRenameReference(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szReference, const char  *szReferenceNew)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidRetrieveColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
	unsigned long  *pcbActual, JET_GRBIT grbit,
	JET_RETINFO  *pretinfo)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidRetrieveKey(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvKey, unsigned long cbMax,
	unsigned long  *pcbActual, JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidSeek(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidSetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidSetColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void  *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO  *psetinfo)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidSetIndexRange(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return(JET_errInvalidTableId);
	}


ERR VTAPI ErrInvalidUpdate(JET_VSESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual)
	{
	return(JET_errInvalidTableId);
	}


#if 0
ERR VTAPI ErrDispEmptyTable(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnEmptyTable)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispGetChecksum(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long  *pChecksum)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	FillClientBuffer(pChecksum, sizeof(unsigned long));

	if (tableid >= tableidMax)
	return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnGetChecksum)(vsesid, vtid,
	pChecksum);

	return(err);
	}


ERR VTAPI ErrDispVtIdle(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnVtIdle)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispNotifyBeginTrans(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnNotifyBeginTrans)(vsesid, vtid);

	return(err);
	}


ERR VTAPI ErrDispNotifyCommitTrans(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnNotifyCommitTrans)(vsesid, vtid, grbit);

	return(err);
	}


ERR VTAPI ErrDispNotifyRollback(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnNotifyRollback)(vsesid, vtid, grbit);

	return(err);
	}


ERR VTAPI ErrDispNotifyUpdateUfn(JET_SESID sesid, JET_TABLEID tableid)
	{
	ERR			err;
	JET_VSESID	vsesid;
	JET_VTID	vtid;

	if (tableid >= tableidMax)
		return(JET_errInvalidTableId);

	vsesid = rgvtdef[tableid].vsesid;

	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		return JET_errInvalidTableId;

	err = (*rgvtdef[tableid].pvtfndef->pfnNotifyUpdateUfn)(vsesid, vtid);

	return(err);
	}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\convert\conv200.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "daestd.h"
#include "conv200.h"
DeclAssertFile;

#include "convmsg.h"

#define cbLvMax					1990*16		/* CONSIDER: Optimized for ISAM V1 */

#define ulCMPDefaultDensity		100			/* to be fine-tuned later */
#define ulCMPDefaultPages		0

#define NO_GRBIT				0


// UNDONE:  Must still be localised, but centralising all the localisable strings
// here makes my job easier.

static char				szDefaultTempDB[MAX_PATH] = "tempupgd.mdb";

#define szCompactStatsFile		"upgdinfo.txt"

#define szSwitches				"-/"

#define cNewLine				'\n'

#define szStats1				"%c%c***** Conversion of database '%s' started!%c"
#define szStats2				"%c***** Conversion of database '%s' completed in %d.%d seconds.%c%c"
#define szStats3				"%cNew database created and initialized in %d.%d seconds.%c"
#define szStats4				"    (Source database owns %d pages, of which %d are available.)%c"
#define szStats5				"%cCopying table '%s'..."
#define szStats6				"%cCopied table '%s' in %d.%d seconds.%c"
#define szStats7				"%c    Created new table in %d.%d seconds."
#define szStats8				"%c    Table has %d fixed/variable columns and %d tagged columns."
#define szStats9				"%c        (Source table owns %d pages, of which %d are available.)"
#define szStats10				"%c    Copying records..."
#define szStats11				"%c    Copied %d records in %d.%d seconds."
#define szStats12				"%c        (Traversed %d leaf pages and at least %d LV pages.)"
#define szStats13				"%c    Rebuilding non-clustered indexes..."
#define szStats14				"%c    Rebuilt %d non-clustered indexes in %d.%d seconds."

//
// The following parameters are set before calling JetInit of the old
// Db. This allows the recovery of the 200 db using the corresponding
// system parameters.
// Note: Values for sysDbPath, LogFilePath etc. are supplied in the arguments
//       but the following paramters are simply hardcoded here.
//
JET_PARAMS ParamListDhcp[]= {
        JET_PARAM( JET_paramMaxBuffers,50,NULL          ),
        JET_PARAM( JET_paramMaxSessions,10,NULL         ),
        JET_PARAM( JET_paramMaxOpenTables,18,NULL       ),
        JET_PARAM( JET_paramMaxVerPages,16,NULL         ),
        JET_PARAM( JET_paramMaxCursors,100,NULL         ),
        JET_PARAM( JET_paramMaxOpenTableIndexes,18,NULL ),
//        JET_PARAM( JET_paramMaxTemporaryTables,1,NULL   ),
        JET_PARAM( JET_paramMaxTemporaryTables,20,NULL   ),
        JET_PARAM( JET_paramLogBuffers,30,NULL          ),
        JET_PARAM( JET_paramBfThrshldLowPrcnt, 80, NULL ),
        JET_PARAM( JET_paramBfThrshldHighPrcnt, 100, NULL ),
        JET_PARAM( JET_paramLogFlushThreshold,20,NULL   ),
        JET_PARAM( JET_paramWaitLogFlush,100,NULL       ),
        JET_PARAM( JET_paramLast,0,NULL                 )
};

JET_PARAMS ParamListWins[]= {
        JET_PARAM( JET_paramMaxBuffers,500,NULL          ),
        JET_PARAM( JET_paramMaxSessions,52,NULL         ),
        JET_PARAM( JET_paramMaxOpenTables,56,NULL       ),
        JET_PARAM( JET_paramMaxVerPages,312,NULL         ),
        JET_PARAM( JET_paramMaxCursors,448,NULL         ),
        JET_PARAM( JET_paramMaxOpenDatabases,208,NULL         ),
        JET_PARAM( JET_paramMaxOpenTableIndexes,56,NULL ),
        JET_PARAM( JET_paramMaxTemporaryTables,10,NULL   ),
        JET_PARAM( JET_paramLogBuffers,30,NULL          ),
        // repeated JET_PARAM( JET_paramLogFlushThreshold,20,NULL          ),
        JET_PARAM( JET_paramBfThrshldLowPrcnt,80,NULL          ),
        JET_PARAM( JET_paramBfThrshldHighPrcnt,100,NULL          ),
        JET_PARAM( JET_paramLogFlushThreshold,20,NULL   ),
        JET_PARAM( JET_paramWaitLogFlush,100,NULL       ),
        JET_PARAM( JET_paramLast,0,NULL                 )
};

JET_PARAMS  ParamListRPL[] = {
    JET_PARAM( JET_paramMaxBuffers,250,NULL          ),
    JET_PARAM( JET_paramMaxSessions,10,NULL         ),
    JET_PARAM( JET_paramMaxOpenTables,30,NULL       ),
    JET_PARAM( JET_paramMaxVerPages,64,NULL         ),
    JET_PARAM( JET_paramMaxCursors,100,NULL         ),
    // JET_PARAM( JET_paramMaxOpenDatabases,???,NULL         ),
    JET_PARAM( JET_paramMaxOpenTableIndexes,105,NULL ),
    JET_PARAM( JET_paramMaxTemporaryTables,5,NULL   ),
    JET_PARAM( JET_paramLogBuffers,41,NULL          ),
    JET_PARAM( JET_paramLogFlushThreshold,10,NULL          ),
    // We handle the next one differently so that ParamSet==TRUE
    { JET_paramBfThrshldLowPrcnt,0,NULL,TRUE          },
    JET_PARAM( JET_paramBfThrshldHighPrcnt,100,NULL          ),
    // JET_PARAM( JET_paramWaitLogFlush,???,NULL       ),
    JET_PARAM( JET_paramLast,0,NULL                 )
};

char*    LogFilePath;
char	 *szBackupPath;
char    *BackupDefaultSuffix[DbTypeMax] = { "",
                                            "jet", // dhcp
                                            "wins_bak",   // wins
                                            ""          // rpl
                                            };


DEFAULT_VALUES DefaultValues[DbTypeMax] = {
    {
        NULL,NULL,NULL,NULL,NULL,NULL
    },
    {   // dhcp

        "System\\CurrentControlSet\\Services\\DhcpServer\\Parameters", // parameters key
        "DatabaseName",       // Db name key
        "%SystemRoot%\\System32\\dhcp\\dhcp.mdb", // DatabaseName
        "%SystemRoot%\\System32\\dhcp\\system.mdb", // SysDatabaseName
        "BackupDatabasePath", // BackupDbKey
        "%SystemRoot%\\System32\\dhcp\\backup", // BackupPath
    },
    {   // wins

        "System\\CurrentControlSet\\Services\\Wins\\Parameters", // parameters key
        "DbFileNm",       // Db name key
        "%SystemRoot%\\System32\\wins\\wins.mdb", // DatabaseName
        "%SystemRoot%\\System32\\wins\\system.mdb", // SysDatabaseName
        "BackupDirPath", // BackupDbKey
        NULL, // BackupPath
    },
    {   // rpl

        "System\\CurrentControlSet\\Services\\RemoteBoot\\Parameters",
        "Directory",
        "%SystemRoot%\\System32\\rpl\\rplsvc.mdb",
        "%SystemRoot%\\System32\\rpl\\system.mdb",
        NULL,
        "BACKUP"
    }
};

char            BackupPathBuffer[MAX_PATH];
char            SourceDbBuffer[MAX_PATH];
char            OldDllBuffer[MAX_PATH];
char            SysDbBuffer[MAX_PATH];
char            LogFilePathBuffer[MAX_PATH];
HANDLE          hMsgModule;

DB_TYPE  DbType = DbTypeMin;
JET_TABLEID WinsTableId = 0;
JET_COLUMNID WinsOwnerIdColumnId = 0;

//
// local protos
//

ERR DeleteCurrentDb( char * LogFilePath, char * SysDb );

typedef struct COLUMNIDINFO
	{
	JET_COLUMNID    columnidSrc;
	JET_COLUMNID    columnidDest;
	} COLUMNIDINFO;


// DLL entry points for CONVERT  --  must be consistent with EXPORTS.DEF
/*
#define	szJetInit				"JetInit@4"
#define	szJetTerm				"JetTerm@4"
#define szJetBeginSession		"JetBeginSession@16"
#define	szJetEndSession			"JetEndSession@8"
#define szJetAttachDatabase		"JetAttachDatabase@12"
#define szJetDetachDatabase		"JetDetachDatabase@8"
#define szJetOpenDatabase		"JetOpenDatabase@20"
#define szJetCloseDatabase		"JetCloseDatabase@12"
#define szJetOpenTable			"JetOpenTable@28"
#define szJetCloseTable			"JetCloseTable@8"
#define szJetRetrieveColumn		"JetRetrieveColumn@32"
#define szJetMove				"JetMove@16"
#define	szJetSetSystemParameter	"JetSetSystemParameter@20"
#define szJetGetObjectInfo		"JetGetObjectInfo@32"
#define szJetGetDatabaseInfo	"JetGetDatabaseInfo@20"
#define szJetGetTableInfo		"JetGetTableInfo@20"
#define szJetGetTableColumnInfo	"JetGetTableColumnInfo@24"
#define szJetGetTableIndexInfo	"JetGetTableIndexInfo@24"
#define szJetGetIndexInfo		"JetGetIndexInfo@28"
*/

// Hack for 200-series convert:
#define	szJetInit				((LPCSTR)145)
#define	szJetTerm				((LPCSTR)167)
#define szJetBeginSession		((LPCSTR)104)
#define	szJetEndSession			((LPCSTR)124)
#define szJetAttachDatabase		((LPCSTR)102)
#define szJetDetachDatabase		((LPCSTR)121)
#define szJetOpenDatabase		((LPCSTR)148)
#define szJetCloseDatabase		((LPCSTR)107)
#define szJetOpenTable			((LPCSTR)149)
#define szJetCloseTable			((LPCSTR)108)
#define szJetRetrieveColumn		((LPCSTR)157)
#define szJetMove				((LPCSTR)147)
#define	szJetSetSystemParameter	((LPCSTR)165)
#define szJetGetObjectInfo		((LPCSTR)134)
#define szJetGetDatabaseInfo	((LPCSTR)130)
#define szJetGetTableInfo		((LPCSTR)139)
#define szJetGetTableColumnInfo	((LPCSTR)137)
#define szJetGetTableIndexInfo	((LPCSTR)138)
#define szJetGetIndexInfo		((LPCSTR)131)
#define szJetRestore    		((LPCSTR)156)

//#undef JET_API
//#define JET_API _cdecl

INLINE LOCAL ERR JET_API ErrCDAttachDatabase(
	JET_SESID	sesid,
	const CHAR	*szFilename,
	JET_GRBIT	grbit )
	{
	return ErrIsamAttachDatabase( sesid, szFilename, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDDetachDatabase( JET_SESID sesid, const CHAR *szFilename )
	{
	return ErrIsamDetachDatabase( sesid, szFilename );
	}

INLINE LOCAL ERR JET_API ErrCDOpenDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabase,
	const CHAR	*szConnect,
	JET_DBID	*pdbid,
	JET_GRBIT	grbit )
	{
	return ErrIsamOpenDatabase( sesid, szDatabase, szConnect, pdbid, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDCloseDatabase(
	JET_SESID	sesid,
	JET_DBID	dbid,
	JET_GRBIT	grbit )
	{
	return ErrIsamCloseDatabase( sesid, dbid, grbit );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDOpenTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const CHAR		*szTableName,
	const VOID		*pvParameters,
	ULONG			cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid )
	{
	return ErrIsamOpenTable( sesid, dbid, ptableid, (CHAR *)szTableName, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDCloseTable( JET_SESID sesid, JET_TABLEID tableid )
	{
	return ErrDispCloseTable( sesid, tableid );
	}

INLINE LOCAL ERR JET_API ErrCDRetrieveColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	VOID			*pvData,
	ULONG			cbData,
	ULONG			*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	return ErrDispRetrieveColumn( sesid, tableid, columnid, pvData, cbData, pcbActual, grbit, pretinfo );
	}

INLINE LOCAL ERR JET_API ErrCDMove(
	JET_SESID	sesid,
	JET_TABLEID	tableid,
	signed long	cRow,
	JET_GRBIT	grbit )
	{
	return ErrDispMove( sesid, tableid, cRow, grbit );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDGetObjectInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OBJTYP		objtyp,
	const CHAR		*szContainerName,
	const CHAR		*szObjectName,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrIsamGetObjectInfo( sesid, dbid, objtyp, szContainerName, szObjectName, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetDatabaseInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrIsamGetDatabaseInfo( sesid, dbid, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableInfo( sesid, tableid, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableColumnInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const CHAR		*szColumnName,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableColumnInfo( sesid, tableid, szColumnName, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableIndexInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const CHAR		*szIndexName,
	VOID			*pvResult,
	ULONG			cbResult,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableIndexInfo( sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDGetIndexInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const CHAR		*szTableName,
	const CHAR		*szIndexName,
	VOID			*pvResult,
	ULONG			cbResult,
	ULONG			InfoLevel )
	{
	return ErrIsamGetIndexInfo( sesid, dbid, szTableName, szIndexName, pvResult, cbResult, InfoLevel );
	}

typedef ERR	JET_API VTCDInit( JET_INSTANCE *);
typedef ERR JET_API VTCDTerm( JET_INSTANCE );
typedef ERR JET_API VTCDBeginSession( JET_INSTANCE, JET_SESID *, const CHAR *, const CHAR *);
typedef ERR JET_API VTCDEndSession( JET_SESID, JET_GRBIT );
typedef ERR JET_API VTCDAttachDatabase( JET_SESID, const CHAR *, JET_GRBIT );
typedef ERR JET_API VTCDDetachDatabase( JET_SESID, const CHAR * );
typedef ERR JET_API VTCDOpenDatabase( JET_SESID, const CHAR *, const CHAR *, JET_DBID *, JET_GRBIT );
typedef ERR JET_API VTCDCloseDatabase( JET_SESID, JET_DBID, JET_GRBIT );
typedef ERR JET_API VTCDOpenTable( JET_SESID, JET_DBID, const CHAR *, const VOID *, ULONG, JET_GRBIT, JET_TABLEID * );
typedef ERR JET_API VTCDCloseTable( JET_SESID, JET_TABLEID );
typedef ERR JET_API VTCDRetrieveColumn( JET_SESID, JET_TABLEID, JET_COLUMNID, VOID *, ULONG, ULONG *, JET_GRBIT, JET_RETINFO * );
typedef ERR JET_API VTCDMove( JET_SESID, JET_TABLEID, signed long, JET_GRBIT );
typedef ERR JET_API VTCDSetSystemParameter( JET_INSTANCE *, JET_SESID, ULONG, ULONG, const CHAR * );
typedef ERR JET_API VTCDGetObjectInfo( JET_SESID, JET_DBID, JET_OBJTYP, const CHAR *, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetDatabaseInfo( JET_SESID, JET_DBID, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableInfo( JET_SESID, JET_TABLEID, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableColumnInfo( JET_SESID, JET_TABLEID, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableIndexInfo( JET_SESID, JET_TABLEID, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetIndexInfo( JET_SESID, JET_DBID, const CHAR *, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDRestore( const CHAR *, int crstmap, JET_RSTMAP *, JET_PFNSTATUS  );

typedef struct tagVTCD
	{
	JET_SESID				sesid;
	VTCDInit				*pErrCDInit;
	VTCDTerm				*pErrCDTerm;
	VTCDBeginSession		*pErrCDBeginSession;
	VTCDEndSession			*pErrCDEndSession;
	VTCDAttachDatabase		*pErrCDAttachDatabase;
	VTCDDetachDatabase		*pErrCDDetachDatabase;
	VTCDOpenDatabase		*pErrCDOpenDatabase;
	VTCDCloseDatabase		*pErrCDCloseDatabase;
	VTCDOpenTable			*pErrCDOpenTable;
	VTCDCloseTable			*pErrCDCloseTable;
	VTCDRetrieveColumn		*pErrCDRetrieveColumn;					
	VTCDMove				*pErrCDMove;
	VTCDSetSystemParameter	*pErrCDSetSystemParameter;
	VTCDGetObjectInfo		*pErrCDGetObjectInfo;	
	VTCDGetDatabaseInfo		*pErrCDGetDatabaseInfo;
	VTCDGetTableInfo		*pErrCDGetTableInfo;
	VTCDGetTableColumnInfo	*pErrCDGetTableColumnInfo;
	VTCDGetTableIndexInfo	*pErrCDGetTableIndexInfo;
	VTCDGetIndexInfo		*pErrCDGetIndexInfo;
	VTCDRestore     		*pErrCDRestore;

	} VTCD;		// The virtual function table used by compact's function dispatcher.


typedef struct tagCOMPACTINFO
	{
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	COLUMNIDINFO	rgcolumnids[JET_ccolTableMost];
	ULONG			ccolSingleValue;
	STATUSINFO		*pstatus;
	JET_CONVERT		*pconvert;
	VTCD			vtcd;
	CHAR			rgbBuf[cbLvMax];
	} COMPACTINFO;

#define cbMsgBufMax	256

INLINE LOCAL VOID CMPFormatMessage( ULONG ulMsgId, CHAR *szMsgBuf, va_list *szMsgArgs )
	{
	DWORD	err;
//	CHAR	*rgszMsgArgs[1] = { szMsgArg };		// Currently only support one argument.
	
    err = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        hMsgModule,
        ulMsgId,
        LANG_USER_DEFAULT,
        szMsgBuf,
        cbMsgBufMax,
        szMsgArgs );
    if ( err == 0 )
		{
        DWORD WinError = GetLastError();

		// Format message failed.  No choice but to dump the error message
		// in English, then bail out.
		printf( "Unexpected Win32 error: %dL\n\n", WinError );
		DBGprintf(( "Unexpected Win32 error: %dL\n\n", WinError ));
		exit( WinError );
		}
	}
	

// Allocates a local buffer for the message, retrieves the message, and prints it out.
LOCAL VOID CMPPrintMessage( ULONG ulMsgId, ... )
	{
	CHAR	szMsgBuf[cbMsgBufMax];
    CHAR    szOemBuf[cbMsgBufMax];
    va_list argList;

    va_start( argList, ulMsgId );
	CMPFormatMessage( ulMsgId, szMsgBuf, &argList);
    CharToOem( szMsgBuf, szOemBuf );
	printf( szOemBuf );
    DBGprintf(( szMsgBuf ));
	}

/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPReportProgress                                                                            *
*                                                                                                                                               *
*       Arguments: pcompactinfo - Compact information segment                                   *
*                                                                                                                                               *
*       Returns : JET_ERR returned by the status call back function                     *
*                                                                                                                                               *
*       Procedure fill up the correct details in the SNMSG structure and call   *
*       the status call back function.                                                                          *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

LOCAL ERR ErrCMPReportProgress( STATUSINFO *pstatus )
	{
	JET_SNPROG	snprog;

	Assert( pstatus != NULL );
	Assert( pstatus->pfnStatus != NULL );
	Assert( pstatus->snp == JET_snpCompact );

	snprog.cbStruct = sizeof( JET_SNPROG );
	snprog.cunitDone = pstatus->cunitDone;
	snprog.cunitTotal = pstatus->cunitTotal;

	Assert( snprog.cunitDone <= snprog.cunitTotal );

	return ( ERR )( *pstatus->pfnStatus )(
			pstatus->sesid,
			pstatus->snp,
			pstatus->snt,
			&snprog );
	}


INLINE LOCAL ERR ErrCMPPopulateVTCD( VTCD *pvtcd, HINSTANCE hDll )
	{
	FARPROC	pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetInit ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDInit = (VTCDInit *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetTerm ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDTerm = (VTCDTerm *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetBeginSession ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDBeginSession = (VTCDBeginSession *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetEndSession ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDEndSession = (VTCDEndSession *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetAttachDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDAttachDatabase = (VTCDAttachDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetDetachDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDDetachDatabase = (VTCDDetachDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetOpenDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDOpenDatabase = (VTCDOpenDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetCloseDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDCloseDatabase = (VTCDCloseDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetOpenTable ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDOpenTable = (VTCDOpenTable *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetCloseTable ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDCloseTable = (VTCDCloseTable *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetRetrieveColumn ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDRetrieveColumn = (VTCDRetrieveColumn *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetMove ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDMove = (VTCDMove *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetSetSystemParameter ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDSetSystemParameter = (VTCDSetSystemParameter *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetObjectInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetObjectInfo = (VTCDGetObjectInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetDatabaseInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetDatabaseInfo = (VTCDGetDatabaseInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableInfo = (VTCDGetTableInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableColumnInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableColumnInfo = (VTCDGetTableColumnInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableIndexInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableIndexInfo = (VTCDGetTableIndexInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetIndexInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetIndexInfo = (VTCDGetIndexInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetRestore ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDRestore = (VTCDRestore *)pfn;

	return JET_errSuccess;	
	}

/*******************************************************************
 * Recover200Db()
 *
 *  This routine does the recovery of the old jet200 database before
 *  we do the coversion.
 *  It basically sets all the parameters and then call JetInit - JetTerm.
 *
 *********************************************************************/
LOCAL ERR Recover200Db(
	VTCD		*pvtcd,
	JET_CONVERT	*pconvert ) {


	ERR				err = JET_errSuccess;
    INT             i;
    PJET_PARAMS ParamList;

	Assert( LogFilePath != NULL );
	Assert( pconvert->szOldSysDb != NULL );

    // printf("Recovering the old database\n" );

    //
    // These parameters must be set for each type of database.
    // printf("Setting sys paramters on old db\n");
    Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramSysDbPath, 0, pconvert->szOldSysDb ) );
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramRecovery, 0, "on" ) );
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramLogFilePath, 0, LogFilePath ) );

    if ( DbType == DbDhcp ) {
        ParamList   =   ParamListDhcp;
    } else if ( DbType == DbWins ) {
        ParamList   =   ParamListWins;
    } else if ( DbType == DbRPL ) {
        ParamList   =   ParamListRPL;
    } else {
        Assert( FALSE );
    }

    for ( i = 0; ParamList[i].ParamOrdVal != JET_paramLast; i++ ) {
        Assert( ParamList[i].ParamSet );
        CallR( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, ParamList[i].ParamOrdVal, ParamList[i].ParamIntVal, ParamList[i].ParamStrVal ) );
    }

    DBGprintf(( "Just before calling JetInit on the old database\n"));
	Call( (*pvtcd->pErrCDInit)( 0 ) );
    DBGprintf(("just before calling JetTerm on the old database\n"));
	Call( (*pvtcd->pErrCDTerm)( 0 ) );
    DBGprintf(("Successfully recovered the old database\n"));

    return JET_errSuccess;
HandleError:
    return err;
    }

/*******************************************************************
 * Recover200Db()
 *
 *  This routine tries to restore the jet200 database from the backup.
 *  we do the coversion.
 *  It basically sets all the parameters and then call JetInit - JetTerm.
 *
 *********************************************************************/
LOCAL ERR Restore200Db(
	VTCD		*pvtcd
	) {

	ERR				err = JET_errSuccess;
    INT             i;
    PJET_PARAMS ParamList;


    CMPPrintMessage( CONVERT_START_RESTORE_ID, NULL );

    Assert( szBackupPath );


	Call( (*pvtcd->pErrCDRestore)( szBackupPath, 0, NULL, NULL ) );

    return JET_errSuccess;
HandleError:
    return err;
    }


INLINE LOCAL ERR ErrCMPConvertInit(
	VTCD		*pvtcd,
	JET_CONVERT	*pconvert,
	const CHAR	*szDatabaseSrc )
	{
	ERR			err;
	HINSTANCE	hDll;
    CHAR        errBuf[11];

	hDll = LoadLibrary( pconvert->szOldDll );
	if ( hDll == NULL ) {
        sprintf(errBuf,"%ld",GetLastError());
        CMPPrintMessage( CONVERT_ERR_OPEN_JET2000_ID, errBuf );
		return ErrERRCheck( JET_errAccessDenied );
    }

	Call( ErrCMPPopulateVTCD( pvtcd, hDll ) );

    	if ( ( err = Recover200Db( pvtcd, pconvert ) ) != JET_errSuccess ){
            sprintf(errBuf,"%d",err);
            CMPPrintMessage( CONVERT_ERR_RECOVER_FAIL1_ID, errBuf );
            CMPPrintMessage( CONVERT_ERR_RECOVER_FAIL2_ID, NULL );
            CMPPrintMessage( CONVERT_ERR_RECOVER_FAIL3_ID, NULL );
            if ( szBackupPath ) {
                if ( ( err = Restore200Db( pvtcd ) ) != JET_errSuccess ){
                    sprintf(errBuf,"%d",err);
                    CMPPrintMessage( CONVERT_ERR_RESTORE_FAIL1_ID, errBuf );
                    CMPPrintMessage( CONVERT_ERR_RESTORE_FAIL2_ID, NULL );

                }
            }
        }

        if ( err != JET_errSuccess ) {
            return err;
        }



    //
    // Now delete the old log files
    //

//	Call( DeleteOldLogs( ) );

	if ( pconvert->szOldSysDb )
		{
		// Use JET_paramSysDbPath (instead of JET_paramSystemPath) for
		// backward compatibility with pre-500 series JET.
		Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramSysDbPath, 0, pconvert->szOldSysDb ) );
		}
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramTempPath, 0, "tempconv.edb" ) );
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramRecovery, 0, "off" ) );
	Call( (*pvtcd->pErrCDInit)( 0 ) );
	Call( (*pvtcd->pErrCDBeginSession)( 0, &pvtcd->sesid, "user", "" ) );
	Call( (*pvtcd->pErrCDAttachDatabase)( pvtcd->sesid, szDatabaseSrc, 0 ) );
	pconvert->fDbAttached = ( err == JET_wrnDatabaseAttached );

HandleError:
	return err;
	}


INLINE LOCAL ERR ErrCMPConvertCleanup(
	VTCD		*pvtcd,
	JET_CONVERT	*pconvert,
	const CHAR	*szDatabaseSrc,
	BOOL		fErrorOccurred )
	{
	ERR			err;
	JET_SESID	sesid = pvtcd->sesid;
	HINSTANCE	hDll = GetModuleHandle( pconvert->szOldDll );
	BOOL		fFunctionsLoaded;

	// Ensure that the functions we need are callable.
	fFunctionsLoaded = ( pvtcd->pErrCDDetachDatabase  &&
		pvtcd->pErrCDEndSession  &&  pvtcd->pErrCDTerm );
	if ( !fFunctionsLoaded )
		{
		err = JET_errSuccess;		// Can't shutdown gracefully.  Just get out.
		goto Done;
		}

	if ( fErrorOccurred )
		{
		err = JET_errSuccess;		// Force cleanup and return success.
		goto HandleError;
		}

	Assert( pvtcd->sesid != 0 );

	if ( !pconvert->fDbAttached )
		{
		Call( (*pvtcd->pErrCDDetachDatabase)( pvtcd->sesid, szDatabaseSrc ) );
		}

	Call( (*pvtcd->pErrCDEndSession)( pvtcd->sesid, 0 ) );
	sesid = 0;
	Call( (*pvtcd->pErrCDTerm)( 0 ) );

	goto Done;


HandleError:

	// Error has already occurred.  Ignore any errors generated by these
	// functions as we attempt to clean up.
	if ( sesid != 0 )
		{
		if ( !pconvert->fDbAttached )
			{
			(VOID)( (*pvtcd->pErrCDDetachDatabase)( pvtcd->sesid, szDatabaseSrc ) );
			}
		(VOID)( (*pvtcd->pErrCDEndSession)( pvtcd->sesid, 0 ) );
		}

	(VOID)( (*pvtcd->pErrCDTerm)( 0 ) );


Done:
	if ( hDll )
		{
		FreeLibrary( hDll );
		}

	return err;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPCompactInit                                                                                                       *
*                                                                                                                                               *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szDatabaseSrc        - Source database that will be converted    *
*                          szConnectSrc         - Connect string for source database            *
*                          szDatabaseDest       - Destination database name                             *
*                          szConnectDest        - Connect string for destination database       *
*                          grbitCompact         - Compact options                                                       *
*                                                                                                                                               *
*       Returns : JET_ERR                                                                                                       *
*                                                                                                                                               *
*       Procedure Opens the source database.  It creates and opens                      *
*       the destination database.                                                                                               *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCompactInit(
	COMPACTINFO     *pcompactinfo,
	const CHAR      *szDatabaseSrc,
	const CHAR      *szDatabaseDest )
	{
	ERR				err;
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	sesid = pcompactinfo->sesid;

	/*	open the source DB Exclusive and ReadOnly
	/**/
	CallR( (*pvtcd->pErrCDOpenDatabase)( pvtcd->sesid,
		szDatabaseSrc, NULL, &dbidSrc,
		JET_bitDbExclusive|JET_bitDbReadOnly ) );

	/* Create and then open the destination database. */

	/* JET_bitCompactDontCopyLocale is set when the user */
	/* wants to ensure that all locales are homogeneous */
	/* throughout the new compacted db - there are to be no */
	/* mixed-language indexes or tables. */

	/* Build a connect string for the destination database if the user */
	/* hasn't supplied one. */

	/* CONSIDER: Always build the connect substring and insert it into */
	/* CONSIDER: the user supplied connect string following the first */
	/* CONSIDER: semicolon ( if any ).  If the user has specified a locale, */
	/* CONSIDER: it will override the one from the connect substring. */

	Call( ErrIsamCreateDatabase( sesid, szDatabaseDest, NULL,
		&dbidDest, JET_bitDbRecoveryOff|JET_bitDbVersioningOff ) );

	/* CONSIDER: Should the destination database be deleted if it already */
	/* CONSIDER: exists? */

	pcompactinfo->dbidSrc = dbidSrc;
	pcompactinfo->dbidDest = dbidDest;

	return( JET_errSuccess );

HandleError:
	(*pvtcd->pErrCDCloseDatabase)( pvtcd->sesid, (JET_VDBID)dbidSrc, 0 );

	return( err );
	}


INLINE LOCAL ERR ErrCMPCopyTaggedColumns(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	JET_COLUMNID	*mpcolumnidcolumnidTagged )
	{
	ERR				err;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	ULONG			cbActual;
	JET_COLUMNID	columnidSrc;
	JET_COLUMNID	columnidDest;
	JET_SETINFO		setinfo = { sizeof(JET_SETINFO), 0, 1 };
	JET_RETINFO		retinfo = { sizeof(JET_RETINFO), 0, 1, 0 };

		
	CallR( (*pvtcd->pErrCDRetrieveColumn)(
		pvtcd->sesid,
		tableidSrc,
		0,
		pcompactinfo->rgbBuf,
		cbLvMax,
		&cbActual,
		JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
		&retinfo ) );

	columnidSrc = 0;
	while ( err != JET_wrnColumnNull )
		{
		Assert( FTaggedFid( retinfo.columnidNextTagged ) );

		// Is this a new column, or another occurrence of the current column?
		if ( columnidSrc == retinfo.columnidNextTagged )
			{
			Assert( setinfo.itagSequence >= 1 );
			setinfo.itagSequence++;
			}
		else
			{
			columnidSrc = retinfo.columnidNextTagged;
			setinfo.itagSequence = 1;
			}

		Assert( mpcolumnidcolumnidTagged != NULL );
		columnidDest = mpcolumnidcolumnidTagged[columnidSrc - fidTaggedLeast];

		if ( cbActual > 0  ||  err == JET_wrnColumnSetNull )
			{
			ULONG	itagSequenceSave;

			// Save off table's retinfo, then set retinfo for current column.
			itagSequenceSave = retinfo.itagSequence;
			retinfo.itagSequence = setinfo.itagSequence;
			Assert( retinfo.ibLongValue == 0 );

			if ( cbActual > cbLvMax )
				{
				Assert( err == JET_wrnBufferTruncated );
				cbActual = cbLvMax;
				}

			Assert( setinfo.ibLongValue == 0 );
			CallR( ErrDispSetColumn(
				pcompactinfo->sesid,
				tableidDest,
				columnidDest,
				pcompactinfo->rgbBuf,
				cbActual,
				NO_GRBIT,
				&setinfo ) );

			/* while the long value is not all copied */

			while ( cbActual == cbLvMax )
				{
				retinfo.ibLongValue += cbLvMax;

				CallR( (*pvtcd->pErrCDRetrieveColumn)(
					pvtcd->sesid,
					tableidSrc,
					columnidSrc,
					pcompactinfo->rgbBuf,
					cbLvMax,
					&cbActual,
					JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
					&retinfo ) );
				Assert( err == JET_wrnBufferTruncated  ||  err == JET_errSuccess );
				Assert( retinfo.columnidNextTagged == columnidSrc );
				
				// Even though we specified RetrieveNull (to be consistent with
				// the initial call), we shouldn't encounter any (the initial
				// call would have handled it).
				// Note that even though we shouldn't get wrnColumnNull, cbActual
				// may still be 0 because retinfo.ibLongValue is greater than 0.
				Assert( err != JET_wrnColumnSetNull );
				Assert( err != JET_wrnColumnNull );

				if ( cbActual > 0 )
					{
					if ( cbActual > cbLvMax )
						{
						Assert( err == JET_wrnBufferTruncated );
						cbActual = cbLvMax;
						}

					// Since we're appending, no need to set ibLongValue.
					Assert( setinfo.ibLongValue == 0 );
					CallR( ErrDispSetColumn(
						pcompactinfo->sesid,
						tableidDest,
						columnidDest,
						pcompactinfo->rgbBuf,
						cbActual,
						JET_bitSetAppendLV,
						&setinfo ) );
					}
				}

			// Restore retinfo for next column.
			retinfo.itagSequence = itagSequenceSave;
			retinfo.ibLongValue = 0;
			}

		else		//	!( cbActual > 0 )
			{
			Assert( setinfo.ibLongValue == 0 );
			CallR( ErrDispSetColumn(
				pcompactinfo->sesid,
				tableidDest,
				columnidDest,
				NULL,
				0,
				JET_bitSetZeroLength,
				&setinfo ) );
			}

		retinfo.itagSequence++;

		Assert( retinfo.ibLongValue == 0 );
		
		CallR( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			tableidSrc,
			0,
			pcompactinfo->rgbBuf,
			cbLvMax,
			&cbActual,
			JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
			&retinfo ) );

		}	// ( err != JET_wrnColumnNull )

	return JET_errSuccess;
	}

/*---------------------------------------------------------------------------
*                                                                                       *
*       Procedure: ErrCMPCopyColumnData                                                 *
*                                                                                       *
*       Arguments: sesid        - session id in which the work is done                  *
*                  tableidSrc   - tableid pointing to the row in the SrcTbl             *
*                  tableidDest  - tableid pointing to the row in the DestTbl            *
*                  columnidSrc  - the columnid of the column in the srcDb               *
*                  columnidDest - the columnid of the column in the DestDb              *
*                  pvBuf                - the segment for copying long values           *
*                                                                                       *
*       Returns : JET_ERR                                                               *
*                                                                                       *
*       Procedure copies a column for the from the source to dest db.                   *
*                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyColumnData(
	JET_SESID		sesid,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	JET_COLUMNID	columnidSrc,
	JET_COLUMNID	columnidDest,
	VOID			*pvBuf,
	VTCD			*pvtcd )
	{
	ULONG			cbActual;
	JET_GRBIT		grbit;
	JET_RETINFO		retinfo;
	ERR				err;

	retinfo.cbStruct = sizeof( retinfo );
	retinfo.ibLongValue = 0;
	retinfo.itagSequence = 1;
	retinfo.columnidNextTagged = 0;

	// Tagged columns are handled in CMPCopyTaggedColumns().
	Assert( !FTaggedFid( columnidSrc ) );
	Assert( !FTaggedFid( columnidDest ) );

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidSrc, columnidSrc, pvBuf,
			cbLvMax, &cbActual, NO_GRBIT, &retinfo ) );

	Assert( cbActual <= JET_cbColumnMost );
	Assert( err == JET_errSuccess  ||  err == JET_wrnColumnNull );

	grbit = ( cbActual == 0  &&  err != JET_wrnColumnNull ?
		JET_bitSetZeroLength : NO_GRBIT );

    //
    // Hack to upgrade wins database.
    //
    if ( (tableidSrc == WinsTableId) && (columnidSrc == WinsOwnerIdColumnId) && (DbType == DbWins)) {
        // printf("Found wins ownerid during copycolumndata\n");
        Assert( cbActual == UlCATColumnSize(JET_coltypUnsignedByte,0,NULL));
        cbActual = UlCATColumnSize(JET_coltypLong,0,NULL );
        // printf("Old/New=(%d/", *(UNALIGNED LPLONG)pvBuf);
        *(LPLONG)pvBuf = (*(LPLONG)pvBuf & 0xff);
        // printf("%d\n", *(LPLONG)pvBuf);
    }

	CallR( ErrDispSetColumn( sesid, tableidDest, columnidDest, pvBuf,
			cbActual, grbit, NULL ) );

	return( JET_errSuccess );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyOneIndex                                                                                              *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          tableidDest          - table on which to build the index                     *
*                          szTableName          - table name on which the index is based    *
*                          indexList            - struct return from JetGetTableIndexInfo   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the columns for a table from the source db                             *
*       to the destination databases                                                                                    *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

LOCAL ERR ErrCMPCopyOneIndex(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList )
	{
	CHAR			*szSeg;
	ERR				err;
	CHAR			szIndexName[JET_cbNameMost+1];
	CHAR			rgchColumnName[JET_cbNameMost];
	JET_GRBIT		grbit;
	JET_GRBIT		grbitColumn;
	ULONG			ichKey;
	ULONG			cbActual;
	ULONG			ulDensity = ulCMPDefaultDensity;
	USHORT			langid = 0;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	szSeg = pcompactinfo->rgbBuf;

	/* retrieve info from table and create the index */

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidindexname, szIndexName,
				JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

	szIndexName[cbActual] = '\0';

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidgrbitIndex, &grbit,
				sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

	/* create the szkey used in ErrIsamCreateIndex */

	ichKey = 0;

	for ( ;; )
		{
		ULONG	iColumn;

		/* Get the individual columns that make up the index */

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitColumn, &grbitColumn,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidcolumnname, rgchColumnName,
					JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

		if ( grbitColumn == JET_bitKeyDescending )
			szSeg[ichKey++] = '-';
		else
			szSeg[ichKey++] = '+';

		/* Append the column name to the description */

		memcpy( szSeg+ichKey, rgchColumnName, ( size_t ) cbActual );

		ichKey += cbActual;
		szSeg[ichKey++] = '\0';

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );

		if ( err == JET_errNoCurrentRecord )
			break;

		if ( err < 0 )
			{
			return( err );
			}

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidiColumn, &iColumn,
				sizeof( iColumn ), &cbActual, NO_GRBIT, NULL ) );

		if ( iColumn == 0 )
			break;         /* Start of a new Index */
		}

	szSeg[ichKey++] = '\0';
/*
	CallR( (*pvtcd->pErrCDGetIndexInfo)(
		pvtcd->sesid,
		(JET_VDBID)pcompactinfo->dbidSrc,
		szTableName,
		szIndexName,
		&ulDensity,
		sizeof(ulDensity),
		JET_IdxInfoSpaceAlloc ) );
*/
	/*      get index language id
	/**/
/*	CallR( (*pvtcd->pErrCDGetIndexInfo)(
		pvtcd->sesid,
		pcompactinfo->dbidSrc,
		szTableName,
		szIndexName,
		&langid,
		sizeof(langid),
		JET_IdxInfoLangid ) );
*/
	if ( langid != 0 )
		{
		*((UNALIGNED USHORT *)(&szSeg[ichKey])) = langid;
		ichKey += 2;
		szSeg[ichKey++] = '\0';
		szSeg[ichKey++] = '\0';
		}

	CallR( ErrDispCreateIndex( pcompactinfo->sesid, tableidDest,
			szIndexName, grbit, szSeg, ichKey, ulDensity ) );

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MovePrevious, NO_GRBIT );

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPCopyTableIndexes                                                                          *
*                                                                                                                                               *
*       Arguments: pcompactinfo                                                                                                 *
*                  tableidDest  - table on which to build the index                             *
*                  szTableName  - table name on which the index is based                *
*                  indexList    - struct return from JetGetTableIndexInfo               *
*                                                                                                                                               *
*       Returns : JET_ERR                                                                                                       *
*                                                                                                                                               *
*       Procedure copies all the indexes except for the clustered index         *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyTableIndexes(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList,
	ULONG			cpgPerIndex )
	{
	ERR				err;
	JET_GRBIT		grbit;
	ULONG			cbActual;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop through all the indexes for this table          */

	while ( err >= 0 )
		{
		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitIndex,
					&grbit, sizeof( JET_GRBIT ), &cbActual,
					NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is not cluster create the index using CopyOneIndex */

			if ( ( grbit & JET_bitIndexClustered ) == 0 )
				{
				CallR( ErrCMPCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );

				if ( pcompactinfo->pstatus )
					{
					pcompactinfo->pstatus->cNCIndexes++;
					pcompactinfo->pstatus->cunitDone += cpgPerIndex;
					CallR( ErrCMPReportProgress( pcompactinfo->pstatus ) );
					}
				}
			}

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyClusteredIndex                                                                                *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          tableidDest          - table on which to build the index                     *
*                          szTableName          - table name on which the index is based    *
*                          indexList            - struct return from JetGetTableIndexInfo   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure checks to see if there is cluster index for the function              *
*       if there is it creates the clustered index                                                              *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyClusteredIndex(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList,
	BOOL			*pfClustered )
	{
	ERR				err;
	JET_GRBIT		grbit;
	ULONG			cbActual;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	*pfClustered = fFalse;

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* while there are still index rows or a cluster index has been found */

	while ( err >= 0 )
		{
		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitIndex, &grbit,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is clustered then create it */

			if ( grbit & JET_bitIndexClustered )
				{
				CallR( ErrCMPCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );
				*pfClustered = fTrue;
				break;
				}
			}

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCreateTableColumn                                                                                                *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                  tableidDest          - table on which to build the index                     *
*                  szTableName          - table name on which the index is based    *
*                  columnList           - struct returned from GetTableColumnInfo       *
*                  columnidInfo         - the columnid's of the user table                      *
*                  tableidTagged        - the tableid of the tagged columns                     *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the columns for a table from the source db                             *
*       to the destination databases                                                                                    *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCreateTableColumn(
	COMPACTINFO		*pcompactinfo,
	const CHAR		*szTableName,
	JET_TABLECREATE	*ptablecreate,
	JET_COLUMNLIST	*columnList,
	COLUMNIDINFO	*columnidInfo,
	JET_COLUMNID	**pmpcolumnidcolumnidTagged )
	{
	ERR				err;
	JET_SESID		sesid;
	JET_DBID		dbidSrc, dbidDest;
	ULONG			ccolSingleValue = 0, cColumns = 0;
	ULONG			cbAllocate;
	ULONG			cbActual;
	JET_COLUMNID	*mpcolumnidcolumnidTagged = NULL;
	BOOL			fLocalAlloc = fFalse;
	JET_COLUMNCREATE *rgcolcreate, *pcolcreateCurr;
	JET_COLUMNID	*rgcolumnidSrc, *pcolumnidSrc;
	JET_COLUMNID	columnidTaggedHighest = 0;
	BYTE			*rgbDefaultValues, *pbCurrDefault;
	BYTE			*pbMax;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	ULONG			cTagged = 0;

	typedef struct
		{
		BYTE 	szName[JET_cbNameMost+1+3];	// +1 for null-terminator, +3 for 4-byte alignment
		ULONG	ulPOrder;					// Only needs to be short, but make long for alignment
		} NAME_PO;
	NAME_PO			*rgNamePO, *pNamePOCurr;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;

	Assert( ptablecreate->cCreated == 0 );

	// Allocate a pool of memory for:
	//		1) list of source table columnids
	//		2) the JET_COLUMNCREATE structures
	//		3) buffer for column names and presentation order
	//		4) buffer for default values and presentation order
	// WARNING: Ensure that each of the elements above is 4-byte aligned

	cColumns = columnList->cRecord;
	cbAllocate =
		( cColumns *
			( sizeof(JET_COLUMNID) +	// source table columnids
			sizeof(JET_COLUMNCREATE) +	// JET_COLUMNCREATE structures
			sizeof(NAME_PO) ) )			// column names and presentation order
		+ cbRECRecordMost;				// all default values must fit in an intrinsic record

	// Can we use the buffer hanging off pcompactinfo?
	if ( cbAllocate <= cbLvMax )
		{
		rgcolumnidSrc = (JET_COLUMNID *)pcompactinfo->rgbBuf;
		}
	else
		{
		rgcolumnidSrc = SAlloc( cbAllocate );
		if ( rgcolumnidSrc == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		fLocalAlloc = fTrue;
		}
	memset( (BYTE *)rgcolumnidSrc, 0, cbAllocate );
	pbMax = (BYTE *)rgcolumnidSrc + cbAllocate;
	pcolumnidSrc = rgcolumnidSrc;

	// JET_COLUMNCREATE structures follow the tagged columnid map.
	rgcolcreate = pcolcreateCurr =
		(JET_COLUMNCREATE *)( rgcolumnidSrc + cColumns );
	Assert( (BYTE *)rgcolcreate < pbMax );

	// Column names and presentation order follow the JET_COLUMNCREATE structures.
	rgNamePO = pNamePOCurr =
		(NAME_PO *)( rgcolcreate + cColumns );
	Assert( (BYTE *)rgNamePO < pbMax );

	// Default values follow the NAME_PO structures.
	rgbDefaultValues = pbCurrDefault = (BYTE *)( rgNamePO + cColumns );

	Assert( rgbDefaultValues + cbRECRecordMost == pbMax );

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, columnList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and
	/* copy the information in the destination database
	/**/
	cColumns = 0;
	while ( err >= 0 )
		{
         BOOL fChangeType = FALSE;

		pcolcreateCurr->cbStruct = sizeof(JET_COLUMNCREATE);

		/* retrieve info from table and create all the columns
		/**/
		Call( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			columnList->tableid,
			columnList->columnidcolumnname,
			pNamePOCurr->szName,
			JET_cbNameMost,
			&cbActual,
			NO_GRBIT,
			NULL ) );

		pNamePOCurr->szName[cbActual] = '\0';
		pcolcreateCurr->szColumnName = (BYTE *)pNamePOCurr;
		Assert( pcolcreateCurr->szColumnName == pNamePOCurr->szName );	// Assert name is first field.
        // printf("column name is %s\n", pNamePOCurr->szName);

        if ( (!strcmp( pNamePOCurr->szName,"OwnerId") || !strcmp( pNamePOCurr->szName, "ownerid" )) && ( DbType == DbWins ) ) {
            fChangeType = TRUE;
        }
		// Assert initialised to zero, which also means no PO.
		Assert( pNamePOCurr->ulPOrder == 0 );
		Call( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			columnList->tableid,
			columnList->columnidPresentationOrder,
			&pNamePOCurr->ulPOrder,
			sizeof(pNamePOCurr->ulPOrder),
			&cbActual,
			NO_GRBIT,
			NULL ) );
		Assert( err = JET_wrnColumnNull  ||  cbActual == sizeof(ULONG) );

		pNamePOCurr++;
		Assert( (BYTE *)pNamePOCurr <= rgbDefaultValues );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcoltyp, &pcolcreateCurr->coltyp,
			sizeof( pcolcreateCurr->coltyp ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_COLTYP ) );

        //
        // This is a hack that we need to convert wins database in the upgrade
        // process.
        //
        if ( fChangeType)
        {
            // printf("Upgrading OwnerId field of wins database\n");
            Assert( pcolcreateCurr->coltyp == JET_coltypUnsignedByte );
            pcolcreateCurr->coltyp = JET_coltypLong;
        }

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcbMax, &pcolcreateCurr->cbMax,
			sizeof( pcolcreateCurr->cbMax ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( ULONG ) );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidgrbit, &pcolcreateCurr->grbit,
			sizeof( pcolcreateCurr->grbit ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_GRBIT ) );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidCp, &pcolcreateCurr->cp,
			sizeof( pcolcreateCurr->cp ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( USHORT ) );

		/*	retrieve default value.
		/**/
		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidDefault, pbCurrDefault,
			cbRECRecordMost, &pcolcreateCurr->cbDefault, NO_GRBIT, NULL ) );
		pcolcreateCurr->pvDefault = pbCurrDefault;
		pbCurrDefault += pcolcreateCurr->cbDefault;
		Assert( pbCurrDefault <= pbMax );

		// Save the source columnid.
		/* CONSIDER: Should the column id be checked? */
		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcolumnid, pcolumnidSrc,
			sizeof( JET_COLUMNID ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_COLUMNID ) );

        if ( fChangeType)
        {
            WinsTableId = columnList->tableid;
            WinsOwnerIdColumnId = *pcolumnidSrc;
        }

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			cTagged++;
			columnidTaggedHighest = max( columnidTaggedHighest, *pcolumnidSrc );
			}

		pcolumnidSrc++;
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		pcolcreateCurr++;
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgNamePO );
		cColumns++;

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, columnList->tableid, JET_MoveNext, NO_GRBIT );
		}

	Assert( cColumns == columnList->cRecord );


	Assert( ptablecreate->rgcolumncreate == NULL );
	Assert( ptablecreate->cColumns == 0 );
	Assert( ptablecreate->rgindexcreate == NULL );
	Assert( ptablecreate->cIndexes == 0 );

	ptablecreate->rgcolumncreate = rgcolcreate;
	ptablecreate->cColumns = cColumns;

	Call( ErrIsamCreateTable( sesid, (JET_VDBID)dbidDest, ptablecreate ) );
	Assert( ptablecreate->cCreated == 1 + cColumns );

	ptablecreate->rgcolumncreate = NULL;
	ptablecreate->cColumns = 0;


	// If there's at least one tagged column, create an array for the
	// tagged columnid map.
	if ( cTagged > 0 )
		{
		Assert( FTaggedFid( columnidTaggedHighest ) );
		cbAllocate = sizeof(JET_COLUMNID) * ( columnidTaggedHighest + 1 - fidTaggedLeast );
		mpcolumnidcolumnidTagged = SAlloc( cbAllocate );
		if ( mpcolumnidcolumnidTagged == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		memset( (BYTE *)mpcolumnidcolumnidTagged, 0, cbAllocate );
		}


	// Update columnid maps.
	for ( pcolcreateCurr = rgcolcreate, pcolumnidSrc = rgcolumnidSrc, cColumns = 0;
		cColumns < columnList->cRecord;
		pcolcreateCurr++, pcolumnidSrc++, cColumns++ )
		{
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgNamePO );
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			Assert( FTaggedFid( *pcolumnidSrc ) );
			Assert( FTaggedFid( pcolcreateCurr->columnid ) );
			Assert( *pcolumnidSrc <= columnidTaggedHighest );
			Assert( mpcolumnidcolumnidTagged[*pcolumnidSrc - fidTaggedLeast] == 0 );
			mpcolumnidcolumnidTagged[*pcolumnidSrc - fidTaggedLeast] = pcolcreateCurr->columnid;
			}
		else
			{
			/*	else add the columnids to the columnid array
			/**/
			columnidInfo[ccolSingleValue].columnidDest = pcolcreateCurr->columnid;
			columnidInfo[ccolSingleValue].columnidSrc  = *pcolumnidSrc;
			ccolSingleValue++;
			}	// if ( columndef.grbit & JET_bitColumnTagged )
		}

	/*	set count of fixed and variable columns to copy
	/**/
	pcompactinfo->ccolSingleValue = ccolSingleValue;

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	if ( err < 0  &&  mpcolumnidcolumnidTagged )
		{
		SFree( mpcolumnidcolumnidTagged );
		mpcolumnidcolumnidTagged = NULL;
		}

	if ( fLocalAlloc )
		{
		SFree( rgcolumnidSrc );
		}

	// Set return value.
	*pmpcolumnidcolumnidTagged = mpcolumnidcolumnidTagged;

	return err;
	}



LOCAL VOID CMPGetTime( ULONG timerStart, INT *piSec, INT *piMSec )
	{
	ULONG	timerEnd;

	timerEnd = GetTickCount();
	
	*piSec = ( timerEnd - timerStart ) / 1000;
	*piMSec = ( timerEnd - timerStart ) % 1000;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyTable                                                                                                 *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szObjectName         - object name to copy the owner of              *
*                          szContainerName      - Container name in which the object exists *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the table from the source database to the                              *
*       destination database.  It can also copy queries, invoked by                             *
*       ErrCMPCopyObjects                                                                                                                  *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyTable(
	COMPACTINFO		*pcompactinfo,
	const CHAR		*szObjectName )
	{
	JET_DBID		dbidSrc = pcompactinfo->dbidSrc;
	ERR				err;
	ERR				errT;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	JET_COLUMNLIST	columnList;
	JET_INDEXLIST	indexList;
	INT				cIndexes;
	BOOL			fHasClustered;
	JET_COLUMNID    *mpcolumnidcolumnidTagged = NULL;
	BOOL			fPageBasedProgress = fFalse;
	STATUSINFO		*pstatus = pcompactinfo->pstatus;
	INT				iSec;
	INT				iMSec;
	ULONG			crowCopied = 0;
	ULONG			recidLast;
	ULONG			rgulAllocInfo[] = { ulCMPDefaultPages, ulCMPDefaultDensity };
	ULONG			cpgProjected;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	JET_TABLECREATE	tablecreate = {
		sizeof(JET_TABLECREATE),
		(CHAR *)szObjectName,
		0,
		ulCMPDefaultDensity,
		NULL,
		0,
		NULL,
		0,
		0,
		0,
		0
		};

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		fprintf( pstatus->hfCompactStats, szStats5, cNewLine, szObjectName );
		fflush( pstatus->hfCompactStats );
		pstatus->timerCopyTable = GetTickCount();
		pstatus->timerInitTable = GetTickCount();
		}

	CallR( (*pvtcd->pErrCDOpenTable)(
		pvtcd->sesid,
		(JET_VDBID)dbidSrc,
		(CHAR *)szObjectName,
		NULL,
		0,
		JET_bitTableSequential,
		&tableidSrc ) );
/*
	CallJ( (*pvtcd->pErrCDGetTableInfo)(
		pvtcd->sesid,
		tableidSrc,
		rgulAllocInfo,
		sizeof(rgulAllocInfo),
		JET_TblInfoSpaceAlloc), CloseIt1 );
*/	tablecreate.ulPages = rgulAllocInfo[0];
	tablecreate.ulDensity = rgulAllocInfo[1];

	/*	get a table with the column information for the query in it
	/**/
    //
    // hack to convert the wins ownerid.
    //

    WinsTableId = 0;
    WinsOwnerIdColumnId = 0;
	CallJ( (*pvtcd->pErrCDGetTableColumnInfo)(
		pvtcd->sesid,
		tableidSrc,
		NULL,
		&columnList,
		sizeof(columnList),
		JET_ColInfoList ), CloseIt1 );

	/*	if a table create the columns in the Dest Db the same as in
	/*	the src Db.
	/**/
	err = ErrCMPCreateTableColumn(
		pcompactinfo,
		szObjectName,
		&tablecreate,
		&columnList,
		pcompactinfo->rgcolumnids,
		&mpcolumnidcolumnidTagged );
   //
   //  HACK HACK HACK.  Need to look at this later
   //
   if (WinsOwnerIdColumnId > 0)
   {
       // printf("HACKING tableidSrc for WINS table");
       WinsTableId = tableidSrc;
   }

	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, columnList.tableid );
	if ( err < 0  ||  errT < 0 )
		{
		if ( err >= 0 )
			{
			Assert( errT < 0 );
			err = errT;
			}
		goto CloseIt2;
		}

	tableidDest = tablecreate.tableid;
	Assert( tablecreate.cCreated == 1 + columnList.cRecord );

	/*  Get the information on the indexes and check if
	/*	there is a clustered index.
	/**/
	CallJ( (*pvtcd->pErrCDGetTableIndexInfo)(
		pvtcd->sesid,
		tableidSrc,
		NULL,
		&indexList,
		sizeof(indexList),
		JET_IdxInfoList ), CloseIt3 );

	if ( pcompactinfo->pconvert )
		// If converting, just assume there's at least one clustered and one-nonclustered.
		// It doesn't matter if we're incorrect -- CopyClusteredIndex() and CopyTableIndexes()
		// will handle it.
		cIndexes = 2;
	else
		{
		CallJ( (*pvtcd->pErrCDGetTableIndexInfo)(
			pvtcd->sesid,
			tableidSrc,
			NULL,
			&cIndexes,
			sizeof(cIndexes),
			JET_IdxInfoCount ), CloseIt3 );
		}

	Assert( cIndexes >= 0 );

	CallJ( ErrCMPCopyClusteredIndex(
		pcompactinfo,
		tableidDest,
		szObjectName,
		&indexList,
		&fHasClustered ), CloseIt4 );
	Assert( !fHasClustered  ||  cIndexes > 0 );

	if ( pstatus )
		{
		Assert( pstatus->pfnStatus );
		Assert( pstatus->snt == JET_sntProgress );

		pstatus->szTableName = (char *)szObjectName;
		pstatus->cTableFixedVarColumns = pcompactinfo->ccolSingleValue;
		pstatus->cTableTaggedColumns = columnList.cRecord - pcompactinfo->ccolSingleValue;
		pstatus->cTableInitialPages = rgulAllocInfo[0];
		pstatus->cNCIndexes = 0;

		if ( !pcompactinfo->pconvert )
			{
			ULONG	rgcpgExtent[2];		// OwnExt and AvailExt
			ULONG	cpgUsed;

			// Can't do page-based progress meter during convert.
			fPageBasedProgress = fTrue;

			CallJ( (*pvtcd->pErrCDGetTableInfo)(
				pvtcd->sesid,
				tableidSrc,
				rgcpgExtent,
				sizeof(rgcpgExtent),
				JET_TblInfoSpaceUsage ), CloseIt4 );

			// AvailExt always less than OwnExt.
			Assert( rgcpgExtent[1] < rgcpgExtent[0] );

			// cpgProjected is the projected total pages completed once
			// this table has been copied.
			cpgProjected = pstatus->cunitDone + rgcpgExtent[0];
			Assert( cpgProjected <= pstatus->cunitTotal );

			cpgUsed = rgcpgExtent[0] - rgcpgExtent[1];
			Assert( cpgUsed > 0 );

			pstatus->cLeafPagesTraversed = 0;
			pstatus->cLVPagesTraversed = 0;

			pstatus->cunitPerProgression = 1 + ( rgcpgExtent[1] / cpgUsed );
			pstatus->cTablePagesOwned = rgcpgExtent[0];
			pstatus->cTablePagesAvail = rgcpgExtent[1];
			}

		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerInitTable, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats, szStats7, cNewLine, iSec, iMSec );
			fprintf( pstatus->hfCompactStats, szStats8,
				cNewLine,
				pstatus->cTableFixedVarColumns,
				pstatus->cTableTaggedColumns );
			if ( !pcompactinfo->pconvert )
				{
				fprintf( pstatus->hfCompactStats,
					szStats9,
					cNewLine,
					pstatus->cTablePagesOwned,
					pstatus->cTablePagesAvail );
				}
			fprintf( pstatus->hfCompactStats, szStats10, cNewLine );
			fflush( pstatus->hfCompactStats );
			pstatus->timerCopyRecords = GetTickCount();
			}
		}

	/*	copy the data in the table
	/**/
	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidSrc, JET_MoveFirst, 0 );
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto DoneCopyRecords;

	if ( pcompactinfo->pconvert )
		{
		COLUMNIDINFO	*pcolinfo, *pcolinfoMax;

		while ( err >= 0 )
			{
			CallJ( ErrDispPrepareUpdate(
				pcompactinfo->sesid,
				tableidDest,
				JET_prepInsert ), DoneCopyRecords );

			pcolinfo = pcompactinfo->rgcolumnids;
			pcolinfoMax = pcolinfo + pcompactinfo->ccolSingleValue;
			for ( ; pcolinfo < pcolinfoMax; pcolinfo++ )
				{
				CallJ( ErrCMPCopyColumnData(
					pcompactinfo->sesid,
					tableidSrc,
					tableidDest,
					pcolinfo->columnidSrc,
					pcolinfo->columnidDest,
					pcompactinfo->rgbBuf,
					pvtcd ), DoneCopyRecords );
				}

			// Copy tagged columns, if any.
			if ( mpcolumnidcolumnidTagged != NULL )
				{
				CallJ( ErrCMPCopyTaggedColumns(
					pcompactinfo,
					tableidSrc,
					tableidDest,
					mpcolumnidcolumnidTagged ), DoneCopyRecords );
				}

			CallJ( ErrDispUpdate(
				pcompactinfo->sesid,
				tableidDest,
				NULL, 0, NULL ), DoneCopyRecords );

			crowCopied++;
				
			err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidSrc, JET_MoveNext, 0 );
			}
		}

	else
		{
		err = ErrIsamCopyRecords(
			pcompactinfo->sesid,
			tableidSrc,
			tableidDest,
			(CPCOL *)pcompactinfo->rgcolumnids,
			pcompactinfo->ccolSingleValue,
			0,
			&crowCopied,
			&recidLast,
			mpcolumnidcolumnidTagged,
			pstatus );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

DoneCopyRecords:

	if ( fHasClustered )
		cIndexes--;		// Clustered already copied.


	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyRecords, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, szStats11, cNewLine, crowCopied, iSec, iMSec );
		if ( !pcompactinfo->pconvert )
			{
			fprintf( pstatus->hfCompactStats,
				szStats12,
				cNewLine,
				pstatus->cLeafPagesTraversed,
				pstatus->cLVPagesTraversed );
			}
		fprintf( pstatus->hfCompactStats, szStats13, cNewLine );
		fflush( pstatus->hfCompactStats );
		pstatus->timerRebuildIndexes = GetTickCount();
		}

	// If no error, do indexes.
	// If an error, but we're repairing, do indexes.
	if ( cIndexes > 0  &&  ( err >= 0  ||  fGlobalRepair ) )
		{
		ULONG	cpgPerIndex = 0;

		if ( fPageBasedProgress )
			{
			ULONG	cpgRemaining;

			Assert( pstatus != NULL );

			Assert( pstatus->cunitDone <= cpgProjected );
			cpgRemaining = cpgProjected - pstatus->cunitDone;

			cpgPerIndex = cpgRemaining / cIndexes;
			Assert( cpgPerIndex * cIndexes <= cpgRemaining );
			}

		errT = ErrCMPCopyTableIndexes(
			pcompactinfo,
			tableidDest,
			szObjectName,
			&indexList,
			cpgPerIndex );
		if ( err >= 0 )
			err = errT;
		}

	if ( pstatus )
		{
		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerRebuildIndexes, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats, szStats14,
				cNewLine, pstatus->cNCIndexes, iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			}

		if ( fPageBasedProgress  &&  ( err >= 0  ||  fGlobalRepair ) )
			{
			Assert( pstatus != NULL );

			// Top off progress meter for this table.
			Assert( pstatus->cunitDone <= cpgProjected );
			pstatus->cunitDone = cpgProjected;
			errT = ErrCMPReportProgress( pstatus );
			if ( err >= 0 )
				err = errT;
			}
		}

CloseIt4:
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, indexList.tableid );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt3:
	Assert( tableidDest == tablecreate.tableid );
	errT = ErrDispCloseTable( pcompactinfo->sesid, tableidDest );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt2:
	if ( mpcolumnidcolumnidTagged != NULL )
		{
		SFree( mpcolumnidcolumnidTagged );
		}

CloseIt1:
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, tableidSrc );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyTable, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, szStats6,
			cNewLine, szObjectName, iSec, iMSec, cNewLine );
		fflush( pstatus->hfCompactStats );
		}

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyObjects                                                                                               *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szContainerName      - Container name in which the object exists *
*                          szObjectName         - object name to copy                                           *
*                          objtyp                       - object type                                                           *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the exta info columns in the MSysObjects table                 *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyObject(
	COMPACTINFO	*pcompactinfo,
	const CHAR	*szObjectName,
	JET_OBJTYP	objtyp )
	{
	ERR	err = JET_errSuccess;

	switch ( objtyp )
		{
		case JET_objtypDb:
			/* Present after CreateDatabase */
			Assert( strcmp( szObjectName, szDbObject ) == 0 );
			break;

		case JET_objtypContainer:
			/* CreateDatabase already created Db/Table containers. */
			/* Pre-500 series DB's may also have a"Relationships" container. */
			Assert( strcmp( szObjectName, szDcObject ) == 0  ||
				strcmp( szObjectName, szTcObject ) == 0  ||
				( pcompactinfo->pconvert  &&  strcmp( szObjectName, "Relationships" ) == 0 ) );
			break;

		case JET_objtypTable:
				/*	CreateDatabase already created system tables.
				/**/
			if ( !FCATSystemTable( szObjectName ) )
				{
				err = ErrCMPCopyTable( pcompactinfo, szObjectName );
				if ( err < 0  &&  fGlobalRepair )
					{
					err = JET_errSuccess;
					UtilReportEvent( EVENTLOG_WARNING_TYPE, REPAIR_CATEGORY, REPAIR_BAD_TABLE, 1, &szObjectName );
					}
				}
			break;

		default :
			/* Don't know how to handle this.  Skip it. */
			Assert( 0 );
			err = ErrERRCheck( JET_errInvalidObject );
		break;
		}

	return( err );
	}



/*---------------------------------------------------------------------------
*
*       Procedure: ErrCMPCopyObjects
*
*       Arguments: pcompactinfo - Compact information segment
*
*       Returns : JET_ERR
*
*       Procedure copies the objects from the source
*       database to the destination databse.  It then copies the extra
*       information in the msysobjects table ( eg Description ) and copies the
*       security rights for all the objects in the database to which it has
*       access.
*       If fCopyContainers is fTrue, copy only container info into destination
*       If fCopyContainers is fFalse, copy only non-container info.
*       NOTE: progress callbacks are currently set up to work such that the
*       NOTE: first call to ErrCMPCopyObjects must be with fCopyContainers set FALSE.
*
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyObjects( COMPACTINFO *pcompactinfo )
	{
	JET_TABLEID		tableidMSO;
	JET_COLUMNID	columnidObjtyp;
	JET_COLUMNID	columnidObjectName;
	ERR				err;
	ERR				errT;
	ULONG			cbActual;
	CHAR			szObjectName[JET_cbNameMost+1];
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	if ( pcompactinfo->pconvert )
		{
		JET_OBJECTLIST	objectlist;
		JET_OBJTYP		objtyp;			// When converting, need JET_OBJTYP

		/* Get the list of all objects in the source database */
		objectlist.tableid = 0;
		CallR( (*pvtcd->pErrCDGetObjectInfo)(
			pvtcd->sesid,
			(JET_VDBID)pcompactinfo->dbidSrc,
			JET_objtypNil,
			NULL,
			NULL,
			&objectlist,
			sizeof( objectlist ),
			JET_ObjInfoListNoStats ) );

		tableidMSO = objectlist.tableid;

		if ( pcompactinfo->pstatus )
			{
			pcompactinfo->pstatus->cunitDone = 0;
			pcompactinfo->pstatus->cunitTotal = objectlist.cRecord;
			pcompactinfo->pstatus->cunitPerProgression = 1;
			}

		columnidObjtyp = objectlist.columnidobjtyp;
		columnidObjectName = objectlist.columnidobjectname;

		Call( (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveFirst, 0 ) );

		do
			{
			/* Get the object's type and name */
			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
				columnidObjtyp, &objtyp, sizeof(objtyp), &cbActual, 0, NULL ) );
			Assert( cbActual == sizeof(JET_OBJTYP) );

			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
					columnidObjectName, szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
			szObjectName[cbActual] = '\0';

			Call( ErrCMPCopyObject( pcompactinfo, szObjectName, objtyp ) );

			if ( pcompactinfo->pstatus )
				{
				Assert( pcompactinfo->pstatus->snt == JET_sntProgress );
				Assert( pcompactinfo->pstatus->cunitPerProgression == 1 );
				pcompactinfo->pstatus->cunitDone += 1;
				Call( ErrCMPReportProgress( pcompactinfo->pstatus ) );
				}
			}
		while ( ( err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveNext, 0 ) ) >= 0 );
		}

	else
		{
		JET_COLUMNDEF	columndef;
		OBJTYP			objtyp;			// When compacting, need OBJTYP

		CallR( (*pvtcd->pErrCDOpenTable)(
			pvtcd->sesid,
			(JET_VDBID)pcompactinfo->dbidSrc,
			szSoTable,
			NULL,
			0,
			0,
			&tableidMSO ) );

		Call( (*pvtcd->pErrCDGetTableColumnInfo)(
			pvtcd->sesid,
			tableidMSO,
			szSoObjectTypeColumn,
			&columndef,
			sizeof(columndef),
			JET_ColInfo ) );
		columnidObjtyp = columndef.columnid;

		Call( (*pvtcd->pErrCDGetTableColumnInfo)(
			pvtcd->sesid,
			tableidMSO,
			szSoObjectNameColumn,
			&columndef,
			sizeof(columndef),
			JET_ColInfo ) );
		columnidObjectName = columndef.columnid;

		Call( (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveFirst, 0 ) );

		do
			{
			/* Get the object's type and name */
			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
				columnidObjtyp, &objtyp, sizeof(objtyp), &cbActual, 0, NULL ) );
			Assert( cbActual == sizeof(OBJTYP) );

			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
					columnidObjectName, szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
			szObjectName[cbActual] = '\0';

			Call( ErrCMPCopyObject( pcompactinfo, szObjectName, (JET_OBJTYP)objtyp ) );
			}
		while ( ( err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveNext, 0 ) ) >= 0 );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	// Return result of CloseTable only if no other errors occurred.
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, tableidMSO );
	if ( err == JET_errSuccess )
		err = errT;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCleanup                                                                                                   *
*                                                                                                                                                       *
*       Arguments: pcompactinfo - Compact information segment                                   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure closes the databases                                                                                  *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCloseDB( COMPACTINFO *pcompactinfo )
	{
	ERR		err;
	ERR		errT;
	VTCD	*pvtcd = &pcompactinfo->vtcd;

	err = (*pvtcd->pErrCDCloseDatabase)( pvtcd->sesid, (JET_VDBID)pcompactinfo->dbidSrc, 0 );
	errT = ErrIsamCloseDatabase( pcompactinfo->sesid, (JET_VDBID)pcompactinfo->dbidDest, 0 );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

	return err;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: JetCompact                                                                                                   *
*                                                                                                                                                       *
*       Returns:   JET_ERR returned by JetCompact or by other Jet API.                  *
*                                                                                                                                                       *
*       The procedure copies the source database into the destination database  *
*       so that it will take up less disk space storage.                                                *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

ERR ISAMAPI ErrIsamConv200(
	JET_SESID		sesid,
	const CHAR		*szDatabaseSrc,
	const CHAR		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	ERR				err = JET_errSuccess;
	ERR				errT;
	ULONG_PTR		grbitSave;
	COMPACTINFO		compactinfo;
	
	if ( pconvert )
		{
		// For convert, must specify old DLL.
		if ( pconvert->szOldDll )
			pconvert->fDbAttached = fFalse;
		else
			return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrGetSystemParameter( sesid, JET_paramSessionInfo, &grbitSave, NULL, 0 ) );
	CallR( ErrSetSystemParameter( sesid, JET_paramSessionInfo,
		JET_bitAggregateTransaction | JET_bitCIMDirty, NULL ) );
	CallR( ErrSetSystemParameter( sesid, JET_paramPageReadAheadMax, 32, NULL ) );


	compactinfo.sesid = sesid;
	compactinfo.pconvert = pconvert;

	if ( pfnStatus )
		{
		compactinfo.pstatus = (STATUSINFO *)SAlloc( sizeof(STATUSINFO) );
		if ( compactinfo.pstatus == NULL )
			return ErrERRCheck( JET_errOutOfMemory );

		memset( compactinfo.pstatus, 0, sizeof(STATUSINFO) );

		compactinfo.pstatus->sesid = sesid;
		compactinfo.pstatus->pfnStatus = pfnStatus;
		compactinfo.pstatus->snp = JET_snpCompact;
		compactinfo.pstatus->snt = JET_sntBegin;
		CallR( ErrCMPReportProgress( compactinfo.pstatus ) );

		compactinfo.pstatus->snt = JET_sntProgress;

		compactinfo.pstatus->fDumpStats = ( grbit & JET_bitCompactStats );
		if ( compactinfo.pstatus->fDumpStats )
			{
			compactinfo.pstatus->hfCompactStats = fopen( szCompactStatsFile, "a" );
			if ( compactinfo.pstatus->hfCompactStats )
				{
				fprintf( compactinfo.pstatus->hfCompactStats, szStats1,
					cNewLine,
					cNewLine,
					szDatabaseSrc,
					cNewLine );
				fflush( compactinfo.pstatus->hfCompactStats );
				compactinfo.pstatus->timerCopyDB = GetTickCount();
				compactinfo.pstatus->timerInitDB = GetTickCount();
				}
			else
				{
				return ErrERRCheck( JET_errFileAccessDenied );
				}
			}
		}

	else
		{
		compactinfo.pstatus = NULL;
		}

	if ( pconvert )
		{
		memset( (BYTE *)&compactinfo.vtcd, 0, sizeof( VTCD ) );
		CallJ( ErrCMPConvertInit( &compactinfo.vtcd, pconvert, szDatabaseSrc ), AfterCloseDB );
		}
	else
		{
		VTCD	*pvtcd = &compactinfo.vtcd;

		// Items marked NULL means the function should not be called
		// during a regular compact.

		pvtcd->sesid = sesid;
		pvtcd->pErrCDInit = NULL;
		pvtcd->pErrCDTerm = NULL;
		pvtcd->pErrCDBeginSession = NULL;
		pvtcd->pErrCDEndSession = NULL;
		pvtcd->pErrCDAttachDatabase = ErrCDAttachDatabase;
		pvtcd->pErrCDDetachDatabase = ErrCDDetachDatabase;
		pvtcd->pErrCDOpenDatabase = ErrCDOpenDatabase;
		pvtcd->pErrCDCloseDatabase = ErrCDCloseDatabase;
		pvtcd->pErrCDOpenTable = ErrCDOpenTable;
		pvtcd->pErrCDCloseTable = ErrCDCloseTable;
		pvtcd->pErrCDRetrieveColumn= ErrCDRetrieveColumn;					
		pvtcd->pErrCDMove = ErrCDMove;
		pvtcd->pErrCDSetSystemParameter = NULL;
		pvtcd->pErrCDGetObjectInfo = ErrCDGetObjectInfo;	
		pvtcd->pErrCDGetDatabaseInfo = ErrCDGetDatabaseInfo;
		pvtcd->pErrCDGetTableInfo = ErrCDGetTableInfo;
		pvtcd->pErrCDGetTableColumnInfo = ErrCDGetTableColumnInfo;
		pvtcd->pErrCDGetTableIndexInfo = ErrCDGetTableIndexInfo;
		pvtcd->pErrCDGetIndexInfo = ErrCDGetIndexInfo;
		}

	/* Open and create the databases */

	CallJ( ErrCMPCompactInit( &compactinfo, szDatabaseSrc, szDatabaseDest ),
		AfterCloseDB );

	if ( pfnStatus != NULL )
		{
		INT iSec, iMSec;

		Assert( compactinfo.pstatus );

		if ( !pconvert )
			{
			/* Init status meter.  We'll be tracking status by pages processed, */
			Call( (*compactinfo.vtcd.pErrCDGetDatabaseInfo)(
				compactinfo.vtcd.sesid,
				compactinfo.dbidSrc,
				&compactinfo.pstatus->cDBPagesOwned,
				sizeof(compactinfo.pstatus->cDBPagesOwned),
				JET_DbInfoSpaceOwned ) );
			Call( (*(compactinfo.vtcd.pErrCDGetDatabaseInfo))(
				compactinfo.vtcd.sesid,
				compactinfo.dbidSrc,
				&compactinfo.pstatus->cDBPagesAvail,
				sizeof(compactinfo.pstatus->cDBPagesAvail),
				JET_DbInfoSpaceAvailable ) );

			// Don't count unused space in the database;
			Assert( compactinfo.pstatus->cDBPagesOwned >= cpgDatabaseMin );
			Assert( compactinfo.pstatus->cDBPagesAvail < compactinfo.pstatus->cDBPagesOwned );
			compactinfo.pstatus->cunitTotal =
				compactinfo.pstatus->cDBPagesOwned - compactinfo.pstatus->cDBPagesAvail;

			// Approximate the number of pages used by MSysObjects, MSysColumns, and MSysIndexes.
			compactinfo.pstatus->cunitDone = 1 + 4 + 1;
			Assert( compactinfo.pstatus->cunitDone <= compactinfo.pstatus->cunitTotal );

			Call( ErrCMPReportProgress( compactinfo.pstatus ) );
			}

		if ( compactinfo.pstatus->fDumpStats )
			{
			Assert( compactinfo.pstatus->hfCompactStats );
			CMPGetTime( compactinfo.pstatus->timerInitDB, &iSec, &iMSec );
			fprintf( compactinfo.pstatus->hfCompactStats, szStats3,
				cNewLine,
				iSec,
				iMSec,
				cNewLine );
			if ( !pconvert )
				{
				fprintf( compactinfo.pstatus->hfCompactStats,
					szStats4,
					compactinfo.pstatus->cDBPagesOwned,
					compactinfo.pstatus->cDBPagesAvail,
					cNewLine );
				}
			fflush( compactinfo.pstatus->hfCompactStats );
			}
		}

	/* Create and copy all non-container objects */

	Call( ErrCMPCopyObjects( &compactinfo ) );

	Assert( !pfnStatus  ||
		( compactinfo.pstatus  &&
			compactinfo.pstatus->cunitDone <= compactinfo.pstatus->cunitTotal ) );

HandleError:
	errT = ErrCMPCloseDB( &compactinfo );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

AfterCloseDB:
	if ( pconvert )
		{
		errT = ErrCMPConvertCleanup( &compactinfo.vtcd, pconvert, szDatabaseSrc, err < 0 );
		if ( ( errT < 0 ) && ( err >= 0 ) )
			err = errT;
		}

	/* reset session info */
	
	errT = ErrSetSystemParameter( sesid, JET_paramSessionInfo, grbitSave, NULL );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;
						
	if ( pfnStatus != NULL )		// Top off status meter.
		{
		Assert( compactinfo.pstatus );

		compactinfo.pstatus->snt = ( err < 0 ? JET_sntFail : JET_sntComplete );
		errT = ErrCMPReportProgress( compactinfo.pstatus );
		if ( ( errT < 0 ) && ( err >= 0 ) )
			err = errT;

		if ( compactinfo.pstatus->fDumpStats )
			{
			INT	iSec, iMSec;
			
			Assert( compactinfo.pstatus->hfCompactStats );
			CMPGetTime( compactinfo.pstatus->timerCopyDB, &iSec, &iMSec );
			fprintf( compactinfo.pstatus->hfCompactStats, szStats2,
				cNewLine,
				szDatabaseSrc,
				iSec,
				iMSec,
				cNewLine,
				cNewLine );
			fflush( compactinfo.pstatus->hfCompactStats );
			fclose( compactinfo.pstatus->hfCompactStats );
			}

		SFree( compactinfo.pstatus );
		}

	/*      detach compacted database */
	(VOID)ErrIsamDetachDatabase( sesid, szDatabaseDest );

	if ( err < 0 )
		{
		if ( err != JET_errDatabaseDuplicate )
			{
			ERR ErrUtilDeleteFile( CHAR *szFileName );
			ErrUtilDeleteFile( (CHAR *)szDatabaseDest );
			}
		}

	return err;
	}


JET_ERR __stdcall PrintStatus( JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv )
	{
	static int	iLastPercentage;
	int 		iPercentage;
	int			dPercentage;

	if ( snp == JET_snpCompact )
		{
		switch( snt )
			{
			case JET_sntProgress:
				Assert( pv );
				iPercentage = ( ( (JET_SNPROG *)pv )->cunitDone * 100 ) / ( (JET_SNPROG *)pv )->cunitTotal;
				dPercentage = iPercentage - iLastPercentage;
				Assert( dPercentage >= 0 );
				while ( dPercentage >= 2 )
					{
					CMPPrintMessage( STATUSBAR_SINGLE_INCREMENT_ID, NULL );
					iLastPercentage += 2;
					dPercentage -= 2;
					}
				break;

			case JET_sntBegin:
				CMPPrintMessage( DOUBLE_CRLF_ID, NULL );
				CMPPrintMessage( STATUSBAR_PADDING_ID, NULL );
				CMPPrintMessage( STATUSBAR_TITLE_CONVERT_ID, NULL );
				CMPPrintMessage( STATUSBAR_PADDING_ID, NULL );
				CMPPrintMessage( STATUSBAR_AXIS_HEADINGS_ID, NULL );
				CMPPrintMessage( STATUSBAR_PADDING_ID, NULL );
				CMPPrintMessage( STATUSBAR_AXIS_ID, NULL );
				CMPPrintMessage( STATUSBAR_PADDING_ID, NULL );

				iLastPercentage = 0;
				break;

			case JET_sntComplete:
				dPercentage = 100 - iLastPercentage;
				Assert( dPercentage >= 0 );
				while ( dPercentage >= 2 )
					{
					CMPPrintMessage( STATUSBAR_SINGLE_INCREMENT_ID, NULL );
					iLastPercentage += 2;
					dPercentage -= 2;
					}

				CMPPrintMessage( STATUSBAR_SINGLE_INCREMENT_ID, NULL );
				CMPPrintMessage( DOUBLE_CRLF_ID, NULL );
				break;
			}
		}

	return JET_errSuccess;
	}

LOCAL BOOL FCONVParsePath( char *arg, char **pszParam, ULONG ulParamTypeId )
	{
	BOOL	fResult = fTrue;
	
	if ( *arg == '\0' )
		{
		CHAR	szParamDesc[cbMsgBufMax];
		
		CMPFormatMessage( ulParamTypeId, szParamDesc, NULL );
		CMPPrintMessage( CRLF_ID, NULL );
		CMPPrintMessage( CONVERT_USAGE_ERR_MISSING_PARAM_ID, szParamDesc );
		
		fResult = fFalse;
		}
	else if ( *pszParam == NULL )
		{
		*pszParam = arg;
		}
	else
		{
		CHAR	szParamDesc[cbMsgBufMax];

		CMPFormatMessage( ulParamTypeId, szParamDesc, NULL );
		CMPPrintMessage( CRLF_ID, NULL );
		CMPPrintMessage( CONVERT_USAGE_ERR_DUPLICATE_PARAM_ID, szParamDesc );

		fResult = fFalse;
		}
		
	return fResult;
	}

BOOL    IsPreserveDbOk( char * szPreserveDBPath )
{
    DWORD   WinError;
    DWORD   FileAttributes;

    FileAttributes = GetFileAttributes( szPreserveDBPath );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create this directory.
            //

            if( !CreateDirectory( szPreserveDBPath, NULL) ) {
                return fFalse;
            }

        }
        else {
            return fFalse;
        }
    }

    return fTrue;
}

ERR PreserveCurrentDb( char *szSourceDb, char * LogFilePath, char * SysDb, char * PreserveDbPath )
{
    char    TempPath[MAX_PATH];
    char    Temp2Path[MAX_PATH];
    char    *FileNameInPath;
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    CHAR CurrentDir[ MAX_PATH ];
    DWORD   Error;

    strcpy(TempPath, PreserveDbPath);
    strcat(TempPath,"\\");

    if ( (FileNameInPath = strrchr( szSourceDb, '\\') ) == NULL ){
        FileNameInPath = szSourceDb;
    }
    strcat(TempPath, FileNameInPath );

    //
    // move the database file.
    if ( !MoveFileEx( szSourceDb, TempPath, MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING ) ){
        DBGprintf(("PreserveCurrentDb: could not save database file: Error %ld\n",GetLastError()));
        DBGprintf(("Src %s, Dest %s\n",szSourceDb,TempPath));
        goto Cleanup;
    }

    //
    // Move the system.mdb file
    //
    strcpy(TempPath, PreserveDbPath);
    strcat(TempPath,"\\");

    if ( (FileNameInPath = strrchr( SysDb, '\\') ) == NULL ){
        FileNameInPath = SysDb;
    }
    strcat(TempPath, FileNameInPath );

    //
    // move the database file.
    if ( !MoveFileEx( SysDb, TempPath, MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING ) ){
        DBGprintf(("PreserveCurrentDb: could not save system database file: Error %ld\n",GetLastError()));
        DBGprintf(("Src %s, Dest %s\n",SysDb,TempPath));

        goto Cleanup;
    }

    //
    // Start file serach on current dir.
    //
    strcpy(Temp2Path,LogFilePath);
    strcat(Temp2Path,"\\");
    strcat(Temp2Path,"jet*.log");
    HSearch = FindFirstFile( Temp2Path, &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        DBGprintf(("Error: No Log files were found in %s\n", Temp2Path ));
        goto Cleanup;
    }

    //
    // Move files.
    //

    for( ;; ) {

        strcpy(TempPath, PreserveDbPath);
        strcat(TempPath,"\\");
        strcat(TempPath, FileData.cFileName );

        strcpy(Temp2Path,LogFilePath);
        strcat(Temp2Path,"\\");
        strcat(Temp2Path,FileData.cFileName );

        if( MoveFileEx( Temp2Path,TempPath, MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING  ) == FALSE ) {

            Error = GetLastError();
            DBGprintf(("PreserveCurrentDb: could not save log file, Error = %ld.\n", Error ));
            DBGprintf(("File %s, Src %s, Dest %s\n",FileData.cFileName,Temp2Path,TempPath));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFile( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( ERROR_NO_MORE_FILES == Error ) {
                break;
            }

//            printf("Error: FindNextFile failed, Error = %ld.\n", Error );
            goto Cleanup;
        }
    }

    Error = JET_errSuccess;

Cleanup:

    if( Error != JET_errSuccess ){
        CHAR    errBuf[11];
        sprintf(errBuf,"%ld",Error);
        CMPPrintMessage( CONVERT_ERR_PRESERVEDB_FAIL1_ID, NULL );
        CMPPrintMessage( CONVERT_ERR_PRESERVEDB_FAIL2_ID, errBuf );
    }

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }
    //
    // reset current currectory.
    //


    //
    // always return same!
    //
    return Error;

}

ERR DeleteCurrentDb( char * LogFilePath, char * SysDb )
{
    char    *FileNameInPath;
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    CHAR CurrentDir[ MAX_PATH ];
    DWORD   Error;



    //
    // Delete the system.mdb file
    //

    if ( SysDb && !DeleteFile( SysDb ) ){
        Error = GetLastError();
        DBGprintf(("DeleteCurrentDb: could not delete system database file: Error %ld\n",Error ));
        goto Cleanup;
    }


    //
    // now move the log files
    //

    if( GetCurrentDirectory( MAX_PATH, CurrentDir ) == 0 ) {

        Error = GetLastError();
        DBGprintf(("DeleteCurrentDb: GetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // set current directory to logfile path.
    //

    if( SetCurrentDirectory( LogFilePath ) == FALSE ) {
        Error = GetLastError();
        DBGprintf(("DeleteCurrentDb: SetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // Start file serach on current dir.
    //

    HSearch = FindFirstFile( "jet*.log", &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
//        printf("Error: No Log files were found in %s\n", LogFilePath );
        goto Cleanup;
    }

    //
    // Delete log files
    //

    for( ;; ) {


        if( DeleteFile( FileData.cFileName ) == FALSE ) {

            Error = GetLastError();
            DBGprintf(("DeleteCurrentDb: could not delete log file, Error = %ld.\n", Error ));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFile( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( ERROR_NO_MORE_FILES == Error ) {
                break;
            }

//            printf("Error: FindNextFile failed, Error = %ld.\n", Error );
            goto Cleanup;
        }
    }

    Error = JET_errSuccess;
Cleanup:
    if( Error != JET_errSuccess ){
        CHAR    errBuf[11];
        sprintf(errBuf,"%ld",Error);
        CMPPrintMessage( CONVERT_ERR_DELCURDB_FAIL1_ID, NULL);
        CMPPrintMessage( CONVERT_ERR_DELCURDB_FAIL2_ID, errBuf );
    }

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }
    //
    // reset current currectory.
    //

    SetCurrentDirectory( CurrentDir );

    //
    // always return success!
    //
    return JET_errSuccess;

}

ERR DeleteBackupDb( char *szSourceDb, char * SysDb, char * BackupDbPath )
{
    char    TempPath[MAX_PATH];
    CHAR CurrentDir[ MAX_PATH ];
    char    *FileNameInPath;
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    DWORD   Error;
    USHORT  BackupPathLen;

    strcpy(TempPath, BackupDbPath);
    BackupPathLen  = (USHORT)strlen( TempPath );

    if ( (FileNameInPath = strrchr( szSourceDb, '\\') ) == NULL ){
        FileNameInPath = szSourceDb;
    }
    strcat(TempPath, FileNameInPath );

    //
    // delete the database file.
    if ( !DeleteFile( TempPath ) ){
        DBGprintf(("DeleteBackupDb: could not delete backup database file: Error %ld\n",GetLastError()));
        goto Cleanup;
    }


    //
    // Delete system.mdb
    //
    TempPath[ BackupPathLen ] = '\0';
    if ( (FileNameInPath = strrchr( SysDb, '\\') ) == NULL ){
        FileNameInPath = SysDb;
    }
    strcat(TempPath, FileNameInPath );

    //
    // move the database file.
    if ( !DeleteFile( TempPath ) ){
        DBGprintf(("DeleteSystemDb: could not delete system database file: Error %ld\n",GetLastError()));
        goto Cleanup;
    }

    //
    // now delete the log files
    //


    if( GetCurrentDirectory( MAX_PATH, CurrentDir ) == 0 ) {

        Error = GetLastError();
        DBGprintf(("DeleteBackupDb: GetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // set current directory to backup path.
    //

    TempPath[ BackupPathLen ] = '\0';
    if( SetCurrentDirectory( TempPath ) == FALSE ) {
        Error = GetLastError();
        DBGprintf(("DeleteBackupDb: SetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // Start file serach dir.
    //
    HSearch = FindFirstFile( "jet*.log", &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
//        printf("Error: No Log files were found in %s\n", LogFilePath );
        goto Cleanup;
    }

    //
    // Move files.
    //

    for( ;; ) {


        if( DeleteFile( FileData.cFileName  ) == FALSE ) {

            Error = GetLastError();
            DBGprintf(("DeleteBackupDb: could not delete backup log file, Error = %ld.,%s\n", Error, FileData.cFileName));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFile( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( ERROR_NO_MORE_FILES == Error ) {
                break;
            }

//            printf("Error: FindNextFile failed, Error = %ld.\n", Error );
            goto Cleanup;
        }
    }

    Error = JET_errSuccess;
Cleanup:

    if( Error != JET_errSuccess ){
        CHAR    errBuf[11];
        sprintf(errBuf,"%ld",Error);
        CMPPrintMessage( CONVERT_ERR_DELBAKDB_FAIL1_ID, NULL );
        CMPPrintMessage( CONVERT_ERR_DELBAKDB_FAIL2_ID, errBuf );
    }

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }
    //
    // reset current currectory.
    //

    SetCurrentDirectory( CurrentDir );

    //
    // always return success
    //
    return JET_errSuccess;

}


void GetDefaultValues( DB_TYPE DbType, char ** szSourceDB, char ** szOldDll , char ** szOldSysDb, char **LogFilePath, char ** szBackupPath)
{
    DWORD   Error;
    DWORD   ValueType;
    char    TempABuf[MAX_PATH];
    DWORD   BufSize = MAX_PATH;
    DWORD   ExpandLen;
    HKEY    Key;


#define DHCP_DB_PATH_KEY  "DatabasePath"
#define DEFAULT_JET200_DLL_PATH "%SystemRoot%\\System32\\jet.dll"

    if ( (Error = RegOpenKeyA(
            HKEY_LOCAL_MACHINE,
            DefaultValues[DbType].ParametersKey,
            &Key) )!= ERROR_SUCCESS ) {
        CMPPrintMessage( CONVERT_ERR_REGKEY_OPEN1_ID,  DefaultValues[DbType].ParametersKey);
        CMPPrintMessage( CONVERT_ERR_REGKEY_OPEN2_ID, NULL);
        return;
    }

    if ( !*szSourceDB ) {
        if ( DbType == DbDhcp ) {
            if ( (Error = RegQueryValueExA(
                            Key,
                            DHCP_DB_PATH_KEY,
                            NULL,
                            &ValueType,
                            TempABuf,
                            &BufSize)) == ERROR_SUCCESS ) {

                strcat(TempABuf,"\\");
                BufSize = MAX_PATH - strlen(TempABuf) - 1;
                Error = RegQueryValueExA(
                    Key,
                    DefaultValues[DbType].DbNameKey,
                    NULL,
                    &ValueType,
                    TempABuf + strlen(TempABuf),
                    &BufSize);

            }

        } else  if ( DbType == DbWins) {
            Error = RegQueryValueExA(
                Key,
                DefaultValues[DbType].DbNameKey,
                NULL,
                &ValueType,
                TempABuf,
                &BufSize);

        } else { // rpl
            if ( ( Error = RegQueryValueExA(
                        Key,
                        DefaultValues[DbType].DbNameKey,
                        NULL,
                        &ValueType,
                        TempABuf,
                        &BufSize) ) == ERROR_SUCCESS ) {
                strcat( TempABuf, "\\");
                strcat( TempABuf, "rplsvc.mdb");
            }

        }

        if ( Error != ERROR_SUCCESS ) {
            DBGprintf(("Error: Failed to read reg %s, error %ld\n",DefaultValues[DbType].DbNameKey,Error ));
            strcpy( TempABuf, DefaultValues[DbType].DatabaseName );
        }

        ExpandLen = ExpandEnvironmentStringsA( TempABuf, SourceDbBuffer, MAX_PATH );
        if ( (ExpandLen > 0) && (ExpandLen <= MAX_PATH) ) {

            *szSourceDB = SourceDbBuffer;
            CMPPrintMessage( CONVERT_DEF_DB_NAME_ID, *szSourceDB);
        }
    }

    if ( !*szOldDll ) {
        ExpandLen = ExpandEnvironmentStringsA( DEFAULT_JET200_DLL_PATH, OldDllBuffer, MAX_PATH );
        if ( (ExpandLen > 0) && (ExpandLen <= MAX_PATH) ) {

            *szOldDll = OldDllBuffer;
            CMPPrintMessage( CONVERT_DEF_JET_DLL_ID, *szOldDll);
        }
    }

    if ( !*szOldSysDb ) {
        char    *SysDbEnd;
        strcpy( SysDbBuffer,*szSourceDB);
        if ( SysDbEnd  =   strrchr( SysDbBuffer, '\\') ) {
            *SysDbEnd = '\0';
            strcat( SysDbBuffer, "\\" );
            strcat( SysDbBuffer, "system.mdb");
            *szOldSysDb     =   SysDbBuffer;
            CMPPrintMessage( CONVERT_DEF_SYS_DB_ID, *szOldSysDb);
        }

    }

    if ( !*LogFilePath ) {
        char    *LogFilePathEnd;
        strcpy( LogFilePathBuffer,*szSourceDB);
        if ( LogFilePathEnd  =   strrchr( LogFilePathBuffer, '\\') ) {
            *LogFilePathEnd = '\0';
            *LogFilePath     =   LogFilePathBuffer;
            CMPPrintMessage( CONVERT_DEF_LOG_FILE_PATH_ID, *LogFilePath);
        }
    }
    if ( !*szBackupPath ) {
        if ( DbType == DbRPL ) {
            char    *BackupPathEnd;
            strcpy( BackupPathBuffer,*szSourceDB);
            if ( BackupPathEnd  =   strrchr( BackupPathBuffer, '\\') ) {
                *BackupPathEnd = '\0';
                strcat( BackupPathBuffer, "\\");
                strcat( BackupPathBuffer, DefaultValues[DbType].BackupPath);
                *szBackupPath     =   BackupPathBuffer;
                CMPPrintMessage( CONVERT_DEF_BACKUP_PATH_ID, *szBackupPath);
            }

        } else {
            BufSize = MAX_PATH;
            Error = RegQueryValueExA(
                Key,
                DefaultValues[DbType].BackupPathKey,
                NULL,
                &ValueType,
                TempABuf,
                &BufSize);

            if ( Error != ERROR_SUCCESS ) {
                DBGprintf(("Error: Failed to read reg %s, error %ld\n",DefaultValues[DbType].BackupPathKey,Error));
                if ( DefaultValues[DbType].BackupPath ) {
                    strcpy( TempABuf, DefaultValues[DbType].BackupPath );
                } else {
                    return;
                }
            }
            ExpandLen = ExpandEnvironmentStringsA( TempABuf, BackupPathBuffer, MAX_PATH );
            if ( (ExpandLen > 0) && (ExpandLen <= MAX_PATH) ) {

                *szBackupPath = BackupPathBuffer;
                CMPPrintMessage( CONVERT_DEF_BACKUP_PATH_ID, *szBackupPath);
            }
        }

    }

}

int _cdecl main( int argc, char *argv[] )
	{
	JET_INSTANCE	instance = 0;
	JET_SESID		sesid = 0;
	JET_ERR			err;
	INT				iarg;
	char			*arg;
	BOOL			fResult = fTrue;
	JET_CONVERT		convert;
	JET_CONVERT		*pconvert;
	ULONG			timerStart, timerEnd;
	INT				iSec, iMSec, ContFlag;
	char			*szSourceDB = NULL;
	char			*szTempDB = NULL;
	char			*szPreserveDBPath = NULL;
	BOOL			fDumpStats = fFalse;
    BOOL			fPreserveTempDB = fFalse;
    BOOL			fDeleteBackup = fFalse;
    DBFILEHDR       dbfilehdr;
    HANDLE          hMutex = NULL;
    BOOL            fCalledByJCONV=fFalse;

//
// be prepared catch AV so that we can return proper retval to
// the invoker.
//
__try {

    hMsgModule = LoadLibrary(TEXT("convmsg.dll"));
    if ( hMsgModule == NULL ) {
        printf("Msg library could not be loaded %lx\n",GetLastError());
        DBGprintf(("Msg library could not be loaded %lx\n",GetLastError()));
        return 1;

    }

	printf( "%c", cNewLine );


/*	if ( argc < 2 )
		{
		printf( szUsageErr3, cNewLine, cNewLine );
		goto Usage;
		}
*/

	memset( &convert, 0, sizeof(JET_CONVERT) );
	pconvert = &convert;
	
	for ( iarg = 1; iarg < argc; iarg++ )
		{
		arg = argv[iarg];

		if ( strchr( szSwitches, arg[0] ) == NULL )
			{
			if ( szSourceDB == NULL )
				{
				szSourceDB = arg;
				}
			else
				{
                CMPPrintMessage( CRLF_ID, NULL );
                CMPPrintMessage( CONVERT_USAGE_ERR_OPTION_SYNTAX_ID, NULL );
                fResult = fFalse;
				}
			}
		else
			{
			switch( arg[1] )
				{
				case 'b':
				case 'B':
					fResult = FCONVParsePath( arg+2, &szBackupPath, CONVERT_BACKUPDB_ID );
					break;
					
				case 'i':
				case 'I':
					fDumpStats = fTrue;
					break;
					
				case 'p':
				case 'P':
					fPreserveTempDB = fTrue;
					fResult = FCONVParsePath( arg+2, &szPreserveDBPath, CONVERT_PRESERVEDB_ID );
					break;
					
				case 'd':
				case 'D':
					fResult = FCONVParsePath( arg+2, &pconvert->szOldDll, CONVERT_OLDDLL_ID);
					break;

				case 'y':
				case 'Y':
					fResult = FCONVParsePath( arg+2, &pconvert->szOldSysDb,  CONVERT_OLDSYSDB_ID);
					break;

                case 'l':
                case 'L':
                    fResult = FCONVParsePath( arg+2, &LogFilePath, CONVERT_LOGFILES_ID );
                    break;

                case 'e':
                case 'E':
                    DbType = atoi( arg+2 );
                    if ( DbType <= DbTypeMin || DbType >= DbTypeMax ) {
                        CMPPrintMessage( CONVERT_USAGE_ERR_OPTION_DBTYPE_ID, arg+2 );
                    }
                    break;

                case 'r':
                case 'R':
                    fDeleteBackup = fTrue;
                    break;

                case '@':
                    fCalledByJCONV = fTrue;
                    break;

                case '?':
                    fResult = fFalse;
                    break;

                default:
                    CMPPrintMessage( CRLF_ID, NULL );
                    CMPPrintMessage( CONVERT_USAGE_ERR_INVALID_OPTION_ID, arg );
					fResult = fFalse;
				}
			}


		if ( !fResult )
			goto Usage;
		}

    //
    // HACK??
    // if this was not called from jconv.exe then make sure there
    // is no other instance of this util currently running at the same time.
    //
    if ( !fCalledByJCONV ) {
        if (((hMutex = CreateMutex( NULL,
                                   FALSE,
                                   JCONVMUTEXNAME)) == NULL) ||
            ( GetLastError() == ERROR_ALREADY_EXISTS) ) {

            CMPPrintMessage( CONVERT_ERR_ANOTHER_CONVERT1_ID, NULL );
            CMPPrintMessage( CONVERT_ERR_ANOTHER_CONVERT2_ID, NULL );

            if( hMutex ) {
                CloseHandle( hMutex );
            }

            return 1;
        }

    }

    if ( DbType == DbTypeMin )
        {
        CMPPrintMessage( CONVERT_USAGE_ERR_NODBTYPE_ID, NULL );
        goto Usage;
        }

    if( !szSourceDB || !pconvert->szOldDll || !pconvert->szOldSysDb || !szBackupPath ) {
        GetDefaultValues( DbType, &szSourceDB, &pconvert->szOldDll, &pconvert->szOldSysDb, &LogFilePath, &szBackupPath );
    }

    if ( szSourceDB == NULL )
        {
    		CMPPrintMessage( CRLF_ID, NULL );
    		CMPPrintMessage( CONVERT_USAGE_ERR_NODB_ID, NULL );
            goto Usage;
        }				


    if ( pconvert->szOldDll == NULL || pconvert->szOldSysDb == NULL )
        {
		CMPPrintMessage( CRLF_ID, NULL );
		CMPPrintMessage( CONVERT_USAGE_ERR_REQUIRED_PARAMS_ID, NULL );
        goto Usage;
        }				

    if ( !LogFilePath )
        {
        CMPPrintMessage( CONVERT_USAGE_ERR_NOLOGFILEPATH_ID, NULL );
        goto Usage;
        }				

    if ( szBackupPath ) {
        strcpy( BackupPathBuffer, szBackupPath );
        strcat( BackupPathBuffer,"\\");
        strcat( BackupPathBuffer, BackupDefaultSuffix[ DbType ] );
        strcat( BackupPathBuffer,"\\");
        szBackupPath = BackupPathBuffer;
    }

    if ( fDeleteBackup && !szBackupPath ) {
        CMPPrintMessage( CONVERT_USAGE_ERR_NOBAKPATH_ID, NULL );
        goto Usage;
    }



    if ( szPreserveDBPath && !IsPreserveDbOk( szPreserveDBPath) ) {
        CMPPrintMessage( CONVERT_ERR_CREATE_PRESERVEDIR_ID, szPreserveDBPath );
        return 1;
    }

    CMPPrintMessage( CONVERT_START_CONVERT_MSG1_ID, NULL );
    CMPPrintMessage( CONVERT_START_CONVERT_MSG2_ID, szSourceDB );
    if ( !fPreserveTempDB ) {
        CMPPrintMessage( CONVERT_OPTION_P_MISSING_MSG1_ID, NULL);
        CMPPrintMessage( CONVERT_OPTION_P_MISSING_MSG2_ID, NULL);
        CMPPrintMessage( CONVERT_OPTION_P_MISSING_MSG3_ID, NULL);
        CMPPrintMessage( CONVERT_OPTION_P_MISSING_MSG4_ID, NULL);
        CMPPrintMessage( CONVERT_OPTION_P_MISSING_MSG5_ID, NULL);
    }

    if ( !fCalledByJCONV ) {
        CMPPrintMessage( CONVERT_CONTINUE_MSG_ID, NULL);

        ContFlag = getchar();

        if ( (ContFlag != 'y') && (ContFlag != 'Y' ) ) {
            return ( 1 );
        }
    }

    err = ErrUtilReadShadowedHeader( szSourceDB, (BYTE*)&dbfilehdr, sizeof(DBFILEHDR) );
    if ( err == JET_errSuccess  &&
        dbfilehdr.ulMagic == ulDAEMagic  &&
        dbfilehdr.ulVersion == ulDAEVersion )
        {
        CMPPrintMessage( CONVERT_ALREADY_CONVERTED_ID, NULL);
        return 0;
        }

	// Facilitate debugging.
	Call( JetSetSystemParameter( &instance, 0, JET_paramAssertAction, JET_AssertMsgBox, NULL ) );

	// Lights, cameras, action...
	timerStart = GetTickCount();
    Call( JetSetSystemParameter( &instance, 0, JET_paramOnLineCompact, 0, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
	Call( JetInit( &instance ) );
	Call( JetBeginSession( instance, &sesid, "user", "" ) );

    //
    // Make the temp mdb path point to the same place as the actual mdb.
    //
    {
        //
        // prepend the dir path of the mdb to the temp name.
        //
        int i;
        strcpy(szDefaultTempDB, szSourceDB);

        for (i=strlen(szDefaultTempDB)-1; i>=0;  i--) {
            //
            // Find last slash
            //
            if (szDefaultTempDB[i] == '\\') {
                //
                // Append the default name.
                //
                szDefaultTempDB[i+1] = '\0';
                (VOID)strcat(szDefaultTempDB, "tempupgd.mdb");
                break;
            }
        }

        if (i < 0) {
            strcpy(szDefaultTempDB, "tempupgd.mdb");
        }

        // printf("SrcPath: %s, defaulttemppath: %s\n", szSourceDB, szDefaultTempDB);
    }

	// Detach temporary database and delete file if present (ignore errors).
	if ( szTempDB == NULL )
		szTempDB = (char *)szDefaultTempDB;
	JetDetachDatabase( sesid, szTempDB );
	DeleteFile( szTempDB );

//    LgErrInitializeCriticalSection( critJet );
	LgEnterCriticalSection( critJet );
	err = ErrIsamConv200(
		sesid,
		szSourceDB,
		szTempDB,
		PrintStatus,
		pconvert,
		fDumpStats ? JET_bitCompactStats : 0 );
	LgLeaveCriticalSection( critJet );

	Call( err );

	// Make backup before instating, if requested.
	if ( szPreserveDBPath != NULL )
		{
        // printf("calling preservecurrentdb\n");
        Call( PreserveCurrentDb( szSourceDB, LogFilePath, pconvert->szOldSysDb, szPreserveDBPath) );
		}

    // Delete source database and overwrite with temporary database.
    if ( !MoveFileEx( szTempDB, szSourceDB, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED ) )
    {
        Call( JET_errFileAccessDenied );
    }

    //
    // cleanup the log files and database files if they were not moved
    // to the preservedDBPath directory.
    if ( !szPreserveDBPath ) {
        // printf("calling Deletecurrentdb\n");
        Call( DeleteCurrentDb( LogFilePath, pconvert->szOldSysDb ) );
    }

    //
    // cleanup the backup directory if were asked so.
    //
    if ( fDeleteBackup) {
        // printf("calling deletebackupdb\n");
        Call( DeleteBackupDb( szSourceDB, pconvert->szOldSysDb, szBackupPath) );
    }
		
	timerEnd = GetTickCount();
	iSec = ( timerEnd - timerStart ) / 1000;
	iMSec = ( timerEnd - timerStart ) % 1000;

		
HandleError:
	if ( sesid != 0 )
		{
		JetEndSession( sesid, 0 );
		}
	JetTerm( instance );

	if ( szTempDB != NULL  &&  !fPreserveTempDB )
		{
		DeleteFile( szTempDB );
		}

    if ( hMutex ) {
        CloseHandle(hMutex);
    }
	if ( err < 0 )
		{
        CHAR	szErrCode[8];
        sprintf( szErrCode, "%d", err );
        CMPPrintMessage( CONVERT_FAIL_ID, szErrCode );
		return err;
		}
	else
		{

        CHAR	szTime[32];
        sprintf( szTime, "%d.%d", iSec, iMSec );
        CMPPrintMessage( CONVERT_SUCCESS_ID, szTime );

		return 0;
		}

Usage:
	CMPPrintMessage( CONVERT_HELP_DESC_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_SYNTAX_ID, argv[0] );
	CMPPrintMessage( CONVERT_HELP_PARAMS1_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_PARAMS2_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_PARAMS3_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_PARAMS4_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_PARAMS5_ID, NULL );

	CMPPrintMessage( CONVERT_HELP_OPTIONS1_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_OPTIONS2_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_OPTIONS3_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_OPTIONS4_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_OPTIONS5_ID, NULL );

	CMPPrintMessage( CONVERT_HELP_EXAMPLE1_ID, argv[0] );
	CMPPrintMessage( CONVERT_HELP_EXAMPLE2_ID, argv[0] );
	CMPPrintMessage( CONVERT_HELP_EXAMPLE3_ID, NULL );
	CMPPrintMessage( CONVERT_HELP_EXAMPLE4_ID, argv[0] );
	CMPPrintMessage( CONVERT_HELP_EXAMPLE5_ID, NULL );

	return 1;

}
__except ( EXCEPTION_EXECUTE_HANDLER) {
    CHAR    errBuf[11];
    sprintf(errBuf,"%lx",GetExceptionCode());
	CMPPrintMessage( CONVERT_ERR_EXCEPTION_ID, errBuf );
    return 1;
}

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\jet500\makefile.inc ===
$(O)\jetmsg.h $(O)\jetmsg.rc: ..\lang\usa\jetmsg.mc
    $(MC) -v -h $(O) -r $(O) $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\vtmgr.c ===
#include "std.h"

DeclAssertFile;


extern const VTFNDEF vtfndefInvalidTableid;

JET_TABLEID		tableidFree;
VTDEF			rgvtdef[tableidMax];
#ifdef DEBUG
int				cvtdefFree = 0;
#endif


#ifdef DEBUG
VOID MarkTableidExportedR( JET_TABLEID tableid )
	{
//	Assert((tableid < tableidMax) && (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid));
	if (tableid != JET_tableidNil)
		rgvtdef[tableid].fExported = fTrue;
	return;
	}


BOOL FTableidExported(JET_TABLEID tableid)
	{
	if (tableid == JET_tableidNil)
		goto ReturnFalse;
	if (tableid >= tableidMax)
		goto ReturnFalse;
	if (!rgvtdef[tableid].fExported)
		goto ReturnFalse;
	return fTrue;
ReturnFalse:
	/*** PUT BREAKPOINT HERE TO CATCH BOGUS TABLEIDS ***/
	return fFalse;
	}
#endif


VOID ReleaseTableid( JET_TABLEID tableid )
	{
//	Assert((tableid < tableidMax) && (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid));

	rgvtdef[tableid].vtid = (JET_VTID) tableidFree;
	rgvtdef[tableid].pvtfndef = &vtfndefInvalidTableid;

	tableidFree = tableid;
#ifdef DEBUG
	cvtdefFree++;
#endif
	}


ERR ErrVtmgrInit(void)
	{
	JET_TABLEID tableid;

	tableidFree = JET_tableidNil;

	for (tableid = (JET_TABLEID) 0; tableid < tableidMax; tableid++)
		ReleaseTableid(tableid);

	return(JET_errSuccess);
	}


ERR ErrAllocateTableid( JET_TABLEID *ptableid, JET_VTID vtid, const struct tagVTFNDEF *pvtfndef )
	{
	JET_TABLEID tableid;

#ifdef DEBUG
	/*	check for corruption of free list
	/**/
	{
	JET_TABLEID t = tableidFree;

	while ( t != JET_tableidNil )
		{
		Assert( rgvtdef[t].pvtfndef == &vtfndefInvalidTableid );
		t = rgvtdef[t].vtid;
		}
	}
#endif

	if ( ( *ptableid = tableid = tableidFree ) == JET_tableidNil )
		{
//		Assert( "static limit of cursors hit" == 0 );
		return JET_errOutOfCursors;
		}

	tableidFree = (JET_TABLEID) rgvtdef[tableid].vtid;

	rgvtdef[tableid].vsesid = (JET_VSESID) 0xFFFFFFFF;
	rgvtdef[tableid].vtid = vtid;

	rgvtdef[tableid].pvtfndef = pvtfndef;

#ifdef DEBUG
	rgvtdef[tableid].fExported = fFalse;
	cvtdefFree--;
#endif
	return(JET_errSuccess);
	}


ERR ErrGetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID  *pvtid)
	{
	if ( ( tableid >= tableidMax ) ||
		( rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid ) )
		return JET_errInvalidTableId;

	*pvtid = rgvtdef[tableid].vtid;

	return JET_errSuccess;
	}


ERR ErrSetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid)
	{
	if ( ( tableid >= tableidMax ) ||
		( rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid ) )
		return JET_errInvalidTableId;

	rgvtdef[tableid].vtid = vtid;

	return(JET_errSuccess);
	}


ERR ErrGetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF  *  *ppvtfndef)
	{
	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	*ppvtfndef = rgvtdef[tableid].pvtfndef;

	return JET_errSuccess;
	}


ERR ErrSetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF  *pvtfndef)
	{
	if ( ( tableid >= tableidMax ) ||
		( rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid ) )
		return JET_errInvalidTableId;

	rgvtdef[tableid].pvtfndef = pvtfndef;

	return JET_errSuccess;
	}


ERR ErrUpdateTableid(JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF  *pvtfndef)
	{
	if ( ( tableid >= tableidMax ) ||
		( rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid ) )
		return JET_errInvalidTableId;

	rgvtdef[tableid].vtid = vtid;
	rgvtdef[tableid].pvtfndef = pvtfndef;

	return JET_errSuccess;
	}


#ifdef DEBUG
BOOL FValidateTableidFromVtid( JET_VTID vtid, JET_TABLEID tableid, const struct tagVTFNDEF **ppvtfndef )
	{
	JET_TABLEID	tableidT;
	BOOL		fFound = fFalse;

	Assert( tableid != JET_tableidNil );

	*ppvtfndef = &vtfndefInvalidTableid;

	for ( tableidT = 0; tableidT < tableidMax; tableidT++ )
		{
		if ( rgvtdef[tableidT].vtid == vtid )
			{
			if ( tableidT == tableid )
				{
				Assert( !fFound );
				fFound = fTrue;

				Assert( rgvtdef[tableidT].pvtfndef != &vtfndefInvalidTableid );
				*ppvtfndef = rgvtdef[tableidT].pvtfndef;
				}
			else
				{
				return fFalse;
				}
			}
		}

	return fFound;
	
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\utilw32.c ===
#include "std.h"
#include "version.h"
#define PERFMON         1

#include <stdarg.h>

#include <winioctl.h>

DeclAssertFile;

#include <stdio.h>

#define TO_UPPER_ONLY	1
#ifndef TO_UPPER_ONLY
#include "b71iseng.h"
#endif

#ifdef DAYTONA
#undef szVerName
#define szVerName	"JET"
char szDLLFile[_MAX_PATH] = "jet500.dll";
#else
char szDLLFile[_MAX_PATH] = "edb.dll";
#endif

/*  DLL entry point for JET.DLL
/**/
INT APIENTRY LibMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
	{
	/*  get DLL path for registry initialization
	/**/
	GetModuleFileName( hInst, szDLLFile, sizeof( szDLLFile ) );
	
	return(1);
	}


/***********************************************************
/***************** debug print routines ********************
/***********************************************************
/**/
#define szJetTxt "edb.txt"

#ifdef DEBUG

BOOL fDBGPrintToStdOut = fFalse;

void VARARG PrintF2(const CHAR * fmt, ...)
	{
	if ( fDBGPrintToStdOut )
		{
		va_list arg_ptr;
		va_start( arg_ptr, fmt );
		vprintf( fmt, arg_ptr );
		fflush( stdout );
		va_end( arg_ptr );
		}
	}


void VARARG FPrintF2(const CHAR * fmt, ...)
	{
	FILE *f;

	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	
	if ( fDBGPrintToStdOut )
		{
		vprintf( fmt, arg_ptr );
		fflush( stdout );
		}
	else
		{
		f = fopen( szJetTxt, "a+" );
		if ( f != NULL )
			{
			vfprintf( f, fmt, arg_ptr );
			fflush( f );
			fclose( f );
			}
		}
		
	va_end( arg_ptr );
	}

#endif  /* DEBUG */



/***********************************************************
/******************** error handling ***********************
/***********************************************************
/**/

STATIC ERR ErrUTILIGetLastErrorFromErr( ERR errDefault )
	{
	ERR		err = errDefault;
	DWORD   dw = DwUtilGetLastError();

	/*	maps system error to JET error, or sets err to given default error
	/**/
	switch ( dw )
		{
	case ERROR_TOO_MANY_OPEN_FILES:
		err = JET_errOutOfFileHandles;
		break;
	case ERROR_ACCESS_DENIED:
	case ERROR_SHARING_VIOLATION:
	case ERROR_LOCK_VIOLATION:
		err = JET_errFileAccessDenied;
		break;
	default:
		break;
		}

	return ErrERRCheck( err );
	}


STATIC ERR ErrUTILIGetLastError( VOID )
	{
	DWORD   dw = DwUtilGetLastError();
	char	szT[64];
	char	*rgszT[1] = { szT };
		
	if ( dw == ERROR_IO_PENDING ||
		 dw == NO_ERROR )
		return JET_errSuccess;

	if ( dw == ERROR_INVALID_USER_BUFFER ||
		 dw == ERROR_NOT_ENOUGH_MEMORY )
		return ErrERRCheck( JET_errTooManyIO );
		
	if ( dw == ERROR_DISK_FULL )
		return ErrERRCheck( JET_errDiskFull );

	if ( dw == ERROR_HANDLE_EOF )
		return ErrERRCheck( JET_errDiskIO );

	if ( dw == ERROR_FILE_NOT_FOUND )
		return ErrERRCheck( JET_errFileNotFound );

	if ( dw == ERROR_NO_MORE_FILES )
		return ErrERRCheck( JET_errFileNotFound );

	if ( dw == ERROR_PATH_NOT_FOUND )
		return ErrERRCheck( JET_errFileNotFound );

	if ( dw == ERROR_VC_DISCONNECTED )
		return ErrERRCheck( JET_errDiskIO );

	if ( dw == ERROR_WRITE_PROTECT )
		return ErrERRCheck( JET_errDiskIO );

	if ( dw == ERROR_IO_DEVICE )
		return ErrERRCheck( JET_errDiskIO );

	if ( dw == ERROR_ACCESS_DENIED )
		return ErrERRCheck( JET_errFileAccessDenied );

	if ( dw == ERROR_NO_SYSTEM_RESOURCES )
		return ErrERRCheck( JET_errDiskIO );

	/*	if this code is hit, then we need another error code
	/**/
	sprintf( szT, "Unexpected Win32 error:  0x%lX", dw );
//#ifdef DEBUG
//	AssertFail( szT, szAssertFilename, __LINE__ );
//#endif
	UtilReportEvent( EVENTLOG_ERROR_TYPE, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );

	return ErrERRCheck( JET_errDiskIO );
	}


/*	test/debug utility for both debug and non-debug builds
/**/
VOID UtilDebugBreak()
	{
	DebugBreak();
	return;
	}

/***********************************************************
/************** international string support ***************
/***********************************************************
/**/
ERR ErrUtilCheckLangid( LANGID *plangid )
	{
	ERR		err;
	WCHAR	rgwA[1];
	WCHAR	rgwB[1];

	/*	if langid is system default, then coerece to system default
	/**/
	if	( *plangid == LANG_SYSTEM_DEFAULT )
		{
		*plangid = GetSystemDefaultLangID();
		}
	else if ( *plangid == LANG_USER_DEFAULT )
		{
		*plangid = GetUserDefaultLangID();
		}

//NOTE:	Julie Bennett said that starting with DAYTONA, the best call to use
//		is IsValidLocale().  I don't have libraries to link to for that yet.
//		She said that the best thing (for performance reasons) to do in NT
//		(pre-daytona) is call CompareStringW with counts of -1.  This will
//		determine if the langid is currently configured on the machine.
//		(not just a valid langid somewhere in the universe).

	rgwA[0] = 0;
	rgwB[0] = 0;

	if ( CompareStringW( MAKELCID( *plangid, 0 ), NORM_IGNORECASE, rgwA, -1, rgwB, -1 ) == 0 )
		{
		Assert( DwUtilGetLastError() == ERROR_INVALID_PARAMETER );
		err = ErrERRCheck( JET_errInvalidLanguageId );
		}
	else
		{
		err = JET_errSuccess;
		}
	
	return err;
	}

				
ERR ErrUtilMapString(
	LANGID  langid,
	BYTE    *pbColumn,
	INT		cbColumn,
	BYTE    *rgbSeg,
	INT		cbMax,
	INT		*pcbSeg )
	{
	ERR		err = JET_errSuccess;

#ifndef _X86_
	/*      convert pbColumn to aligned pointer for MIPS/Alpha builds
	/**/
	BYTE    rgbColumn[JET_cbColumnMost];
#endif

//      UNDONE: refine this constant based on unicode key format
/*      3 * number of unicode character bytes + 7 overhead bytes + 10 fudge
/**/
#define JET_cbUnicodeKeyMost    ( 3 * JET_cbColumnMost + 7 + 10 )
	BYTE    rgbKey[JET_cbUnicodeKeyMost];
	INT		cbKey;

#ifndef _X86_
	memcpy( rgbColumn, pbColumn, cbColumn );
	pbColumn = (BYTE *)&rgbColumn[0];
#endif

	/*	assert non-zero length unicode string
	/**/
	Assert( cbColumn <= JET_cbColumnMost );
	Assert( cbColumn > 0 );
	Assert( cbColumn % 2 == 0 );

	cbKey = LCMapStringW(
		MAKELCID( langid, 0 ),
		LCMAP_SORTKEY | NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
		(const unsigned short *)pbColumn,
		(int) cbColumn / sizeof(WORD),
		(unsigned short *)rgbKey,
		JET_cbUnicodeKeyMost );
	if ( cbKey == 0 )
		{
		/*	cbKey is 0 if WindowsNT installation does not
		/*	support language id.  This can happen if a database
		/*	is moved from one machine to another.
		/**/
		BYTE	szT[16];
		BYTE	*rgszT[1];

		sprintf( szT, "%lx", langid );
		rgszT[0] = szT;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, LANGUAGE_NOT_SUPPORTED_ID, 1, rgszT );
		err = ErrERRCheck( JET_errInvalidLanguageId );
		}
	else
		{
		Assert( cbKey > 0 );

		if ( cbKey > cbMax )
			{
			err = ErrERRCheck( wrnFLDKeyTooBig );
			*pcbSeg = cbMax;
			}
		else
			{
			Assert( err == JET_errSuccess );
			*pcbSeg = cbKey;
			}
		memcpy( rgbSeg, rgbKey, *pcbSeg );
		}

	return err;
	}


//+api------------------------------------------------------
//
//	UtilNormText( CHAR *rgchText, INT cchText, CHAR *rgchNorm, INT cchNorm, INT *pchNorm )
//	=========================================================
//
//	VOID UtilNormText( CHAR *rgchText, INT cchText, CHAR *rgchNorm, INT cchNorm, INT *pchNorm )
//
//	Normalizes text string.
//
//----------------------------------------------------------
VOID UtilNormText( CHAR *rgchText, INT cchText, BYTE *rgbNorm, INT cbNorm, INT *pbNorm )
	{
	ERR     err;

	Assert( cbNorm <= JET_cbKeyMost );
	err = ErrUtilNormText( rgchText, cchText, cbNorm, rgbNorm, pbNorm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );

	return;
	}


#ifndef BINARY_NAMES
//+api------------------------------------------------------
//
//	VOID UtilCmpName( const CHAR *sz1, const CHAR sz2 )
//	========================================================
//	Compares two unnormalized text strings by first normalizing them
//	and then comparing them.
//
//	Returns:	> 0		if sz1 > sz2
//				== 0	if sz1 == sz2
//				< 0		if sz1 < sz2
//
//----------------------------------------------------------
INT UtilCmpName( const CHAR *sz1, const CHAR *sz2 )
	{
#ifdef TO_UPPER_ONLY
	return _stricmp( sz1, sz2 );
#else
	ERR		err;
	INT		cch1;
	INT		cch2;
	CHAR    rgch1Norm[ JET_cbKeyMost ];
	INT		cch1Norm;
	CHAR    rgch2Norm[ JET_cbKeyMost ];
	INT		cch2Norm;
	INT		cchDiff;
	INT		iCmp;

	/*	get text string lengths
	/**/
	cch1 = strlen( sz1 );
	Assert( cch1 <= JET_cbKeyMost );
	cch2 = strlen( sz2 );
	Assert( cch2 <= JET_cbKeyMost );

	err = ErrUtilNormText( sz1, cch1, JET_cbKeyMost, rgch1Norm, &cch1Norm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );

	err = ErrUtilNormText( sz2, cch2, JET_cbKeyMost, rgch2Norm, &cch2Norm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
	
	cchDiff = cch1Norm - cch2Norm;
	iCmp = memcmp( rgch1Norm, rgch2Norm, cchDiff < 0 ? cch1Norm : cch2Norm );
	Assert( ( iCmp == 0 && _stricmp( sz1, sz2 ) == 0 )
		|| ( cchDiff < 0 && _stricmp( sz1, sz2 ) < 0 )
		|| ( cchDiff > 0 && _stricmp( sz1, sz2 ) > 0 ) );
	return iCmp ? iCmp : cchDiff;
#endif
	}


VOID UtilStringCompare( char  *pb1,
	unsigned long cb1,
	char  *pb2,
	unsigned long cb2,
	unsigned long sort,
	long  *plResult )
	{
	CHAR    rgb1[JET_cbColumnMost + 1];
	CHAR    rgb2[JET_cbColumnMost + 1];

	/*      ensure NULL terminated
	/**/
	memcpy( rgb1, pb1, min( JET_cbColumnMost, cb1 ) );
	rgb1[ min( JET_cbColumnMost, cb1 ) ] = '\0';
	memcpy( rgb2, pb2, min( JET_cbColumnMost, cb2 ) );
	rgb2[ min( JET_cbColumnMost, cb2 ) ] = '\0';

	*plResult = UtilCmpName( (const char *)rgb1, (const char *)rgb2 );

	return;
	}
#endif


ERR ErrUtilNormText(
	const BYTE		*pbText,
	INT				cbText,
	INT				cbKeyBufLeft,
	BYTE			*pbNorm,
	INT				*pcbNorm )
	{
#ifdef TO_UPPER_ONLY
	JET_ERR			err;
	BYTE			*pb;
	BYTE			*pbMax;

	if ( cbKeyBufLeft == 0 )
		{
		*pcbNorm = 0;
		if ( cbText == 0 )
			{
			err = JET_errSuccess;
			}
		else
			{
			err = ErrERRCheck( wrnFLDKeyTooBig );
			}
		}
	else
		{
		Assert( cbKeyBufLeft > 0 );

		if ( cbText < cbKeyBufLeft )
			{
			err = JET_errSuccess;
			strncpy( pbNorm, pbText, cbText );
			pbNorm[cbText] = '\0';
			_strupr( pbNorm );
			*pcbNorm = cbText + 1;
			}
		else
			{
			err = ErrERRCheck( wrnFLDKeyTooBig );
			for ( pb = pbNorm, pbMax = pbNorm + cbKeyBufLeft;
				pb < pbMax;
				pb++, pbText++ )
				*pb = (BYTE)toupper( *pbText );
			*pcbNorm = cbKeyBufLeft;
			}
		}

	return err;
#else
	BYTE            *pbNormBegin = pbNorm;
	BYTE            rgbAccent[ (JET_cbKeyMost + 1) / 2 + 1 ];
	BYTE            *pbAccent = rgbAccent;
	BYTE            *pbBeyondKeyBufLeft = pbNorm + cbKeyBufLeft;
	const BYTE      *pbBeyondText;
	const BYTE      *pbTextLastChar = pbText + cbText - 1;
	BYTE            bAccentTmp = 0;

	while ( *pbTextLastChar-- == ' ' )
		cbText--;

	/*	add one back to the pointer
	/**/
	pbTextLastChar++;

	Assert( pbTextLastChar == pbText + cbText - 1 );
	pbBeyondText = pbTextLastChar + 1;

	while ( pbText <  pbBeyondText && pbNorm < pbBeyondKeyBufLeft )
		{
		BYTE	bTmp;

		/*	do a single to single char conversion
		/**/
		*pbNorm = bTmp = BGetTranslation(*pbText);

		if ( bTmp >= 250 )
			{
			/*	do a single to double char conversion
			/**/
			*pbNorm++ = BFirstByteForSingle(bTmp);
			if ( pbNorm < pbBeyondKeyBufLeft )
				*pbNorm = BSecondByteForSingle(bTmp);
			else
				break;

			/*	no need to do accent any more,
			/*	so break out of while loop
			/**/
			}

		pbNorm++;

		/*	at this point, pbText should point to the char for accent mapping
		/**/

		/*	do accent now
		/*	the side effect is to increment pbText
		/**/
		if ( bAccentTmp == 0 )
			{
			/*	first nibble of accent
			/**/
			bAccentTmp = (BYTE)( BGetAccent( *pbText++ ) << 4 );
			Assert( bAccentTmp > 0 );
			}
		else
			{
			/*	already has first nibble
			/**/
			*pbAccent++ = BGetAccent(*pbText++) | bAccentTmp;
			bAccentTmp = 0;
			/*	reseting the accents
			/**/
			}
		}

	if ( pbNorm < pbBeyondKeyBufLeft )
		{
		/*	need to do accent
		/**/
		*pbNorm++ = 0;

		/*	key-accent separator
		/**/
		if ( bAccentTmp != 0 && bAccentTmp != 0x10 )
			{
			/*	an trailing accent which is not 0x10 should be kept
			/**/
			*pbAccent++ = bAccentTmp;
			}

		/*	at this point, pbAccent is pointing at one char
		/*	beyond the accent bytes.  clear up trailing 0x11's
		/**/
		while (--pbAccent >= rgbAccent && *pbAccent == 0x11)
			;
		*( pbAccent + 1 ) = 0;

		/*	append accent to text.
		/*	copy bytes up to and including '\0'.
		/*	case checked for rgbAccent being empty.
		/**/
		pbAccent = rgbAccent;
		Assert( pbNorm <= pbBeyondKeyBufLeft );
		while ( pbNorm < pbBeyondKeyBufLeft  &&  (*pbNorm++  =  *pbAccent++ ) )
			;
		}

	/*	compute the length of the normalized key and return
	/**/
	*pcbNorm = pbNorm - pbNormBegin;

	if ( pbNorm < pbBeyondKeyBufLeft )
		{
		return JET_errSuccess;
		}

	return ErrERRCheck( wrnFLDKeyTooBig );
#endif
	}


/***********************************************************
/******************** memory allocation ********************
/***********************************************************
/**/

/*	monitored  memory stats
/**/

static ULONG    cbAllocTotal = 0;
static ULONG    cblockAlloc = 0;
static ULONG    cblockFree = 0;


#if defined( DEBUG ) || defined( RFS2 )

#ifdef MEM_CHECK

#define icalMax 10000

typedef struct  {
	VOID    *pv;
	ULONG   cbAlloc;
	BYTE    alloctyp;
	} CAL;

static CAL              rgcal[icalMax];
static BOOL             fInit = fFalse;

static cbSAlloc = 0;
static cbLAlloc = 0;
static cbUAlloc = 0;

#define alloctypS 1
#define alloctypL 2
#define alloctypU 3

VOID UtilIInsertAlloc( VOID *pv, ULONG cbAlloc, INT alloctyp )
	{
	INT		ical;

	/*	do not track failed allocations
	/**/
	if ( pv == NULL )
		return;

	/*	initialize array of allocations if not yet initialized.
	/**/
	if ( fInit == fFalse )
		{
		memset( rgcal, '\0', sizeof(rgcal) );
		fInit = fTrue;
		}

	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == NULL )
			{
			rgcal[ical].pv = pv;
			rgcal[ical].cbAlloc = cbAlloc;
			rgcal[ical].alloctyp = alloctyp;
			switch( alloctyp )
				{
				case alloctypS: cbSAlloc += cbAlloc; break;
				case alloctypL: cbLAlloc += cbAlloc; break;
				case alloctypU: cbUAlloc += cbAlloc; break;
				}
			cbAllocTotal += cbAlloc;
			cblockAlloc++;
			return;
			}
		}
	Assert( fFalse );
	}


VOID UtilIDeleteAlloc( VOID *pv, INT alloctyp )
	{
	INT     ical;

	Assert( pv != NULL );
	Assert( fInit == fTrue );

	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == pv )
			{
			INT cbAlloc = rgcal[ical].cbAlloc;
			cblockFree++;
			cbAllocTotal -= cbAlloc;
			Assert( rgcal[ical].alloctyp == alloctyp );
			switch( alloctyp )
				{
				case alloctypS: cbSAlloc -= cbAlloc; Assert( cbSAlloc >= 0 ); break;
				case alloctypL: cbLAlloc -= cbAlloc; Assert( cbLAlloc >= 0 ); break;
				case alloctypU: cbUAlloc -= cbAlloc; Assert( cbUAlloc >= 0 ); break;
				}
			rgcal[ical].pv = NULL;
			rgcal[ical].cbAlloc = 0;
			return;
			}
		}
	AssertSz( fFalse, "Attempt to Free a bad pointer" );
	}

#else  //  !MEM_CHECK

#define UtilIInsertAlloc( pv, cb, alloctyp )
#define UtilIDeleteAlloc( pv, alloctyp )

#endif  //  !MEM_CHECK


VOID *SAlloc( unsigned long cbBlock )
	{
	VOID *pv;

#ifdef RFS2
	if ( !RFSAlloc( SAllocMemory ) )
		return NULL;
#endif

	pv =  GlobalAlloc( 0, cbBlock );
	UtilIInsertAlloc( pv, cbBlock, alloctypS );
	return pv;
	}


VOID OSSFree( void *pv )
	{
	UtilIDeleteAlloc( pv, alloctypS );
	GlobalFree( pv );
	}


VOID *LAlloc( unsigned long cBlock, unsigned short cbBlock )
	{
	VOID *pv;

#ifdef RFS2
	if ( !RFSAlloc( LAllocMemory ) )
		return NULL;
#endif

	pv =  GlobalAlloc( 0, cBlock * cbBlock );
	UtilIInsertAlloc( pv, cBlock * cbBlock, alloctypL );
	return pv;
	}


VOID OSLFree( void *pv )
	{
	UtilIDeleteAlloc( pv, alloctypL );
	GlobalFree( pv );
	}


VOID *PvUtilAlloc( ULONG dwSize )
	{
	VOID            *pv;

#ifdef RFS2
	if ( !RFSAlloc( PvUtilAllocMemory ) )
		return NULL;
#endif

	pv = VirtualAlloc( NULL, dwSize, MEM_RESERVE, PAGE_READWRITE );
	UtilIInsertAlloc( pv, dwSize, alloctypU );
	return pv;
	}


VOID *PvUtilCommit( VOID *pv, ULONG ulSize )
	{
	VOID *pvCommit;

	pvCommit = VirtualAlloc( pv, ulSize, MEM_COMMIT, PAGE_READWRITE );

	return pvCommit;
	}


VOID UtilFree( VOID *pv )
	{
	UtilIDeleteAlloc( pv, alloctypU );
	VirtualFree( pv, 0, MEM_RELEASE );
	return;
	}


VOID UtilDecommit( VOID *pv, ULONG ulSize  )
	{
	VirtualFree( pv, ulSize, MEM_DECOMMIT );
	return;
	}

#endif  //  DEBUG || RFS2


VOID *PvUtilAllocAndCommit( ULONG ulSize )
	{
	VOID *pv;
	
	if ( ( pv = PvUtilAlloc( ulSize ) ) == NULL )
		return pv;
	if ( PvUtilCommit( pv, ulSize ) == NULL )
		{
		UtilFree( pv );
		return NULL;
		}
	return pv;
	}


void UtilMemCheckTerm(void)
	{
#ifdef MEM_CHECK
#ifdef DEBUG
	ULONG   cbTrueAllocTotal = cbAllocTotal;  /*  Alloc total not counting crit's  */
	INT		ical;
	ULONG   cbTotalNotFreed = 0;

	/*	find critJet in store and delete size from true alloc total, if allocated
	/**/
	if ( critJet )
		{
		for ( ical = 0; ical < icalMax; ical++ )
			{
			if ( rgcal[ical].pv == critJet )
				{
				cbTrueAllocTotal -= rgcal[ical].cbAlloc;
				break;
				}
			}
		}
		
	if ( cbTrueAllocTotal != 0 )
		{
		char szAllocTotal[256];

		sprintf( szAllocTotal, "%ld bytes unfreed memory on termination.", cbTrueAllocTotal );
		AssertFail((const char *)szAllocTotal, szAssertFilename, __LINE__ );
		}
	
	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv )
			{
			cbTotalNotFreed += rgcal[ical].cbAlloc;
			}
		}
#endif
#endif
	return;
	}


/***********************************************************
/****************** thread managment ***********************
/***********************************************************
/**/


VOID UtilSleepEx( ULONG ulTime, BOOL fAlert )
	{
	UtilAssertNotInCrit( critJet );
	Assert( ulTime < cmsecSleepMax );
	if ( ulTime > cmsecSleepMax )
		ulTime = cmsecSleepMax;
	SleepEx( ulTime, fAlert );
	return;
	}


VOID UtilSleep( ULONG ulTime )
	{
	if ( ulTime != 0 )
		{
		UtilAssertNotInCrit( critJet );
		}
	Assert( ulTime < cmsecSleepMax );
	if ( ulTime > cmsecSleepMax )
		ulTime = cmsecSleepMax;
	Sleep( ulTime );
	return;
	}


//+api------------------------------------------------------
//
//      ErrUtilCreateThread( ULONG (*pulfn)(), ULONG cbStackSize, LONG lThreadPriority, HANDLE *phandle );
//      ========================================================
//
//      Creates a thread with the given stack size.
//
//----------------------------------------------------------
ERR ErrUtilCreateThread( ULONG (*pulfn)(), ULONG cbStackSize, LONG lThreadPriority, HANDLE *phandle )
	{
	HANDLE	handle;
	DWORD	tid;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );

	handle = (HANDLE) CreateThread( NULL,
		cbStackSize,
		(LPTHREAD_START_ROUTINE) pulfn,
		NULL,
		(DWORD) 0,
		&tid );
	if ( handle == 0 )
		{
		return ErrERRCheck( JET_errOutOfThreads );
		}

	if ( lThreadPriority != THREAD_PRIORITY_NORMAL )
		SetThreadPriority( handle, lThreadPriority );

	/*      return handle to thread
	/**/
	*phandle = handle;
	return JET_errSuccess;
	}


//+api------------------------------------------------------
//
//      UtilEndThread
//      ========================================================
//
//      UtilEndThread( HANDLE hThread, SIG sigEnd );
//
//      Returns thread exit code, if accessible.
//
//----------------------------------------------------------
ULONG UtilEndThread( HANDLE hThread, SIG sigEnd )
	{
	DWORD   dwExitCode;

	SetEvent( (HANDLE)sigEnd );
	WaitForSingleObject( hThread, INFINITE );

	GetExitCodeThread( hThread, &dwExitCode );
	return (unsigned long)dwExitCode;
	}


/*	sets thread priority to high or normal
/**/
void UtilSetThreadPriority( HANDLE hThread, LONG lThreadPriority )
	{
	BOOL f;

	Assert( lThreadPriority == lThreadPriorityNormal ||
		lThreadPriority == lThreadPriorityHigh );

	if ( lThreadPriority == lThreadPriorityNormal )
		{
		f = SetThreadPriority( hThread, THREAD_PRIORITY_NORMAL );
		Assert( f );
		}
	else if ( lThreadPriority == lThreadPriorityHigh )
		{
		f = SetThreadPriority( hThread, THREAD_PRIORITY_HIGHEST );
		Assert( f );
		}
	return;
	}


	/*  Registry support
	/*
	/*  NOTE:  I have mapped out reserved args and have set defaults for security
	/*         to simplify calls
	/**/

#include <winreg.h>

	/*  Polymorph Windows error codes to ErrUtilReg relevant JET error codes  */

ERR ErrUtilRegPolyErr(DWORD errWin)
	{
	switch ( errWin )
		{
		case ERROR_SUCCESS:
		case ERROR_REGISTRY_RECOVERED:
			return JET_errSuccess;
		case ERROR_OUTOFMEMORY:
		case ERROR_NOT_ENOUGH_MEMORY:
			return ErrERRCheck( JET_errOutOfMemory );
		case ERROR_BADKEY:
			return ErrERRCheck( JET_errPermissionDenied );
		case ERROR_CANTOPEN:
		case ERROR_CANTREAD:
		case ERROR_CANTWRITE:
		case ERROR_KEY_DELETED:
		case ERROR_KEY_HAS_CHILDREN:
		case ERROR_CHILD_MUST_BE_VOLATILE:
			return ErrERRCheck( JET_errAccessDenied );
		case ERROR_BADDB:
		case ERROR_REGISTRY_CORRUPT:
		case ERROR_REGISTRY_IO_FAILED:
		case ERROR_NO_LOG_SPACE:
			return ErrERRCheck( JET_errDiskIO );
		default:
			return ErrERRCheck( JET_errPermissionDenied );
		};

	return JET_errSuccess;
	}


ERR ErrUtilRegOpenKeyEx( HKEY hkeyRoot, LPCTSTR lpszSubKey, PHKEY phkResult )
	{
	return ErrUtilRegPolyErr(RegOpenKeyEx(hkeyRoot,lpszSubKey,0,KEY_ALL_ACCESS,phkResult));
	}


ERR ErrUtilRegCloseKeyEx( HKEY hkey )
	{
	ERR             err = JET_errSuccess;

	if ( hkey != (HKEY)(-1) )
		{
		err = ErrUtilRegPolyErr( RegCloseKey(hkey) );
		}

	return err;
	}


ERR ErrUtilRegCreateKeyEx( HKEY hkeyRoot,
	LPCTSTR lpszSubKey,
	PHKEY phkResult,
	LPDWORD lpdwDisposition )
	{
	return ErrUtilRegPolyErr(RegCreateKeyEx(hkeyRoot,lpszSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,NULL,phkResult,lpdwDisposition));
	}


ERR ErrUtilRegDeleteKeyEx( HKEY hkeyRoot, LPCTSTR lpszSubKey )
	{
	return ErrUtilRegPolyErr( RegDeleteKey( hkeyRoot, lpszSubKey ) );
	}


ERR ErrUtilRegDeleteValueEx( HKEY hkey, LPTSTR lpszValue )
	{
	return ErrUtilRegPolyErr( RegDeleteValue( hkey,lpszValue ) );
	}


ERR ErrUtilRegSetValueEx(HKEY hkey,LPCTSTR lpszValue,DWORD fdwType,CONST BYTE *lpbData,DWORD cbData)
	{
	/*  make sure type is set correctly by deleting value first
	/**/
	(VOID)ErrUtilRegDeleteValueEx( hkey, (LPTSTR)lpszValue );
	return ErrUtilRegPolyErr( RegSetValueEx( hkey, lpszValue, 0, fdwType, lpbData, cbData ) );
	}


/*  ErrUtilRegQueryValueEx() adds to the functionality of RegQueryValueEx() by returning
/*  the data in callee SAlloc()ed memory and automatically converting REG_EXPAND_SZ
/*  strings using ExpandEnvironmentStrings() to REG_SZ strings.
/*
/*  NOTE:  references to nonexistent env vbles will be left unexpanded :-(  (Ex.  %UNDEFD% => %UNDEFD%)
/**/
ERR ErrUtilRegQueryValueEx(HKEY hkey,LPTSTR lpszValue,LPDWORD lpdwType,LPBYTE *lplpbData)
	{
	DWORD           cbData;
	LPBYTE          lpbData;
	DWORD           errWin;
	DWORD           cbDataExpanded;
	LPBYTE          lpbDataExpanded;

	*lplpbData = NULL;
	if ( ( errWin = RegQueryValueEx( hkey, lpszValue, 0, lpdwType, NULL, &cbData ) ) != ERROR_SUCCESS )
		{
		return ErrUtilRegPolyErr(errWin);
		}

	if ( ( lpbData = SAlloc( cbData ) ) == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	if ( ( errWin = RegQueryValueEx( hkey, lpszValue, 0, lpdwType, lpbData, &cbData ) ) != ERROR_SUCCESS )
		{
		SFree( lpbData );
		return ErrUtilRegPolyErr( errWin );
		}

	if ( *lpdwType == REG_EXPAND_SZ )
		{
		cbDataExpanded = ExpandEnvironmentStrings( lpbData, NULL, 0 );
		if ( ( lpbDataExpanded = SAlloc( cbDataExpanded ) ) == NULL )
			{
			SFree( lpbData );
			return ErrERRCheck( JET_errOutOfMemory );
			}

		if ( !ExpandEnvironmentStrings( lpbData, lpbDataExpanded, cbDataExpanded ) )
			{
			SFree( lpbData );
			SFree( lpbDataExpanded );
			return ErrUtilRegPolyErr( GetLastError() );
			}
		SFree( lpbData );
		*lplpbData = lpbDataExpanded;
		*lpdwType = REG_SZ;
		}
	else  /*  lpdwType != REG_EXPAND_SZ  */
		{
		*lplpbData = lpbData;
		}

	return JET_errSuccess;
	}


/*  Adds a given string to a MULTI_SZ type string.  The string is not added if it is already a
/*  member when fUnique is set.  The final size of the MULTI_SZ is the return value and the newly
/*  generated string is returned via *lplpsz.  If an error occurs, the return value will be 0 and
/*  *lplpsz will be unmodified.  If a new string is added, it is added to the head of the list.
/*
/*  The input string **lplpsz must be in SAlloc()ed memory.  The returned string will also be in
/*  SAlloc()ed memory.
/**/
ULONG UlUtilMultiSzAddSz( LPTSTR *lplpsz, LPCTSTR lpszAdd, BOOL fUnique )
	{
	LPTSTR  lpszCurrent;
	LPTSTR  lpszMatch;
	ULONG   ulSize;
	ULONG   ulAddSize;
	LPTSTR  lpszOut;
	ULONG   ulOutSize;

	/*  you must be adding a valid and non-empty string
	/**/
	Assert( lpszAdd && lstrlen( lpszAdd ) );

	/*  after this search loop, the number of chars in the MultiSz will be lpszCurrent-*lplpsz+1
	/**/
	if ( *lplpsz )
		{
		for ( lpszCurrent = *lplpsz, lpszMatch = NULL; lpszCurrent[0] != '\0'; lpszCurrent += lstrlen( lpszCurrent ) + 1 )
			if ( !lstrcmp( (LPCTSTR)lpszCurrent, lpszAdd ) )
				lpszMatch = lpszCurrent;
		ulSize = (ULONG)(( lpszCurrent + 1 ) - *lplpsz);

		if ( fUnique && lpszMatch )
			return ulSize;
		}
	else
		{
		ulSize = 0;
		}

	/*  add new string to input string to form output string and return
	/**/
	ulAddSize = lstrlen( lpszAdd ) + 1;
	ulOutSize = ulSize + ulAddSize;
	if ( !( lpszOut = SAlloc( ulOutSize ) ) )
		{
		return 0;
		}
	memcpy( lpszOut, lpszAdd, ulAddSize );
	memcpy( lpszOut + ulAddSize, *lplpsz, ulSize );
	
	SFree( *lplpsz );
	*lplpsz = lpszOut;
	return ulOutSize;
	}


/*  Removes a given string from a MULTI_SZ type string, if it exists.  The final size of
/*  the MULTI_SZ is the return value and the newly generated string is returned via *lplpsz.
/*  If an error occurs, the return value will be 0 and *lplpsz will be unmodified.
/*
/*  NOTE:  if the string to remove is not unique, the first instance will be removed
/*
/*  The input string **lplpsz must be in SAlloc()ed memory.  The returned string will also
/*  be in SAlloc()ed memory.
/**/
ULONG UlUtilMultiSzRemoveSz( LPTSTR *lplpsz, LPCTSTR lpszRemove )
	{
	LPTSTR  lpszCurrent;
	LPTSTR  lpszMatch;
	ULONG   ulSize;
	ULONG   ulRemoveSize;
	LPTSTR  lpszOut;
	ULONG   ulOutSize;

	/*  you must be removing a valid and non-empty string
	/**/
	Assert( *lplpsz && lpszRemove && lstrlen( lpszRemove ) );

	/*  after this search loop, the number of chars in the MultiSz will be lpszCurrent-*lplpsz+1
	/**/
	for ( lpszCurrent = *lplpsz, lpszMatch = NULL; lpszCurrent[0] != '\0'; lpszCurrent += lstrlen(lpszCurrent) + 1 )
		if ( !lpszMatch && !lstrcmp( (LPCTSTR)lpszCurrent, lpszRemove ) )
			lpszMatch = lpszCurrent;
	ulSize = (ULONG)(( lpszCurrent + 1 ) - *lplpsz);

	if ( !lpszMatch )
		return ulSize;

	/*  remove string from input string to form output string and return
	/**/
	ulRemoveSize = lstrlen(lpszRemove) + 1;
	ulOutSize = ulSize - ulRemoveSize;
	if ( !( lpszOut = SAlloc( ulOutSize ) ) )
		return 0;
	/*      copy first part of string (before match)
	/**/
	memcpy( lpszOut, *lplpsz, (size_t)( lpszMatch - *lplpsz ) );
	/*      copy second part of string (after match)
	/**/
	memcpy( lpszOut + ( lpszMatch - *lplpsz ),
		lpszMatch + ulRemoveSize,
		(size_t)( ( lpszCurrent + 1 ) - lpszMatch ) );
	
	SFree( *lplpsz );
	*lplpsz = lpszOut;
	return ulOutSize;
	}


#if defined( DEBUG ) || defined( PERFDUMP )

/*  GetDebugEnvValue() reads debug environment information from the registry
/*  in <hkeyHiveRoot>\DebugEnv and returns it in callee SAlloc()ed memory
/*
/*  Note that the registry can reference environment variables via the REG_EXPAND_SZ
/*  data type (expanded to REG_SZ automatically by ErrUtilRegQueryValueEx()).
/**/

static const CHAR szNull[] = "";

extern HKEY hkeyDebugEnv;

CHAR *GetDebugEnvValue( CHAR *szEnvVar )
	{
	DWORD   Type;
	LPBYTE  lpbData;

	if ( hkeyDebugEnv == (HKEY)(-1) )
		return NULL;

	/*  look for queried value in registry
	/**/
	if ( ErrUtilRegQueryValueEx( hkeyDebugEnv, szEnvVar, &Type, &lpbData ) < 0 )
		{
		(VOID)ErrUtilRegSetValueEx( hkeyDebugEnv, szEnvVar, REG_SZ, (CONST BYTE *)szNull, strlen( szNull ) + 1 );
		return NULL;
		}

	/*  if string is empty, return NULL instead of an empty string
	/**/
	if ( Type != REG_SZ || ((CHAR *)lpbData)[0] == '\0' )
		{
		SFree( lpbData );
		return NULL;
		}

	return (CHAR *)lpbData;
	}

#endif


/*=================================================================
Initialize the Registry
=================================================================*/

/*  Hive Root Key  */

HKEY hkeyHiveRoot = (HKEY)(-1);


#if defined( DEBUG ) || defined( PERFDUMP )

/*  DebugEnv Key  */

HKEY hkeyDebugEnv = (HKEY)(-1);

/*  Debug Environment values with non-NULL default values  */

static const CHAR rgrgszDebugEnvDefaults[][2][32] =
	{
	{ "JETUseEnv",          "on" },         /*  JET use Debug Environment  */
	{ "",                   "" },           /*  <EOL>  */
	};

#endif

#ifdef RFS2

/*  RFS2 Key  */
	
HKEY hkeyRFS2 = (HKEY)(-1);

/*  RFS2 Options Text  */

static const CHAR szDisableRFS[]                = "Disable RFS";
static const CHAR szLogJETCall[]                = "Enable JET Call Logging";
static const CHAR szLogRFS[]                    = "Enable RFS Logging";
static const CHAR szRFSAlloc[]                  = "RFS Allocations (-1 to allow all)";
static const CHAR szRFSIO[]                     = "RFS IOs (-1 to allow all)";

/*  RFS2 Defaults  */

static const DWORD_PTR rgrgdwRFS2Defaults[][2] =
	{
	(DWORD_PTR)szDisableRFS,            0x00000001,             /*  Disable RFS  */
	(DWORD_PTR)szLogJETCall,            0x00000000,             /*  Disable JET call logging  */
	(DWORD_PTR)szLogRFS,                0x00000000,             /*  Disable RFS logging  */
	(DWORD_PTR)szRFSAlloc,              0xffffffff,             /*  Allow ALL RFS allocations  */
	(DWORD_PTR)szRFSIO,                 0xffffffff,             /*  Allow ALL RFS IOs  */
	(DWORD_PTR)NULL,                    0x00000000,             /*  <EOL>  */
	};

#endif  /* RFS2 */

static const CHAR szAlwaysInit[]        = "Always Init";
static const CHAR szUpdating[]          = "Updating...";


#if defined( DEBUG ) || defined( PERFDUMP ) || defined( RFS2 )

static ERR ErrUtilRegInitEDBKeys( BOOL fSetDefaults )
	{
	ERR		err;
	DWORD	Disposition;
	DWORD	Type;
	LPBYTE	lpbData = NULL;
	INT		iDefault;

#if defined( DEBUG ) || defined( PERFDUMP )
	/*  Initialize Registry for the Debug Environment
	/*
	/*  Our DebugEnv key is "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\EDB\DebugEnv"
	/**/
	if ( ( err = ErrUtilRegOpenKeyEx( hkeyHiveRoot,
		"DebugEnv",
		&hkeyDebugEnv ) ) < 0 )
		{
		if ( ( err = ErrUtilRegCreateKeyEx( hkeyHiveRoot,
			"DebugEnv",
			&hkeyDebugEnv,
			&Disposition ) ) < 0 )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		fSetDefaults = fTrue;		// Key had to be created.  Force regeneration of defaults.
		}

	if ( fSetDefaults )
		{
		/*  set all the default values, if not previously set
		/**/
		for ( iDefault = 0; rgrgszDebugEnvDefaults[iDefault][0][0] != '\0'; iDefault++ )
			{
			err = ErrUtilRegQueryValueEx( hkeyDebugEnv, (LPTSTR)rgrgszDebugEnvDefaults[iDefault][0], &Type, &lpbData );
			if ( err < 0 || Type != REG_SZ )
				{
				if ( lpbData )
					SFree( lpbData );
				if ( ( err = ErrUtilRegSetValueEx(
						hkeyDebugEnv,
						rgrgszDebugEnvDefaults[iDefault][0],
						REG_SZ,
						(CONST BYTE *)rgrgszDebugEnvDefaults[iDefault][1],
						strlen(rgrgszDebugEnvDefaults[iDefault][1])+1 ) ) < 0 )
					goto HandleError;
				}
			else
				{
				SFree( lpbData );
				}
			}
		}

	/*  leave hkeyDebugEnv key open
	/**/
#endif

#ifdef RFS2
	/*  Initialize Registry for RFS2 Testing
	/*
	/*  Our RFS2 key is "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\EDB\RFS2"
	/**/

	if ( ( err = ErrUtilRegOpenKeyEx( hkeyHiveRoot, "RFS2", &hkeyRFS2 ) ) < 0 )
		{
		if ( ( err = ErrUtilRegCreateKeyEx( hkeyHiveRoot,
			"RFS2",
			&hkeyRFS2,
			&Disposition ) ) < 0 )
			{
			/*      return error since RFS enabled and will not be tested
			/*      for lack of registry privlages.
			/**/
			goto HandleError;
			}
		fSetDefaults = fTrue;		// Key had to be created.  Force regeneration of defaults.
		}


	if ( fSetDefaults )
		{
		/*  set all the default values, if not previously set
		/**/
		for ( iDefault = 0; rgrgdwRFS2Defaults[iDefault][0] != 0; iDefault++ )
			{
			lpbData = NULL;
			err = ErrUtilRegQueryValueEx( hkeyRFS2, (LPTSTR)rgrgdwRFS2Defaults[iDefault][0], &Type, &lpbData );
			if ( err < 0 || Type != REG_DWORD )
				{
				if ( lpbData )
					{
					SFree( lpbData );
					}
				if ( ( err = ErrUtilRegSetValueEx(
					hkeyRFS2,
					(LPTSTR)rgrgdwRFS2Defaults[iDefault][0],
					REG_DWORD,
					(CONST BYTE *)(rgrgdwRFS2Defaults[iDefault]+1),
					sizeof(DWORD) ) ) < 0 )
					{
					goto HandleError;
					}
				}
			else
				{
				SFree( lpbData );
				}
			}
		}

	/*  leave hkeyRFS2 key open
	/**/

#endif  /*  RFS2  */

HandleError:
	return err;
	}

#endif



/*  Registry init function  */

ERR ErrUtilRegInit(void)
	{
	JET_ERR         err = JET_errSuccess;
	JET_ERR			errT = JET_errSuccess;
	DWORD           Disposition;
	char            szVersion[32];
	DWORD           Type;
	LPBYTE          lpbData = NULL;
	HKEY            hkeyEventLog = (HKEY)(-1);
	HKEY            hkeyEventLogAppRoot = (HKEY)(-1);
	DWORD           Data;
	ULONG           ulSize;

	/*  Initialize Registry for Event Logging
	/*
	/*  We _always_ do this to make sure that the path to our DLL is valid.
	/*
	/*  Our EventLog key is "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Application\EDB"
	/**/

	/*  install our key in the Application hive
	/**/
	if ( ( err = ErrUtilRegOpenKeyEx( HKEY_LOCAL_MACHINE,
		"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" szVerName,
		&hkeyEventLog ) ) < 0 )
		{
		err = ErrUtilRegCreateKeyEx(
					HKEY_LOCAL_MACHINE,
					"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" szVerName,
					&hkeyEventLog,
					&Disposition );
		}

	if ( err < 0 )
		{
		goto CloseEventLog;
		}
		
	errT = ErrUtilRegSetValueEx(
				hkeyEventLog,
				"EventMessageFile",
				REG_EXPAND_SZ,
				(CONST BYTE *)&szDLLFile,
				strlen(szDLLFile)+1 );
	err = errT < 0 && err >= 0 ? errT : err;
		
	errT = ErrUtilRegSetValueEx(
				hkeyEventLog,
				"CategoryMessageFile",
				REG_EXPAND_SZ,
				(CONST BYTE *)&szDLLFile,
				strlen(szDLLFile)+1 );
	err = errT < 0 && err >= 0 ? errT : err;

	Data = MAC_CATEGORY-1;
	errT = ErrUtilRegSetValueEx(
				hkeyEventLog,
				"CategoryCount",
				REG_DWORD,
				(CONST BYTE *)&Data,
				sizeof(DWORD) );
	err = errT < 0 && err >= 0 ? errT : err;

	Data = EVENTLOG_INFORMATION_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
	errT = ErrUtilRegSetValueEx(
				hkeyEventLog,
				"TypesSupported",
				REG_DWORD,
				(CONST BYTE *)&Data,
				sizeof(DWORD) );
	err = errT < 0 && err >= 0 ? errT : err;

CloseEventLog:
	errT = ErrUtilRegCloseKeyEx(hkeyEventLog);
	hkeyEventLog = (HKEY)(-1);

	/*  add EDB as an event source in ...\Application's value Sources
	/**/
	errT = ErrUtilRegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application",
				&hkeyEventLogAppRoot );
	err = errT < 0 && err >= 0 ? errT : err;

	if ( errT < 0 )
		{
		goto CloseEventLogAppRoot;
		}
	
	errT = ErrUtilRegQueryValueEx( hkeyEventLogAppRoot, "Sources", &Type, &lpbData );
	err = errT < 0 && err >= 0 ? errT : err;

	if ( errT < 0 || Type != REG_MULTI_SZ )
		{
		goto CloseEventLogAppRoot;
		}

	if ( !( ulSize = UlUtilMultiSzAddSz( &lpbData, szVerName, 1 ) ) )
		{
		goto CloseEventLogAppRoot;
		}

	errT = ErrUtilRegSetValueEx(
				hkeyEventLogAppRoot,
				"Sources",
				REG_MULTI_SZ,
				(CONST BYTE *)lpbData, ulSize );
	err = errT < 0 && err >= 0 ? errT : err;
	
CloseEventLogAppRoot:
	if ( lpbData )
		{
		SFree( lpbData );
		lpbData = NULL;
		}
	(VOID)ErrUtilRegCloseKeyEx( hkeyEventLogAppRoot );
	hkeyEventLogAppRoot = (HKEY)(-1);


	/*  open our root key in the registry, and create it if
	/*  it does not already exist
	/**/
	if ( ( errT = ErrUtilRegOpenKeyEx( HKEY_LOCAL_MACHINE,
		"SOFTWARE\\Microsoft\\" szVerName,
		&hkeyHiveRoot ) ) < 0 )
		{
		if ( ( errT = ErrUtilRegCreateKeyEx( HKEY_LOCAL_MACHINE,
			"SOFTWARE\\Microsoft\\" szVerName,
			&hkeyHiveRoot,
			&Disposition ) ) < 0 )
			{
			/*      if registry not set, and cannot create registry,
			/*      then return success
			/**/
			err = errT < 0 && err >= 0 ? errT : err;
			goto HandleError;
			}
		}

	/*  Get version.
	/*      If it is equal to the current DLL version, the registry is already initialized.
	/*  If Version == "Always Init", we will ALWAYS initialize the registry.
	/**/
	sprintf( szVersion, "%4g.%02g.%04g", (double)(rmj), (double)(rmm), (double)(rup) );
	err = ErrUtilRegQueryValueEx(hkeyHiveRoot,"Version",&Type,&lpbData);
	if ( err >= 0 &&
		Type == REG_SZ && !lstrcmp( (LPCTSTR)lpbData, (LPCTSTR)szVersion ) &&
		lstrcmp( (LPCTSTR)lpbData, (LPCTSTR)szAlwaysInit ) )
		{
		if ( lpbData )
			{
			SFree( lpbData );
			lpbData = NULL;
			}

		/*  open all keys needed during operation
		/**/
#if defined( DEBUG ) || defined( PERFDUMP ) || defined( RFS2 )
		if ( ( err = ErrUtilRegInitEDBKeys( fFalse ) ) < 0 )
			{
			goto HandleError;
			}
#endif

		}
	
	else
		{
		if ( lpbData )
			{
			if ( !lstrcmp((LPCTSTR)lpbData, (LPCTSTR)szAlwaysInit ) )
				{
				lstrcpy((LPTSTR)szVersion,(LPCTSTR)szAlwaysInit);
				}

			SFree( lpbData );
			lpbData = NULL;
			}

		/*  set Version to "Updating..." to indicate that we are updating registry information.  If our init
		/*  fails, another version will see that Version is Updating and will attempt to reinitialize the registry,
		/*  avoiding partial init problems.  Do not set to Updating if Version is "Always Init", where it will force
		/*  another version to reinit anyway.
		/**/
		if ( lstrcmp( (LPCTSTR)szVersion, (LPCTSTR)szAlwaysInit ) )
			{
			if ( ( err = ErrUtilRegSetValueEx( hkeyHiveRoot, "Version", REG_SZ, (CONST BYTE *)szUpdating, lstrlen(szUpdating) ) ) < 0 )
				goto HandleError;
			}

		/*      leave hkeyHiveRoot key open
		/**/

		/**/
		/*  If we are here, either the info in the registry is old, or a previous attempt to initialize the
		/*  registry failed.  We will now initialize the registry, waiting to set the Version value LAST.
		/*  This way, if the init fails in any way, we will get a chance to do it again later.
		/*
		/*  NOTE:  if we fail, we must UNDO any changes we make to other applications' keys in order to ensure
		/*  that they do not crash due to a partial update of their hives.  We will also remove our own hive on
		/*  an error so that a bad install won't corrupt the behavior of an older version of the DLL running
		/*  immediately after our failure.
		/**/
#if defined( DEBUG ) || defined( PERFDUMP ) || defined( RFS2 )
		if ( ( err = ErrUtilRegInitEDBKeys( fTrue ) ) < 0 )
			{
			goto HandleError;
			}
#endif

		/*  we've made it through all our initializations, so attempt to update the Version value in our root
		/*  hive key.  Note that if this fails, we still need to redo init at a later time.
		/*
		/*  Note that if Version was "Always Init", do not update it
		/**/
		if ( lstrcmp((LPCTSTR)szVersion, (LPCTSTR)szAlwaysInit ) )
			{
			if ( ( err = ErrUtilRegSetValueEx( hkeyHiveRoot, "Version",REG_SZ, (CONST BYTE *)szVersion, lstrlen(szVersion) + 1 ) ) < 0 )
				{
				goto HandleError;
				}
			}
		}

HandleError:
	/*      read our configuration from the registry and return
	/**/
	errT = ErrUtilRegReadConfig();
	if ( err >= 0 )
		{
		return errT;
		}

	/*  we failed to init the registry, so return EVERYTHING to the way it was as much as possible
	/**/

	/*      if error is permission denied, then return JET_errSuccess
	/**/
	if ( err == JET_errPermissionDenied )
		err = JET_errSuccess;

#ifdef RFS2
	/*  close RFS2 key
	/**/
	if ( hkeyRFS2 != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx(hkeyRFS2);
		hkeyRFS2 = (HKEY)(-1);
		}
#endif  /*  RFS2  */

#if defined( DEBUG ) || defined( PERFDUMP )
	/*  close DebugEnv key
	/**/
	if ( hkeyDebugEnv != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx(hkeyDebugEnv);
		hkeyDebugEnv = (HKEY)(-1);
		}
#endif

	/*  close EventLogAppRoot key
	/**/
	if ( hkeyEventLogAppRoot != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyEventLogAppRoot );
		hkeyEventLogAppRoot = (HKEY)(-1);
		}
	
	/*  close and delete EventLog key
	/**/
	if ( hkeyEventLog != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyEventLog );
		hkeyEventLog = (HKEY)(-1);
		}
	(VOID)ErrUtilRegDeleteKeyEx( HKEY_LOCAL_MACHINE,
		"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" szVerName );
	//      UNDONE:  remove EDB from Sources value?

	/*  close root hive
	/**/
	if ( hkeyHiveRoot != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyHiveRoot );
		hkeyHiveRoot = (HKEY)(-1);
		}
	
	return err;
	}

	
/*  Read all configuration info from the registry
/**/

#ifdef RFS2

DWORD  fDisableRFS		= 0x00000001;
DWORD  fAuxDisableRFS	= 0x00000000;
DWORD  fLogJETCall		= 0x00000000;
DWORD  fLogRFS			= 0x00000000;
DWORD  cRFSAlloc		= 0xffffffff;
DWORD  cRFSIO			= 0xffffffff;

#endif /* RFS2 */

ERR ErrUtilRegReadConfig( VOID )
	{
#ifdef DEBUG
	char    *sz;
#endif  //  DEBUG
#ifdef RFS2
	ERR		err;
	DWORD   Type;
	LPBYTE  lpbData;
	char    szT[2][128];
	LPCTSTR	rgszT[8];
	BOOL	fSysParamSet;
#endif

#ifdef DEBUG
	/*  Get Assert Action from registry.  If Assert Action is a null string, no change is made
	/*  to the wAssertAction default assigned in INITTERM.C.
	/**/
	if ( ( sz = GetDebugEnvValue( "Assert Action" ) ) != NULL )
		{
		wAssertAction = atol( sz );
		SFree( sz );
		}
#endif

#ifdef RFS2
	/*  remember if the RFS2 system parameters were set
	/**/
	fSysParamSet = !fDisableRFS;
	
	/*	read RFS2 options from registry
	/**/
	if ( !fSysParamSet )
		{	
		if ( ( err = ErrUtilRegQueryValueEx( hkeyRFS2, (char *)szDisableRFS, &Type, &lpbData ) ) < 0 )
			return err;
		else
			{
			fDisableRFS = *( (DWORD *)lpbData );
			SFree( lpbData );
			}
		}

	if ( ( err = ErrUtilRegQueryValueEx( hkeyRFS2, (char *)szLogJETCall, &Type, &lpbData ) ) < 0 )
		return err;
	else
		{
		fLogJETCall = *( (DWORD *)lpbData );
		SFree( lpbData );
		}
		
	if ( ( err = ErrUtilRegQueryValueEx( hkeyRFS2, (char *)szLogRFS, &Type, &lpbData ) ) < 0 )
		return err;
	else
		{
		fLogRFS = *((DWORD *)lpbData );
		SFree( lpbData );
		}

	if ( !fSysParamSet )
		{	
		if ( ( err = ErrUtilRegQueryValueEx( hkeyRFS2, (char *)szRFSAlloc, &Type, &lpbData ) ) < 0 )
			return err;
		else
			{
			cRFSAlloc = *( (DWORD *)lpbData );
			SFree( lpbData );
			}

		if ( ( err = ErrUtilRegQueryValueEx( hkeyRFS2, (char *)szRFSIO, &Type, &lpbData ) ) < 0 )
			return err;
		else
			{
			cRFSIO = *( (DWORD *)lpbData );
			SFree( lpbData );
			}
		}

	if ( !fDisableRFS )
		{
		rgszT[0] = szDisableRFS;
		rgszT[1] = ( fDisableRFS ? "yes" : "no" );
		rgszT[2] = szLogJETCall;
		rgszT[3] = ( fLogJETCall ? "yes" : "no" );
		rgszT[4] = szLogRFS;
		rgszT[5] = ( fLogRFS ? "yes" : "no" );
		sprintf( szT[0], "%s:    %ld", szRFSAlloc, cRFSAlloc );
		rgszT[6] = szT[0];
		sprintf( szT[1], "%s:    %ld", szRFSIO, cRFSIO );
		rgszT[7] = szT[1];
		
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, RFS2_CATEGORY, RFS2_INIT_ID, 8, rgszT );
		}
#endif

	return JET_errSuccess;
	}


/*	registry termination
/**/
void UtilRegTerm( void )
	{
	/*  close our keys in the registry
	/**/
#ifdef RFS2
	if ( hkeyRFS2 != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyRFS2 );
		}
#endif
#if defined( DEBUG ) || defined( PERFDUMP )
	if ( hkeyDebugEnv != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyDebugEnv );
		}
#endif
	if ( hkeyHiveRoot != (HKEY)(-1) )
		{
		(VOID)ErrUtilRegCloseKeyEx( hkeyHiveRoot );
		}

	return;
	}


CODECONST(char) szReleaseHdr[] = "Rel. ";
CODECONST(char) szFileHdr[] = ", File ";
CODECONST(char) szLineHdr[] = ", Line ";
CODECONST(char) szErrorHdr[] = ", Err. ";
CODECONST(char) szMsgHdr[] = ": ";
CODECONST(char) szPidHdr[] = "PID: ";
CODECONST(char) szTidHdr[] = ", TID: ";
CODECONST(char) szNewLine[] = "\r\n";

CODECONST(char) szAssertFile[] = "assert.txt";
CODECONST(char) szAssertHdr[] = "Assertion Failure: ";

CODECONST(char) szAssertCaption[] = "JET Assertion Failure";

int fNoWriteAssertEvent = 0;

/*  Event Logging
/**/

extern char szEventSource[];

HANDLE hEventSource = NULL;

VOID UtilReportEvent( WORD fwEventType, WORD fwCategory, DWORD IDEvent, WORD cStrings, LPCTSTR *plpszStrings )
	{
	char	*rgsz[16];
	int 	pid = HandleToUlong(UtilGetCurrentTask());
	char	szT[10];

    Assert( fwCategory < MAC_CATEGORY );
	Assert( cStrings < 14 );

	rgsz[0] = szEventSource;

	/*	process id
	/**/
	sprintf( szT, "(%d) ", pid );
	rgsz[1] = szT;

    if (plpszStrings != NULL)
	    memcpy( &rgsz[2], plpszStrings, sizeof(char *) * cStrings );
	
	/*	write to our event log first, if it has been opened
	/**/
	if ( hEventSource )
		{
		(void)ReportEvent(
			hEventSource,
			fwEventType,
			fwCategory,
			IDEvent,
			0,
			(WORD)(cStrings + 2),
			0,
			rgsz,
			0 );
		}

	return;
	}


/*	reports error event in the context of a category and optionally
/*	in the context of a IDEvent.  If IDEvent is 0, then an IDEvent
/*	is chosen based on error code.  If IDEvent is !0, then the
/*	appropriate event is reported.
/**/
VOID UtilReportEventOfError( WORD fwCategory, DWORD IDEvent, ERR err )
	{
	BYTE	szT[16];
	char	*rgszT[1];

	if ( IDEvent == 0 )
		{
		switch ( err )
			{
			default:
				sprintf( szT, "%d", err );
				rgszT[0] = szT;
				UtilReportEvent( EVENTLOG_ERROR_TYPE, fwCategory, IDEvent, 1, rgszT );
				break;
			case JET_errDiskFull:
				UtilReportEvent( EVENTLOG_ERROR_TYPE, fwCategory, DISK_FULL_ERROR_ID, 0, NULL );
				break;
			}
		}
	else
		{
		sprintf( szT, "%d", err );
		rgszT[0] = szT;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, fwCategory, IDEvent, 1, rgszT );
		}

	return;
	}


#ifndef RETAIL

/*      write assert to assert.txt
/*      may raise alert
/*      may log to event log
/*      may pop up
/*
/*      condition parameters
/*      assemble monolithic string for assert.txt,
/*              alert and event log
/*      assemble separated string for pop up
/*
/**/
void AssertFail( const char *sz, const char *szFilename, unsigned Line )
	{
	int                     hf;
	char            szT[45];
	char            szMessage[512];
	int                     id;
	const char      *pch;
	DWORD           dw;

	/*      get last error before another system call
	/**/
	dw = GetLastError();

	/*      select file name from file path
	/**/
	for ( pch = szFilename; *pch; pch++ )
		{
		if ( *pch == '\\' )
			szFilename = pch + 1;
		}

	/*      assemble monolithic assert string
	/**/
	szMessage[0] = '\0';
	lstrcat( szMessage, (LPSTR) szAssertHdr );
	lstrcat( szMessage, (LPSTR) szReleaseHdr );
	/*      copy version number to message
	/**/
	_ltoa( rmm, szT, 10 );
	lstrcat( szMessage, (LPSTR) szT );
	lstrcat( szMessage, "." );
	_ltoa( rup, szT, 10 );
	lstrcat( szMessage, (LPSTR) szT );
	/*      file name
	/**/
	lstrcat( szMessage, (LPSTR) szFileHdr );
	lstrcat( szMessage, (LPSTR) szFilename );
	/*      convert line number to ASCII
	/**/
	lstrcat( szMessage, (LPSTR) szLineHdr );
	_ultoa( Line, szT, 10 );
	lstrcat( szMessage, szT );
	lstrcat( szMessage, (LPSTR) szMsgHdr );
	lstrcat( szMessage, (LPSTR)sz );
	lstrcat( szMessage, szNewLine );

	/******************************************************
	/*      write assert to assert.txt
	/**/
	hf = _lopen( (LPSTR) szAssertFile, OF_READWRITE );
	/*      if open failed, assume no such file and create, then
	/*      seek to end of file.
	/**/
	if ( hf == -1 )
		hf = _lcreat( (LPSTR)szAssertFile, 0 );
	else
		_llseek( hf, 0, 2 );
	_lwrite( hf, (LPSTR)szMessage, lstrlen(szMessage) );
	_lclose( hf );
	/******************************************************
	/**/

	/*      if event log environment variable set then write
	/*      assertion to event log.
	/**/
	if ( !fNoWriteAssertEvent )
		{
		char *rgszT[1];
		
		rgszT[0] = szMessage;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
		}

	if ( wAssertAction == JET_AssertExit )
		{
		FatalExit( 0x68636952 );
		}
	else if ( wAssertAction == JET_AssertBreak )
		{
		DebugBreak();
		}
	else if ( wAssertAction == JET_AssertStop )
		{
		for( ;; )
			{
			/*	wait for developer, or anyone else, to debug the failure
			/**/
			Sleep( 100 );
			}
		}
	else if ( wAssertAction == JET_AssertMsgBox )
		{
		int 	pid = HandleToUlong(UtilGetCurrentTask());
		int		tid = DwUtilGetCurrentThreadId();

		/*	assemble monolithic assert string
		/**/
		szMessage[0] = '\0';
		/*	copy version number to message
		/**/
		lstrcat( szMessage, (LPSTR) szReleaseHdr );
		_ltoa( rmm, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		lstrcat( szMessage, "." );
		_ltoa( rup, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		/*      file name
		/**/
		lstrcat( szMessage, (LPSTR) szFileHdr );
		lstrcat( szMessage, (LPSTR) szFilename );
		/*      line number
		/**/
		lstrcat( szMessage, (LPSTR) szLineHdr );
		_ultoa( Line, szT, 10 );
		lstrcat( szMessage, szT );
		/*      error
		/**/
		if ( dw && dw != ERROR_IO_PENDING )
			{
			lstrcat( szMessage, szErrorHdr );
			_ltoa( dw, szT, 10 );
			lstrcat( szMessage, szT );
			}
		lstrcat( szMessage, (LPSTR) szNewLine );
		/*      assert txt
		/**/
		lstrcat( szMessage, (LPSTR) sz );
		lstrcat( szMessage, (LPSTR) szNewLine );

		/*	process and thread id
		/**/
		lstrcat( szMessage, szPidHdr );
		_ultoa( pid, szT, 10 );
		lstrcat( szMessage, szT );
		lstrcat( szMessage, szTidHdr );
		_ultoa( tid, szT, 10 );
		lstrcat( szMessage, szT );

		id = MessageBox( NULL, (LPTSTR) szMessage, (LPTSTR) szAssertCaption, MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL );
		if ( id == IDCANCEL )
			DebugBreak();
		}

	return;
	}


CODECONST(char) szFmtHeader[] = "JET(%08X): ";


void VARARG DebugWriteString(BOOL fHeader, const char  *szFormat, ...)
	{
	va_list         val;
	char            szOutput[1024];
	int                     cch;

	unsigned wTaskId;

	wTaskId = DwUtilGetCurrentThreadId();

	/*      prefix message with JET and process id
	/**/
	if ( fHeader )
		wsprintf(szOutput, (LPSTR) szFmtHeader, wTaskId);
	else
		cch = 0;

	va_start(val, szFormat);
	wvsprintf(szOutput+cch, (LPSTR) szFormat, val);
	OutputDebugString((LPTSTR) szOutput);
	va_end(val);
	}

#endif  /* !RETAIL */


void UtilCloseSignal(void *pv)
	{
	BOOL f;

	HANDLE h = pv;
	f = CloseHandle( h );
#ifdef DEBUG
	if ( !f )
		{
		DWORD dw = GetLastError();
		Assert( f == fTrue );
		}
#endif
	Assert( f == fTrue );
	}


void UtilCloseSemaphore( SEM sem )
	{
	BOOL f;

	HANDLE h = sem;
	f = CloseHandle( h );
#ifdef DEBUG
	if ( !f )
		{
		DWORD dw = GetLastError();
		Assert( f == fTrue );
		}
#endif
	Assert( f == fTrue );
	}


#ifdef SPIN_LOCK

/****************** DO NOT CHANGE BETWEEN THESE LINES **********************/
/******************** copied from \dae\inc\spinlock.h **********************/

#ifdef DEBUG
void    free_spinlock(long volatile *);
#else
#define free_spinlock(a)    *((long*)a) = 0 ;
#endif

int get_spinlockfn(long volatile *plLock, int fNoWait);

/*
** When /Ogb1 or /Ogb2 flag is used in the compiler, this function will
** be expanded in line
*/
__inline    int     get_spinlock(long volatile *plock, int b)
{
#ifdef _X86_
	_asm    // Use bit test and set instruction
	{
	    mov eax, plock
	    lock bts [eax], 0x0
	    jc  bsy     // If already set go to busy, otherwise return TRUE
	} ;

#else
	if (InterlockedExchange(plock, 1) == 0)
#endif
	{
		return(fTrue);
	}
bsy:
		return(get_spinlockfn(plock, b));
}

/******************** copied from \dae\src\spinlock.c **********************/

/*
**  get_spinlock(&addr, nowait) -- Obtains an SMP safe lock on the address
**      given. The contents of the address must be initialized to -1.
**      The address must be a dword boundary otherwise Interlocked
**      functions are not SMP safe.
**      nowait parameter specifies if it should wait and retry or return
**      WARNING: Does not release any semaphore or critsec when waiting.
**
**      WARNING: Spinlocks are not reentrant
**
**  Created 04/20/93 by LaleD
*/

/* function copied from SQL server */
#define lSpinCtr 30

int get_spinlockfn(long volatile *plLock, int fNoWait)
{
    int i,n=0;
    int m = 0;
	int cms = 1;

#ifdef DEBUG
    if ((int)(plLock) & 0x3)
	AssertSz(0, "\nError: get_spinlock:Spinlock address isn't aligned\n");
#endif


startover:

#ifdef _X86_
	_asm    // Use bit test and set instruction
	{
	    mov eax, plLock
	    lock bts [eax], 0x0
	    jc  busy    // If already set go to busy, otherwise return TRUE
	} ;

#else
	if (InterlockedExchange(plLock, 1) == 0)
#endif

	{
	    return (fTrue);
	}
busy:
	if (fNoWait)
	    return(fFalse);

	/* Spin in place for a while and then try again */
	for (i = 0 ; i < lSpinCtr ; i++,n++)
	{
	    if (*plLock == 0)
		goto startover;
	}

	/* We tried spinning SPINCTR times, it was busy each time.
	** Need to yield here
	*/

	/* The number below (used to compare m) should be the
	 * max number of threads with critical priority.
	 */
	if (m++ > 10)
	{
		if (cms < 10000)
			cms <<= 1;
#if 0
		else
			/* Sleep for 10 sec's at a time. We may be stuck in an uncleared
			** spinlock. Better to sleep than hog the cpu, and also flag
			** the condition.
			*/
			AssertSz(0, "\nget_spinlock stuck in loop.");
#endif

	    // NOTE: Something is very wrong if you got here. Most likely
	    // somebody forgot to release the spinlock. Put your customized
	    // backout/ error out code here.

		m = 0;
	    Sleep(cms - 1);

	}
	else
	    /* We sleep with a 0 time which is equivalent to a yield*/
	    Sleep(cms - 1);

	goto startover;
	/* try again */

}

/* This function becomes a simple mov instruction in the
** nondebug case (defined inside ksrc_dcl.h)
*/

/*
**  free_spinlock((long *)plock) -- Releases the spinlock, wakes up anybody
**      waiting on it.
**
**  WARNING: This is implemented as a macro defined in ksrc_dcl.h
*/
#ifdef DEBUG

void    free_spinlock(long volatile *plLock)
{

#ifdef _X86_
	// This part of the code will only be used if we want to debug
	// something and turn free_spinlock back to a function to put a
	// breakpoint
	_asm    // Use bit test and set instruction
	{
	    mov eax, plLock
	    lock btr [eax], 0x0
	    jc  wasset  // If was set go to end, otherwise print error
	}
	AssertSz(0, "\nfree_spinlock: spinlock wasn't taken\n");
wasset:
	 ;
#else
	if(InterlockedExchange(plLock, 0) != 1)
	{
	    AssertSz(0, "\nfree_spinlock counter 0x%x\n", (*plLock));
	    *plLock = 0;
	}
#endif

}

#endif

/***************************** end of copy *********************************/
/****************** DO NOT CHANGE BETWEEN THESE LINES **********************/


/*      SPIN_LOCK critical section
/**/
typedef struct
	{
#ifdef DEBUG
	volatile        unsigned int    cHold;
#endif
	volatile        long                    l;
	volatile        unsigned int    tidOwner; /* used by both nestable CS & dbg */
	volatile        int                             cNested;
	} CRITICALSECTION;

#ifdef DEBUG
CRITICALSECTION csNestable = { 0, 0, 0, 0 };
#else
CRITICALSECTION csNestable = { 0, 0, 0 };
#endif


ERR ErrUtilInitializeCriticalSection( void  *  *ppv )
	{
	*ppv = SAlloc(sizeof(CRITICALSECTION));
	if ( *ppv == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
#ifdef DEBUG
	((CRITICALSECTION *)*ppv)->cHold = 0;
#endif
	((CRITICALSECTION *)*ppv)->tidOwner = 0;
	((CRITICALSECTION *)*ppv)->cNested = 0;
	((CRITICALSECTION *)*ppv)->l = 0;
	return JET_errSuccess;
	}


void UtilDeleteCriticalSection( void  * pv )
	{
	CRITICALSECTION *pcs = pv;
	
	Assert( pcs != NULL );
	Assert( pcs->cHold == 0);
	SFree(pcs);
	}


void UtilEnterCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	(void) get_spinlock( &pcs->l, fFalse );
#ifdef DEBUG
	pcs->tidOwner = DwUtilGetCurrentThreadId();
	pcs->cNested++;
	Assert( pcs->cNested == 1 );
#endif
	}


void UtilLeaveCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

#ifdef DEBUG
	Assert( pcs->cHold == 0 );
	if ( --pcs->cNested == 0 )
		pcs->tidOwner = 0;
#endif
	free_spinlock( &pcs->l );
	}


#ifdef DEBUG
PUBLIC void UtilHoldCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	pcs->cHold++;
	Assert( pcs->cHold );
	return;
	}


PUBLIC void UtilReleaseCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->cHold );
	pcs->cHold--;
	return;
	}

			
#undef UtilAssertCrit
PUBLIC void UtilAssertCrit(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->l != 0 );
	Assert( pcs->tidOwner == DwUtilGetCurrentThreadId() );
	Assert( pcs->cNested > 0 );
	return;
	}

			
#undef UtilAssertNotInCrit
PUBLIC void UtilAssertNotInCrit(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( !pcs->l || !pcs->cNested || pcs->tidOwner != DwUtilGetCurrentThreadId() );
	return;
	}
#endif


void UtilEnterNestableCriticalSection(void  *pv)
	{
	BOOL                            fCallerOwnIt = fFalse;
	CRITICALSECTION         *pcs = pv;
	unsigned int            tid = DwUtilGetCurrentThreadId();
	
	UtilEnterCriticalSection( &csNestable );
	/* must check cs contents within csNestable protection
	/**/
	if (pcs->cNested > 0 && pcs->tidOwner == tid)
		{
		fCallerOwnIt = fTrue;
		pcs->cNested++;
		}
	UtilLeaveCriticalSection( &csNestable );
	
	if (fCallerOwnIt)
		return;

	(void) get_spinlock( &pcs->l, fFalse );
	Assert( pcs->cNested == 0 );
	pcs->tidOwner = DwUtilGetCurrentThreadId();
	pcs->cNested++;
	}


void UtilLeaveNestableCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	if ( --pcs->cNested == 0 )
		{
		pcs->tidOwner = 0;
		free_spinlock( &pcs->l );
		}
	else
		{
		Assert( pcs->cNested > 0 );
		return;
		}
	}

#else /* !SPIN_LOCK */
#ifdef DEBUG

/*      !SPIN_LOCK critical section
/**/
typedef struct
	{
	volatile        unsigned int                            tidOwner;
	volatile        int                                                     cNested;
	volatile        unsigned int                            cHold;
	volatile        RTL_CRITICAL_SECTION            rcs;
	} CRITICALSECTION;

ERR ErrUtilInitializeCriticalSection( void  *  *ppv )
	{
	*ppv = SAlloc(sizeof(CRITICALSECTION));
	if ( *ppv == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	((CRITICALSECTION *)*ppv)->tidOwner = 0;
	((CRITICALSECTION *)*ppv)->cNested = 0;
	((CRITICALSECTION *)*ppv)->cHold = 0;
	InitializeCriticalSection( (LPCRITICAL_SECTION)&((CRITICALSECTION *)(*ppv))->rcs );
	return JET_errSuccess;
	}


void UtilDeleteCriticalSection( void  * pv )
	{
	CRITICALSECTION *pcs = pv;
	
	Assert( pcs->cHold == 0 );
	Assert( pcs != NULL );
	DeleteCriticalSection( (LPCRITICAL_SECTION)&pcs->rcs );
	SFree(pv);
	}


void UtilEnterCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;
	
	EnterCriticalSection( (LPCRITICAL_SECTION)&pcs->rcs);
	pcs->tidOwner = DwUtilGetCurrentThreadId();
	pcs->cNested++;
	Assert( pcs->cNested == 1 );
	}


void UtilLeaveCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->cHold == 0);
	Assert( pcs->cNested > 0 );
	if ( --pcs->cNested == 0 )
		pcs->tidOwner = 0;
	LeaveCriticalSection((LPCRITICAL_SECTION)&pcs->rcs);
	}


void UtilEnterNestableCriticalSection(void  *pv)
	{
	CRITICALSECTION         *pcs = pv;
	unsigned int            tid = DwUtilGetCurrentThreadId();
	
	EnterCriticalSection( (LPCRITICAL_SECTION)&pcs->rcs);

	Assert( pcs->cNested == 0 || pcs->tidOwner == tid );
	pcs->tidOwner = tid;
	pcs->cNested++;
	}


void UtilLeaveNestableCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	--pcs->cNested;
	if ( pcs->cNested == 0 )
		{
		pcs->tidOwner = 0;
		}
	else
		{
		Assert( pcs->cNested > 0 );
		}
	LeaveCriticalSection((LPCRITICAL_SECTION)&pcs->rcs);
	}

void UtilHoldCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	pcs->cHold++;
	Assert( pcs->cHold );
	return;
	}


void UtilReleaseCriticalSection(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->cHold );
	pcs->cHold--;
	return;
	}

			
#undef UtilAssertCrit
PUBLIC void UtilAssertCrit(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->tidOwner == DwUtilGetCurrentThreadId() );
	Assert( pcs->cNested > 0 );
	return;
	}

			
#undef UtilAssertNotInCrit
PUBLIC void UtilAssertNotInCrit(void  *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( !pcs->cNested || pcs->tidOwner != DwUtilGetCurrentThreadId() );
	return;
	}
	
#endif  //  DEBUG
#endif /* SPIN_LOCK */


//-----------------------------------------------------------------------------
//
// UtilGetDateTime2
// ============================================================================
//
//      VOID UtilGetDateTime2
//
//      Gets date time in date serial format.
//              ie, the double returned contains:
//                      Integer part: days since 12/30/1899.
//                      Fraction part: fraction of a day.
//
//-----------------------------------------------------------------------------
VOID UtilGetDateTime2( _JET_DATETIME *pdate )
	{
	SYSTEMTIME              systemtime;
	
	GetLocalTime( &systemtime );

	pdate->month = systemtime.wMonth;
	pdate->day = systemtime.wDay;
	pdate->year = systemtime.wYear;
	pdate->hour = systemtime.wHour;
	pdate->minute   = systemtime.wMinute;
	pdate->second   = systemtime.wSecond;
	}
	
VOID UtilGetDateTime( JET_DATESERIAL *pdt )
	{
	VOID                    *pv = (VOID *)pdt;
	_JET_DATETIME   date;
	unsigned long   rgulDaysInMonth[] =
		{ 31,29,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31     };

	unsigned        long    ulDay;
	unsigned        long    ulMonth;
	unsigned        long    iulMonth;
	unsigned        long    ulTime;

	static const unsigned long hr  = 0x0AAAAAAA;    // hours to fraction of day
	static const unsigned long min = 0x002D82D8;    // minutes to fraction of day
	static const unsigned long sec = 0x0000C22E;    // seconds to fraction of day

	UtilGetDateTime2( &date );

	ulDay = ( ( date.year - 1900 ) / 4 ) * ( 366 + 365 + 365 + 365 );
	ulMonth = ( ( ( date.year - 1900 ) % 4 ) * 12 ) + date.month;

	/*      walk months adding number of days.
	/**/
	for ( iulMonth = 0; iulMonth < ulMonth - 1; iulMonth++ )
		{
		ulDay += rgulDaysInMonth[iulMonth];
		}

	/*      add number of days in this month.
	/**/
	ulDay += date.day;

	/*      add one day if before March 1st, 1900
	/**/
	if ( ulDay < 61 )
		ulDay++;

	ulTime = date.hour * hr + date.minute * min + date.second * sec;

	// Now lDays and ulTime will be converted into a double (JET_DATESERIAL):
	//      Integer part: days since 12/30/1899.
	//      Fraction part: fraction of a day.

	// The following code is machine and floating point format specific.
	// It is set up for 80x86 machines using IEEE double precision.
	((long *)pv)[0] = ulTime << 5;
	((long *)pv)[1] = 0x40E00000 | ( (LONG) (ulDay & 0x7FFF) << 5) | (ulTime >> 27);
	}


	//  convert JET_DATESERIAL to a string
	//
	//  from SerialToDate() from JET\tools\jqa\date.c

char *SzUtilSerialToDate(JET_DATESERIAL dt)
{
	long                    julian;
	int                             cent;
	unsigned long   frac;
	long                    temp;
	double                  dDay;

	unsigned short  year;
	unsigned char   month;
	unsigned char   day;
	unsigned char   hour;
	unsigned char   minute;
	unsigned char   second;
	static  char    sz[20];

	dDay = (double)dt;
	julian = (long)dDay;
	dDay -= julian;
	if (julian < 0)
		dDay *= -1;
	frac = (unsigned long) ((dDay * 86400) + 0.5);
	julian += 109511;

	cent = (int) ((4 * julian + 3) / 146097);

	julian += cent - cent / 4;
	year = (unsigned short) ((julian * 4 + 3) / 1461);
	temp = julian - (year * 1461L) / 4;
	month = (unsigned char) ((temp * 10 + 5) / 306);
	day = (unsigned char) (temp - (month * 306L + 5) / 10 + 1);

	month += 3;
	if (month > 12)
	{
		month -= 12;
		year  += 1;
	}
	year += 1600;

	hour = (unsigned char) (frac / 3600);
	minute = (unsigned char) ((frac / 60) % 60);
	second = (unsigned char) (frac % 60);

	sprintf(sz, "%u/%u/%u %u:%02u:%02u",month,day,year,hour,minute,second);
	return sz;
}


	/*  RFS Utility functions  */


#ifdef RFS2

	/*
		RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
		cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
	*/

DWORD  cRFSAllocBreak	= 0xfffffffe;
DWORD  cRFSIOBreak		= 0xfffffffe;

int UtilRFSAlloc( const char  *szType, int Type )
	{
	/*  leave ASAP if we are not enabled  */

	if ( fDisableRFS )
		return UtilRFSLog( szType, 1 );
		
	/*  Breaking here on RFS failure allows easy change to RFS success during debugging  */
	
	if (	(	( cRFSAllocBreak == cRFSAlloc && Type == 0 ) ||
				( cRFSIOBreak == cRFSIO && Type == 1 ) ) &&
			!( fDisableRFS || fAuxDisableRFS ) )
		DebugBreak();

	switch ( Type )
		{
		case 0:  //  general allocation
			if ( cRFSAlloc == -1 || ( fDisableRFS || fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !cRFSAlloc )
				return UtilRFSLog( szType, 0 );
			cRFSAlloc--;
			return UtilRFSLog( szType, 1 );
		case 1:  //  IO operation
			if ( cRFSIO == -1 || ( fDisableRFS || fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !cRFSIO )
				return UtilRFSLog( szType, 0 );
			cRFSIO--;
			return UtilRFSLog( szType, 1 );
		default:
			Assert( 0 );
			break;
		}

	return 0;
	}

	/*
		RFS logging (log on success/failure).  If fPermitted == 0, access was denied.  Returns fPermitted.
		Turns on JET call logging if fPermitted == 0
	*/

int UtilRFSLog(const char  *szType,int fPermitted)
	{
	char *rgszT[1];
	
	if (!fPermitted)
		fLogJETCall = 1;
	
	if (!fLogRFS && fPermitted)
		return fPermitted;

	rgszT[0] = (char *) szType;
		
	if ( fPermitted )
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, RFS2_CATEGORY, RFS2_PERMITTED_ID, 1, rgszT );
	else
		UtilReportEvent( EVENTLOG_WARNING_TYPE, RFS2_CATEGORY, RFS2_DENIED_ID, 1, rgszT );
	
	return fPermitted;
	}

	/*  JET call logging (log on failure)
	/*  Logging will start even if disabled when RFS denies an allocation
	/**/

void UtilRFSLogJETCall(const char  *szFunc,ERR err,const char  *szFile,unsigned Line)
	{
	char szT[2][16];
	char *rgszT[4];
	
	if (err >= 0 || !fLogJETCall)
		return;

	rgszT[0] = (char *) szFunc;
	sprintf( szT[0], "%ld", err );
	rgszT[1] = szT[0];
	rgszT[2] = (char *) szFile;
	sprintf( szT[1], "%ld", Line );
	rgszT[3] = szT[1];
	
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, RFS2_CATEGORY, RFS2_JET_CALL_ID, 4, rgszT );
	}

	/*  JET inline error logging (logging controlled by JET call flags)  */

void UtilRFSLogJETErr(ERR err,const char  *szLabel,const char  *szFile,unsigned Line)
	{
	char szT[2][16];
	char *rgszT[4];

	if ( !fLogJETCall )
		return;
	
	sprintf( szT[0], "%ld", err );
	rgszT[0] = szT[0];
	rgszT[1] = (char *) szLabel;
	rgszT[2] = (char *) szFile;
	sprintf( szT[1], "%ld", Line );
	rgszT[3] = szT[1];
	
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, PERFORMANCE_CATEGORY, RFS2_JET_ERROR_ID, 4, rgszT );
	}

#endif  /*  RFS2  */


/***********************************************************
/******************* file IO routines **********************
/***********************************************************
/**/

/*  open a file that was opened as for write but shared to read.
/**/
ERR ErrUtilOpenReadFile( CHAR *szFileName, HANDLE *phf )
	{
#ifdef RFS2
	*phf = INVALID_HANDLE_VALUE;
	if ( !RFSAlloc( IOOpenReadFile ) )
		return ErrERRCheck( JET_errFileNotFound );
#endif

	*phf = CreateFile( szFileName,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL |
		FILE_FLAG_NO_BUFFERING,
		0 );

	if ( *phf == INVALID_HANDLE_VALUE )
		{
		ERR     err;

		err = ErrUTILIGetLastErrorFromErr( JET_errFileNotFound );

		/*	event log
		/**/
		if ( err == JET_errFileAccessDenied )
			{
			UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, FILE_ACCESS_DENIED_ERROR_ID, 1, &szFileName );
			}

		return err;
		}

	return JET_errSuccess;
	}


ERR ErrUtilCreateDirectory( CHAR *szDirName )
	{
	ERR		err = JET_errSuccess;
	BOOL	f;

	f = CreateDirectory( szDirName, NULL );
	if ( !f )
		{
		err = ErrUTILIGetLastError();
		}
	return err;
	}


ERR ErrUtilRemoveDirectory( CHAR *szDirName )
	{
	ERR		err = JET_errSuccess;
	BOOL	f;

	f = RemoveDirectory( szDirName );
	if ( !f )
		{
		err = ErrUTILIGetLastError();
		if ( err == JET_errFileNotFound )
			err = JET_errSuccess;
		}
	return err;
	}


ERR ErrUtilGetFileAttributes( CHAR *szFileName, BOOL *pfReadOnly )
	{
	DWORD dwAttributes = GetFileAttributes( szFileName );
	if ( dwAttributes == 0xFFFFFFFF )
		return JET_errFileNotFound;

	*pfReadOnly = ( dwAttributes & FILE_ATTRIBUTE_READONLY );
	return JET_errSuccess;
	}


ERR ErrUtilFindFirstFile( CHAR *szFind, HANDLE *phandleFind, CHAR *szFound )
	{
	ERR					err = JET_errSuccess;
	HANDLE				handleFind;
	WIN32_FIND_DATA		ffd;


	handleFind = FindFirstFile( szFind, &ffd );
	if ( handleFind == handleNil )
		{
		err = ErrUTILIGetLastError();
		}
	else
		{
		if ( szFound )
			strcpy( szFound, ffd.cFileName );
		*phandleFind = handleFind;
		}
	return err;
	}


ERR ErrUtilFindNextFile( HANDLE handleFind, CHAR *szFound )
	{
	ERR			   	err = JET_errSuccess;
	WIN32_FIND_DATA	ffd;
	BOOL			f;

	f = FindNextFile( handleFind, &ffd );
	if ( !f )
		{
		err = ErrUTILIGetLastError();
		}
	else
		{
		if ( szFound )
			strcpy( szFound, ffd.cFileName );
		}
	return err;
	}


VOID UtilFindClose( HANDLE handleFind )
	{
#ifdef DEBUG
	BOOL	f;

	f = FindClose( handleFind );
	Assert( f );
#else
	(VOID)FindClose( handleFind );
#endif

	return;
	}


BOOL FUtilFileExists( CHAR *szFilePathName )
	{
	JET_ERR	err;
	HANDLE	handle = handleNil;

	err = ErrUtilFindFirstFile( szFilePathName, &handle, NULL );
	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( handle != handleNil )
		UtilFindClose( handle );

	return (err != JET_errFileNotFound );
	}


//+api------------------------------------------------------
//
//	ErrUtilOpenFile
//	========================================================
//
//	Opens a given file.
//
//----------------------------------------------------------

ERR ErrUtilOpenFile(
	CHAR    *szFileName,
	HANDLE  *phf,
	ULONG   ulFileSize,
	BOOL    fReadOnly,
	BOOL    fOverlapped)
	{
	ERR		err = JET_errSuccess;
	DWORD   fdwAccess;
	DWORD   fdwShare;
	DWORD   fdwAttrsAndFlags;
	BOOL    f;

	Assert( !ulFileSize || ulFileSize && !fReadOnly );
	*phf = INVALID_HANDLE_VALUE;

#ifdef RFS2
	if ( !RFSAlloc( IOOpenFile ) )
		return ErrERRCheck( JET_errFileNotFound );
#endif

	/*	set access to read or read-write
	/**/
	if ( fReadOnly )
		fdwAccess = GENERIC_READ;
	else
		fdwAccess = GENERIC_READ | GENERIC_WRITE;

	/*	do not allow sharing on database file
	/**/
#define FILE_LOCK	1
#ifdef FILE_LOCK
#ifdef DEBUG
	if ( fOverlapped )
		fdwShare = 0;   /* no sharing for database */
	else
		fdwShare = FILE_SHARE_READ;     /* share read for log files */
#else
	fdwShare = 0;   /* no sharing */
#endif	/* DEBUG */
#else
	fdwShare = FILE_SHARE_READ;     /* share for all files */
#endif /* FILE_LOCK */

	if ( fOverlapped )
		{
		fdwAttrsAndFlags =
			FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_OVERLAPPED;
		}
	else
		{
		/*      This is a bad design. When opened ReadOnly, we happened to know
		 *      it is for backup the log files. Only sequential read involved. Only
		 *      for sequential_scan and not no_buffering.
		 */
		fdwAttrsAndFlags =
			FILE_ATTRIBUTE_NORMAL |
			( fReadOnly ?
				FILE_FLAG_SEQUENTIAL_SCAN :
				FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH );
		}

	if ( ulFileSize != 0L )
		{
		/*	create a new file
		/**/
		fdwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS;

		*phf = CreateFile( szFileName,
			fdwAccess,
			fdwShare,
			0,
			CREATE_NEW,
			fdwAttrsAndFlags,
			0 );

		if ( *phf == INVALID_HANDLE_VALUE )
			{
			err = ErrUTILIGetLastErrorFromErr( JET_errFileNotFound );

			/*	event log
			/**/
			if ( err == JET_errFileAccessDenied )
				{
				UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, FILE_ACCESS_DENIED_ERROR_ID, 1, &szFileName );
				}

			return err;
			}

		/*	no overlapped, it does not work!
		/**/
		err = ErrUtilNewSize( *phf, ulFileSize, 0, fFalse );

		/*	force log file pre-allocation to be effective
		/**/
		Assert( sizeof(HANDLE) == sizeof(HFILE) );
		f = CloseHandle( (HANDLE) *phf );
		Assert( f );
		*phf = INVALID_HANDLE_VALUE;

		/*	if created file, but could not allocate sufficient space,
		/*	then delete file and return error.
		/**/
		if ( err < 0 )
			{
			f = DeleteFile( szFileName );
			Assert( f );
			goto HandleError;
			}

		//	UNDONE: is this still necessary in Daytona
		/*	this bogus code works around an NT bug which
		/*	causes network files not to have file usage
		/*	restrictions reset until a GENERIC_READ file
		/*	handle is closed.
		/**/
		if ( fOverlapped )
			{
			fdwAttrsAndFlags =
				FILE_ATTRIBUTE_NORMAL |
				FILE_FLAG_NO_BUFFERING |
				FILE_FLAG_WRITE_THROUGH |
				FILE_FLAG_OVERLAPPED;
			}
		else
			{
			fdwAttrsAndFlags =
				FILE_ATTRIBUTE_NORMAL |
				FILE_FLAG_NO_BUFFERING |
				FILE_FLAG_WRITE_THROUGH;
			}

		*phf = CreateFile( szFileName,
			GENERIC_READ,
			fdwShare,
			0,
			OPEN_EXISTING,
			fdwAttrsAndFlags,
			0 );

		if ( *phf == INVALID_HANDLE_VALUE )
			{
			err = ErrUTILIGetLastErrorFromErr( JET_errFileNotFound );

			/*	event log
			/**/
			if ( err == JET_errFileAccessDenied )
				{
				UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, FILE_ACCESS_DENIED_ERROR_ID, 1, &szFileName );
				}
			
			return err;
			}

		f = CloseHandle( (HANDLE) *phf );
		Assert( f );
		}

	if ( fOverlapped )
		{
		fdwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_OVERLAPPED;
		}
	else
		{
		fdwAttrsAndFlags =
			FILE_ATTRIBUTE_NORMAL |
			( fReadOnly ?
				FILE_FLAG_SEQUENTIAL_SCAN :
				FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH );
		}

	*phf = CreateFile( szFileName,
		fdwAccess,
		fdwShare,
		0,
		OPEN_EXISTING,
		fdwAttrsAndFlags,
		0 );

	/*	open in read_only mode if open in read_write mode failed
	/**/
	if ( *phf == INVALID_HANDLE_VALUE && !fReadOnly && !ulFileSize )
		{
		/*	try to open file read only
		/**/
		fdwAccess = GENERIC_READ;

		*phf = CreateFile( szFileName,
			fdwAccess,
			fdwShare,
			0,
			OPEN_EXISTING,
			fdwAttrsAndFlags,
			0 );

		err = JET_wrnFileOpenReadOnly;
		}

	/*	if file could not be opened, return NULL file handle.
	/**/
	if ( *phf == INVALID_HANDLE_VALUE )
		{
		err = ErrUTILIGetLastErrorFromErr( JET_errFileNotFound );

		/*	event log
		/**/
		if ( err == JET_errFileAccessDenied )
			{
			UtilReportEvent( EVENTLOG_ERROR_TYPE, GENERAL_CATEGORY, FILE_ACCESS_DENIED_ERROR_ID, 1, &szFileName );
			}

		return err;
		}

HandleError:
	if ( err < 0 && *phf != INVALID_HANDLE_VALUE )
		{
		f = CloseHandle( (HANDLE)*phf );
		Assert( f );
		*phf = INVALID_HANDLE_VALUE;
		}

	return err;
	}


//+api------------------------------------------------------
//
//      ErrUtilDeleteFile
//      ========================================================
//
//      ERR ErrUtilDeleteFile( const CHAR *szFileName )
//
//      Delete given file.
//
//----------------------------------------------------------
ERR ErrUtilDeleteFile( CHAR *szFileName )
	{
#ifdef RFS2
	if ( !RFSAlloc( IODeleteFile ) )
		return ErrERRCheck( JET_errFileNotFound );
#endif

	if ( DeleteFile( szFileName ) )
		return JET_errSuccess;
	return ErrERRCheck( JET_errFileNotFound );
	}


//+api------------------------------------------------------
//
//      ERR ErrUtilNewSize( HANDLE hf, ULONG ulSize, ULONG ulSizeHigh, BOOL fOverlapped )
//      ========================================================
//
//      Resize database file.  Not MUTEX protected as new size
//      operation will not conflict with chgfileptr, read or write.
//
//      PARAMETERS
//              hf                      file handle
//              cpg                     new size of database file in pages
//
//----------------------------------------------------------

/*	file extension OLP
/**/
OLP olpExtend;

/*	file extension signal
/**/
SIG sigExtend = sigNil;

/*	file extension buffer (just a bunch of zeros)
/**/
LONG	cbZero = 4096;
BYTE	*rgbZero = NULL;


ERR ErrUtilNewSize( HANDLE hf, ULONG ulSize, ULONG ulSizeHigh, BOOL fOverlapped )
	{
	ERR		err = JET_errSuccess;
	QWORDX	qwxOldSize;
	QWORDX	qwxNewSize;
	QWORDX	qwxT;
	ULONG	cb;
	ULONG	cbT;
	QWORDX	qwxOffset;

#ifdef RFS2
	if ( !RFSAlloc( IONewFileSize ) )
		return ErrERRCheck( JET_errDiskFull );
#endif

	/*	get current file size
	/**/
	qwxOldSize.l = GetFileSize( hf, &qwxOldSize.h );
	if ( qwxOldSize.l == 0xFFFFFFFF )
		{
		CallR( ErrUTILIGetLastError() );
		}

	/*	if we are truncating the file, set the new end of file pointer
	/**/
	qwxNewSize.l = ulSize;
	qwxNewSize.h = ulSizeHigh;

	/*	if we are extending the file, force NT to commit sectors to the new
	/*	extension by writing to the end of the file
	/**/
	if ( qwxNewSize.qw > qwxOldSize.qw )
		{
		/*	calculate offset
		/**/
		cb = (ULONG) min( qwxNewSize.qw - qwxOldSize.qw, cbZero );
		qwxOffset.qw = qwxNewSize.qw - (QWORD) cb;

		/*	if this is an overlapped file, perform overlapped IO
		/**/
		if ( fOverlapped )
			{
			olpExtend.Offset = qwxOffset.l;
			olpExtend.OffsetHigh = qwxOffset.h;
			olpExtend.hEvent = sigExtend;
			UtilSignalReset( sigExtend );
			CallR( ErrUtilWriteBlockOverlapped( hf, rgbZero, cb, &cbT, &olpExtend ) );
			UtilSignalWait( sigExtend, -1 );
			}

		/*	if this is not an overlapped file, perform sync IO
		/**/
		else
			{
			qwxT = qwxOffset;
			qwxT.l = SetFilePointer( hf, qwxT.l, &qwxT.h, FILE_BEGIN );
			if ( qwxT.l == 0xFFFFFFFF )
				CallR( ErrUTILIGetLastError() );
			CallR( ErrUtilWriteBlock( hf, rgbZero, cb, &cbT ) );
			}
		}

	/*	Set file size.
	 */
	qwxT = qwxNewSize;
	qwxT.l = SetFilePointer( hf, qwxT.l, &qwxT.h, FILE_BEGIN );
	if ( qwxT.l == 0xFFFFFFFF )
		CallR( ErrUTILIGetLastError() );
	Assert( qwxT.qw == qwxNewSize.qw );

	if ( !SetEndOfFile( hf ) )
		CallR( ErrUTILIGetLastError() );
			
	/*	verify file size
	/**/
#ifdef DEBUG
	qwxT.qw = 0;
	UtilChgFilePtr( hf, 0, &qwxT.h, FILE_END, &qwxT.l );
	Assert( qwxT.qw == qwxNewSize.qw );
#endif

	return JET_errSuccess;
	}


//+api------------------------------------------------------
//
// ErrUtilCloseFile
// =========================================================
//
//      ERR ErrUtilCloseFile( HANDLE hf )
//
//      Close file.
//
//----------------------------------------------------------
ERR ErrUtilCloseHandle( HANDLE hf )
	{
	BOOL    f;

	Assert(sizeof(HANDLE) == sizeof(HFILE));
	f = CloseHandle( (HANDLE) hf );
	if ( !f )
		{
#ifdef DEBUG
		DWORD dw = GetLastError();
#endif
		return ErrERRCheck( JET_errFileClose );
		}
	return JET_errSuccess;
	}


ERR ErrUtilReadFile( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead )
	{
	BOOL    f;
	INT		msec = 1;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );

#ifdef RFS2
	if ( !RFSAlloc( IOReadBlock ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

IssueRead:
	f = ReadFile( (HANDLE) hf, pvBuf, cbBuf, pcbRead, NULL );
	if ( f )
		{
		return JET_errSuccess;
		}
	else
		{
		ERR err = ErrUTILIGetLastError();

		if ( err == JET_errTooManyIO )
			{
			msec <<= 1;
			UtilSleep( msec - 1 );
			goto IssueRead;
			}
		else
			return err;
		}
	}


/********************
/* optimised version of UlUtilChecksum for calculating the
/* checksum on pages. we assume that the pagesize is a multiple
/* of 16 bytes, this is true for 4k and 8k pages.
/*
/* because it is a bottleneck we turn on the optimisations
/* even in debug
/*
/**/
#pragma optimize( "agt", on )
ULONG UlUtilChecksum( const BYTE *pb, INT cb )
	{
	const ULONG	*pul = (ULONG *)pb;
	const ULONG	* const pulMax = pul + (cb/sizeof(ULONG));
	ULONG	ulChecksum = 0x89abcdef;

	Assert( (cb % 32) == 0 );
	
	/* skip the first four bytes as it is the checksum */
	goto Start;

	while ( pul < pulMax )
		{
		ulChecksum += pul[0];
Start:
		ulChecksum += pul[1];
		ulChecksum += pul[2];
		ulChecksum += pul[3];
		ulChecksum += pul[4];
		ulChecksum += pul[5];
		ulChecksum += pul[6];
		ulChecksum += pul[7];
		pul += 8;
		}
	
	return ulChecksum;
	}
#pragma optimize( "", off )


/*	read shadowed header. The header is multiple sectors.
/*	Checksum must be the first 4 bytes of the header.
/**/
ERR ErrUtilReadShadowedHeader( CHAR *szFileName, BYTE *pbHeader, INT cbHeader )
	{
	ERR		err;
	HANDLE	hf = handleNil;
	LONG	lT;
	LONG	cbT;

 	Call( ErrUtilOpenFile( szFileName, &hf, 0, fFalse, fFalse ) );

 	UtilChgFilePtr( hf, 0, NULL, FILE_BEGIN, &lT );
 	Assert( lT == 0 );
 	err = ErrUtilReadBlock( hf, pbHeader, (UINT)cbHeader, &cbT );
	Assert( err < 0 || err == JET_errSuccess );
	if ( err == JET_errSuccess && cbT == cbHeader )
		{
		/*	header read successfully, now check checksum
		/**/
		ULONG	lT;
		lT = UlUtilChecksum( pbHeader, cbHeader );
		if ( lT == *(ULONG *)( pbHeader ) )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		}

	/*	first header corrupt so read shadow header
	/**/
	Assert( cbHeader % 512 == 0 );
 	UtilChgFilePtr( hf, cbHeader, NULL, FILE_BEGIN, &lT );
 	Assert( lT == cbHeader );
 	err = ErrUtilReadBlock( hf, (BYTE *)pbHeader, (UINT)cbHeader, &cbT );
	Assert( err < 0 || err == JET_errSuccess );
	if ( err == JET_errSuccess && cbT == cbHeader )
		{
		/*	checkpoint read successfully, now check checksum
		/**/
		ULONG	lT;
		lT = UlUtilChecksum( pbHeader, cbHeader );
		if ( lT == *(ULONG *)( pbHeader ) )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		}

	/*	it should never happen that both checkpoints in the checkpoint
	/*	file are corrupt.
	/**/
	err = ErrERRCheck( JET_errDiskIO );

HandleError:
	if ( hf != handleNil )
		CallS( ErrUtilCloseFile( hf ) );

	return err;
	}


ERR ErrUtilWriteShadowedHeader( CHAR *szFileName, BYTE *pbHeader, INT cbHeader )
	{
	ERR		err;
	HANDLE	hf = handleNil;
	LONG	lT;
	LONG	cbT;

	/*  try to create file.  If creation fails, it may already exist, so try and simply open
	/*  the file.  If this STILL fails, then we have a true error
	/**/
	Assert( cbHeader % 512 == 0 );
	
 	err = ErrUtilOpenFile( szFileName, &hf, 2*cbHeader, fFalse, fFalse );
 	if ( err < 0 )
 		Call( ErrUtilOpenFile( szFileName, &hf, 0, fFalse, fFalse ) );

	/*	write header at offset 0 and at offset cbheader to
	/*	act as shadow in case write failure causes checkpoint to be
	/*	corrupted.  Since checkpoint contains information necessary for
	/*	recovery, Shadowed file operations must be robust such that no
	/*	failure can cause shadowed data to become inaccessible.
	/**/
 	UtilChgFilePtr( hf, 0, NULL, FILE_BEGIN, &lT );
 	Assert( lT == 0 );

	/*	update header checksum last
	/**/
	*(ULONG *)( pbHeader ) = UlUtilChecksum( pbHeader, cbHeader );

 	Call( ErrUtilWriteBlock( hf, pbHeader, (UINT)cbHeader, &cbT ) );
	if ( cbT != cbHeader )
		{
		Error( ErrERRCheck( JET_errDiskIO ), HandleError );
		}
 	UtilChgFilePtr( hf, cbHeader, NULL, FILE_BEGIN, &lT );
 	Assert( lT == cbHeader );
 	err = ErrUtilWriteBlock( hf, pbHeader, (UINT)cbHeader, &cbT );
	if ( err < 0 || cbT != cbHeader )
		{
		Error( ErrERRCheck( JET_errDiskIO ), HandleError );
		}

HandleError:
	if ( err < 0 )
		{
		BYTE	*rgszT[1];

		rgszT[0] = szFileName;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY, SHADOW_PAGE_WRITE_FAIL_ID, 1, rgszT );
		}

	if ( hf != handleNil )
		{
		CallS( ErrUtilCloseFile( hf ) );
		}

	return err;
	}


//+api------------------------------------------------------
//
//      ErrUtilReadBlock( hf, pvBuf, cbBuf, pcbRead )
//      ========================================================
//
//      ERR     ErrUtilReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//      Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//      or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrUtilReadBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead )
	{
	BOOL    f;
	INT             msec = 1;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );

#ifdef RFS2
	if ( !RFSAlloc( IOReadBlock ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

IssueRead:
	f = ReadFile( (HANDLE) hf, pvBuf, cbBuf, pcbRead, NULL );
	if ( f )
		{
		if ( cbBuf != *pcbRead )
			return ErrERRCheck( JET_errDiskIO );
		else
			return JET_errSuccess;
		}
	else
		{
		ERR err = ErrUTILIGetLastError();

		if ( err == JET_errTooManyIO )
			{
			msec <<= 1;
			UtilSleep( msec - 1 );
			goto IssueRead;
			}
		else
			return err;
		}
	}


//+api------------------------------------------------------
//
// ERR ErrUtilWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
// =========================================================
//
//      ERR     ErrUtilWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//      Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrUtilWriteBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbWritten )
	{
	BOOL    f;
	INT		msec = 1;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );

#ifdef RFS2
	if ( !RFSAlloc( IOWriteBlock ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

IssueWrite:
	f = WriteFile( (HANDLE) hf, pvBuf, cbBuf, pcbWritten, NULL );
	if ( f )
		{
		if ( cbBuf != *pcbWritten )
			{
			if ( DwUtilGetLastError() == ERROR_DISK_FULL )
				return ErrERRCheck( JET_errDiskFull );
			else
				return ErrERRCheck( JET_errDiskIO );
			}
		else
			return JET_errSuccess;
		}
	else
		{
		ERR err = ErrUTILIGetLastError();

		if ( err == JET_errTooManyIO )
			{
			msec <<= 1;
			UtilSleep(msec - 1);
			goto IssueWrite;
			}
		else
			return err;
		}
	}


//+api------------------------------------------------------
//
// ErrUtilReadBlockOverlapped( hf, pvBuf, cbBuf, pcbRead )
// =========================================================
//
//      ERR     ErrUtilReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//      Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//      or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrUtilReadBlockOverlapped(
	HANDLE  hf,
	VOID    *pvBuf,
	UINT    cbBuf,
	DWORD   *pcbRead,
	OLP		*polp)
	{
	BOOL    f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

#ifdef RFS2
	if ( !RFSAlloc( IOReadBlockOverlapped ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

	f = ReadFile( (HANDLE) hf, pvBuf, cbBuf, pcbRead, (OVERLAPPED *) polp );
	if ( f )
		return JET_errSuccess;
	else
		return ErrUTILIGetLastError();
	}


//+api------------------------------------------------------
//
// ErrUtilWriteBlockOverlapped( hf, pvBuf, cbBuf, pcbWritten )
// =========================================================
//
//      ERR     ErrUtilWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//      Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrUtilWriteBlockOverlapped(
	HANDLE  hf,
	VOID    *pvBuf,
	UINT    cbBuf,
	DWORD   *pcbWritten,
	OLP		*polp)
	{
	BOOL    f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

#ifdef RFS2
	if ( !RFSAlloc( IOWriteBlockOverlapped ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

	f = WriteFile( (HANDLE) hf, pvBuf, cbBuf, pcbWritten, (OVERLAPPED *)polp );
	if ( f )
		{
		return JET_errSuccess;
		}
	else
		{
		return ErrUTILIGetLastError();
		}
	}


//+api------------------------------------------------------
//
//      ErrUtilReadBlockEx( hf, pvBuf, cbBuf, pcbRead )
//      ========================================================
//
//      ERR     ErrUtilReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//      Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//      or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrUtilReadBlockEx(
	HANDLE  hf,
	VOID    *pvBuf,
	UINT    cbBuf,
	OLP		*polp,
	VOID    *pfnCompletion)
	{
	BOOL    f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

#ifdef RFS2
	if ( !RFSAlloc( IOReadBlockEx ) )
		return ErrERRCheck( JET_errDiskIO );
#endif

	f = ReadFileEx( (HANDLE) hf,
		pvBuf,
		cbBuf,
		(OVERLAPPED *) polp,
		(LPOVERLAPPED_COMPLETION_ROUTINE) pfnCompletion );

	if ( f )
		return JET_errSuccess;
	else
		return ErrUTILIGetLastError();
	}


//+api------------------------------------------------------
//
//      ERR ErrUtilWriteBlockEx( hf, pvBuf, cbBuf, pcbWritten )
//      ========================================================
//
//      ERR     ErrUtilWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//      Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrUtilWriteBlockEx(
	HANDLE  hf,
	VOID    *pvBuf,
	UINT    cbBuf,
	OLP     *polp,
	VOID    *pfnCompletion )
	{
	BOOL    f;
	ERR     err;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

	f = WriteFileEx( (HANDLE) hf,
		pvBuf,
		cbBuf,
		(OVERLAPPED *)polp,
		(LPOVERLAPPED_COMPLETION_ROUTINE)pfnCompletion );

	if ( f )
		err = JET_errSuccess;
	else
		err = ErrUTILIGetLastError();

	return err;
	}


ERR ErrUtilGetOverlappedResult(
	HANDLE  hf,
	OLP		*polp,
	UINT    *pcb,
	BOOL    fWait)
	{
	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );
	
	if ( GetOverlappedResult( (HANDLE) hf, (OVERLAPPED *)polp, pcb, fWait ) )
		return JET_errSuccess;

	if ( DwUtilGetLastError() == ERROR_DISK_FULL )
		return ErrERRCheck( JET_errDiskFull );

	return ErrERRCheck( JET_errDiskIO );
	}


//+api------------------------------------------------------
//
//	ErrUtilMove( CHAR *szFrom, CHAR *szTo )
// =========================================================
//
//	ERR     ErrUtilMove( CHAR *szFrom, CHAR *szTo )
//
//	Renames file or directory szFrom to file name szTo.
//
//----------------------------------------------------------
ERR ErrUtilMove( CHAR *szFrom, CHAR *szTo )
	{
	BOOL	f;
#ifdef RFS2
	if ( !RFSAlloc( IOMoveFile ) )
		return ErrERRCheck( JET_errFileAccessDenied );
#endif

	f = MoveFile( szFrom, szTo );
	if  ( !f )
		{
		/*	it was found that NT sometimes fails the move but
		/*	will allow it a short time later, so this retry
		/*	logic has been added.
		/**/
		Sleep( 100 );
		f = MoveFile( szFrom, szTo );
		}
		
	return ( f ? JET_errSuccess : ErrUTILIGetLastErrorFromErr( JET_errFileNotFound ) );
	}


//+api------------------------------------------------------
//
//      ERR ErrUtilCopy( CHAR *szFrom, CHAR *szTo, BOOL fFailIfExists )
//      ========================================================
//
//      Copies file szFrom to file name szTo.
//      If szTo already exists, the function either fails or overwrites
//      the existing file, depending on the flag fFailIfExists
//
//----------------------------------------------------------
ERR ErrUtilCopy( CHAR *szFrom, CHAR *szTo, BOOL fFailIfExists )
	{
#ifdef RFS2
	if ( !RFSAlloc( IOCopyFile ) )
		return ErrERRCheck( JET_errFileAccessDenied );
#endif

	if ( CopyFile( szFrom, szTo, fFailIfExists ) )
		return JET_errSuccess;
	else
		return ErrUTILIGetLastError();
	}


#ifdef PERFMON
/************************************/
/*  PERFORMANCE MONITORING SUPPORT  */
/************************************/

#include <wchar.h>

#include "winperf.h"

	/*  ICF used by main JETBlue object  */

PM_ICF_PROC LProcNameICFLPpv;

WCHAR wszProcName[36] = L"\0";		// L converts to Unicode

#define szDSModuleName		"dsamain"
#define szDSInstanceName	"Directory"
#define szISModuleName		"store"
#define szISInstanceName	"Information Store"

long LProcNameICFLPpv(long lAction,void **ppvMultiSz)
	{
	//  init ICF
		
	if (lAction == ICFInit)
		{
		CHAR szT[_MAX_PATH];
		CHAR szBaseName[_MAX_FNAME];
		
        szT[0] = '\0';

		/*  get our process name  */
		GetModuleFileName(NULL,szT,sizeof(szT));
		_splitpath((const CHAR *)szT,NULL,NULL,szBaseName,NULL);

		// special-case handling of Exchange services:
		if ( _stricmp( szBaseName, szDSModuleName ) == 0 )
			{
			strcpy( szBaseName, szDSInstanceName );
			}
		else if ( _stricmp( szBaseName, szISModuleName ) == 0 )
			{
			strcpy( szBaseName, szISInstanceName );
			}

		swprintf(wszProcName,L"%.18S\0",szBaseName);
		}

	else
		{
		if (ppvMultiSz)
			{
			*ppvMultiSz = wszProcName;
			return 1;
			}
		}
	
	return 0;
	}


#if defined( DEBUG ) || defined( PERFDUMP )
void  *  critDBGPrint;
#endif

#ifdef DEBUG
VOID JET_API DBGFPrintF( char *sz )
	{
	UtilEnterCriticalSection( critDBGPrint );
	FPrintF2( "%s", sz );
	UtilLeaveCriticalSection( critDBGPrint );
	}
#endif


/*	dump performance statistics string to performance stats file
/**/
void UtilPerfDumpStats(char *szText)
	{
	int			hf;
	char		szMessage[2048];

#if defined( DEBUG ) || defined( PERFDUMP )
extern BOOL fDBGPerfOutput;     /* reg controled flag in dae\src\sysinit.c */

	if ( !fDBGPerfOutput )
		return;
#else
	return;
#endif

	/*	assemble monolithic perf stat string
	/**/
	szMessage[0] = '\0';
	/*	copy perf stat text to message
	/**/
	lstrcat( szMessage, szText );
	lstrcat( szMessage, szNewLine );

	/******************************************************
	/*	write string to perf stat file
	/**/
#if defined( DEBUG ) || defined( PERFDUMP )
	UtilEnterCriticalSection( critDBGPrint );
#endif
	
	hf = _lopen( (LPSTR) szJetTxt, OF_READWRITE );
	/*	if open failed, assume no such file and create, then
	/*	seek to end of file.
	/**/
	if ( hf == -1 )
		hf = _lcreat( (LPSTR)szJetTxt, 0 );
	else
		_llseek( hf, 0, 2 );
	_lwrite( hf, (LPSTR)szMessage, lstrlen(szMessage) );
	_lclose( hf );
	
#if defined( DEBUG ) || defined( PERFDUMP )
	UtilLeaveCriticalSection( critDBGPrint );
#endif
	
	return;
	}

	
	/*  Init/Term routines for performance monitoring
	/*
	/*  NOTE:  these initializations are just enough to allow this
	/*      instance to detect a performance data request.  Further
	/*      initialization is done only if such a request is made
	/*      to save init time and memory (see UtilPerfThreadInit())
	/**/

HANDLE hPERFDataThread = NULL;
SIG sigPERFEndDataThread = NULL;
HANDLE hPERFCollectSem = NULL;
HANDLE hPERFProcCountSem = NULL;
HANDLE hPERFNewProcMutex = NULL;

PACL AllocGenericACL()
{
    PACL                        pAcl;
    PSID                        pSid;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;
    DWORD                       dwAclLength, dwError;

    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSid ) )
    {
        dwError = GetLastError();
        return NULL;
    }

    dwAclLength = sizeof(ACL) + 
                  sizeof(ACCESS_ALLOWED_ACE) -
                  sizeof(ULONG) +
                  GetLengthSid(pSid);

    pAcl = GlobalAlloc (GPTR, dwAclLength);
    if (pAcl != NULL)
    {
        if (!InitializeAcl( pAcl, dwAclLength, ACL_REVISION) ||
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   pSid ) )
        {
            dwError = GetLastError();
            GlobalFree(pAcl);
            pAcl = NULL;
        }
    }

    FreeSid(pSid);

    return pAcl;
}

void FreeGenericACL( PACL pAcl)
{
    if (pAcl != NULL)
        GlobalFree(pAcl);
}

extern DWORD UtilPerfThread(DWORD);

ERR ErrUtilPerfInit(void)
	{
	ERR						err;
	char					szT[256];
#if defined( DEBUG ) || defined( PERFDUMP )
	JET_DATESERIAL			dtNow;
	extern BOOL				fDBGPerfOutput;
	char					*sz;
#endif
    BYTE					rgbSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR	pSD = (PSECURITY_DESCRIPTOR) rgbSD;
	SECURITY_ATTRIBUTES		SA;
	SECURITY_ATTRIBUTES		*pSA;
    PACL                    pAcl;
	
    if ((pAcl = AllocGenericACL()) == NULL ||
        !SetSecurityDescriptorDacl (pSD, TRUE, pAcl, FALSE))
    {
        // don't free pAcl here since there is no way 
        // to get out of this function without calling
        // FreeGenericACL().
        pSD = NULL; 
    }

	/*
	 * We've been having access denied problems opening the file mapping
	 * from the perfmon dll, so make extra sure that we have rights to do
	 * so by creating a SD that grants full access.  If the creation fails
	 * then just fall back on passing in a NULL SD pointer.
	 *
	if ( !InitializeSecurityDescriptor( pSD, SECURITY_DESCRIPTOR_REVISION ) ||
		!SetSecurityDescriptorDacl( pSD, TRUE, (PACL)NULL, FALSE ) )
		{
		pSD = NULL;
		}
     */
	pSA = &SA;
	pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
	pSA->lpSecurityDescriptor = pSD;
	pSA->bInheritHandle = FALSE;

	/*	open/create the performance data collect semaphore
	/**/
	sprintf( szT,"Collect:  %.246s",szPERFVersion);
	if ( !( hPERFCollectSem = CreateSemaphore(pSA,0,PERF_INIT_INST_COUNT,szT)))
		{
		if ( GetLastError() == ERROR_ALREADY_EXISTS )
			hPERFCollectSem = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, szT );
		}
	if ( !hPERFCollectSem )
    {
        FreeGenericACL(pAcl);
		return ErrERRCheck( JET_errPermissionDenied );
    }

	/*	create/open the new process mutex, but do not acquire
	/**/
	sprintf( szT,"New Proc:  %.246s",szPERFVersion );
	if ( !( hPERFNewProcMutex = CreateMutex( pSA, FALSE, szT ) ) )
		{
        if ( GetLastError() == ERROR_ALREADY_EXISTS )
            hPERFNewProcMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, szT );
        }

    if ( !hPERFNewProcMutex )
        {
		err = ErrERRCheck( JET_errPermissionDenied );
		goto FreeSem;
		}

	/*  create our private signal to our performance data thread
	/**/
	if ( ( err = ErrUtilSignalCreate( &sigPERFEndDataThread, NULL ) ) < 0 )
		goto FreeMutex;

	/*  create our performance data thread
	/*
	/*  NOTE:  MUST be Realtime priority or conflicts will occur
	/**/
	WaitForSingleObject(hPERFNewProcMutex,INFINITE);
	if ( ( err = ErrUtilCreateThread( UtilPerfThread, 0, THREAD_PRIORITY_TIME_CRITICAL, &hPERFDataThread ) ) < 0 )
		{
		ReleaseMutex(hPERFNewProcMutex);
		goto FreeSignal;
		}

	/*	create/open the inst count semaphore, and acquire one count
	/**/
	sprintf( szT,"Proc Count:  %.246s", szPERFVersion );
	if ( !( hPERFProcCountSem = CreateSemaphore( pSA, PERF_INIT_INST_COUNT, PERF_INIT_INST_COUNT, szT ) ) )
		{
		if (GetLastError() == ERROR_ALREADY_EXISTS)
			hPERFProcCountSem = OpenSemaphore(SEMAPHORE_ALL_ACCESS,FALSE,szT);
		}
	if (!hPERFProcCountSem)
		{
		ReleaseMutex(hPERFNewProcMutex);
		err = ErrERRCheck( JET_errPermissionDenied );
		goto KillThread;
		}
	
	WaitForSingleObject(hPERFProcCountSem,INFINITE);
	
	ReleaseMutex(hPERFNewProcMutex);

#if defined( DEBUG ) || defined( PERFDUMP )
	if ( ( sz = GetDebugEnvValue ( "PERFOUTPUT" ) ) != NULL )
	{
	fDBGPerfOutput = fTrue;
	SFree( sz );
	
		/*  start new section in perf stat file  */

	UtilGetDateTime(&dtNow);
	LProcNameICFLPpv(1,NULL);       //  get proc name via ICF init
	sprintf(szT,"\n%s  Version %02d.%02d.%04d  \"%S\"  %s\n",
		szVerName,rmj,rmm,rup,wszProcName,SzUtilSerialToDate(dtNow));
	UtilPerfDumpStats(szT);
	LProcNameICFLPpv(2,NULL);       //  term ICF
	}
#endif

    FreeGenericACL(pAcl);
	return JET_errSuccess;
	
KillThread:
	UtilEndThread(hPERFDataThread,sigPERFEndDataThread);
	(void) ErrUtilCloseHandle(hPERFDataThread);
	hPERFDataThread = NULL;
FreeSignal:
	UtilCloseSignal(sigPERFEndDataThread);
	sigPERFEndDataThread = NULL;
FreeMutex:
	(void) ErrUtilCloseHandle(hPERFNewProcMutex);
	hPERFNewProcMutex = NULL;
FreeSem:
	(void) ErrUtilCloseHandle(hPERFCollectSem);
	hPERFCollectSem = NULL;

    FreeGenericACL(pAcl);
	return err;
	}


void UtilPerfTerm(void)
	{
	/*  release one count and close the instance count semaphore  */
	WaitForSingleObject(hPERFNewProcMutex,INFINITE);
	
	ReleaseSemaphore(hPERFProcCountSem,1,NULL);
	
	if ( hPERFProcCountSem )
		{
		ErrUtilCloseHandle(hPERFProcCountSem);
		hPERFProcCountSem = NULL;
		}
	
	/*  end the performance data thread  */
	UtilEndThread(hPERFDataThread,sigPERFEndDataThread);
	if ( hPERFDataThread )
		{
		(void)ErrUtilCloseHandle(hPERFDataThread);
		hPERFDataThread = NULL;
		}
	
	ReleaseMutex(hPERFNewProcMutex);

	/*  free our private signal to the performance data thread  */
	if ( sigPERFEndDataThread )
		{
		UtilCloseSignal(sigPERFEndDataThread);
		sigPERFEndDataThread = NULL;
		}

	/*  close the new process mutex  */
	if ( hPERFNewProcMutex )
		{
		ErrUtilCloseHandle(hPERFNewProcMutex);
		hPERFNewProcMutex = NULL;
		}

	/*  free the performance data collect semaphore  */
	if ( hPERFCollectSem )
		{
		ErrUtilCloseHandle(hPERFCollectSem);
		hPERFCollectSem = NULL;
		}
	}


/*  Performance thread init/term routines  */

void *pvPERFSharedData = NULL;
HANDLE hPERFFileMap = NULL;
HANDLE hPERFSharedDataMutex = NULL;
HANDLE hPERFDoneEvent = NULL;

DWORD cbMaxCounterBlockSize;
DWORD cbInstanceSize;

BOOL fUtilPerfThreadInit = fFalse;

DWORD cCollect;

ERR ErrUtilPerfThreadInit(void)
	{
	ERR							err;
	DWORD						dwCurObj;
	DWORD						dwCurCtr;
	CHAR						szT[_MAX_PATH];
	DWORD						dwOffset;
	PPERF_OBJECT_TYPE			ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION	ppcdCounterSrc;
	PSDA						psda;
    BYTE						rgbSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR		pSD = (PSECURITY_DESCRIPTOR) rgbSD;
	SECURITY_ATTRIBUTES			SA;
	SECURITY_ATTRIBUTES			*pSA;
    PACL                        pAcl;
	
    if ((pAcl = AllocGenericACL()) == NULL ||
        !SetSecurityDescriptorDacl (pSD, TRUE, pAcl, FALSE))
    {
        FreeGenericACL(pAcl);
        pSD = NULL; 
    }

    /*
	 * We've been having access denied problems opening the file mapping
	 * from the perfmon dll, so make extra sure that we have rights to do
	 * so by creating a SD that grants full access.  If the creation fails
	 * then just fall back on passing in a NULL SD pointer.
	 *
	if ( !InitializeSecurityDescriptor( pSD, SECURITY_DESCRIPTOR_REVISION ) ||
		!SetSecurityDescriptorDacl( pSD, TRUE, (PACL)NULL, FALSE ) )
		{
		pSD = NULL;
		}
     */
	pSA = &SA;
	pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
	pSA->lpSecurityDescriptor = pSD;
	pSA->bInheritHandle = FALSE;
	
	/*  init only if we are not currently initialized  */

	if (!fUtilPerfThreadInit)
		{
		/*  open the performance data area file mapping  */

		if (!(hPERFFileMap = OpenFileMapping(FILE_MAP_WRITE,FALSE,szPERFVersion)))
			return ErrERRCheck( JET_errPermissionDenied );
		if (!(pvPERFSharedData = MapViewOfFile(hPERFFileMap,FILE_MAP_WRITE,0,0,0)))
			{
			err = ErrERRCheck( JET_errPermissionDenied );
			goto CloseFileMap;
			}

		/*  open/create the performance data collect done event  */

		sprintf(szT,"Done:  %.246s",szPERFVersion);
		if (!(hPERFDoneEvent = CreateEvent(pSA,FALSE,FALSE,szT)))
			{
			if (GetLastError() == ERROR_ALREADY_EXISTS)
				hPERFDoneEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,szT);
			}
		if (!hPERFDoneEvent)
			{
			err = ErrERRCheck( JET_errPermissionDenied );
			goto UnmapFileMap;
			}

		/*  create/open the performance data area mutex, but do not acquire  */

		sprintf(szT,"Access:  %.246s",szPERFVersion);
		if (!(hPERFSharedDataMutex = CreateMutex(pSA,FALSE,szT)))
			{
            if (GetLastError() == ERROR_ALREADY_EXISTS)
                hPERFSharedDataMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, szT);
            }
        if (!hPERFSharedDataMutex)
            {
			err = ErrERRCheck( JET_errPermissionDenied );
			goto FreeEvent;
			}

		/*  initialize all objects/counters  */

		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
			if (rgpicfPERFICF[dwCurObj](ICFInit,NULL))
				{
				for (dwCurObj--; (dwCurObj & 0x80000000) == 0; dwCurObj--)
					rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
					
				err = ErrERRCheck( JET_errPermissionDenied );
				goto FreeMutex;
				}
			}

		for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
			{
			if (rgpcefPERFCEF[dwCurCtr](CEFInit,NULL))
				{
				for (dwCurCtr--; (dwCurCtr & 0x80000000) == 0; dwCurCtr--)
					rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);
				for (dwCurObj = dwPERFNumObjects-1; (dwCurObj & 0x80000000) == 0; dwCurObj--)
					rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
					
				err = ErrERRCheck( JET_errPermissionDenied );
				goto FreeMutex;
				}
			}

			/*  initialize counter offsets and calculate instance size from template data  */

		ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
		ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
		cbMaxCounterBlockSize = sizeof(PERF_COUNTER_BLOCK);
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
			ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
			dwOffset = sizeof(PERF_COUNTER_BLOCK);
			for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
				{
				ppcdCounterSrc->CounterOffset = dwOffset;
				dwOffset += ppcdCounterSrc->CounterSize;
				
				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
				}
			
			cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);
			
			ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			}
		cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

		/*  set collect count to collect count of performance DLL  */

		psda = (PSDA)pvPERFSharedData;
		cCollect = psda->cCollect - 1;

		/*  initialization succeeded  */

		fUtilPerfThreadInit = fTrue;
		}

    FreeGenericACL(pAcl);

	return JET_errSuccess;

FreeMutex:
	ErrUtilCloseHandle(hPERFSharedDataMutex);
	hPERFSharedDataMutex = NULL;
FreeEvent:
	ErrUtilCloseHandle(hPERFDoneEvent);
	hPERFDoneEvent = NULL;
UnmapFileMap:
	UnmapViewOfFile(pvPERFSharedData);
	pvPERFSharedData = NULL;
CloseFileMap:
	ErrUtilCloseHandle(hPERFFileMap);
	hPERFFileMap = NULL;
    FreeGenericACL(pAcl);
	return err;
	}


void UtilPerfThreadTerm(void)
	{
	DWORD dwCurObj;
	DWORD dwCurCtr;
	
	/*  perform termination tasks, if we ever initialized  */

	if (fUtilPerfThreadInit)
		{
		/*  terminate all counters/objects  */

		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			(void)rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
		for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
			(void)rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);

		/*  free all resources  */
			
		ErrUtilCloseHandle(hPERFSharedDataMutex);
		hPERFSharedDataMutex = NULL;
		ErrUtilCloseHandle(hPERFDoneEvent);
		hPERFDoneEvent = NULL;
		UnmapViewOfFile(pvPERFSharedData);
		pvPERFSharedData = NULL;
		ErrUtilCloseHandle(hPERFFileMap);
		hPERFFileMap = NULL;

		fUtilPerfThreadInit = fFalse;
		}
	}


/*  Performance Data thread  */

DWORD UtilPerfThread(DWORD parm)
	{
	DWORD errWin;
	DWORD dwCurObj;
	DWORD dwCurInst;
	DWORD dwCurCtr;
	DWORD dwCollectCtr;
	CHAR szT[_MAX_PATH];
	char *rgszT[1];
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceDest;
	PPERF_COUNTER_DEFINITION ppcdCounterSrc;
	PPERF_COUNTER_BLOCK ppcbCounterBlockDest;
	DWORD cInstances;
	DWORD cbSpaceNeeded;
	PSDA psda;
	LPVOID pvBlock;
	LPWSTR lpwszInstName;
	
	HANDLE rghObjects[2];

	rghObjects[0] = (HANDLE)sigPERFEndDataThread;
	rghObjects[1] = hPERFCollectSem;

	for(;;)
		{
		/*  wait to either be killed or to collect data
		/**/
		UtilSignalReset(sigPERFEndDataThread);
		Sleep( 0 );
		errWin = WaitForMultipleObjects(2,rghObjects,FALSE,INFINITE);

		/*  if we were killed, adios
		/**/
		if ( errWin == WAIT_OBJECT_0 + 0 )
			break;

		/*  if we did not receive a collect semaphore, try again
		/**/
		if ( errWin != WAIT_OBJECT_0 + 1 )
			continue;

		/*  initialize performance thread resources.  If the init fails,
		/*  we'll simply abort and try again next time
		/**/
		if ( ErrUtilPerfThreadInit() < 0 )
			{
			cCollect++;
			continue;
			}

		/*  if we have previously filled a data block during this collection call, then
		/*  one of the scheduled processes must have gone away, so immediately signal the
		/*  performance DLL that we are done and it will subtract the remaining process
		/*  count from the process count semaphore to prevent future wait time outs.  Note
		/*  that this will happen only if a process crashes or is forcefully killed
		/**/
		psda = (PSDA)pvPERFSharedData;
		if (cCollect == psda->cCollect)
			{
			SetEvent(hPERFDoneEvent);
			continue;
			}

		/*  collect instances for all objects
		/**/
		for ( dwCurObj = 0, cInstances = 0; dwCurObj < dwPERFNumObjects; dwCurObj++ )
			{
			rglPERFNumInstances[dwCurObj] = rgpicfPERFICF[dwCurObj](ICFData,&rgwszPERFInstanceList[dwCurObj]);
			cInstances += rglPERFNumInstances[dwCurObj];
			}

		/*  calculate space needed to store instance data
		/*
		/*  Instance data for all objects is stored in our data block
		/*  in the following format:
		/*
		/*      //  Object 1
		/*      DWORD cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*      . . .
		/*
		/*      //  Object n
		/*      DWORD cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*  The performance DLL can read this structure because it also
		/*  knows how many objects we have and it can also check for the
		/*  end of our data block.
		/*
		/*  NOTE:  If an object has 0 instances, it only has cInstances
		/*      for its data.  No PIDs are produced.
		/**/
		cbSpaceNeeded = cInstances*cbInstanceSize + sizeof(DWORD)*dwPERFNumObjects;

		/*  get a lock on shared memory
		/**/
		WaitForSingleObject(hPERFSharedDataMutex,INFINITE);

		/*  verify that we have sufficient store to collect our data
		/**/
		if (psda->cbAvail < sizeof(DWORD) + cbSpaceNeeded)
			{
			/*  insufficient free store:  don't collect data this time
			/*
			/*  NOTE:  this should NEVER happen if constants are set correctly
			/**/
			sprintf(szT,"Insufficient free store to collect data for %S [%ldb available/%ldb needed].  Increase PERF_SIZEOF_SHARED_DATA in perfdata.h.",
				wszProcName,psda->cbAvail,sizeof(DWORD) + cbSpaceNeeded);
#ifdef DEBUG
			AssertFail(szT,__FILE__,__LINE__);
#endif
			rgszT[0] = szT;
			UtilReportEvent( EVENTLOG_ERROR_TYPE, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			ReleaseMutex( hPERFSharedDataMutex );
		  	goto InstDone;
			}

		/*  allocate space for our data
		/**/
//		sprintf(szT,"JET [%S] filling block #%ld...",wszProcName,psda->iNextBlock);
//		rgszT[0] = szT;
//		UtilReportEvent( EVENTLOG_WARNING_TYPE, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
		
		psda->cbAvail -= sizeof(DWORD) + cbSpaceNeeded;
		psda->ibTop -= cbSpaceNeeded;
		psda->ibBlockOffset[psda->iNextBlock++] = psda->ibTop;

		/*	get a pointer to our data block
		/**/
		pvBlock = (void *)((CHAR *)pvPERFSharedData + psda->ibTop);

		/*  release our lock on shared memory
		/**/
		ReleaseMutex(hPERFSharedDataMutex);

		/*	loop through all objects, filling our block with instance data
		/**/
		dwCurCtr = 0;
		ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
		ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
			/*	write the number of instances for this object to the block
			/**/
			*((DWORD *)pvBlock) = rglPERFNumInstances[dwCurObj];

			/*  get current instance name list
			/**/
			lpwszInstName = rgwszPERFInstanceList[dwCurObj];

			/*  loop through each instance
			/**/
			ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)pvBlock + sizeof(DWORD));
			for ( dwCurInst = 0; dwCurInst < (DWORD)rglPERFNumInstances[dwCurObj]; dwCurInst++ )
				{
				/*	initialize instance/counter block from template data
				/**/
				memcpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,ppidInstanceSrc->ByteLength);
				ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppidInstanceDest + ppidInstanceDest->ByteLength);
				memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
				ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;

				/*	no unique instance ID
				/**/
				ppidInstanceDest->UniqueID = PERF_NO_UNIQUE_ID;

				/*  NOTE:  performance DLL sets object hierarchy information  */

				/*	write instance name to buffer
				/**/
				ppidInstanceDest->NameLength = (wcslen(lpwszInstName)+1)*sizeof(wchar_t);
				memcpy((void *)((char *)ppidInstanceDest + ppidInstanceDest->NameOffset),(void *)lpwszInstName,ppidInstanceDest->NameLength);
				lpwszInstName += wcslen(lpwszInstName)+1;

				/*  collect counter data for this instance
				/**/
				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				for (dwCollectCtr = 0; dwCollectCtr < ppotObjectSrc->NumCounters; dwCollectCtr++)
					{
					rgpcefPERFCEF[dwCollectCtr + dwCurCtr](dwCurInst,(void *)((char *)ppcbCounterBlockDest + ppcdCounterSrc->CounterOffset));
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
					}
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest + cbInstanceSize);
				}
			dwCurCtr += ppotObjectSrc->NumCounters;
			ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			pvBlock = (void *)((CHAR *)pvBlock + sizeof(DWORD) + cbInstanceSize * rglPERFNumInstances[dwCurObj]);
			}

		/*	write generated data to the event log
		/**/
//		rgszT[0] = (char *)szT;
//		
//		ReportEvent(
//			hEventSource,
//			EVENTLOG_WARNING_TYPE,
//			(WORD)PERFORMANCE_CATEGORY,
//			PLAIN_TEXT_ID,
//			0,
//			1,
//			cbSpaceNeeded,
//			rgszT,
//			(void *)((CHAR *)pvPERFSharedData + psda->ibTop));

		/*	if we are the last one done, let the performance DLL know
		/**/
InstDone:
		cCollect++;
		if (!InterlockedDecrement(&psda->dwProcCount))
			SetEvent(hPERFDoneEvent);
		}

	/*  terminate performance thread resources  */

	UtilPerfThreadTerm();

	return 0;
	}

#else

ERR ErrUtilPerfInit(void)
	{
	return JET_errSuccess;
	}

void UtilPerfTerm(void)
	{
	return;
	}

void UtilPerfDumpStats(char *szText)
	{
	szText == szText;
	return;
	}

#endif


/*	ErrUtilWideCharToMultiByte() adds to the functionality of WideCharToMultiByte()
/*	by returning the data in callee SAlloc()ed memory.
/**/
ERR ErrUtilWideCharToMultiByte(LPCWSTR lpcwStr, LPSTR *lplpOutStr)
	{
	int	cbStrLen;

	/*	figure out how big a buffer we need, create it, and convert the string
	/**/
	*lplpOutStr = NULL;
	cbStrLen = WideCharToMultiByte( CP_ACP, 0, lpcwStr, -1, NULL, 0, NULL, NULL);
	Assert( cbStrLen != FALSE );

	if ( ( *lplpOutStr = SAlloc(cbStrLen) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	cbStrLen = WideCharToMultiByte( CP_ACP, 0, lpcwStr, -1, *lplpOutStr, cbStrLen, NULL, NULL);
	Assert( cbStrLen != FALSE );

	return JET_errSuccess;
	}


	/*  Init/Term routines for system indirection layer  */

DWORD dwInitCount = 0;

SYSTEM_INFO siSystemConfig;


ERR ErrUtilInit( VOID )
	{
	ERR		err;

	/*  if we haven't been initialized already, perform init
	/**/
	if ( !dwInitCount )
		{
#if defined( DEBUG ) || defined( PERFDUMP )
		/*	initialize debug functions
		/**/
		if ( ( err = ErrUtilInitializeCriticalSection( &critDBGPrint ) ) < 0 )
			return err;
#endif
		/*  open the event log
		/**/
	    if ( !( hEventSource = RegisterEventSource( NULL, szVerName ) ) )
			return ErrERRCheck( JET_errPermissionDenied );

		/* alloc file extension signal
		/**/
		CallR( ErrUtilSignalCreate( &sigExtend, NULL ) );

		/* alloc file extension buffer
		/**/
		if ( !( rgbZero = PvUtilAllocAndCommit( cbZero ) ) )
			return ErrERRCheck( JET_errOutOfMemory );
		memset( rgbZero, 0, cbZero );

		/*  initialize the registry
		/**/
		(void)ErrUtilRegInit();
		
		/*  initialize performance monitoring
		/**/
		(void)ErrUtilPerfInit();

		/*  get system information
		/**/
		GetSystemInfo( &siSystemConfig );
		}

	/*  init succeeded
	/**/
	dwInitCount++;

	return JET_errSuccess;

	UtilRegTerm();
	UtilMemCheckTerm();
	DeregisterEventSource( hEventSource );
	hEventSource = NULL;
	return err;
	}


VOID UtilTerm( VOID )
	{
	/*  last one out, turn out the lights!
	/**/
	if ( !dwInitCount )
		return;
	dwInitCount--;
	if ( !dwInitCount )
		{
		/*  shutdown performance monitoring
		/**/
		UtilPerfTerm();
		
#ifdef DEBUG
		UtilDeleteCriticalSection( critDBGPrint );
#endif

		/*  close the registry
		/**/
		UtilRegTerm();

		/*  free file extension buffer
		/**/
		if ( rgbZero != NULL )
			{
			UtilFree( rgbZero );
			rgbZero = NULL;
			}

		/*  free file extension signal
		/**/
		if ( sigExtend != sigNil )
			{
			UtilCloseSignal( sigExtend );
			sigExtend = sigNil;
			}

		/*  shutdown the lower tier system indirection layer
		/**/
		UtilMemCheckTerm();

		/*  close the event log(s)
		/**/
		if ( hEventSource )
			{
			DeregisterEventSource( hEventSource );
			hEventSource = NULL;
			}
		}
	}


/***********************************************************
/******************** error handling ***********************
/***********************************************************
/**/
#ifdef DEBUG
ERR ErrERRCheck( ERR err )
	{
	/*	to trap a specific error/warning, either set your breakpoint here
	/*	or include a specific case below for the error/warning trapped
	/*	and set your breakpoint there.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			/*	invalid error
			/**/
			Assert( fFalse );
			break;

		case JET_errInvalidTableId:
			QwUtilPerfCount();
			break;

		case JET_errKeyDuplicate:
			QwUtilPerfCount();
			break;

		case JET_errDiskIO:
			QwUtilPerfCount();
			break;
			
		case JET_errReadVerifyFailure:
			QwUtilPerfCount();
			break;

		case JET_errOutOfMemory:
			QwUtilPerfCount();
			break;

		default:
			break;
		}

	return err;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\convert\conv200.h ===
#ifndef _CONV200_H_
#define _CONV200_H_

typedef enum _DB_TYPE {
    DbTypeMin,
    DbDhcp,
    DbWins,
    DbRPL,
    DbTypeMax
} DB_TYPE, *PDB_TYPE;

typedef struct _JET_PARAMS {
    INT                 ParamOrdVal;
    INT                 ParamIntVal;
    PCHAR               ParamStrVal;
    BOOL                ParamSet;
} JET_PARAMS, *PJET_PARAMS;

#define JET_paramLast   99999
#define JET_PARAM( _Param, _IntVal, _StrVal )   \
    { _Param, _IntVal, _StrVal, (( _IntVal || _StrVal ) ? TRUE : FALSE) }

#define JCONVMUTEXNAME  TEXT("JCMUTEX")

typedef struct _DEFAULT_VALUES {
    PCHAR   ParametersKey;
    PCHAR   DbNameKey;
    PCHAR   DatabaseName;
    PCHAR   SysDatabaseName;
    PCHAR   BackupPathKey;
    PCHAR   BackupPath;
} DEFAULT_VALUES, *PDEFAULT_VALUES;

#if DBG
#define DBGprintf(__print) DbgPrint __print
#else
#define DBGprintf(__print)
#endif
#endif  _CONV200_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\_cat.c ===
#define sidEngine	{0x02, 0x03}

static CODECONST(BYTE ) rgbSidEngine[] = sidEngine;

typedef struct
	{
	OBJID						objidParent;
	const CHAR 					*szName;
	OBJID						objid;
	OBJTYP  					objtyp;
	} SYSOBJECTDEF;

static CODECONST(SYSOBJECTDEF) rgsysobjdef[] =
	{
	{ objidRoot,			szTcObject, 	 	objidTblContainer, 	JET_objtypContainer }, 
	{ objidRoot,			szDcObject, 		objidDbContainer,  	JET_objtypContainer }, 
	{ objidDbContainer,		szDbObject, 	 	objidDbObject,     	JET_objtypDb } 
	};

static CODECONST(CDESC) rgcdescSo[] =
	{
	"Id", 				JET_coltypLong, 	   		JET_bitColumnNotNULL, 	0, 						
	"ParentId", 		JET_coltypLong, 	   		JET_bitColumnNotNULL, 	0, 						
	"Name", 		   	JET_coltypText, 	   		JET_bitColumnNotNULL, 	JET_cbColumnMost, 		
	"Type", 		   	JET_coltypShort, 	   		JET_bitColumnNotNULL, 	0, 						
	"DateCreate", 		JET_coltypDateTime,    		JET_bitColumnNotNULL, 	0, 						
	"DateUpdate", 		JET_coltypDateTime,    		0,		 				0, 						
	"Owner", 			JET_coltypBinary, 			0, 						JET_cbColumnMost, 		
	"Flags", 			JET_coltypLong, 	   		0, 						0, 						
	"Pages", 			JET_coltypLong,   			0, 					 	0,						
	"Density", 			JET_coltypLong,   			0, 					 	0,
	"Stats",			JET_coltypBinary,			0,						JET_cbColumnMost		
	};

JET_COLUMNID rgcolumnidSo[sizeof(rgcdescSo)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSc[] =
	{
	"ObjectId", 			JET_coltypLong, 			JET_bitColumnNotNULL, 	0, 							
	"Name", 	 			JET_coltypText, 			JET_bitColumnNotNULL, 	JET_cbColumnMost,			
	"ColumnId",				JET_coltypLong,				JET_bitColumnNotNULL,	0,							
	"Coltyp", 				JET_coltypUnsignedByte, 	JET_bitColumnNotNULL, 	0, 							
	"Length",				JET_coltypLong,				JET_bitColumnNotNULL,	0,
	"CodePage", 			JET_coltypShort, 			JET_bitColumnNotNULL, 	0, 							
	"Flags",				JET_coltypUnsignedByte,		JET_bitColumnNotNULL,	0,
	"RecordOffset",			JET_coltypShort,			0,						0,
	"DefaultValue",			JET_coltypBinary,			0,						JET_cbColumnMost,
	"PresentationOrder",	JET_coltypShort, 			0, 						0
	};

JET_COLUMNID rgcolumnidSc[sizeof(rgcdescSc)/sizeof(CDESC)];


static CODECONST(CDESC) rgcdescSi[] =
	{
	"ObjectId",				JET_coltypLong,   			JET_bitColumnNotNULL, 	0,
	"Name", 				JET_coltypText,   			JET_bitColumnNotNULL, 	JET_cbColumnMost,
	"IndexId",				JET_coltypLong,				JET_bitColumnNotNULL,	0,
	"Density",				JET_coltypLong, 	 		JET_bitColumnNotNULL, 	0,
	"LanguageId",			JET_coltypShort,			JET_bitColumnNotNULL,	0,
	"Flags",				JET_coltypShort,			JET_bitColumnNotNULL,	0,
	/*	maximum number of fields in a key is
	/*	(size of coltypBinary)/(size of FID) = 254/4 = 63
	/**/
	"KeyFldIDs",			JET_coltypBinary,			0,						JET_cbColumnMost,
	"Stats",				JET_coltypBinary,			0,						JET_cbColumnMost,
	"VarSegMac",	  		JET_coltypShort,			0,					 	0
	};

JET_COLUMNID rgcolumnidSi[sizeof(rgcdescSi)/sizeof(CDESC)];

static CODECONST(IDESC) rgidescSo[] =
	{
	(CHAR *)szSoNameIndex, 			"+ParentId\0+Name\0",	JET_bitIndexUnique | JET_bitIndexDisallowNull,
	(CHAR *)szSoIdIndex, 			"+Id\0", 	 			JET_bitIndexClustered | JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSc[] =
	{
	/*	this index IS NOT unique.
	/*	We need to keep track of deleted columns.
	/**/
	(CHAR *)szScObjectIdNameIndex,	"+ObjectId\0+Name\0", 	JET_bitIndexClustered | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSi[] =
	{
	(CHAR *)szSiObjectIdNameIndex,	"+ObjectId\0+Name\0",	JET_bitIndexClustered | JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull
	};

static CODECONST(SYSTABLEDEF) rgsystabdef[] =
	{
	szSoTable, rgcdescSo, rgidescSo, sizeof(rgcdescSo)/sizeof(CDESC), sizeof(rgidescSo)/sizeof(IDESC),1, rgcolumnidSo, 2,
	szScTable, rgcdescSc, rgidescSc, sizeof(rgcdescSc)/sizeof(CDESC), sizeof(rgidescSc)/sizeof(IDESC),4, rgcolumnidSc, 4,
	szSiTable, rgcdescSi, rgidescSi, sizeof(rgcdescSi)/sizeof(CDESC), sizeof(rgidescSi)/sizeof(IDESC),1, rgcolumnidSi, 9,
	};

#define csystabs ( sizeof(rgsystabdef) / sizeof(SYSTABLEDEF) )

#define szSqAttribute 			rgidescSq[0].szIdxName
#define szSaceId  				rgidescSp[0].szIdxName

#define cSysIdxs			2 	// The max. number of indexes for any systable.
#define cSysIdxFlds			2 	// The max. number of fields in each systable index.

#define cScColsOfInterest	7	// The number of columns of Sc we currently use
								// to populate a FIELD structure.

#define cSiColsOfInterest	7 	// The number of columns of Si we currently use
								// to populate an IDD structure.

#define CATIGetColumnid( iTable, iField )	(rgsystabdef[iTable].rgcolumnid[iField])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eapolcfg.h ===
extern "C" {
#include "ntddndis.h"
#include "wzcsapi.h"
}

#pragma once

#define EAPOL_CTL_LOCKED    0x00000001
//
// CEapolConfig
//
class CEapolConfig
{
public:
    DWORD               m_dwCtlFlags;

    CEapolConfig();
    ~CEapolConfig();
    DWORD CopyEapolConfig(CEapolConfig *pEapolConfig);
    DWORD LoadEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid);
    DWORD SaveEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid);
    EAPOL_INTF_PARAMS   m_EapolIntfParams;
    DTLLIST             *m_pListEapcfgs;
    BOOL Is8021XEnabled();
    VOID Set8021XState(BOOLEAN fSet);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\precomp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module contains the header files that needed to included across 
    various source files


Revision History:

    sachins, Dec 04 2001, Created
   
Notes:

    Maintain the order of the include files, at the top being vanilla
    definitions files, bottom being dependent definitions

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <rtutils.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <wzccrypt.h>
#include <tls1key.h>
#include <spbasei.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\spbasei.h ===
#ifdef __cplusplus
extern "C" {
#endif

#define MULTI_THREADED
#include "schannel.h"
#include <sha.h>
#include <md2.h>
#include <rc2.h>
#include <rc4.h>
#include <md5.h>

#ifdef __cplusplus
}
#endif


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eluidlg.h ===
//
// String identifiers
//

#define SID_AuthenticationFailed 1
#define SID_GetUserIdentity 2
#define SID_GetUserNamePassword 3
#define SID_InvokeInteractiveUI 4
#define SID_NoCertificateFound 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\tls1key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner    :ramas
*   Date         :5/03/97
*   description        : Main Crypto functions for TLS1
*----------------------------------------------------------------------------*/
#ifndef _TLS1KEY_H_
#define _TLS1KEY_H_

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    );

#endif //_TLS1KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\tls1key.c ===
#include <precomp.h>
#pragma hdrstop

#define SafeAllocaAllocateWZC(pData, cbData) \
{ \
    pData = LocalAlloc (LPTR, cbData); \
}

#define SafeAllocaFreeWZC(pData) \
{ \
    LocalFree (pData); \
}


#define HMAC_K_PADSIZE              64

BOOL MyPrimitiveSHA(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;

            
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;

    return fRet;
}                                

BOOL MyPrimitiveMD5(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[MD5DIGESTLEN])
{
    BOOL fRet = FALSE;
    MD5_CTX   sMD5Hash;

            
    MD5Init(&sMD5Hash);
    MD5Update(&sMD5Hash, (BYTE *) pbData, cbData);
    MD5Final(&sMD5Hash);
    memcpy(rgbHash, sMD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;

    return fRet;
}                                

BOOL MyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial, 
        DWORD       cbKeyMaterial,
        PBYTE       pbData, 
        DWORD       cbData,
        ALG_ID      Algid,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BYTE    rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    BOOL    fRet = FALSE;

    BYTE    rgbKipad[HMAC_K_PADSIZE];
    BYTE    rgbKopad[HMAC_K_PADSIZE];
    DWORD   dwBlock;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    
    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    if (CALG_SHA1 == Algid)
    {
        // do this inline since it would require data copy
        A_SHA_CTX   sSHAHash;
        BYTE        HashVal[A_SHA_DIGEST_LEN];

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, HashVal, A_SHA_DIGEST_LEN);

        if (!MyPrimitiveSHA(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + A_SHA_DIGEST_LEN,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // do this inline since it would require data copy
        MD5_CTX   sMD5Hash;
            
        MD5Init(&sMD5Hash);
        MD5Update(&sMD5Hash, rgbKipad, HMAC_K_PADSIZE);
        MD5Update(&sMD5Hash, pbData, cbData);
        MD5Final(&sMD5Hash);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sMD5Hash.digest, MD5DIGESTLEN);

        if (!MyPrimitiveMD5(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + MD5DIGESTLEN,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;    
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS 
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    ALG_ID Algid,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];      
    DWORD   iKey;
    DWORD   cbHash;

    PBYTE   pbAofiDigest = NULL;

    SafeAllocaAllocateWZC(pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN);
    if (NULL == pbAofiDigest)
        goto Ret;

    if (CALG_SHA1 == Algid)
    {
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        cbHash = MD5DIGESTLEN;
    }

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    // build A(1)
    if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed,
                              Algid, pbAofiDigest))
        goto Ret;

    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[cbHash], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest,
                                  cbSeed + cbHash, Algid, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        if(cbKeyOut < cbHash)
        {
            CopyMemory(pbKeyOut, rgbDigest, cbKeyOut);
            break;
        }
        else
        {
            CopyMemory(pbKeyOut, rgbDigest, cbHash);
            pbKeyOut += cbHash;
        }

        cbKeyOut -= cbHash;

        // build A(i) = HMAC(key, A(i-1))
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbHash,
                                  Algid, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbAofiDigest)
        SafeAllocaFreeWZC(pbAofiDigest);

    return fRet;
}

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    )
{
    BYTE    *pbBuff = NULL;
    BYTE    *pbLabelAndSeed = NULL;
    DWORD   cbLabelAndSeed;
    DWORD   cbOdd;
    DWORD   cbHalfSecret;
    DWORD   i;
    BOOL    fRet = FALSE;

    cbOdd = cbSecret % 2;
    cbHalfSecret = cbSecret / 2;

    cbLabelAndSeed = cbLabel + cbSeed;
    SafeAllocaAllocateWZC(pbLabelAndSeed, cbLabelAndSeed);
    if (NULL == pbLabelAndSeed)
        goto Ret;
    SafeAllocaAllocateWZC(pbBuff, cbKeyOut);
    if (NULL == pbBuff)
        goto Ret;

    // copy label and seed into one buffer
    memcpy(pbLabelAndSeed, pbLabel, cbLabel);
    memcpy(pbLabelAndSeed + cbLabel, pbSeed, cbSeed);

    // Use P_hash to calculate MD5 half
    if (!P_Hash(pbSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_MD5, pbKeyOut, cbKeyOut))
        goto Ret;

    // Use P_hash to calculate SHA half
    if (!P_Hash(pbSecret + cbHalfSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_SHA1, pbBuff, cbKeyOut))
        goto Ret;

    // XOR the two halves
    for (i=0;i<cbKeyOut;i++)
    {
        pbKeyOut[i] = pbKeyOut[i] ^ pbBuff[i];
    }
    fRet = TRUE;
Ret:
    if (pbBuff)
        SafeAllocaFreeWZC(pbBuff);
    if (pbLabelAndSeed)
        SafeAllocaFreeWZC(pbLabelAndSeed);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\crypt\src\wzccrypt.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    wzcsec.c

Abstract:

    This module contains code for providing security functions


Revision History:

    sachins, Dec 04 2001, Created

--*/

#include "precomp.h"
#pragma hdrstop

UCHAR   SHApad1[40] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
UCHAR   SHApad2[40] = {0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2};

VOID
GetNewKeyFromSHA (
        IN  UCHAR   *StartKey,
        IN  UCHAR   *SessionKey,
        IN  DWORD   SessionKeyLength,
        OUT UCHAR   *InterimKey 
        )
{
    A_SHA_CTX       Context;
    UCHAR           Digest[A_SHA_DIGEST_LEN];

    ZeroMemory(Digest, A_SHA_DIGEST_LEN);

    A_SHAInit(&Context);
    A_SHAUpdate(&Context, StartKey, SessionKeyLength);
    A_SHAUpdate(&Context, SHApad1, 40);
    A_SHAUpdate(&Context, SessionKey, SessionKeyLength);
    A_SHAUpdate(&Context, SHApad2, 40);
    A_SHAFinal(&Context, Digest);

    CopyMemory (InterimKey, Digest, SessionKeyLength);
}


#define     MAX_TOTAL_KEY_LENGTH        128
#define     MAX_TOTAL_IV_LENGTH         64

DWORD
GenerateMasterSessionKeys (
    PBYTE   pbSecret,
    DWORD   cbSecret,
    PBYTE   pbRandom,
    DWORD   cbRandom,
    PMASTER_SESSION_KEYS    pMasterSessionKeys
    )
{
    BYTE    bPRF1[MAX_TOTAL_KEY_LENGTH]={0}, bPRF2[MAX_TOTAL_IV_LENGTH]={0};
    BOOL    fResult = FALSE;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        fResult = PRF (   
                pbSecret, 
                cbSecret, 
                csz_CLIENT_EAP_ENCRYPTION, 
                strlen (csz_CLIENT_EAP_ENCRYPTION),
                pbRandom,
                cbRandom,
                bPRF1,
                MAX_TOTAL_KEY_LENGTH
                );

        if (!fResult)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        CopyMemory ((PBYTE)pMasterSessionKeys, 
                bPRF1, 
                MAX_TOTAL_KEY_LENGTH);

        fResult = PRF (   
                pbSecret, 
                cbSecret, 
                csz_CLIENT_EAP_ENCRYPTION,
                strlen(csz_CLIENT_EAP_ENCRYPTION),
                pbRandom,
                cbRandom,
                bPRF2,
                MAX_TOTAL_IV_LENGTH
                );

        if (!fResult)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        CopyMemory ((PBYTE)pMasterSessionKeys+MAX_TOTAL_KEY_LENGTH, 
                bPRF2, 
                MAX_TOTAL_IV_LENGTH);
    }
    while (FALSE);
    
    return dwRetCode;
}


DWORD
DeriveSessionKeys (
    PBYTE       pbMasterSendKey,
    PBYTE       pbMasterReceiveKey,
    DWORD       dwSessionKeyLength,
    PSESSION_KEYS   pSessionKeys
    )
{
    PBYTE   pbSendKey = pSessionKeys->bSendKey;
    PBYTE   pbReceiveKey = pSessionKeys->bReceiveKey;
    DWORD   dwEffectiveMasterKeyLength = 0;
    BOOLEAN fReduceKeysStrength = FALSE;
    DWORD   dwRetCode = NO_ERROR;

    switch (dwSessionKeyLength*8)
    {
        case 40:
            fReduceKeysStrength = TRUE;
        case 56:
            dwEffectiveMasterKeyLength = 8;
            break;
        case 104:
            fReduceKeysStrength = TRUE;
        case 128:
            dwEffectiveMasterKeyLength = 16;
            break;
        case 168:
            fReduceKeysStrength = TRUE;
        case 192:
            dwEffectiveMasterKeyLength = 24;
            break;
        default:
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
    }
    if (dwRetCode != NO_ERROR)
    {
        return dwRetCode;
    }

    do
    {
        GetNewKeyFromSHA (
                pbMasterSendKey, 
                pbMasterSendKey, 
                dwEffectiveMasterKeyLength,
                pSessionKeys->bSendKey
                );

        GetNewKeyFromSHA (
                pbMasterReceiveKey, 
                pbMasterReceiveKey, 
                dwEffectiveMasterKeyLength,
                pSessionKeys->bReceiveKey
                );

        if (fReduceKeysStrength)
        {
            pbSendKey[0] = pbReceiveKey[0]= 0xD1;
            pbSendKey[1] = pbReceiveKey[1]= 0x26;
            pbSendKey[2] = pbReceiveKey[2]= 0x9E;
        }
    }
    while (FALSE);

    return dwRetCode;
}


#define     NUM_IGNORE_BYTES        3

DWORD
GenerateDynamicKeys (
        IN  PBYTE   pbMasterSecret,
        IN  DWORD   dwMasterSecretLength,
        IN  PBYTE   pbRandom,
        IN  DWORD   dwRandomLength,
        IN  DWORD   dwDynamicKeyLength,
        OUT SESSION_KEYS *pSessionKeys
        )
{
    MASTER_SESSION_KEYS     MasterKeys = {0};
    SESSION_KEYS            SessionKeys = {0};
    BOOLEAN                 fIgnoreThreeLeadingBytes = FALSE;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        if (IsBadWritePtr(pSessionKeys, sizeof(SESSION_KEYS)))
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }

        switch (dwDynamicKeyLength*8)
        {
            case 40:
            case 104:
            case 168:
                fIgnoreThreeLeadingBytes = TRUE;
                break;
        }
        if ((dwRetCode = GenerateMasterSessionKeys (
                            pbMasterSecret,
                            dwMasterSecretLength,
                            pbRandom,
                            dwRandomLength,
                            &MasterKeys
                            )) != NO_ERROR)
        {
            break;
        }

        // Use Peer Encryption (P->A) key as the Master Send Key
        // Use Authenticator Encryption (A->P) key as the Master Receive Key
        if ((dwRetCode = DeriveSessionKeys (
                            MasterKeys.bPeerEncryptionKey,
                            MasterKeys.bAuthenticatorEncryptionKey,
                            dwDynamicKeyLength,
                            &SessionKeys
                            )) != NO_ERROR)
        {
            break;
        }

        ZeroMemory(pSessionKeys, sizeof(SESSION_KEYS));
        pSessionKeys->dwKeyLength = dwDynamicKeyLength;
        memcpy(pSessionKeys->bSendKey,
               SessionKeys.bSendKey + (fIgnoreThreeLeadingBytes?NUM_IGNORE_BYTES:0),
               dwDynamicKeyLength);
        memcpy(pSessionKeys->bReceiveKey,
               SessionKeys.bReceiveKey + (fIgnoreThreeLeadingBytes?NUM_IGNORE_BYTES:0),
               dwDynamicKeyLength);
    }
    while (FALSE);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eapolcfg.cpp ===
#include <precomp.h>
#include "eapolcfg.h"

#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))

////////////////////////////////////////////////////////////////////////
// CEapolConfig related stuff
//
//+---------------------------------------------------------------------------
// constructor
CEapolConfig::CEapolConfig()
{
    m_dwCtlFlags = 0;
    ZeroMemory(&m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    m_pListEapcfgs = NULL;
}

//+---------------------------------------------------------------------------
// destructor
CEapolConfig::~CEapolConfig()
{
    ZeroMemory(&m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    if (m_pListEapcfgs != NULL)
    {
        DtlDestroyList (m_pListEapcfgs, DestroyEapcfgNode);
        m_pListEapcfgs = NULL;
    }
}

//+---------------------------------------------------------------------------
DWORD CEapolConfig::CopyEapolConfig(CEapolConfig *pEapolConfig)
{
    DTLLIST     *pListEapcfgs = NULL;
    DTLNODE     *pCopyNode = NULL, *pInNode = NULL;
    DWORD       dwErr = ERROR_SUCCESS;

    if (pEapolConfig)
    {
        pListEapcfgs = ::ReadEapcfgList (EAPOL_MUTUAL_AUTH_EAP_ONLY);
        if (pListEapcfgs)
        {
            for (pCopyNode = DtlGetFirstNode(pListEapcfgs);
                 pCopyNode;
                 pCopyNode = DtlGetNextNode(pCopyNode))
            {
                EAPCFG* pCopyEapcfg = (EAPCFG* )DtlGetData(pCopyNode);
                for (pInNode = DtlGetFirstNode(pEapolConfig->m_pListEapcfgs);
                        pInNode;
                        pInNode = DtlGetNextNode(pInNode))
                {
                    EAPCFG* pInEapcfg = (EAPCFG* )DtlGetData(pInNode);
                    if (pCopyEapcfg->dwKey == pInEapcfg->dwKey)
                    {
                        if ((pCopyEapcfg->pData = (PBYTE) MALLOC (pInEapcfg->cbData)) == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        memcpy (pCopyEapcfg->pData, pInEapcfg->pData, pInEapcfg->cbData);
                        pCopyEapcfg->cbData = pInEapcfg->cbData;
                        break;
                    }
                }
                if (dwErr != NO_ERROR)
                {
                    goto LExit;
                }
            }
        }
        m_pListEapcfgs = pListEapcfgs;
        memcpy (&m_EapolIntfParams, &pEapolConfig->m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    }
    else
    {
        dwErr = ERROR_INVALID_DATA;
    }

LExit:
    if (dwErr != ERROR_SUCCESS && pListEapcfgs != NULL)
    {
        DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
    }
    return dwErr;
}



//+---------------------------------------------------------------------------
DWORD CEapolConfig::LoadEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid)
{
    DWORD       dwErr = ERROR_SUCCESS;
    BYTE        *pbData = NULL;
    DWORD       cbData = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    DTLLIST     *pListEapcfgs = NULL;

    // Initialize EAP package list
    // Read the EAPCFG information from the registry and find the node
    // selected in the entry, or the default, if none.

    do
    {
        DTLNODE* pNode = NULL;

        // Read the EAPCFG information from the registry and find the node
        // selected in the entry, or the default, if none.

        pListEapcfgs = ::ReadEapcfgList (EAPOL_MUTUAL_AUTH_EAP_ONLY);

        if (pListEapcfgs)
        {

            DTLNODE*            pNodeEap;
            DWORD               dwkey = 0;

            // Read the EAP params for this interface

            ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
            EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
            EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
            if (pndSsid)
            {
                EapolIntfParams.dwSizeOfSSID = pndSsid->SsidLength;
                memcpy (EapolIntfParams.bSSID, pndSsid->Ssid, pndSsid->SsidLength);
            }
            else
            {
                // If NULL SSID, this will get default EAPOL values
                EapolIntfParams.dwSizeOfSSID = 1;
            }
            dwErr = WZCEapolGetInterfaceParams (
                        NULL,
                        wszIntfGuid,
                        &EapolIntfParams);

            if (dwErr != ERROR_SUCCESS)
                break;

            memcpy (&m_EapolIntfParams, &EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));

            // Read the EAP configuration info for all EAP packages

            for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap))
            {
                EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
                ASSERT( pEapcfg );

                dwErr = ERROR_SUCCESS;
                pbData = NULL;

                    cbData = 0;

                    // Get the size of the EAP blob

                    dwErr = WZCEapolGetCustomAuthData(
                                    NULL,
                                    wszIntfGuid,
                                    pEapcfg->dwKey,
                                    EapolIntfParams.dwSizeOfSSID,
                                    EapolIntfParams.bSSID,
                                    NULL,
                                    &cbData
                                    );
                    if (dwErr != ERROR_SUCCESS)
                    {
                        if ((EapolIntfParams.dwSizeOfSSID != 0) &&
                            (dwErr == ERROR_FILE_NOT_FOUND))
                        {


                            // The Last Used SSID did not have a connection
                            // blob created. Call again for size of blob with
                            // NULL SSID

                            EapolIntfParams.dwSizeOfSSID = 0;

                            // Get the size of the EAP blob

                            dwErr = WZCEapolGetCustomAuthData (
                                            NULL,
                                            wszIntfGuid,
                                            pEapcfg->dwKey,
                                            0,
                                            NULL,
                                            NULL,
                                            &cbData
                                            );
                        }

                        if (dwErr == ERROR_BUFFER_TOO_SMALL)
                        {
                            if (cbData <= 0)
                            {
                                // No EAP blob stored in the registry
                                pbData = NULL;

                                // Will continue processing for errors
                                // Not exit
                                dwErr = ERROR_SUCCESS;

                            }
                            else
                            {
                                // Allocate memory to hold the blob

                                pbData = (PBYTE) MALLOC (cbData);

                                if (pbData == NULL)
                                {
                                    dwErr = ERROR_SUCCESS;
                                    continue;
                                }
                                ZeroMemory (pbData, cbData);

                                dwErr = WZCEapolGetCustomAuthData (
                                            NULL,
                                            wszIntfGuid,
                                            pEapcfg->dwKey,
                                            EapolIntfParams.dwSizeOfSSID,
                                            EapolIntfParams.bSSID,
                                            pbData,
                                            &cbData
                                            );

                                if (dwErr != ERROR_SUCCESS)
                                {
                                    FREE ( pbData );
                                    dwErr = ERROR_SUCCESS;
                                    continue;
                                }
                            }
                        }
                        else
                        {
                            dwErr = ERROR_SUCCESS;
                            continue;
                        }
                    }
                    else
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    if (pEapcfg->pData != NULL)
                    {
                        FREE ( pEapcfg->pData );
                    }
                    pEapcfg->pData = (UCHAR *)pbData;
                    pEapcfg->cbData = cbData;
            }

            m_pListEapcfgs = pListEapcfgs;
        }
        else
        {
            dwErr = ERROR_INVALID_DATA;
        }

    } while (FALSE);

    return dwErr;
}


//+---------------------------------------------------------------------------
DWORD CEapolConfig::SaveEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid)
{
    WCHAR       *pwszLastUsedSSID = NULL;
    DWORD       dwEapFlags = 0;
    DWORD       dwErrOverall = ERROR_SUCCESS;
    DWORD       dwErr = ERROR_SUCCESS;

    // Save the EAP configuration data into the registry

    DTLNODE* pNodeEap = NULL;

    dwErr = ERROR_SUCCESS;

    // Save data for all EAP packages in the registry

    if (m_pListEapcfgs == NULL)
    {
        return ERROR_SUCCESS;
    }
            
    if (pndSsid)
    {
        m_EapolIntfParams.dwSizeOfSSID = pndSsid->SsidLength;
        memcpy (m_EapolIntfParams.bSSID, pndSsid->Ssid, pndSsid->SsidLength);
    }

    for (pNodeEap = DtlGetFirstNode(m_pListEapcfgs);
         pNodeEap;
         pNodeEap = DtlGetNextNode(pNodeEap))
    {
        EAPCFG* pcfg = (EAPCFG* )DtlGetData(pNodeEap);
        if (pcfg == NULL)
        {
            continue;
        }

        dwErr = ERROR_SUCCESS;

        // ignore error and continue with next

        dwErr = WZCEapolSetCustomAuthData (
                    NULL,
                    wszIntfGuid,
                    pcfg->dwKey,
                    m_EapolIntfParams.dwSizeOfSSID,
                    m_EapolIntfParams.bSSID,
                    pcfg->pData,
                    pcfg->cbData);

        if (dwErr != ERROR_SUCCESS)
        {
            dwErrOverall = dwErr;
            dwErr = ERROR_SUCCESS;
        }
    }

    if (m_dwCtlFlags & EAPOL_CTL_LOCKED)
        m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;

    dwErr = WZCEapolSetInterfaceParams (
                NULL,
                wszIntfGuid,
                &m_EapolIntfParams);

    if (dwErrOverall != ERROR_SUCCESS)
    {
        dwErr = dwErrOverall;
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
BOOL CEapolConfig::Is8021XEnabled()
{
    return (IS_EAPOL_ENABLED(m_EapolIntfParams.dwEapFlags));
}
    
//+---------------------------------------------------------------------------
VOID CEapolConfig::Set8021XState(BOOLEAN fSet)
{
    if (fSet)
        m_EapolIntfParams.dwEapFlags |= EAPOL_ENABLED;
    else
        m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eldefs.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eldefs.h

Abstract:

    The module contains various
    . constants
    . definitions
    . macros
    for the following functions:
      - memory-allocation
      - logging
      - tracing

Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOLUI_DEFS_H_
#define _EAPOLUI_DEFS_H_


// Constants

#define TRACEID                     g_dwTraceId
#define LOGHANDLE                   g_hLogEvents


// MEMORY ALLOCATION

// MACROS

#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))


//
// TRACING
//

// Definitions
#define EAPOL_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAPOL           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAP             ((DWORD)0x00020000 | TRACE_USE_MASK)
#define EAPOL_TRACE_INIT            ((DWORD)0x00040000 | TRACE_USE_MASK)
#define EAPOL_TRACE_DEVICE          ((DWORD)0x00080000 | TRACE_USE_MASK)
#define EAPOL_TRACE_LOCK            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define EAPOL_TRACE_PORT            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define EAPOL_TRACE_TIMER           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define EAPOL_TRACE_USER            ((DWORD)0x00800000 | TRACE_USE_MASK)
#define EAPOL_TRACE_NOTIFY          ((DWORD)0x01000000 | TRACE_USE_MASK)


// Macros
//

#if 0
#define TRACE0(l,a)                                                     \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a)
#define TRACE1(l,a,b)                                                   \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)                                                 \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)                                               \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)                                             \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)                                           \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f)
#define TRACE6(l,a,b,c,d,e,f,g)                                         \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f, g)

#define EAPOL_DUMPW(pBuf,dwBuf)                                                \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,4,1,NULL)

#define EAPOL_DUMPB(pbBuf,dwBuf)                                        \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)
#define EAPOL_DUMPBA(pbBuf,dwBuf)                                        \
        TraceDumpExA(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)
#else
#define TRACE0(l,a)                                                     
#define TRACE1(l,a,b)                                                  
#define TRACE2(l,a,b,c)                                               
#define TRACE3(l,a,b,c,d)                                            
#define TRACE4(l,a,b,c,d,e)                                         
#define TRACE5(l,a,b,c,d,e,f)                                      
#define TRACE6(l,a,b,c,d,e,f,g)                                   

#define EAPOL_DUMPW(pBuf,dwBuf)                                                
#define EAPOL_DUMPB(pbBuf,dwBuf)
#define EAPOL_DUMPBA(pbBuf,dwBuf)
#endif


//
// EVENT LOGGING
//

#define EapolLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    RouterLogError( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray,    \
                    dwRetCode )

#define EapolLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    RouterLogWarning( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray, 0 )

#define EapolLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    RouterLogInformation(g_hLogEvents,LogId, NumStrings, lpwsSubStringArray,0)

#define EapolLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    RouterLogErrorString( g_hLogEvents, LogId, NumStrings,                  \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    RouterLogWarningString( g_hLogEvents, LogId, NumStrings,                \
                           lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    RouterLogInformationString( g_hLogEvents, LogId,                        \
                                NumStrings, lpwsSubStringArray, dwRetCode,dwPos)


#endif // _EAPOLUI_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eluiuser.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    
    eluser.c


Abstract:

    The module deals with functions related to user interaction, user logon


Revision History:

    sachins, Apr 22 2001, Created

--*/


#include "precomp.h"
#pragma hdrstop

#define cszEapKeyRas   TEXT("Software\\Microsoft\\RAS EAP\\UserEapInfo")

#define cszEapValue TEXT("EapInfo")

static const DWORD g_adMD5Help[] =
{
    0, 0
};

//
// ElGetUserIdentityDlgWorker
//
// Description:
//
// Function called to fetch identity of the user, via UI if required
// 
// Arguments:
//
// Return values:
//
//

DWORD
ElGetUserIdentityDlgWorker (
        IN  WCHAR   *pwszConnectionName,
        IN  VOID    *pvContext
        )
{
    DTLLIST                 *pListEaps = NULL;
    DTLNODE                 *pEapcfgNode = NULL;
    EAPCFG                  *pEapcfg = NULL;
    CHAR                    *pszIdentity = NULL;
    BYTE                    *pUserDataOut = NULL;
    DWORD                   dwSizeOfUserDataOut = 0;
    LPWSTR                  lpwszIdentity = NULL;
    HWND                    hwndOwner = NULL;
    PBYTE                   pbUserIn = NULL;
    DWORD                   cbData = 0;
    DWORD                   dwInSize = 0;
    PBYTE                   pbAuthData = NULL;
    HANDLE                  hLib = NULL;
    RASEAPFREE              pFreeFunc = NULL;
    RASEAPGETIDENTITY       pIdenFunc = NULL;
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    EAPOLUI_RESP            EapolUIResp;
    DWORD                   dwEapTypeToBeUsed = 0;
    BOOLEAN                 fSendResponse = FALSE;
    BOOLEAN                 fVerifyPhase = FALSE;
    DWORD                   dwRetCode1= NO_ERROR;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        if (pvContext == NULL)
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            return dwRetCode;
        }

        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)pvContext;

        if (pwszConnectionName == NULL)
        {
            fVerifyPhase = TRUE;
        }

        pListEaps = ReadEapcfgList (0);
        if (pListEaps == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        pEapcfgNode = EapcfgNodeFromKey (
                        pListEaps,
                        pEAPUIContext->dwEapTypeId

                        );
        if (pEapcfgNode == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        pEapcfg = (EAPCFG*) DtlGetData (pEapcfgNode);

        // Get the size of the user blob
        if ((dwRetCode = WZCGetEapUserInfo (
                        pEAPUIContext->wszGUID,
                        pEAPUIContext->dwEapTypeId,
                        pEAPUIContext->dwSizeOfSSID,
                        pEAPUIContext->bSSID,
                        NULL,
                        &dwInSize
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_INSUFFICIENT_BUFFER)
            {
                if (dwInSize <= 0)
                {
                    // No blob stored in the registry
                    // Continue processing
                    TRACE0 (USER, "ElGetUserIdentityDlgWorker: NULL sized user data");
                    pbUserIn = NULL;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbUserIn = MALLOC (dwInSize);
                    if (pbUserIn == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentityDlgWorker: Error in memory allocation for User data");
                        break;
                    }
                    if ((dwRetCode = WZCGetEapUserInfo (
                                pEAPUIContext->wszGUID,
                                pEAPUIContext->dwEapTypeId,
                                pEAPUIContext->dwSizeOfSSID,
                                pEAPUIContext->bSSID,
                                pbUserIn,
                                &dwInSize
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentityDlgWorker: WZCGetEapUserInfo failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // User info may not have been created till now
                // which is valid condition to proceed
                if (dwRetCode != ERROR_FILE_NOT_FOUND)
                {
                    TRACE1 (USER, "ElGetUserIdentityDlgWorker: WZCGetEapUserInfo size estimation failed with error %ld",
                            dwRetCode);
                    break;
                }
                else
                {
                    dwRetCode = NO_ERROR;
                }
            }
        }

        // In verification phase, if NULL user size, wait for onballoonclick
        // before showing balloon

#if 0
        if (fVerifyPhase)
        {
            if ((pbUserIn == NULL) && (dwInSize == 0))
            {
                dwRetCode = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                break;
            }
        }
#endif

        hLib = LoadLibrary (pEapcfg->pszIdentityDll);
        if (hLib == NULL)
        {
            dwRetCode = GetLastError ();
            break;
        }

        pIdenFunc = (RASEAPGETIDENTITY)GetProcAddress(hLib, 
                                                    "RasEapGetIdentity");
        pFreeFunc = (RASEAPFREE)GetProcAddress(hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pIdenFunc == NULL))
        {
            TRACE0 (USER, "ElGetUserIdentityDlgWorker: pIdenFunc or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get the size of the EAP blob
        if ((dwRetCode = WZCEapolGetCustomAuthData (
                        NULL,
                        pEAPUIContext->wszGUID,
                        pEAPUIContext->dwEapTypeId,
                        pEAPUIContext->dwSizeOfSSID,
                        pEAPUIContext->bSSID,
                        NULL,
                        &cbData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (cbData == 0)
                {
                    // No EAP blob stored in the registry
                    TRACE0 (USER, "ElGetUserIdentityDlgWorker: NULL sized EAP blob");
                    pbAuthData = NULL;
                    // Every port should have connection data !!!
                    // dwRetCode = ERROR_CAN_NOT_COMPLETE;
                    // break;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbAuthData = MALLOC (cbData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentityDlgWorker: Error in memory allocation for EAP blob");
                        break;
                    }
                    if ((dwRetCode = WZCEapolGetCustomAuthData (
                                        NULL,
                                        pEAPUIContext->wszGUID,
                                        pEAPUIContext->dwEapTypeId,
                                        pEAPUIContext->dwSizeOfSSID,
                                        pEAPUIContext->bSSID,
                                        pbAuthData,
                                        &cbData
                                        )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentityDlgWorker: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (USER, "ElGetUserIdentityDlgWorker: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }


        // Get handle to desktop window

        hwndOwner = GetDesktopWindow ();

        dwEapTypeToBeUsed = pEAPUIContext->dwEapTypeId;

        if (pIdenFunc)
        if ((dwRetCode = (*(pIdenFunc))(
                        dwEapTypeToBeUsed,
                        fVerifyPhase?NULL:hwndOwner, // hwndOwner
                        (fVerifyPhase?RAS_EAP_FLAG_NON_INTERACTIVE:0) 
                        | RAS_EAP_FLAG_8021X_AUTH, // dwFlags
                        NULL, // lpszPhonebook
                        pwszConnectionName, // lpszEntry
                        pbAuthData, // Connection data
                        cbData, // Count of pbAuthData
                        pbUserIn, // User data for port
                        dwInSize, // Size of user data
                        &pUserDataOut,
                        &dwSizeOfUserDataOut,
                        &lpwszIdentity
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserIdentityDlgWorker: Error in calling GetIdentity = %ld",
                    dwRetCode);
            if (fVerifyPhase)
            {
                // If interactive mode is required, return error accordingly
                if (dwRetCode == ERROR_INTERACTIVE_MODE)
                {
                    dwRetCode = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                    break;
                }
            }
            break;
        }

        if (lpwszIdentity != NULL)
        {
            pszIdentity = MALLOC (wcslen(lpwszIdentity)*sizeof(CHAR) + sizeof(CHAR));
            if (pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentityDlgWorker: MALLOC failed for pszIdentity");
                break;
            }

            if (0 == WideCharToMultiByte (
                        CP_ACP,
                        0,
                        lpwszIdentity,
                        -1,
                        pszIdentity,
                        wcslen(lpwszIdentity)*sizeof(CHAR)+sizeof(CHAR),
                        NULL, 
                        NULL ))
            {
                dwRetCode = GetLastError();
                TRACE2 (USER, "ElGetUserIdentityDlgWorker: WideCharToMultiByte (%ws) failed: %ld",
                        lpwszIdentity, dwRetCode);
                break;
            }

            TRACE1 (USER, "ElGetUserIdentityDlgWorker: Got identity = %s",
                    pszIdentity);
        }
    }
    while (FALSE);

    // Create UI Response for Service

    ZeroMemory ((VOID *)&EapolUIResp, sizeof (EapolUIResp));

    if (pszIdentity)
    {
        EapolUIResp.rdData0.dwDataLen = strlen (pszIdentity);
    }
    else
    {
        EapolUIResp.rdData0.dwDataLen = 0;
    }
    EapolUIResp.rdData0.pData = pszIdentity;

    if ((dwSizeOfUserDataOut != 0) && (pUserDataOut != NULL))
    {
        EapolUIResp.rdData1.dwDataLen = dwSizeOfUserDataOut;
        EapolUIResp.rdData1.pData = pUserDataOut;
    }

    if ((cbData != 0) && (pbAuthData != NULL))
    {
        EapolUIResp.rdData2.dwDataLen = cbData;
        EapolUIResp.rdData2.pData = pbAuthData;
    }

    if (dwRetCode == NO_ERROR)
    {
        fSendResponse = TRUE;
    }
    else
    {
        // Send out GUEST identity if no certificate available
        // Do not fill out any identity information
        if ((dwRetCode == ERROR_NO_EAPTLS_CERTIFICATE) &&
                (IS_GUEST_AUTH_ENABLED(pEAPUIContext->dwEapFlags)))
        {
            // Reset error, since guest identity can be sent in
            // absence of certificate
            fSendResponse = TRUE;
            dwRetCode = NO_ERROR;
            TRACE0 (USER, "ElGetUserIdentityDlgWorker: Sending guest identity");
        }
        else
        {
            if ((dwRetCode != ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION) &&
                (dwRetCode != ERROR_NO_EAPTLS_CERTIFICATE) &&
                (dwRetCode != ERROR_NO_SMART_CARD_READER))
            {
                pEAPUIContext->dwRetCode = dwRetCode;
                fSendResponse = TRUE;
            }
        }
    }

    // Don't send out response during verification phase, if user-interaction
    // is required
    if ((dwRetCode != ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION) &&
        (dwRetCode != ERROR_NO_EAPTLS_CERTIFICATE) &&
        (dwRetCode != ERROR_NO_SMART_CARD_READER) &&
        fSendResponse)
    {
        if ((dwRetCode = WZCEapolUIResponse (
                        NULL,
                        *pEAPUIContext,
                        EapolUIResp
                )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserIdentityDlgWorker: WZCEapolUIResponse failed with error %ld",
                    dwRetCode);
        }
    }

    if (pbUserIn != NULL)
    {
        FREE (pbUserIn);
    }
    if (pbAuthData != NULL)
    {
        FREE (pbAuthData);
    }
    if (pszIdentity != NULL)
    {
        FREE (pszIdentity);
    }
    if (pFreeFunc != NULL)
    {
        if (lpwszIdentity != NULL)
        {
            if (( dwRetCode1 = (*(pFreeFunc)) ((BYTE *)lpwszIdentity)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentityDlgWorker: Error in pFreeFunc = %ld",
                        dwRetCode1);
            }
        }
        if (pUserDataOut != NULL)
        {
            if (( dwRetCode1 = (*(pFreeFunc)) ((BYTE *)pUserDataOut)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentityDlgWorker: Error in pFreeFunc = %ld",
                        dwRetCode1);
            }
        }
    }
    if (pListEaps != NULL)
    {
        DtlDestroyList(pListEaps, NULL);
    }
    if (hLib != NULL)
    {
        FreeLibrary (hLib);
    }

    return dwRetCode;
}


//
// ElGetUserNamePasswordDlgWorker
//
// Description:
//
// Function called to fetch username/password credentials for the user using
// UI dialog
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetUserNamePasswordDlgWorker (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        )
{
    HANDLE              hUserToken = NULL;
    DWORD               dwInSize = 0;
    HWND                hwndOwner = NULL;
    EAPOLMD5UI          *pEapolMD5UI = NULL;
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    EAPOLUI_RESP        EapolUIResp;
    BOOLEAN             fSendResponse = FALSE;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElGetUserNamePasswordDlgWorker entered");

        if (pvContext == NULL)
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            return dwRetCode;
        }

        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)pvContext;

        pEapolMD5UI = MALLOC (sizeof (EAPOLMD5UI));
        if (pEapolMD5UI == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElGetUserNamePasswordDlgWorker: MALLOC failed for pEapolMD5UI");
            break;
        }

        pEapolMD5UI->pwszFriendlyName = 
            MALLOC ((wcslen(pwszConnectionName)+1)*sizeof(WCHAR));
        if (pEapolMD5UI->pwszFriendlyName == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElGetUserNamePasswordDlgWorker: MALLOC failed for pEapolMD5UI->pwszFriendlyName");
            break;
        }
        wcscpy (pEapolMD5UI->pwszFriendlyName, pwszConnectionName);

        // Call the user dialog for obtaining the username and password

        if ((dwRetCode = ElUserDlg (hwndOwner, pEapolMD5UI)) != NO_ERROR)
        {
            TRACE0 (USER, "ElGetUserNamePasswordDlgWorker: ElUserDlg failed");
            break;
        }

    } while (FALSE);

    // Create UI Response for Service

    ZeroMemory ((VOID *)&EapolUIResp, sizeof (EapolUIResp));

    if (dwRetCode == NO_ERROR)
    {
        if (pEapolMD5UI->pszIdentity)
        {
            EapolUIResp.rdData0.dwDataLen = strlen (pEapolMD5UI->pszIdentity);
            fSendResponse = TRUE;
        }
        else
        {
            EapolUIResp.rdData0.dwDataLen = 0;

            // Send out NULL identity independent of guest auth setting
            // if (IS_GUEST_AUTH_ENABLED(pEAPUIContext->dwEapFlags))
            {
                fSendResponse = TRUE;
            }
        }

        EapolUIResp.rdData0.pData = pEapolMD5UI->pszIdentity;
        EapolUIResp.rdData1.dwDataLen = pEapolMD5UI->PasswordBlob.cbData;
        EapolUIResp.rdData1.pData = pEapolMD5UI->PasswordBlob.pbData;
    }
    else
    {
        pEAPUIContext->dwRetCode = dwRetCode;
        fSendResponse = TRUE;
    }

    if (fSendResponse)
    {
        if ((dwRetCode = WZCEapolUIResponse (
                        NULL,
                        *pEAPUIContext,
                        EapolUIResp
                )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserNamePasswordWorker: WZCEapolUIResponse failed with error %ld",
                    dwRetCode);
        }
    }

    if (pEapolMD5UI != NULL)
    {
        if (pEapolMD5UI->pwszFriendlyName != NULL)
        {
            FREE (pEapolMD5UI->pwszFriendlyName);
        }
        if (pEapolMD5UI->pszIdentity != NULL)
        {
            FREE (pEapolMD5UI->pszIdentity);
        }
        if (pEapolMD5UI->pwszPassword != NULL)
        {
            FREE (pEapolMD5UI->pwszPassword);
        }
        if (pEapolMD5UI->PasswordBlob.pbData != NULL)
        {
            FREE (pEapolMD5UI->PasswordBlob.pbData);
        }
        FREE (pEapolMD5UI);
    }

    TRACE1 (USER, "ElGetUserNamePasswordDlgWorker completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElUserDlg
//
// Description:
//
// Function called to pop-up dialog box to user to enter username, password,
// domainname etc.
//
// Arguments:
//      hwndOwner - handle to user desktop
//      pEapolMD5UI - 
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
DWORD
ElUserDlg (
        IN  HWND        hwndOwner,
        IN  EAPOLMD5UI  *pEapolMD5UI
        )
{
    USERDLGARGS     args;
    DWORD           dwRetCode = NO_ERROR;     


    TRACE0 (USER, "ElUserDlg: Entered");

    args.pEapolMD5UI = pEapolMD5UI;

    if ( DialogBoxParam (
                    GetModuleHandle(cszModuleName),
                    MAKEINTRESOURCE (DID_DR_DialerUD),
                    hwndOwner,
                    ElUserDlgProc,
                    (LPARAM)&args ) == -1)
    {
        dwRetCode = GetLastError ();
        TRACE1 (USER, "ElUserDlg: DialogBoxParam failed with error %ld",
                dwRetCode);
    }

    return dwRetCode;
}


//
// ElUserDlgProc
//
// Description:
//
// Function handling all events for username/password/... dialog box
//
// Arguments:
//      hwnd -
//      unMsg -
//      wparam -
//      lparam -
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

INT_PTR
ElUserDlgProc (
        IN HWND hwnd,
        IN UINT unMsg,
        IN WPARAM wparam,
        IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            {
                return ElUserDlgInit( hwnd, (USERDLGARGS* )lparam );
                break;
            }
        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                // ElContextHelp ( g_adMD5Help, hwnd, unMsg, wparam, lparam );
                break;
            }
        case WM_COMMAND:
            {
                USERDLGINFO* pInfo = (USERDLGINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );
                return ElUserDlgCommand (
                        pInfo, HIWORD(wparam), LOWORD(wparam), (HWND)lparam );

                break;
            }
        case WM_DESTROY:
            {
                USERDLGINFO* pInfo = (USERDLGINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ElUserDlgTerm (hwnd, pInfo);
                break;
            }
    }

    return FALSE;
}


//
// ElUserDlgInit
//
// Description:
//
// Function initializing UI dialog
//
// Arguments:
//      hwndDlg -
//      pArgs -
//
// Return values:
//      TRUE -
//      FALSE -
//

BOOL
ElUserDlgInit (
        IN  HWND    hwndDlg,
        IN  USERDLGARGS  *pArgs
        )
{
    USERDLGINFO     *pInfo = NULL;
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (USER, "ElUserDlgInit entered");

    do
    {
        pInfo = MALLOC (sizeof (USERDLGINFO));
        if (pInfo == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElUserDlgInit: MALLOC failed for pInfo");
            break;
        }
     
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
    
        SetWindowLongPtr (hwndDlg, DWLP_USER, (ULONG_PTR)pInfo);
#if 0
        if (!SetWindowLongPtr (hwndDlg, DWLP_USER, (ULONG_PTR)pInfo))
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgInit: SetWindowLongPtr failed with error %ld",
                    dwRetCode);
            break;
        }
#endif

        TRACE0 (USER, "ElUserDlgInit: Context Set");
    
        // 
        // Set the title
        //
    
        if (pArgs->pEapolMD5UI->pwszFriendlyName)
        {
            if (!SetWindowText (hwndDlg, pArgs->pEapolMD5UI->pwszFriendlyName))
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElUserDlgInit: SetWindowText failed with error %ld",
                        dwRetCode);
                break;
            }
        }
        else
        {
            if (!SetWindowText (hwndDlg, L""))
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElUserDlgInit: SetWindowText - NULL failed with error %ld",
                        dwRetCode);
                break;
            }
        }
    
        pInfo->hwndEbUser = GetDlgItem( hwndDlg, CID_DR_EB_User );
        ASSERT (pInfo->hwndEbUser);
        pInfo->hwndEbPw = GetDlgItem( hwndDlg, CID_DR_EB_Password );
        ASSERT (pInfo->hwndEbPw);
        pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_DR_EB_Domain );
        ASSERT (pInfo->hwndEbDomain);
    
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//
// ElContextHelp
//
// Description:
//
// Function supporting help Ids
// Calls WinHelp to popup context sensitive help. padwMap is an array of 
// control-ID help-ID pairs terminated with a 0,0 pair. unMsg is WM_HELP or 
// WM_CONTEXTMENU indicating the message received requesting help. wParam and 
// lParam are the parameters of the message received requesting help.
//
// Arguments:
//      hwndDlg -
//      pArgs -
//
// Return values:
//

VOID
ElContextHelp(
    IN  const   DWORD*  padwMap,
    IN          HWND    hWndDlg,
    IN          UINT    unMsg,
    IN          WPARAM  wParam,
    IN          LPARAM  lParam
    )
{
    HWND        hWnd;
    UINT        unType;
    WCHAR       *pwszHelpFile    = NULL;
    HELPINFO    *pHelpInfo;

    do
    {
        if (unMsg == WM_HELP)
        {
            pHelpInfo = (HELPINFO*) lParam;
    
            if (pHelpInfo->iContextType != HELPINFO_WINDOW)
            {
                break;
            }

            hWnd = pHelpInfo->hItemHandle;
            unType = HELP_WM_HELP;
        }
        else
        {
            // Standard Win95 method that produces a one-item "What's This?" 
            // menu that user must click to get help.
            hWnd = (HWND) wParam;
            unType = HELP_CONTEXTMENU;
        };
    
        // pwszHelpFile = WszFromId(g_hInstance, IDS_HELPFILE);
    
        if (pwszHelpFile == NULL)
        {
            break;
        }
    
        WinHelp(hWnd, pwszHelpFile, unType, (ULONG_PTR)padwMap);
    }
    while (FALSE);

    if (pwszHelpFile != NULL)
    {
        LocalFree(pwszHelpFile);
    }
}


//
// ElUserDlgCommand
//
// Description:
//
// Function called on WM_COMMAND
// domainname etc.
//
// Arguments:
//      pInfo - dialog context
//      wNotification - notification code of the command 
//      wId - control/menu identifier of the command  
//      hwndCtrl - control window handle the command.
//
// Return values:
//      TRUE - success
//      FALSE - error
//

BOOL
ElUserDlgCommand (
        IN  USERDLGINFO *pInfo,
        IN  WORD        wNotification,
        IN  WORD        wId,
        IN  HWND        hwndCtrl
        )
{
    switch (wId)
    {
        case IDOK:
        case CID_DR_PB_DialConnect:
            {
                ElUserDlgSave (pInfo);
                EndDialog (pInfo->hwndDlg, TRUE);
                return TRUE;
            }
        case IDCANCEL:
        case CID_DR_PB_Cancel:
            {
                EndDialog (pInfo->hwndDlg, TRUE);
                return TRUE;
            }
        default:
            {
                break;
            }
    }

    return FALSE;
}


//
// ElUserDlgSave
//
// Description:
//
// Function handling saving of credentials
//
// Arguments:
//      pInfo -
//
// Return values:
//

VOID
ElUserDlgSave (
        IN  USERDLGINFO      *pInfo
        )
{
    EAPOLMD5UI      *pEapolMD5UI = NULL;
    int             iError;
    WCHAR           wszUserName[UNLEN + 1];
    WCHAR           wszDomain[DNLEN + 1];
    WCHAR           wszIdentity[UNLEN + DNLEN + 1];
    WCHAR           wszPassword[PWLEN + 1];
    DWORD           dwRetCode = NO_ERROR;

    pEapolMD5UI = (EAPOLMD5UI *)pInfo->pArgs->pEapolMD5UI;

    do 
    {
        // Username

        if ((iError = 
                    GetWindowText ( 
                        pInfo->hwndEbUser, 
                        &(wszUserName[0]), 
                        UNLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Username failed with error %ld",
                    dwRetCode);
        }
        wszUserName[iError] = L'\0';
    
        TRACE1 (USER, "ElUserDlgSave: Get Username %ws", wszUserName);
    
        // Password

        if ((iError = 
                    GetWindowText ( 
                        pInfo->hwndEbPw, 
                        &(wszPassword[0]), 
                        PWLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Password failed with error %ld",
                    dwRetCode);
        }
        wszPassword[iError] = L'\0';
    
        if (pEapolMD5UI->pwszPassword != NULL)
        {
            FREE (pEapolMD5UI->pwszPassword);
            pEapolMD5UI->pwszPassword = NULL;
        }

        pEapolMD5UI->pwszPassword = MALLOC ((wcslen(wszPassword) + 1)*sizeof(WCHAR));
        
        if (pEapolMD5UI->pwszPassword == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElUserDlgSave: MALLOC failed for pEapolMD5UI->pwszPassword");
            break;
        }

        wcscpy (pEapolMD5UI->pwszPassword, wszPassword);

        ZeroMemory (wszPassword, wcslen(wszPassword)*sizeof(WCHAR));
    
        // Domain
    
        if ((iError = 
                    GetWindowText ( 
                        pInfo->hwndEbDomain, 
                        &(wszDomain[0]), 
                        DNLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Domain failed with error %ld",
                    dwRetCode);
        }
        wszDomain[iError] = L'\0';
    
        TRACE1 (USER, "ElUserDlgSave: Got Domain %ws", wszDomain);
    
        if (pEapolMD5UI->pszIdentity != NULL)
        {
            FREE (pEapolMD5UI->pszIdentity);
            pEapolMD5UI->pszIdentity = NULL;
        }

        if (wcslen(wszDomain)+wcslen(wszUserName) > (UNLEN+DNLEN-1))
        {
            dwRetCode = ERROR_INVALID_DATA;
            break;
        }
        if ((wszDomain != NULL) &&
                (wszDomain[0] != (CHAR)NULL))
        {
            wcscpy (wszIdentity, wszDomain);
            wcscat (wszIdentity, L"\\" );
            wcscat (wszIdentity, wszUserName);
        }
        else
        {
            wcscpy (wszIdentity, wszUserName);
        }

        if (wszIdentity[0] != (CHAR)NULL)
        {
            pEapolMD5UI->pszIdentity = MALLOC (wcslen(wszIdentity)*sizeof(CHAR) + sizeof(CHAR));
            if (pEapolMD5UI->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElUserDlgSave: MALLOC failed for pEapolMD5UI->pszIdentity");
                break;
            }

            if (0 == WideCharToMultiByte (
                        CP_ACP,
                        0,
                        wszIdentity,
                        -1,
                        pEapolMD5UI->pszIdentity,
                        wcslen(wszIdentity)*sizeof(CHAR)+sizeof(CHAR),
                        NULL, 
                        NULL ))
            {
                dwRetCode = GetLastError();
                TRACE2 (USER, "ElUserDlgSave: WideCharToMultiByte (%ws) failed: %ld",
                        wszIdentity, dwRetCode);
                break;
            }
        }
        TRACE1 (USER, "ElUserDlgSave: Got identity %s", pEapolMD5UI->pszIdentity);
        // Encrypt password, using user's ACL via Crypt API
        // The service will be able to decrypt it, since it has handle to
        // user's token

        if ((dwRetCode = ElSecureEncodePw (
                                &(pEapolMD5UI->pwszPassword), 
                                &(pEapolMD5UI->PasswordBlob))) != NO_ERROR)
        {
            TRACE1 (USER, "ElUserDlgSave: ElSecureEncodePw failed with error %ld",
                    dwRetCode);
            break;
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pEapolMD5UI->pszIdentity != NULL)
        {
            FREE (pEapolMD5UI->pszIdentity);
            pEapolMD5UI->pszIdentity = NULL;
        }
    
        if (pEapolMD5UI->PasswordBlob.pbData != NULL)
        {
            FREE (pEapolMD5UI->PasswordBlob.pbData);
            pEapolMD5UI->PasswordBlob.pbData = NULL;
            pEapolMD5UI->PasswordBlob.cbData = 0;
        }
    }

    if (pEapolMD5UI->pwszPassword != NULL)
    {
        FREE (pEapolMD5UI->pwszPassword);
        pEapolMD5UI->pwszPassword = NULL;
    }

    return;

}


//
// ElUserDlgTerm
//
// Description:
//
// Function handling dialog termination
//
// Arguments:
//      hwndDlg -
//      pInfo -
//
// Return values:
//

VOID
ElUserDlgTerm (
        IN  HWND        hwndDlg,
        IN  USERDLGINFO      *pInfo
        )
{
    EndDialog (hwndDlg, TRUE);
    FREE (pInfo);
}


//
// ElInvokeInteractiveUIDlgWorker
//
// Description:
//
// Function called to pop-up UI dialog to user via EAP-dll
// 
// Arguments:
//

DWORD
ElInvokeInteractiveUIDlgWorker (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        )
{
    DTLLIST             *pListEaps = NULL;
    DTLNODE             *pEapcfgNode = NULL;
    EAPCFG              *pEapcfg = NULL;
    HANDLE              hLib = NULL;
    RASEAPFREE          pFreeFunc = NULL;
    RASEAPINVOKEINTERACTIVEUI     pEapInvokeUI = NULL;
    BYTE                *pUIDataOut = NULL;
    DWORD               dwSizeOfUIDataOut = 0;
    HWND                hwndOwner = NULL;
    EAPOL_EAP_UI_CONTEXT *pEAPUIContext = NULL;
    DWORD               dwEapTypeToBeUsed = 0;
    EAPOLUI_RESP        EapolUIResp;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElInvokeInteractiveUIDlgWorker entered");

        if (pvContext == NULL)
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            return dwRetCode;
        }

        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)pvContext;

        pListEaps = ReadEapcfgList (0);
        if (pListEaps == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        pEapcfgNode = EapcfgNodeFromKey (
                        pListEaps,
                        pEAPUIContext->dwEapTypeId
                        );
        if (pEapcfgNode == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        pEapcfg = (EAPCFG*) DtlGetData (pEapcfgNode);

        hLib = LoadLibrary (pEapcfg->pszIdentityDll);
        if (hLib == NULL)
        {
            dwRetCode = GetLastError ();
            break;
        }

        dwEapTypeToBeUsed = pEAPUIContext->dwEapTypeId;

        pEapInvokeUI = (RASEAPINVOKEINTERACTIVEUI) GetProcAddress 
                                        (hLib, "RasEapInvokeInteractiveUI");
        pFreeFunc = (RASEAPFREE) GetProcAddress (hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pEapInvokeUI == NULL))
        {
            TRACE0 (USER, "ElInvokeInteractiveUIDlgWorker: pEapInvokeUI or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get handle to desktop window
        hwndOwner = GetDesktopWindow ();

        if ((dwRetCode = (*(pEapInvokeUI))(
                        dwEapTypeToBeUsed,
                        hwndOwner, // hwndOwner
                        pEAPUIContext->bEapUIData, 
                        pEAPUIContext->dwSizeOfEapUIData, 
                        &pUIDataOut,
                        &dwSizeOfUIDataOut
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElInvokeInteractiveUIDlgWorker: Error in calling InvokeInteractiveUI = %ld",
                    dwRetCode);
            // break;
        }

        // Create UI Response for Service

        ZeroMemory ((VOID *)&EapolUIResp, sizeof (EapolUIResp));
        EapolUIResp.rdData0.dwDataLen = dwSizeOfUIDataOut;
        EapolUIResp.rdData0.pData = pUIDataOut;
        pEAPUIContext->dwRetCode = dwRetCode;

        if ((dwRetCode = WZCEapolUIResponse (
                        NULL,
                        *pEAPUIContext,
                        EapolUIResp
                )) != NO_ERROR)
        {
            TRACE1 (USER, "ElInvokeInteractiveUIDlgWorker: WZCEapolUIResponse failed with error %ld",
                    dwRetCode);
            break;
        }

        TRACE0 (USER, "ElInvokeInteractiveUIDlgWorker: Calling ElEapWork");

    } while (FALSE);

    if (pFreeFunc != NULL)
    {
        if (pUIDataOut != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)pUIDataOut)) != NO_ERROR)
            {
                TRACE1 (USER, "ElInvokeInteractiveUIDlgWorker: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
    }

    if (pListEaps != NULL)
    {
        DtlDestroyList(pListEaps, NULL);
    }

    if (hLib != NULL)
    {
        FreeLibrary (hLib);
    }

    TRACE1 (USER, "ElInvokeInteractiveUIDlgWorker completed with error %ld", 
            dwRetCode);

    return dwRetCode;
}


//
// ElDialogCleanup
//
// Description:
//
// Function called close any old dialogs for the user
// 
// Arguments:
//

DWORD
ElDialogCleanup (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        )
{
    HWND        hwnd = NULL;
    UINT        Msg;
    WPARAM      wparam;
    LPARAM      lparam;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Find earlier instances of 802.1X windows on this interface

        // Send message to quit

        // SendMessage (hwnd, Msg, wparam, lparam);
    }
    while (FALSE);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\eluiuser.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:
    eluiuser.h

Abstract:

    User interaction module definitions


Revision History:

    sachins, April 25, 2001, Created

--*/

#ifndef _ELUIUSER_H
#define _ELUIUSER_H

#define BID_Dialer                      100
#define DID_DR_DialerUD                 117
#define CID_DR_EB_User                  1104
#define CID_DR_EB_Password              1103
#define CID_DR_PB_DialConnect           1590
#define CID_DR_PB_Cancel                1591
#define CID_DR_BM_Useless               1100
#define CID_DR_ST_User                  1413
#define CID_DR_ST_Password              1112
#define CID_DR_ST_Domain                1110
#define CID_DR_EB_Domain                1102
#define IDC_STATIC                      -1

#define MAX_BALLOON_MSG_LEN             255

#define cszModuleName TEXT("wzcdlg.dll")

//
// MD5 dialog info
//

typedef struct _EAPOLMD5UI
{
    // Authentication identity using RasGetUserIdentity or other means
    CHAR                    *pszIdentity;

    // User Password for EAP MD5 CHAP
    WCHAR                   *pwszPassword;

    // User Password for EAP MD5 CHAP
    DATA_BLOB               PasswordBlob;

    // Friendly name of the interface on which this port is opened
    WCHAR                   *pwszFriendlyName;

} EAPOLMD5UI, *PEAPOLMD5UI;

//
// MD5 dialog argument block
//

typedef struct
_USERDLGARGS
{
    EAPOLMD5UI      *pEapolMD5UI;
} USERDLGARGS;

//
// MD5 dialog context block 
//

typedef struct _USERDLGINFO
{
    // Common dial context information including the RAS API arguments.
    USERDLGARGS* pArgs;

    // Handle of the dialog and some of it's controls.
    HWND hwndDlg;
    HWND hwndEbUser;
    HWND hwndEbPw;
    HWND hwndEbDomain;
} USERDLGINFO;


DWORD
ElGetUserIdentityDlgWorker (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        );

DWORD
ElGetUserNamePasswordDlgWorker (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        );

VOID
ElUserDlgSave (
        IN  USERDLGINFO         *pInfo
        );
BOOL
ElUserDlgCommand (
        IN  USERDLGINFO         *pInfo,
        IN  WORD                wNotification,
        IN  WORD                wId,
        IN  HWND                hwndCtrl
        );

VOID
ElContextHelp(
    IN  const   DWORD*  padwMap,
    IN          HWND    hWndDlg,
    IN          UINT    unMsg,
    IN          WPARAM  wParam,
    IN          LPARAM  lParam
    );

DWORD
ElUserDlg (
        IN  HWND                hwndOwner,
        IN  EAPOLMD5UI          *pEapolMD5UI
        );

BOOL
ElUserDlgInit (
        IN  HWND                hwndDlg,
        IN  USERDLGARGS         *pArgs
        );

VOID
ElUserDlgTerm (
        IN  HWND                hwndDlg,
        IN  USERDLGINFO         *pInfo
        );

INT_PTR
ElUserDlgProc (
        IN  HWND                hwnd,
        IN  UINT                unMsg,
        IN  WPARAM              wparam,
        IN  LPARAM              lparam 
        );

DWORD
ElInvokeInteractiveUIDlgWorker (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        );

DWORD
ElDialogCleanup (
        IN  WCHAR       *pwszConnectionName,
        IN  VOID        *pvContext
        );

#endif // _ELUIUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzcatl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    wzcatl.h

Abstract:

    ATL header for wzcdlg.dll.

Author:

    FlorinT    02-May-2001

Environment:

    User Level: Win32

Revision History:


--*/

#pragma once

#include <atlbase.h>
extern  CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\elutil.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:
    eapolutil.h

Abstract:

    Definitions for tools and ends


Revision History:

    sachins, April 25, 2001, Created

--*/

#ifndef _ELUTIL_H
#define _ELUTIL_H

# ifdef     __cplusplus
extern "C" {
# endif

//
// STRUCT: EAPOLUIFUNC
//

typedef DWORD (*EAPOLUIFUNC) (WCHAR *, VOID *);

//
// STRUCT: EAPOLUIFUNCMAP
//

typedef struct _EAPOLUIFUNCMAP
{
    DWORD               dwEAPOLUIMsgType;
    EAPOLUIFUNC         EapolUIFunc;
    EAPOLUIFUNC         EapolUIVerify;
    DWORD               fShowBalloon;
    DWORD               dwStringID;
} EAPOLUIFUNCMAP, *PEAPOLUIFUNCMAP;

// Global table for UI functions
extern EAPOLUIFUNCMAP  EapolUIFuncMap[NUM_EAPOL_DLG_MSGS];


HRESULT 
ElCanShowBalloon ( 
        IN const GUID * pGUIDConn, 
        IN const WCHAR * pszAdapterName,
        IN OUT   BSTR * pszBalloonText, 
        IN OUT   BSTR * pszCookie
        );

HRESULT 
ElOnBalloonClick ( 
        IN const GUID * pGUIDConn, 
        IN const WCHAR * pszAdapterName,
        IN const BSTR   szCookie
        );

HRESULT 
ElQueryConnectionStatusText ( 
        IN const GUID *  pGUIDConn, 
        IN const NETCON_STATUS ncs,
        OUT BSTR *  pszStatusText
        );
DWORD
ElSecureEncodePw (
        IN  PWCHAR              *pwszPassword,
        OUT DATA_BLOB           *pDataBlob
        );

# ifdef     __cplusplus
}
# endif

#endif // _ELUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for wzcdlg.dll.

Author:

    SachinS    20-March-2001

Environment:

    User Level: Win32

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <oleauto.h>
#include <rtutils.h>
#include <commctrl.h>
#include <shellapi.h>
#include <wzcsapi.h>
#include <raserror.h>
#include <raseapif.h>
#include <wincrypt.h>
#include <lmcons.h>
#include <netconp.h>
#include <shfusion.h>

#ifdef  __cplusplus
extern "C"
{
#endif

#include "ntddndis.h"
#include "eldefs.h"
#include "eluiuser.h"
#include "eluidlg.h"
#include "xpsp1res.h"
#include "elutil.h"

#ifdef    __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wzcdlg.rc
//
#define IDB_WZC_LISTICONS               103
#define IDD_WZCQCFG                     2001
#define IDC_WZCQCFG_LBL_INFO            2002
#define IDC_WZCQCFG_LBL_NETWORKS        2003
#define IDC_WZCQCFG_NETWORKS            2004
#define IDC_WZCQCFG_LBL_WKINFO          2005
#define IDC_WZCQCFG_LBL_WEPK            2006
#define IDC_WZCQCFG_WEPK                2007
#define IDC_WZCQCFG_LBL_NOTWORKING      2008
#define IDC_WZCQCFG_ADVANCED            2009
#define IDC_WZCQCFG_CONNECT             2010
#define IDS_WZCDLG_FAILED               5001
#define IDS_WZCERR_INVALID_WEPK         5002
#define IDS_WZCERR_CAPTION              5003
#define IDS_CANTACCESSNET_INFRA         5004
#define IDS_CANTACCESSNET_ADHOC         5005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzccore.cpp ===
#include <precomp.h>
#include "resource.h"
#include "wzccore.h"
#include "wzcatl.h"
#include "quickcfg.h"

CWZCQuickCfg    *pDlgCfg = NULL;

//--------------------------------------------------------
// "CanShowBalloon" hook into the WZC part of the UI pipe
// This call is supposed to return either S_OK and a pszBalloonText
// to be filled into the popping balloon, or S_FALSE if no balloon
// is to be popped up
HRESULT 
WZCDlgCanShowBalloon ( 
    IN const GUID * pGUIDConn, 
    IN OUT   BSTR * pszBalloonText, 
    IN OUT   BSTR * pszCookie)
{
    HRESULT hr = S_FALSE;

    if (pszCookie != NULL && pszBalloonText != NULL)
    {
        PWZCDLG_DATA pDlgData = reinterpret_cast<PWZCDLG_DATA>(*pszCookie);

        if (pDlgData->dwCode == WZCDLG_FAILED)
        {
            WCHAR wszBuffer[MAX_PATH];

            SysFreeString(*pszBalloonText);
            LoadString(_Module.GetResourceInstance(),
                       IDS_WZCDLG_FAILED,
                       wszBuffer,
                       MAX_PATH);
            *pszBalloonText = SysAllocString(wszBuffer);
            hr = pDlgData->lParam == 0 ? S_FALSE : S_OK;
        }
    }

    return hr;
}

//--------------------------------------------------------
// "OnBalloonClick" hook into the WZC part of the UI pipe.
// This call is supposed to be called whenever the user clicks
// on a balloon previously displayed by WZC
HRESULT 
WZCDlgOnBalloonClick ( 
    IN const GUID * pGUIDConn, 
    IN const LPWSTR wszConnectionName,
    IN const BSTR szCookie)
{
    HRESULT         hr = S_OK;
    PWZCDLG_DATA    pDlgData = reinterpret_cast<PWZCDLG_DATA>(szCookie);
    LRESULT         lRetCode;
    CWZCQuickCfg    *pLocalDlgCfg;

    if (pDlgCfg == NULL)
    {
        pDlgCfg = new CWZCQuickCfg(pGUIDConn);

        if (pDlgCfg != NULL)
        {
            pDlgCfg->m_wszTitle = wszConnectionName;

            lRetCode = pDlgCfg->SpDoModal(NULL);

            if (lRetCode == IDC_WZCQCFG_ADVANCED)
            {
                TCHAR   szConnProps[4*(GUID_NCH+3)+1];
                LPTSTR  pszConnGuid;

                _tcscpy(szConnProps, CONN_PROPERTIES_DLG);
                _tcscat(szConnProps, _T("::"));
                pszConnGuid = szConnProps + _tcslen(szConnProps);
                StringFromGUID2(*pGUIDConn, pszConnGuid, GUID_NCH);

                // According to MSDN, ShellExecute succeeds if the return value is >32!
                if (ShellExecute(
                        NULL,
                        COMM_WLAN_PROPS_VERB,
                        szConnProps,
                        NULL,
                        NULL,
                        SW_SHOWNORMAL) > (HINSTANCE)UlongToHandle(32))
                {
                }
            }

            pLocalDlgCfg = pDlgCfg;
            pDlgCfg = NULL;
            delete pLocalDlgCfg;
        }
    }
    else
    {
        // there could be a window when we've seen the pDlgCfg as not being NULL, but
        // while we're trying to get the window on top the user dismisses the dialog.
        // However, the fact we're in this code is a result of the user clicking on the
        // balloon - how fast can the user be in order to move the mouse to the dialog
        // and dismiss it while we're processing the click?
        pDlgCfg->SetWindowPos(HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
        pDlgCfg->SetWindowPos(HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\elutil.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    elutil.c

Abstract:

    Tools and ends


Revision History:

    sachins, Apr 23 2001, Created

--*/

#include "precomp.h"
#pragma hdrstop

//
// EAPOLUI function mapping
//

EAPOLUIFUNCMAP  EapolUIFuncMap[NUM_EAPOL_DLG_MSGS]=
{
    {EAPOLUI_GET_USERIDENTITY, ElGetUserIdentityDlgWorker, ElGetUserIdentityDlgWorker, TRUE, SID_GetUserIdentity},
    {EAPOLUI_GET_USERNAMEPASSWORD, ElGetUserNamePasswordDlgWorker, NULL, TRUE, SID_GetUserNamePassword},
    {EAPOLUI_INVOKEINTERACTIVEUI, ElInvokeInteractiveUIDlgWorker, NULL, TRUE, SID_InvokeInteractiveUI},
    {EAPOLUI_EAP_NOTIFICATION, NULL, NULL, TRUE, 0},
    {EAPOLUI_REAUTHENTICATE, NULL, NULL, FALSE, 0},
    {EAPOLUI_CREATEBALLOON, NULL, NULL, TRUE, SID_AuthenticationFailed},
    {EAPOLUI_CLEANUP, NULL, NULL, FALSE, 0},
    {EAPOLUI_DUMMY, NULL, NULL, FALSE, 0}
};


//
// ElCanShowBalloon
//
// Description:
// Function called by netshell, to query if balloon is to be displayed
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      pszConnectionName - Connection Name
//      pszBalloonText - Pointer to text to be display
//      pszCookie - EAPOL specific information
//
// Return values:
//      S_OK    - Display balloon
//      S_FALSE - Do not display balloon
//

HRESULT 
ElCanShowBalloon ( 
        IN const GUID * pGUIDConn, 
        IN const WCHAR * pszConnectionName,
        IN OUT   BSTR * pszBalloonText, 
        IN OUT   BSTR * pszCookie
        )
{
    EAPOL_EAP_UI_CONTEXT *pEapolUIContext = NULL;
    DWORD               dwIndex = 0;
    DWORD               dwSessionId = 0;
    WCHAR               cwszBuffer[MAX_BALLOON_MSG_LEN];
    WCHAR               wsSSID[MAX_SSID_LEN+1];
    DWORD               dwSizeOfSSID = 0;
    BYTE                *bSSID = NULL;
    WCHAR               *pszFinalBalloonText = NULL;
    DWORD               dwFinalStringId = 0;
    DWORD               dwRetCode = NO_ERROR;
    DWORD               dwRetCode1 = NO_ERROR;
    HRESULT             hr = S_OK;

    do
    {
        pEapolUIContext = (EAPOL_EAP_UI_CONTEXT *)(*pszCookie);

        if (!ProcessIdToSessionId (GetCurrentProcessId (), &dwSessionId))
        {
            dwRetCode = GetLastError ();
            break;
        }

        if (pEapolUIContext->dwSessionId != dwSessionId)
        {
            // Not intended for this session
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }

        dwSizeOfSSID = pEapolUIContext->dwSizeOfSSID;
        bSSID = pEapolUIContext->bSSID;

        for (dwIndex=0; dwIndex < NUM_EAPOL_DLG_MSGS; dwIndex++)
        {
            if (pEapolUIContext->dwEAPOLUIMsgType == 
                    EapolUIFuncMap[dwIndex].dwEAPOLUIMsgType)
            {
                if (EapolUIFuncMap[dwIndex].fShowBalloon)
                {
                    TRACE1 (RPC, "ElCanShowBalloon: Response function found, msg (%ld)",
                            EapolUIContext->dwEAPOLUIMsgType);

                    dwFinalStringId = EapolUIFuncMap[dwIndex].dwStringID;

                    // Verify is balloon indeed needs to be popped up OR
                    // can purpose be achieved without user involvement

                    if (EapolUIFuncMap[dwIndex].EapolUIVerify != NULL)
                    {
                        // Indicate that it is verification cycle, by passing
                        // NULL connection name, to indicate no display !
                        dwRetCode1 = EapolUIFuncMap[dwIndex].EapolUIVerify (
                                    NULL,
                                    pEapolUIContext
                                );
                        if (dwRetCode1 == ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION)
                        {
                            // Continue with show balloon
                            dwRetCode = NO_ERROR;
                        }
                        else
                        {
                            if (dwRetCode1 != NO_ERROR) 
                            {
                                switch (dwRetCode1)
                                {
                                    case ERROR_NO_EAPTLS_CERTIFICATE:
                                    // No certificate found
                                    // Pop balloon accordingly
                                    dwFinalStringId = SID_NoCertificateFound;
                                    // Since we wont take action on this
                                    // balloon being clicked, flag it as
                                    // EAPOLUI_DUMMY
                                    pEapolUIContext->dwEAPOLUIMsgType = EAPOLUI_DUMMY;
                                    dwRetCode = NO_ERROR;
                                    break;

                                    case ERROR_NO_SMART_CARD_READER:
                                    // No smartcard reader found
                                    dwFinalStringId = SID_NoSmartCardReaderFound;
                                    // Since we wont take action on this
                                    // balloon being clicked, flag it as
                                    // EAPOLUI_DUMMY
                                    pEapolUIContext->dwEAPOLUIMsgType = EAPOLUI_DUMMY;
                                    dwRetCode = NO_ERROR;
                                    break;

                                    default:
                                    // Continue with show balloon for any 
                                    // error in verification function
                                    dwRetCode = NO_ERROR;
                                    break;
                                }
                            }
                            else
                            {
                                // No need to process more.
                                // Response has been sent successfully 
                                // without user intervention
                                dwRetCode = ERROR_CAN_NOT_COMPLETE;
                                break;
                            }
                        }
                    }

                    if (dwFinalStringId != 0)
                    {
                        // Load string based on Id
                        if (dwFinalStringId <= SID_NoCertificateFound)
                        {
                            if (LoadString (GetModuleHandle(cszModuleName), dwFinalStringId, cwszBuffer, MAX_BALLOON_MSG_LEN) == 0)
                            {
                                dwRetCode = GetLastError ();
                                break;
                            }
                        }
                        else
                        {
                            if (LoadString (WZCGetSPResModule(), dwFinalStringId, cwszBuffer, MAX_BALLOON_MSG_LEN) == 0)
                            {
                                dwRetCode = GetLastError ();
                                break;
                            }
                        }

                        // Append the network-name / SSID 
                        if (dwSizeOfSSID != 0)
                        {
                            if (0 == MultiByteToWideChar (
                                            CP_ACP,
                                            0,
                                            bSSID,
                                            dwSizeOfSSID,
                                            wsSSID, 
                                            MAX_SSID_LEN+1))
                            {
                                dwRetCode = GetLastError();
                                break;
                            }

                            if ((pszFinalBalloonText = MALLOC ((wcslen(cwszBuffer)+1+ dwSizeOfSSID)*sizeof(WCHAR))) == NULL)
                            {
                                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }
                            wcscpy (pszFinalBalloonText, cwszBuffer);
                            memcpy ((BYTE *)(pszFinalBalloonText + wcslen(cwszBuffer)), (BYTE *)wsSSID, dwSizeOfSSID*sizeof(WCHAR));
                            pszFinalBalloonText[wcslen(cwszBuffer)+dwSizeOfSSID] = L'\0';
                        }
                        else
                        {
                            // Append a "." (period)
                            if ((pszFinalBalloonText = MALLOC ((wcslen(cwszBuffer) + 3)*sizeof(WCHAR))) == NULL)
                            {
                                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }
                            wcscpy (pszFinalBalloonText, cwszBuffer);
                            pszFinalBalloonText[wcslen(cwszBuffer)+1] = L'.';
                            pszFinalBalloonText[wcslen(cwszBuffer)+2] = L'\0';
                        }

                        if (*pszBalloonText)
                        {
                            if (!SysReAllocString (pszBalloonText, pszFinalBalloonText))
                            {
                                dwRetCode = ERROR_CAN_NOT_COMPLETE;
                                break;
                            }
                        }
                        else
                        {
                            *pszBalloonText = SysAllocString (pszFinalBalloonText);
                            if (*pszBalloonText == NULL)
                            {
                                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }
                        }
                    }
                    else
                    {
                        // Display the string that was passed
                    }

                    // If notification message, check to see if explorer 
                    // needs to be started off
                    if (pEapolUIContext->dwEAPOLUIMsgType == EAPOLUI_EAP_NOTIFICATION)
                    {
                        // Parse text message
                        // Attach to cookie
                    }
                }
                else
                {
                    TRACE1 (RPC, "ElCanShowBalloon: No balloon display, msg (%ld)",
                            EapolUIContext.dwEAPOLUIMsgType);
                }
            }
        }

    }
    while (FALSE);

    if (pszFinalBalloonText != NULL)
    {
        FREE (pszFinalBalloonText);
    }

    if (dwRetCode != NO_ERROR)
    {
        hr = S_FALSE;
    }
    return hr;
}


//
// ElOnBalloonClick
//
// Description:
//
// Function called by netshell, in response to a balloon click
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      szCookie - EAPOL specific information
//
// Return values:
//      S_OK    - No error
//      S_FALSE - Error
//

HRESULT 
ElOnBalloonClick ( 
        IN const GUID * pGUIDConn, 
        IN const WCHAR * pszConnectionName,
        IN const BSTR   szCookie
        )
{
    EAPOL_EAP_UI_CONTEXT *pEapolUIContext = NULL;
    DWORD               dwIndex = 0;
    DWORD               dwSessionId = 0;
    DWORD               dwRetCode = NO_ERROR;
    WCHAR               *pwszConnectionName = NULL;
    HRESULT             hr = S_OK;

    do
    {
        pEapolUIContext = (EAPOL_EAP_UI_CONTEXT *)szCookie;
        pwszConnectionName = (WCHAR *)pszConnectionName;

        for (dwIndex=0; dwIndex < NUM_EAPOL_DLG_MSGS; dwIndex++)
        {
            if (pEapolUIContext->dwEAPOLUIMsgType == 
                    EapolUIFuncMap[dwIndex].dwEAPOLUIMsgType)
            {
                if (EapolUIFuncMap[dwIndex].EapolUIFunc)
                {
                    TRACE1 (RPC, "ElOnBalloonClick: Response function found, msg (%ld)",
                            EapolUIContext->dwEAPOLUIMsgType);
                    // Cleanup any previous dialogs for this interface
                    if ((dwRetCode =
                                ElDialogCleanup (
                                    (WCHAR *)pszConnectionName,
                                    szCookie
                                    )) != NO_ERROR)
                    {
                        TRACE0 (RPC, "ElOnBalloonClick: Error in dialog cleanup");
                        break;
                    }

                    if ((dwRetCode = 
                            EapolUIFuncMap[dwIndex].EapolUIFunc (
                                pwszConnectionName,
                                pEapolUIContext
                            )) != NO_ERROR)
                    {
                        TRACE1 (RPC, "ElOnBalloonClick: Response function failed with error %ld",
                                dwRetCode);
                    }
                }
                else
                {
                    TRACE1 (RPC, "ElOnBalloonClick: No response function, msg (%ld)",
                            EapolUIContext.dwEAPOLUIMsgType);
                }
                break;
            }
        }
    }
    while (FALSE);

    hr = HRESULT_FROM_NT (dwRetCode);
    return hr;
}


//
// ElSecureEncodePw
//
// Description:
//
//      Encrypt password locally using user-ACL
//

DWORD
ElSecureEncodePw (
    IN  PWCHAR      *ppwszPassword,
    OUT DATA_BLOB   *pDataBlob
    )
{
    DWORD       dwRetCode = NO_ERROR;
    DATA_BLOB   blobIn, blobOut;

    do
    {
        blobIn.cbData = (wcslen (*ppwszPassword) + 1)*sizeof(WCHAR);
        blobIn.pbData = (BYTE *)*ppwszPassword;

        if (!CryptProtectData (
                    &blobIn,
                    L"",
                    NULL,
                    NULL,
                    NULL,
                    0,
                    &blobOut))
        {
            dwRetCode = GetLastError ();
            break;
        }
        
        // copy over blob to password

        if (pDataBlob->pbData != NULL)
        {
            FREE (pDataBlob->pbData);
            pDataBlob->pbData = NULL;
            pDataBlob->cbData = 0;
        }

        pDataBlob->pbData = MALLOC (blobOut.cbData);
        if (pDataBlob->pbData == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memcpy (pDataBlob->pbData, blobOut.pbData, blobOut.cbData);
        pDataBlob->cbData = blobOut.cbData;
    }
    while (FALSE);

    if (blobOut.pbData != NULL)
    {
        LocalFree (blobOut.pbData);
    }

    if (dwRetCode != NO_ERROR)
    {
        if (pDataBlob->pbData != NULL)
        {
            FREE (pDataBlob->pbData);
            pDataBlob->pbData = NULL;
            pDataBlob->cbData = 0;
        }
    }

    return dwRetCode;
}


//
// ElQueryConnectionStatusText
//
// Description:
//
// Function called by netshell, to query appropriate text for 802.1X states
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      ncs - NETCON_STATUS for the interface
//      pszStatusText - Detailed 802.1X status to be displayed
//
// Return values:
//      S_OK    - No error
//      S_FALSE - Error
//

HRESULT 
ElQueryConnectionStatusText ( 
        IN const GUID *  pGUIDConn, 
        IN const NETCON_STATUS ncs,
        IN OUT BSTR *  pszStatusText
        )
{
    WCHAR       wszGuid[GUID_STRING_LEN_WITH_TERM];
    WCHAR       cwszBuffer[MAX_BALLOON_MSG_LEN];
    EAPOL_INTF_STATE    EapolIntfState = {0};
    DWORD       dwStringId = 0;
    DWORD       dwRetCode = NO_ERROR;
    HRESULT     hr = S_OK;

    do
    {
        ZeroMemory ((PVOID)&EapolIntfState, sizeof(EAPOL_INTF_STATE));
        StringFromGUID2 (pGUIDConn, wszGuid, GUID_STRING_LEN_WITH_TERM);

        // Query current EAPOL state
        if ((dwRetCode = WZCEapolQueryState (
                        NULL,
                        wszGuid,
                        &EapolIntfState
                        )) != NO_ERROR)
        {
            break;
        }

        // Assign appropriate display string
        switch (EapolIntfState.dwEapUIState)
        {
            case 0:
                if (EapolIntfState.dwState == EAPOLSTATE_ACQUIRED)
                {
                    dwStringId =  SID_ContactingServer;
                }
                break;
            case EAPUISTATE_WAITING_FOR_IDENTITY:
                dwStringId = SID_AcquiringIdentity;
                break;
            case EAPUISTATE_WAITING_FOR_UI_RESPONSE:
                dwStringId = SID_UserResponse;
                break;
        }

        if (dwStringId != 0)
        {
            // Load string based on Id
            if (dwStringId <= SID_NoCertificateFound)
            {
                if (LoadString (GetModuleHandle(cszModuleName), dwStringId, cwszBuffer, MAX_BALLOON_MSG_LEN) == 0)
                {
                    dwRetCode = GetLastError ();
                    break;
                }
            }
            else
            {
                if (LoadString (WZCGetSPResModule(), dwStringId, cwszBuffer, MAX_BALLOON_MSG_LEN) == 0)
                {
                    dwRetCode = GetLastError ();
                    break;
                }
            }

            if (*pszStatusText)
            {
                if (!SysReAllocString (pszStatusText, cwszBuffer))
                {
                    dwRetCode = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
            }
            else
            {
                *pszStatusText = SysAllocString (cwszBuffer);
                if (*pszStatusText == NULL)
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }
        else
        {
            // Indicate to netshell that it need not process this response
            hr = S_FALSE;
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
        hr = HRESULT_FROM_NT (dwRetCode);

    WZCEapolFreeState (&EapolIntfState);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\quickcfg.h ===
#include "resource.h"
#include "xpsp1res.h"
#include "wzcdata.h"
#pragma once

// utility macro to convert a hexa digit into its value
#define HEX(c)  ((c)<='9'?(c)-'0':(c)<='F'?(c)-'A'+0xA:(c)-'a'+0xA)

// flags indicating various operational actions.
// flags are used in:
//   AddUniqueConfig()
#define WZCADD_HIGROUP     0x00000001   // add in front of its group
#define WZCADD_OVERWRITE   0x00000002   // overwrite data
#define WZCOP_VLIST        0x00000004   // operate on the visible list
#define WZCOP_PLIST        0x00000008   // operate on the preferred list
// defines legal lengths for the WEP Key material
#define WZC_WEPKMAT_40_ASC  5
#define WZC_WEPKMAT_40_HEX  10
#define WZC_WEPKMAT_104_ASC 13
#define WZC_WEPKMAT_104_HEX 26
#define WZC_WEPKMAT_128_ASC 16
#define WZC_WEPKMAT_128_HEX 32

class CWZCQuickCfg:
    public CDialogImpl<CWZCQuickCfg>
{
protected:

    // handles to the controls
    HWND    m_hLblInfo;
    HWND    m_hLblNetworks;
    HWND    m_hLstNetworks;
    HWND    m_hWarnIcon;
    HWND    m_hLblNoWepKInfo;
    HWND    m_hChkNoWepK;
    HWND    m_hLblWepKInfo;
    HWND    m_hLblWepK;
    HWND    m_hEdtWepK;
    HWND    m_hLblWepK2;
    HWND    m_hEdtWepK2;
    HWND    m_hChkOneX;
    HWND    m_hBtnAdvanced;
    HWND    m_hBtnConnect;
    // Handle to the images
    HIMAGELIST  m_hImgs;    // list items images

    BEGIN_MSG_MAP(CWZCQuickCfg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick);
        COMMAND_ID_HANDLER(IDC_WZCQCFG_CONNECT, OnConnect)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDCLOSE, OnCancel)
        COMMAND_ID_HANDLER(IDC_WZCQCFG_ADVANCED, OnAdvanced)
        COMMAND_ID_HANDLER(IDC_WZCQCFG_WEPK, OnWepKMatCmd)
        COMMAND_ID_HANDLER(IDC_WZCQCFG_CHK_NOWK, OnCheckConfirmNoWep)
    END_MSG_MAP()

    enum {IDD = IDD_WZCQCFG };

    // GUID on which we're operating
    GUID        m_Guid;
    // zero conf data on the interface
    BOOL        m_bHaveWZCData;
    INTF_ENTRY  m_IntfEntry;
    DWORD       m_dwOIDFlags;
    UINT        m_nTimer;
    HCURSOR     m_hCursor;
    BOOL        m_bKMatTouched; // tells whether the user changed the wep key

    // internal lists
    CWZCConfig   *m_pHdVList;   // list of visible configs
    CWZCConfig   *m_pHdPList;   // list of preferred configs

    DWORD GetWepKMaterial(UINT *pnKeyLen, LPBYTE *ppszKMat, DWORD *pdwCtlFlags);
    BOOL IsConfigInList(CWZCConfig *pHdList, PWZC_WLAN_CONFIG pwzcConfig, CWZCConfig **ppMatchingConfig = NULL);
    DWORD InitListView();
    DWORD GetOIDs(DWORD dwInFlags, LPDWORD pdwOutFlags);
    DWORD SavePreferredConfigs(PINTF_ENTRY pIntf, CWZCConfig *pStartCfg = NULL);
    DWORD FillVisibleList(PWZC_802_11_CONFIG_LIST pwzcVList);
    DWORD FillPreferredList(PWZC_802_11_CONFIG_LIST pwzcPList);
    DWORD RefreshListView();
    DWORD RefreshControls();

    // calls operating only on the internal lists (m_pHdVList or m_pHdPList)
    DWORD AddUniqueConfig(
            DWORD dwOpFlags,                // operation specific flags (see WZCADD_* flags)
            DWORD dwEntryFlags,             // flags for the config to be inserted
            PWZC_WLAN_CONFIG pwzcConfig,    // WZC Configuration
            CWZCConfig **ppNewNode = NULL);   // [out] gives the pointer of the newly created config object
public:
    LPWSTR  m_wszTitle;
    // class constructor
    CWZCQuickCfg(const GUID * pGuid);
    // class destructor
    ~CWZCQuickCfg();
    // Dialog related members
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnWepKMatCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCheckConfirmNoWep(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
public:
	INT_PTR SpDoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT<CWindow>*)this);
#ifdef _DEBUG
        m_bModal = true;
#endif //_DEBUG
		return ::DialogBoxParam(
                    WZCGetSPResModule(),
                    MAKEINTRESOURCE(CWZCQuickCfg::IDD),
                    ::GetActiveWindow(),
                    (DLGPROC)CWZCQuickCfg::StartDialogProc,
                    NULL);
	}
	BOOL SpEndDialog(INT_PTR nRetCode)
	{
		return ::EndDialog(m_hWnd, nRetCode);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\quickcfg.cpp ===
#include <precomp.h>
#include "wzcatl.h"
#include "quickcfg.h"
#include "eapolcfg.h"
#include "wzccore.h"
#include "wzchelp.h"

#define RFSH_TIMEOUT    3500
UINT g_TimerID = 373;
// g_wszHiddWebK is a string of 26 bullets (0x25cf - the hidden password char) and a NULL
WCHAR g_wszHiddWepK[] = {0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf,
                         0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x0000};

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

// Enhanced message box function
int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...);

//+---------------------------------------------------------------------------
// checks the validity of the WEP Key material and selects the
// material from the first invalid char (non hexa in hexa format or longer
// than the specified length
DWORD
CWZCQuickCfg::GetWepKMaterial(UINT *pnKeyLen, LPBYTE *ppbKMat, DWORD *pdwCtlFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    UINT    nKeyLen = ::GetWindowTextLength(m_hEdtWepK);
    DWORD   dwCtlFlags = 0;
    LPSTR   pszKMat = NULL;

    // we only accept the follwing material for WEP keys:
    // - no text (length 0) => there is no WEP key provided
    // - 5 chars or 10 hexadecimal digits (5byte / 40bit key)
    // - 13 chars or 26 hexadecimal digits (13byte / 104bit key)
    // - 16 chars or 32 hexadecimal digits (16byte / 128bit key)
    if (nKeyLen != 0 && 
        nKeyLen != WZC_WEPKMAT_40_ASC && nKeyLen != WZC_WEPKMAT_40_HEX &&
        nKeyLen != WZC_WEPKMAT_104_ASC && nKeyLen != WZC_WEPKMAT_104_HEX &&
        nKeyLen != WZC_WEPKMAT_128_ASC && nKeyLen != WZC_WEPKMAT_128_HEX)
    {
        dwErr = ERROR_INVALID_DATA;
    }
    else if (nKeyLen != 0) // the key is either ascii or hexadecimal, 40 or 104bit
    {
        dwCtlFlags = WZCCTL_WEPK_PRESENT;

        pszKMat = new CHAR[nKeyLen + 1];
        if (pszKMat == NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        // get the current key material from the edit control
        if (dwErr == ERROR_SUCCESS)
        {
            if (nKeyLen != ::GetWindowTextA(m_hEdtWepK, pszKMat, nKeyLen+1))
                dwErr = GetLastError();
        }

        // now we have the key material
        if (dwErr == ERROR_SUCCESS)
        {
            // if the key is provided in hexadecimal digits, mark it in
            // the ctl flags and do the conversion
            if (nKeyLen == WZC_WEPKMAT_40_HEX || nKeyLen == WZC_WEPKMAT_104_HEX || nKeyLen == WZC_WEPKMAT_128_HEX)
            {
                UINT i = 0, j = 0;

                dwCtlFlags |= WZCCTL_WEPK_XFORMAT;
                while (i < nKeyLen && pszKMat[i] != '\0')
                {
                    BYTE chHexByte = 0;
                
                    if (!isxdigit(pszKMat[i]) || !isxdigit(pszKMat[i+1]))
                    {
                        dwErr = ERROR_INVALID_DATA;
                        break;
                    }
                    chHexByte = HEX(pszKMat[i]) << 4;
                    i++;
                    chHexByte |= HEX(pszKMat[i]);
                    i++;
                    pszKMat[j++] = chHexByte;
                }

                // if everything went fine, since we parsed hexadecimal digits
                // it means the real length is half of the text length (two hexadecimal
                // digits per byte)
                if (dwErr == ERROR_SUCCESS)
                    nKeyLen /= 2;
            }
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        if (pdwCtlFlags != NULL)
            *pdwCtlFlags = dwCtlFlags;

        if (pnKeyLen != NULL)
            *pnKeyLen = nKeyLen;

        if (ppbKMat != NULL)
            *ppbKMat = (LPBYTE)pszKMat;
        else if (pszKMat != NULL)
            delete pszKMat;
    }
    else
    {
        if (pszKMat != NULL)
            delete pszKMat;
    }

    return dwErr;
}

//+---------------------------------------------------------------------
// IsConfigInList - checks whether the pwzcConfig (WZC_WLAN_CONFIG object) is
// in the list provided as the first parameter.
BOOL
CWZCQuickCfg::IsConfigInList(CWZCConfig *pHdList, PWZC_WLAN_CONFIG pwzcConfig, CWZCConfig **ppMatchingConfig)
{
    BOOL bYes = FALSE;

    if (pHdList != NULL)
    {
        CWZCConfig    *pwzcCrt;

        pwzcCrt = pHdList;
        do
        {
            if (pwzcCrt->Match(pwzcConfig))
            {
                if (ppMatchingConfig != NULL)
                    *ppMatchingConfig = pwzcCrt;

                bYes = TRUE;
                break;
            }
            pwzcCrt = pwzcCrt->m_pNext;
        } while(pwzcCrt != pHdList);
    }

    return bYes;
}

//+---------------------------------------------------------------------
// InitListView - initializes the networks list view (doesn't fill it in)
DWORD
CWZCQuickCfg::InitListView()
{
    RECT        rc;
    LV_COLUMN   lvc = {0};
    DWORD       dwStyle;

    // initialize the image list styles
    dwStyle = ::GetWindowLong(m_hLstNetworks, GWL_STYLE);
    ::SetWindowLong(m_hLstNetworks, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

    // Create state image lists
    m_hImgs = ImageList_LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDB_WZC_LISTICONS),
        16,
        0,
        PALETTEINDEX(6),
        IMAGE_BITMAP,
        0);

    ListView_SetImageList(m_hLstNetworks, m_hImgs, LVSIL_SMALL);
        
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;

    ::GetClientRect(m_hLstNetworks, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    //lvc.cx = rc.right;
    ListView_InsertColumn(m_hLstNetworks, 0, &lvc);

    ListView_SetExtendedListViewStyleEx(m_hLstNetworks, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------
// GetOIDs - gets the OIDs for the m_IntfEntry member. It assumes the
// GUID is set already
DWORD
CWZCQuickCfg::GetOIDs(DWORD dwInFlags, LPDWORD pdwOutFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwOutFlags;

    if (m_IntfEntry.wszGuid == NULL)
    {
        m_IntfEntry.wszGuid = (LPWSTR)RpcCAlloc(sizeof(WCHAR)*GUID_NCH);
        if (m_IntfEntry.wszGuid == NULL)
        {
            dwError = GetLastError();
        }
        else
        {
            // don't care of the return code. If getting the GUID fails (it shouldn't)
            // then we end up with a "0000..." GUID which will fail anyhow in the
            // RPC call later
            StringFromGUID2(
                m_Guid,
                m_IntfEntry.wszGuid, 
                GUID_NCH);
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        if (dwInFlags & INTF_DESCR)
        {
            RpcFree(m_IntfEntry.wszDescr);
            m_IntfEntry.wszDescr = NULL;
        }
        if (dwInFlags & INTF_PREFLIST)
        {
            RpcFree(m_IntfEntry.rdStSSIDList.pData);
            m_IntfEntry.rdStSSIDList.dwDataLen = 0;
            m_IntfEntry.rdStSSIDList.pData = NULL;
        }
        if (dwInFlags & INTF_SSID)
        {
            RpcFree(m_IntfEntry.rdSSID.pData);
            m_IntfEntry.rdSSID.dwDataLen = 0;
            m_IntfEntry.rdSSID.pData = NULL;
        }
        if (dwInFlags & INTF_BSSID)
        {
            RpcFree(m_IntfEntry.rdBSSID.pData);
            m_IntfEntry.rdBSSID.dwDataLen = 0;
            m_IntfEntry.rdBSSID.pData = NULL;
        }
        if (dwInFlags & INTF_BSSIDLIST)
        {
            RpcFree(m_IntfEntry.rdBSSIDList.pData);
            m_IntfEntry.rdBSSIDList.dwDataLen = 0;
            m_IntfEntry.rdBSSIDList.pData = NULL;
        }
        dwError = WZCQueryInterface(
                        NULL,
                        dwInFlags,
                        &m_IntfEntry,
                        pdwOutFlags);
    }

    return dwError;
}

//+---------------------------------------------------------------------
// SavePreferredConfigs - fills in the INTF_ENTRY parameter with all 
// the preferred networks from the m_pHdPList
DWORD
CWZCQuickCfg::SavePreferredConfigs(PINTF_ENTRY pIntf, CWZCConfig *pStartCfg)
{
    DWORD       dwErr = ERROR_SUCCESS;
    CWZCConfig  *pCrt = NULL;
    UINT        nPrefrd = 0;

    if (m_pHdPList != NULL)
    {
        // count first the number of preferred entries in the list
        pCrt = m_pHdPList;
        do
        {
            nPrefrd++;
            pCrt = pCrt->m_pNext;
        } while(pCrt != m_pHdPList);
    }

    if (nPrefrd > 0)
    {
        PWZC_802_11_CONFIG_LIST pwzcPrefrdList;
        UINT                    nwzcPrefrdSize;

        nwzcPrefrdSize = sizeof(WZC_802_11_CONFIG_LIST)+ (nPrefrd-1)*sizeof(WZC_WLAN_CONFIG);

        // allocate as much memory as needed for storing all the preferred SSIDs
        pwzcPrefrdList = (PWZC_802_11_CONFIG_LIST)RpcCAlloc(nwzcPrefrdSize);
        if (pwzcPrefrdList == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            DWORD dwLErr;

            pwzcPrefrdList->NumberOfItems = 0; 
            pwzcPrefrdList->Index = 0;
            // we have now all we need - start copying the preferred 
            pCrt = m_pHdPList;
            do
            {
                PWZC_WLAN_CONFIG    pPrefrdConfig;

                // if this is the configuration that needs to attempted first,
                // mark its index in the Index field.
                if (pCrt == pStartCfg)
                {
                    pwzcPrefrdList->Index = pwzcPrefrdList->NumberOfItems;

                    // save the 802.1x configuration just for the configuration we're connecting to!
                    if (pCrt->m_pEapolConfig != NULL)
                    {
                        dwLErr = pCrt->m_pEapolConfig->SaveEapolConfig(m_IntfEntry.wszGuid, &(pCrt->m_wzcConfig.Ssid));

                        if (dwErr == ERROR_SUCCESS)
                            dwErr = dwLErr;
                    }
                }

                pPrefrdConfig = &(pwzcPrefrdList->Config[pwzcPrefrdList->NumberOfItems++]);
                CopyMemory(pPrefrdConfig, &pCrt->m_wzcConfig, sizeof(WZC_WLAN_CONFIG));

                pCrt = pCrt->m_pNext;
            } while(pwzcPrefrdList->NumberOfItems < nPrefrd && pCrt != m_pHdPList);

            pIntf->rdStSSIDList.dwDataLen = nwzcPrefrdSize;
            pIntf->rdStSSIDList.pData = (LPBYTE)pwzcPrefrdList;
        }
    }
    else
    {
        pIntf->rdStSSIDList.dwDataLen = 0;
        pIntf->rdStSSIDList.pData = NULL;
    }

    return dwErr;
}

//+---------------------------------------------------------------------
// FillVisibleList - fills in the configs from the WZC_802_11_CONFIG_LIST object
// into the list of visible configs
DWORD
CWZCQuickCfg::FillVisibleList(PWZC_802_11_CONFIG_LIST pwzcVList)
{
    DWORD   dwErr = ERROR_SUCCESS;
    UINT    i;

    // cleanup whatever we might already have in the visible list
    if (m_pHdVList != NULL)
    {
        while (m_pHdVList->m_pNext != m_pHdVList)
        {
            delete m_pHdVList->m_pNext;
        }
        delete m_pHdVList;
        m_pHdVList = NULL;
    }

    if (pwzcVList != NULL)
    {
        for (i = 0; i < pwzcVList->NumberOfItems; i++)
        {
            dwErr = AddUniqueConfig(
                        0,                  // no op flags
                        WZC_DESCR_VISIBLE,  // this is a visible entry
                        &(pwzcVList->Config[i]));

            // reset the error if config was just duplicated
            if (dwErr == ERROR_DUPLICATE_TAG)
                dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------
// FillPreferredList - fills in the configs from the WZC_802_11_CONFIG_LIST object
// into the list of preferred configs
DWORD
CWZCQuickCfg::FillPreferredList(PWZC_802_11_CONFIG_LIST pwzcPList)
{
    DWORD   dwErr = ERROR_SUCCESS;
    UINT    i;

    // cleanup whatever we might already have in the preferred list
    if (m_pHdPList != NULL)
    {
        while (m_pHdPList ->m_pNext != m_pHdPList)
        {
            delete m_pHdPList ->m_pNext;
        }
        delete m_pHdPList;
        m_pHdPList = NULL;
    }

    if (pwzcPList != NULL)
    {
        for (i = 0; i < pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG    pwzcPConfig = &(pwzcPList->Config[i]);
            CWZCConfig          *pVConfig = NULL;
            DWORD               dwFlags = WZC_DESCR_PREFRD;

            // check whether this preferred is also visible and adjust dwFlags if so
            if (IsConfigInList(m_pHdVList, pwzcPConfig, &pVConfig))
            {
                // mark the visible entry as being also preferred!
                // NOTE: This is why the visible list needs to be filled in first!
                pVConfig->m_dwFlags |= WZC_DESCR_PREFRD;
                dwFlags |= WZC_DESCR_VISIBLE;
            }

            dwErr = AddUniqueConfig(
                        WZCADD_OVERWRITE,   // preferred entries cause info to be overwritten
                        dwFlags,
                        pwzcPConfig);

            // reset the error if config was just duplicated
            if (dwErr == ERROR_DUPLICATE_TAG)
                dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
// Adds the given configuration to the internal lists. The entries in the lists
// are ordered on InfrastructureMode in descending order. This way the Infrastructure
// entries will be on the top of the list while the adhoc entries will be on the
// bottom. (we rely on the order as it is given in NDIS_802_11_NETWORK_INFRASTRUCTURE)
DWORD
CWZCQuickCfg::AddUniqueConfig(
    DWORD            dwOpFlags,
    DWORD            dwEntryFlags,
    PWZC_WLAN_CONFIG pwzcConfig,
    CWZCConfig       **ppNewNode)
{
    DWORD       dwErr    = ERROR_SUCCESS;
    CWZCConfig  *pHdList = (dwEntryFlags & WZC_DESCR_PREFRD) ? m_pHdPList : m_pHdVList;

    // skip the null SSIDs from the visible list (coming from APs
    // not responding to broadcast SSID).
    if (pHdList == m_pHdVList)
    {
        UINT i = pwzcConfig->Ssid.SsidLength;
        for (; i > 0 && pwzcConfig->Ssid.Ssid[i-1] == 0; i--);
        if (i == 0)
            goto exit;
    }

    // if the list is currently empty, create the first entry as the head of the list
    if (pHdList == NULL)
    {
        pHdList = new CWZCConfig(dwEntryFlags, pwzcConfig);
        if (pHdList == NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        else
        {
            pHdList->m_pEapolConfig = new CEapolConfig;
            if (pHdList->m_pEapolConfig == NULL)
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            else
                dwErr = pHdList->m_pEapolConfig->LoadEapolConfig(m_IntfEntry.wszGuid, &(pHdList->m_wzcConfig.Ssid));

            if (dwErr != ERROR_SUCCESS)
            {
                delete pHdList;
                pHdList = NULL;
            }
        }

        // if the caller wants, return the pointer to the newly created object
        if (ppNewNode != NULL)
            *ppNewNode = pHdList;
    }
    else
    {
        // else the list already contains at least one element
        CWZCConfig *pCrt, *pHdGroup;

        // scan the list (keep in mind it is ordered descendingly on IM)
        pHdGroup = pCrt = pHdList;
        do
        {
            // check whether we entered a new group of configs (different InfrastructureMode)
            if (pHdGroup->m_wzcConfig.InfrastructureMode != pCrt->m_wzcConfig.InfrastructureMode)
                pHdGroup = pCrt;

            // if found an identical entry (same SSID and same InfraMode)
            // signal the DUPLICATE_TAG error
            if (pCrt->Match(pwzcConfig))
            {
                // merge the flags first
                pCrt->m_dwFlags |= dwEntryFlags;

                // If requested, copy over the new configuration.
                // If not explicitly requested, copy over only if the existent configuration
                // prooves to be weaker than the one being added.
                if (dwOpFlags & WZCADD_OVERWRITE || pCrt->Weaker(pwzcConfig))
                {
                    memcpy(&(pCrt->m_wzcConfig), pwzcConfig, sizeof(WZC_WLAN_CONFIG));
                }

                // if the caller wants, return the pointer to the matching entry
                if (ppNewNode != NULL)
                    *ppNewNode = pCrt;

                // signal there is already a matching config
                dwErr = ERROR_DUPLICATE_TAG;
            }
            pCrt = pCrt->m_pNext;
        } while (dwErr == ERROR_SUCCESS &&
                 pCrt != pHdList && 
                 pwzcConfig->InfrastructureMode <= pCrt->m_wzcConfig.InfrastructureMode);

        // if dwErr is unchanged, this means a new node has to be added ahead of pCrt node
        if (dwErr == ERROR_SUCCESS)
        {
            // create the new config and insert it ahead of this node.
            CWZCConfig *pNewConfig;

            pNewConfig = new CWZCConfig(dwEntryFlags, pwzcConfig);
            if (pNewConfig == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                pNewConfig->m_pEapolConfig = new CEapolConfig;
                if (pNewConfig->m_pEapolConfig == NULL)
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                else
                    dwErr = pNewConfig->m_pEapolConfig->LoadEapolConfig(m_IntfEntry.wszGuid, &(pNewConfig->m_wzcConfig.Ssid));

                if (dwErr != ERROR_SUCCESS)
                {
                    delete pNewConfig;
                    pNewConfig = NULL;
                }
            }

            if (dwErr == ERROR_SUCCESS)
            {
                INT nDiff;

                // if asked to insert in the head of the group, pCrt should point to this head
                if (dwOpFlags & WZCADD_HIGROUP)
                    pCrt = pHdGroup;

                pNewConfig->m_pPrev = pCrt->m_pPrev;
                pNewConfig->m_pNext = pCrt;
                pCrt->m_pPrev->m_pNext = pNewConfig;
                pCrt->m_pPrev = pNewConfig;

                // get the difference between the Infrastructure modes for the new node and
                // for the current head
                nDiff = pNewConfig->m_wzcConfig.InfrastructureMode - pHdList->m_wzcConfig.InfrastructureMode;

                // if the newly entered entry has the largest "key" in
                // the existent sequence, or it has to be inserted in the head of its group and it is
                // in the first group, then the global list head moves to the new entry
                if (nDiff > 0 || ((dwOpFlags & WZCADD_HIGROUP) && (nDiff == 0)))
                    pHdList = pNewConfig;
            }

            // if the caller wants, return the pointer to the newly created object
            if (ppNewNode != NULL)
                *ppNewNode = pNewConfig;
        }
    }

    if (dwEntryFlags & WZC_DESCR_PREFRD)
    {
        m_pHdPList = pHdList;
    }
    else
    {
        m_pHdVList = pHdList;
    }

exit:
    return dwErr;
}

//+---------------------------------------------------------------------------
// Display the Visible & Preferred lists into their controls
DWORD
CWZCQuickCfg::RefreshListView()
{
    DWORD       dwErr = ERROR_SUCCESS;
    CWZCConfig  *pCrt;
    UINT        i = 0;

    // clear first the list
    ListView_DeleteAllItems(m_hLstNetworks);

    // Add first VPI
    if (m_pHdPList != NULL)
    {
        pCrt = m_pHdPList;
        do
        {
            if (pCrt->m_dwFlags & WZC_DESCR_VISIBLE &&
                pCrt->m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure)
            {
                pCrt->m_nListIndex = i;
                pCrt->AddConfigToListView(m_hLstNetworks, i++);
            }
            pCrt = pCrt->m_pNext;
        } while (pCrt != m_pHdPList);
    }

    // Add next VI
    if (m_pHdVList != NULL)
    {
        pCrt = m_pHdVList;
        do
        {
            if (!(pCrt->m_dwFlags & WZC_DESCR_PREFRD) &&
                pCrt->m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure)
            {
                pCrt->m_nListIndex = i;
                pCrt->AddConfigToListView(m_hLstNetworks, i++);
            }
            pCrt = pCrt->m_pNext;
        } while (pCrt != m_pHdVList);
    }

    // Add now VPA
    if (m_pHdPList != NULL)
    {
        pCrt = m_pHdPList;
        do
        {
            if (pCrt->m_dwFlags & WZC_DESCR_VISIBLE &&
                pCrt->m_wzcConfig.InfrastructureMode == Ndis802_11IBSS)
            {
                pCrt->m_nListIndex = i;
                pCrt->AddConfigToListView(m_hLstNetworks, i++);
            }
            pCrt = pCrt->m_pNext;
        } while (pCrt != m_pHdPList);
    }

    // Add now VA
    if (m_pHdVList != NULL)
    {
        pCrt = m_pHdVList;
        do
        {
            if (!(pCrt->m_dwFlags & WZC_DESCR_PREFRD) &&
                pCrt->m_wzcConfig.InfrastructureMode == Ndis802_11IBSS)
            {
                pCrt->m_nListIndex = i;
                pCrt->AddConfigToListView(m_hLstNetworks, i++);
            }
            pCrt = pCrt->m_pNext;
        } while (pCrt != m_pHdVList);
    }

    ListView_SetItemState(m_hLstNetworks, 0, LVIS_SELECTED, LVIS_SELECTED);
    ListView_EnsureVisible(m_hLstNetworks, 0, FALSE);

    return dwErr;
}

DWORD
CWZCQuickCfg::RefreshControls()
{
    DWORD       dwError = ERROR_SUCCESS;
    CWZCConfig  *pConfig = NULL;
    LVITEM      lvi = {0};
    INT         iSelected;
    BOOL        bEnableWepCtrls = FALSE;
    UINT        nKLen = 0;
    UINT        nCheckOneX = BST_UNCHECKED;
    BOOL        bEnableOneX = FALSE;

    // get the selected item from the visible list
    iSelected = ListView_GetNextItem(m_hLstNetworks, -1, LVNI_SELECTED);
    if (iSelected >= 0)
    {
        lvi.mask  = LVIF_PARAM;
        lvi.iItem = iSelected;
        if (ListView_GetItem(m_hLstNetworks, &lvi))
        {
            pConfig = (CWZCConfig*)lvi.lParam;
        }
    }
    else
    {
        ::EnableWindow(m_hBtnConnect, FALSE);
        return dwError;
    }

    // since we just switched the networks, yes, the wep key can be seen as touched.
    // If we find out there is already a key available, we'll reset this flag and go
    // with that one until the user is clicking it.
    m_bKMatTouched = TRUE;

    if (pConfig != NULL)
    {
        CWZCConfig *pVConfig;

        // pick up the "privacy" bit from the matching visible configuration
        // NOTE: The test below should always succeed actually
        if (IsConfigInList(m_pHdVList, &(pConfig->m_wzcConfig), &pVConfig))
            bEnableWepCtrls = (pVConfig->m_wzcConfig.Privacy != 0);
        else
            bEnableWepCtrls = (pConfig->m_wzcConfig.Privacy != 0);

        if (pConfig->m_dwFlags & WZC_DESCR_PREFRD &&
            pConfig->m_wzcConfig.dwCtlFlags & WZCCTL_WEPK_PRESENT &&
            pConfig->m_wzcConfig.KeyLength > 0)
        {
            //--- when a password is to be displayed as hidden chars, don't put in
            //--- its actual length, but just 8 bulled chars.
            nKLen = 8;

            m_bKMatTouched = FALSE;
        }

        if (bEnableWepCtrls)
        {
            // For networks requiring privacy, 802.1X is going to be by default disabled and
            // locked out on all IBSS networks.
            if (pConfig->m_wzcConfig.InfrastructureMode == Ndis802_11IBSS)
            {
                nCheckOneX = BST_UNCHECKED;
                bEnableOneX = FALSE;
            }
            else
            {
                // for all non-preferred Infrastructure networks, 802.1X is going to be by default
                // enabled since these networks start with "the key is provided for me automatically"
                // which suggests 802.1X.
                if (!(pConfig->m_dwFlags & WZC_DESCR_PREFRD))
                {
                    nCheckOneX = BST_CHECKED;
                }
                else // this is a preferred Infrastructure network
                {
                    // initial 802.1X state is the one from the profile
                    nCheckOneX = pConfig->m_pEapolConfig->Is8021XEnabled() ? 
                                    BST_CHECKED:
                                    BST_UNCHECKED;
                }
                // for Infrastructure networks requiring privacy, user is allowed to change 802.1X state
                bEnableOneX = TRUE;
            }
        }
    }

    g_wszHiddWepK[nKLen] = L'\0';
    ::SetWindowText(m_hEdtWepK, g_wszHiddWepK);
    ::SetWindowText(m_hEdtWepK2, g_wszHiddWepK);
    g_wszHiddWepK[nKLen] = 0x25cf;

    if (bEnableWepCtrls)
    {
        CheckDlgButton(IDC_WZCQCFG_CHK_ONEX, nCheckOneX);
        ::EnableWindow(m_hChkOneX, bEnableOneX);

        if (::IsWindowEnabled(m_hEdtWepK2))
        {
            ::EnableWindow(m_hLblWepK2, FALSE);
            ::EnableWindow(m_hEdtWepK2, FALSE);
        }

        if (::IsWindowVisible(m_hLblNoWepKInfo))
        {
            ::ShowWindow(m_hWarnIcon, SW_HIDE);
            ::ShowWindow(m_hLblNoWepKInfo, SW_HIDE);
            ::ShowWindow(m_hChkNoWepK, SW_HIDE);
        }

        if (!::IsWindowVisible(m_hLblWepKInfo))
        {
            ::ShowWindow(m_hLblWepKInfo, SW_SHOW);
            ::ShowWindow(m_hLblWepK, SW_SHOW);
            ::ShowWindow(m_hEdtWepK, SW_SHOW);
            ::ShowWindow(m_hLblWepK2, SW_SHOW);
            ::ShowWindow(m_hEdtWepK2, SW_SHOW);
            ::ShowWindow(m_hChkOneX, SW_SHOW);
        }
    }
    else
    {
        if (::IsWindowVisible(m_hLblWepKInfo))
        {
            ::ShowWindow(m_hLblWepKInfo, SW_HIDE);
            ::ShowWindow(m_hLblWepK, SW_HIDE);
            ::ShowWindow(m_hEdtWepK, SW_HIDE);
            ::ShowWindow(m_hLblWepK2, SW_HIDE);
            ::ShowWindow(m_hEdtWepK2, SW_HIDE);
            ::ShowWindow(m_hChkOneX, SW_HIDE);
        }

        if (!::IsWindowVisible(m_hLblNoWepKInfo))
        {
            ::ShowWindow(m_hWarnIcon, SW_SHOW);
            ::ShowWindow(m_hLblNoWepKInfo, SW_SHOW);
            ::ShowWindow(m_hChkNoWepK, SW_SHOW);
            CheckDlgButton(IDC_WZCQCFG_CHK_NOWK,BST_UNCHECKED);
        }

        pConfig = NULL;     // reset the pointer to the configuration to force disable the "Connect" button
    }

    ::EnableWindow(m_hBtnConnect, pConfig != NULL);

    return dwError;
}

//+---------------------------------------------------------------------------
// class constructor
CWZCQuickCfg::CWZCQuickCfg(const GUID * pGuid)
{
    // initialize the UI handles
    m_hLblInfo = NULL;
    m_hLblNetworks = NULL;
    m_hLstNetworks = NULL;
    m_hLblWepKInfo = NULL;
    m_hLblWepK = NULL;
    m_hEdtWepK = NULL;
    m_hLblWepK2 = NULL;
    m_hEdtWepK2 = NULL;
    m_hChkOneX = NULL;
    m_hWarnIcon = NULL;
    m_hLblNoWepKInfo = NULL;
    m_hChkNoWepK = NULL;
    m_hBtnAdvanced = NULL;
    m_hBtnConnect = NULL;
    // initialize the Images handle
    m_hImgs     = NULL;

    // initialize the WZC data
    m_bHaveWZCData = FALSE;
    ZeroMemory(&m_IntfEntry, sizeof(INTF_ENTRY));
    m_dwOIDFlags = 0;
    m_nTimer = 0;
    m_hCursor = NULL;

    if (pGuid != NULL)
        m_Guid = *pGuid;
    else
        ZeroMemory(&m_Guid, sizeof(GUID));

    // init the internal list heads
    m_pHdVList = NULL;
    m_pHdPList = NULL;

    // init the connection
    m_wszTitle = NULL;
}

//+---------------------------------------------------------------------------
// class destructor
CWZCQuickCfg::~CWZCQuickCfg()
{
    if (m_hImgs != NULL)
        ImageList_Destroy(m_hImgs);

    // delete the internal INTF_ENTRY object
    WZCDeleteIntfObj(&m_IntfEntry);

    // delete the internal list of visible configurations
    // (is like filling it with NULL)
    FillVisibleList(NULL);

    // delete the internal list of preferred configurations
    // (is like filling it with NULL)
    FillPreferredList(NULL);

    if (m_nTimer != 0)
        KillTimer(m_nTimer);
}

//+---------------------------------------------------------------------------
// INIT_DIALOG handler
LRESULT
CWZCQuickCfg::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DWORD dwError;
    DWORD dwInFlags;
    BOOL  bEnableAll;

    m_bKMatTouched = TRUE;

    // reference the UI controls
    m_hLblInfo = GetDlgItem(IDC_WZCQCFG_LBL_INFO);
    m_hLblNetworks = GetDlgItem(IDC_WZCQCFG_LBL_NETWORKS);
    m_hLstNetworks = GetDlgItem(IDC_WZCQCFG_NETWORKS);
    m_hLblWepKInfo = GetDlgItem(IDC_WZCQCFG_LBL_WKINFO);
    m_hLblWepK = GetDlgItem(IDC_WZCQCFG_LBL_WEPK);
    m_hEdtWepK = GetDlgItem(IDC_WZCQCFG_WEPK);
    m_hLblWepK2 = GetDlgItem(IDC_WZCQCFG_LBL_WEPK2);
    m_hEdtWepK2 = GetDlgItem(IDC_WZCQCFG_WEPK2);
    m_hChkOneX = GetDlgItem(IDC_WZCQCFG_CHK_ONEX);
    m_hWarnIcon = GetDlgItem(IDC_WZCQCFG_ICO_WARN);
    m_hLblNoWepKInfo = GetDlgItem(IDC_WZCQCFG_LBL_NOWKINFO);
    m_hChkNoWepK = GetDlgItem(IDC_WZCQCFG_CHK_NOWK);
    m_hBtnAdvanced = GetDlgItem(IDC_WZCQCFG_ADVANCED);
    m_hBtnConnect = GetDlgItem(IDC_WZCQCFG_CONNECT);

    if (m_wszTitle != NULL)
        SetWindowText(m_wszTitle);

    if (m_hWarnIcon != NULL)
        ::SendMessage(m_hWarnIcon, STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_WARNING), (LPARAM)0);

    // sets the icon images for the list view
    InitListView();

    CenterWindow();
    m_dwOIDFlags = 0;
    dwInFlags = INTF_BSSIDLIST|INTF_PREFLIST|INTF_ALL_FLAGS;
    dwError = GetOIDs(dwInFlags,&m_dwOIDFlags);
    if (m_dwOIDFlags == dwInFlags)
    {
        // if the OIDs are supported, fill in everything.
        if (m_IntfEntry.dwCtlFlags & INTFCTL_OIDSSUPP)
        {
            // add the list of visible configs for this adapter
            FillVisibleList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdBSSIDList.pData);
            // add the list of preferred configs for this adapter
            FillPreferredList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdStSSIDList.pData);
            // fill in the list view
            RefreshListView();

            m_hCursor = SetCursor(LoadCursor(NULL, IDC_ARROW));
            // and enable all controls
            bEnableAll = TRUE;
        }
    }
    else
    {
        // switch the cursor to "App starting"
        m_hCursor = SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        // we should fill in the UI after Tr (see the WZC state machine)
        // Tr is 3secs (defined in ..zeroconf\server\state.h)
        m_nTimer = (UINT)SetTimer(g_TimerID, RFSH_TIMEOUT);
        bEnableAll = FALSE;
    }

    // now that the UI is filled up set the remaining controls to their
    // respective states.
    RefreshControls();

    ::EnableWindow(m_hLblInfo, bEnableAll);
    ::EnableWindow(m_hLblNetworks, bEnableAll);
    ::EnableWindow(m_hLstNetworks, bEnableAll);
    ::EnableWindow(m_hBtnAdvanced, bEnableAll);
    ::SetFocus(m_hLstNetworks);
    bHandled = TRUE;
    return 0;
}
//+---------------------------------------------------------------------------
// Help handlers
extern const WCHAR c_szNetCfgHelpFile[];
LRESULT
CWZCQuickCfg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::WinHelp(m_hWnd,
              c_wszWzcHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)g_aHelpIDs_IDD_WZCQCFG);
    bHandled = TRUE;
    return 0;
}
LRESULT 
CWZCQuickCfg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_wszWzcHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_IDD_WZCQCFG);
        bHandled = TRUE;
    }
    return 0;
}
//+---------------------------------------------------------------------
// Refresh timer handler
LRESULT
CWZCQuickCfg::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_nTimer != 0)
    {
        BOOL  bEnableAll;
        DWORD dwInFlags;

        // switch the cursor back to whatever it was
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        KillTimer(m_nTimer);
        m_nTimer = 0;

        m_dwOIDFlags = 0;
        dwInFlags = INTF_BSSIDLIST|INTF_PREFLIST|INTF_ALL_FLAGS;
        GetOIDs(dwInFlags,&m_dwOIDFlags);
        bEnableAll = (m_dwOIDFlags == dwInFlags) && (m_IntfEntry.dwCtlFlags & INTFCTL_OIDSSUPP);

        if (bEnableAll)
        {
            // add the list of visible configs for this adapter
            FillVisibleList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdBSSIDList.pData);
            // add the list of preferred configs for this adapter
            FillPreferredList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdStSSIDList.pData);
            // fill in the list view
            RefreshListView();
        }

        // now that the UI is filled up set the remaining controls to their
        // respective states.
        RefreshControls();

        // enable all the UI when done refreshing
        ::EnableWindow(m_hLblInfo, bEnableAll);
        ::EnableWindow(m_hLblNetworks, bEnableAll);
        ::EnableWindow(m_hLstNetworks, bEnableAll);
        ::EnableWindow(m_hBtnAdvanced, bEnableAll);
    }

    return 0;
}

//+---------------------------------------------------------------------
// Selection changed in the list
LRESULT CWZCQuickCfg::OnItemChanged(
    int idCtrl,
    LPNMHDR pnmh,
    BOOL& bHandled)
{
    bHandled = TRUE;
    RefreshControls();
    ::SetFocus(m_hLstNetworks);
    return 0;
}

//+---------------------------------------------------------------------
// User clicked an entry in the list
LRESULT CWZCQuickCfg::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    if (idCtrl == IDC_WZCQCFG_NETWORKS && ::IsWindowEnabled(m_hBtnConnect))
    {
        OnConnect(
            (WORD)pnmh->code,
            (WORD)pnmh->idFrom,
            pnmh->hwndFrom,
            bHandled);
    }
    return 0;
}

//+---------------------------------------------------------------------------
// OnConnect button handler
LRESULT
CWZCQuickCfg::OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DWORD       dwErr = ERROR_SUCCESS;
    INT         iSelected;
    CWZCConfig  *pConfig = NULL;
    UINT        nKeyLen;
    LPBYTE      pbKMat = NULL;
    DWORD       dwCtlFlags;
    BOOL        bOkToDismiss = TRUE;

    // get the selected item from the visible list
    iSelected = ListView_GetNextItem(m_hLstNetworks, -1, LVNI_SELECTED);
    if (iSelected < 0)
        dwErr = ERROR_GEN_FAILURE;

    // iSelected should be 0 otherwise "Connect" won't be enabled
    if (dwErr == ERROR_SUCCESS)
    {
        LVITEM      lvi = {0};
        lvi.mask  = LVIF_PARAM;
        lvi.iItem = iSelected;
        if (ListView_GetItem(m_hLstNetworks, &lvi))
        {
            pConfig = (CWZCConfig*)lvi.lParam;
            if (pConfig == NULL)
                dwErr = ERROR_GEN_FAILURE;
        }
        else
            dwErr = ERROR_GEN_FAILURE;
    }
 
    if (dwErr == ERROR_SUCCESS)
    {
        // here we should have a valid pConfig
        ASSERT(pConfig);

        if ((m_IntfEntry.dwCtlFlags & INTFCTL_CM_MASK) != Ndis802_11AutoUnknown &&
            (m_IntfEntry.dwCtlFlags & INTFCTL_CM_MASK) != pConfig->m_wzcConfig.InfrastructureMode)
        {
            // User is trying to access a network type (infra or adhoc) that they're not allowed to access.
            // Give them an error message
            UINT idMessage = (pConfig->m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure) ? IDS_CANTACCESSNET_INFRA : IDS_CANTACCESSNET_ADHOC;

            WCHAR szSSID[MAX_PATH];
            ListView_GetItemText(m_hLstNetworks, iSelected, 0, szSSID, ARRAYSIZE(szSSID));

            DisplayFormatMessage(m_hWnd, IDS_WZCERR_CAPTION, idMessage, MB_ICONERROR | MB_OK, szSSID);

            // Can't connect - error
            dwErr = ERROR_GEN_FAILURE;
            // Don't close the dialog
            bOkToDismiss = FALSE;
        }
    }

    // get the WEP key only if the user touched it. m_bKMatTouched is FALSE only when the configuration
    // selected is already in the preferred list and that preferred config already contained a key which was
    // not touched a bit by the user. Otherwise it is TRUE.
    if (dwErr == ERROR_SUCCESS && m_bKMatTouched)
    {
        UINT nIdsErr;

        // check whether the WEP key has the right format
        dwErr = GetWepKMaterial(&nKeyLen, &pbKMat, &dwCtlFlags);
        if (dwErr != ERROR_SUCCESS)
        {
            ::SendMessage(m_hEdtWepK, EM_SETSEL, 0, (LPARAM)-1);
            ::SetFocus(m_hEdtWepK);
            nIdsErr = IDS_WZCERR_INVALID_WEPK;
        }

        // check whether the WEP key is confirmed correctly
        if (dwErr == ERROR_SUCCESS && nKeyLen > 0)
        {
            WCHAR wszWepK1[32], wszWepK2[32];
            UINT nKeyLen1, nKeyLen2;

            nKeyLen1 = ::GetWindowText(m_hEdtWepK,  wszWepK1, sizeof(wszWepK1)/sizeof(WCHAR));
            nKeyLen2 = ::GetWindowText(m_hEdtWepK2, wszWepK2, sizeof(wszWepK2)/sizeof(WCHAR));

            if (nKeyLen1 != nKeyLen2 || nKeyLen1 == 0 || wcscmp(wszWepK1, wszWepK2) != 0)
            {
                nIdsErr = IDS_WZCERR_MISMATCHED_WEPK;
                ::SetWindowText(m_hEdtWepK2, L"");
                ::SetFocus(m_hEdtWepK2);
                dwErr = ERROR_INVALID_DATA;
            }
        }

        if (dwErr != ERROR_SUCCESS)
        {
            WCHAR wszBuffer[MAX_PATH];
            WCHAR wszCaption[MAX_PATH];

            LoadString(nIdsErr == IDS_WZCERR_INVALID_WEPK ? _Module.GetResourceInstance() : WZCGetSPResModule(),
                       nIdsErr,
                       wszBuffer,
                       MAX_PATH);
            LoadString(_Module.GetResourceInstance(),
                       IDS_WZCERR_CAPTION,
                       wszCaption,
                       MAX_PATH);
            MessageBox(wszBuffer, wszCaption, MB_ICONERROR|MB_OK);
        
            bOkToDismiss = FALSE;
        }
    }

    // we do have the right WEP key here, lets copy it to the corresponding config
    if (dwErr == ERROR_SUCCESS)
    {
        // if this configuration is not a preferred one, copy it in the preferred
        // list at the top of its group
        if (!(pConfig->m_dwFlags & WZC_DESCR_PREFRD))
        {
            // move this configuration out of the visible list
            pConfig->m_pNext->m_pPrev = pConfig->m_pPrev;
            pConfig->m_pPrev->m_pNext = pConfig->m_pNext;

            // if the list head pointed on this config, move it to
            // the next in the list
            if (m_pHdVList == pConfig)
                m_pHdVList = pConfig->m_pNext;

            // if the list head still points on the same config,
            // it means this was the only one in the list. So, null out the head.
            if (m_pHdVList == pConfig)
                m_pHdVList = NULL;

            //next insert this visible config in the preferred list
            if (m_pHdPList == NULL)
            {
                m_pHdPList = pConfig;
                pConfig->m_pNext = pConfig;
                pConfig->m_pPrev = pConfig;
            }
            else
            {
                CWZCConfig *pCrt;

                // the new preferred config comes on top of the list if:
                // (it is infrastructure) or (there are no infrastructures in the preferred list)
                if (pConfig->m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure ||
                    m_pHdPList->m_wzcConfig.InfrastructureMode == Ndis802_11IBSS)
                {
                    pCrt = m_pHdPList;
                    m_pHdPList = pConfig;
                }
                else // it definitely doesn't come the first in the list
                {
                    for (pCrt = m_pHdPList->m_pNext; pCrt != m_pHdPList; pCrt=pCrt->m_pNext)
                    {
                        // if this is the first configuration in the matching group break the loop
                        if (pCrt->m_wzcConfig.InfrastructureMode == Ndis802_11IBSS)
                            break;
                    }
                }

                // now we have to insert pConfig in the front of pCrt;
                pConfig->m_pNext = pCrt;
                pConfig->m_pPrev = pCrt->m_pPrev;
                pConfig->m_pNext->m_pPrev = pConfig;
                pConfig->m_pPrev->m_pNext = pConfig;
            }
        }
        // if the configuration is a preferred one, just make sure we copy over the 
        // privacy bit from the visible list. That one is the "real" thing
        else
        {
            CWZCConfig *pVConfig;

            if (IsConfigInList(m_pHdVList, &pConfig->m_wzcConfig, &pVConfig))
            {
                pConfig->m_wzcConfig.Privacy = pVConfig->m_wzcConfig.Privacy;
            }
        }

        // now the configuration is at its right position - put in the new WEP key, if any was typed in
        if (pConfig->m_wzcConfig.Privacy && m_bKMatTouched)
        {
            // if no key is provided, it means there is no key material.
            // All we do is to reset the corresponding bit - whatever material was there
            // will be preserved along with its length & format
            if (!(dwCtlFlags & WZCCTL_WEPK_PRESENT))
            {
                pConfig->m_wzcConfig.dwCtlFlags &= ~WZCCTL_WEPK_PRESENT;
            }
            else
            {
                // now if we have a WEP key, copy over its control flags and material
                pConfig->m_wzcConfig.dwCtlFlags = dwCtlFlags;
                ZeroMemory(pConfig->m_wzcConfig.KeyMaterial, WZCCTL_MAX_WEPK_MATERIAL);
                pConfig->m_wzcConfig.KeyLength = nKeyLen;
                memcpy(pConfig->m_wzcConfig.KeyMaterial, pbKMat, nKeyLen);
            }
        }
    }

    // if all 802.11 params have been taken care of, copy now the 802.1x params (if needed)
    if (dwErr == ERROR_SUCCESS &&
        pConfig->m_pEapolConfig != NULL)
    {
        // if the network is an infrastructure one fix the 802.1X state.
        // For ad hoc networks don't touch the 802.1x since it might mess the setting for a
        // corresponding Infrastructure network (802.1X doesn't differentiate between SSID Infra & SSID ad hoc)
        // 802.1X engine is smart enough to not act on ad hoc networks regardless its registry state!
        if (pConfig->m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure)
        {
            // if the network requires privacy, set its state according to the "Enable 802.1X" checkbox
            if (pConfig->m_wzcConfig.Privacy)
            {
                pConfig->m_pEapolConfig->Set8021XState(IsDlgButtonChecked(IDC_WZCQCFG_CHK_ONEX) == BST_CHECKED);
            }
            else // if the network doesn't require privacy - disable 802.1X!
            {
                // if the network is either ad hoc or infrastructure with no wep 
                // explicitly disable 802.1x
                pConfig->m_pEapolConfig->Set8021XState(0);
            }
        }
    }

    // ok, save the preferred list back to Wireless Zero Configuration Service
    if (dwErr == ERROR_SUCCESS)
    {
        RpcFree(m_IntfEntry.rdStSSIDList.pData);
        m_IntfEntry.rdStSSIDList.dwDataLen = 0;
        m_IntfEntry.rdStSSIDList.pData = NULL;
        dwErr = SavePreferredConfigs(&m_IntfEntry, pConfig);
    }

    if (dwErr == ERROR_SUCCESS)
    {
        // by saving the preferred list here we're forcing a hard reset to
        // the WZC State machine. This is what we want since we're here
        // as a consequence of a failure and a user intervention.
        dwErr = WZCSetInterface(
            NULL,
            INTF_PREFLIST,
            &m_IntfEntry,
            NULL);

        if (dwErr == ERROR_PARTIAL_COPY)
        {
            DisplayFormatMessage(
                m_hWnd,
                IDS_WZCERR_CAPTION,
                IDS_WZC_PARTIAL_APPLY,
                MB_ICONEXCLAMATION|MB_OK);

            dwErr = ERROR_SUCCESS;
        }
    }

    // in case of any failure we might want to warn the user (another popup?)
    // the question is what is the user supposed to do in such a case?
    if (dwErr != ERROR_SUCCESS)
    {
        dwErr = ERROR_SUCCESS;
    }

    if(pbKMat != NULL)
        delete pbKMat;

    if (bOkToDismiss)
    {
        bHandled = TRUE;
        SpEndDialog(IDOK);
    }
    return 0;
}

//+---------------------------------------------------------------------------
// OK button handler
LRESULT
CWZCQuickCfg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = TRUE;
    SpEndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
// Advanced button handler
LRESULT
CWZCQuickCfg::OnAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = TRUE;
    SpEndDialog(IDC_WZCQCFG_ADVANCED);
    return 0;
}

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...)
{
    int iResult = IDCANCEL;
    TCHAR szError[1024 + 1]; *szError = 0;
    TCHAR szCaption[256 + 1];
    TCHAR szFormat[1024 + 1]; *szFormat = 0;

    // Load and format the error body
    if (LoadString(WZCGetSPResModule(), idFormatString, szFormat, ARRAYSIZE(szFormat)))
    {
        va_list arguments;
        va_start(arguments, uType);

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, szError, ARRAYSIZE(szError), &arguments))
        {
            // Load the caption
            if (LoadString(_Module.GetResourceInstance(), idCaption, szCaption, ARRAYSIZE(szCaption)))
            {
                iResult = MessageBox(hwnd, szError, szCaption, uType);
            }
        }

        va_end(arguments);
    }
    return iResult;
}

//+---------------------------------------------------------------------------
// Notification handler for the wep key edit text box
LRESULT
CWZCQuickCfg::OnWepKMatCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (wNotifyCode == EN_SETFOCUS)
    {
        if (!m_bKMatTouched)
        {
            // the user has just clicked for the first time on an existent key.. clear out the fields,
            // standing for "The key is provided automatically"
            ::SetWindowText(m_hEdtWepK, L"");
            ::SetWindowText(m_hEdtWepK2, L"");
            ::EnableWindow(m_hLblWepK2, FALSE); // disable confirmation label for empty key
            ::EnableWindow(m_hEdtWepK2, FALSE); // disable confirmation edit for empty key
            m_bKMatTouched = TRUE;

            // if the 802.1X checkbox is enabled then we do have to check it here!          
            if (::IsWindowEnabled(m_hChkOneX))
                CheckDlgButton(IDC_WZCQCFG_CHK_ONEX, BST_CHECKED);
        }
    }
    if (wNotifyCode == EN_CHANGE)
    {
        UINT nKMatLen = ::GetWindowTextLength(m_hEdtWepK);

        if (!::IsWindowEnabled(m_hEdtWepK2) && nKMatLen > 0)
        {
            // user just typed in some key material - enable the confirmation text
            ::EnableWindow(m_hLblWepK2, TRUE);
            ::EnableWindow(m_hEdtWepK2, TRUE);
            // also uncheck 802.1x checkbox
            if (::IsWindowEnabled(m_hChkOneX))
                CheckDlgButton(IDC_WZCQCFG_CHK_ONEX, BST_UNCHECKED);
        }
        if (::IsWindowEnabled(m_hEdtWepK2) && nKMatLen == 0)
        {
            // user just deleted all of the key material - switching to 
            // "The key is provided for me automatically"
            ::SetWindowText(m_hEdtWepK2, L"");
            ::EnableWindow(m_hLblWepK2, FALSE);
            ::EnableWindow(m_hEdtWepK2, FALSE);
            // auto key suggests 802.1X
            if (::IsWindowEnabled(m_hChkOneX))
                CheckDlgButton(IDC_WZCQCFG_CHK_ONEX, BST_CHECKED);
        }
    }

    return 0;
}

LRESULT
CWZCQuickCfg::OnCheckConfirmNoWep(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    ::EnableWindow(m_hBtnConnect, IsDlgButtonChecked(IDC_WZCQCFG_CHK_NOWK) == BST_CHECKED);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\inf\makefile.inc ===
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\eapol.inf: eapol.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzccore.h ===
#pragma once

// number of (generic type) characters in a GUID string representation
#define GUID_NCH              sizeof("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}")

#define CONN_PROPERTIES_DLG   _T("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{7007ACC7-3202-11D1-AAD2-00805FC1270E}\\")
#define COMM_WLAN_PROPS_VERB  _T("wzcproperties")

//--------------------------------------------------------
// "CanShowBalloon" hook into the WZC part of the UI pipe
// This call is supposed to return either S_OK and a pszBalloonText
// to be filled into the popping balloon, or S_FALSE if no balloon
// is to be popped up
HRESULT 
WZCDlgCanShowBalloon ( 
    IN const GUID * pGUIDConn, 
    IN OUT   BSTR * pszBalloonText, 
    IN OUT   BSTR * pszCookie);

//--------------------------------------------------------
// "OnBalloonClick" hook into the WZC part of the UI pipe.
// This call is supposed to be called whenever the user clicks
// on a balloon previously displayed by WZC
HRESULT 
WZCDlgOnBalloonClick ( 
    IN const GUID * pGUIDConn, 
    IN const LPWSTR wszConnectionName,
    IN const BSTR szCookie);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzchelp.h ===
//{{NO_DEPENDENCIES}}
// WZC dialog help file
// Generated by FlorinT 05/07/2001
// Used by wzcdlg.rc
#pragma once

#define IDH_WZCQCFG_NETWORKS            40002004
#define IDH_WZCQCFG_CHK_NOWK            40002014
#define IDH_WZCQCFG_WEPK                40002007
#define IDH_WZCQCFG_WEPK2               40002010
#define IDH_WZCQCFG_ADVANCED            40002008
#define IDH_WZCQCFG_CONNECT             40002009
#define IDH_WZCQCFG_CHK_ONEX            40002016
#define IDH_DISABLEHELP                 ((DWORD)-1)

extern const WCHAR c_wszWzcHelpFile[];
extern const DWORD g_aHelpIDs_IDD_WZCQCFG[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzchelp.cpp ===
//{{NO_DEPENDENCIES}}
// WZC dialog help file
// Generated by FlorinT 05/07/2001
// Used by wzcdlg.rc
#include <precomp.h>
#include "resource.h"
#include "xpsp1res.h"
#include "wzchelp.h"

extern const __declspec(selectany) WCHAR c_wszWzcHelpFile[] = L"netcfg.hlp";

const DWORD g_aHelpIDs_IDD_WZCQCFG[] =
{
    IDC_WZCQCFG_LBL_INFO,       IDH_DISABLEHELP,
    IDC_WZCQCFG_LBL_NETWORKS,   IDH_WZCQCFG_NETWORKS,
    IDC_WZCQCFG_NETWORKS,       IDH_WZCQCFG_NETWORKS,
    IDC_WZCQCFG_ICO_WARN,       IDH_DISABLEHELP,
    IDC_WZCQCFG_LBL_NOWKINFO,   IDH_DISABLEHELP,
    IDC_WZCQCFG_CHK_NOWK,       IDH_WZCQCFG_CHK_NOWK,
    IDC_WZCQCFG_LBL_WKINFO,     IDH_DISABLEHELP,
    IDC_WZCQCFG_LBL_WEPK,       IDH_WZCQCFG_WEPK,
    IDC_WZCQCFG_WEPK,           IDH_WZCQCFG_WEPK,
    IDC_WZCQCFG_LBL_WEPK2,      IDH_WZCQCFG_WEPK2,
    IDC_WZCQCFG_WEPK2,          IDH_WZCQCFG_WEPK2,
    IDC_WZCQCFG_CHK_ONEX,       IDH_WZCQCFG_CHK_ONEX,
    IDC_WZCQCFG_LBL_NOTWORKING, IDH_DISABLEHELP,
    IDC_WZCQCFG_ADVANCED,       IDH_WZCQCFG_ADVANCED,
    IDC_WZCQCFG_CONNECT,        IDH_WZCQCFG_CONNECT,                       
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\parser\makefile.inc ===
#
# Copy the ini file next to the parser in the obj dir
#

$(BH_BUILD_ROOT)\$(O)\$(TARGETNAME).ini: $(TARGETNAME).ini
    copy $(TARGETNAME).ini $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\parser\eapol.c ===
//============================================================================//
//  MODULE: eapol.c                                                                                                  //
//                                                                                                                 //
//  Description: EAPOL/802.1X Parser                                                                    //
//                                                                                                                 //
//  Note: info for this parsers was gleaned from :
//  IEEE 802.1X
//                                                                                                                 //
//  Modification History                                                                                           //
//                                                                                                                 //
//  timmoore       04/04/2000          Created                                                       //
//===========================================================================//
#include "eapol.h"

// the type of EAPOL packet
LABELED_BYTE lbEAPOLCode[] = 
{
    {  EAPOL_PACKET,          "Packet" },
    {  EAPOL_START,           "Start" },
    {  EAPOL_LOGOFF,          "Logoff"  },
    {  EAPOL_KEY,             "Key"  },       
};

SET EAPOLCodeSET = {(sizeof(lbEAPOLCode)/sizeof(LABELED_BYTE)), lbEAPOLCode };

// property table
PROPERTYINFO EAPOL_Prop[] = {
    //EAPOL_SUMMARY
    { 0, 0,
      "Summary",
      "Summary of EAPOL packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,                     
      EAPOL_FormatSummary   
    },

    //EAPOL_VERSION   
    { 0, 0,
      "Version",
      "EAPOL packet type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_TYPE  
    { 0, 0,
      "Type",
      "EAPOL packet type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &EAPOLCodeSET,
      80,
      FormatPropertyInstance
    },

    //EAPOL_LENGTH
    { 0, 0,
      "Length",
      "EAPOL length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_SIGNTYPE
    { 0, 0,
      "Signature Type",
      "EAPOL Signature Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYTYPE
    { 0, 0,
      "Key Type",
      "EAPOL Key Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYLENGTH
    { 0, 0,
      "Length",
      "EAPOL Key length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_REPLAY
    { 0, 0,
      "Replay",
      "EAPOL Replay Counter",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYIV
    { 0, 0,
      "Key IV",
      "EAPOL Key IV",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYINDEX
    { 0, 0,
      "Index",
      "EAPOL Key Index",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYSIGN
    { 0, 0,
      "Key Signature",
      "EAPOL Key Signature",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEY
    { 0, 0,
      "Key",
      "EAPOL Key",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },
   
};

WORD    NUM_EAPOL_PROPERTIES = sizeof(EAPOL_Prop) / sizeof(PROPERTYINFO);

// Define the entry points that we will pass back at dll entry time...
ENTRYPOINTS EAPOLEntryPoints =
{
    // EAPOL Entry Points
    EAPOL_Register,
    EAPOL_Deregister,
    EAPOL_RecognizeFrame,
    EAPOL_AttachProperties,
    EAPOL_FormatProperties
};
    
// Globals -------------------------------------------------------------------
HPROTOCOL hEAPOL = NULL;
HPROTOCOL hEAP = NULL;

//============================================================================
//  Function: EAPOL_Register
// 
//  Description: Create our property database and handoff sets.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
void BHAPI EAPOL_Register( HPROTOCOL hEAPOL)
{
    WORD  i;

    // tell the kernel to make reserve some space for our property table
    CreatePropertyDatabase( hEAPOL, NUM_EAPOL_PROPERTIES);

    // add our properties to the kernel's database
    for( i = 0; i < NUM_EAPOL_PROPERTIES; i++)
    {
        AddProperty( hEAPOL, &EAPOL_Prop[i]);
    }
    hEAP = GetProtocolFromName("EAP");
}

//============================================================================
//  Function: EAPOL_Deregister
// 
//  Description: Destroy our property database and handoff set
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
VOID WINAPI EAPOL_Deregister( HPROTOCOL hEAPOL)
{
    // tell the kernel that it may now free our database
    DestroyPropertyDatabase( hEAPOL);
}

//============================================================================
//  Function: EAPOL_RecognizeFrame
// 
//  Description: Determine whether we exist in the frame at the spot 
//               indicated. We also indicate who (if anyone) follows us
//               and how much of the frame we claim.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
ULPBYTE BHAPI EAPOL_RecognizeFrame( HFRAME      hFrame,         
                                      ULPBYTE      pMacFrame,      
                                      ULPBYTE      pEAPOLFrame, 
                                      DWORD       MacType,        
                                      DWORD       BytesLeft,      
                                      HPROTOCOL   hPrevProtocol,  
                                      DWORD       nPrevProtOffset,
                                      LPDWORD     pProtocolStatus,
                                      LPHPROTOCOL phNextProtocol,
                                      PDWORD_PTR     InstData)       
{
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)pEAPOLFrame;
    if(pEAPOLHeader->bType == EAPOL_START || pEAPOLHeader->bType == EAPOL_LOGOFF
     || pEAPOLHeader->bType == EAPOL_KEY) {
        *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
        return NULL;
    }
    else {
        *phNextProtocol = hEAP;
        *pProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;
        return pEAPOLFrame + 4;
    }
}

//============================================================================
//  Function: EAPOL_AttachProperties
// 
//  Description: Indicate where in the frame each of our properties live.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
ULPBYTE BHAPI EAPOL_AttachProperties(  HFRAME      hFrame,         
                                    ULPBYTE      pMacFrame,     
                                    ULPBYTE      pEAPOLFrame,   
                                    DWORD       MacType,        
                                    DWORD       BytesLeft,      
                                    HPROTOCOL   hPrevProtocol,  
                                    DWORD       nPrevProtOffset,
                                    DWORD_PTR       InstData)       

{
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)pEAPOLFrame;

    // summary line
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_SUMMARY].hProperty,
                            (WORD)BytesLeft,
                            (ULPBYTE)pEAPOLFrame,
                            0, 0, 0);

    // Version
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_VERSION].hProperty,
                            sizeof(BYTE),
                            &(pEAPOLHeader->bVersion),
                            0, 1, 0);

    // EAPOL Type
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_TYPE].hProperty,
                            sizeof(BYTE),
                            &(pEAPOLHeader->bType),
                            0, 1, 0);

    // Length
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_LENGTH].hProperty,
                            sizeof(WORD),
                            &(pEAPOLHeader->wLength),
                            0, 1, 0);

    if(pEAPOLHeader->bType == EAPOL_KEY)
    {
		ULPEAPOLKEY pEAPOLKey = (ULPEAPOLKEY)&(pEAPOLHeader->pEAPPacket[0]);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_SIGNTYPE].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bSignType),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYTYPE].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bKeyType),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYLENGTH].hProperty,
                                    sizeof(WORD),
                                    &(pEAPOLKey->wKeyLength),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYREPLAY].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeyReplay),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYIV].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeyIV),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYINDEX].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bKeyIndex),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYSIGN].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeySign),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEY].hProperty,
                                    XCHG(pEAPOLKey->wKeyLength),
                                    &(pEAPOLKey->bKey),
                                    0, 1, 0);
    }
    return NULL;
}

//============================================================================
//  Function: EAPOL_FormatProperties
// 
//  Description: Format the given properties on the given frame.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
DWORD BHAPI EAPOL_FormatProperties(  HFRAME          hFrame,
                                   ULPBYTE          pMacFrame,
                                   ULPBYTE          pEAPOLFrame,
                                   DWORD           nPropertyInsts,
                                   LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}

//============================================================================
//  Function: EAPOL_FormatSummary
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
VOID WINAPIV EAPOL_FormatSummary( LPPROPERTYINST pPropertyInst)
{
    ULPBYTE       pReturnedString = pPropertyInst->szPropertyText;
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)(pPropertyInst->lpData);
    char*        szTempString;

    // fetch the message type
    szTempString = LookupByteSetString( &EAPOLCodeSET, pEAPOLHeader->bType );
    if( szTempString == NULL )
    {
        wsprintf( pReturnedString, "Packet Type: Unknown");
    }
    else
    {
        pReturnedString += wsprintf( pReturnedString, "Packet: %s", szTempString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzcdata.h ===
#pragma once

////////////////////////////////////////////////////////////////////////
// CWZCConfig related stuff
//
// flags used in CWZCConfig::m_dwFlags
// the entry is preferred (user defined)
#define WZC_DESCR_PREFRD    0x00000001
// the entry is currently visible in the air
#define WZC_DESCR_VISIBLE   0x00000002
// the entry is currently active (the one plumbed to the adapter)
#define WZC_DESCR_ACTIVE    0x00000004

// flags used to select state & item images
#define WZCIMG_PREFR_NOSEL     0    // empty check box
#define WZCIMG_PREFR_SELECT    1    // checked check box
#define WZCIMG_INFRA_AIRING    2    // infra icon
#define WZCIMG_INFRA_ACTIVE    3    // infra icon + blue circle
#define WZCIMG_INFRA_SILENT    4    // infra icon + red cross
#define WZCIMG_ADHOC_AIRING    5    // adhoc icon
#define WZCIMG_ADHOC_ACTIVE    6    // adhoc icon + blue circle
#define WZCIMG_ADHOC_SILENT    7    // adhoc icon + red cross

// object attached to each entry in the list
class CWZCConfig
{
public:
    class CWZCConfig    *m_pPrev, *m_pNext;
    INT                 m_nListIndex;           // index of the entry in the list
    DWORD               m_dwFlags;              // WZC_DESCR* flags
    WZC_WLAN_CONFIG     m_wzcConfig;            // all WZC configuration
    class CEapolConfig  *m_pEapolConfig;        // all 802.1x configuration

public:
    // constructor
    CWZCConfig(DWORD dwFlags, PWZC_WLAN_CONFIG pwzcConfig);
    // destructor
    ~CWZCConfig();
    // checks whether this SSID matches with the one from pwzcConfig
    BOOL Match(PWZC_WLAN_CONFIG pwzcConfig);
    // checks whether this configuration is weaker than the one given as parameter
    BOOL Weaker(PWZC_WLAN_CONFIG pwzcConfig);
    // add the Configuration to the list of entries in the list view
    DWORD AddConfigToListView(HWND hwndLV, INT nPos);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzcdata.cpp ===
#include <precomp.h>
#include "eapolcfg.h"
#include "wzcdata.h"

////////////////////////////////////////////////////////////////////////
// CWZCConfig related stuff
//
//+---------------------------------------------------------------------------
// constructor
CWZCConfig::CWZCConfig(DWORD dwFlags, PWZC_WLAN_CONFIG pwzcConfig)
{
    m_dwFlags = dwFlags;
    CopyMemory(&m_wzcConfig, pwzcConfig, sizeof(WZC_WLAN_CONFIG));
    m_pPrev = m_pNext = this;
    m_nListIndex = -1;
    m_pEapolConfig = NULL;
}

//+---------------------------------------------------------------------------
// destructor
CWZCConfig::~CWZCConfig()
{
    // remove the object from the list
    m_pPrev->m_pNext = m_pNext;
    m_pNext->m_pPrev = m_pPrev;
    if (m_pEapolConfig != NULL)
    {
        delete m_pEapolConfig;
        m_pEapolConfig = NULL;
    }
}

//+---------------------------------------------------------------------------
// checks whether this configuration matches with the one from pwzcConfig
BOOL
CWZCConfig::Match(PWZC_WLAN_CONFIG pwzcConfig)
{
    BOOL bMatch;

    // check whether the InfrastructureMode matches
    bMatch = (m_wzcConfig.InfrastructureMode == pwzcConfig->InfrastructureMode);
    // check whether the SSIDs are of the same length
    bMatch = bMatch && (m_wzcConfig.Ssid.SsidLength == pwzcConfig->Ssid.SsidLength);
    if (bMatch && m_wzcConfig.Ssid.SsidLength != 0)
    {
        // in case of Non empty SSIDs, check if they're the same
        bMatch = (memcmp(m_wzcConfig.Ssid.Ssid,
                         pwzcConfig->Ssid.Ssid,
                         m_wzcConfig.Ssid.SsidLength)) == 0;
    }

    return bMatch;
}

//+---------------------------------------------------------------------------
// checks whether this configuration is weaker than the one given as parameter
BOOL 
CWZCConfig::Weaker(PWZC_WLAN_CONFIG pwzcConfig)
{
    BOOL bWeaker = FALSE;

    // a configuration is stronger if its privacy bit is set while the matching one is not set
    if (m_wzcConfig.Privacy != pwzcConfig->Privacy)
        bWeaker = pwzcConfig->Privacy;
    // if privacy bits are identical, a configuration is stronger if it has Open Auth mode
    else if (m_wzcConfig.AuthenticationMode != pwzcConfig->AuthenticationMode)
        bWeaker = (pwzcConfig->AuthenticationMode == Ndis802_11AuthModeOpen);

    return bWeaker;
}


DWORD
CWZCConfig::AddConfigToListView(HWND hwndLV, INT nPos)
{
    DWORD   dwErr = ERROR_SUCCESS;
    // ugly but this is life. In order to convert the SSID to LPWSTR we need a buffer.
    // We know an SSID can't exceed 32 chars (see NDIS_802_11_SSID from ntddndis.h) so
    // make room for the null terminator and that's it. We could do mem alloc but I'm
    // not sure it worth the effort (at runtime).
    WCHAR   wszSSID[33];
    UINT    nLenSSID = 0;

    // convert the LPSTR (original SSID format) to LPWSTR (needed in List Ctrl)
    if (m_wzcConfig.Ssid.SsidLength != 0)
    {
        nLenSSID = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        (LPCSTR)m_wzcConfig.Ssid.Ssid,
                        m_wzcConfig.Ssid.SsidLength,
                        wszSSID,
                        sizeof(wszSSID)/sizeof(WCHAR));

        if (nLenSSID == 0)
            dwErr = GetLastError();
    }

    if (dwErr == ERROR_SUCCESS)
    {
        LVITEM lvi={0};
        UINT   nImgIdx;

        // put the null terminator
        wszSSID[nLenSSID]=L'\0';

        // get the item's image index
        if (m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure)
        {
            nImgIdx = (m_dwFlags & WZC_DESCR_ACTIVE) ? WZCIMG_INFRA_ACTIVE :
                        ((m_dwFlags & WZC_DESCR_VISIBLE) ? WZCIMG_INFRA_AIRING : WZCIMG_INFRA_SILENT);
        }
        else
        {
            nImgIdx = (m_dwFlags & WZC_DESCR_ACTIVE) ? WZCIMG_ADHOC_ACTIVE :
                        ((m_dwFlags & WZC_DESCR_VISIBLE) ? WZCIMG_ADHOC_AIRING : WZCIMG_ADHOC_SILENT);
        }

        lvi.iItem = nPos;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        lvi.pszText = wszSSID;
        lvi.iImage = nImgIdx;
        lvi.lParam = (LPARAM)this;
        // store the list position in the object
        m_nListIndex = ListView_InsertItem(hwndLV, &lvi);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\parser\eapol.h ===
//============================================================================//
//  MODULE: eapol.h                                                                                                  //
//                                                                                                                 //
//  Description: EAPOL/802.1X Parser                                                                    //
//                                                                                                                 //
//  Note: info for this parsers was gleaned from :
//  IEEE 802.1X
//                                                                                                                 //
//  Modification History                                                                                           //
//                                                                                                                 //
//  timmoore       04/04/2000           Created                                                       //
//===========================================================================//

#ifndef __EAPOL_H_
#define __EAPOL_H_

#include <windows.h>
#include <netmon.h>
#include <stdlib.h>
#include <string.h>
// #include <parser.h>

// EAPOL Header structure----------------------------------------------------
#pragma pack(1)
typedef struct _EAPHDR 
{
    BYTE bVersion;
    BYTE bType;   // packet type
    WORD wLength;
    BYTE pEAPPacket[0];
} EAPHDR;

typedef EAPHDR UNALIGNED *ULPEAPHDR;

typedef struct _EAPOLKEY
{
	BYTE	bSignType;
	BYTE	bKeyType;
	WORD	wKeyLength;
	BYTE	bKeyReplay[16];
	BYTE	bKeyIV[16];
	BYTE	bKeyIndex;
	BYTE	bKeySign[16];
	BYTE	bKey[0];
} EAPOLKEY;

typedef EAPOLKEY UNALIGNED *ULPEAPOLKEY;

#pragma pack()

// packet types
#define EAPOL_PACKET    0
#define EAPOL_START     1
#define EAPOL_LOGOFF    2
#define EAPOL_KEY       3

// property table indice
typedef enum
{
    EAPOL_SUMMARY,
    EAPOL_VERSION,
    EAPOL_TYPE,
    EAPOL_LENGTH,
    EAPOL_KEY_SIGNTYPE,
    EAPOL_KEY_KEYTYPE,
    EAPOL_KEY_KEYLENGTH,
    EAPOL_KEY_KEYREPLAY,
    EAPOL_KEY_KEYIV,
    EAPOL_KEY_KEYINDEX,
    EAPOL_KEY_KEYSIGN,
    EAPOL_KEY_KEY,
    EAPOL_UNKNOWN,
};

// Functions Prototypes --------------------------------------------------------
extern VOID   WINAPI EAPOL_Register( HPROTOCOL hEAPOL);
extern VOID   WINAPI EAPOL_Deregister( HPROTOCOL hEAPOL);
extern ULPBYTE WINAPI EAPOL_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);
extern ULPBYTE WINAPI EAPOL_AttachProperties(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);
extern DWORD  WINAPI EAPOL_FormatProperties( HFRAME hFrame, 
                                                ULPBYTE pMacFrame, 
                                                ULPBYTE pEAPOLFrame, 
                                                DWORD nPropertyInsts, 
                                                LPPROPERTYINST p);

VOID WINAPIV EAPOL_FormatSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV EAPOL_FormatAttribute( LPPROPERTYINST pPropertyInst);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\dialog\wzcdlg.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzcdlg.c

Abstract:

    Main file for wzcdlg

Author:

    SachinS    20-March-2001

Environment:

    User Level: Win32

Revision History:

--*/

#include <precomp.h>
#include <wzcdlg.h>
#include <wzcsapi.h>
#include "wzcatl.h"
#include "wzccore.h"

// Global
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

//
// WZCDlgMain
//
// Description:
//
// Dll Entry function
//
// Arguments:
//      hmod - 
//      dwReason -
//      pctx -
//
// Return values:
//      TRUE
//      FALSE
//

EXTERN_C BOOL
WZCDlgMain (
        IN HINSTANCE hInstance,
        IN DWORD    dwReason,
        IN LPVOID   lpReserved OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstance);
            _Module.Init(ObjectMap, hInstance);
            SHFusionInitializeFromModuleID (hInstance, 2);
            break;
        case DLL_PROCESS_DETACH:
	        SHFusionUninitialize();
            _Module.Term();
            break;
    }

    return TRUE;
}


//
// WZCCanShowBalloon
//
// Description:
//
// Function called by netshell, to query if balloon is to be displayed
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      pszBalloonText - Pointer to text to be display
//      pszCookie - WZC specific information
//
// Return values:
//      S_OK    - Display balloon
//      S_FALSE - Do not display balloon
//

EXTERN_C HRESULT 
WZCCanShowBalloon ( 
                   IN const GUID * pGUIDConn, 
                   IN const PCWSTR pszConnectionName, 
                   IN OUT   BSTR * pszBalloonText, 
                   IN OUT   BSTR * pszCookie
                   )
{
    HRESULT     hr = S_FALSE;

    if (pszCookie != NULL)
    {
        PWZCDLG_DATA pDlgData = reinterpret_cast<PWZCDLG_DATA>(*pszCookie);

        if (WZCDLG_IS_WZC(pDlgData->dwCode))
            hr = WZCDlgCanShowBalloon(pGUIDConn, pszBalloonText, pszCookie);
        else
        {
            hr = ElCanShowBalloon (
                pGUIDConn,
                (WCHAR *)pszConnectionName,
                pszBalloonText,
                pszCookie
                );
        }
    }

    return hr;
}


//
// WZCOnBalloonClick
//
// Description:
//
// Function called by netshell, in response to a balloon click
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      pszCookie - WZC specific information
//
// Return values:
//      S_OK    - No error
//      S_FALSE - Error
//

EXTERN_C HRESULT 
WZCOnBalloonClick ( 
                   IN const GUID * pGUIDConn, 
                   IN const BSTR pszConnectionName,
                   IN const BSTR szCookie
                   )
{
    HRESULT     hr = S_OK;
    ULONG_PTR   ulActivationCookie;
    PWZCDLG_DATA pDlgData = reinterpret_cast<PWZCDLG_DATA>(szCookie);

    SHActivateContext (&ulActivationCookie);

    if (WZCDLG_IS_WZC(pDlgData->dwCode))
    {
        hr = WZCDlgOnBalloonClick(
                pGUIDConn, 
                (LPWSTR) pszConnectionName,
                szCookie);
    }
    else
    {
        hr = ElOnBalloonClick (
                pGUIDConn,
                (WCHAR *)pszConnectionName,
                szCookie
                );
    }

    SHDeactivateContext (ulActivationCookie);

    return hr;
}


//
// WZCQueryConnectionStatusText
//
// Description:
//
// Function called by netshell, to query appropriate text for 802.1X states
//
// Arguments:
//      pGUIDConn - Interface GUID string
//      ncs - NETCON_STATUS for the interface
//      pszStatusText - Detailed 802.1X status to be displayed
//
// Return values:
//      S_OK    - No error
//      S_FALSE - Error
//

EXTERN_C HRESULT 
WZCQueryConnectionStatusText ( 
        IN const GUID *  pGUIDConn, 
        IN const NETCON_STATUS ncs,
        IN OUT BSTR *  pszStatusText
        )
{
    HRESULT     hr = S_OK;

    hr = ElQueryConnectionStatusText (
            pGUIDConn,
            ncs,
            pszStatusText
            );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eapol.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    eapol.h

Abstract:

    This module contains declarations which will be used by other processes.
    This may be placed in sdk\inc


Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_H_
#define _EAPOL_H_

//
// Structure:   EAPOL_STATS
//

typedef struct _EAPOL_STATS 
{
    DWORD           dwEAPOLFramesRcvd;
    DWORD           dwEAPOLFramesXmt;
    DWORD           dwEAPOLStartFramesXmt;
    DWORD           dwEAPOLLogoffFramesXmt;
    DWORD           dwEAPRespIdFramesXmt;
    DWORD           dwEAPRespFramesXmt;
    DWORD           dwEAPReqIdFramesRcvd;
    DWORD           dwEAPReqFramesRcvd;
    DWORD           dwEAPOLInvalidFramesRcvd;
    DWORD           dwEAPLengthErrorFramesRcvd;
    DWORD           dwEAPOLLastFrameVersion;
    BYTE            bEAPOLLastFrameSource[6];      // assuming 6-byte MAC addr
} EAPOL_STATS, *PEAPOL_STATS;

//
// Structure:   EAPOL_CONFIG
//

typedef struct _EAPOL_CONFIG 
{

    DWORD           dwheldPeriod;       // Time in seconds, for which the
                                        // port will be held in HELD state
    DWORD           dwauthPeriod;       // Time in seconds, for which the 
                                        // port will wait in AUTHENTICATING/
                                        // ACQUIRED state waiting for requests
    DWORD           dwstartPeriod;      // Time in seconds, the port will
                                        // wait in CONNECTING state, before
                                        // re-issuing EAPOL_START packet
    DWORD           dwmaxStart;         // Max number of EAPOL_Start packets
                                        // that can be sent out without any
                                        // response

} EAPOL_CONFIG, *PEAPOL_CONFIG;

//
// Structure: EAPOL_CUSTOM_AUTH_DATA
//

typedef struct _EAPOL_CUSTOM_AUTH_DATA
{
    DWORD       dwSizeOfCustomAuthData;
    BYTE        pbCustomAuthData[1];
} EAPOL_CUSTOM_AUTH_DATA, *PEAPOL_CUSTOM_AUTH_DATA;

//
// Structure: EAPOL_EAP_UI_DATA
//

typedef struct _EAPOL_EAP_UI_DATA
{
    DWORD       dwContextId;
    PBYTE       pEapUIData;
    DWORD       dwSizeOfEapUIData;
} EAPOL_EAP_UI_DATA, *PEAPOL_EAP_UI_DATA;


// Definitions common to elport.c and eleap.c

//
// Defines states for the EAP protocol.
//

typedef enum _EAPSTATE 
{
    EAPSTATE_Initial,
    EAPSTATE_IdentityRequestSent,
    EAPSTATE_Working,
    EAPSTATE_EapPacketSentToAuthServer,
    EAPSTATE_EapPacketSentToClient,
    EAPSTATE_NotificationSentToClient

}   EAPSTATE;

typedef enum _EAPTYPE 
{
    EAPTYPE_Identity    = 1,
    EAPTYPE_Notification,
    EAPTYPE_Nak,
    EAPTYPE_MD5Challenge,
    EAPTYPE_SKey,
    EAPTYPE_GenericTokenCard

} EAPTYPE;

//
// Actions that need to be performed on EAP data after it is processed
//

typedef enum _ELEAP_ACTION
{
    ELEAP_NoAction,
    ELEAP_Done,
    ELEAP_SendAndDone,
    ELEAP_Send
} ELEAP_ACTION;


//
// EAPOL Authentication Types - Used for MACHINE_AUTH
//

typedef enum _EAPOL_AUTHENTICATION_TYPE
{
    EAPOL_UNAUTHENTICATED_ACCESS = 0,
    EAPOL_USER_AUTHENTICATION,
    EAPOL_MACHINE_AUTHENTICATION
} EAPOL_AUTHENTICATION_TYPE;


#endif  // _EAPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eapoldlgrc.h ===
//depot/private/config/net/config/netman/eapol/service/eapoldlgrc.h#2 - branch change 4547 (text)
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define BID_Dialer                      100
#define DID_DR_DialerUD                 117
#define CID_DR_EB_User                  1104
#define CID_DR_EB_Password              1103
#define CID_DR_PB_DialConnect           1590
#define CID_DR_PB_Cancel                1591
#define CID_DR_BM_Useless               1100
#define CID_DR_ST_User                  1413
#define CID_DR_ST_Password              1112
#define CID_DR_ST_Domain                1110
#define CID_DR_EB_Domain                1102
#define CID_DR_CB_SavePassword          1101
#define CID_DR_PB_Properties            1107
#define CID_DR_PB_Help                  1592
#define SID_NeedEapKeys                 1570
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\parser\eapolint.c ===
//=================================================================================================================//
//  MODULE: eapolinit.c
//
//  Description:
//
//  Attach properties for the BLOODHOUND PPP Parser.
//
//  Modification History
//
//  timmoore       04/04/2000            Created from PPP parser.
//=================================================================================================================//
#include "eapol.h"

extern ENTRYPOINTS EAPOLEntryPoints;
extern HPROTOCOL hEAPOL;

char    IniFile[INI_PATH_LENGTH];

//==========================================================================================================================
//  FUNCTION: DllMain()
//
//  Modification History
//
//  timmoore       04/04/2000            Created from PPP parser.
//==========================================================================================================================
DWORD Attached = 0;

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulCommand, LPVOID lpReserved)
{
    if (ulCommand == DLL_PROCESS_ATTACH)
    {
        if (Attached++ == 0)
        {
            hEAPOL    = CreateProtocol("EAPOL",     &EAPOLEntryPoints,  ENTRYPOINTS_SIZE);
        }                  
    }
    else if (ulCommand == DLL_PROCESS_DETACH)
    {
        if (--Attached == 0)
        {
            DestroyProtocol(hEAPOL);
        }
    }
            
    return TRUE;

    //... Make the compiler happy.

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(lpReserved);
}

//==========================================================================================================================
//  FUNCTION: ParserAutoInstallInfo()
//
//  Modification History
//
//  timmoore       04/04/2000            
//==========================================================================================================================
PPF_PARSERDLLINFO   WINAPI  ParserAutoInstallInfo ()
{
    PPF_PARSERDLLINFO   pParserDllInfo;
    PPF_PARSERINFO      pParserInfo;
    DWORD               dwNumProtocols = 0;

    DWORD               dwNumHandoffs = 0;
    PPF_HANDOFFSET      pHandoffSet;
    PPF_HANDOFFENTRY    pHandoffEntry;

    dwNumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO) HeapAlloc (GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    sizeof( PF_PARSERDLLINFO ) 
                                                    + dwNumProtocols * sizeof( PF_PARSERINFO));

    if ( pParserDllInfo == NULL )
    {
        return NULL;
    }

    pParserDllInfo->nParsers = dwNumProtocols;

    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    wsprintf ( pParserInfo->szProtocolName, "EAPOL");
    wsprintf (pParserInfo->szComment, "EAPOL/802.1x Protocol");
    wsprintf ( pParserInfo->szHelpFile, "");
    
    dwNumHandoffs = 1;
    pHandoffSet = (PPF_HANDOFFSET) HeapAlloc (GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                sizeof( PF_HANDOFFSET ) +
                                                dwNumHandoffs * sizeof( PF_HANDOFFENTRY) );

    if (pHandoffSet == NULL)
    {
        return NULL;
    }

    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = dwNumHandoffs;

    pHandoffEntry = &(pHandoffSet->Entry[0]);
    wsprintf( pHandoffEntry->szIniFile,    "MAC.INI" );
    wsprintf( pHandoffEntry->szIniSection, "ETYPES" );
    wsprintf( pHandoffEntry->szProtocol,   "EAPOL" );
    pHandoffEntry->dwHandOffValue =        0x888E;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_HEX;

    return pParserDllInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eldefs.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eldefs.h

Abstract:

    The module contains various
    . constants
    . definitions
    . macros
    for the following functions:
      - memory-allocation
      - logging
      - tracing

Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_DEFS_H_
#define _EAPOL_DEFS_H_


// Constants

#define PORT_TABLE_BUCKETS          29 // # buckets in the port hash table
#define INTF_TABLE_BUCKETS          29 // # buckets in the interface hash table

#define MAX_PORT_NAME               255 // Max friendly name of the adapter
#define MAX_NDIS_DEVICE_NAME_LEN    255 // NDIS UI device name

#define NOW                         0
#define DELTA                       1
#define INFINITE_INTERVAL           0x7fffffff    // Used in timers
#define INFINITE_SECONDS            0x1ffffc      // Used in timers

#define MAX_PACKET_SIZE             1518
#define MAX_EAPOL_BUFFER_SIZE       1498 // Ethernet header + CRC + 802.1P
#define SIZE_ETHERNET_CRC           4
#define WAP_LEEWAY                  100
#define SIZE_ETHERNET_TYPE          2
#define SIZE_PROTOCOL_VERSION       2
#define EAPOL_8021P_TAG_TYPE        0x0081
#define SIZE_MAC_ADDR               6
#define EAPOL_INIT_START_PERIOD     1   // 1 sec interval between EAPOL_Start
                                        // packets with no user logged on
#define EAPOL_MIN_RESTART_INTERVAL  2000 // Minimum msec between 2 restarts
#define EAPOL_HEAP_INITIAL_SIZE     50000
#define EAPOL_HEAP_MAX_SIZE         0
#define EAPOL_SERVICE_NAME          TEXT("EAPOL")
#define EAPOL_MAX_START             3
#define EAPOL_START_PERIOD          60
#define EAPOL_AUTH_PERIOD           30
#define EAPOL_HELD_PERIOD           60
#define EAPOL_MAX_AUTH_FAIL_COUNT   3
#define EAPOL_TOTAL_MAX_AUTH_FAIL_COUNT 9 

#define MAX_CHALLENGE_SIZE          8
#define MAX_RESPONSE_SIZE           24

#define EAP_TYPE_MD5                4
#define EAP_TYPE_TLS                13

#define NDIS_802_11_SSID_LEN        36
#define GUID_STRING_LEN_WITH_TERM   39

#define MAX_NOTIFICATION_MSG_SIZE   255

// Module startup flags
#define WMI_MODULE_STARTED          0x0001
#define DEVICE_NOTIF_STARTED        0x0002
#define EAPOL_MODULE_STARTED        0x0004 
#define BINDINGS_MODULE_STARTED     0x0008 
#define LOGON_MODULE_STARTED        0x0010 

#ifndef ZEROCONFIG_LINKED
#define ALL_MODULES_STARTED         0x001f
#else
#define ALL_MODULES_STARTED         0x0014
#endif


// Definitions

//#define LOCKSTORE                   (&(g_dlsDynamicLocksStore))
#define TRACEID                     g_dwTraceId
#define LOGHANDLE                   g_hLogEvents



// Macros
#define SWAP(a, b, c)               { (c)=(a); (a)=(b); (b)=(c); }
#define MAX(a, b)                   (((a) >= (b)) ? (a) : (b))
#define MIN(a, b)                   (((a) <= (b)) ? (a) : (b))
#define ISSET(i, flag)              ((i)->dwFlags & (flag))
#define SET(i, flag)                ((i)->dwFlags |= (flag))
#define RESET(i, flag)              ((i)->dwFlags &= ~(flag))



//
// TIMER
//

// Definitions
#define BLOCKING                    -1
#define NONBLOCKING                 NULL
#define MAX_TIME                    0xffffffff
#define SECTOMILLISEC(x)            ((x) * 1000)
// current time
#define Now()                       (((ULONG)GetTickCount()) / 1000)




// Macros

// Timers will always be one-shot and they will execute in I/O component 
// thread
#define CREATE_TIMER(phHandle, pfn, pvContext, ulWhen, szName, pdwRetCode)      \
{                                                                           \
    TRACE2(ANY, "TIMER: Create  %-20s\tTime: %u", szName, ulWhen);          \
    if (CreateTimerQueueTimer((phHandle),                                   \
                              g_hTimerQueue,                                \
                              (pfn),                                        \
                              (pvContext),                                  \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL,                            \
                              WT_EXECUTEDEFAULT))                        \
    {                                                                       \
        *(pdwRetCode)   = NO_ERROR;                                             \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(phHandle) = NULL;                                                 \
        *(pdwRetCode)   = GetLastError();                                       \
        TRACE1(ANY, "Error %u creating timer", *(pdwRetCode));                  \
    }                                                                       \
}

// it is safe to hold locks while making this call if
// 1. tType is NONBLOCKING  or
// 2. tType is BLOCKING and
//    the callback function doesn't acquire any of these locks
#define DELETE_TIMER(hHandle, tType, pdwRetCode)                                \
{                                                                           \
    if (DeleteTimerQueueTimer(g_hTimerQueue,                                \
                              (hHandle),                                    \
                              (HANDLE)tType))                               \
    {                                                                       \
        *(pdwRetCode) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwRetCode) = GetLastError();                                         \
        TRACE1(ANY, "Error %u deleting timer, continuing...", *(pdwRetCode));   \
    }                                                                       \
}

#define RESTART_TIMER(hHandle, ulWhen, szName, pdwRetCode)                      \
{                                                                           \
    TRACE2(ANY, "TIMER: Restart %-20s\tTime: %u", szName, ulWhen);          \
    if (ChangeTimerQueueTimer(g_hTimerQueue,                             \
                              (hHandle),                                    \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL))                           \
    {                                                                       \
        *(pdwRetCode) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwRetCode) = GetLastError();                                         \
        TRACE1(ANY, "Error %u restarting timer, continuing...", *(pdwRetCode)); \
    }                                                                       \
}



// MEMORY ALLOCATION

// MACROS

#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))


//
// TRACING
//

// Definitions
#define EAPOL_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAPOL           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAP             ((DWORD)0x00020000 | TRACE_USE_MASK)
#define EAPOL_TRACE_INIT            ((DWORD)0x00040000 | TRACE_USE_MASK)
#define EAPOL_TRACE_DEVICE          ((DWORD)0x00080000 | TRACE_USE_MASK)
#define EAPOL_TRACE_LOCK            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define EAPOL_TRACE_PORT            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define EAPOL_TRACE_TIMER           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define EAPOL_TRACE_USER            ((DWORD)0x00800000 | TRACE_USE_MASK)
#define EAPOL_TRACE_NOTIFY          ((DWORD)0x01000000 | TRACE_USE_MASK)
#define EAPOL_TRACE_RPC             ((DWORD)0x02000000 | TRACE_USE_MASK)


// Macros
#define TRACE0(l,a)                                                     \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a)
#define TRACE1(l,a,b)                                                   \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)                                                 \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)                                               \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)                                             \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)                                           \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f)
#define TRACE6(l,a,b,c,d,e,f,g)                                         \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f, g)

#define EAPOL_DUMPW(pBuf,dwBuf)                                                \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,4,1,NULL)

#define EAPOL_DUMPB(pbBuf,dwBuf)                                        \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)
#define EAPOL_DUMPBA(pbBuf,dwBuf)                                        \
        TraceDumpExA(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)


//
// EVENT LOGGING
//

#define EapolLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    RouterLogError( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray,    \
                    dwRetCode )

#define EapolLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    RouterLogWarning( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray, 0 )

#define EapolLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    RouterLogInformation(g_hLogEvents,LogId, NumStrings, lpwsSubStringArray,0)

#define EapolLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    RouterLogErrorString( g_hLogEvents, LogId, NumStrings,                  \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    RouterLogWarningString( g_hLogEvents, LogId, NumStrings,                \
                           lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    RouterLogInformationString( g_hLogEvents, LogId,                        \
                                NumStrings, lpwsSubStringArray, dwRetCode,dwPos)


#endif // _EAPOL_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eapolutil.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eapolutil.h

Abstract:

    Definitions for tools and ends


Revision History:

    sachins, May 04 2000, Created

--*/

#ifndef _EAPOLUTIL_H_
#define _EAPOLUTIL_H_

//
// EAPOL_ZC_INTF
//
// Used to transfer data between 802.1X and Zero Config
//

typedef struct  _EAPOL_ZC_INTF
{
    DWORD                           dwAuthFailCount;
    EAPOL_AUTHENTICATION_TYPE       PreviousAuthenticationType;
    DWORD                           dwSizeOfSSID;
    BYTE                            bSSID[MAX_SSID_LEN];
} EAPOL_ZC_INTF, *PEAPOL_ZC_INTF;

//
// STRUCT: EAPOLUIRESPFUNC
//

typedef DWORD (*EAPOLUIRESPFUNC) (EAPOL_EAP_UI_CONTEXT, EAPOLUI_RESP);

//
// STRUCT: EAPOLUIRESPFUNCMAP
//

typedef struct _EAPOLUIRESPFUNCMAP
{
    DWORD               dwEAPOLUIMsgType;
    EAPOLUIRESPFUNC     EapolRespUIFunc;
    DWORD               dwNumBlobs;
} EAPOLUIRESPFUNCMAP, *PEAPOLUIRESPFUNCMAP;


//
// Definitions and structures used in creating default EAP-TLS connection
// blob in the registry
// Ensure that the EAP-TLS structures defined below are always in sync 
// with those defined in EAP-TLS code directory
//

#define     EAPTLS_CONN_FLAG_REGISTRY           0x00000001
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_CERT   0x00000002
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_NAME   0x00000004

typedef struct _EAPTLS_CONN_PROPERTIES
{
    DWORD       dwVersion;
    DWORD       dwSize;
    DWORD       fFlags;
    DWORD       cbHash;
    BYTE        pbHash[20]; // MAX_HASH_SIZE = 20
    WCHAR       awszServerName[1];
} EAPTLS_CONN_PROPERTIES, *PEAPTLS_CONN_PROPERTIES;


//
// FUNCTION DECLARATIONS
//

extern 
HANDLE
GetCurrentUserTokenW (
        WCHAR       Winsta[],
        DWORD       DesiredAccess
        );

VOID
HostToWireFormat16(
    IN 	   WORD         wHostFormat,
    IN OUT PBYTE        pWireFormat
    );

WORD
WireToHostFormat16(
    IN PBYTE                pWireFormat
    );

VOID
HostToWireFormat32(
    IN 	   DWORD            dwHostFormat,
    IN OUT PBYTE            pWireFormat
    );

DWORD
WireToHostFormat32(
    IN PBYTE pWireFormat
    );

DWORD
ElSetCustomAuthData (
        IN  WCHAR       *pwszGuid,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  BYTE        *pbConnInfo,
        IN  DWORD       *pdwInfoSize
        );

DWORD
ElGetCustomAuthData (
        IN  WCHAR           *pwszGuid,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT BYTE        *pbConnInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

DWORD
ElReAuthenticateInterface (
        IN  WCHAR           *pwszGuid);

DWORD
WINAPI
ElReAuthenticateInterfaceWorker (
        IN  PVOID           pvContext);

DWORD
ElSetEapUserInfo (
        IN  HANDLE      hToken,
        IN  WCHAR       *pwszGuid,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  BYTE        *pbUserInfo,
        IN  DWORD       dwInfoSize
        );

DWORD
ElGetEapUserInfo (
        IN  HANDLE          hToken,
        IN  WCHAR           *pwszGuid,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT BYTE        *pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

DWORD
ElDeleteEapUserInfo (
        IN  HANDLE          hToken,
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID
        );

DWORD
ElSetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  EAPOL_INTF_PARAMS  *pIntfParams
        );

DWORD
ElGetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS  *pIntfParams
        );

DWORD
ElQueryInterfaceState (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_STATE  *pIntfState
        );

DWORD
ElGetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   dwSizeOfIn,
        IN  BYTE    *pbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   *pdwSizeOfOut,
        IN  PBYTE   *ppbBufferOut
        );

DWORD
ElSetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   *pdwSizeOfIn,
        IN  PBYTE   *ppbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   dwAuthData,
        IN  PBYTE   pbAuthData
        );

DWORD
ElGetEapKeyFromToken (
        IN  HANDLE      hUserToken,
        OUT HKEY        *phkey
        );

DWORD
ElInitRegPortData (
        IN  WCHAR       *pszDeviceGUID
        );

DWORD
ElCreateDefaultEapData (
        IN OUT  DWORD       *pdwSizeOfEapData,
        IN OUT  BYTE        *pbEapData
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetVendorSpecific (
        IN  DWORD                       dwVendorId,
        IN  DWORD                       dwVendorType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetFirst (
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes,
        OUT HANDLE                      *phAttribute
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetNext (
        IN  OUT HANDLE                  *phAttribute,
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGet (
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes
        );

VOID
ElReverseString (
        IN  CHAR        *psz 
    );

CHAR*
ElEncodePw (
        IN OUT CHAR     *pszPassword 
    );

CHAR*
ElDecodePw (
        IN OUT CHAR     *pszPassword 
    );

DWORD
ElSecureEncodePw (
    IN  BYTE        *pbPassword,
    IN  DWORD       dwSizeOfPassword,
    OUT DATA_BLOB   *pDataBlob
    );

DWORD
ElSecureDecodePw (
    IN  DATA_BLOB   *pDataBlob,
    OUT PBYTE       *ppbPassword,
    OUT DWORD       *pdwSizeOfPassword
    );

VOID
ElEncryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        );

VOID
ElDecryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        );

VOID
ElGetHMACMD5Digest (
        IN      BYTE        *pbBuf,     
        IN      DWORD       dwBufLen,   
        IN      BYTE        *pbKey,
        IN      DWORD       dwKeyLen,
        IN OUT  VOID        *pvDigest
        );

DWORD
ElWmiGetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  OUT BYTE    *pbOutputBuffer,
        IN  OUT DWORD   *pdwOutputBufferSize
        );

DWORD
ElWmiSetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  BYTE        *pbInputBuffer,
        IN  DWORD       dwInputBufferSize
        );

DWORD
ElNdisuioSetOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       ulOidDataLength
        );

DWORD
ElNdisuioQueryOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       *pulOidDataLength
        );

DWORD 
ElGuidFromString (
        IN  OUT GUID        *pGuid,
        IN      WCHAR       *pwszGuidString
        );

DWORD
ElGetLoggedOnUserName (
        IN      HANDLE      hToken,
        OUT     PWCHAR      *ppwszActiveUserName
        );

DWORD
ElGetMachineName (
        IN      EAPOL_PCB       *pPCB
        );

DWORD
ElUpdateRegistryInterfaceList (
        IN      PNDIS_ENUM_INTF     Interfaces
        );

DWORD
ElEnumAndUpdateRegistryInterfaceList (
        );

DWORD
WINAPI
ElWatchGlobalRegistryParams (
        IN      PVOID       pvContext
        );

DWORD
ElReadGlobalRegistryParams ();

DWORD
WINAPI
ElWatchEapConfigRegistryParams (
        IN      PVOID       pvContext
        );

DWORD
ElReadGlobalRegistryParams ();

DWORD 
ElPostEapConfigChanged (
        IN      WCHAR               *pwszGuid,
        IN      EAPOL_INTF_PARAMS   *pIntfParams   
        );

DWORD
WINAPI
ElProcessEapConfigChange (
        IN      PVOID       pvContext
        );

VOID
ElStringToGuid (
        IN      WCHAR       *pwszGuid,
        OUT     LPGUID      pGuid      
        );

DWORD
ElGetIdentity (
        IN      EAPOL_PCB   *pPCB
        );

HANDLE
ElNLAConnectLPC ();

VOID
ElNLACleanupLPC ();

VOID
ElNLARegister_802_1X ( 
        IN      PLOCATION_802_1X plocation 
        );

VOID
ElNLADelete_802_1X (
        IN      PLOCATION_802_1X plocation
        );

DWORD
ElGetInterfaceNdisStatistics (  
        IN      WCHAR           *pszInterfaceName,
        IN OUT  NIC_STATISTICS  *pStats
        );

DWORD
ElCheckUserLoggedOn (
        );

DWORD
ElCheckUserModuleReady (
        );

DWORD 
ElGetWinStationUserToken (
        IN  DWORD       dwSessionId,
        IN  PHANDLE     pUserToken
        );

#ifdef  ZEROCONFIG_LINKED

DWORD
ElZeroConfigEvent (
        IN      DWORD               dwHandle,
        IN      WCHAR               *pwszGuid,
        IN      NDIS_802_11_SSID    ndSSID,
        IN      PRAW_DATA           prdUserData
        );

DWORD
ElZeroConfigNotify (
        IN      DWORD               dwHandle,
        IN      DWORD               dwCmdCode,
        IN      WCHAR               *pwszGuid,
        IN      EAPOL_ZC_INTF       *pZCData
        );

#endif // ZEROCONFIG_LINKED

DWORD
ElNetmanNotify (
        IN  EAPOL_PCB           *pPCB,
        IN  EAPOL_NCS_STATUS    Status,
        IN  WCHAR               *pwszDisplayMessage
        );

DWORD
ElPostShowBalloonMessage (
        IN  EAPOL_PCB           *pPCB,
        IN  DWORD               cbCookie,
        IN  BYTE                *pbCookie,
        IN  DWORD               cbMessageLen,
        IN  WCHAR               *pwszMessage
        );

DWORD
ElProcessReauthResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        );

DWORD
WINAPI
ElIPPnPWorker (
        IN      PVOID       pvContext
        );

DWORD
ElUpdateRegistry (
        );

DWORD
ElRegistryUpdateXPBeta2 (
        );

DWORD
ElRegistryUpdateXPSP1 (
        );

DWORD
ElReadPolicyParams (
        );

#endif // _EAPOLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eapolutil.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eapolutil.c

Abstract:

    Tools and ends


Revision History:

    sachins, Apr 23 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

// 
// Definitions used to read/write to registry
//

#define MAX_REGISTRY_VALUE_LENGTH   ((64*1024) - 1)

// Location of User blob
#define cwszEapKeyEapolUser   L"Software\\Microsoft\\EAPOL\\UserEapInfo"

// Location of Connection blob
#define cwszEapKeyEapolConn   L"Software\\Microsoft\\EAPOL\\Parameters\\Interfaces"

// Location of EAPOL Parameters Service
#define cwszEapKeyEapolServiceParams   L"Software\\Microsoft\\EAPOL\\Parameters\\General"

// Location of EAPOL Global state machine params
#define cwszEAPOLGlobalParams   L"Software\\Microsoft\\EAPOL\\Parameters\\General\\Global"

// Location of policy parameters
#define cwszEAPOLPolicyParams   L"Software\\Policies\\Microsoft\\Windows\\Network Connections\\8021X"
 
// Location of netman dll
#define NETMAN_DLL_PATH         L"%SystemRoot%\\system32\\netman.dll"

#define cwszEapolEnabled     L"EapolEnabled"
#define cwszDefaultEAPType   L"DefaultEAPType"
#define cwszLastUsedSSID     L"LastUsedSSID"
#define cwszInterfaceList    L"InterfaceList"
#define cwszAuthPeriod       L"authPeriod"
#define cwszHeldPeriod       L"heldPeriod"
#define cwszStartPeriod      L"startPeriod"
#define cwszMaxStart         L"maxStart"
#define cwszSupplicantMode   L"SupplicantMode"
#define cwszAuthMode         L"AuthMode"
#define cszCARootHash        "8021XCARootHash"
#define SIZE_OF_CA_CONV_STR  3

#define PASSWORDMAGIC 0xA5

#define WZCSVC_SERVICE_NAME     L"WZCSVC"

//
// EAPOLRESPUI function mapping
//

EAPOLUIRESPFUNCMAP  EapolUIRespFuncMap[NUM_EAPOL_DLG_MSGS]=
    {
    {EAPOLUI_GET_USERIDENTITY, ElProcessUserIdentityResponse, 3},
    {EAPOLUI_GET_USERNAMEPASSWORD, ElProcessUserNamePasswordResponse, 2},
    {EAPOLUI_INVOKEINTERACTIVEUI, ElProcessInvokeInteractiveUIResponse, 1},
    {EAPOLUI_EAP_NOTIFICATION, NULL, 0},
    {EAPOLUI_REAUTHENTICATE, ElProcessReauthResponse, 0},
    {EAPOLUI_CREATEBALLOON, NULL, 0},
    {EAPOLUI_CLEANUP, NULL, 0}
    };

BYTE    g_bDefaultSSID[MAX_SSID_LEN]={0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22};

#define MAX_VALUENAME_LEN  33

//
// HostToWireFormat16
//
// Description: 
//
// Will convert a 16 bit integer from host format to wire format
//

VOID
HostToWireFormat16 (
    IN 	   WORD  wHostFormat,
    IN OUT PBYTE pWireFormat
    )
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+1) = (BYTE) (wHostFormat);
}


//
// WireToHostFormat16
//
// Description: 
//
// Will convert a 16 bit integer from wire format to host format
//

WORD
WireToHostFormat16 (
    IN PBYTE pWireFormat
    )
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
                        (*((PBYTE)(pWireFormat)+1)));

    return( wHostFormat );
}


//
// HostToWireFormat32
//
// Description: 
//
// Will convert a 32 bit integer from host format to wire format
//

VOID
HostToWireFormat32 (
    IN 	   DWORD dwHostFormat,
    IN OUT PBYTE pWireFormat
    )
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE) ((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE) ((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE) (dwHostFormat);
}


//
// WireToHostFormat32
//
// Description: 
//
// Will convert a 32 bit integer from wire format to host format
//

DWORD
WireToHostFormat32 (
    IN PBYTE pWireFormat
    )
{
    DWORD dwHostFormat = ((*((PBYTE)(pWireFormat)+0) << 24) +
    			  (*((PBYTE)(pWireFormat)+1) << 16) +
        		  (*((PBYTE)(pWireFormat)+2) << 8)  +
                    	  (*((PBYTE)(pWireFormat)+3) ));

    return( dwHostFormat );
}


//
// ElSetCustomAuthData
//
// Description:
//
// Function called to set the connection data for an interface for a specific
// EAP type and SSID (if any). Data will be stored in the HKLM hive
//
// Arguments:
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be stored
//  dwSizeOfSSID - Size of special identifier, if any, for the EAP blob
//  pwszSSID - Special identifier, if any, for the EAP blob
//  pbConnInfo - pointer to EAP connection data blob
//  pdwInfoSize - Size of EAP connection blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElSetCustomAuthData (
        IN  WCHAR       *pwszGUID,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  PBYTE       pbConnInfo,
        IN  DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwDisposition;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    WCHAR       *pwszValueName = NULL;
    WCHAR       wcszValueName[MAX_VALUENAME_LEN];
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL, *pbEapBlobIn = NULL;
    DWORD       dwEapBlob = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    EAPOL_INTF_PARAMS       *pDefIntfParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetCustomAuthData: GUID = NULL");
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElSetCustomAuthData: GUID = NULL");
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }
        if (dwSizeOfSSID > MAX_SSID_LEN)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Invalid SSID length = (%ld)",
                    dwSizeOfSSID);
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegCreateKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegCreateKeyEx (
                        hkey,
                        pwszGUID,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey1,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegCreateKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Work with appropriate SSID
        if ((dwSizeOfSSID == 0) || (pbSSID == NULL))
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElSetCustomAuthData: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if (dwMaxValueNameLen > MAX_VALUENAME_LEN)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Valuename too long (%ld)",
                    dwMaxValueLen);
            break;
        }

        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            TRACE0 (ANY, "ElSetCustomAuthData: MALLOC failed for pbValueBuf");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwMaxValueNameLen = MAX_VALUENAME_LEN;
            ZeroMemory (&wcszValueName, MAX_VALUENAME_LEN*sizeof(WCHAR));
            if ((lError = RegEnumValue (
                            hkey1,
                            dwIndex,
                            wcszValueName,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                TRACE0 (ANY, "ElSetCustomAuthData: dwValueData < sizeof (EAPOL_INTF_PARAMS");
                lError = ERROR_INVALID_DATA;
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(wcszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (wcszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }

            if (!memcmp (pRegParams->bSSID, g_bDefaultSSID, MAX_SSID_LEN))
            {
                if ((pbDefaultValue = MALLOC (dwValueData)) == NULL)
                {
                    TRACE0 (ANY, "ElSetCustomAuthData: MALLOC failed for pbDefaultValue");
                    lError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                memcpy (pbDefaultValue, pbValueBuf, dwValueData);
                dwDefaultValueLen = dwValueData;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElSetCustomAuthData: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            DWORD dwNewValueName = (dwMaxValueName >= dwNumValues)?(++dwMaxValueName):dwNumValues;
            _ltow (dwNewValueName, wcszValueName, 10);
            if ((pbDefaultValue = MALLOC (sizeof(EAPOL_INTF_PARAMS))) == NULL)
            {
                TRACE0 (ANY, "ElSetCustomAuthData: MALLOC failed for pbDefaultValue");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pDefIntfParams = (EAPOL_INTF_PARAMS *)pbDefaultValue;
            pDefIntfParams->dwEapFlags = DEFAULT_EAP_STATE;
            pDefIntfParams->dwEapType = dwEapTypeId;
            pDefIntfParams->dwVersion = EAPOL_CURRENT_VERSION;
            pDefIntfParams->dwSizeOfSSID = dwSizeOfSSID;
            memcpy (pDefIntfParams->bSSID, pbSSID, dwSizeOfSSID);

            dwEapBlob = sizeof(EAPOL_INTF_PARAMS);
            pbEapBlob = pbDefaultValue;
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        pbEapBlobIn = pbEapBlob;
        if ((dwRetCode = ElSetEapData (
                dwEapTypeId,
                &dwEapBlob,
                &pbEapBlob,
                sizeof (EAPOL_INTF_PARAMS),
                *pdwInfoSize,
                pbConnInfo
                )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: ElSetEapData failed with error %ld",
                    dwRetCode);
            break;
        }

        // Overwrite/Create new value
        if ((lError = RegSetValueEx (
                        hkey1,
                        wcszValueName,
                        0,
                        REG_BINARY,
                        pbEapBlob,
                        dwEapBlob)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegSetValueEx for SSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElSetCustomAuthData: Set value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if ((pbEapBlob != pbEapBlobIn) && (pbEapBlob != NULL))
    {
        FREE (pbEapBlob);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }

    return dwRetCode;
}


//
// ElGetCustomAuthData
//
// Description:
//
// Function called to retrieve the connection data for an interface for a 
// specific EAP type and SSID (if any). Data is retrieved from the HKLM hive
//
// Arguments:
//
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be retrieved
//  dwSizeOfSSID - Size of Special identifier if any for the EAP blob
//  pbSSID - Special identifier if any for the EAP blob
//  pbConnInfo - output: pointer to EAP connection data blob
//  pdwInfoSize - output: pointer to size of EAP connection blob
//
// Return values:
//
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetCustomAuthData (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT BYTE        *pbConnInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwTempValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL;
    DWORD       dwEapBlob = 0;
    BYTE        *pbAuthData = NULL;
    DWORD       dwAuthData = 0;
    BYTE        *pbAuthDataIn = NULL;
    DWORD       dwAuthDataIn = 0;
    BOOLEAN     fFreeAuthData = FALSE;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS   *pRegParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: GUID = NULL");
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: EapTypeId invalid");
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }
        if (dwSizeOfSSID > MAX_SSID_LEN)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: Invalid SSID length = (%ld)",
                    dwSizeOfSSID);
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }

        // Work with appropriate SSID
        if ((dwSizeOfSSID == 0) || (pbSSID == NULL))
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        KEY_READ,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            // Assume no value is found and proceed ahead
            if (lError == ERROR_FILE_NOT_FOUND)
            {
                lError = ERROR_SUCCESS;
                fFoundValue = FALSE;
                goto LNotFoundValue;
            }
            else
            {
                TRACE1 (ANY, "ElGetCustomAuthData: Error in RegOpenKeyEx for base key, %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey,
                        pwszGUID,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            // Assume no value is found and proceed ahead
            if (lError == ERROR_FILE_NOT_FOUND)
            {
                lError = ERROR_SUCCESS;
                fFoundValue = FALSE;
                goto LNotFoundValue;
            }
            else
            {
                TRACE1 (ANY, "ElGetCustomAuthData: Error in RegOpenKeyEx for GUID, %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
        }

        if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElGetCustomAuthData: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElGetCustomAuthData: MALLOC failed for pwszValueName");
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: MALLOC failed for pbValueBuf");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwTempValueNameLen = dwMaxValueNameLen;
            dwValueData = dwMaxValueLen;
            ZeroMemory ((VOID *)pwszValueName, dwMaxValueNameLen*sizeof(WCHAR));
            ZeroMemory ((VOID *)pbValueBuf, dwMaxValueLen);
            if ((lError = RegEnumValue (
                            hkey1,
                            dwIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                lError = ERROR_INVALID_DATA;
                TRACE0 (ANY, "ElGetCustomAuthData: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(pwszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (pwszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElGetCustomAuthData: RegEnumValue 2 failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

LNotFoundValue:

        // For SSIDs for which there is no blob stored, create default blob
        // For default SSID, there should have been a blob created
        if (!fFoundValue)
        {
            if ((dwRetCode = ElCreateDefaultEapData (&dwDefaultValueLen, NULL)) == ERROR_BUFFER_TOO_SMALL)
            {
                EAPOL_INTF_PARAMS   IntfParams;
                IntfParams.dwVersion = EAPOL_CURRENT_VERSION;
                if ((pbDefaultValue = MALLOC (dwDefaultValueLen)) == NULL)
                {
                    TRACE0 (ANY, "ElGetCustomAuthData: MALLOC failed for Conn Prop");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                if ((dwRetCode = ElCreateDefaultEapData (&dwDefaultValueLen, pbDefaultValue)) != NO_ERROR)
                {
                    TRACE1 (ANY, "ElGetCustomAuthData: ElCreateDefaultEapData failed with error (%ld)",
                            dwRetCode);
                    break;
                }
        
                pbEapBlob = (BYTE *)&IntfParams;
                dwEapBlob = sizeof (EAPOL_INTF_PARAMS);
                if ((dwRetCode = ElSetEapData (
                            DEFAULT_EAP_TYPE,
                            &dwEapBlob,
                            &pbEapBlob,
                            sizeof (EAPOL_INTF_PARAMS),
                            dwDefaultValueLen,
                            pbDefaultValue
                            )) != NO_ERROR)
                {
                    TRACE1 (ANY, "ElGetCustomAuthData: ElSetEapData failed with error %ld",
                            dwRetCode);
                    break;
                }
                // Assign to pbDefaultValue for freeing later on
                FREE (pbDefaultValue);
                pbDefaultValue = pbEapBlob;
                dwDefaultValueLen = dwEapBlob;
            }
            else
            {
                TRACE0 (ANY, "ElGetCustomAuthData: ElCreateDefaultEapData should have failed !!!");
                dwRetCode = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            // Use pbDefaultValue & dwDefaultValueLen
            pbEapBlob = pbDefaultValue;
            dwEapBlob = dwDefaultValueLen;
        }
        else
        {
            if (fFoundValue)
            {
                // Use pbValueBuf & dwValueData
                pbEapBlob = pbValueBuf;
                dwEapBlob = dwValueData;
            }
        }

        // If default blob is not present, exit
        if ((pbEapBlob == NULL) && (dwEapBlob == 0))
        {
            TRACE0 (ANY, "ElGetCustomAuthData: (pbEapBlob == NULL) && (dwEapBlob == 0)");
            dwRetCode = ERROR_INVALID_DATA;
            break;
        }

        if ((dwRetCode = ElGetEapData (
                dwEapTypeId,
                dwEapBlob,
                pbEapBlob,
                sizeof (EAPOL_INTF_PARAMS),
                &dwAuthData,
                &pbAuthData
                )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: ElGetEapData failed with error %ld",
                    dwRetCode);
            break;
        }

        pbAuthDataIn = pbAuthData;
        dwAuthDataIn = dwAuthData;

        // Get the policy data, if any
        // If there is policy data use it instead of the registry setting
        if ((dwRetCode = ElGetPolicyCustomAuthData (
                            dwEapTypeId,
                            dwSizeOfSSID,
                            pbSSID,
                            &pbAuthDataIn,
                            &dwAuthDataIn,
                            &pbAuthData,
                            &dwAuthData
                        )) == NO_ERROR)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: POLICY: Initialized with Policy data");
            fFreeAuthData = TRUE;
        }
        else
        {
            if (dwRetCode != ERROR_FILE_NOT_FOUND)
            {
                TRACE1 (ANY, "ElGetCustomAuthData: ElGetPolicyCustomAuthData returned error %ld",
                    dwRetCode);
            }
            dwRetCode = NO_ERROR;
        }

        // Return the data if sufficient space allocated
        if ((pbConnInfo != NULL) && (*pdwInfoSize >= dwAuthData))
        {
            memcpy (pbConnInfo, pbAuthData, dwAuthData);
        }
        else
        {
            dwRetCode = ERROR_BUFFER_TOO_SMALL;
        }
        *pdwInfoSize = dwAuthData;

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }
    if (fFreeAuthData)
    {
        if (pbAuthData != NULL)
        {
            FREE (pbAuthData);
        }
    }

    return dwRetCode;
}


//
// ElReAuthenticateInterface
//
// Description:
//
// Function called to reinitiate authentication on an interface
//
// Arguments:
//
//  pwszGUID - pointer to GUID string for the interface
//
// Return values:
//
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElReAuthenticateInterface (
        IN  WCHAR           *pwszGUID
        )
{
    BYTE    *pbData = NULL;
    DWORD   dwEventStatus = 0;
    BOOLEAN fDecrWorkerThreadCount = FALSE;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            dwRetCode = NO_ERROR;
            break;
        }
        if (( dwEventStatus = WaitForSingleObject (
                                    g_hEventTerminateEAPOL,
                                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            break;
        }
        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            break;
        }

        fDecrWorkerThreadCount = TRUE;
        InterlockedIncrement (&g_lWorkerThreads);

        pbData = (BYTE *) MALLOC ((wcslen(pwszGUID)+1)*sizeof(WCHAR));
        if (pbData == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wcscpy ((WCHAR *)pbData, pwszGUID);

        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)ElReAuthenticateInterfaceWorker,
                    (PVOID)pbData,
                    WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElPostEapConfigChanged: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            fDecrWorkerThreadCount = FALSE;
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pbData != NULL)
        {
            FREE (pbData);
        }
    }
    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    return dwRetCode;
}


//
// ElReAuthenticateInterfaceWorker
//
// Description:
//
// Worker function called to reinitiate authentication on an interface
//
// Arguments:
//
//  pwszGUID - pointer to GUID string for the interface
//
// Return values:
//
//      NO_ERROR - success
//      non-zero - error
//

DWORD
WINAPI
ElReAuthenticateInterfaceWorker (
        IN  PVOID       pvContext
        )
{
    PWCHAR  pwszGUID = NULL;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        pwszGUID = (PWCHAR)pvContext;

        // Do not shutdown interface, merely restart authentication
#if 0
        if ((dwRetCode = ElShutdownInterface (pwszGUID)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElReAuthenticateInterface: ElShutdownInterface failed with error %ld",
                    dwRetCode);
            break;
        }
#endif

        if ((dwRetCode = ElEnumAndOpenInterfaces (
                        NULL, pwszGUID, 0, NULL))
                != NO_ERROR)
        {
            TRACE1 (ANY, "ElReAuthenticateInterface: ElEnumAndOpenInterfaces returned error %ld",
                    dwRetCode);
        }
    }
    while (FALSE);

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }
    InterlockedDecrement (&g_lWorkerThreads);

    return dwRetCode;
}


//
// ElQueryInterfaceState
//
// Description:
//
// Function called to query the EAPOL state for an interface
//
// Arguments:
//
//  pwszGUID - pointer to GUID string for the interface
//  pIntfState - pointer to interface state structure
//
// Return values:
//
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElQueryInterfaceState (
        IN  WCHAR                   *pwszGUID,
        IN OUT  EAPOL_INTF_STATE    *pIntfState
        )
{
    EAPOL_PCB               *pPCB = NULL;
    BOOLEAN                 fPortReferenced = FALSE;
    BOOLEAN                 fPCBLocked = FALSE;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        ACQUIRE_WRITE_LOCK (&g_PCBLock);
        if ((pPCB = ElGetPCBPointerFromPortGUID (pwszGUID)) != NULL)
        {
            if (EAPOL_REFERENCE_PORT (pPCB))
            {
                fPortReferenced = TRUE;
            }
            else
            {
                pPCB = NULL;
            }
        }
        RELEASE_WRITE_LOCK (&g_PCBLock);
        if (pPCB == NULL)
        {
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
        fPCBLocked = TRUE;

        if (pPCB->pSSID)
        {
            pIntfState->dwSizeOfSSID = pPCB->pSSID->SsidLength;
            memcpy (pIntfState->bSSID, pPCB->pSSID->Ssid,
                    NDIS_802_11_SSID_LEN-sizeof(ULONG));
        }
        else
        {
            pIntfState->dwSizeOfSSID = 0;
        }

        if (pPCB->pszIdentity)
        {
            if ((pIntfState->pszEapIdentity = RpcCAlloc((strlen(pPCB->pszIdentity)+1)*sizeof(CHAR))) == NULL)
            {
                dwRetCode = GetLastError ();
                break;
            }
            strcpy (pIntfState->pszEapIdentity, (LPSTR)pPCB->pszIdentity);
        }

        if ((pIntfState->pwszLocalMACAddr = RpcCAlloc(3*SIZE_MAC_ADDR*sizeof(WCHAR))) == NULL)
        {
            dwRetCode = GetLastError ();
            break;
        }
        ZeroMemory ((PVOID)pIntfState->pwszLocalMACAddr, 3*SIZE_MAC_ADDR*sizeof(WCHAR));
        MACADDR_BYTE_TO_WSTR(pPCB->bSrcMacAddr, pIntfState->pwszLocalMACAddr);

        if ((pIntfState->pwszRemoteMACAddr = RpcCAlloc(3*SIZE_MAC_ADDR*sizeof(WCHAR))) == NULL)
        {
            dwRetCode = GetLastError ();
            break;
        }
        ZeroMemory ((PVOID)pIntfState->pwszRemoteMACAddr, 3*SIZE_MAC_ADDR*sizeof(WCHAR));
        MACADDR_BYTE_TO_WSTR(pPCB->bDestMacAddr, pIntfState->pwszRemoteMACAddr);

        pIntfState->dwState = pPCB->State;
        pIntfState->dwEapUIState = pPCB->EapUIState;
        pIntfState->dwEAPOLAuthMode = pPCB->dwEAPOLAuthMode;
        pIntfState->dwEAPOLAuthenticationType = pPCB->PreviousAuthenticationType;
        pIntfState->dwEapType = pPCB->dwEapTypeToBeUsed;
        pIntfState->dwFailCount = pPCB->dwAuthFailCount;
        pIntfState->dwPhysicalMediumType = pPCB->PhysicalMediumType;
    }
    while (FALSE);

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }
    if (fPortReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }
    if (dwRetCode != NO_ERROR)
    {
        RpcFree (pIntfState->pwszLocalMACAddr);
        RpcFree (pIntfState->pwszRemoteMACAddr);
        RpcFree (pIntfState->pszEapIdentity);
        pIntfState->pwszLocalMACAddr = NULL;
        pIntfState->pwszRemoteMACAddr = NULL;
        pIntfState->pszEapIdentity = NULL;
    }

    return dwRetCode;
}


//
// ElSetEapUserInfo
//
// Description:
//
// Function called to store the user data for an interface for a 
// specific EAP type and SSID (if any). Data is stored in the HKCU hive.
// In case of EAP-TLS, this data will be the hash blob of the certificate
// chosen for the last successful authentication.
//
// Arguments:
//
//  hToken - Handle to token for the logged on user
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP user blob
//  pbSSID - Special identifier if any for the EAP user blob
//  pbUserInfo - pointer to EAP user data blob
//  dwInfoSize - Size of EAP user blob
//
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElSetEapUserInfo (
        IN  HANDLE      hToken,
        IN  WCHAR       *pwszGUID,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  PBYTE       pbUserInfo,
        IN  DWORD       dwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    DWORD       dwDisposition;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    WCHAR       wcszValueName[MAX_VALUENAME_LEN];
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL, *pbEapBlobIn = NULL;
    DWORD       dwEapBlob = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    EAPOL_INTF_PARAMS       *pDefIntfParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (hToken == NULL)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: User Token = NULL");
            break;
        }
        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: GUID = NULL");
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: GUID = NULL");
            break;
        }
        if ((pbUserInfo == NULL) || (dwInfoSize <= 0))
        {
            TRACE0 (ANY, "ElSetEapUserInfo: Invalid blob data");
            break;
        }

        // Get handle to HKCU

        if ((dwRetCode = ElGetEapKeyFromToken (
                                hToken,
                                &hkey)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in ElGetEapKeyFromToken %ld",
                    dwRetCode);
            break;
        }

        if ((lError = RegCreateKeyEx (
                        hkey,
                        cwszEapKeyEapolUser,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE | KEY_READ,
                        NULL,
                        &hkey1,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegCreateKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegCreateKeyEx (
                        hkey1,
                        pwszGUID,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE | KEY_READ,
                        NULL,
                        &hkey2,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegCreateKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((lError = RegQueryInfoKey (
                        hkey2,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElSetEapUserInfo: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if (dwMaxValueNameLen > MAX_VALUENAME_LEN)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: dwMaxValueNameLen too long (%ld)",
                    dwMaxValueNameLen);
        }
        dwMaxValueNameLen = MAX_VALUENAME_LEN;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElSetEapUserInfo: MALLOC failed for pbValueBuf");
            break;
        }

        // Set correct SSID
        if ((dwSizeOfSSID == 0) || (dwSizeOfSSID > MAX_SSID_LEN) || 
                (pbSSID == NULL))
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwMaxValueNameLen = MAX_VALUENAME_LEN;
            ZeroMemory (wcszValueName, MAX_VALUENAME_LEN*sizeof(WCHAR));
            if ((lError = RegEnumValue (
                            hkey2,
                            dwIndex,
                            wcszValueName,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                lError = ERROR_INVALID_DATA;
                TRACE2 (ANY, "ElSetEapUserInfo: dwValueData (%ld) < sizeof (EAPOL_INTF_PARAMS) (%ld)",
                        dwValueData,  sizeof (EAPOL_INTF_PARAMS));
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(wcszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (wcszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }

        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElSetEapUserInfo: RegEnumValue 2 failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            DWORD dwNewValueName = (dwMaxValueName >= dwNumValues)?(++dwMaxValueName):dwNumValues;
            _ltow (dwNewValueName, wcszValueName, 10);
            if ((pbDefaultValue = MALLOC (sizeof(EAPOL_INTF_PARAMS))) == NULL)
            {
                TRACE0 (ANY, "ElSetEapUserInfo: MALLOC failed for pbDefaultValue");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            // Mark that SSID for this entry
            // Rest of the parameters are dummy for UserEapInfo
            pDefIntfParams = (EAPOL_INTF_PARAMS *)pbDefaultValue;
            pDefIntfParams->dwSizeOfSSID = dwSizeOfSSID;
            memcpy (pDefIntfParams->bSSID, pbSSID, dwSizeOfSSID);

            dwEapBlob = sizeof(EAPOL_INTF_PARAMS);
            pbEapBlob = pbDefaultValue;
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        pbEapBlobIn = pbEapBlob;
        if ((dwRetCode = ElSetEapData (
                dwEapTypeId,
                &dwEapBlob,
                &pbEapBlob,
                sizeof (EAPOL_INTF_PARAMS),
                dwInfoSize,
                pbUserInfo
                )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: ElSetEapData failed with error %ld",
                    dwRetCode);
            break;
        }

        // Overwrite/Create new value
        if ((lError = RegSetValueEx (
                        hkey2,
                        wcszValueName,
                        0,
                        REG_BINARY,
                        pbEapBlob,
                        dwEapBlob)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegSetValueEx for SSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElSetEapUserInfo: Set value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if ((pbEapBlob != pbEapBlobIn) && (pbEapBlob != NULL))
    {
        FREE (pbEapBlob);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }

    return dwRetCode;
}


//
// ElGetEapUserInfo
//
// Description:
//
// Function called to retrieve the user data for an interface for a 
// specific EAP type and SSID (if any). Data is retrieved from the HKCU hive
//
// Arguments:
//  hToken - Handle to token for the logged on user
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP user blob
//  pbSSID - Special identifier if any for the EAP user blob
//  pbUserInfo - output: pointer to EAP user data blob
//  dwInfoSize - output: pointer to size of EAP user blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetEapUserInfo (
        IN  HANDLE          hToken,
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwTempValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL;
    DWORD       dwEapBlob = 0;
    BYTE        *pbAuthData = NULL;
    DWORD       dwAuthData = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS   *pRegParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (hToken == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: User Token = NULL");
            break;
        }
        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: GUID = NULL");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: GUID = NULL");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get handle to HKCU

        if ((dwRetCode = ElGetEapKeyFromToken (
                                hToken,
                                &hkey)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in ElGetEapKeyFromToken %ld",
                    dwRetCode);
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey,
                        cwszEapKeyEapolUser,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey1,
                        pwszGUID,
                        0,
                        KEY_READ,
                        &hkey2
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Set correct SSID
        if ((dwSizeOfSSID == 0) || (dwSizeOfSSID > MAX_SSID_LEN) || 
                (pbSSID == NULL))
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        if ((lError = RegQueryInfoKey (
                        hkey2,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElGetEapUserInfo: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: MALLOC failed for pwszValueName");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: MALLOC failed for pbValueBuf");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwTempValueNameLen = dwMaxValueNameLen;
            if ((lError = RegEnumValue (
                            hkey2,
                            dwIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                TRACE0 (ANY, "ElGetEapUserInfo: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                lError = ERROR_INVALID_DATA;
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(pwszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (pwszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElGetEapUserInfo: RegEnumValue 2 failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            pbEapBlob = NULL;
            dwEapBlob = 0;
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        // If blob is not present, exit
        if ((pbEapBlob == NULL) && (dwEapBlob == 0))
        {
            TRACE0 (ANY, "ElGetEapUserInfo: (pbEapBlob == NULL) && (dwEapBlob == 0)");
            *pdwInfoSize = 0;
            break;
        }

        if ((dwRetCode = ElGetEapData (
                dwEapTypeId,
                dwEapBlob,
                pbEapBlob,
                sizeof (EAPOL_INTF_PARAMS),
                &dwAuthData,
                &pbAuthData
                )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: ElGetEapData failed with error %ld",
                    dwRetCode);
            break;
        }

        // Return the data if sufficient space allocated

        if ((pbUserInfo != NULL) && (*pdwInfoSize >= dwAuthData))
        {
            memcpy (pbUserInfo, pbAuthData, dwAuthData);
        }
        else
        {
            dwRetCode = ERROR_BUFFER_TOO_SMALL;
        }
        *pdwInfoSize = dwAuthData;

        TRACE0 (ANY, "ElGetEapUserInfo: Get value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }

    return dwRetCode;
}


//
// ElDeleteEapUserInfo
//
// Description:
//
// Function called to delete the user data for an interface for a 
// specific EAP type and SSID (if any). Data is stored in the HKCU hive.
// In case of EAP-TLS, this data will be the hash blob of the certificate
// chosen for the last successful authentication.
//
// Arguments:
//
//  hToken - Handle to token for the logged on user
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP user blob
//  pbSSID - Special identifier if any for the EAP user blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElDeleteEapUserInfo (
        IN  HANDLE      hToken,
        IN  WCHAR       *pwszGUID,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    DWORD       dwDisposition;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwTempValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    WCHAR       *pwszValueName = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL, *pbEapBlobIn = NULL;
    DWORD       dwEapBlob = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    EAPOL_INTF_PARAMS       *pDefIntfParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (hToken == NULL)
        {
            TRACE0 (ANY, "ElDeleteEapUserInfo: User Token = NULL");
            break;
        }
        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElDeleteEapUserInfo: GUID = NULL");
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElDeleteEapUserInfo: GUID = NULL");
            break;
        }

        // Get handle to HKCU

        if ((dwRetCode = ElGetEapKeyFromToken (
                                hToken,
                                &hkey)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElDeleteEapUserInfo: Error in ElGetEapKeyFromToken %ld",
                    dwRetCode);
            break;
        }

        if ((lError = RegOpenKeyEx (
                        hkey,
                        cwszEapKeyEapolUser,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey1)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElDeleteEapUserInfo: Error in RegOpenKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey1,
                        pwszGUID,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey2)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElDeleteEapUserInfo: Error in RegOpenKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((lError = RegQueryInfoKey (
                        hkey2,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElDeleteEapUserInfo: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElDeleteEapUserInfo: MALLOC failed for pwszValueName");
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElDeleteEapUserInfo: MALLOC failed for pbValueBuf");
            break;
        }

        // Set correct SSID
        if ((dwSizeOfSSID == 0) || (dwSizeOfSSID > MAX_SSID_LEN) || 
                (pbSSID == NULL))
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwTempValueNameLen = dwMaxValueNameLen;
            if ((lError = RegEnumValue (
                            hkey2,
                            dwIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                lError = ERROR_INVALID_DATA;
                TRACE0 (ANY, "ElDeleteEapUserInfo: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(pwszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (pwszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElDeleteEapUserInfo: RegEnumValue 2 failed with error %ld",
                        dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            break;
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        pbEapBlobIn = pbEapBlob;
        if ((dwRetCode = ElSetEapData (
                dwEapTypeId,
                &dwEapBlob,
                &pbEapBlob,
                sizeof(EAPOL_INTF_PARAMS),
                0,
                NULL
                )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElDeleteEapUserInfo: ElSetEapData failed with error %ld",
                        dwRetCode);
            break;
        }

        // Overwrite value
        if ((lError = RegSetValueEx (
                        hkey2,
                        pwszValueName,
                        0,
                        REG_BINARY,
                        pbEapBlob,
                        dwEapBlob)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElDeleteEapUserInfo: Error in RegSetValueEx for SSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElDeleteEapUserInfo: Delete value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if ((pbEapBlob != pbEapBlobIn) && (pbEapBlob != NULL))
    {
        FREE (pbEapBlob);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }

    return dwRetCode;
}


//
// ElGetInterfaceParams
//
// Description:
//
// Function called to retrieve the EAPOL parameters for an interface, stored
// in the HKLM hive.
//
// Arguments:
//
//  pwszGUID - pointer to GUID string for the interface
//  pIntfParams - pointer to interface parameter structure
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS *pIntfParams
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    BYTE        *pbSSID = NULL;
    BYTE        bSSID[MAX_SSID_LEN];
    DWORD       dwSizeOfSSID = 0;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwTempValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL;
    DWORD       dwEapBlob = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    EAPOL_POLICY_PARAMS     EAPOLPolicyParams = {0};
    LONG        lError = ERROR_SUCCESS;
    EAPOL_PCB   *pPCB = NULL;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Validate input params
        if (pwszGUID == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            TRACE0 (ANY, "ElGetInterfaceParams: GUID = NULL");
            break;
        }

        if (pIntfParams == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Work with appropriate SSID
        if (pIntfParams->dwSizeOfSSID != 0)
        {
            dwSizeOfSSID = pIntfParams->dwSizeOfSSID;
            if (dwSizeOfSSID > MAX_SSID_LEN)
            {
                dwRetCode = ERROR_INVALID_PARAMETER;
                TRACE2 (ANY, "ElGetInterfaceParams: dwSizeOfSSID (%ld) > MAX_SSID_LEN (%ld)",
                        dwSizeOfSSID, MAX_SSID_LEN);
                break;
            }
            pbSSID = pIntfParams->bSSID;
        }
        else
        {
            ACQUIRE_WRITE_LOCK (&g_PCBLock);

            if ((pPCB = ElGetPCBPointerFromPortGUID (pwszGUID)) != NULL)
            {
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
                if ((pPCB->pSSID != NULL) && (pPCB->MediaState != MEDIA_STATE_DISCONNECTED))
                {
                    dwSizeOfSSID = pPCB->pSSID->SsidLength;
                    ZeroMemory (bSSID, MAX_SSID_LEN);
                    memcpy (bSSID, pPCB->pSSID->Ssid, pPCB->pSSID->SsidLength);
                    pbSSID = bSSID;
                }
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            }

            RELEASE_WRITE_LOCK (&g_PCBLock);

            if (dwSizeOfSSID == 0)
            {
                dwSizeOfSSID = MAX_SSID_LEN;
                pbSSID = g_bDefaultSSID;
            }
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        KEY_READ,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            // Assume no value is found and proceed ahead
            if (lError == ERROR_FILE_NOT_FOUND)
            {
                lError = ERROR_SUCCESS;
                fFoundValue = FALSE;
                goto LNotFoundValue;
            }
            else
            {
                TRACE1 (ANY, "ElGetInterfaceParams: Error in RegOpenKeyEx for base key, %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey,
                        pwszGUID,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            // Assume no value is found and proceed ahead
            if (lError == ERROR_FILE_NOT_FOUND)
            {
                lError = ERROR_SUCCESS;
                fFoundValue = FALSE;
                goto LNotFoundValue;
            }
            else
            {
                TRACE1 (ANY, "ElGetInterfaceParams: Error in RegOpenKeyEx for GUID, %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
        }

        if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElGetInterfaceParams: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElGetInterfaceParams: MALLOC failed for pwszValueName");
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElGetInterfaceParams: MALLOC failed for pbValueBuf");
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwTempValueNameLen = dwMaxValueNameLen;
            if ((lError = RegEnumValue (
                            hkey1,
                            dwIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                TRACE0 (ANY, "ElGetInterfaceParams: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                lError = ERROR_INVALID_DATA;
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(pwszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (pwszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

LNotFoundValue:

        if (!fFoundValue)
        {
            if ((pbDefaultValue = MALLOC (sizeof (EAPOL_INTF_PARAMS))) == NULL)
            {
                lError = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (ANY, "ElGetInterfaceParams: MALLOC failed for pbDefaultValue");
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbDefaultValue;
            pRegParams->dwEapType = DEFAULT_EAP_TYPE;
            pRegParams->dwEapFlags = DEFAULT_EAP_STATE;
            pRegParams->dwVersion = EAPOL_CURRENT_VERSION;
            pRegParams->dwSizeOfSSID = dwSizeOfSSID;
            memcpy (pRegParams->bSSID, pbSSID, dwSizeOfSSID);
            dwDefaultValueLen = sizeof(EAPOL_INTF_PARAMS);

            // Use pbDefaultValue & dwDefaultValueLen
            pbEapBlob = pbDefaultValue;
            dwEapBlob = dwDefaultValueLen;
        }
        else
        {
            if (dwSizeOfSSID == MAX_SSID_LEN)
            {
                if (!memcmp (pbSSID, g_bDefaultSSID, MAX_SSID_LEN))
                {
                    pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;
                    if ((pRegParams->dwVersion != EAPOL_CURRENT_VERSION) &&
                            (pRegParams->dwEapType == EAP_TYPE_TLS))
                    {
                        pRegParams->dwVersion = EAPOL_CURRENT_VERSION;
                        pRegParams->dwEapFlags |= DEFAULT_MACHINE_AUTH_STATE;
                        pRegParams->dwEapFlags &= ~EAPOL_GUEST_AUTH_ENABLED;
                    }
                }
            }

            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        if ((dwRetCode = ElGetPolicyInterfaceParams (
                        dwSizeOfSSID,
                        pbSSID,
                        &EAPOLPolicyParams
                        )) == NO_ERROR)
        {
            TRACE0 (ANY, "ElGetInterfaceParams: POLICY: ElGetPolicyInterfaceParams found relevant data");
            pbEapBlob = (PBYTE)(&(EAPOLPolicyParams.IntfParams));
            dwEapBlob = sizeof(EAPOL_INTF_PARAMS);
        }
        else
        {
            if (dwRetCode != ERROR_FILE_NOT_FOUND)
            {
                TRACE1 (ANY, "ElGetInterfaceParams: ElGetPolicyInterfaceParams failed with error (%ld)",
                    dwRetCode);
            }
            dwRetCode = NO_ERROR;
        }

        // Existing blob is not valid
        if ((dwEapBlob < sizeof(EAPOL_INTF_PARAMS)))
        {
            dwRetCode = ERROR_FILE_NOT_FOUND;
            TRACE0 (ANY, "ElGetInterfaceParams: (dwEapBlob < sizeof(EAPOL_INTF_PARAMS)) || (pbEapBlob == NULL)");
            break;
        }

        memcpy ((BYTE *)pIntfParams, (BYTE *)pbEapBlob, sizeof(EAPOL_INTF_PARAMS));
    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }

    return dwRetCode;
}


//
// ElSetInterfaceParams
//
// Description:
//
// Function called to set the EAPOL parameters for an interface, in the HKLM
// hive
//
// Arguments:
//
//  pwszGUID - Pointer to GUID string for the interface
//  pIntfParams - pointer to interface parameter structure
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
//

DWORD
ElSetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS *pIntfParams
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwDisposition;
    BYTE        *pbSSID = NULL;
    DWORD       dwSizeOfSSID = 0;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    WCHAR       wcszValueName[MAX_VALUENAME_LEN];
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL;
    DWORD       dwEapBlob = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS   *pRegParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Validate input params

        if (pwszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetInterfaceParams: GUID = NULL");
            break;
        }

        if (pIntfParams == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        TRACE1 (ANY, "Setting stuff in registry for %ws", pwszGUID);

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE | KEY_READ,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegCreateKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>
        if ((lError = RegCreateKeyEx (
                        hkey,
                        pwszGUID,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE | KEY_READ,
                        NULL,
                        &hkey1,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegCreateKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Select correct SSID value
        if (pIntfParams->dwSizeOfSSID != 0)
        {
            dwSizeOfSSID = pIntfParams->dwSizeOfSSID;
            if (dwSizeOfSSID > MAX_SSID_LEN)
            {
                dwRetCode = ERROR_INVALID_PARAMETER;
                TRACE2 (ANY, "ElSetInterfaceParams: dwSizeOfSSID (%ld) > MAX_SSID_LEN (%ld)",
                        dwSizeOfSSID, MAX_SSID_LEN);
                break;
            }
            pbSSID = pIntfParams->bSSID;
        }
        else
        {
            dwSizeOfSSID = MAX_SSID_LEN;
            pbSSID = g_bDefaultSSID;
        }

        if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            break;
        }

        if (dwMaxValueNameLen > MAX_VALUENAME_LEN)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE1 (ANY, "ElSetInterfaceParams: dwMaxValueNameLen too long (%ld)",
                    dwMaxValueNameLen);
            break;
        }
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwMaxValueNameLen = MAX_VALUENAME_LEN;
            ZeroMemory (wcszValueName, MAX_VALUENAME_LEN*sizeof(WCHAR));

            if ((lError = RegEnumValue (
                            hkey1,
                            dwIndex,
                            wcszValueName,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                lError = ERROR_INVALID_DATA;
                TRACE0 (ANY, "ElSetInterfaceParams: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(wcszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (wcszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }

        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElSetInterfaceParams: RegEnumValue 2 failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            DWORD dwNewValueName = (dwMaxValueName >= dwNumValues)?(++dwMaxValueName):dwNumValues;
            _ltow (dwNewValueName, wcszValueName, 10);
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        if ((dwEapBlob < sizeof(EAPOL_INTF_PARAMS)) && (pbEapBlob != NULL))
        {
            TRACE0 (ANY, "ElSetInterfaceParams: (dwEapBlob < sizeof(EAPOL_INTF_PARAMS)) && (pbEapBlob != NULL)");
            break;
        }

        if (pbEapBlob != NULL)
        {
            memcpy ((BYTE *)pbEapBlob, (BYTE *)pIntfParams, sizeof(EAPOL_INTF_PARAMS));
        }
        else
        {
            pbEapBlob = (BYTE *)pIntfParams;
            dwEapBlob = sizeof(EAPOL_INTF_PARAMS);
        }
        pRegParams = (EAPOL_INTF_PARAMS *)pbEapBlob;
        pRegParams->dwVersion = EAPOL_CURRENT_VERSION;
        pRegParams->dwSizeOfSSID = dwSizeOfSSID;
        memcpy (pRegParams->bSSID, pbSSID, dwSizeOfSSID);

        // Overwrite/Create new value
        if ((lError = RegSetValueEx (
                        hkey1,
                        wcszValueName,
                        0,
                        REG_BINARY,
                        pbEapBlob,
                        dwEapBlob)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegSetValueEx for SSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElSetInterfaceParams: Succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }

    return dwRetCode;
}


//
// ElGetEapData
//
// Description:
//
// Function to extract Eap Data out of a blob containing many EAP data
// 
// Arguments:
//      dwEapType -
//      dwSizeOfIn -
//      pbBufferIn -
//      dwOffset -
//      pdwSizeOfOut -
//      ppbBufferOut -
//
// Return values:
//
//

DWORD
ElGetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   dwSizeOfIn,
        IN  BYTE    *pbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   *pdwSizeOfOut,
        IN  PBYTE   *ppbBufferOut
        )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   cbOffset = 0;
    EAPOL_AUTH_DATA   *pCustomData = NULL;

    do
    {
        *pdwSizeOfOut = 0;
        *ppbBufferOut = NULL;

        if (pbBufferIn == NULL)
        {
            break;
        }

        // Align to start of EAP blob
        cbOffset = dwOffset;

        while (cbOffset < dwSizeOfIn)
        {
            pCustomData = (EAPOL_AUTH_DATA *) 
                ((PBYTE) pbBufferIn + cbOffset);

            if (pCustomData->dwEapType == dwEapType)
            {
                break;
            }
            cbOffset += sizeof (EAPOL_AUTH_DATA) + pCustomData->dwSize;
        }

        if (cbOffset < dwSizeOfIn)
        {
            *pdwSizeOfOut = pCustomData->dwSize;
            *ppbBufferOut = pCustomData->bData;
        }
    }
    while (FALSE);

    return dwRetCode;
}


//
// ElSetEapData
//
// Description:
//
// Function to set Eap Data in a blob containing many EAP data
// 
// Arguments:
//      dwEapType -
//      dwSizeOfIn -
//      pbBufferIn -
//      dwOffset -
//      pdwSizeOfOut -
//      ppbBufferOut -
//
// Return values:
//
//

DWORD
ElSetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   *pdwSizeOfIn,
        IN  PBYTE   *ppbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   dwAuthData,
        IN  PBYTE   pbAuthData
        )
{
    DWORD   cbOffset = 0;
    EAPOL_AUTH_DATA   *pCustomData = NULL;
    BYTE   *pbNewAuthData = NULL;
    DWORD   dwSize = 0;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        // Align to start of EAP blob
        cbOffset = dwOffset;

        // Find the old EAP Data
        while (cbOffset < *pdwSizeOfIn)
        {
            pCustomData = (EAPOL_AUTH_DATA *) 
                ((PBYTE) *ppbBufferIn + cbOffset);

            if (pCustomData->dwEapType == dwEapType)
            {
                break;
            }
            cbOffset += sizeof (EAPOL_AUTH_DATA) + pCustomData->dwSize;
        }

        if (cbOffset < *pdwSizeOfIn)
        {
            dwSize = sizeof (EAPOL_AUTH_DATA) + pCustomData->dwSize;
            MoveMemory (*ppbBufferIn + cbOffset,
                        *ppbBufferIn + cbOffset + dwSize,
                        *pdwSizeOfIn - cbOffset - dwSize);
            *pdwSizeOfIn -= dwSize;
        }
        if ((*pdwSizeOfIn == 0) && (*ppbBufferIn != NULL))
        {
            // FREE (*ppbBufferIn);
            *ppbBufferIn = NULL;
        }

        if ((dwAuthData == 0) || (pbAuthData == NULL))
        {
            break;
        }

#ifdef _WIN64
        dwSize = ((dwAuthData+7) & 0xfffffff8) + *pdwSizeOfIn + sizeof (EAPOL_AUTH_DATA);
#else
        dwSize = dwAuthData + *pdwSizeOfIn + sizeof (EAPOL_AUTH_DATA);
#endif

        if ((pbNewAuthData = MALLOC (dwSize)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory (pbNewAuthData, *ppbBufferIn, *pdwSizeOfIn);

        pCustomData = (EAPOL_AUTH_DATA *) (pbNewAuthData + *pdwSizeOfIn);

        pCustomData->dwEapType = dwEapType;
        CopyMemory (pCustomData->bData, pbAuthData, dwAuthData);
#ifdef _WIN64
        pCustomData->dwSize = (dwAuthData+7) & 0xfffffff8;
#else
        pCustomData->dwSize = dwAuthData;
#endif
        
        if (*ppbBufferIn != NULL)
        {
            // FREE (*ppbBufferIn);
        }

        *ppbBufferIn = pbNewAuthData;
        *pdwSizeOfIn = dwSize;
    }
    while (FALSE);

    return dwRetCode;
}


//
// ElGetEapKeyFromToken
//
// Description:
//
// Function to get handle to User hive from User Token
//
// Arguments:
//  hUserToken - handle to user token
//  phkey - output: pointer to handle to user hive
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetEapKeyFromToken (
        IN  HANDLE      hUserToken,
        OUT HKEY        *phkey
        )
{
    DWORD               dwSizeNeeded;
    TOKEN_USER          *pTokenData = NULL;
    UNICODE_STRING      UnicodeSidString;
    WCHAR               wsUnicodeBuffer[256];
    HKEY                hUserKey;
    HKEY                hkeyEap;
    DWORD               dwDisposition;
    NTSTATUS            Status = STATUS_SUCCESS;
    PBYTE               pbInfo = NULL;
    CHAR                *pszInfo = NULL;
    DWORD               dwType;
    DWORD               dwInfoSize = 0;
    LONG                lRetVal;
    EAPOL_PCB           *pPCB;
    DWORD               i;
    LONG                lError = ERROR_SUCCESS;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        if (hUserToken != NULL)
        {
            if (!GetTokenInformation(hUserToken, TokenUser, 0, 0, &dwSizeNeeded))
            {
                if ((dwRetCode = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                {
                    pTokenData = (TOKEN_USER *) MALLOC (dwSizeNeeded);

                    if (pTokenData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (ANY,"ElGetEapKeyFromToken: Allocation for TokenData failed");
                        break;
                    }
                    // Reset error code since we are continuing processing
                    // This was a valid scenario
                    dwRetCode = NO_ERROR;
                }
                else
                {
                    TRACE1 (ANY,"ElGetEapKeyFromToken: Error in GetTokenInformation = %ld",
                            dwRetCode);
                    break;
                }

                if (!GetTokenInformation (hUserToken,
                                            TokenUser,
                                            pTokenData,
                                            dwSizeNeeded,
                                            &dwSizeNeeded))
                {
                    dwRetCode = GetLastError ();
                    
                    TRACE1 (ANY,"ElGetEapKeyFromToken: GetTokenInformation failed with error %ld",
                            dwRetCode);
                    break;
                }

                UnicodeSidString.Buffer = wsUnicodeBuffer;
                UnicodeSidString.Length = 0;
                UnicodeSidString.MaximumLength = sizeof(wsUnicodeBuffer);

                Status = RtlConvertSidToUnicodeString (
                                        &UnicodeSidString,
                                        pTokenData->User.Sid,
                                        FALSE);

                if (!NT_SUCCESS(Status))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetEapKeyFromToken: RtlconvertSidToUnicodeString failed with error %ld",
                            dwRetCode);
                    break;
                }

                UnicodeSidString.Buffer[UnicodeSidString.Length] = 0;

                // Open the user's key
                if ((lError = RegOpenKeyEx(HKEY_USERS, 
                            UnicodeSidString.Buffer, 
                            0, 
                            KEY_ALL_ACCESS, 
                            &hUserKey)) != ERROR_SUCCESS)
                {
                    dwRetCode = (DWORD)lError;
                    TRACE1 (USER, "ElGetEapKeyFromToken: RegOpenKeyEx failed with error %ld",
                            dwRetCode);
                    break;
                }
                else
                {
                    TRACE0 (ANY, "ElGetEapKeyFromToken: RegOpenKeyEx succeeded"); 
                }

            }
            else
            {
                TRACE0 (ANY,"ElGetEapKeyFromToken: GetTokenInformation succeeded when it should have failed");
                break;
            }
        }
        else
        {
            TRACE0 (ANY, "ElGetEapKeyFromToken: Error, hUserToken == NULL ");
            dwRetCode = ERROR_NO_TOKEN;
            break;
        }

        *phkey = hUserKey;

    } while (FALSE);

    if (pTokenData != NULL)
    {
        FREE (pTokenData);
    }

    return dwRetCode;
}


//
// ElInitRegPortData
//
// Description:
//
// Function to verify existence of connection data for the port
// If no data exists, initialize with default values
// For EAP-TLS, default settings are no server certificate authentication, 
// registry certificates
//
// Arguments:
//  pwszDeviceGUID - Pointer to GUID string for the port for which data is being
//                  initiialized
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElInitRegPortData (
        WCHAR       *pwszDeviceGUID
        )
{
    DWORD       dwAuthData  = 0;
    BYTE        *pConnProp  = NULL;
    DWORD       dwSizeOfConnProp = 0;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Get the size of the Eap data first
        if ((dwRetCode = ElGetCustomAuthData (
                        pwszDeviceGUID,
                        DEFAULT_EAP_TYPE,
                        0,
                        NULL,  
                        NULL, 
                        &dwAuthData
                       )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElInitRegPortData: ElGetCustomAuthData returned error %ld",
                    dwRetCode);

            // There is data in the registry
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                dwRetCode = NO_ERROR;
                break;
            }

            if ((dwRetCode = ElCreateDefaultEapData (&dwSizeOfConnProp, NULL)) == ERROR_BUFFER_TOO_SMALL)
            {
                if ((pConnProp = MALLOC (dwSizeOfConnProp)) == NULL)
                {
                    TRACE0 (ANY, "ElInitRegPortData: MALLOC failed for Conn Prop");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                if ((dwRetCode = ElCreateDefaultEapData (&dwSizeOfConnProp, pConnProp)) != NO_ERROR)
                {
                    TRACE1 (ANY, "ElInitRegPortData: ElCreateDefaultEapData failed with error (%ld)",
                            dwRetCode);
                    break;
                }
            }

            // Set this blob into the registry for the port
            if ((dwRetCode = ElSetCustomAuthData (
                        pwszDeviceGUID,
                        DEFAULT_EAP_TYPE,
                        0,
                        NULL,
                        pConnProp,
                        &dwSizeOfConnProp
                       )) != NO_ERROR)
            {
                TRACE1 (ANY, "ElInitRegPortData: ElSetCustomAuthData failed with %ld",
                        dwRetCode);
                break;
            }
        } 

    } while (FALSE);

    if (pConnProp != NULL)
    {
        FREE (pConnProp);
        pConnProp = NULL;
    }


    TRACE1 (ANY, "ElInitRegPortData: completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElCreateDefaultEapData
//
// Description:
//
// Function to create default EAP data for a connection
// Current default EAP type is EAP-TLS.
// For EAP-TLS, default settings are no server certificate authentication, 
// registry certificates
//
// Arguments:
//      *pdwSizeOfEapData -
//      pbEapData -
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCreateDefaultEapData (
        IN OUT  DWORD       *pdwSizeOfEapData,
        IN OUT  BYTE        *pbEapData
        )
{
    EAPTLS_CONN_PROPERTIES  ConnProp;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        if (*pdwSizeOfEapData < sizeof (EAPTLS_CONN_PROPERTIES))
        {
            *pdwSizeOfEapData = sizeof (EAPTLS_CONN_PROPERTIES);
            dwRetCode = ERROR_BUFFER_TOO_SMALL;
            break;
        }

        ZeroMemory ((VOID *)&ConnProp, sizeof (EAPTLS_CONN_PROPERTIES));

        // Registry certs, Server cert validation, No server name
        // comparison

        ConnProp.fFlags = (EAPTLS_CONN_FLAG_REGISTRY |
                                EAPTLS_CONN_FLAG_NO_VALIDATE_CERT |
                                EAPTLS_CONN_FLAG_NO_VALIDATE_NAME);

        ConnProp.fFlags &= ~EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;
        ConnProp.dwSize = sizeof (EAPTLS_CONN_PROPERTIES);

        memcpy ((VOID *)pbEapData, (VOID *)&ConnProp, sizeof (EAPTLS_CONN_PROPERTIES));
        *pdwSizeOfEapData = sizeof (EAPTLS_CONN_PROPERTIES);

    } while (FALSE);

    return dwRetCode;
}


//
// ElAuthAttributeGetVendorSpecific
//
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetVendorSpecific (
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
    )
{
    HANDLE               hAttribute;
    RAS_AUTH_ATTRIBUTE * pAttribute;

    //
    // First search for the vendor specific attribute
    //

    pAttribute = ElAuthAttributeGetFirst ( raatVendorSpecific,
                                           pAttributes,
                                           &hAttribute );

    while ( pAttribute != NULL )
    {
        //
        // If this attribute is of at least size to hold vendor Id/Type
        //

        if ( pAttribute->dwLength >= 8 )
        {
            //
            // Does this have the correct VendorId
            //

            if (WireToHostFormat32( (PBYTE)(pAttribute->Value) ) == dwVendorId)
            {
                //
                // Does this have the correct Vendor Type
                //

                if ( *(((PBYTE)(pAttribute->Value))+4) == dwVendorType )
                {
                    return( pAttribute );
                }
            }
        }

        pAttribute = ElAuthAttributeGetNext ( &hAttribute,
                                              raatVendorSpecific );
    }

    return( NULL );
}


//
// ElAuthAttributeGetFirst
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetFirst (
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes,
    OUT HANDLE *                 phAttribute
    )
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pRequiredAttribute;

    pRequiredAttribute = ElAuthAttributeGet ( raaType, pAttributes );

    if ( pRequiredAttribute == NULL )
    {
        *phAttribute = NULL;

        return( NULL );
    }

    *phAttribute = pRequiredAttribute;

    return( pRequiredAttribute );
}


//
// ElAuthAttributeGetNext
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetNext (
    IN  OUT HANDLE *             phAttribute,
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType
    )
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pAttributes = (RAS_AUTH_ATTRIBUTE *)*phAttribute;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    pAttributes++;

    while( pAttributes->raaType != raatMinimum )
    {
        if ( pAttributes->raaType == raaType )
        {
            *phAttribute = pAttributes;
            return( pAttributes );
        }

        pAttributes++;
    }

    *phAttribute = NULL;
    return( NULL );
}


//
// ElAuthAttributeGet
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGet (
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes
    )
{
    DWORD dwIndex;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ )
    {
        if ( pAttributes[dwIndex].raaType == raaType )
        {
            return( &(pAttributes[dwIndex]) );
        }
    }

    return( NULL );
}


//
// ElReverseString
//
// Description:
//      Reverses order of characters in 'psz'
//

VOID
ElReverseString (
    CHAR* psz 
    )
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


//
// ElEncodePw
//
// Description:
//
//      Obfuscate 'pszPassword' in place to foil memory scans for passwords.
//      Returns the address of 'pszPassword'.
//

CHAR*
ElEncodePw (
    IN OUT CHAR* pszPassword 
    )
{
    if (pszPassword)
    {
        CHAR* psz;

        ElReverseString (pszPassword);

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != (CHAR)PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }

    return pszPassword;
}


//
// ElDecodePw
//
// Description:
//
//      Un-obfuscate 'pszPassword' in place.
//      Returns the address of 'pszPassword'.
//

CHAR*
ElDecodePw (
    IN OUT CHAR* pszPassword 
    )
{
    return ElEncodePw (pszPassword);
}


//
// ElSecureEncodePw
//
// Description:
//
//      Encrypt password locally using user-ACL
//

DWORD
ElSecureEncodePw (
    IN  BYTE        *pbPassword,
    IN  DWORD       dwSizeOfPassword,
    OUT DATA_BLOB   *pDataBlob
    )
{
    DWORD       dwRetCode = NO_ERROR;
    DATA_BLOB   blobIn = {0}, blobOut = {0};

    do
    {
        blobIn.cbData = dwSizeOfPassword;
        blobIn.pbData = pbPassword;

        if (!CryptProtectData (
                    &blobIn,
                    L"",
                    NULL,
                    NULL,
                    NULL,
                    0,
                    &blobOut))
        {
            dwRetCode = GetLastError ();
            break;
        }
        
        // copy over blob to password

        if (pDataBlob->pbData != NULL)
        {
            FREE (pDataBlob->pbData);
            pDataBlob->pbData = NULL;
            pDataBlob->cbData = 0;
        }

        pDataBlob->pbData = MALLOC (blobOut.cbData);
        if (pDataBlob->pbData == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memcpy (pDataBlob->pbData, blobOut.pbData, blobOut.cbData);
        pDataBlob->cbData = blobOut.cbData;
    }
    while (FALSE);

    if (blobOut.pbData != NULL)
    {
        LocalFree (blobOut.pbData);
    }

    if (dwRetCode != NO_ERROR)
    {
        if (pDataBlob->pbData != NULL)
        {
            FREE (pDataBlob->pbData);
            pDataBlob->pbData = NULL;
            pDataBlob->cbData = 0;
        }
    }

    return dwRetCode;
}


//
// ElDecodePw
//
// Description:
//
//      Decrypt password locally using user-ACL
//

DWORD
ElSecureDecodePw (
        IN  DATA_BLOB   *pDataBlob,
        OUT PBYTE       *ppbPassword,
        OUT DWORD       *pdwSizeOfPassword
    )
{
    DWORD       dwRetCode = NO_ERROR;
    DATA_BLOB   blobOut = {0};
    LPWSTR pDescrOut = NULL; // NULL;

    do
    {
        if (!CryptUnprotectData (
                    pDataBlob,
                    &pDescrOut,
                    NULL,
                    NULL,
                    NULL,
                    0,
                    &blobOut))
        {
            dwRetCode = GetLastError ();
            break;
        }
        
        // copy over blob to password

        if (*ppbPassword != NULL)
        {
            FREE (*ppbPassword);
            *ppbPassword = NULL;
        }

        *ppbPassword = MALLOC (blobOut.cbData);
        if (*ppbPassword == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        *pdwSizeOfPassword = blobOut.cbData;
        memcpy ((BYTE *)*ppbPassword, blobOut.pbData, blobOut.cbData);
        // TRACE1 (ANY, "SecureDecode: Password = %ws", *ppbPassword);
    }
    while (FALSE);

    if (blobOut.pbData != NULL)
    {
        LocalFree (blobOut.pbData);
    }
    if (pDescrOut)
    {
        LocalFree (pDescrOut);
    }

    if (dwRetCode != NO_ERROR)
    {
        if (*ppbPassword != NULL)
        {
            FREE (*ppbPassword);
            *ppbPassword = NULL;
        }
    }

    return dwRetCode;
}


//
// Call: ElEncryptKeyUsingMD5
//
// Description:
//      Given a secret, encrypt a given blob
//      
//
//

VOID
ElEncryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        )
{
    MD5_CTX     MD5Context;
    BYTE        bcipherText[MD5DIGESTLEN];
    BYTE        *pbWork = NULL, *pbEnd = NULL;
    BYTE        *pbEndBlock = NULL, *pbSrc = NULL;

    //
    // Compute the beginning and end of the data to be crypted
    //
    pbWork = pbBuf;
    pbEnd   = pbBuf + ulBufLen;

    //
    // Loop through the buffer
    //
    while (pbWork < pbEnd)
    {
        // Compute the digest
        MD5Init (&MD5Context);
        MD5Update (&MD5Context, pbSecret, ulSecretLen);
        MD5Final (&MD5Context);

        // Find the end of the block to be decrypted
        pbEndBlock = pbWork + MD5DIGESTLEN;
        if (pbEndBlock >= pbEnd)
        {
            // We've reached the end of the buffer
            pbEndBlock = pbEnd;
        }
        else
        {
            // ISSUE: Save the ciphertext for the next pass?
        }
    
        // Crypt the block
        for (pbSrc = MD5Context.digest; pbWork < pbEndBlock; ++pbWork, ++pbSrc)
        {
            *pbWork ^= *pbSrc;
        }
    }
}


//
// ElDecryptKeyUsingMD5
//
// Description:
//      Given a secret, decrypt a given blob
//      
//
//

VOID
ElDecryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        )
{
    MD5_CTX     MD5Context;
    BYTE        bcipherText[MD5DIGESTLEN];
    BYTE        *pbWork = NULL, *pbEnd = NULL;
    BYTE        *pbEndBlock = NULL, *pbSrc = NULL;
    DWORD       dwNumBlocks = 0;
    DWORD       dwBlock = 0;
    DWORD       dwIndex = 0;

    dwNumBlocks = ( ulBufLen - 2 ) / MD5DIGESTLEN;

    //
    // Walk through the blocks
    //
    for (dwBlock = 0; dwBlock < dwNumBlocks; dwBlock++ )
    {
        MD5Init ( &MD5Context);
        MD5Update ( &MD5Context, (PBYTE)pbSecret, ulSecretLen);

        //
        // ISSUE:
        // Do we use any part of the ciphertext at all to generate 
        // the digest
        //

        MD5Final ( &MD5Context);

        for ( dwIndex = 0; dwIndex < MD5DIGESTLEN; dwIndex++ )
        {
            *pbBuf ^= MD5Context.digest[dwIndex];
            pbBuf++;
        }
    }

}


//
// ElGetHMACMD5Digest
//
// Description:
//
//      Given a secret, generate a MD5 digest
//
// Arguments:
//      pbBuf - pointer to data stream
//      dwBufLen - length of data stream
//      pbKey - pointer to authentication key
//      dwKeyLen - length of authentication key
//      pvDigest - caller digest to be filled in
//
// Return values:
//      None
//

VOID
ElGetHMACMD5Digest (
        IN      BYTE        *pbBuf,
        IN      DWORD       dwBufLen,
        IN      BYTE        *pbKey,
        IN      DWORD       dwKeyLen,
        IN OUT  VOID        *pvDigest
        )
{
        MD5_CTX         MD5context;
        UCHAR           k_ipad[65];	/* inner padding - key XORd with ipad */
        UCHAR           k_opad[65];  /* outer padding - key XORd with opad */
        UCHAR           tk[16];
        DWORD           dwIndex = 0;

        // if key is longer than 64 bytes reset it to key=MD5(key)
        if (dwKeyLen > 64)
        {
            MD5_CTX     tctx;

            MD5Init (&tctx);
            MD5Update (&tctx, pbKey, dwKeyLen);
            MD5Final (&tctx);
            memcpy (tk, tctx.digest, 16);
            pbKey = tk;
            dwKeyLen = 16;
        }
        
        //
        // the HMAC_MD5 transform looks like:
        //
        // MD5(K XOR opad, MD5(K XOR ipad, text))
        //
        // where K is an n byte key
        // ipad is the byte 0x36 repeated 64 times
        // opad is the byte 0x5c repeated 64 times
        // and text is the data being protected
        //

        // start out by storing key in pads
        ZeroMemory ( k_ipad, sizeof k_ipad);
        ZeroMemory ( k_opad, sizeof k_opad);
        memcpy ( k_ipad, pbKey, dwKeyLen);
        memcpy ( k_opad, pbKey, dwKeyLen);

        // XOR key with ipad and opad values
        for (dwIndex=0; dwIndex<64; dwIndex++) 
        {
            k_ipad[dwIndex] ^= 0x36;
            k_opad[dwIndex] ^= 0x5c;
        }

        //
        // perform inner MD5
        //

        // init context for 1st pass
        MD5Init(&MD5context);                   		
        // start with inner pad
        MD5Update(&MD5context, k_ipad, 64);
        // then text of datagram 
        MD5Update(&MD5context, pbBuf, dwBufLen); 	
        // finish up 1st pass
        MD5Final(&MD5context);
        memcpy (pvDigest, MD5context.digest, MD5DIGESTLEN);

        //
        // perform outer MD5
        //

        // init context for 2nd pass
        MD5Init(&MD5context);                   		
        // start with outer pad
        MD5Update(&MD5context, k_opad, 64);     	
        // then results of 1st hash
        MD5Update(&MD5context, pvDigest, 16);     	
        // finish up 2nd pass
        MD5Final(&MD5context);
        memcpy (pvDigest, MD5context.digest, MD5DIGESTLEN);
}


//
// ElWmiGetValue
//
// Description:
//
// Get a value for a GUID instance through WMI
//
// Arguments:
//      pGuid - Pointer to guid for which value is to be fetched
//      pszInstanceName - Friendly name for the interface
//      pbInputBuffer - Pointer to data
//      dwInputBufferSize - Size of data
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElWmiGetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  OUT BYTE    *pbOutputBuffer,
        IN  OUT DWORD   *pdwOutputBufferSize
        )
{
    WMIHANDLE               WmiHandle = NULL;
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   ulBufferSize = 0;
    WCHAR                   *pwszInstanceName = NULL;
    BYTE                    *pbLocalBuffer = NULL;
    DWORD                   dwLocalBufferSize = 0;
    LONG                    lStatus = ERROR_SUCCESS;

    do 
    {

        if ((pwszInstanceName = MALLOC ((strlen(pszInstanceName)+1) * sizeof (WCHAR))) == NULL)
        {
            TRACE2 (ANY, "ElWmiGetValue: MALLOC failed for pwszInstanceName, Friendlyname =%s, len= %ld",
                    pszInstanceName, strlen(pszInstanceName));
            lStatus = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pszInstanceName,
                    -1,
                    pwszInstanceName,
                    strlen(pszInstanceName)+1 ) )
        {
            lStatus = GetLastError();
    
            TRACE2 (ANY, "ElWmiGetValue: MultiByteToWideChar(%s) failed: %ld",
                    pszInstanceName, lStatus);
            break;
        }
        pwszInstanceName[strlen(pszInstanceName)] = L'\0';
    
        TRACE1 (ANY, "ElWmiGetValue: MultiByteToWideChar succeeded: %ws",
                pwszInstanceName);

        if ((lStatus = WmiOpenBlock (pGuid, 0, &WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiGetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
            break;
        }

        if ((lStatus = WmiQuerySingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                &dwLocalBufferSize,
                                                NULL)) != ERROR_SUCCESS)
        {

            if (lStatus == ERROR_INSUFFICIENT_BUFFER)
            {
                TRACE1 (ANY, "ElWmiGetValue: Size Required = %ld",
                        dwLocalBufferSize);

                if ((pbLocalBuffer = MALLOC (dwLocalBufferSize)) == NULL)
                {
                    TRACE0 (ANY, "ElWmiGetValue: MALLOC failed for pbLocalBuffer");
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if ((lStatus = WmiQuerySingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                &dwLocalBufferSize,
                                                pbLocalBuffer))
                                                    != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElWmiGetValue: WmiQuerySingleInstance failed with error %ld",
                        lStatus);
                    break;
                }

                pWnode = (PWNODE_SINGLE_INSTANCE)pbLocalBuffer;

                // If enough space in the output buffer, copy the data block
                if (*pdwOutputBufferSize >= pWnode->SizeDataBlock)
                {
                    memcpy (pbOutputBuffer, 
                            (PBYTE)((BYTE *)pWnode + pWnode->DataBlockOffset),
                            pWnode->SizeDataBlock
                            );
                }
                else
                {
                    lStatus = ERROR_INSUFFICIENT_BUFFER;
                    TRACE0 (ANY, "ElWmiGetValue: Not sufficient space to copy DataBlock");
                    *pdwOutputBufferSize = pWnode->SizeDataBlock;
                    break;
                }
                 
                *pdwOutputBufferSize = pWnode->SizeDataBlock;
        
                TRACE0 (ANY, "ElWmiGetValue: Got values from Wmi");
        
                TRACE1 (ANY, "SizeofDataBlock = %ld", pWnode->SizeDataBlock);
        
                EAPOL_DUMPBA (pbOutputBuffer, *pdwOutputBufferSize);
        
            }
            else
            {
                TRACE1 (ANY, "ElWmiGetValue: WmiQuerySingleInstance failed with error %ld",
                        lStatus);
                break;
            }

        }


        
    } while (FALSE);

    if (WmiHandle != NULL)
    {
        if ((lStatus = WmiCloseBlock (WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiGetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
        }
    }

    if (pbLocalBuffer != NULL)
    {
        FREE (pbLocalBuffer);
    }

    if (pwszInstanceName  != NULL)
    {
        FREE (pwszInstanceName);
    }

    return (DWORD)lStatus;

}


//
// ElWmiSetValue
//
// Description:
//
// Set a value for a GUID instance through WMI
//
// Arguments:
//      pGuid - Pointer to guid for which value is to be set
//      pszInstanceName - Friendly name for the interface
//      pbInputBuffer - Pointer to data
//      dwInputBufferSize - Size of data
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElWmiSetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  BYTE        *pbInputBuffer,
        IN  DWORD       dwInputBufferSize
        )
{
    WMIHANDLE               WmiHandle = NULL;
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   ulBufferSize = 0;
    WCHAR                   *pwszInstanceName = NULL;
    BYTE                    bBuffer[4096];

    LONG            lStatus = ERROR_SUCCESS;

    do 
    {

        if ((pwszInstanceName = MALLOC ((strlen(pszInstanceName)+1) * sizeof (WCHAR))) == NULL)
        {
            TRACE0 (ANY, "ElWmiSetValue: MALLOC failed for pwszInstanceName");
            lStatus = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pszInstanceName,
                    -1,
                    pwszInstanceName,
                    strlen(pszInstanceName)+1 ) )
        {
            lStatus = GetLastError();
    
            TRACE2 (ANY, "ElWmiSetValue: MultiByteToWideChar(%s) failed: %d",
                    pszInstanceName,
                    lStatus);
            break;
        }
        pwszInstanceName[strlen(pszInstanceName)] = L'\0';
    
        if ((lStatus = WmiOpenBlock (pGuid, 0, &WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
            break;
        }

        if ((lStatus = WmiSetSingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                1,
                                                dwInputBufferSize,
                                                pbInputBuffer)) 
                                                     != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiSetSingleInstance failed with error %ld",
                    lStatus);
            break;
        }

        TRACE0 (ANY, "ElWmiSetValue: Successful !!!");

    } while (FALSE);

    if (WmiHandle != NULL)
    {
        if ((lStatus = WmiCloseBlock (WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
        }
    }

    if (pwszInstanceName != NULL)
    {
        FREE (pwszInstanceName);
    }

    return (DWORD)lStatus;

}


//
// ElNdisuioSetOIDValue
//
// Description:
//
// Set a value for an OID for an interface using Ndisuio
//
// Arguments:
//      hInterface - Ndisuio handle to interface 
//      Oid - Oid for which value needs to be set
//      pbOidData - Pointer to Oid data 
//      ulOidDataLength - Oid data length
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElNdisuioSetOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       ulOidDataLength
        )
{
    PNDISUIO_SET_OID    pSetOid = NULL;
    DWORD               BytesReturned = 0;
    BOOLEAN             fSuccess = TRUE;
    DWORD               dwRetCode = NO_ERROR;


    do
    {
        pSetOid = (PNDISUIO_SET_OID) MALLOC (ulOidDataLength + sizeof(NDISUIO_SET_OID)); 

        if (pSetOid == NULL)
        {
            TRACE0 (ANY, "ElNdisuioSetOIDValue: MALLOC failed for pSetOid");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        pSetOid->Oid = Oid;
        memcpy(&pSetOid->Data[0], pbOidData, ulOidDataLength);

        fSuccess = (BOOLEAN) DeviceIoControl (
                                    hInterface, 
                                    IOCTL_NDISUIO_SET_OID_VALUE,
                                    (LPVOID)pSetOid,
                                    FIELD_OFFSET(NDISUIO_SET_OID, Data) + ulOidDataLength,
                                    (LPVOID)pSetOid,
                                    0,
                                    &BytesReturned,
                                    NULL);
        if (!fSuccess)
        {
            TRACE1 (ANY, "ElNdisuioSetOIDValue: DeviceIoControl failed with error %ld",
                    (dwRetCode = GetLastError()));
            break;
        }
        else
        {
            TRACE0 (ANY, "ElNdisuioSetOIDValue: DeviceIoControl succeeded");
        }

    }
    while (FALSE);

    if (pSetOid != NULL)
    {
        FREE (pSetOid);
    }

    return dwRetCode;
}


//
// ElNdisuioQueryOIDValue
//
// Description:
//
// Query the value for an OID for an interface using Ndisuio
//
// Arguments:
//      hInterface - Ndisuio handle to interface 
//      Oid - Oid for which value needs to be set
//      pbOidValue - Pointer to Oid value 
//      pulOidDataLength - Pointer to Oid data length
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElNdisuioQueryOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       *pulOidDataLength
        )
{
    PNDISUIO_QUERY_OID  pQueryOid = NULL;
    DWORD               BytesReturned = 0;
    BOOLEAN             fSuccess = TRUE;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        pQueryOid = (PNDISUIO_QUERY_OID) MALLOC (*pulOidDataLength + sizeof(NDISUIO_QUERY_OID)); 

        if (pQueryOid == NULL)
        {
            TRACE0 (ANY, "ElNdisuioQueryOIDValue: MALLOC failed for pQueryOid");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        pQueryOid->Oid = Oid;

        fSuccess = (BOOLEAN) DeviceIoControl (
                                    hInterface, 
                                    IOCTL_NDISUIO_QUERY_OID_VALUE,
                                    (LPVOID)pQueryOid,
                                    FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + *pulOidDataLength,
                                    (LPVOID)pQueryOid,
                                    FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + *pulOidDataLength,
                                    &BytesReturned,
                                    NULL);
        if (!fSuccess)
        {
            dwRetCode = GetLastError();
            TRACE2 (ANY, "ElNdisuioQueryOIDValue: DeviceIoControl failed with error %ld, BytesReturned = %ld",
                    dwRetCode, BytesReturned); 
            *pulOidDataLength = BytesReturned;
            break;
        }
        else
        {
            BytesReturned -= FIELD_OFFSET(NDISUIO_QUERY_OID, Data);

            if (BytesReturned > *pulOidDataLength)
            {
                BytesReturned = *pulOidDataLength;
            }
            else
            {
                *pulOidDataLength = BytesReturned;
            }

            memcpy(pbOidData, &pQueryOid->Data[0], BytesReturned);
            
        }
    }
    while (FALSE);

    if (pQueryOid != NULL)
    {
        FREE (pQueryOid);
    }

    return dwRetCode;
}


//
// ElGuidFromString
//
// Description:
//
// Convert a GUID-string to GUID
//
// Arguments:
//      pGuid - pointer to GUID
//      pwszGuidString - pointer to string version of GUID
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD 
ElGuidFromString (
        IN  OUT GUID        *pGuid,
        IN      WCHAR       *pwszGuidString
        )
{
    DWORD       dwGuidLen = 0;
    WCHAR       wszGuidString[64];
    LPWSTR      lpwszWithBraces = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

        if (pwszGuidString == NULL)
        {
            break;
        }

        ZeroMemory (pGuid, sizeof(GUID));

        if ((hr = CLSIDFromString (pwszGuidString, pGuid)) != NOERROR)
        {
            TRACE1 (ANY, "ElGuidFromString: CLSIDFromString failed with error %0lx",
                    hr);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
        }

    } while (FALSE);

    return dwRetCode;
}



//
// ElGetLoggedOnUserName
//
// Description:
//
// Get the Username and Domain of the currently logged in user
//
// Arguments:
//      hToken - User token
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElGetLoggedOnUserName (
        IN      HANDLE      hToken,
        OUT     PWCHAR      *ppwszActiveUserName
        )
{
    HANDLE              hUserToken; 
    WCHAR               *pwszUserNameBuffer = NULL;
    DWORD               dwBufferSize = 0;
    BOOL                fNeedToRevertToSelf = FALSE;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        hUserToken = hToken;

        if (hUserToken != NULL)
        {
            if (!ImpersonateLoggedOnUser (hUserToken))
            {
                dwRetCode = GetLastError();
                TRACE1 (USER, "ElGetLoggedOnUserName: ImpersonateLoggedOnUser failed with error %ld",
                        dwRetCode);
                break;
            }

            fNeedToRevertToSelf = TRUE;

            dwBufferSize = 0;
            if (!GetUserNameEx (NameSamCompatible,
                        NULL,
                        &dwBufferSize))
            {
                dwRetCode = GetLastError ();
                if (dwRetCode == ERROR_MORE_DATA)
                {
                    dwRetCode = NO_ERROR;
                    if ((pwszUserNameBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                    {
                        TRACE0 (ANY, "ElGetLoggedOnUserName: MALLOC failed for pwszUserNameBuffer");
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
    
                    if (!GetUserNameEx (NameSamCompatible,
                                            pwszUserNameBuffer,
                                            &dwBufferSize))
                    {
                        dwRetCode = GetLastError ();
                        TRACE1 (ANY, "ElGetLoggedOnUserName: GetUserNameEx failed with error %ld",
                                dwRetCode);
                        break;
                    }
    
                    TRACE1 (ANY, "ElGetLoggedOnUserName: Got User Name %ws",
                            pwszUserNameBuffer);
                }
                else
                {
                    TRACE1 (ANY, "ElGetLoggedOnUserName: GetUserNameEx failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
        }
        else
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            TRACE0 (ANY, "ElGetLoggedOnUserName: UserToken is NULL");
            break;
        }

    } while (FALSE);

    if (pwszUserNameBuffer != NULL)
    {
        *ppwszActiveUserName = pwszUserNameBuffer;
    }

    // Revert impersonation
            
    if (fNeedToRevertToSelf)
    {
        if (!RevertToSelf())
        {
            DWORD   dwRetCode1 = NO_ERROR;
            dwRetCode1 = GetLastError();
            TRACE1 (USER, "ElGetLoggedOnUserName: Error in RevertToSelf = %ld",
                    dwRetCode1);
            dwRetCode = ERROR_BAD_IMPERSONATION_LEVEL;
        }
    }

    return dwRetCode;
}


//
// ElGetMachineName
//
// Description:
//
// Get the machine name of the computer the service is currently running on
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which machine name is to
//              to be obtained
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElGetMachineName (
        IN      EAPOL_PCB       *pPCB
        )
{
    WCHAR               *pwszComputerNameBuffer = NULL;
    CHAR                *pszComputerNameBuffer = NULL;
    WCHAR               *pwszComputerDomainBuffer = NULL;
    CHAR                *pszComputerDomainBuffer = NULL;
    DWORD               dwBufferSize = 0;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        dwBufferSize = 0;
        if (!GetComputerNameEx (ComputerNamePhysicalNetBIOS,
                                    NULL,
                                    &dwBufferSize))
        {
            dwRetCode = GetLastError ();
            if (dwRetCode == ERROR_MORE_DATA)
            {
                // Reset error
                dwRetCode = NO_ERROR;
                if ((pwszComputerNameBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pwszComputerNameBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (!GetComputerNameEx (ComputerNamePhysicalNetBIOS,
                                        pwszComputerNameBuffer,
                                        &dwBufferSize))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                            dwRetCode);
                    break;
                }

                TRACE1 (ANY, "ElGetMachineName: Got Computer Name %ws",
                        pwszComputerNameBuffer);

                pszComputerNameBuffer = 
                    MALLOC (wcslen(pwszComputerNameBuffer) + 1);
                if (pszComputerNameBuffer == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pszComputerNameBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (0 == WideCharToMultiByte (
                            CP_ACP,
                            0,
                            pwszComputerNameBuffer,
                            -1,
                            pszComputerNameBuffer,
                            wcslen(pwszComputerNameBuffer)+1,
                            NULL, 
                            NULL ))
                {
                    dwRetCode = GetLastError();
         
                    TRACE2 (ANY, "ElGetMachineName: WideCharToMultiByte (%ws) failed: %ld",
                            pwszComputerNameBuffer, dwRetCode);
                    break;
                }

                pszComputerNameBuffer[wcslen(pwszComputerNameBuffer)] = L'\0';

            }
            else
            {
                TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        dwBufferSize = 0;
        if (!GetComputerNameEx (ComputerNamePhysicalDnsDomain,
                                    NULL,
                                    &dwBufferSize))
        {
            dwRetCode = GetLastError ();
            if (dwRetCode == ERROR_MORE_DATA)
            {
                // Reset error
                dwRetCode = NO_ERROR;
                if ((pwszComputerDomainBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pwszComputerDomainBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (!GetComputerNameEx (ComputerNamePhysicalDnsDomain,
                                        pwszComputerDomainBuffer,
                                        &dwBufferSize))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx Domain failed with error %ld",
                            dwRetCode);
                    break;
                }

                TRACE1 (ANY, "ElGetMachineName: Got Computer Domain %ws",
                        pwszComputerDomainBuffer);

                pszComputerDomainBuffer = 
                    MALLOC (wcslen(pwszComputerDomainBuffer) + 1);
                if (pszComputerDomainBuffer == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pszComputerDomainBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (0 == WideCharToMultiByte (
                            CP_ACP,
                            0,
                            pwszComputerDomainBuffer,
                            -1,
                            pszComputerDomainBuffer,
                            wcslen(pwszComputerDomainBuffer)+1,
                            NULL, 
                            NULL ))
                {
                    dwRetCode = GetLastError();
         
                    TRACE2 (ANY, "ElGetMachineName: WideCharToMultiByte (%ws) failed: %ld",
                            pwszComputerDomainBuffer, dwRetCode);
                    break;
                }

                pszComputerDomainBuffer[wcslen(pwszComputerDomainBuffer)] = L'\0';
                *(strrchr (pszComputerDomainBuffer, '.')) = '\0';

                if (pPCB->pszIdentity != NULL)
                {
                    FREE (pPCB->pszIdentity);
                    pPCB->pszIdentity = NULL;
                }

                pPCB->pszIdentity = MALLOC (strlen(pszComputerDomainBuffer) +
                        strlen(pszComputerNameBuffer) + 3);

                if (pPCB->pszIdentity == NULL)
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pPCB->pszIdentity");
                    break;
                }
                        
                memcpy (pPCB->pszIdentity, 
                        pszComputerDomainBuffer,
                        strlen(pszComputerDomainBuffer));
                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)] = '\\';
                memcpy (&pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1], 
                        pszComputerNameBuffer,
                        strlen(pszComputerNameBuffer));

                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1+strlen(pszComputerNameBuffer)] = '$';
                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1+strlen(pszComputerNameBuffer)+1] = '\0';

            }
            else
            {
                TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                        dwRetCode);
                break;
            }
        }

    } while (FALSE);


    if (pwszComputerNameBuffer != NULL)
    {
        FREE (pwszComputerNameBuffer);
    }

    if (pszComputerNameBuffer != NULL)
    {
        FREE (pszComputerNameBuffer);
    }

    if (pwszComputerDomainBuffer != NULL)
    {
        FREE (pwszComputerDomainBuffer);
    }

    if (pszComputerDomainBuffer != NULL)
    {
        FREE (pszComputerDomainBuffer);
    }

    return dwRetCode;

}


//
// ElUpdateRegistryInterfaceList
//
// Description:
//
// Write the interface list to which NDISUIO is bound to, to the registry
//
// Arguments:
//      Interfaces - Interface list containing Device Name and Description
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElUpdateRegistryInterfaceList (
        IN  PNDIS_ENUM_INTF     Interfaces
        )
{
    WCHAR       *pwszRegInterfaceList = NULL;
    HKEY        hkey = NULL;
    DWORD       dwDisposition = 0;
    LONG        lError = ERROR_SUCCESS;

    DWORD       dwRetCode = NO_ERROR;

    do 
    {
        ANSI_STRING		InterfaceName;
        UCHAR			ucBuffer[256];
        DWORD			i;
        DWORD           dwSizeOfList = 0;


        // Determine the number of bytes in the list
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                dwSizeOfList += wcslen(Interfaces->Interface[i].DeviceName.Buffer);
            }
            else
            {
                TRACE0 (ANY, "ElUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }
        }

        // One extra char for terminating NULL char
        pwszRegInterfaceList = 
            (WCHAR *) MALLOC ((dwSizeOfList + 1)*sizeof(WCHAR));

        if ( pwszRegInterfaceList == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElUpdateRegistryInterfaceList: MALLOC failed for pwszRegInterfaceList");
            break;
        }

        // Start again
        dwSizeOfList = 0;

        // Create the string in REG_SZ format
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                wcscat (pwszRegInterfaceList, 
                        Interfaces->Interface[i].DeviceName.Buffer);
                dwSizeOfList += 
                    (wcslen(Interfaces->Interface[i].DeviceName.Buffer));
            }
            else
            {
                TRACE0 (ANY, "ElUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }
        }

        // Final NULL character
        pwszRegInterfaceList[dwSizeOfList++] = L'\0';

        // Write the string as a REG_SZ value

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General

        if ((lError = RegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolServiceParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElUpdateRegistryInterfaceList: Error in RegCreateKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        //
        // Set the value of 
        // ...\EAPOL\Parameters\General\InterfaceList key
        //

        if ((lError = RegSetValueEx (
                        hkey,
                        cwszInterfaceList,
                        0,
                        REG_SZ,
                        (BYTE *)pwszRegInterfaceList,
                        dwSizeOfList*sizeof(WCHAR))) 
                != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElUpdateRegistryInterfaceList: Error in RegSetValueEx for InterfaceList, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }

    if (pwszRegInterfaceList != NULL)
    {
        FREE (pwszRegInterfaceList);
    }

    return dwRetCode;
}


//
// ElEnumAndUpdateRegistryInterfaceList
//
// Description:
//
// Enumerate the interface list to which NDISUIO is bound to.
// Write the interface list to the registry
//
// Arguments:
//      None
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElEnumAndUpdateRegistryInterfaceList (
        )
{
    CHAR                EnumerateBuffer[256];
    PNDIS_ENUM_INTF     Interfaces = NULL;
    BYTE                *pbNdisuioEnumBuffer = NULL;
    DWORD               dwNdisuioEnumBufferSize = 0;
    DWORD               dwAvailableInterfaces = 0;
    WCHAR               *pwszRegInterfaceList = NULL;
    HKEY                hkey = NULL;
    DWORD               dwDisposition = 0;
    ANSI_STRING         InterfaceName;
    UCHAR               ucBuffer[256];
    DWORD               i;
    DWORD               dwSizeOfList = 0;
    LONG                lError = ERROR_SUCCESS;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        ZeroMemory (EnumerateBuffer, 256);
        Interfaces = (PNDIS_ENUM_INTF)EnumerateBuffer;

        // Allocate amount of memory as instructed by NdisEnumerateInterfaces
        // once the API allows querying of bytes required
    
        if (!NdisEnumerateInterfaces(Interfaces, 256)) 
        {
            dwRetCode = GetLastError ();
            TRACE1 (ANY, "ElEnumAndUpdateRegistryInterfaceList: NdisEnumerateInterfaces failed with error %ld",
                    dwRetCode);
            break;
        }

        dwNdisuioEnumBufferSize = (Interfaces->BytesNeeded + 7) & 0xfffffff8;
        dwAvailableInterfaces = Interfaces->AvailableInterfaces;
    
        if (dwNdisuioEnumBufferSize == 0)
        {
            TRACE0 (ANY, "ElEnumAndUpdateRegistryInterfaceList: MALLOC skipped for pbNdisuioEnumBuffer as dwNdisuioEnumBufferSize == 0");
            dwRetCode = NO_ERROR;
            break;
        }

        pbNdisuioEnumBuffer = (BYTE *) MALLOC (4*dwNdisuioEnumBufferSize);

        if (pbNdisuioEnumBuffer == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElEnumAndUpdateRegistryInterfaceList: MALLOC failed for pbNdisuioEnumBuffer");
            break;
        }
        Interfaces = (PNDIS_ENUM_INTF)pbNdisuioEnumBuffer;

        // Enumerate all the interfaces present on the machine
        if ((dwRetCode = ElNdisuioEnumerateInterfaces (
                                Interfaces, 
                                dwAvailableInterfaces,
                                4*dwNdisuioEnumBufferSize)) != NO_ERROR)
        {
            TRACE1(ANY, "ElEnumAndUpdateRegistryInterfaceList: ElNdisuioEnumerateInterfaces failed with error %d", 
                dwRetCode);
            break;
        }

        // Update the interface list in the registry that NDISUIO has bound to.
        // The current interface list is just overwritten into the registry.

        // Determine the number of bytes in the list
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                dwSizeOfList += wcslen(Interfaces->Interface[i].DeviceName.Buffer);
            }
            else
            {
                TRACE0 (ANY, "ElEnumAndUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }
        }

        // One extra char for terminating NULL char
        pwszRegInterfaceList = 
            (WCHAR *) MALLOC ((dwSizeOfList + 1)*sizeof(WCHAR));

        if ( pwszRegInterfaceList == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElEnumAndUpdateRegistryInterfaceList: MALLOC failed for pwszRegInterfaceList");
            break;
        }

        // Start again
        dwSizeOfList = 0;

        // Create the string in REG_SZ format
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                wcscat (pwszRegInterfaceList, 
                        Interfaces->Interface[i].DeviceName.Buffer);
                dwSizeOfList += 
                    (wcslen(Interfaces->Interface[i].DeviceName.Buffer));
            }
            else
            {
                TRACE0 (ANY, "ElEnumAndUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }
        }

        // Final NULL character
        pwszRegInterfaceList[dwSizeOfList++] = L'\0';

        // Write the string as a REG_SZ value

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General

        if ((lError = RegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolServiceParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElEnumAndUpdateRegistryInterfaceList: Error in RegCreateKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        //
        // Set the value of 
        // ...\EAPOL\Parameters\General\InterfaceList key
        //

        if ((lError = RegSetValueEx (
                        hkey,
                        cwszInterfaceList,
                        0,
                        REG_SZ,
                        (BYTE *)pwszRegInterfaceList,
                        dwSizeOfList*sizeof(WCHAR))) 
                != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElEnumAndUpdateRegistryInterfaceList: Error in RegSetValueEx for InterfaceList, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

    } while (FALSE);

    if (pbNdisuioEnumBuffer != NULL)
    {
        FREE(pbNdisuioEnumBuffer);
    }
    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (pwszRegInterfaceList != NULL)
    {
        FREE (pwszRegInterfaceList);
    }

    return dwRetCode;
}


//
// ElReadGlobalRegistryParams
//
// Description:
//
// Read registry parameters global to EAPOL state machine
//  i.e. maxStart, startPeriod, authPeriod, heldPeriod
//
// Arguments:
//      Unused
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElReadGlobalRegistryParams ()
{
    HKEY        hKey = NULL;
    DWORD       dwDisposition = 0;
    DWORD       dwType = 0;
    DWORD       dwInfoSize = 0;
    DWORD       lError = 0;
    DWORD       dwmaxStart=0, dwstartPeriod=0, dwauthPeriod=0, dwheldPeriod=0;
    DWORD       dwSupplicantMode = EAPOL_DEFAULT_SUPPLICANT_MODE;
    DWORD       dwEAPOLAuthMode = EAPOL_DEFAULT_AUTH_MODE;
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General\Global

        if ((lError = RegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEAPOLGlobalParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            if (lError != ERROR_FILE_NOT_FOUND)
            {
                TRACE1 (ANY, "ElReadGlobalRegistryParams: Error in RegCreateKeyEx for base key, %ld",
                        lError);
            }
            break;
        }

        ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);

        // If setting values for the first time, initialize values

        if (!(g_dwmaxStart || g_dwstartPeriod || g_dwauthPeriod || g_dwheldPeriod || g_dwSupplicantMode))
        {
            g_dwmaxStart = EAPOL_MAX_START;
            g_dwstartPeriod = EAPOL_START_PERIOD;
            g_dwauthPeriod = EAPOL_AUTH_PERIOD;
            g_dwheldPeriod = EAPOL_HELD_PERIOD;
            g_dwSupplicantMode = EAPOL_DEFAULT_SUPPLICANT_MODE;
        }
            
        RELEASE_WRITE_LOCK (&g_EAPOLConfig);

        dwmaxStart = g_dwmaxStart;
        dwstartPeriod = g_dwstartPeriod;
        dwauthPeriod = g_dwauthPeriod;
        dwheldPeriod = g_dwheldPeriod;


        // Get the value of ..\General\EAPOLGlobal\authPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszAuthPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwauthPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            if (lError != ERROR_FILE_NOT_FOUND)
            {
                TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cszAuthPeriod, %ld, InfoSize=%ld",
                        lError, dwInfoSize);
            }
            dwauthPeriod = g_dwauthPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\heldPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszHeldPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwheldPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            if (lError != ERROR_FILE_NOT_FOUND)
            {
                TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cszHeldPeriod, %ld, InfoSize=%ld",
                        lError, dwInfoSize);
            }
            dwheldPeriod = g_dwheldPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\startPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszStartPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwstartPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            if (lError != ERROR_FILE_NOT_FOUND)
            {
                TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cszStartPeriod, %ld, InfoSize=%ld",
                        lError, dwInfoSize);
            }
            dwstartPeriod = g_dwstartPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\maxStart

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszMaxStart,
                        0,
                        &dwType,
                        (BYTE *)&dwmaxStart,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            if (lError != ERROR_FILE_NOT_FOUND)
            {
                TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cszMaxStart, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            }
            dwmaxStart = g_dwmaxStart;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\SupplicantMode

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszSupplicantMode,
                        0,
                        &dwType,
                        (BYTE *)&dwSupplicantMode,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cwszSupplicantMode, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwSupplicantMode = g_dwSupplicantMode;
            lError = ERROR_SUCCESS;
        }
        if (dwSupplicantMode > MAX_SUPPLICANT_MODE)
        {
            dwSupplicantMode = EAPOL_DEFAULT_SUPPLICANT_MODE;
        }
        g_dwSupplicantMode = dwSupplicantMode;

        // Get the value of ..\General\EAPOLGlobal\AuthMode

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueEx (
                        hKey,
                        cwszAuthMode,
                        0,
                        &dwType,
                        (BYTE *)&dwEAPOLAuthMode,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueEx for cwszAuthMode, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwEAPOLAuthMode = g_dwEAPOLAuthMode;
            lError = ERROR_SUCCESS;
        }
        if (dwEAPOLAuthMode > MAX_EAPOL_AUTH_MODE)
        {
            dwEAPOLAuthMode = EAPOL_DEFAULT_AUTH_MODE;
        }
        g_dwEAPOLAuthMode = dwEAPOLAuthMode;

        // Successful in reading all parameters
        
        ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);

        g_dwmaxStart = dwmaxStart;
        g_dwstartPeriod = dwstartPeriod;
        g_dwauthPeriod = dwauthPeriod;
        g_dwheldPeriod = dwheldPeriod;

        RELEASE_WRITE_LOCK (&g_EAPOLConfig);

    } while (FALSE);
    
    dwRetCode = (DWORD)lError;
    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (ANY, "ElReadGlobalRegistryParams: failed with error %ld",
            dwRetCode);
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return dwRetCode;

}


//
// ElPostEapConfigChanged
//
// Description:
//
// Watch the registry for changes in EAP config
//  - HKLM - EAP type
//  - HKLM - EAPOLEnabled
//
//  Restart the state machine if the params change
//
// Arguments:
//      pwszGuid - Interface GUID string
//
// Return values:
//      NO_ERROR - success
//      !NO_ERROR - error
//
//

DWORD 
ElPostEapConfigChanged (
        IN  WCHAR               *pwszGuid,
        IN  EAPOL_INTF_PARAMS   *pIntfParams   
        )
{
    DWORD   dwEventStatus = 0;
    BYTE    *pbData = NULL;
    BOOLEAN fDecrWorkerThreadCount = FALSE;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            dwRetCode = NO_ERROR;
            break;
        }
        if (( dwEventStatus = WaitForSingleObject (
                                    g_hEventTerminateEAPOL,
                                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            break;
        }
        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            break;
        }

        fDecrWorkerThreadCount = TRUE;
    
        InterlockedIncrement (&g_lWorkerThreads);

        pbData = (BYTE *) MALLOC ((((wcslen(pwszGuid)+1)*sizeof(WCHAR) + 7) & 0xfffffff8) + sizeof (EAPOL_INTF_PARAMS));
        if (pbData == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy ((WCHAR *)pbData, pwszGuid);
        memcpy (pbData + (((wcslen(pwszGuid)+1)*sizeof(WCHAR) + 7) & 0xfffffff8), (BYTE *)pIntfParams, sizeof(EAPOL_INTF_PARAMS));

        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)ElProcessEapConfigChange,
                    (PVOID)pbData,
                    WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElPostEapConfigChanged: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            fDecrWorkerThreadCount = FALSE;
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pbData != NULL)
        {
            FREE (pbData);
        }
    }

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    return dwRetCode;
}


//
// ElProcessEapConfigChange
//
// Description:
//
// Read EAP config changes made in registry. Restart EAPOL on the particular
// interface or stop EAPOL
//
// Arguments:
//      pvContext - GUID String
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
WINAPI
ElProcessEapConfigChange (
        IN  PVOID       pvContext
        )
{
    DWORD       dwEapFlags = 0;
    DWORD       dwEapTypeToBeUsed = 0;
    WCHAR       *pwszModifiedGUID = NULL;
    DWORD       dwSizeOfAuthData = 0;
    PBYTE       pbAuthData = NULL;
    EAPOL_PCB   *pPCB = NULL;
    BOOL        fReStartPort = FALSE;
    EAPOL_ZC_INTF   ZCData;
    EAPOL_INTF_PARAMS   EapolIntfParams, *pTmpIntfParams = NULL;
    BYTE        *pbModifiedSSID = NULL;
    DWORD       dwSizeOfModifiedSSID = 0;
    BOOLEAN     fPCBReferenced = FALSE;
    BOOLEAN     fPCBLocked = FALSE;
    LONG        lError = 0;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Get the GUID for the interface for which EAP config was modified
        pwszModifiedGUID = (WCHAR *)pvContext;
        pTmpIntfParams = (EAPOL_INTF_PARAMS *)((BYTE *)pvContext + (((wcslen(pwszModifiedGUID)+1)*sizeof(WCHAR) + 7 ) & 0xfffffff8));
        pbModifiedSSID = (BYTE *)(&pTmpIntfParams->bSSID[0]);
        dwSizeOfModifiedSSID = pTmpIntfParams->dwSizeOfSSID;

        // Get interface-wide parameters
        ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
        EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
        EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
        if ((dwRetCode = ElGetInterfaceParams (
                                pwszModifiedGUID,
                                &EapolIntfParams
                                )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_FILE_NOT_FOUND)
            {
                TRACE1 (PORT, "ElProcessEapConfigChange: ElGetInterfaceParams failed with error %ld",
                    dwRetCode);
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
        }
        dwEapTypeToBeUsed = EapolIntfParams.dwEapType;
        dwEapFlags = EapolIntfParams.dwEapFlags;

        // Check if PCB exists

        ACQUIRE_WRITE_LOCK (&(g_PCBLock));
        if ((pPCB = ElGetPCBPointerFromPortGUID (pwszModifiedGUID)) 
                != NULL)
        {
            EAPOL_REFERENCE_PORT (pPCB);
            fPCBReferenced = TRUE;
        }
        RELEASE_WRITE_LOCK (&(g_PCBLock));

        if (!fPCBReferenced)
        {
            if (IS_EAPOL_ENABLED(dwEapFlags))
            {
                TRACE0 (ANY, "ElProcessEapConfigChange: PCB not started, enabled, starting PCB");
                fReStartPort = TRUE;
            }
            else
            {
                TRACE0 (ANY, "ElProcessEapConfigChange: PCB not started, not enabled");
            }
            break;
        }
        else
        {
            if (!IS_EAPOL_ENABLED(dwEapFlags))
            {
                // Found PCB for interface, where EAPOLEnabled = 0
                // Stop EAPOL on the port and remove the port from the module

                TRACE0 (ANY, "ElProcessEapConfigChange: PCB ref'd, need to disable");
#if 0
                pPCB->dwFlags &= ~EAPOL_PORT_FLAG_ACTIVE;
                pPCB->dwFlags |= EAPOL_PORT_FLAG_DISABLED;
#endif

                fReStartPort = TRUE;

                if ((dwRetCode = ElShutdownInterface (pwszModifiedGUID)) != NO_ERROR)
                {
                    TRACE1 (ANY, "ElProcessEapConfigChange: ElShutdownInterface failed with error %ld",
                            dwRetCode);
                    break;
                }

                break;
            }
            else
            {
                TRACE0 (ANY, "ElProcessEapConfigChange: PCB ref and enabled, continue check");
            }
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
        fPCBLocked = TRUE;

        // If SSID changed != current SSID of PCB, do not worry 

        if (pPCB->pSSID != NULL)
        {
            if (dwSizeOfModifiedSSID != pPCB->pSSID->SsidLength)
            {
                TRACE0 (ANY, "ElProcessEapConfigChange: Set for different SSID, ignore");
                break;
            }
            else
            {
                if (memcmp (pPCB->pSSID->Ssid, pbModifiedSSID, pPCB->pSSID->SsidLength))
                {
                    TRACE0 (ANY, "ElProcessEapConfigChange: Same non-NULL length, diff SSID, ignoring");
                    break;
                }
            }
        }
        else
        {
            // No SSID on current PCB
            if (dwSizeOfModifiedSSID != 0)
            {
                // Only if default SSID, should we proceed for further checks
                if (dwSizeOfModifiedSSID == MAX_SSID_LEN)
                {
                    if (memcmp (pbModifiedSSID, g_bDefaultSSID, MAX_SSID_LEN))
                    {
                        TRACE0 (ANY, "ElProcessEapConfigChange: Modified SSID MAX_SSID_LEN, not default SSID");
                        break;
                    }
                }
                else
                {
                    TRACE0 (ANY, "ElProcessEapConfigChange: Modified SSID non-NULL, PCB SSID NULL");
                    break;
                }
            }
        }

        // Restart port for the following cases:
        // EAPOL_INTF_PARAMS for SSID changed 
        // CustomAuthData for default EAP type changed

        if ((dwEapFlags != pPCB->dwEapFlags) ||
                (dwEapTypeToBeUsed != pPCB->dwEapTypeToBeUsed))
        {
            TRACE0 (ANY, "ElProcessEapConfigChange: dwEapFlags != pPCB->dwEapFlags || dwEapTypeToBeUsed != pPCB->dwEapTypeToBeUsed");
            fReStartPort = TRUE;
            break;
        }

        // Get Custom auth data for the current default EAP Type

        // Get the size of the EAP blob
        if ((dwRetCode = ElGetCustomAuthData (
                        pwszModifiedGUID,
                        dwEapTypeToBeUsed,
                        dwSizeOfModifiedSSID,
                        pbModifiedSSID,
                        NULL,
                        &dwSizeOfAuthData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (dwSizeOfAuthData <= 0)
                {
                    // No EAP blob stored in the registry
                    pbAuthData = NULL;

                    if (pPCB->pCustomAuthConnData)
                    {
                        if (pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData > 0)
                        {
                            TRACE0 (ANY, "ElProcessEapConfigChange: Current customauthdata = 0; PCB != 0");
                            fReStartPort = TRUE;
                        }
                    }
                    dwRetCode = NO_ERROR;
                    break;
                }
                else
                {
                    pbAuthData = MALLOC (dwSizeOfAuthData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (ANY, "ElProcessEapConfigChange: MALLOC failed for pbAuthData");
                        break;
                    }
                    if ((dwRetCode = ElGetCustomAuthData (
                                pwszModifiedGUID,
                                dwEapTypeToBeUsed,
                                dwSizeOfModifiedSSID,
                                pbModifiedSSID,
                                pbAuthData,
                                &dwSizeOfAuthData
                                )) != NO_ERROR)
                    {
                        TRACE1 (ANY, "ElProcessEapConfigChange: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                dwRetCode = ERROR_CAN_NOT_COMPLETE;
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (ANY, "ElProcessEapConfigChange: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        if (pPCB->pCustomAuthConnData == NULL)
        {
            if (dwSizeOfAuthData > 0)
            {
                fReStartPort = TRUE;
                break;
            }
        }
        else
        {
            if (pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData
                    != dwSizeOfAuthData)
            {
                // Same EAP Type, but different lengths
                fReStartPort = TRUE;
                break;
            }
            else
            {
                if (memcmp (
                        pPCB->pCustomAuthConnData->pbCustomAuthData, 
                        pbAuthData, dwSizeOfAuthData) != 0)
                {
                    // Same EAP Type, same auth data length, but 
                    // different contents
                    fReStartPort = TRUE;
                    break;
                }
                else
                {
                    // No change in EAP config data for this 
                    // interface
                    TRACE0 (ANY, "ElProcessEapConfigChange: Same SSID, EAPType, CustomAuth, No content change");
                }
            }
        }
    } while (FALSE);

    if (fPCBLocked && fPCBReferenced && fReStartPort)
    {
        // Reset connection to go through full authentication
        if (pPCB->pSSID != NULL)
        {
            FREE (pPCB->pSSID);
            pPCB->pSSID = NULL;
        }
    }

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }

    if (fPCBReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }
    
    if (fReStartPort)
    {
#ifdef ZEROCONFIG_LINKED

        // Indicate hard-reset to WZC
        ZeroMemory ((PVOID)&ZCData, sizeof(EAPOL_ZC_INTF));
        ZCData.dwAuthFailCount = 0;
        ZCData.PreviousAuthenticationType = 0;
        if ((dwRetCode = ElZeroConfigNotify (
                        0,
                        WZCCMD_HARD_RESET,
                        pwszModifiedGUID,
                        &ZCData
                        )) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ElProcessEapConfigChange: ElZeroConfigNotify failed with error %ld",
                    dwRetCode);
            dwRetCode = NO_ERROR;
        }
#endif // ZEROCONFIG_LINKED

        DbLogPCBEvent (DBLOG_CATEG_INFO, NULL, EAPOL_PARAMS_CHANGE, pwszModifiedGUID);

        if ((dwRetCode = ElEnumAndOpenInterfaces (
                        NULL, pwszModifiedGUID, 0, NULL))
                != NO_ERROR)
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: ElEnumAndOpenInterfaces returned error %ld",
                    dwRetCode);
            dwRetCode = NO_ERROR;
        }
    }

    TRACE1 (ANY, "ElProcessEapConfigChange: Finished with error %ld",
            dwRetCode);

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    if (pbAuthData != NULL)
    {
        FREE (pbAuthData);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return 0;
}


//
// ElStringToGuid
//
// Description:
//
// Function to convert a Guid-String to a GUID
//
// Arguments:
//      psGuid  - String-ized Guid
//      pGuid   - Pointer to Guid
//
// Return values:
//  None
//

VOID
ElStringToGuid (
        IN  WCHAR       *pwsGuid,
        OUT LPGUID      pGuid      
        )
{
    WCHAR    wc;
    DWORD   i=0;

    //
    // If the first character is a '{', skip it.
    //

    if ( pwsGuid[0] == L'{' )
        pwsGuid++;


    //
    // Convert string to guid
    // (since pwsGuid may be used again below, no permanent modification to
    //  it may be made)
    //

    wc = pwsGuid[8];
    pwsGuid[8] = 0;
    pGuid->Data1 = wcstoul ( &pwsGuid[0], 0, 16 );
    pwsGuid[8] = wc;
    wc = pwsGuid[13];
    pwsGuid[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul ( &pwsGuid[9], 0, 16 );
    pwsGuid[13] = wc;
    wc = pwsGuid[18];
    pwsGuid[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul ( &pwsGuid[14], 0, 16 );
    pwsGuid[18] = wc;

    wc = pwsGuid[21];
    pwsGuid[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul ( &pwsGuid[19], 0, 16 );
    pwsGuid[21] = wc;
    wc = pwsGuid[23];
    pwsGuid[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul ( &pwsGuid[21], 0, 16 );
    pwsGuid[23] = wc;

    for ( i=0; i < 6; i++ )
    {
        wc = pwsGuid[26+i*2];
        pwsGuid[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul ( &pwsGuid[24+i*2], 0, 16 );
        pwsGuid[26+i*2] = wc;
    }

    return;
}


//
// ElGetIdentity
//
// Description:
//
// Get the identity depending on the authentication type being used
//
// Arguments:
//      pPCB - Pointer to PCB for the port
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElGetIdentity (
        IN  EAPOL_PCB   *pPCB
        )
{
    BOOLEAN     fUserLogonAllowed = FALSE;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
            switch (pPCB->dwEAPOLAuthMode)
            {
                case EAPOL_AUTH_MODE_0:
                    fUserLogonAllowed = TRUE;
                    break;
                case EAPOL_AUTH_MODE_1:
                    fUserLogonAllowed = TRUE;
                    break;
                case EAPOL_AUTH_MODE_2:
                    fUserLogonAllowed = FALSE;
                    break;
            }

            // Get user's identity if it has not been obtained till now
            if ((g_fUserLoggedOn) 
                    && (fUserLogonAllowed)
                    && (pPCB->PreviousAuthenticationType != EAPOL_MACHINE_AUTHENTICATION))
            {
                TRACE0 (ANY, "ElGetIdentity: Userlogged, Prev !Machine auth");
                if (!(pPCB->fGotUserIdentity))
                {
                    if (pPCB->dwAuthFailCount < EAPOL_MAX_AUTH_FAIL_COUNT)
                    {
                        pPCB->PreviousAuthenticationType = EAPOL_USER_AUTHENTICATION;
                        if (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)
                        {
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: MD5");
                            // EAP-MD5CHAP
                            if ((dwRetCode = ElGetUserNamePassword (
                                                pPCB)) != NO_ERROR)
                            {
                                TRACE1 (ANY, "ElGetIdentity: Error in ElGetUserNamePassword %ld",
                                        dwRetCode);
                            }
                        }
                        else
                        {
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: !MD5");
                            // All other EAP Types
                            if ((dwRetCode = ElGetUserIdentity (
                                                pPCB)) != NO_ERROR)
                            {
                                TRACE1 (ANY, "ElGetIdentity: Error in ElGetUserIdentity %ld",
                                        dwRetCode);
                            }
                        }

                        if ((dwRetCode == NO_ERROR) || (dwRetCode == ERROR_IO_PENDING))
                        {
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: No Error: User Auth fine");
                            break;
                        }
                        else
                        {
                            pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: ERROR");
                        
                        }
                    }
                    else
                    {
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, >Maxauth, Prev !Machine auth");
                        if (!IS_GUEST_AUTH_ENABLED(pPCB->dwEapFlags))
                        {
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, Prev !Machine auth:>MaxAuth: Guest disabled");
                            dwRetCode = ERROR_CAN_NOT_COMPLETE;
                            break;
                        }

                        if (pPCB->pszIdentity != NULL)
                        {
                            FREE (pPCB->pszIdentity);
                            pPCB->pszIdentity = NULL;
                        }
                        pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                        dwRetCode = NO_ERROR;
                         
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, Prev !Machine auth:>MaxAuth OR Error: Guest identity sent");

                    }
                }
                else
                {
                    TRACE0 (ANY, "ElGetIdentity: Already got identity");
                }
            }
            else
            {
                if (pPCB->hUserToken != NULL)
                {
                    CloseHandle (pPCB->hUserToken);
                    pPCB->hUserToken = NULL;
                }

                TRACE3 (ANY, "ElGetIdentity: Userlogged=%ld, AuthMode=%ld, Prev Machine auth?=%ld",
                        g_fUserLoggedOn?1:0, 
                        pPCB->dwEAPOLAuthMode,
                        (pPCB->PreviousAuthenticationType==EAPOL_MACHINE_AUTHENTICATION)?1:0 );

                // No UI required
                if ((pPCB->dwEapTypeToBeUsed != EAP_TYPE_MD5) &&
                        (IS_MACHINE_AUTH_ENABLED(pPCB->dwEapFlags)) &&
                        (pPCB->dwAuthFailCount < EAPOL_MAX_AUTH_FAIL_COUNT))
                {
                    TRACE0 (ANY, "ElGetIdentity: !MD5, <MaxAuth, Machine auth");

                    pPCB->PreviousAuthenticationType = EAPOL_MACHINE_AUTHENTICATION;
                    // Get Machine credentials
                    dwRetCode = ElGetUserIdentity (pPCB);

                    if (dwRetCode != NO_ERROR)
                    {
                        TRACE1 (ANY, "ElGetIdentity: ElGetUserIdentity, Machine auth, failed with error %ld",
                                dwRetCode);
                        pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                    }
                        
                    break;
                }

                if ((!IS_MACHINE_AUTH_ENABLED(pPCB->dwEapFlags)) ||
                    (pPCB->dwAuthFailCount >= EAPOL_MAX_AUTH_FAIL_COUNT) ||
                        (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5))
                {
                    TRACE5 (ANY, "ElGetIdentity: Error=%ld, Machine auth enabled=%ld, MD5=%ld, auth fail (%ld), max fail (%ld)",
                                    dwRetCode?1:0,
                                    IS_MACHINE_AUTH_ENABLED(pPCB->dwEapFlags)?1:0,
                                    (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)?1:0,
                                    pPCB->dwAuthFailCount,
                                    EAPOL_MAX_AUTH_FAIL_COUNT);
                    if (!IS_GUEST_AUTH_ENABLED (pPCB->dwEapFlags))
                    {
                        dwRetCode = ERROR_CAN_NOT_COMPLETE;
                        break;
                    }

                    if (pPCB->pszIdentity != NULL)
                    {
                        FREE (pPCB->pszIdentity);
                        pPCB->pszIdentity = NULL;
                    }

                    pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                    dwRetCode = NO_ERROR;

                    TRACE0 (ANY, "ElGetIdentity: machine auth, Guest identity sent");
                }
            }

    }
    while (FALSE);

    return dwRetCode;
}


//
// ElNLAConnectLPC
//
// Description: 
//
// Function called to connect to the LPC port for NLA service
//
// Arguments:
//      None
//
// Return values:
//      Non-NULL - valid handle
//      NULL - error
//

HANDLE
ElNLAConnectLPC () 
{

    HANDLE              h = NULL;
    LARGE_INTEGER       sectionSize;
    UNICODE_STRING      portName;
    SECURITY_QUALITY_OF_SERVICE dynamicQoS = 
    {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityAnonymous,
        SECURITY_DYNAMIC_TRACKING,
        FALSE
    };
    WSM_LPC_DATA        data;
    ULONG               dataLength;

    NTSTATUS            status = STATUS_SUCCESS;

    do 
    {
            
        TRACE0 (EAP, "NLAConnectLPC: Entered");

        // Create a shared section for passing the large-size LPC messages.
        RtlZeroMemory(&g_ClientView, sizeof(g_ClientView));
        g_ClientView.Length = sizeof(g_ClientView);
        g_ClientView.ViewSize = sizeof(LOCATION_802_1X);
        sectionSize.QuadPart = sizeof(LOCATION_802_1X);
    
        status = NtCreateSection (&g_ClientView.SectionHandle,
                                (SECTION_MAP_READ | SECTION_MAP_WRITE),
                                NULL,
                                &sectionSize,
                                PAGE_READWRITE,
                                SEC_COMMIT,
                                NULL
                                );
    
        if (!NT_SUCCESS(status))
        {
            h = NULL;
            TRACE1 (EAP, "NLAConnectLPC: NtCreateSection failed with error",
                    status);
            break;
        }
    
        // Connect via LPC to the Network Location Awareness (NLA) service.
        RtlInitUnicodeString (&portName, WSM_PRIVATE_PORT_NAME);
    
        RtlZeroMemory (&data, sizeof (data));
        data.signature = WSM_SIGNATURE;
        data.connect.version.major = WSM_VERSION_MAJOR;
        data.connect.version.minor = WSM_VERSION_MINOR;
    
        dataLength = sizeof (data);
    
        status = NtConnectPort (&h,
                            &portName,
                            &dynamicQoS,
                            &g_ClientView,
                            NULL,
                            NULL,
                            &data,
                            &dataLength
                            );
    
        // If NtConnectPort() succeeded, LPC will maintain a reference
        // to the section, otherwise we no longer need it.
    
        NtClose (g_ClientView.SectionHandle);
        g_ClientView.SectionHandle = NULL;
    
        if (!NT_SUCCESS(status)) {
            TRACE1 (EAP, "NLAConnectLPC: NtConnectPort failed with error %ld",
                    status);
        }

    } 
    while (FALSE);

    return (h);

} 


//
// ElNLACleanupLPC
//
// Description: 
//
// Function called to close the LPC port for NLA service
//
// Arguments:
//      None
//
// Return values:
//      None
//

VOID
ElNLACleanupLPC () 
{
    if (g_hNLA_LPC_Port != NULL) {
        NtClose (g_hNLA_LPC_Port);
        g_hNLA_LPC_Port = NULL;
    }
} 


//
// ElNLARegister_802_1X
//
// Description: 
//
// Function called to register 802.1X information with NLA
//
// Arguments:
//      plocation - Pointer to data needed to be registered with NLA
//
// Return values:
//      None
//

VOID
ElNLARegister_802_1X ( 
        IN  PLOCATION_802_1X    plocation 
        ) 
{

    WSM_LPC_MESSAGE     message;
    NTSTATUS            status;

    ACQUIRE_WRITE_LOCK (&g_NLALock); 

    do 
    {

        TRACE0 (EAP, "NLARegister_802_1X: Entered");

        // Connect to the Network Location Awareness (NLA) service if
        // necessary.

        if (g_hNLA_LPC_Port == NULL) {
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) {
                RELEASE_WRITE_LOCK (&g_NLALock);
                return;
            }
        }

        TRACE0 (EAP, "NLARegister_802_1X: g_hNLA_LPC_Port != NULL");

        // Send information to the NLA service.
        RtlZeroMemory (&message, sizeof (message));
        message.portMsg.u1.s1.TotalLength = sizeof (message);
        message.portMsg.u1.s1.DataLength = sizeof (message.data);
        message.data.signature = WSM_SIGNATURE;
        message.data.request.type = LOCATION_802_1X_REGISTER;
        __try {
            RtlCopyMemory (g_ClientView.ViewBase, 
                            plocation, sizeof(LOCATION_802_1X));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            RELEASE_WRITE_LOCK (&g_NLALock);
            return;
        }

        status = NtRequestWaitReplyPort ( g_hNLA_LPC_Port, (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);

        if (status != STATUS_SUCCESS) {
        
            TRACE1 (EAP, "NLARegister_802_1X: NtWaitReplyPort failed with error",
                    status);

            // It's possible the service was stopped and restarted.
            // Ditch the old LPC connection.
            CloseHandle (g_hNLA_LPC_Port);
        
            // Create a new LPC connection.
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) {
                RELEASE_WRITE_LOCK (&g_NLALock);
                TRACE0 (EAP, "NLARegister_802_1X: NLAConnectLPC failed");
                return;
            }

            // Try the send one last time.
            status = NtRequestWaitReplyPort (g_hNLA_LPC_Port, 
                            (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);
            TRACE1 (EAP, "NLARegister_802_1X: NtWaitReplyPort, try 2, failed with error",
                    status);

        }

        TRACE1 (EAP, "NLARegister_802_1X: Completed with status = %ld",
                status);

    }
    while (FALSE);
        
    RELEASE_WRITE_LOCK (&g_NLALock);

} 


//
// ElNLADelete_802_1X
//
// Description: 
//
// Function called to de-register 802.1X information registered with NLA
//
// Arguments:
//      plocation - Pointer to data to be de-registered from NLA
//
// Return values:
//      None
//

VOID
ElNLADelete_802_1X (
        IN  PLOCATION_802_1X    plocation
        ) 
{

    WSM_LPC_MESSAGE     message;
    NTSTATUS            status;

    ACQUIRE_WRITE_LOCK (&g_NLALock); 

    do 
    {

        // Connect to the NLA service if necessary.
        if (g_hNLA_LPC_Port == NULL) 
        {
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) 
            {
                RELEASE_WRITE_LOCK (&g_NLALock);
                return;
            }
        }

        // Send information to the NLA service.
        RtlZeroMemory (&message, sizeof(message));
        message.portMsg.u1.s1.TotalLength = sizeof (message);
        message.portMsg.u1.s1.DataLength = sizeof (message.data);
        message.data.signature = WSM_SIGNATURE;
        message.data.request.type = LOCATION_802_1X_DELETE;
        __try {
            RtlCopyMemory (g_ClientView.ViewBase, 
                    plocation, sizeof(plocation->adapterName));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            RELEASE_WRITE_LOCK (&g_NLALock);
            return;
        }

        status = NtRequestWaitReplyPort (g_hNLA_LPC_Port, 
                        (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);

        if (status != STATUS_SUCCESS) 
        {
            // If the service was stopped (and possibly restarted), we don't
            // care ... it won't have this information in its list for us
            // to bother deleting.
            CloseHandle (g_hNLA_LPC_Port);
            g_hNLA_LPC_Port = NULL;
        }

    }
    while (FALSE);

    RELEASE_WRITE_LOCK (&g_NLALock);

} 

//
// ElGetInterfaceNdisStatistics
//
// Function to query NDIS NIC_STATISTICS parameters for an interface
//
// Input arguments:
//  pszInterfaceName - Interface Name
//
// Return values:
//  pStats - NIC_STATISTICS structure 
//  
//

DWORD
ElGetInterfaceNdisStatistics (  
        IN      WCHAR           *pwszInterfaceName,
        IN OUT  NIC_STATISTICS  *pStats
        )
{
    WCHAR               *pwszDeviceInterfaceName = NULL;
    UNICODE_STRING      UInterfaceName;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        pwszDeviceInterfaceName = 
            MALLOC ((wcslen (pwszInterfaceName)+12)*sizeof(WCHAR));
        if (pwszDeviceInterfaceName == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElGetInterfaceNdisStatistics: MALLOC failed for pwszDeviceInterfaceName");
            break;
        }

        wcscpy (pwszDeviceInterfaceName, L"\\Device\\");
        wcscat (pwszDeviceInterfaceName, pwszInterfaceName);


        TRACE1 (ANY, "ElGetInterfaceNdisStatistics: pwszDeviceInterfaceName = (%ws)",
                pwszDeviceInterfaceName);

        RtlInitUnicodeString (&UInterfaceName, pwszDeviceInterfaceName);
    
        pStats->Size = sizeof(NIC_STATISTICS);
        if (NdisQueryStatistics (&UInterfaceName, pStats))
        {
        }
        else
        {
            dwRetCode = GetLastError ();
            TRACE2 (ANY, "ElGetInterfaceNdisStatistics: NdisQueryStatistics failed with error (%ld), Interface=(%ws)",
                    dwRetCode, UInterfaceName.Buffer);
        }
    }
    while (FALSE);

    if (pwszDeviceInterfaceName != NULL)
    {
        FREE (pwszDeviceInterfaceName);
    }

    return dwRetCode;
}


//
// ElCheckUserLoggedOn
//
// Function to query if interactive user has logged on prior to service start
//
// Input arguments:
//  None 
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCheckUserLoggedOn (  
        )
{
    BOOLEAN             fDecrWorkerThreadCount = TRUE;
    HANDLE              hUserToken = NULL;
	PWTS_SESSION_INFO   pSessionInfo = NULL;	
	WTS_SESSION_INFO    SessionInfo;	
	BOOL                fFoundActiveConsoleId = FALSE;
	DWORD               dwCount = 0;
	DWORD               dwSession;	
    PVOID               pvBuffer = NULL;
    DWORD               dwRetCode = NO_ERROR;

    InterlockedIncrement (&g_lWorkerThreads);

    do
    {
        TRACE1 (ANY, "ElCheckUserLoggedOn: ActiveConsoleId = (%ld)",
                USER_SHARED_DATA->ActiveConsoleId);

	    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwCount))
	    {
		    TRACE1 (ANY, "ElCheckUserLoggedOn: WTSEnumerateSessions, count = (%ld)",
                    dwCount);
    
		    for (dwSession = 0; dwSession < dwCount; dwSession++)
		    {	
			    SessionInfo = pSessionInfo[dwSession];
    
			    TRACE2 (ANY, "ElCheckUserLoggedOn: WTSEnumerateSessions: enumerating SessionId =(%ld), State =(%ld)",
                        SessionInfo.SessionId, SessionInfo.State);
		    	
                // Check if the user is active or connected
			    if ((SessionInfo.State != WTSActive) && (SessionInfo.State != WTSConnected))
			    {
				    continue;
			    }

                // Check if user has actually logged in
                if (ElGetWinStationUserToken (dwSession, &hUserToken) != NO_ERROR)
                {
                    continue;
                }

                if (dwSession == USER_SHARED_DATA->ActiveConsoleId)
                {
                    fFoundActiveConsoleId = TRUE;
                    g_dwCurrentSessionId = dwSession;
                    g_fUserLoggedOn = TRUE;
                    TRACE1 (ANY, "ElCheckUserLoggedOn: Session (%ld) is active console id",
                            dwSession);
                    break;
                }
                else
                {
                    if (hUserToken != NULL)
                    {
                        CloseHandle (hUserToken);
                        hUserToken = NULL;
                    }
                }
		    }		
		    WTSFreeMemory(pSessionInfo);
	    }
	    else
	    {
		    dwRetCode = GetLastError ();
		    if (dwRetCode == RPC_S_INVALID_BINDING) //Due to Terminal Services Disabled
		    {
                // Check if we can get user token for SessionId 0
                if (ElGetWinStationUserToken (0, &hUserToken) == NO_ERROR)
                {
                    fFoundActiveConsoleId = TRUE;
                    g_dwCurrentSessionId = 0;
                    g_fUserLoggedOn = TRUE;
                    TRACE0 (ANY, "ElCheckUserLoggedOn: Session 0 is active console id");
                }
		    }
		    else
		    {
			    TRACE1 (ANY, "ElCheckUserLoggedOn: WTSEnumerateSessions failed with error (%ld)", 
                        dwRetCode);
		    }		
	    }
    }
    while (FALSE);

    if (hUserToken != NULL)
    {
        CloseHandle (hUserToken);
    }

    if (dwRetCode != NO_ERROR)
    {
        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    return dwRetCode;
}


typedef HRESULT (APIENTRY *GETCLIENTADVISES)(LPWSTR**, LPDWORD);

//
// ElCheckUserModuleReady
//
// Function to query if interactive user context for current
// interactive session is ready to be notified
//
// Input arguments:
//  None 
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCheckUserModuleReady (  
        )
{
    HANDLE  hToken = NULL;
    WCHAR   *pwszActiveUserName = NULL;
    LPWSTR  *ppwszAdviseUsers = NULL;
    DWORD   dwCount = 0, dwIndex = 0;
    HMODULE hLib = NULL;
    PWCHAR  pwszNetmanDllExpandedPath = NULL;
    DWORD   cbSize = 0;
    GETCLIENTADVISES    pGetClientAdvises = NULL;
    HRESULT hr = S_OK;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        // Try only if user has logged on
        if (g_dwCurrentSessionId != 0xffffffff)
        {
            if ((dwRetCode = ElGetWinStationUserToken (g_dwCurrentSessionId, &hToken))
                    != NO_ERROR)
            {
                TRACE1 (NOTIFY, "ElCheckUserModuleReady: ElGetWinStationUserToken failed with error %ld",
                        dwRetCode);
                break;
            }
            
            if ((dwRetCode = ElGetLoggedOnUserName (hToken, &pwszActiveUserName))
                        != NO_ERROR)
            {
                TRACE1 (NOTIFY, "ElCheckUserModuleReady: ElGetLoggedOnUserName failed with error %ld",
                        dwRetCode);
                break;
            }

            // Replace the %SystemRoot% with the actual path.
            cbSize = ExpandEnvironmentStrings (NETMAN_DLL_PATH, NULL, 0);
            if (cbSize == 0)
            {
                dwRetCode = GetLastError();
                break;
            }
            pwszNetmanDllExpandedPath = (LPWSTR) MALLOC (cbSize*sizeof(WCHAR));
            if (pwszNetmanDllExpandedPath == (LPWSTR)NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            cbSize = ExpandEnvironmentStrings (NETMAN_DLL_PATH,
                                            pwszNetmanDllExpandedPath,
                                            cbSize);
            if (cbSize == 0)
            {
                dwRetCode = GetLastError();
                break;
            }

            hLib = LoadLibrary (pwszNetmanDllExpandedPath);
            if (hLib == NULL)
            {
                dwRetCode = GetLastError ();
                TRACE2 (NOTIFY, "ElCheckUserModuleReady: LoadLibrary for (%ws) failed with error %ld",
                        NETMAN_DLL_PATH, dwRetCode);
                break;
            }
                
            if ((pGetClientAdvises = (GETCLIENTADVISES)GetProcAddress (hLib, "GetClientAdvises")) == NULL)
            {
                dwRetCode = GetLastError ();
                TRACE1 (NOTIFY, "ElCheckUserModuleReady: GetProcAddress failed with error %ld",
                        dwRetCode);
                break;
            }

            hr = (* pGetClientAdvises) (&ppwszAdviseUsers, &dwCount);
            if (FAILED(hr))
            {
                TRACE1 (NOTIFY, "ElCheckUserModuleReady: GetClientAdvises failed with error %0lx",
                    hr);
                break;
            }

            for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
            {
                TRACE2 (NOTIFY, "ElCheckUserModuleReady: Advise[%ld] = %ws", dwIndex, ppwszAdviseUsers[dwIndex]);
                if (!wcscmp (ppwszAdviseUsers[dwIndex], pwszActiveUserName))
                {
                    TRACE1 (NOTIFY, "ElCheckUserModuleReady: Tray icon ready for username %ws", 
                            ppwszAdviseUsers[dwIndex]);
                    g_fTrayIconReady = TRUE;
                    break;
                }
            }

            if (!g_fTrayIconReady)
            {
                TRACE0 (NOTIFY, "ElCheckUserModuleReady: No appropriate advise found");
            }
        }
        else
        {
            TRACE0 (NOTIFY, "ElCheckUserModuleReady: No user logged on");
        }
    }
    while (FALSE);

    if (hToken != NULL)
    {
        CloseHandle (hToken);
    }

    if (hLib != NULL)
    {
        FreeLibrary (hLib);
    }

    if (pwszNetmanDllExpandedPath != NULL)
    {
        FREE (pwszNetmanDllExpandedPath);
    }

    if (pwszActiveUserName != NULL)
    {
        FREE (pwszActiveUserName);
        pwszActiveUserName = NULL;
    }

    if (ppwszAdviseUsers != NULL)
    {
        CoTaskMemFree (ppwszAdviseUsers);
    }

    return dwRetCode;
}


//
// ElGetWinStationUserToken
//
// Function to get the user token for specified session id
//
// Input arguments:
//      dwSessionId - Session Id
//      pUserToken - Pointer to user token
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD 
ElGetWinStationUserToken (
        IN  DWORD       dwSessionId,
        IN  OUT PHANDLE pUserToken
        )
{
	HANDLE  hUserToken          = NULL;
	HANDLE  hImpersonationToken = NULL;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
	    *pUserToken = NULL;
	    if (GetWinStationUserToken (dwSessionId, pUserToken))
	    {
		    // TRACE0 (ANY, "ElGetWinStationUserToken: GetWinStationUserToken successful");
	    }
	    else
	    {
		    dwRetCode = GetLastError();
    
		    TRACE2 (ANY, "ElGetWinStationUserToken: GetWinStationUserToken failed for SessionId (%ld) with error (%ld)",
                    dwSessionId, dwRetCode);
    
		    // if ((dwRetCode == RPC_S_INVALID_BINDING) && (dwSessionId == 0))
		    if (dwSessionId == 0)
		    {
                dwRetCode = NO_ERROR;
			    *pUserToken = NULL;
                hUserToken = GetCurrentUserTokenW (
                                    L"WinSta0", TOKEN_ALL_ACCESS);
                if (hUserToken == NULL) 				
                {									
                    dwRetCode = GetLastError();
                    TRACE1 (ANY, "ElGetWinStationUserToken: GetCurrentUserTokenW failed with error (%ld)",
                            dwRetCode);
                    break;
                }
                else
                {
                    if (!DuplicateTokenEx (hUserToken, 0, NULL, SecurityImpersonation, TokenImpersonation, &hImpersonationToken))
                    {
                        dwRetCode = GetLastError();
                        TRACE1 (ANY, "ElGetWinStationUserToken: DuplicateTokenEx for sessionid 0 failed with error (%ld)",
                                dwRetCode);
                        break;
                    }
                    *pUserToken = hImpersonationToken;

                    // TRACE0 (ANY, "ElGetWinStationUserToken: GetCurrentUserTokenW succeeded");
                }
		    }
		    else // (dwSessionId == 0)
		    {	
			    TRACE2 (ANY, "ElGetWinStationUserToken: GetWinStationUserToken failed for session= (%ld) with error= (%ld)", 
                        dwSessionId, dwRetCode);
            }
	    }

        if (pUserToken == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            TRACE0 (ANY, "ElGetWinStationUserToken: UserToken = NULL after fetching successfully\n");
            break;
        }
    }
    while (FALSE);

	return dwRetCode;
}

#ifdef  ZEROCONFIG_LINKED

//
// ElZeroConfigEvent
// 
// Description:
//
// Callback function called by Zero-Config on media events
//
// Arguments:
//      dwHandle - unique transaction id
//      pwzcDeviceNotif - media specific identifier
//      ndSSID - SSID of network currently associated to
//      prdUserData - 802.1X data stored with zero-config
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElZeroConfigEvent (
        IN      DWORD               dwHandle,
        IN      WCHAR               *pwszGuid,
        IN      NDIS_802_11_SSID    ndSSID,
        IN      PRAW_DATA           prdUserData
        )
{
    WCHAR   *pDummyPtr = NULL;
    WCHAR   cwsDummyBuffer[256];
    DWORD   dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
    DWORD   dwEapolEnabled = DEFAULT_EAPOL_STATE;
    EAPOL_ZC_INTF   ZCData, *pZCData = NULL;
    DWORD   dwEventStatus = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            break;
        }
        if (!(g_dwModulesStarted & ALL_MODULES_STARTED))
        {
            TRACE0 (DEVICE, "ElZeroConfigEvent: Received notification before module started");
            break;
        }
        if (( dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1 (ANY, "ElZeroConfigEvent: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            break;
        }
        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            TRACE0 (ANY, "ElZeroConfigEvent: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }

        // Verify if 802.1X can start on this interface

        ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
        if (prdUserData != NULL)
        {
            if ((prdUserData->dwDataLen >= sizeof (EAPOL_ZC_INTF))
                    && (prdUserData->pData != NULL))
            {
                // Extract information stored with Zero-Config
                pZCData = (EAPOL_ZC_INTF *)prdUserData->pData;
            }
        }
        memcpy (EapolIntfParams.bSSID, ndSSID.Ssid, ndSSID.SsidLength);
        EapolIntfParams.dwSizeOfSSID = ndSSID.SsidLength;
        EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
        if ((dwRetCode = ElGetInterfaceParams (
                                pwszGuid,
                                &EapolIntfParams
                                )) != NO_ERROR)
        {
            TRACE2 (DEVICE, "ElZeroConfigEvent: ElGetInterfaceParams failed with error %ld for interface %ws",
                    dwRetCode, pwszGuid);

            if (dwRetCode == ERROR_FILE_NOT_FOUND)
            {
                EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
                EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
            }
            else
            {
                break;
            }
        }

        // Start 802.1X state machine

        if ((dwRetCode = ElEnumAndOpenInterfaces (
                        0,
                        pwszGuid,
                        dwHandle,
                        prdUserData
                        )) != NO_ERROR)
        {
            TRACE1 (DEVICE, "ElZeroConfigEvent: ElEnumAndOpenInterfaces failed with error %ld",
                    dwRetCode);
            break;
        }

        if (!IS_EAPOL_ENABLED(EapolIntfParams.dwEapFlags))
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    }
    while (FALSE);

    // If not possible send RpcCmdInterface - WZCCMD_AUTH_DISABLED to
    // Zero Config

    if (dwRetCode != NO_ERROR)
    {
        ZeroMemory ((PVOID)&ZCData, sizeof(EAPOL_ZC_INTF));
        ElZeroConfigNotify (
                dwHandle,
                WZCCMD_CFG_NOOP,
                pwszGuid,
                &ZCData
                );
    }

    return dwRetCode;
}

//
// ElZeroConfigNotify
// 
// Description:
//
// Function called to notify Zero-Config about 802.1X events
//
// Arguments:
//      dwHandle - unique transaction id
//      dwCmdCode - 
//      pwszGuid - Interface GUID
//      pZCData - Data to be stored with ZC for next retry
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElZeroConfigNotify (
        IN      DWORD               dwHandle,
        IN      DWORD               dwCmdCode,
        IN      WCHAR               *pwszGuid,
        IN      EAPOL_ZC_INTF       *pZCData
        )
{
    RAW_DATA    rdUserData;
    DWORD       dwRetCode = NO_ERROR;

    TRACE3 (ANY, "ElZeroConfigNotify: Handle=(%ld), failcount=(%ld), lastauthtype=(%ld)",
            dwHandle, pZCData->dwAuthFailCount, pZCData->PreviousAuthenticationType);

    do
    {
        ZeroMemory ((PVOID)&rdUserData, sizeof (RAW_DATA));
        rdUserData.dwDataLen = sizeof (EAPOL_ZC_INTF);
        rdUserData.pData = MALLOC (rdUserData.dwDataLen);
        if (rdUserData.pData == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElZeroConfigNotify: MALLOC failed for rdUserData.pData");
            break;
        }

        memcpy (rdUserData.pData, (BYTE *)pZCData, sizeof (EAPOL_ZC_INTF));

        if ((dwRetCode = RpcCmdInterface (
                        dwHandle,
                        dwCmdCode,
                        pwszGuid,
                        &rdUserData
                        )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElZeroConfigNotify: RpcCmdInterface failed with error %ld", 
                    dwRetCode);
            break;
        }
    }
    while (FALSE);

    if (rdUserData.pData != NULL)
    {
        FREE (rdUserData.pData);
    }

    return dwRetCode;
}

#endif // ZEROCONFIG_LINKED


//
// ElNetmanNotify
// 
// Description:
//
// Function to update status and display balloon with netman
//
// Arguments:
//      pPCB - Pointer to PCB
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElNetmanNotify (
        IN  EAPOL_PCB           *pPCB,
        IN  EAPOL_NCS_STATUS    Status,
        IN  WCHAR               *pwszDisplayMessage
        )
{
    GUID    DeviceGuid;
    WCHAR   wcszDummy[]=L"EAPOL";
    WCHAR   * pwszBalloonMessage = NULL;
    BSTR    pwszDummy = NULL;
    NETCON_STATUS   ncsStatus = 0;
    EAPOL_EAP_UI_CONTEXT *pEAPUIContext = NULL;
    HRESULT hr = S_OK;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        ElStringToGuid (pPCB->pwszDeviceGUID, &DeviceGuid);

        if ((Status == EAPOL_NCS_NOTIFICATION) || 
                (Status == EAPOL_NCS_AUTHENTICATION_FAILED))
        {
            if (Status == EAPOL_NCS_NOTIFICATION)
            {
                pwszBalloonMessage = pPCB->pwszEapReplyMessage;
            }

            pEAPUIContext = MALLOC (sizeof(EAPOL_EAP_UI_CONTEXT));
            if (pEAPUIContext == NULL)
            {
                TRACE0 (USER, "ElNetmanNotify: MALLOC failed for pEAPUIContext");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (Status == EAPOL_NCS_NOTIFICATION)
            {
                pEAPUIContext->dwEAPOLUIMsgType = EAPOLUI_EAP_NOTIFICATION;
            }
            else
            {
                pEAPUIContext->dwEAPOLUIMsgType = EAPOLUI_CREATEBALLOON;
            }
            wcsncpy (pEAPUIContext->wszGUID, pPCB->pwszDeviceGUID, 
                    sizeof(pEAPUIContext->wszGUID));
            // Do not increment invocation id, since these are notification
            // balloons
            pEAPUIContext->dwSessionId = g_dwCurrentSessionId;
            pEAPUIContext->dwContextId = pPCB->dwUIInvocationId;
            pEAPUIContext->dwEapId = pPCB->bCurrentEAPId;
            pEAPUIContext->dwEapTypeId = pPCB->dwEapTypeToBeUsed;
            if (pPCB->pwszSSID)
            {
                wcscpy (pEAPUIContext->wszSSID, pPCB->pwszSSID);
            }
            if (pPCB->pSSID)
            {
                pEAPUIContext->dwSizeOfSSID = pPCB->pSSID->SsidLength;
                memcpy ((BYTE *)pEAPUIContext->bSSID, (BYTE *)pPCB->pSSID->Ssid,
                        NDIS_802_11_SSID_LEN-sizeof(ULONG));
            }

            // Post the message to netman

            if ((dwRetCode = ElPostShowBalloonMessage (
                            pPCB,
                            sizeof(EAPOL_EAP_UI_CONTEXT),
                            (BYTE *)pEAPUIContext,
                            pwszBalloonMessage?(wcslen(pwszBalloonMessage)*sizeof(WCHAR)):0,
                            pwszBalloonMessage
                            )) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: ElPostShowBalloonMessage failed with error %ld",
                        dwRetCode);
                break;
            }

        }

        hr = S_OK;

        if (Status != EAPOL_NCS_NOTIFICATION)
        {
            switch (pPCB->State)
            {
                case EAPOLSTATE_LOGOFF:
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_DISCONNECTED:
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_CONNECTING:
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_ACQUIRED:
                    ncsStatus = NCS_CREDENTIALS_REQUIRED;
                    break;
                case EAPOLSTATE_AUTHENTICATING:
                    ncsStatus = NCS_AUTHENTICATING;
                    break;
                case EAPOLSTATE_HELD:
                    ncsStatus = NCS_AUTHENTICATION_FAILED;
                    break;
                case EAPOLSTATE_AUTHENTICATED:
                    ncsStatus = NCS_AUTHENTICATION_SUCCEEDED;
                    break;
                default:
                    hr = S_FALSE;
                    break;
            }

            if (SUCCEEDED (hr))
            {
                hr = WZCNetmanConnectionStatusChanged (
                        &DeviceGuid, 
                        ncsStatus);
            }

            if (FAILED (hr))
            {
                dwRetCode = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
    }
    while (FALSE);

    if (pwszDummy != NULL)
    {
        SysFreeString (pwszDummy);
    }

    if (pEAPUIContext != NULL)
    {
        FREE (pEAPUIContext);
    }

    return dwRetCode;
}


//
// ElPostShowBalloonMessage
// 
// Description:
//
// Function to display balloon on tray icon
//
// Arguments:
//      pPCB - Pointer to PCB
//      cbCookieLen - Cookie Length
//      pbCookie - Pointer to cookie
//      cbMessageLen - Message Length
//      pbMessage - Pointer to message
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElPostShowBalloonMessage (
        IN  EAPOL_PCB           *pPCB,
        IN  DWORD               cbCookieLen,
        IN  BYTE                *pbCookie,
        IN  DWORD               cbMessageLen,
        IN  WCHAR               *pwszMessage
        )
{
    GUID    DeviceGuid;
    BSTR    pwszBalloonMessage = NULL;
    WCHAR   wcszDummy[] = L"Dummy";
    BSTR    pwszCookie = NULL;
    HRESULT hr = S_OK;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        ElStringToGuid (pPCB->pwszDeviceGUID, &DeviceGuid);

        pwszCookie = SysAllocStringByteLen (pbCookie, cbCookieLen);
        if (pwszCookie == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    
        if (cbMessageLen != 0)
        {
            pwszBalloonMessage = SysAllocString (pwszMessage);
        }
        else
        {
            pwszBalloonMessage = SysAllocString (wcszDummy);
        }
        if (pwszBalloonMessage == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hr = WZCNetmanShowBalloon (
                &DeviceGuid, 
                pwszCookie, 
                pwszBalloonMessage);

        if (FAILED (hr))
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    }
    while (FALSE);

    if (pwszBalloonMessage != NULL)
    {
        SysFreeString (pwszBalloonMessage);
    }

    if (pwszCookie != NULL)
    {
        SysFreeString (pwszCookie);
    }

    return dwRetCode;
}


//
// ElProcessReauthResponse
//
// Description:
//
// Function to handle UI response for initiating re-auth
// 
// Arguments:
//
// Return values:
//
//

DWORD
ElProcessReauthResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        )
{
    DWORD   dwRetCode = NO_ERROR;

    do
    {
    }
    while (FALSE);

    return dwRetCode;
}


//
// ElIPPnpWorker
//
// Description:
//
// Function to renew address on a particular interface
// 
// Arguments:
//      pvContext - GUID string for the intended interface
//
// Return values:
//
//

DWORD
WINAPI
ElIPPnPWorker (
        IN      PVOID       pvContext
        )
{
    DHCP_PNP_CHANGE     DhcpPnpChange;
    WCHAR               *pwszGUID = NULL;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        if (pvContext == NULL)
        {
            break;
        }

        pwszGUID = (WCHAR *)pvContext;

        // Call DHCP to do PnP
        ZeroMemory(&DhcpPnpChange, sizeof(DHCP_PNP_CHANGE));
        DhcpPnpChange.Version = DHCP_PNP_CHANGE_VERSION_0;
        if ((dwRetCode = DhcpHandlePnPEvent(
                    0, 
                    DHCP_CALLER_TCPUI, 
                    pwszGUID,
                    &DhcpPnpChange, 
                    NULL)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElIPPnPWorker: DHCPHandlePnPEvent returned error %ld",
                    dwRetCode);
            // Ignore DHCP error, it's outside 802.1X logic
            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE0 (EAPOL, "ElIPPnPWorker: DHCPHandlePnPEvent successful");
        }

        // Call IPv6 to renew this interface
        dwRetCode = Ip6RenewInterface(pwszGUID);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1(EAPOL, "ElIPPnPWorker: Ip6RenewInterface returned error %ld",
                   dwRetCode);
            // Failure not fatal!  Stack might be uninstalled.
            // Ignore IPv6 error, it's outside the 802.1x logic.
            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE0(EAPOL, "ElIPPnPWorker: Ip6RenewInterface successful");
        }
    }
    while (FALSE);

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return dwRetCode;
}


//
// ElUpdateRegistry
//
// Description:
//
// Function to modify keys left behind in earlier versions
// 
// Arguments:
//      None
//
// Return values:
//      NO_ERROR - success
//      !NO_ERROR - error
//

DWORD
ElUpdateRegistry (
        )
{
    DWORD dwRetCode = NO_ERROR;

    do
    {
        if ((dwRetCode = ElRegistryUpdateXPBeta2 ()) != NO_ERROR)
        {
            TRACE1 (ANY, "ElUpdateRegistry: ElRegistryUpdateXPBeta2 failed with error %ld",
                    dwRetCode);
            dwRetCode = NO_ERROR;
        }

        if ((dwRetCode = ElRegistryUpdateXPSP1 ()) != NO_ERROR)
        {
            TRACE1 (ANY, "ElUpdateRegistry: ElRegistryUpdateXPSP1 failed with error %ld",
                    dwRetCode);
            dwRetCode = NO_ERROR;
        }
    }
    while (FALSE);

    return dwRetCode;
}


//
// ElRegistryUpdateXPBeta2
//
// Description:
//
// Function to cleanup keys left behind prior 2 Beta2
// 
// Arguments:
//      None
//
// Return values:
//      NO_ERROR - success
//      !NO_ERROR - error
//

DWORD
ElRegistryUpdateXPBeta2 (
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwDisposition;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwNumSubKeys = 0, dwMaxSubKeyLen = 0;
    DWORD       dwMaxValueName = 0;
    DWORD       dwNumValues1 = 0, dwMaxValueNameLen1 = 0, dwMaxValueLen1 = 0;
    DWORD       dwNumSubKeys1 = 0, dwMaxSubKeyLen1 = 0;
    DWORD       dwMaxValueName1 = 0;
    LONG        lIndex = 0, lIndex1 = 0;
    BYTE        *pbKeyBuf = NULL;
    DWORD       dwKeyBufLen = 0;
    BYTE        *pbKeyBuf1 = NULL;
    DWORD       dwKeyBufLen1 = 0;
    WCHAR       *pwszValueName = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Delete keys in HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces 
        // with no "{"

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElRegistryUpdateXPBeta2: Error in RegOpenKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((lError = RegQueryInfoKey (
                        hkey,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumSubKeys,
                        &dwMaxSubKeyLen,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        dwMaxSubKeyLen++;
        if ((pbKeyBuf = MALLOC (dwMaxSubKeyLen*sizeof(WCHAR))) == NULL)
        {
            TRACE0 (ANY, "ElRegistryUpdateXPBeta2: MALLOC failed for dwMaxSubKeyLen");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (lIndex = (dwNumSubKeys-1); lIndex >= 0, dwNumSubKeys > 0; lIndex--)
        {
            dwKeyBufLen = dwMaxSubKeyLen;
            ZeroMemory (pbKeyBuf, dwMaxSubKeyLen*sizeof(WCHAR));
            if ((lError = RegEnumKey (
                            hkey,
                            lIndex,
                            (WCHAR *)pbKeyBuf,
                            dwKeyBufLen
                            )) != ERROR_SUCCESS)
            {
                TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegEnumValue failed with error %ld",
                        lError);
                break;
            }

            // If the first character in the key is not a '{' delete it

            if (wcsncmp ((WCHAR *)pbKeyBuf, L"{", 1))
            {
                if ((dwRetCode = SHDeleteKey (
                                hkey,
                                (WCHAR *)pbKeyBuf
                            )) != ERROR_SUCCESS)
                {
                    TRACE2 (ANY, "ElRegistryUpdateXPBeta2: RegDelete of (%ws) failed with error %ld",
                            (WCHAR *)pbKeyBuf, dwRetCode);
                    dwRetCode = ERROR_SUCCESS;
                }

                continue;
            }

            // This is a "{GUID}" type key
            // Delete all sub-keys under this

            if ((lError = RegOpenKeyEx (
                            hkey,
                            (WCHAR *)pbKeyBuf,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey1
                            )) != ERROR_SUCCESS)
            {
                TRACE1 (ANY, "ElRegistryUpdateXPBeta2: Error in RegOpenKeyEx for hkey1, %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }

            do 
            {

            if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumSubKeys1,
                        &dwMaxSubKeyLen1,
                        NULL,
                        &dwNumValues1,
                        &dwMaxValueNameLen1,
                        &dwMaxValueLen1,
                        NULL,
                        NULL
                    )) != NO_ERROR)
            {
                dwRetCode = (DWORD)lError;
                TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegQueryInfoKey failed with error %ld",
                        dwRetCode);
                break;
            }

            dwMaxSubKeyLen1++;
            if ((pbKeyBuf1 = MALLOC (dwMaxSubKeyLen1*sizeof(WCHAR))) == NULL)
            {
                TRACE0 (ANY, "ElRegistryUpdateXPBeta2: MALLOC failed for dwMaxSubKeyLen");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
    
            for (lIndex1 = (dwNumSubKeys1-1); lIndex1 >= 0, dwNumSubKeys1 > 0; lIndex1--)
            {
                dwKeyBufLen1 = dwMaxSubKeyLen1;
                ZeroMemory (pbKeyBuf1, dwMaxSubKeyLen1*sizeof(WCHAR));
                if ((lError = RegEnumKey (
                                hkey1,
                                lIndex1,
                                (WCHAR *)pbKeyBuf1,
                                dwKeyBufLen1
                                )) != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegEnumValue failed with error %ld",
                            lError);
                    break;
                }
    
                // Delete all sub-keys
    
                if ((dwRetCode = SHDeleteKey (
                                hkey1,
                                (WCHAR *)pbKeyBuf1
                            )) != ERROR_SUCCESS)
                {
                    TRACE2 (ANY, "ElRegistryUpdateXPBeta2: RegDelete of (%ws) failed with error %ld",
                            (WCHAR *)pbKeyBuf1, dwRetCode);
                    dwRetCode = ERROR_SUCCESS;
                }
            }
            if (pbKeyBuf1 != NULL)
            {
                FREE (pbKeyBuf1);
                pbKeyBuf1 = NULL;
            }
            if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
            {
                dwRetCode = (DWORD)lError;
                TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegEnumKey failed with error %ld",
                        dwRetCode);
                break;
            }
            else
            {
                lError = ERROR_SUCCESS;
            }

            // Delete all values with names "DefaultEapType", "EapolEnabled",
            // "LastModifiedSSID"

            dwMaxValueNameLen1++;
            if ((pwszValueName = MALLOC (dwMaxValueNameLen1*sizeof(WCHAR))) == NULL)
            {
                TRACE0 (ANY, "ElRegistryUpdateXPBeta2: MALLOC failed for pwszValueName");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
    
            for (lIndex1 = (dwNumValues1-1); lIndex1 >= 0, dwNumValues1 > 0; lIndex1--)
            {
                dwMaxValueNameLen = dwMaxValueNameLen1;
                ZeroMemory (pwszValueName, dwMaxValueNameLen1*sizeof(WCHAR));
                if ((lError = RegEnumValue (
                                hkey1,
                                lIndex1,
                                pwszValueName,
                                &dwMaxValueNameLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                )) != ERROR_SUCCESS)
                {
                    if (lError != ERROR_MORE_DATA)
                    {
                        break;
                    }
                    lError = ERROR_SUCCESS;
                }

                if ((!wcscmp (pwszValueName, cwszDefaultEAPType)) ||
                        (!wcscmp (pwszValueName, cwszEapolEnabled)) ||
                        (!wcscmp (pwszValueName, cwszLastUsedSSID)))
                {
                    if ((lError = RegDeleteValue (
                                    hkey1,
                                    pwszValueName
                                    )) != ERROR_SUCCESS)
                    {
                        TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegDeleteValue failed with error %ld",
                                lError);
                        lError = ERROR_SUCCESS;
                    }
                }
            }
            if (pwszValueName != NULL)
            {
                FREE (pwszValueName);
                pwszValueName = NULL;
            }
            if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
            {
                dwRetCode = (DWORD)lError;
                TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegEnumValue failed with error %ld",
                        dwRetCode);
                break;
            }
            else
            {
                lError = ERROR_SUCCESS;
            }

            }
            while (FALSE);

            if (hkey1 != NULL)
            {
                RegCloseKey (hkey1);
                hkey1 = NULL;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElRegistryUpdateXPBeta2: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbKeyBuf != NULL)
    {
        FREE (pbKeyBuf);
    }

    return dwRetCode;
}


BOOLEAN
IsSSIDPresentInWZCList (
        PEAPOL_INTF_PARAMS      pIntfParams,
        PWZC_802_11_CONFIG_LIST pwzcCfgList
        )
{
    DWORD   dwIndex = 0;
    BOOLEAN fFound = FALSE;
    
    do
    {
        for (dwIndex=0; dwIndex<pwzcCfgList->NumberOfItems; dwIndex++)
        {
            if (pwzcCfgList->Config[dwIndex].Ssid.SsidLength ==
                    pIntfParams->dwSizeOfSSID)
            {
                if (memcmp(pwzcCfgList->Config[dwIndex].Ssid.Ssid,
                            pIntfParams->bSSID,
                            pIntfParams->dwSizeOfSSID) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }
        }
    }
    while (FALSE);

    return fFound;
}


DWORD
ElWZCCfgChangeHandler (
        IN LPWSTR   pwszGUID,
        PWZC_802_11_CONFIG_LIST pwzcCfgList
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwMaxValueLen = 0;
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbValueBuf = NULL;
    LONG        lError = ERROR_SUCCESS;
    LONG        lIndex = 0;
    DWORD       dwValueData = 0;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    DWORD       dwTempValueNameLen = 0;
    BOOLEAN     fFreeWZCCfgList = FALSE;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Enumerate registry blobs

        if (pwzcCfgList == NULL)
        {
            // Create structure with zero items in list
            pwzcCfgList = (PWZC_802_11_CONFIG_LIST) MALLOC (sizeof(WZC_802_11_CONFIG_LIST));
            if (pwzcCfgList == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (ANY, "ElWZCCfgChangeHandler: pwzcCfgList = NULL");
                break;
            }
            else
            {
                fFreeWZCCfgList = TRUE;
            }
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWZCCfgChangeHandler: Error in RegOpenKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey,
                        pwszGUID,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWZCCfgChangeHandler: Error in RegOpenKeyEx for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((lError = RegQueryInfoKey (
                        hkey1,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElWZCCfgChangeHandler: RegQueryInfoKey failed with error %ld",
                    dwRetCode);
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElWZCCfgChangeHandler: MALLOC failed for pwszValueName");
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElWZCCfgChangeHandler: MALLOC failed for pbValueBuf");
            break;
        }

            
        for (lIndex = (dwNumValues-1); lIndex >= 0, dwNumValues > 0; lIndex--)
        {
            dwValueData = dwMaxValueLen;
            dwTempValueNameLen = dwMaxValueNameLen;
            if ((lError = RegEnumValue (
                            hkey1,
                            lIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                break;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                TRACE0 (ANY, "ElWZCCfgChangeHandler: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                lError = ERROR_INVALID_DATA;
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            // Ignore default setting since this is needed
            if ((memcmp (pRegParams->bSSID, g_bDefaultSSID, MAX_SSID_LEN)) == 0)
            {
                continue;
            }

            // If SSID corresponding to registry blob is not found in 
            // WZC list, delete it
            if (!IsSSIDPresentInWZCList (pRegParams,
                                        pwzcCfgList
                                        ))
            {
                // Delete Registry Value
                if ((lError = RegDeleteValue (
                                hkey1,
                                pwszValueName
                                )) != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElWZCCfgChangeHandler: RegDeleteValue failed with error (%ld)",
                            lError);
                    lError = ERROR_SUCCESS;
                }
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }
    }
    while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }
    if (fFreeWZCCfgList)
    {
        FREE (pwzcCfgList);
    }

    return dwRetCode;
}


//
// ElRegistryUpdateXPSP1
//
// Description:
//
// Function to modify 802.1X settings created prior to SP1. This will disable
// 802.1x on all existing configurations. 802.1x, if required, will have to 
// be enabled by the user on the existing connection.
// 
// Arguments:
//      None
//
// Return values:
//      NO_ERROR - success
//      !NO_ERROR - error
//

DWORD
ElRegistryUpdateXPSP1 (
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwNumValues=0, dwMaxValueNameLen=0, dwMaxValueLen=0;
    WCHAR       *pwszValueName=NULL;
    WCHAR       wszGUID[GUID_STRING_LEN_WITH_TERM];
    WCHAR       *pwszGUID = NULL;
    DWORD       dwSubKeys=0, dwSubKeyLen = 0;
    BYTE        *pbValueBuf = NULL;
    LONG        lError = ERROR_SUCCESS;
    LONG        lKey=0, lIndex=0;
    DWORD       dwValueData=0;
    EAPOL_INTF_PARAMS       *pRegParams = NULL;
    DWORD       dwTempValueNameLen=0;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Enumerate registry blobs

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces
        if ((lError = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cwszEapKeyEapolConn,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElRegistryUpdateXPSP1: Error in RegOpenKeyEx for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((lError = RegQueryInfoKey (
                        hkey,
                        NULL,
                        NULL,
                        NULL,
                        &dwSubKeys,
                        &dwSubKeyLen,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElRegistryUpdateXPSP1: RegQueryInfoKey hkey failed with error %ld",
                    dwRetCode);
            break;
        }

        for (lKey = (dwSubKeys-1); lKey >= 0, dwSubKeys > 0; lKey--)
        {
            ZeroMemory (&wszGUID[0], GUID_STRING_LEN_WITH_TERM*sizeof(WCHAR));
            pwszGUID = &wszGUID[0];
            dwSubKeyLen = GUID_STRING_LEN_WITH_TERM;
            if ((lError = RegEnumKeyEx (
                            hkey,
                            lKey,
                            pwszGUID,
                            &dwSubKeyLen,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            )) != ERROR_SUCCESS)
            {
                break;
            }

            if (dwSubKeyLen < (GUID_STRING_LEN_WITH_TERM - 1))
            {
                TRACE0 (ANY, "ElRegistryUpdateXPSP1: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                lError = ERROR_INVALID_DATA;
                break;
            }
            if (hkey1)
            {
                RegCloseKey (hkey1);
                hkey1 = NULL;
            }

            // Get handle to HKLM\Software\...\Interfaces\<GUID>

            if ((lError = RegOpenKeyEx (
                            hkey,
                            pwszGUID,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey1
                            )) != ERROR_SUCCESS)
            {
                TRACE1 (ANY, "ElRegistryUpdateXPSP1: Error in RegOpenKeyEx for GUID, %ld",
                        lError);
                break;
            }

            dwNumValues = 0;
            dwMaxValueNameLen = 0;
            if ((lError = RegQueryInfoKey (
                            hkey1,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumValues,
                            &dwMaxValueNameLen,
                            &dwMaxValueLen,
                            NULL,
                            NULL
                    )) != NO_ERROR)
            {
                TRACE1 (ANY, "ElRegistryUpdateXPSP1: RegQueryInfoKey failed with error %ld",
                        lError);
                break;
            }

            if (pwszValueName)
            {
                FREE (pwszValueName);
                pwszValueName = NULL;
            }
            if (pbValueBuf)
            {
                FREE (pbValueBuf);
                pbValueBuf = NULL;
            }
    
            if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
            {
                lError = dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (ANY, "ElRegistryUpdateXPSP1: MALLOC failed for pwszValueName");
                break;
            }
            dwMaxValueNameLen++;
            if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
            {
                lError = dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (ANY, "ElRegistryUpdateXPSP1: MALLOC failed for pbValueBuf");
                break;
            }
    
             
            for (lIndex = (dwNumValues-1); lIndex >= 0, dwNumValues > 0; lIndex--)
            {
                dwValueData = dwMaxValueLen;
                dwTempValueNameLen = dwMaxValueNameLen;
                if ((lError = RegEnumValue (
                                hkey1,
                                lIndex,
                                pwszValueName,
                                &dwTempValueNameLen,
                                NULL,
                                NULL,
                                pbValueBuf,
                                &dwValueData
                                )) != ERROR_SUCCESS)
                {
                    break;
                }
    
                if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
                {
                    TRACE0 (ANY, "ElRegistryUpdateXPSP1: dwValueData < sizeof (EAPOL_INTF_PARAMS)");
                    lError = ERROR_INVALID_DATA;
                    break;
                }
                pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;
    
                if (pRegParams->dwVersion != EAPOL_CURRENT_VERSION)
                {
                    pRegParams->dwVersion = EAPOL_CURRENT_VERSION;
    
                    if ((dwRetCode = ElSetInterfaceParams (
                                            pwszGUID,
                                            pRegParams
                                            )) != NO_ERROR)
                    {
                        TRACE1 (PORT, "ElRegistryUpdateXPSP1: ElSetInterfaceParams failed with error %ld, continuing",
                            dwRetCode);
                        dwRetCode = NO_ERROR;
                    }
                }
            }
            if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
            {
                TRACE1 (ANY, "ElRegistryUpdateXPSP1: RegEnumValue hkey1 failed with error (%ld)",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
            else
            {
                lError = ERROR_SUCCESS;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }
    }
    while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eldeviceio.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eldeviceio.c

Abstract:

    This module contains implementations for media-management and device I/O.
    The routines declared here operate asynchronously on the handles 
    associated with an I/O completion port opened on the ndis uio driver. 

Revision History:

    sachins, Apr 23 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

// NDISUIO constants

CHAR            NdisuioDevice[] = "\\\\.\\\\Ndisuio";
CHAR *          pNdisuioDevice = &NdisuioDevice[0];
WCHAR           cwszNDISUIOProtocolName[] = L"NDISUIO";
WORD            g_wEtherType8021X= 0x8E88;


//
// ElMediaInit
// 
// Description:
//
// Called on EAPOL service startup to initialize all the media related events 
// and callback functions
// 
//
// Arguments:
//
// Return Values:
//

DWORD
ElMediaInit (
        )
{
    DWORD       dwIndex = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (INIT, "ElMediaInit: Entered");

    do 
    {
        // Create Global Interface lock
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_ITFLock), "ITF") != NO_ERROR)
        {
            TRACE1(EAPOL, "ElMediaInit: Error (%ld) in creating g_ITFLock read-write-lock", dwRetCode);
            break;
        }
        // Initialize NLA locks
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_NLALock), "NLA") != NO_ERROR)
        {
            TRACE1(EAPOL, "ElMediaInit: Error (%ld) in creating g_NLALock read-write-lock", dwRetCode);
            break;
        }

        // Initialize EAPOL structures

        if ((dwRetCode = ElInitializeEAPOL()) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElInitializeEAPOL failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            // TRACE0(INIT, "ElMediaInit: ElInitializeEAPOL successful");
            g_dwModulesStarted |= EAPOL_MODULE_STARTED;
        }
    
        // Initialize interface hash bucket table
    
        g_ITFTable.pITFBuckets = (ITF_BUCKET *) MALLOC (INTF_TABLE_BUCKETS * sizeof (ITF_BUCKET));
    
        if (g_ITFTable.pITFBuckets == NULL)
        {
            TRACE0 (DEVICE, "Error in allocation memory for ITF buckets");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    
        for (dwIndex=0; dwIndex < INTF_TABLE_BUCKETS; dwIndex++)
        {
            g_ITFTable.pITFBuckets[dwIndex].pItf=NULL;
        }
    
        // Indicate logon/logoff notifications can be accepted
        g_dwModulesStarted |= LOGON_MODULE_STARTED;

        // Check if service was delayed in starting, start user logon

        ElCheckUserLoggedOn ();

        // Check if the user-context process is ready to be notified

        if ((dwRetCode = ElCheckUserModuleReady ()) == ERROR_BAD_IMPERSONATION_LEVEL)
        {
            break;
        }

        // Enumerate all the interfaces and start EAPOL state machine
        // on interfaces which are of LAN type

        if ((dwRetCode = ElEnumAndOpenInterfaces (NULL, NULL, 0, NULL)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElEnumAndOpenInterfaces failed with dwRetCode = %d", 
                    dwRetCode );
                    
            break;
        }
        else
        {
            // TRACE0(INIT, "ElMediaInit: ElEnumAndOpenInterfaces successful");
        }
        
#ifndef ZEROCONFIG_LINKED

        // Register for Media Sense detection of MEDIA_CONNECT and 
        // MEDIA_DISCONNECT of interfaces
    
        if ((dwRetCode = ElMediaSenseRegister (TRUE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElMediaSenseRegister failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            g_dwModulesStarted |= WMI_MODULE_STARTED;
            // TRACE0(INIT, "ElMediaInit: ElMediaSenseRegister successful");
        }

        // Register for detecting protocol BIND and UNBIND
    
        if ((dwRetCode = ElBindingsNotificationRegister (TRUE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElBindingsNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            g_dwModulesStarted |= BINDINGS_MODULE_STARTED;
            // TRACE0(INIT, "ElMediaInit: ElBindingsNotificationRegister successful");
        }

        // Register for device notifications. We are interested in LAN 
        // interfaces coming and going. 

        if ((dwRetCode = ElDeviceNotificationRegister (TRUE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElDeviceNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            g_dwModulesStarted |= DEVICE_NOTIF_STARTED;
            // TRACE0(INIT, "ElMediaInit: ElDeviceNotificationRegister successful");
        }

#endif // ZEROCONFIG_LINKED


    } while (FALSE);
        
    if (dwRetCode == NO_ERROR)
    {
        TRACE0(INIT, "ElMediaInit successful");
    }
    else
    {
        TRACE1(INIT, "ElMediaInit failed with error %ld",
                dwRetCode);
    }

    return dwRetCode;
}

    
//
// ElMediaDeInit
// 
// Description:
//
// Called on EAPOL service shutdown to de-initialize all the media 
// related events and callback functions
// 
//
// Arguments:
//
// Return Values:
//

DWORD
ElMediaDeInit (
        )
{
    LONG        lLocalWorkerThreads = 0;
    DWORD       dwIndex = 0;
    EAPOL_ITF   *pITFWalker = NULL, *pITF = NULL;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (INIT, "ElMediaDeInit: Entered");
 
    // Indicate logon/logoff notifications will not be accepted anymore
    g_dwModulesStarted &= ~LOGON_MODULE_STARTED;

#ifndef ZEROCONFIG_LINKED

    // DeRegister Media Sense detection of MEDIA_CONNECT and MEDIA_DISCONNECT
    // of interfaces

    if (g_dwModulesStarted & WMI_MODULE_STARTED)
    {
        if ((dwRetCode = ElMediaSenseRegister (FALSE)) != NO_ERROR )
        {
            TRACE1(INIT, "ElMediaDeInit: ElMediaSenseRegister failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            // TRACE0(INIT, "ElMediaDeInit: ElMediaSenseRegister successful");
        }
            
        g_dwModulesStarted &= ~WMI_MODULE_STARTED;
    }

    // Deregister detecting protocol BIND and UNBIND

    if (g_dwModulesStarted & BINDINGS_MODULE_STARTED)
    {
    
        if ((dwRetCode = ElBindingsNotificationRegister (FALSE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaDeInit: ElBindingsNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            g_dwModulesStarted &= ~BINDINGS_MODULE_STARTED;
            // TRACE0(INIT, "ElMediaDeInit: ElBindingsNotificationRegister successful");
        }
    }

    // Deregister device notifications that may have been posted

    if (g_dwModulesStarted & DEVICE_NOTIF_STARTED)
    {
        if ((dwRetCode = ElDeviceNotificationRegister (FALSE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaDeInit: ElDeviceNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            // TRACE0(INIT, "ElMediaDeInit: ElDeviceNotificationRegister successful");
        }

        g_dwModulesStarted &= ~DEVICE_NOTIF_STARTED;
    }

#endif // ZEROCONFIG_LINKED

    // Wait for all the related threads to die
    // viz. MediaSense, BindingsNotification, DeviceNotification,
    // Registry-watch for EAP-configuration change,
    // Registry-watch for EAPOL-parameter change

    do
    {
        lLocalWorkerThreads = 0;

        lLocalWorkerThreads = InterlockedCompareExchange (
                                    &g_lWorkerThreads,
                                    0,
                                    0);
        if (lLocalWorkerThreads == 0)
        {
            TRACE0 (INIT, "ElMediaDeInit: No worker threads alive, exiting");
            TRACE2 (INIT, "ElMediaDeInit: (%ld) - (%ld) worker threads still alive", 
                lLocalWorkerThreads, g_lWorkerThreads);
            break;
        }
        TRACE2 (INIT, "ElMediaDeInit: (%ld) - (%ld) worker threads still alive, sleeping zzz... ", 
                lLocalWorkerThreads, g_lWorkerThreads);
        Sleep (1000);
    }
    while (TRUE);

    // Shutdown EAPOL state machine
            
    if (g_dwModulesStarted & EAPOL_MODULE_STARTED)
    {
        if ((dwRetCode = ElEAPOLDeInit()) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaDeInit: ElEAPOLDeInit failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            TRACE0(INIT, "ElMediaDeInit: ElEAPOLDeInit successful");
        }

        g_dwModulesStarted &= ~EAPOL_MODULE_STARTED;
    }


    // Free the interface table

    if (READ_WRITE_LOCK_CREATED(&(g_ITFLock)))
    {
        ACQUIRE_WRITE_LOCK (&(g_ITFLock));

        if (g_ITFTable.pITFBuckets != NULL)
        {

            for (dwIndex = 0; dwIndex < INTF_TABLE_BUCKETS; dwIndex++)
            {
                for (pITFWalker = g_ITFTable.pITFBuckets[dwIndex].pItf;
                    pITFWalker != NULL;
                    /* NOTHING */
                    )
                {
                    pITF = pITFWalker;
                    pITFWalker = pITFWalker->pNext;
    
                    if (pITF->pwszInterfaceDesc)
                    {
                        FREE (pITF->pwszInterfaceDesc);
                    }
                    if (pITF->pwszInterfaceGUID)
                    {
                        FREE (pITF->pwszInterfaceGUID);
                    }
                    if (pITF)
                    {
                        FREE (pITF);
                    }
                }
            }

            FREE(g_ITFTable.pITFBuckets);
        }

        ZeroMemory (&g_ITFTable, sizeof (g_ITFTable));

        RELEASE_WRITE_LOCK (&(g_ITFLock));
    
        // Delete ITF table lock

        DELETE_READ_WRITE_LOCK(&(g_ITFLock));

    }
    
    if (READ_WRITE_LOCK_CREATED(&(g_NLALock)))
    {
        // Delete NLA lock

        DELETE_READ_WRITE_LOCK(&(g_NLALock));
    }

    TRACE0(INIT, "ElMediaDeInit completed");

    return dwRetCode;
}

#ifdef  ZEROCONFIG_LINKED

//
// ElMediaEventsHandler
//
// Description:
//
// Function called by WZC Service to signal various media events
//
// Arguments: 
//      pwzcDeviceNotif - Pointer to WZC_DEVICE_NOTIF structure
// 
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElMediaEventsHandler (
        IN  PWZC_DEVICE_NOTIF   pwzcDeviceNotif
        )
{
    DWORD   dwDummyValue = NO_ERROR;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        TRACE0 (DEVICE, "ElMediaEventsHandler entered");

        if (pwzcDeviceNotif == NULL)
        {
            break;
        }

        switch (pwzcDeviceNotif->dwEventType)
        {
            case WZCNOTIF_DEVICE_ARRIVAL:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElDeviceNotificationHandler ");
                ElDeviceNotificationHandler (
                        (VOID *)&(pwzcDeviceNotif->dbDeviceIntf),
                        DBT_DEVICEARRIVAL
                        );
                break;

            case WZCNOTIF_DEVICE_REMOVAL:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElDeviceNotificationHandler ");
                ElDeviceNotificationHandler (
                        (VOID *)&(pwzcDeviceNotif->dbDeviceIntf),
                        DBT_DEVICEREMOVECOMPLETE
                        );
                break;

            case WZCNOTIF_ADAPTER_BIND:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElBindingsNotificationCallback ");
                ElBindingsNotificationCallback (
                        &(pwzcDeviceNotif->wmiNodeHdr),
                        0
                        );
                break;

            case WZCNOTIF_ADAPTER_UNBIND:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElBindingsNotificationCallback ");
                ElBindingsNotificationCallback (
                        &(pwzcDeviceNotif->wmiNodeHdr),
                        0
                        );
                break;
            case WZCNOTIF_MEDIA_CONNECT:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElMediaSenseCallback ");
                ElMediaSenseCallback (
                        &(pwzcDeviceNotif->wmiNodeHdr),
                        0
                        );
                break;

            case WZCNOTIF_MEDIA_DISCONNECT:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElMediaSenseCallback ");
                ElMediaSenseCallback (
                        &(pwzcDeviceNotif->wmiNodeHdr),
                        0
                        );
                break;

            case WZCNOTIF_WZC_CONNECT:
                TRACE0 (DEVICE, "ElMediaEventsHandler: Calling ElZeroConfigEvent ");
                ElZeroConfigEvent (
                        pwzcDeviceNotif->wzcConfig.dwSessionHdl,
                        pwzcDeviceNotif->wzcConfig.wszGuid,
                        pwzcDeviceNotif->wzcConfig.ndSSID,
                        &(pwzcDeviceNotif->wzcConfig.rdEventData)
                        );
                break;

            default:
                break;
        }
    }
    while (FALSE);

    return dwRetCode;
}

#endif // ZEROCONFIG_LINKED

//
// ElMediaSenseRegister
//
// Description:
//
// Function called to register CallBack function with WMI
// for MEDIA_CONNECT/MEDIA_DISCONNECT events
//
// Arguments: 
//      fRegister - True = Register for Media Sense
//                  False = Deregister Media Sense requests
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElMediaSenseRegister (
        IN  BOOL        fRegister
        )
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = ElMediaSenseCallback;

    dwRetCode = WmiNotificationRegistration (
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_CONNECT),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR) 
    {
		TRACE1(INIT, "ElMediaSenseRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_STATUS_MEDIA_CONNECT", dwRetCode);
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration (
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_DISCONNECT),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR)
    {
		TRACE1(INIT, "ElMediaSenseRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_STATUS_MEDIA_DISCONNECT", dwRetCode);
        return( dwRetCode );
    }

    TRACE1 (INIT, "ElMediaSenseRegister - completed with RetCode %d", dwRetCode);

    return( dwRetCode );
}


//
// ElDeviceNotificationRegister
// 
// Description:
//
// Function called to register for device addition/removal notifications
//
// Arguments: 
//      fRegister - True = Register for Device Notifications
//                  False = Deregister Device Notifications
//
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElDeviceNotificationRegister (
        IN  BOOL        fRegister
        )
{
    HANDLE      hDeviceNotification = NULL;
    DWORD       dwRetCode = NO_ERROR;

#ifdef EAPOL_SERVICE

    DEV_BROADCAST_DEVICEINTERFACE   PnPFilter;

    if (fRegister)
    {
        ZeroMemory (&PnPFilter, sizeof(PnPFilter));

        PnPFilter.dbcc_size = sizeof(PnPFilter);
        PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        PnPFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

        g_hDeviceNotification = RegisterDeviceNotification (
                                    (HANDLE)g_hServiceStatus,
                                    &PnPFilter,
                                    DEVICE_NOTIFY_SERVICE_HANDLE );

        if (g_hDeviceNotification == NULL)
        {
            dwRetCode = GetLastError();
    
            TRACE1 (DEVICE, "ElDeviceNotificationRegister failed with error %ld",
                    dwRetCode);
        }
    }
    else
    {
        if (g_hDeviceNotification != NULL)
        {
            if (!UnregisterDeviceNotification (
                        g_hDeviceNotification
                        ))
            {
                dwRetCode = GetLastError();
                TRACE1 (DEVICE, "ElDeviceNotificationRegister: Unregister failed with error (%ld)",
                        dwRetCode);
            }
        }
    }

#endif

    return dwRetCode;
}


//
// ElBindingsNotificationRegister
//
// Description:
//
// Function called to register CallBack function with WMI
// for protocol bind/unbind
//
// Arguments: 
//      fRegister - True = Register for Media Sense
//                  False = Deregister Media Sense requests
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElBindingsNotificationRegister (
        IN  BOOL        fRegister
        )
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = ElBindingsNotificationCallback;

    dwRetCode = WmiNotificationRegistration (
                    (LPGUID)(&GUID_NDIS_NOTIFY_BIND),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR) 
    {
		TRACE1(INIT, "ElBindingsNotificationRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_NOTIFY_BIND", dwRetCode);
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration (
                    (LPGUID)(&GUID_NDIS_NOTIFY_UNBIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR)
    {
		TRACE1(INIT, "ElBindingsNotificationRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_NOTIFY_BIND", dwRetCode);
        return( dwRetCode );
    }

    TRACE1 (INIT, "ElBindingsNotificationRegister - completed with RetCode %d", dwRetCode);

    return( dwRetCode );
}


//
// ElDeviceNotificationHandler
// 
// Description:
//
// Function called to handle device notifications for interface addition/
// removal
//
// Arguments:
//      lpEventData - interface information
//      dwEventType - notification type 
//

DWORD
ElDeviceNotificationHandler (
        IN  VOID        *lpEventData,
        IN  DWORD       dwEventType
        )
{
    DWORD                           dwEventStatus = 0;
    DEV_BROADCAST_DEVICEINTERFACE   *pInfo = 
        (DEV_BROADCAST_DEVICEINTERFACE *) lpEventData;
    PVOID                           pvBuffer = NULL;
    BOOLEAN                         fDecrWorkerThreadCount = TRUE;
    DWORD                           dwRetCode = NO_ERROR;

    InterlockedIncrement (&g_lWorkerThreads);

    TRACE0 (DEVICE, "ElDeviceNotificationHandler entered");

    do
    {

        if (g_hEventTerminateEAPOL == NULL)
        {
            break;
        }
        if (!(g_dwModulesStarted & ALL_MODULES_STARTED))
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: Received notification before module started");
            break;
        }

        // Check if have already gone through EAPOLCleanUp before

        if ((dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1(INIT, "ElDeviceNotificationHandler: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            // log
    
            break;
        }

        if (dwEventStatus == WAIT_OBJECT_0)
        {
            TRACE0(INIT, "ElDeviceNotificationHandler: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }
    
        if (lpEventData == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: lpEventData == NULL");
            break;
        }
    
        if (pInfo->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: Event for Interface type");
    
            if ((pvBuffer = MALLOC (pInfo->dbcc_size + 16)) == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (DEVICE, "ElDeviceNotificationHandler: MALLOC failed for pvBuffer");
                break;
            }
    
            *((DWORD *)pvBuffer) = dwEventType;
            memcpy ((PBYTE)pvBuffer + 8, (PBYTE)pInfo, pInfo->dbcc_size);
    
            if (!QueueUserWorkItem (
                (LPTHREAD_START_ROUTINE)ElDeviceNotificationHandlerWorker,
                pvBuffer,
                WT_EXECUTELONGFUNCTION))
            {
                dwRetCode = GetLastError();
                TRACE1 (DEVICE, "ElDeviceNotificationHandler: QueueUserWorkItem failed with error %ld",
                        dwRetCode);
	            break;
            }
            else
            {
                fDecrWorkerThreadCount = FALSE;
            }

        }
        else
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: Event NOT for Interface type");
        }

    }
    while (FALSE);
    
    TRACE1 (DEVICE, "ElDeviceNotificationHandler completed with retcode %ld",
            dwRetCode);

    if (dwRetCode != NO_ERROR)
    {
        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    return dwRetCode;
}


//
// ElDeviceNotificationHandlerWorker
// 
// Description:
//
// Worker function for ElDeviceNotificationHandlerWorker
//
// Arguments:
//      pvContext - interface information
//

DWORD
WINAPI
ElDeviceNotificationHandlerWorker (
        IN  PVOID       pvContext
        )
{
    HANDLE                          hDevice = NULL;
    DEV_BROADCAST_DEVICEINTERFACE   *pInfo = NULL;
    DWORD                           dwEventType = 0;
    DWORD                           dwRetCode = NO_ERROR;

    TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Entered");

    do
    {
        if (pvContext == NULL)
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: pvContext == NULL");
            break;
        }

        if (!(g_dwModulesStarted & ALL_MODULES_STARTED))
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Received notification before module started");
            break;
        }

        dwEventType = *((DWORD *) pvContext);
        pInfo = (DEV_BROADCAST_DEVICEINTERFACE*)((PBYTE)pvContext + 8);

        if ((dwEventType == DBT_DEVICEARRIVAL) ||
                (dwEventType == DBT_DEVICEREMOVECOMPLETE))
        {
            // Extract GUID from the \Device\GUID string

            WCHAR   *pwszGUIDStart = NULL;
            WCHAR   *pwszGUIDEnd = NULL;
        
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Interface arr/rem");

            pwszGUIDStart  = wcsrchr( pInfo->dbcc_name, L'{' );
            pwszGUIDEnd    = wcsrchr( pInfo->dbcc_name, L'}' );

            if ((pwszGUIDStart != NULL) && (pwszGUIDEnd != NULL) && 
                ((pwszGUIDEnd- pwszGUIDStart) == (GUID_STRING_LEN_WITH_TERM-2)))
            {
                *(pwszGUIDEnd + 1) = L'\0';

                TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: For interface %ws",
                        pwszGUIDStart);

                // Interface was added

                if (dwEventType == DBT_DEVICEARRIVAL)
                {
                    TRACE0(DEVICE, "ElDeviceNotificationHandlerWorker: Callback for device addition");
        
                    if ((dwRetCode = ElEnumAndOpenInterfaces (
                                    NULL, pwszGUIDStart, 0, NULL)) != NO_ERROR)
                    {
                        TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: ElEnumAndOpenInterfaces returned error %ld", 
                            dwRetCode);
                    }
                }
                else
                {
        
                    TRACE0(DEVICE, "ElDeviceNotificationHandlerWorker: Callback for device removal");

                    if ((dwRetCode = ElShutdownInterface (pwszGUIDStart)) 
                            != NO_ERROR)
                    {
                        TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: ElShutdownInterface failed with error %ld",
                                dwRetCode);
                    }

                    if ((dwRetCode = ElEnumAndUpdateRegistryInterfaceList ()) != NO_ERROR)
                    {
                            TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: ElEnumAndUpdateRegistryInterfaceList failed with error %ld",
                                            dwRetCode);
                    }
                }
            }
            else
            {
                dwRetCode = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        else
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Event type is is NOT device arr/rem");
        }

    }
    while (FALSE);

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker completed with retcode %ld",
            dwRetCode);

    InterlockedDecrement (&g_lWorkerThreads);

    return 0;
}


//
// ElMediaSenseCallback
// 
// Description:
//
// Callback function called by WMI on MEDIA_CONNECT/MEDIA_DISCONNECT 
// events
//
// Arguments:
//      pWnodeHeader - Pointer to information returned by the event
//      uiNotificationContext - unused
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

VOID
CALLBACK
ElMediaSenseCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        )
{
    DWORD       dwEventStatus = 0;
    PVOID       pvBuffer = NULL;
    BOOLEAN     fDecrWorkerThreadCount = TRUE;
    DWORD       dwRetCode = NO_ERROR;

    InterlockedIncrement (&g_lWorkerThreads);

    TRACE0 (DEVICE, "ElMediaSenseCallback: Entered");

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            break;
        }
        if (!(g_dwModulesStarted & ALL_MODULES_STARTED))
        {
            TRACE0 (DEVICE, "ElMediaSenseCallback: Received notification before module started");
            break;
        }

        // Check if have already gone through EAPOLCleanUp before

        if (( dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1 (INIT, "ElMediaSenseCallback: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            // log
    
            break;
        }

        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            TRACE0 (INIT, "ElMediaSenseCallback: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }

        if (pWnodeHeader == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (DEVICE, "ElMediaSenseCallback: pWnodeHeader == NULL");
            break;
        }

        if ((pvBuffer = MALLOC (pWnodeHeader->BufferSize)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (DEVICE, "ElMediaSenseCallback: MALLOC failed for pvBuffer");
            break;
        }

        memcpy ((PVOID)pvBuffer, (PVOID)pWnodeHeader, pWnodeHeader->BufferSize);

        if (!QueueUserWorkItem (
            (LPTHREAD_START_ROUTINE)ElMediaSenseCallbackWorker,
            pvBuffer,
            WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElMediaSenseCallback: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            // log

            break;
        }
        else
        {
            fDecrWorkerThreadCount = FALSE;
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (DEVICE, "ElMediaSenseCallback: Failed with error %ld",
                dwRetCode);

        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

}


//
// ElMediaSenseCallbackWorker
// 
// Description:
//
// Worker function for ElMediaSenseCallback and executes in a separate
// thread
//
// Arguments:
//      pvContext - Pointer to information returned by the media-sense event
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
WINAPI
ElMediaSenseCallbackWorker (
        IN  PVOID       pvContext
        )
{
    PWNODE_HEADER           pWnodeHeader = (PWNODE_HEADER)pvContext;
    PWNODE_SINGLE_INSTANCE  pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    WCHAR                   *pwsName = NULL;
    WCHAR                   *pwszDeviceName = NULL;
    WCHAR                   *pwsGUIDString = NULL;
    WCHAR                   *pwszDeviceGUID = NULL;
    WCHAR                   *pwszGUIDStart = NULL, *pwszGUIDEnd = NULL;
    DWORD                   dwGUIDLen = 0;
    USHORT                  cpsLength;
    EAPOL_ITF               *pITF;
    EAPOL_PCB               *pPCB = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {

#ifdef EAPOL_SERVICE

    if ((g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
         ||
         (g_ServiceStatus.dwCurrentState == SERVICE_STOPPED))
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Callback received while service was stopping");
        break;
    }

#endif // EAPOL_SERVICE

    if (pWnodeHeader == NULL)
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Callback received with NULL NDIS interface details");

        break;
    }

    pwsName = (PWCHAR)RtlOffsetToPointer(
                                    pWnode,
                                    pWnode->OffsetInstanceName );

    pwsGUIDString = (PWCHAR)RtlOffsetToPointer(
                                    pWnode,
                                    pWnode->DataBlockOffset );

    cpsLength = (SHORT)( *((SHORT *)pwsName) );

    if (!(pwszDeviceName = (WCHAR *) MALLOC ((cpsLength+1)*sizeof(WCHAR))))
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Error in Memory allocation for pszDeviceName");
        break;
    }

    memcpy ((CHAR *)pwszDeviceName, (CHAR *)pwsName+sizeof(SHORT), cpsLength);
    pwszDeviceName[cpsLength] = L'\0';

    pwszGUIDStart = wcschr (pwsGUIDString, L'{');
    pwszGUIDEnd = wcschr (pwsGUIDString, L'}');

    if ((pwszGUIDStart == NULL) || (pwszGUIDEnd == NULL) || ((pwszGUIDEnd - pwszGUIDStart) != (GUID_STRING_LEN_WITH_TERM-2)))
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: GUID not constructed correctly");
        dwRetCode = ERROR_INVALID_PARAMETER;
        break;
    }

    dwGUIDLen = GUID_STRING_LEN_WITH_TERM;
    pwszDeviceGUID = NULL;
    if ((pwszDeviceGUID = MALLOC (dwGUIDLen * sizeof (WCHAR))) == NULL)
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: MALLOC failed for pwszDeviceGUID");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        break;
    }

    memcpy ((VOID *)pwszDeviceGUID, (VOID *)pwszGUIDStart, ((dwGUIDLen-1)*sizeof(WCHAR)));
    pwszDeviceGUID[dwGUIDLen-1] = L'\0';

    TRACE3 (DEVICE, "ElMediaSenseCallbackWorker: For interface (%ws), GUID (%ws), length of block = %d", 
            pwszDeviceName, pwszDeviceGUID, cpsLength);

    //
    // Get the information for the media disconnect.
    //

    if (memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_STATUS_MEDIA_DISCONNECT, 
                 sizeof(GUID)) == 0)
    {
        // MEDIA DISCONNECT callback 

        DbLogPCBEvent (DBLOG_CATEG_INFO, NULL, EAPOL_MEDIA_DISCONNECT, pwszDeviceName);

        // Check if EAPOL was actually started on this interface
        // Verify by checking existence of corresponding entry in hash table

        TRACE0(DEVICE, "ElMediaSenseCallbackWorker: Callback for sense disconnect");

        ACQUIRE_WRITE_LOCK (&(g_PCBLock));
        pPCB = ElGetPCBPointerFromPortGUID (pwszDeviceGUID);
        if (pPCB != NULL)
        {
            ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
            if ((dwRetCode = FSMDisconnected (pPCB, NULL)) != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: FSMDisconnected failed with error %ld", 
                    dwRetCode);
            }
            else
            {
                TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: Port marked disconnected %ws", 
                    pwszDeviceName);
            }
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
        }
        RELEASE_WRITE_LOCK (&(g_PCBLock));
    }
    else
    {
        if (memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_STATUS_MEDIA_CONNECT, 
                     sizeof(GUID)) == 0)
        {
            // MEDIA CONNECT callback

            DbLogPCBEvent (DBLOG_CATEG_INFO, NULL, EAPOL_MEDIA_CONNECT, pwszDeviceName);

            TRACE0(DEVICE, "ElMediaSenseCallbackWorker: Callback for sense connect");

            if ((dwRetCode = ElEnumAndOpenInterfaces (
                            NULL, pwszDeviceGUID, 0, NULL))
                != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: ElEnumAndOpenInterfaces returned error %ld", 
                        dwRetCode);
            }
        }
    }

    }
    while (FALSE);

    TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: processed, RetCode = %ld", dwRetCode);


    if (pWnodeHeader != NULL)
    {
        FREE (pWnodeHeader);
    }

    if (pwszDeviceName != NULL)
    {
        FREE (pwszDeviceName);
    }

    if (pwszDeviceGUID != NULL)
    {
        FREE (pwszDeviceGUID);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return 0;
}


//
// ElBindingsNotificationCallback
// 
// Description:
//
// Callback function called by WMI on protocol bind/unbind
// events
//
// Arguments:
//      pWnodeHeader - Pointer to information returned by the event
//      uiNotificationContext - unused
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

VOID
CALLBACK
ElBindingsNotificationCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        )
{
    DWORD       dwEventStatus = 0;
    PVOID       pvBuffer = NULL;
    BOOLEAN     fDecrWorkerThreadCount = TRUE;
    DWORD       dwRetCode = NO_ERROR;

    InterlockedIncrement (&g_lWorkerThreads);

    TRACE0 (DEVICE, "ElBindingsNotificationCallback: Entered");

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            break;
        }
        if (!(g_dwModulesStarted & ALL_MODULES_STARTED))
        {
            TRACE0 (DEVICE, "ElBindingsNotificationCallback: Received notification before module started");
            break;
        }

        // Check if have already gone through EAPOLCleanUp before

        if (( dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1 (INIT, "ElBindingsNotificationCallback: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            break;
        }

        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            TRACE0 (INIT, "ElBindingsNotificationCallback: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }

        if (pWnodeHeader == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (DEVICE, "ElBindingsNotificationCallback: pWnodeHeader == NULL");
            break;
        }

        if ((pvBuffer = MALLOC (pWnodeHeader->BufferSize)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (DEVICE, "ElBindingsNotificationCallback: MALLOC failed for pvBuffer");
            break;
        }

        memcpy ((PVOID)pvBuffer, (PVOID)pWnodeHeader, pWnodeHeader->BufferSize);

        if (!QueueUserWorkItem (
            (LPTHREAD_START_ROUTINE)ElBindingsNotificationCallbackWorker,
            pvBuffer,
            WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElBindingsNotificationCallback: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            // log

            break;
        }
        else
        {
            fDecrWorkerThreadCount = FALSE;
        }
    
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (DEVICE, "ElBindingsNotificationCallback: Failed with error %ld",
                dwRetCode);

        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

}


//
// ElBindingsNotificationCallbackWorker
// 
// Description:
//
// Worker function for ElBindingsNotificationCallback and executes in a separate
// thread
//
// Arguments:
//      pvContext - Pointer to information returned by the protocol bind/unbind 
//                  event
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
WINAPI
ElBindingsNotificationCallbackWorker (
        IN  PVOID       pvContext
        )
{
    PWNODE_HEADER           pWnodeHeader = (PWNODE_HEADER)pvContext;
    PWNODE_SINGLE_INSTANCE  pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    WCHAR                   *pwsName = NULL;
    WCHAR                   *pwszDeviceGUID = NULL;
    WCHAR                   *pwszGUIDStart = NULL, *pwszGUIDEnd = NULL;
    DWORD                   dwGUIDLen = 0;
    WCHAR                   *pwsTransportName = NULL;
    WCHAR                   *pwszDeviceName = NULL;
    USHORT                  cpsLength;
    EAPOL_ITF               *pITF = NULL;
    EAPOL_PCB               *pPCB = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {

#ifdef EAPOL_SERVICE

    if ((g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
         ||
         (g_ServiceStatus.dwCurrentState == SERVICE_STOPPED))
    {
        TRACE0 (DEVICE, "ElBindingsNotificationCallbackWorker: Callback received while service was stopping");
        break;
    }

#endif // EAPOL_SERVICE

    if (pWnodeHeader == NULL)
    {
        TRACE0 (DEVICE, "ElBindingsNotificationCallbackWorker: Callback received with NULL NDIS interface details");

        break;
    }

    pwsName = (PWCHAR)RtlOffsetToPointer(
                                    pWnode,
                                    pWnode->OffsetInstanceName );

    pwsTransportName = (PWCHAR)RtlOffsetToPointer(
                                    pWnode,
                                    pWnode->DataBlockOffset );

    if (wcsncmp (cwszNDISUIOProtocolName, pwsTransportName, wcslen (cwszNDISUIOProtocolName)))
    {
        TRACE1 (DEVICE, "ElBindingsNotificationCallbackWorker: Protocol binding (%ws) not for NDISUIO",
                pwsTransportName);
        break;
    }

    // Get the length of the device name string and null terminate it 

    cpsLength = (SHORT)( *((SHORT *)pwsName) );

    if (!(pwszDeviceName = (WCHAR *) MALLOC ((cpsLength+1)*sizeof(WCHAR))))
    {
        TRACE0 (DEVICE, "ElBindingsNotificationCallbackWorker: Error in Memory allocation for pwszDeviceName");
        break;
    }

    memcpy ((CHAR *)pwszDeviceName, (CHAR *)pwsName+sizeof(SHORT), cpsLength);
    pwszDeviceName[cpsLength] = L'\0';

    pwszDeviceGUID = pwsTransportName + wcslen(cwszNDISUIOProtocolName) + 1;

    pwszGUIDStart = wcschr (pwszDeviceGUID, L'{');
    pwszGUIDEnd = wcschr (pwszDeviceGUID, L'}');

    pwszDeviceGUID = NULL;

    if ((pwszGUIDStart == NULL) || (pwszGUIDEnd == NULL) || ((pwszGUIDEnd - pwszGUIDStart) != (GUID_STRING_LEN_WITH_TERM-2)))
    {
        TRACE0 (DEVICE, "ElBindingsNotificationCallbackWorker: GUID not constructed correctly");
        dwRetCode = ERROR_INVALID_PARAMETER;
        break;
    }

    dwGUIDLen = GUID_STRING_LEN_WITH_TERM;
    if ((pwszDeviceGUID = MALLOC (dwGUIDLen * sizeof (WCHAR))) == NULL)
    {
        TRACE0 (DEVICE, "ElBindingsNotificationCallbackWorker: MALLOC failed for pwszDeviceGUID");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        break;
    }

    memcpy ((VOID *)pwszDeviceGUID, (VOID *)pwszGUIDStart, ((dwGUIDLen-1)*sizeof(WCHAR)));
    pwszDeviceGUID[dwGUIDLen-1] = L'\0';

    TRACE2 (DEVICE, "ElBindingsNotificationCallbackWorker: For interface = %ws, guid=%ws", 
            pwszDeviceName, pwszDeviceGUID);
    
    //
    // Get the information for the protocol UNBIND
    //

    if (memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_NOTIFY_UNBIND, 
                 sizeof(GUID)) == 0)
    {
        // Protocol UNBIND callback 

        DbLogPCBEvent (DBLOG_CATEG_INFO, NULL, EAPOL_NDISUIO_UNBIND, pwszDeviceName);

        TRACE0(DEVICE, "ElBindingsNotificationCallbackWorker: Callback for protocol unbind");

        if ((dwRetCode = ElShutdownInterface (pwszDeviceGUID)) != ERROR)
        {
            TRACE2 (DEVICE, "ElBindingsNotificationCallbackWorker: ElShutdownInterface failed with error %ld for (%ws)",
                    dwRetCode, pwszDeviceGUID);
        }
                    
        if ((dwRetCode = ElEnumAndUpdateRegistryInterfaceList ()) != NO_ERROR)
        {
            TRACE1 (DEVICE, "ElBindingsNotificationCallbackWorker: ElEnumAndUpdateRegistryInterfaceList failed with error %ld",
                                dwRetCode);
        }
    }
    else
    {

        if (memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_NOTIFY_BIND, 
                     sizeof(GUID)) == 0)
        {
            // protocol BIND callback

            DbLogPCBEvent (DBLOG_CATEG_INFO, NULL, EAPOL_NDISUIO_BIND, pwszDeviceName);

            TRACE0(DEVICE, "ElBindingsNotificationCallbackWorker: Callback for protocol BIND");

            if ((dwRetCode = ElEnumAndOpenInterfaces (
                            NULL, pwszDeviceGUID, 0, NULL))
                                                        != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElBindingsNotificationCallbackWorker: ElEnumAndOpenInterfaces returned error %ld", 
                        dwRetCode);
            }
        }
    }

    }
    while (FALSE);

    TRACE1 (DEVICE, "ElBindingsNotificationCallbackWorker: processed, RetCode = %ld", dwRetCode);

    if (pWnodeHeader != NULL)
    {
        FREE (pWnodeHeader);
    }

    if (pwszDeviceName != NULL)
    {
        FREE (pwszDeviceName);
    }

    if (pwszDeviceGUID != NULL)
    {
        FREE (pwszDeviceGUID);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return 0;
}


// 
// ElEnumAndOpenInterfaces
// 
// Description:
//
// Enumerates interfaces and intializes EAPOL on desired ones.
//
// If EAPOL is to be started on an interface, it opens a handle to 
// the NDISUIO driver, calls EAPOL to create and initialize PCB for the 
// interface, and finally adds an entry to the interface hashtable.
//
// If pwszDesiredGUID is not NULL, all interfaces are enumerated, but 
// EAPOL will be initialized only on the interface whose GUID matches.
//
// If pwszDesiredDescription is not NULL, all interfaces are enumerated, but 
// EAPOL will be initialized only on the interface whose description matches.
//
// If pwszDesiredGUID and pwszDescription are both NULL, all interfaces are 
// enumerated. EAPOL will be initialized only on all interfaces that 
// does have an entry in the interface hashtable.
//
//
// Arguments:
//      pwszDesiredDescription - Interface Description on which EAPOL is to 
//                  be started
//      pwszDesiredGUID - Interface GUID on which EAPOL is to be started
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElEnumAndOpenInterfaces (
        WCHAR       *pwszDesiredDescription,
        WCHAR       *pwszDesiredGUID,
        DWORD       dwHandle,
        PRAW_DATA   prdUserData
        )
{ 
    CHAR				EnumerateBuffer[256];
    PNDIS_ENUM_INTF		Interfaces = NULL;
    BYTE                *pbNdisuioEnumBuffer = NULL;
    DWORD               dwNdisuioEnumBufferSize = 0;
    HANDLE              hDevice = NULL;
    BOOL                fSearchByDescription = FALSE;
    BOOL                fSearchByGUID = FALSE;
    DWORD               dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
    WCHAR               cwsDummyBuffer[256], *pDummyPtr = NULL;
    WCHAR               *pwszGUIDStart = NULL;
    EAPOL_PCB           *pPCB = NULL;
    BOOL                fPCBExists = FALSE;
    BOOL                fPCBReferenced = FALSE;
    DWORD               dwAvailableInterfaces = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    DWORD               dwRetCode = NO_ERROR;


    TRACE2 (DEVICE, "ElEnumAndOpenInterfaces: DeviceDesc = %ws, GUID = %ws",
            pwszDesiredDescription, pwszDesiredGUID);
        
    ACQUIRE_WRITE_LOCK (&(g_ITFLock));

    if (pwszDesiredGUID == NULL)
    {
        if (pwszDesiredDescription != NULL)
        {
            fSearchByDescription = TRUE;
        }
    }
    else
    {
        if (pwszDesiredDescription != NULL)
        {
            RELEASE_WRITE_LOCK (&(g_ITFLock));
            return ERROR;
        }
        fSearchByGUID = TRUE;
    }

    ZeroMemory (EnumerateBuffer, 256);
    Interfaces = (PNDIS_ENUM_INTF)EnumerateBuffer;

    //
    // Allocate amount of memory as instructed by NdisEnumerateInterfaces
    // once the API allows querying of bytes required
    //

    Interfaces->TotalInterfaces = 0;
    Interfaces->AvailableInterfaces = 0;
    Interfaces->BytesNeeded = 0;
    if (!NdisEnumerateInterfaces(Interfaces, 256)) 
    {
        RELEASE_WRITE_LOCK (&(g_ITFLock));
        dwRetCode = GetLastError ();
        TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: NdisEnumerateInterfaces failed with error %ld",
                dwRetCode);
        return dwRetCode;
    }

    dwNdisuioEnumBufferSize = (Interfaces->BytesNeeded + 7) & 0xfffffff8;
    dwAvailableInterfaces = Interfaces->AvailableInterfaces;

    if (dwNdisuioEnumBufferSize == 0)
    {
        RELEASE_WRITE_LOCK (&(g_ITFLock));
        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: MALLOC skipped for pbNdisuioEnumBuffer as dwNdisuioEnumBufferSize == 0");
        dwRetCode = NO_ERROR;
        return dwRetCode;
    }

    pbNdisuioEnumBuffer = (BYTE *) MALLOC (4*dwNdisuioEnumBufferSize);

    if (pbNdisuioEnumBuffer == NULL)
    {
        RELEASE_WRITE_LOCK (&(g_ITFLock));
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: MALLOC failed for pbNdisuioEnumBuffer");
        return dwRetCode;
    }

    Interfaces = (PNDIS_ENUM_INTF)pbNdisuioEnumBuffer;

    // Enumerate all the interfaces present on the machine

    if ((dwRetCode = ElNdisuioEnumerateInterfaces (
                            Interfaces, 
                            dwAvailableInterfaces,
                            4*dwNdisuioEnumBufferSize)) == NO_ERROR)
    {
        UNICODE_STRING  *pInterfaceName = NULL;
        UNICODE_STRING  *pInterfaceDescription = NULL;
        DWORD			i;

        // Update the interface list in the registry that NDISUIO has bound to.
        // The current interface list is just overwritten into the registry.


        if ((dwRetCode = ElUpdateRegistryInterfaceList (Interfaces)) 
                != NO_ERROR)
        {
            TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: ElUpdateInterfaceList failed with error =%ld", 
                    dwRetCode);

            dwRetCode = NO_ERROR;

            // log
        }

        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            fPCBExists = fPCBReferenced = FALSE;
            if ((dwRetCode != NO_ERROR) &&
                    (fSearchByDescription || fSearchByGUID))
            {
                break;
            }
            else
            {
                dwRetCode = NO_ERROR;
            }

            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                pInterfaceName = &(Interfaces->Interface[i].DeviceName);
            }
            else
            {
                TRACE0(INIT, "NdisEnumerateInterfaces: Device Name was NULL");
                continue;
            }

            TRACE1(INIT, "Device: %ws", pInterfaceName->Buffer);

                    
            if (Interfaces->Interface[i].DeviceDescription.Buffer != NULL)
            {
                pInterfaceDescription = &(Interfaces->Interface[i].DeviceDescription);
            }
            else
            {
                TRACE0(INIT, "NdisEnumerateInterfaces: Device Description was NULL");
                continue;
            }

            TRACE1(INIT, "Description: %ws", pInterfaceDescription->Buffer);

            // EAPOL requested be started only a particular
            // interface

            if (fSearchByDescription)
            {
                if (wcscmp (pInterfaceDescription->Buffer,
                            pwszDesiredDescription)
                        != 0)
                {
                    // No match, continue with next interface
                    continue;
                }

                TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Found interface after enumeration %ws", pInterfaceDescription->Buffer);
            }

            if (fSearchByGUID)
            {
                if (wcsstr (pInterfaceName->Buffer,
                            pwszDesiredGUID)
                        == NULL)
                {
                    // No match, continue with next interface
                    continue;
                }

                TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Found interface after enumeration %ws", pInterfaceName->Buffer);
            }

            {
                // Extract GUID-string out of device name

                WCHAR   *pwszGUIDEnd = NULL;
                WCHAR   *pwszGUID = NULL;
                WCHAR   wchGUIDSaveLast;

                pwszGUID = pInterfaceName->Buffer;
                pwszGUIDStart  = wcschr( pwszGUID, L'{' );
                pwszGUIDEnd    = wcschr( pwszGUID, L'}' );

                    
                if (pwszGUIDStart != NULL)
                {
                    wchGUIDSaveLast = *(pwszGUIDEnd+1);
                    
                    *(pwszGUIDEnd+1) = (WCHAR)NULL;
                }

                // Verify if a PCB already exists for the interface
                // This is possible if no media disconnect was received
                // after the initial media connect

                pPCB = NULL;
                hDevice = NULL;

                ACQUIRE_WRITE_LOCK (&(g_PCBLock));
                if ((pPCB = ElGetPCBPointerFromPortGUID (pwszGUIDStart)) != NULL)
                {
                    if (EAPOL_REFERENCE_PORT (pPCB))
                    {
                        fPCBReferenced = TRUE;
                    }
                }
                RELEASE_WRITE_LOCK (&(g_PCBLock));

                // Restore interface buffer

                *(pwszGUIDEnd+1) = wchGUIDSaveLast;

                if (pPCB != NULL)
                {
                    // Point to existing handle

                    hDevice = pPCB->hPort;
                    fPCBExists = TRUE;
                    dwRetCode = NO_ERROR;
                    TRACE0 (INIT, "ElEnumAndOpenInterfaces: Found PCB already existing for interface");
                }
                else
                {
                    TRACE0 (INIT, "ElEnumAndOpenInterfaces: Did NOT find PCB already existing for interface");

                    // Open handle to ndisuio driver

                    if ((dwRetCode = ElOpenInterfaceHandle (
                                    pInterfaceName->Buffer,
                                    &hDevice
                                    )) != NO_ERROR)
                    {
                        TRACE1 (INIT, "ElEnumAndOpenInterfaces: ElOpenInterfaceHandle failed with error = %d\n",
                            dwRetCode );
                    }
                }

                *(pwszGUIDEnd+1) = (CHAR)NULL;

            }

            if (dwRetCode != NO_ERROR)
            {
                TRACE0 (INIT, "ElEnumAndOpenInterfaces: Failed to open handle");
                continue;
            }
            else
            {
                // Create EAPOL PCB and start state machine

                if ((dwRetCode = ElCreatePort (
                                hDevice,
                                pwszGUIDStart,
                                pInterfaceDescription->Buffer,
                                dwHandle,
                                prdUserData
                                )) != NO_ERROR)
                {
                    TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Error in CreatePort = %d", dwRetCode);

                    if (fPCBExists)
                    {
                        if (dwRetCode = ElShutdownInterface (
                                            pPCB->pwszDeviceGUID
                                            ) != NO_ERROR)
                        {
                            TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: ElShutdownInterface handle 1 failed with error %ld",
                                        dwRetCode);
                        }
                        if (fPCBReferenced)
                        {
                            EAPOL_DEREFERENCE_PORT (pPCB);
                        }
                    }
                    else
                    {
                        // Close the handle just opened to the ndisuio driver

                        if ((dwRetCode = ElCloseInterfaceHandle (
                                        hDevice, 
                                        pwszGUIDStart)) != NO_ERROR)
                        {
                            TRACE1 (DEVICE, 
                                "ElEnumAndOpenInterfaces: Error in ElCloseInterfaceHandle %d", 
                                dwRetCode);
                        }
                    }

                    // Continue with the next interface

                    continue;
                }
                else
                {
                    TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: CreatePort successful");

                    // If PCB already existed, do not add to the hash
                    // table

                    if (fPCBExists)
                    {
                        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: PCB already existed, skipping Interface hash table addition");
                        fPCBExists = FALSE;
                        if (fPCBReferenced)
                        {
                            EAPOL_DEREFERENCE_PORT (pPCB);
                        }
                        continue;
                    }

                    if ((dwRetCode = ElCreateInterfaceEntry (
                                        pwszGUIDStart,
                                        pInterfaceDescription->Buffer
                                    )) != NO_ERROR)
                    {
                        // Could not create new interface entry
                        // Delete Port entry created for this GUID

                        if ((dwRetCode = ElDeletePort (
                                        pwszGUIDStart,
                                        &hDevice)) != NO_ERROR)
                        {
        
                            TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Error in deleting port for %ws", 
                                    pwszGUIDStart);
                            // log
                        }

                        // Close the handle to the NDISUIO driver

                        if ((dwRetCode = ElCloseInterfaceHandle (
                                        hDevice, 
                                        pwszGUIDStart)) != NO_ERROR)
                        {
                            TRACE1 (DEVICE, 
                                    "ElEnumAndOpenInterfaces: Error in ElCloseInterfaceHandle %d", 
                                    dwRetCode);
                            // log
                        }
                    }
                }
            }
        } // for (i=0; i < Interfaces
    }
    else
    {
        TRACE1(INIT, "ElEnumAndOpenInterfaces: ElNdisuioEnumerateInterfaces failed with error %d", 
                dwRetCode);
    }

    TRACE1(INIT, "ElEnumAndOpenInterfaces: Completed with retcode = %d", 
            dwRetCode);

    if (pbNdisuioEnumBuffer != NULL)
    {
        FREE(pbNdisuioEnumBuffer);
    }

    RELEASE_WRITE_LOCK (&(g_ITFLock));

    return dwRetCode;
}


//
// ElOpenInterfaceHandle
// 
// Description:
//
// Function called to open handle to the NDISUIO driver for an interface.
//
// Arguments:
//      DeviceName - Identifier for the interface is of the 
//                     form \Device\{GUID String}
//      phDevice - Output pointer to handle of NDISUIO driver for 
//                      the interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElOpenInterfaceHandle (
        IN  WCHAR       *pwszDeviceName,
        OUT HANDLE      *phDevice
        )
{
    DWORD   dwDesiredAccess;
    DWORD   dwShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;
    DWORD   dwCreationDistribution;
    DWORD   dwFlagsAndAttributes;
    HANDLE  hTemplateFile;
    HANDLE  hHandle = INVALID_HANDLE_VALUE;
    DWORD   dwRetCode = NO_ERROR;
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];
    INT     wNameLength;
    INT     NameLength = wcslen(pwszDeviceName);
    DWORD   dwBytesReturned;
    USHORT  wEthernetType = g_wEtherType8021X;
    INT     i;

    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    dwCreationDistribution = OPEN_EXISTING;
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
    hTemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    TRACE1 (INIT, "ElOpenInterfaceHandle: Opening handle for %ws", 
            pwszDeviceName);

    do 
    {

        // Convert to unicode string - non-localized...
        
        wNameLength = 0;
        for (i = 0; (i < NameLength) && (i < MAX_NDIS_DEVICE_NAME_LEN-1); i++)
        {
            wNdisDeviceName[i] = (WCHAR)pwszDeviceName[i];
            wNameLength++;
        }
        wNdisDeviceName[i] = L'\0';
    
        TRACE1(DEVICE, "ElOpenInterfaceHandle: Trying to access NDIS Device: %ws\n", 
                wNdisDeviceName);

        // --ft: Replace these calls to Ndisuio with the calls to the opened handles hash.
        //hHandle = CreateFileA(
        //            pNdisuioDevice,
        //            dwDesiredAccess,
        //            dwShareMode,
        //            lpSecurityAttributes,
        //            dwCreationDistribution,
        //            dwFlagsAndAttributes,
        //            hTemplateFile
        //            );
        //
        //if (hHandle == INVALID_HANDLE_VALUE)
        //{
        //    *phDevice = NULL;
        //    dwRetCode = GetLastError();
        //    TRACE1 (INIT, "ElOpenInterfaceHandle: Failed in CreateFile with error %d", dwRetCode);
        //    break;
        //}
        //else
        //{
        //    *phDevice = hHandle;
        //}
        //
        //if (!(DeviceIoControl(
        //        *phDevice,
        //        IOCTL_NDISUIO_OPEN_DEVICE,
        //        (LPVOID)&wNdisDeviceName[0],
        //        wNameLength*sizeof(WCHAR),
        //        NULL,
        //        0,
        //        &dwBytesReturned,
        //        NULL)))
        //        
        //{
        //    *phDevice = NULL;
        //    if ((dwRetCode = GetLastError()) == 0)
        //    {
        //        dwRetCode = ERROR_IO_DEVICE;
        //    }
        //    TRACE1(DEVICE, "ElOpenInterfaceHandle: Error in accessing NDIS Device: %ws", wNdisDeviceName);
        //    break;
        //}
        // The call below goes to the opened handles hash which takes care of
        // sharing the handles. EAPOL doesn't have to care about anyone else
        // using this handle - the sharing hash keeps a ref count for the handle
        // such that the callers can just call OpenIntfHandle & CloseIntfHandle
        // whenever they wish.
        dwRetCode = OpenIntfHandle(
                        wNdisDeviceName,
                        &hHandle);

        if (dwRetCode != ERROR_SUCCESS)
        {
            TRACE1(DEVICE, "ElOpenInterfaceHandle: Error in OpenIntfHandle(%ws)", wNdisDeviceName);
            break;
        }
        *phDevice = hHandle;

        TRACE2(DEVICE, "ElOpenInterfaceHandle: OpenIntfHandle(%ws) = %d", wNdisDeviceName, *phDevice);

        // IOCTL down the Ethernet type

        if (!(DeviceIoControl(
                *phDevice,
                IOCTL_NDISUIO_SET_ETHER_TYPE,
                (LPVOID)&wEthernetType,
                sizeof(USHORT),
                NULL,
                0,
                &dwBytesReturned,
                NULL)))
                
        {
            *phDevice = NULL;
            if ((dwRetCode = GetLastError()) == 0)
            {
                dwRetCode = ERROR_IO_DEVICE;
            }
            TRACE1(DEVICE, "ElOpenInterfaceHandle: Error in ioctling ETHER type : %ws", wNdisDeviceName);
            break;
        }

        // Bind for asynchronous I/O handling of Read/Write data
        // Depending on whether it is completion for Readfile() or WriteFile()
        // ElIoCompletionRoutine will call ElReadCompletionRoutine
        // or ElWriteCompletionRoutine
       
        if (!BindIoCompletionCallback(
                *phDevice,
                ElIoCompletionRoutine,
                0
                ))
        {
            dwRetCode = GetLastError();
            if (dwRetCode != ERROR_INVALID_PARAMETER)
            {
                *phDevice = NULL;
                TRACE1 (DEVICE, "ElOpenInterfaceHandle: Error in BindIoCompletionCallBac %d", dwRetCode);
                break;
            }
            else
            {
                TRACE0 (DEVICE, "ElOpenInterfaceHandle: BindIoCompletionCallback already done !!!");
                dwRetCode = NO_ERROR;
            }
        }
        
    } while (FALSE);

    // Cleanup if there is error

    if (dwRetCode != NO_ERROR)
    {
        if (hHandle != INVALID_HANDLE_VALUE)
        {
            // --ft: if anything bad happened, don't overwrite the dwRetCode - we're interested
            // what the first error was, not the error that might have happened when we
            // tried to close the hHandle.
            // Note: ElCloseInterfaceHandle understands the Guid both decorated and un-decorated
            if (ElCloseInterfaceHandle(hHandle, pwszDeviceName) != ERROR_SUCCESS)
            {
                TRACE1 (INIT, "ElOpenInterfaceHandle: Error in CloseHandle %d", dwRetCode);
            }
        }
    }
        
    TRACE2 (INIT, "ElOpenInterfaceHandle: Opened handle %p with dwRetCode %d", *phDevice, dwRetCode);

    return (dwRetCode);

}


//
// ElCloseInterfaceHandle
// 
// Description:
//
// Function called to close handle to NDISUIO driver for an interface 
//
// Arguments:
//      hDevice - Handle to NDISUIO device for the interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCloseInterfaceHandle (
        IN  HANDLE      hDevice,
        IN  LPWSTR      pwszDeviceGuid
        )
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];

    TRACE2 (DEVICE, "ElCloseInterfaceHandle(0x%x,%ws) entered", hDevice, pwszDeviceGuid);

    ZeroMemory (wNdisDeviceName, MAX_NDIS_DEVICE_NAME_LEN);

    // if first char in the Guid is '\' then we assume the GUID format is
    // '\DEVICE\{...}'. We do just the UNICODE conversion then
    if (pwszDeviceGuid[0] == '\\')
    {
        wcscpy (wNdisDeviceName, pwszDeviceGuid);
    }
    // else, we assume the Guid is un-decorated, and we add the decorations.
    else
    {
        wcscpy(wNdisDeviceName, L"\\DEVICE\\");
        wcsncat(wNdisDeviceName, pwszDeviceGuid, MAX_NDIS_DEVICE_NAME_LEN - 8);
        wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN-1]=L'\0';
    }

    // --ft: For now, don't go directly to Ndisuio to close handles. Instead,
    // go to the opened handles hash. This takes care of all the handle sharing
    // problem.
    dwRetCode = CloseIntfHandle(wNdisDeviceName);

    //if (!CloseHandle(hDevice))
    //{
    //    dwRetCode = GetLastError();
    //}

    if (dwRetCode != ERROR_SUCCESS)
    {
        TRACE1 (INIT, "ElCloseInterfaceHandle: Error in CloseHandle %d", 
                dwRetCode);
    }

    return dwRetCode;
}


//
// ElReadFromInterface
// 
// Description:
//
// Function called to perform Overlapped read on handle to NDISUIO driver
//
// Arguments:
//      hDevice - Handle to NDISUIO driver for this interface
//      pElBuffer - Context buffer
//      dwBufferLength - Bytes to be read
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElReadFromInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pElBuffer,
        IN DWORD            dwBufferLength
        )
{
    DWORD   dwRetCode = NO_ERROR;

    if (!ReadFile (
                hDevice,
                pElBuffer->pBuffer,
                dwBufferLength,
                NULL,
                &pElBuffer->Overlapped
                ))
    {
        dwRetCode = GetLastError();
            
        if (dwRetCode == ERROR_IO_PENDING)
        {
            // Pending status is fine, we are doing OVERLAPPED read

            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE1 (DEVICE, "ElReadFromInterface: ReadFile failed with error %d",
                    dwRetCode);
        }
    }

    return dwRetCode;
}


//
// ElWriteToInterface
// 
// Description:
//
// Function called to perform Overlapped write on handle to NDISUIO driver
//
// Arguments:
//      hDevice - Handle to NDISUIO device for this interface
//      pElBuffer - Context buffer
//      dwBufferLength - Bytes to be written
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElWriteToInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pElBuffer,
        IN DWORD            dwBufferLength
        )
{
    DWORD   dwRetCode = NO_ERROR;
    
    TRACE0 (DEVICE, "ElWriteToInterface entered");

    if (!WriteFile (
                hDevice,
                pElBuffer->pBuffer,
                dwBufferLength,
                NULL,
                &pElBuffer->Overlapped
                ))
    {
        dwRetCode = GetLastError();
            
        if (dwRetCode == ERROR_IO_PENDING)
        {
            // Pending status is fine, we are doing OVERLAPPED write

            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE1 (DEVICE, "ElWriteToInterface: WriteFile failed with error %d",
                dwRetCode);
        }
    }

    TRACE1 (DEVICE, "ElWriteToInterface completed, RetCode = %d", dwRetCode);
    return dwRetCode;
}


// 
// ElHashInterfaceDescToBucket
// 
// Description:
//
// Function called to convert Friendly name of interface into interface hash 
// table index.
//
// Arguments:
//      pwszInterfaceDesc - Friendly name of the interface
//
// Return values:
//      Hash table index between from 0 to INTF_TABLE_BUCKETS-1
//

DWORD
ElHashInterfaceDescToBucket (
        IN WCHAR    *pwszInterfaceDesc
        )
{
    return ((DWORD)((_wtol(pwszInterfaceDesc)) % INTF_TABLE_BUCKETS)); 
}


//
// ElGetITFPointerFromInterfaceDesc
//
// Description:
//
// Function called to convert Friendly name of interface to ITF entry pointer
//
// Arguments:
//      pwszInterfaceDesc - Friendly name of the interface
//
// Return values:
//      Pointer to interface entry in hash table
//

PEAPOL_ITF
ElGetITFPointerFromInterfaceDesc (
        IN WCHAR    *pwszInterfaceDesc 
        )
{
    EAPOL_ITF   *pITFWalker = NULL;
    DWORD       dwIndex;
    INT         i=0;

    TRACE1 (DEVICE, "ElGetITFPointerFromInterfaceDesc: Desc = %ws", pwszInterfaceDesc);
        
    if (pwszInterfaceDesc == NULL)
    {
        return (NULL);
    }

    dwIndex = ElHashInterfaceDescToBucket (pwszInterfaceDesc);

    TRACE1 (DEVICE, "ElGetITFPointerFromItfDesc: Index %d", dwIndex);

    for (pITFWalker = g_ITFTable.pITFBuckets[dwIndex].pItf;
            pITFWalker != NULL;
            pITFWalker = pITFWalker->pNext
            )
    {
        if (wcsncmp (pITFWalker->pwszInterfaceDesc, pwszInterfaceDesc, wcslen(pwszInterfaceDesc)) == 0)
        {
            return pITFWalker;
        }
    }

    return (NULL);
}


//
// ElRemoveITFFromTable
// 
// Description:
//
// Function called to remove an interface entry from the interface hash 
// table
//
// Arguments:
//      pITF - Point to the Interface entry in the hash table
//
// Return values:
// 

VOID
ElRemoveITFFromTable (
        IN EAPOL_ITF *pITF
        )
{
    DWORD       dwIndex;
    EAPOL_ITF   *pITFWalker = NULL;
    EAPOL_ITF   *pITFTemp = NULL;

    if (pITF == NULL)
    {
        TRACE0 (EAPOL, "ElRemoveITFFromTable: Deleting NULL ITF, returning");
        return;
    }

    dwIndex = ElHashInterfaceDescToBucket (pITF->pwszInterfaceDesc);
    pITFWalker = g_ITFTable.pITFBuckets[dwIndex].pItf;
    pITFTemp = pITFWalker;

    while (pITFTemp != NULL)
    {
        if (wcsncmp (pITFTemp->pwszInterfaceGUID, 
                    pITF->pwszInterfaceGUID, wcslen(pITF->pwszInterfaceGUID)) == 0)
        {
            // Entry is at head of list in table
            if (pITFTemp == g_ITFTable.pITFBuckets[dwIndex].pItf)
            {
                g_ITFTable.pITFBuckets[dwIndex].pItf = pITFTemp->pNext;
            }
            else
            {
                // Entry is inside list in table
                pITFWalker->pNext = pITFTemp->pNext;
            }
        
            break;
        }

        pITFWalker = pITFTemp;
        pITFTemp = pITFWalker->pNext;
    }

    return;
}


//
// ElNdisuioEnumerateInterfaces
// 
// Description:
//
// Function called to enumerate the interfaces on which NDISUIO is bound
//
// Arguments:
//      pItfBuffer - Pointer to buffer which will hold interface details
//      dwAvailableInterfaces - Number of interfaces for which details can
//                      be held in pItfBuffer
//      dwBufferSize - Number of bytes in pItfBuffer
//
// Return values:
// 

DWORD
ElNdisuioEnumerateInterfaces (
        IN OUT  PNDIS_ENUM_INTF     pItfBuffer,
        IN      DWORD               dwAvailableInterfaces,
        IN      DWORD               dwBufferSize
        )
{
    DWORD       dwDesiredAccess;
    DWORD       dwShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;
    DWORD       dwCreationDistribution;
    DWORD       dwFlagsAndAttributes;
    HANDLE      hTemplateFile;
    HANDLE      hHandle;
    DWORD       dwBytesReturned = 0;
    INT         i;
    CHAR        Buf[1024];
    DWORD       BufLength = sizeof(Buf);
    DWORD       BytesWritten = 0;
    PNDISUIO_QUERY_BINDING pQueryBinding = NULL;
    PCHAR       pTempBuf = NULL;
    DWORD       dwRetCode = NO_ERROR;

    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    dwCreationDistribution = OPEN_EXISTING;
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
    hTemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    TRACE0 (DEVICE, "ElNdisuioEnumerateInterfaces: Opening handle");

    do 
    {

        hHandle = CreateFileA (
                    pNdisuioDevice,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    0,
                    NULL
                    );

        if (hHandle == INVALID_HANDLE_VALUE)
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Failed in CreateFile with error %d", dwRetCode);

            break;
        }

        // Send IOCTL to ensure NDISUIO binds to all relevant interfaces

        if (!DeviceIoControl (
                    hHandle,
                    IOCTL_NDISUIO_BIND_WAIT,
                    NULL,
                    0,
                    NULL,
                    0,
                    &dwBytesReturned,
                    NULL))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Failed in DeviceIoCoontrol NDISUIO_BIND_WAIT with error %d", dwRetCode);
            break;
        }
    
        pQueryBinding = (PNDISUIO_QUERY_BINDING)Buf;

        pTempBuf = (PBYTE)pItfBuffer + dwBufferSize;

        i = 0;
        for (pQueryBinding->BindingIndex = i;
            pQueryBinding->BindingIndex < dwAvailableInterfaces;
            pQueryBinding->BindingIndex = ++i)
        {

            // Query for one interface at a time
            
            if (DeviceIoControl (
                    hHandle,
                    IOCTL_NDISUIO_QUERY_BINDING,
                    pQueryBinding,
                    sizeof(NDISUIO_QUERY_BINDING),
                    Buf,
                    BufLength,
                    &BytesWritten,
                    NULL))
            {
                TRACE3 (DEVICE, "NdisuioEnumerateInterfaces: NDISUIO bound to: (%ld) %ws\n     - %ws\n",
                    pQueryBinding->BindingIndex,
                    (PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset,
                    (PUCHAR)pQueryBinding + pQueryBinding->DeviceDescrOffset);

                pTempBuf = pTempBuf - ((pQueryBinding->DeviceNameLength + 7) & 0xfffffff8);

                if (((PBYTE)pTempBuf - (PBYTE)&pItfBuffer->Interface[pItfBuffer->TotalInterfaces]) <= 0)
                {
                    // Going beyond start of buffer, Error
                    TRACE0 (DEVICE, "NdisuioEnumerateInterfaces: DeviceName: Memory being corrupted !!!");
                    dwRetCode = ERROR_INVALID_DATA;
                    break;
                }

                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Buffer = (PWCHAR) pTempBuf;


                memcpy ((BYTE *)(pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Buffer), (BYTE *)((PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset), (pQueryBinding->DeviceNameLength ));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Length = (SHORT) ( pQueryBinding->DeviceNameLength );
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.MaximumLength = (SHORT) ( pQueryBinding->DeviceNameLength );

                pTempBuf = pTempBuf - ((pQueryBinding->DeviceDescrLength + 7) & 0xfffffff8);;

                if (((PBYTE)pTempBuf - (PBYTE)&pItfBuffer->Interface[pItfBuffer->TotalInterfaces]) <= 0)
                {
                    // Going beyond start of buffer, Error
                    TRACE0 (DEVICE, "NdisuioEnumerateInterfaces: DeviceDescr: Memory being corrupted !!!");
                    dwRetCode = ERROR_INVALID_DATA;
                    break;
                }

                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Buffer = (PWCHAR) pTempBuf;


                memcpy ((pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Buffer), (PWCHAR)((PUCHAR)pQueryBinding + pQueryBinding->DeviceDescrOffset), (pQueryBinding->DeviceDescrLength ));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Length = (SHORT) (pQueryBinding->DeviceDescrLength );
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.MaximumLength = (SHORT) (pQueryBinding->DeviceDescrLength );

                pItfBuffer->TotalInterfaces++;

                memset(Buf, 0, BufLength);
            }
            else
            {
                dwRetCode = GetLastError ();
                if (dwRetCode != ERROR_NO_MORE_ITEMS)
                {
                    TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: DeviceIoControl terminated for with IOCTL_NDISUIO_QUERY_BINDING with error %ld",
                            dwRetCode);
                }
                else
                {
                    // Reset error, since it only indicates end-of-list
                    dwRetCode = NO_ERROR;
                    TRACE0 (DEVICE, "ElNdisuioEnumerateInterfaces: DeviceIoControl IOCTL_NDISUIO_QUERY_BINDING has no more entries");
                }
                break;
            }
        }
            
    } while (FALSE);

    // Cleanup 

    if (hHandle != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hHandle))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Error in CloseHandle %d", dwRetCode);
        }
    }
         
    return dwRetCode;
}


//
// ElShutdownInterface
// 
// Description:
//
// Function called to stop EAPOL state machine, close handle to NDISUIO and
//  remove existence of the interface from the module
//
// Arguments:
//      pwszDeviceGUID - Pointer to interface GUID
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
// 

DWORD
ElShutdownInterface (
        IN  WCHAR   *pwszDeviceGUID
        )
{
    WCHAR       *pwszGUID = NULL;
    EAPOL_PCB   *pPCB = NULL;
    EAPOL_ITF   *pITF = NULL;
    HANDLE      hDevice = NULL;
    DWORD       dwRetCode = NO_ERROR;

    do
    {

        TRACE1 (DEVICE, "ElShutdownInterface: Called for interface removal for %ws",
                pwszGUID);

        pwszGUID = MALLOC ( (wcslen (pwszDeviceGUID) + 1) * sizeof(WCHAR));
        if (pwszGUID == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (DEVICE, "ElShutdownInterface: MALLOC failed for pwszGUID");
            break;
        }

        wcscpy (pwszGUID, pwszDeviceGUID);

        ACQUIRE_WRITE_LOCK (&(g_ITFLock));

        // Check if EAPOL was actually started on this interface
        // Verify by checking existence of corresponding 
        // entry in hash table
    
        ACQUIRE_WRITE_LOCK (&(g_PCBLock));

        if ((pPCB = ElGetPCBPointerFromPortGUID(pwszGUID))
                != NULL)
        {
            RELEASE_WRITE_LOCK (&(g_PCBLock));
            TRACE0 (DEVICE, "ElShutdownInterface: Found PCB entry for interface");

            if ((pITF = ElGetITFPointerFromInterfaceDesc(
                            pPCB->pwszFriendlyName))
                            == NULL)
            {
                TRACE0 (DEVICE, "ElShutdownInterface: Did not find ITF entry when PCB exits, HOW BIZARRE !!!");
            }
    
            if ((dwRetCode = ElDeletePort (
                            pwszGUID, 
                            &hDevice)) != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElShutdownInterface: Error in deleting port for %ws", 
                    pPCB->pwszDeviceGUID);
            }
    
            // Remove interface entry from interface table
            
            if (pITF != NULL)
            {
                ElRemoveITFFromTable(pITF);
                        
                if (pITF->pwszInterfaceDesc)
                {
                    FREE (pITF->pwszInterfaceDesc);
                }
                if (pITF->pwszInterfaceGUID)
                {
                    FREE (pITF->pwszInterfaceGUID);
                }
                if (pITF)
                {
                    FREE (pITF);
                }
            }
    
            // Close the handle to the NDISUIO driver

            if (hDevice != NULL)
            {
                if ((dwRetCode = ElCloseInterfaceHandle (hDevice, pwszGUID)) 
                        != NO_ERROR)
                {
                    TRACE1 (DEVICE, 
                        "ElShutdownInterface: Error in ElCloseInterfaceHandle %d", 
                        dwRetCode);
                }
            }
    
            TRACE1 (DEVICE, "ElShutdownInterface: Port deleted (%ws)", 
                    pwszGUID);
    
        }
        else
        {
            RELEASE_WRITE_LOCK (&(g_PCBLock));

            // Ignore device removal 
            
            TRACE0 (DEVICE, "ElShutdownInterface: ElGetPCBPointerFromPortGUID did not find any matching entry, ignoring interface REMOVAL");
    
        }
    
        RELEASE_WRITE_LOCK (&(g_ITFLock));

    } while (FALSE);

    if (pwszGUID != NULL)
    {
        FREE (pwszGUID);
    }

    return dwRetCode;
}


//
// ElCreateInterfaceEntry
// 
// Description:
//
// Function called to create an entry in the global interface table
//
// Arguments:
//      pwszInterfaceGUID - Pointer to interface GUID
//      pwszInterfaceDescription - Pointer to interface Description
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
// 

DWORD
ElCreateInterfaceEntry (
        IN  WCHAR       *pwszInterfaceGUID,
        IN  WCHAR       *pwszInterfaceDescription
        )
{
    EAPOL_ITF * pNewITF = NULL;
    DWORD       dwIndex = 0;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        dwIndex = ElHashInterfaceDescToBucket (pwszInterfaceDescription);
                    
        pNewITF = (PEAPOL_ITF) MALLOC (sizeof (EAPOL_ITF));
                    
        if (pNewITF == NULL) 
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pNewITF->pwszInterfaceGUID = 
            (WCHAR *) MALLOC ((wcslen(pwszInterfaceGUID) + 1)*sizeof(WCHAR));
        if (pNewITF->pwszInterfaceGUID == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pNewITF->pwszInterfaceDesc = 
            (WCHAR *) MALLOC ((wcslen(pwszInterfaceDescription) + 1)*sizeof(WCHAR));
        if (pNewITF->pwszInterfaceDesc == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy (pNewITF->pwszInterfaceGUID, pwszInterfaceGUID);
        
        wcscpy (pNewITF->pwszInterfaceDesc, pwszInterfaceDescription);

        pNewITF->pNext = g_ITFTable.pITFBuckets[dwIndex].pItf;
        g_ITFTable.pITFBuckets[dwIndex].pItf = pNewITF;


        TRACE3 (DEVICE, "ElCreateInterfaceEntry: Added to hash table GUID= %ws : Desc= %ws at Index=%d",
                pNewITF->pwszInterfaceGUID,
                pNewITF->pwszInterfaceDesc,
                dwIndex
                );
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pNewITF)
        {
            if (pNewITF->pwszInterfaceDesc)
            {
                FREE (pNewITF->pwszInterfaceDesc);
            }
            if (pNewITF->pwszInterfaceGUID)
            {
                FREE (pNewITF->pwszInterfaceGUID);
            }

            FREE (pNewITF);
        }
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eldialog.c ===
/*++
Copyright (c) 2000, Microsoft Corporation

Module Name:
    eldialog.cpp

Abstract:
    Module to handle the communication from 802.1X state machine to netshell

Revision History:

    sachins, March 20, 2001, Created

--*/

#include "pcheapol.h"
#pragma hdrstop
#include <netconp.h>
#include <dbt.h>
#include "eldialog.h"


//
// WZCNetmanConnectionStatusChanged
// 
// Description:
//
// Function called to update NCS status with netman
//
// Arguments:
//      pGUIDConn - Interface GUID
//      ncs - NETCON_STATUS of GUID
//
// Return values:
//      HRESULT
//

HRESULT 
WZCNetmanConnectionStatusChanged (
        IN  GUID            *pGUIDConn,
        IN  NETCON_STATUS   ncs
        )
{
    HRESULT hr = S_OK;
    INetConnectionRefresh *pNetmanNotify = NULL;

    TRACE0 (NOTIFY, "WZCNetmanConnectionStatusChanged: Entered");

    if (!g_fTrayIconReady)
    {
        return hr;
    }

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED (hr))
    {

        hr = CoCreateInstance (
                &CLSID_ConnectionManager, 
                NULL,
                CLSCTX_ALL,
                &IID_INetConnectionRefresh, 
                (LPVOID *)&pNetmanNotify);

        if (SUCCEEDED (hr))
        {
            TRACE0 (NOTIFY, "QueueEvent: CoCreateInstance succeeded");

            pNetmanNotify->lpVtbl->ConnectionStatusChanged (
                    pNetmanNotify, pGUIDConn, ncs);

            pNetmanNotify->lpVtbl->Release (pNetmanNotify);
        }
        else
        {
            TRACE0 (NOTIFY, "ConnectionStatusChanged: CoCreateInstance failed");
        }
    
        CoUninitialize ();
    }
    else
    {
        TRACE0 (NOTIFY, "ConnectionStatusChanged: CoInitializeEx failed");
    }


    TRACE0 (NOTIFY, "ConnectionStatusChanged completed");

    return hr;
}


//
// WZCNetmanShowBalloon
// 
// Description:
//
// Function called to display balloon on tray icon
//
// Arguments:
//      pGUIDConn - Interface GUID
//      pszCookie - Cookie for the transaction
//      pszBalloonText - Balloon text to be displayed
//
// Return values:
//      HRESULT
//

HRESULT 
WZCNetmanShowBalloon (
        IN  GUID            *pGUIDConn,
        IN  BSTR            pszCookie,
        IN  BSTR            pszBalloonText
        )
{
    HRESULT hr = S_OK;
    INetConnectionRefresh *pNetmanNotify = NULL;

    TRACE0 (NOTIFY, "WZCNetmanShowBalloon: Entered");

    if (!g_fTrayIconReady)
    {
        return hr;
    }

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED (hr))
    {

        hr = CoCreateInstance (
                &CLSID_ConnectionManager, 
                NULL,
                CLSCTX_ALL,
                &IID_INetConnectionRefresh, 
                (LPVOID *)&pNetmanNotify);

        if (SUCCEEDED (hr))
        {
            TRACE0 (NOTIFY, "WZCNetmanShowBalloon: CoCreateInstance succeeded");

            pNetmanNotify->lpVtbl->ShowBalloon 
                (pNetmanNotify, pGUIDConn, pszCookie, pszBalloonText);
            pNetmanNotify->lpVtbl->Release (pNetmanNotify);
        }
        else
        {
            TRACE0 (NOTIFY, "WZCNetmanShowBalloon: CoCreateInstance failed");
        }
    
        CoUninitialize ();
    }
    else
    {
        TRACE0 (NOTIFY, "WZCNetmanShowBalloon: CoInitializeEx failed");
    }


    TRACE0 (NOTIFY, "WZCNetmanShowBalloon completed");

    return hr;
}


//
//  EAPOLQueryGUIDNCSState
//
//  Purpose:    Called by Netman module query the ncs state of the 
//              GUID
//
//  Arguments:
//      pGuidConn - Interface GUID
//      pncs - NCS status of the interface
//
//  Returns:    
//      S_OK - no error
//      !S_OK - error
//

HRESULT 
EAPOLQueryGUIDNCSState ( 
        IN      GUID            * pGuidConn, 
        OUT     NETCON_STATUS   * pncs 
        )
{
    WCHAR       wszGuid[GUID_STRING_LEN_WITH_TERM];
    CHAR        szGuid[GUID_STRING_LEN_WITH_TERM];
    EAPOL_PCB   *pPCB = NULL;
    DWORD       dwRetCode = NO_ERROR;
    HRESULT     hr = S_OK;

    InterlockedIncrement (&g_lWorkerThreads);

    do
    {
        if (g_dwModulesStarted != ALL_MODULES_STARTED)
        {
            hr = S_FALSE;
            break;
        }

        StringFromGUID2 (pGuidConn, wszGuid, GUID_STRING_LEN_WITH_TERM);

        ACQUIRE_WRITE_LOCK (&g_PCBLock);

        pPCB = ElGetPCBPointerFromPortGUID (wszGuid);

        if (pPCB)
        {
            EAPOL_REFERENCE_PORT (pPCB);
        }

        RELEASE_WRITE_LOCK (&g_PCBLock);

        if (pPCB == NULL)
        {
            hr = S_FALSE;
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        if (pPCB->fIsRemoteEndEAPOLAware)
        {
            switch (pPCB->State)
            {
                case EAPOLSTATE_LOGOFF:
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_DISCONNECTED:
                    if (pPCB->dwAuthFailCount >= pPCB->dwTotalMaxAuthFailCount)
                    {
                        *pncs = NCS_AUTHENTICATION_FAILED;
                        break;
                    }
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_CONNECTING:
                    hr = S_FALSE;
                    break;
                case EAPOLSTATE_ACQUIRED:
                    *pncs = NCS_CREDENTIALS_REQUIRED;
                    break;
                case EAPOLSTATE_AUTHENTICATING:
                    *pncs = NCS_AUTHENTICATING;
                    break;
                case EAPOLSTATE_HELD:
                    *pncs = NCS_AUTHENTICATION_FAILED;
                    break;
                case EAPOLSTATE_AUTHENTICATED:
                    *pncs = NCS_AUTHENTICATION_SUCCEEDED;
                    break;
                default:
                    hr = S_FALSE;
                    break;
            }
        }
        else
        {
            hr = S_FALSE;
        }

        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

        EAPOL_DEREFERENCE_PORT (pPCB);
    }
    while (FALSE);

    InterlockedDecrement (&g_lWorkerThreads);

    return hr;
}

//
//  EAPOLTrayIconReady
//
//  Purpose:    Called by Netman module to inform about Tray being
//              ready for notifications from WZCSVC
//
//  Arguments:
//      pszUserName - Username of the user logged in on the desktop
//
//  Returns:    
//      NONE
//

VOID
EAPOLTrayIconReady (
        IN  const   WCHAR   * pwszUserName
        )
{
    BOOLEAN fDecrWorkerThreadCount = FALSE;
    PVOID   pvContext = NULL;
    DWORD   dwRetCode = NO_ERROR;

    TRACE1 (NOTIFY, "EAPOLTrayIconReady: Advise username = %ws", pwszUserName);

    do
    {
        pvContext = (VOID *) MALLOC ((wcslen(pwszUserName)+1)*sizeof(WCHAR));
        if (pvContext == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (NOTIFY, "EAPOLTrayIconReady: MALLOC failed for pvContext");
            break;
        }

        memcpy (pvContext, (PVOID)pwszUserName, (wcslen(pwszUserName)+1)*sizeof(WCHAR));

        InterlockedIncrement (&g_lWorkerThreads);

        fDecrWorkerThreadCount = TRUE;
    
        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)EAPOLTrayIconReadyWorker,
                    (PVOID)pvContext,
                    WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (NOTIFY, "EAPOLTrayIconReady: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            fDecrWorkerThreadCount = FALSE;
        }
    }
    while (FALSE);

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    return;
}


//
//  EAPOLTrayIconReadyWorker
//
//  Purpose:    Called by Netman module to inform about Tray being
//              ready for notifications from WZCSVC
//
//  Arguments:
//      pszUserName - Username of the user logged in on the desktop
//
//  Returns:    
//      NONE
//

DWORD
WINAPI
EAPOLTrayIconReadyWorker (
        IN PVOID    pvContext
        )
{
    HANDLE  hToken = NULL;
    WCHAR   *pwszUserName = NULL;
    WCHAR   *pwszActiveUserName = NULL;
    DWORD   dwLoop = 0;
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        pwszUserName = (WCHAR *)pvContext;
        TRACE1 (NOTIFY, "EAPOLTrayIconReadyWorker: Advise username = %ws", pwszUserName);

        // Loop 3 times, since there have been timing issues between
        // notification coming through and the call failing
        while ((dwLoop++) < 3)
        {
        dwRetCode = NO_ERROR;
        Sleep (1000);

        if (g_dwCurrentSessionId != 0xffffffff)
        {
            if (hToken != NULL)
            {
                if (!CloseHandle (hToken))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (NOTIFY, "EAPOLTrayIconReadyWorker: CloseHandle failed with error (%ld)",
                            dwRetCode);
                    dwRetCode = NO_ERROR;
                }
                hToken = NULL;
            }


            if (pwszActiveUserName != NULL)
            {
                FREE (pwszActiveUserName);
                pwszActiveUserName = NULL;
            }

            if ((dwRetCode = ElGetWinStationUserToken (g_dwCurrentSessionId, &hToken))
                    != NO_ERROR)
            {
                TRACE1 (NOTIFY, "EAPOLTrayIconReadyWorker: ElGetWinStationUserToken failed with error %ld",
                        dwRetCode);
                continue;
            }
            
            if ((dwRetCode = ElGetLoggedOnUserName (hToken, &pwszActiveUserName))
                        != NO_ERROR)
            {
                TRACE1 (NOTIFY, "EAPOLTrayIconReadyWorker: ElGetLoggedOnUserName failed with error %ld",
                        dwRetCode);
                if (dwRetCode == ERROR_BAD_IMPERSONATION_LEVEL)
                {
                    break;
                }
                continue;
            }

            if (!wcscmp (pwszUserName, pwszActiveUserName))
            {
                TRACE1 (NOTIFY, "EAPOLTrayIconReadyWorker: Tray icon ready for username %ws", 
                        pwszUserName);
                g_fTrayIconReady = TRUE;
                break;
            }
        }
        else
        {
            TRACE0 (NOTIFY, "EAPOLTrayIconReadyWorker: No user logged on");
        }

        } // while
    }
    while (FALSE);

    if (hToken != NULL)
    {
        CloseHandle (hToken);
    }

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    if (pwszActiveUserName != NULL)
    {
        FREE (pwszActiveUserName);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eldeviceio.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eldeviceio.h

Abstract:

    This module contains declarations for media-management and device I/O.
    The module interfaces with WMI, NDIS for device managment, and NDIS UIO
    for read/write of data.
    The routines declared here operate asynchronously on the handles 
    associated with an I/O completion port opened on the ndis uio driver. 


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_DEVICEIO_H_
#define _EAPOL_DEVICEIO_H_

//
// Hash table definition for interfaces
//

typedef struct _EAPOL_ITF
{
    struct _EAPOL_ITF  *pNext;
    WCHAR              *pwszInterfaceDesc; // Friendly name of interface
    WCHAR              *pwszInterfaceGUID; // GUID 
} EAPOL_ITF, *PEAPOL_ITF;


typedef struct _ITF_BUCKET
{
    EAPOL_ITF           *pItf;
} ITF_BUCKET, *PITF_BUCKET;


typedef struct _ITF_TABLE
{
    ITF_BUCKET          *pITFBuckets;
    DWORD               dwNumITFBuckets;
} ITF_TABLE, *PITF_TABLE;


//
// Variables global to eldeviceio.h
//

// Interface table containing interface friendly-name GUID pair

ITF_TABLE           g_ITFTable;         

// Read-write lock for interface table synchronization

READ_WRITE_LOCK     g_ITFLock;          


//
// FUNCTION DECLARATIONS
//

DWORD
ElMediaInit (
        );

DWORD
ElMediaDeInit (
        );

DWORD
ElMediaEventsHandler (
        IN  PWZC_DEVICE_NOTIF   pwzcDeviceNotif
        );

DWORD
ElMediaSenseRegister (
        IN  BOOL            Register
        );

VOID
ElMediaSenseCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        );

DWORD
WINAPI
ElMediaSenseCallbackWorker (
        IN PVOID            pvContext
        );

DWORD
ElBindingsNotificationRegister (
        IN  BOOL            fRegister
        );

VOID
ElBindingsNotificationCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        );

DWORD
WINAPI
ElBindingsNotificationCallbackWorker (
        IN PVOID            pvContext
        );

DWORD
ElDeviceNotificationRegister (
        IN  BOOL            fRegister
        );

DWORD
ElDeviceNotificationHandler (
        IN  PVOID           lpEventData,
        IN  DWORD           dwEventType
        );

DWORD
WINAPI
ElDeviceNotificationHandlerWorker (
        IN  PVOID           pvContext
        );

DWORD
ElEnumAndOpenInterfaces (
        IN WCHAR            *pwszDesiredDescription,
        IN WCHAR            *pwszDesiredGUID,
        IN DWORD            dwHandle,
        IN PRAW_DATA        prdUserData
        );

DWORD
ElOpenInterfaceHandle (
        IN  WCHAR           *pwszDeviceName,
        OUT HANDLE          hDevice
        );

DWORD
ElCloseInterfaceHandle (
        IN  HANDLE          hDevice,
        IN  LPWSTR          pwszDeviceGUID
        );

DWORD
ElReadFromInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElWriteToInterface (
        IN HANDLE  hDevice,
        IN PEAPOL_BUFFER    pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElGetCardStatus (
        UNICODE_STRING      *pInterface,
        DWORD               *pdwNetCardStatus,
        DWORD               *pdwMediaType
        );

DWORD
ElHashInterfaceDescToBucket (
        IN WCHAR            *pwszInterfaceDesc
        );

PEAPOL_ITF
ElGetITFPointerFromInterfaceDesc (
        IN WCHAR            *pwszInterfaceDesc
        );

VOID
ElRemoveITFFromTable (
        IN EAPOL_ITF        *pITF
        );

DWORD
ElNdisuioEnumerateInterfaces (
        IN OUT  PNDIS_ENUM_INTF     pItfBuffer,
        IN      DWORD               dwAvailableInterfaces,
        IN      DWORD               dwBufferSize
        );

DWORD
ElShutdownInterface (
        IN      WCHAR               *pwszGUID
        );

DWORD
ElCreateInterfaceEntry (
        IN      WCHAR               *pwszInterfaceGUID,
        IN      WCHAR               *pwszInterfaceDescription
        );

#endif //_EAPOL_DEVICEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\elglobals.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elglobals.h

Abstract:

    This module contains declaration of global variables


Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_GLOBALS_H_
#define _EAPOL_GLOBALS_H_

// Current threads alive
LONG                g_lWorkerThreads;

// Current contexts alive
LONG                g_lPCBContextsAlive;

// Current count of allocated PCBs
ULONG               g_MaxPorts;         

// Global read-write lock for PCB Hash bucket list
READ_WRITE_LOCK     g_PCBLock;          

// Structure used to define hash-table entities
typedef struct _PCB_BUCKET              
{                                       
    EAPOL_PCB       *pPorts;
} PCB_BUCKET, *PPCB_BUCKET;

typedef struct _PCB_TABLE
{
    PCB_BUCKET      *pPCBBuckets;
    DWORD           dwNumPCBBuckets;
} PCB_TABLE, *PPCB_TABLE;


// EAPOL PCB table
PCB_TABLE           g_PCBTable;         

// Handle to event log
HANDLE              g_hLogEvents;       

// Identifier of trace output
DWORD               g_dwTraceId;        


// Pool of reusable read-write locks
PDYNAMIC_LOCKS_STORE g_dlsDynamicLockStore;  


// Global indication as to whether user has logged on
BOOLEAN             g_fUserLoggedOn;     

// Global indication as to which session is currently being/authenticated
DWORD               g_dwCurrentSessionId;     

// Global flag to indicate tray icon ready for notification
BOOLEAN             g_fTrayIconReady;

// Global timer queue for queueing timers using thread pool
HANDLE              g_hTimerQueue;

// Device notification registration handle
HANDLE              g_hDeviceNotification;

//
// EAPOL globals
//

// Max number of EAPOL_STARTs that can be sent out without response
DWORD               g_dwmaxStart;         

// Default time interval in secs between two EAPOL_STARTs
DWORD               g_dwstartPeriod;      

// Default time interval in secs between sending EAP_Resp/Id and not
// receiving any authenticator packet
DWORD               g_dwauthPeriod;       

// Default time in secs held in case of received EAP_Failure
DWORD               g_dwheldPeriod;       

// Supplicant modes of operation
DWORD               g_dwSupplicantMode;       

// Supplicant modes of operation
DWORD               g_dwEAPOLAuthMode;       

// Global read-write lock for EAPOL configuration
READ_WRITE_LOCK     g_EAPOLConfig;          

// 802.1X Ethertype
extern BYTE g_bEtherType8021X[SIZE_ETHERNET_TYPE];


//
// EAP Globals
//

// Table containing pointer to functions of different EAP dlls
EAP_INFO            *g_pEapTable;

// Number of EAP protocols for which DLLs are loaded
DWORD               g_dwNumEapProtocols;

// Global UI transaction Id counter
DWORD               g_dwEAPUIInvocationId;

// Certificate authority root name
BYTE                *g_pbCARootHash;

// Read-write lock for Policy parameters
READ_WRITE_LOCK     g_PolicyLock;          

// Global Policy setting
EAPOL_POLICY_LIST   *g_pEAPOLPolicyList;

//
// EAPOL service globals
//

// Event to exit main service thread
HANDLE              g_hStopService;

// Event to indicate shutdown of EAPOL module and cleanup threads
HANDLE              g_hEventTerminateEAPOL;

SERVICE_STATUS_HANDLE   g_hServiceStatus;

SERVICE_STATUS      g_ServiceStatus;

DWORD               g_dwModulesStarted;

// Global values for NLA

HANDLE              g_hNLA_LPC_Port;

PORT_VIEW           g_ClientView;

READ_WRITE_LOCK     g_NLALock;


// Global table for UI Response function

EAPOLUIRESPFUNCMAP  EapolUIRespFuncMap[NUM_EAPOL_DLG_MSGS];

// Default SSID value

extern  BYTE                g_bDefaultSSID[MAX_SSID_LEN];


#endif  // _EAPOL_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eleap.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eleap.h

Abstract:
e   This module contains the definitions and declarations related to 
    EAP protocol


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_EAP_H_
#define _EAPOL_EAP_H_

//#define EAP_DUMPW(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,4,1,NULL)
//#define EAP_DUMPB(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,1,1,NULL)


//
// Structure used to hold information about EAP DLLs that are loaded
//

typedef struct _EAP_INFO 
{
    // Handle to loaded EAP DLL
    HINSTANCE       hInstance;
    
    // Struture holding pointer to mandatory EAP DLL entrypoints
    PPP_EAP_INFO    RasEapInfo;

} EAP_INFO, *PEAP_INFO;

// 
// Structure used to hold port/connection configuration blob
// received from the EAP DLL, using RasEapInvokeConfigUI
//
typedef struct _ELEAP_SET_CUSTOM_AUTH_DATA
{
    BYTE        *pConnectionData;
    DWORD       dwSizeOfConnectionData;

} ELEAP_SET_CUSTOM_AUTH_DATA;

// 
// Structure used to hold data blob
// received from the EAP DLL, using RasEapInvokeInteractiveUI
//
typedef struct _ELEAP_INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    BYTE        *pbUIContextData;
    DWORD       dwSizeOfUIContextData;

} ELEAP_INVOKE_EAP_UI;

//
// Structure used to pass results and data between EAP processing and EAPOL
//

typedef struct _ELEAP_RESULT
{
    ELEAP_ACTION    Action;

    //
    // The packet ID which will cause the timeout for this send to be removed
    // from the timer queue.  Otherwise, the timer queue is not touched.  The
    // packet received is returned to the AP regardless of whether the timer
    // queue is changed.
    //

    BYTE            bIdExpected;

    //
    // dwError is valid only with an Action code of Done or SendAndDone.  0
    // indicates succesful authentication.  Non-0 indicates unsuccessful
    // authentication with the value indicating the error that occurred.
    //

    DWORD	        dwError;

    //
    // Valid only when dwError is non-0.  Indicates whether client is allowed
    // to retry without restarting authentication.  (Will be true in MS
    // extended CHAP only)
    //

    BOOL            fRetry;

    CHAR            szUserName[ UNLEN + 1 ];

    //
    // Set to attributes to be used for this user. If this is NULL, attributes 
    // from the authenticator will be used for this user. It is upto the
    // allocater of this memory to free it. Must be freed during the RasCpEnd 
    // call. 
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Used by MS-CHAP to pass the challenge used during the authentication
    // protocol. These 8 bytes are used as the variant for the 128 bit
    // encryption keys.
    //

    BYTE                            abChallenge[MAX_CHALLENGE_SIZE];

    BYTE                            abResponse[MAX_RESPONSE_SIZE];

    // Size of EAP packet constructed by EAP DLL
    WORD                            wSizeOfEapPkt;

    // Does RasEapInvokeInteractiveUI entrypoint need to be invoked?
    BOOL                            fInvokeEapUI;

    // Data obtained via RasEapInvokeInteractiveUI entrypoint of the DLL
    ELEAP_INVOKE_EAP_UI             InvokeEapUIData;

    // EAP type e.g. for EAP-TLS = 13
    DWORD                           dwEapTypeId;

    // Does user data blob created by EAP DLL need to be stored in the
    // registry
    BOOL                            fSaveUserData;
    
    // User data blob created by EAP DLL
    BYTE                            *pUserData;

    // Size of user data blob created by EAP DLL
    DWORD                           dwSizeOfUserData;

    // Does connection data blob created by EAP DLL need to be stored in the
    // registry
    BOOL                            fSaveConnectionData;

    // Connection data blob created by EAP DLL
    ELEAP_SET_CUSTOM_AUTH_DATA      SetCustomAuthData;
    
    // Notification text extracted from EAP-Notification message
    CHAR                            *pszReplyMessage;
  
} ELEAP_RESULT;


//
//
// FUNCTION DECLARATIONS
//

DWORD
ElEapInit (
        IN  BOOL            fInitialize
    );

DWORD
ElEapBegin (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElEapEnd (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElEapMakeMessage (
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElMakeSupplicantMessage (
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElEapDllBegin (
        IN EAPOL_PCB        *pPCB,
        IN DWORD            dwEapIndex
        );

DWORD
ElEapDllWork ( 
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElEapDllEnd (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElGetEapTypeIndex ( 
        IN  DWORD           dwEapType
        );

#endif // _EAPOL_EAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\elip6.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    elip6.h

Abstract:

    This module contains the interface to the IPv6 stack.

    Required, since the IPv6 stack needs restart its protocol
    mechanisms on the link once authentication succeeds.

Author:

    Mohit Talwar (mohitt) Fri Apr 20 12:05:23 2001

--*/


DWORD
Ip6RenewInterface (
    IN  WCHAR           *pwszInterface
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eldialog.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eldialog.h

Abstract:
    Module to handle the communication from 802.1X state machine to netshell

Revision History:

    sachins, March 21, 2001, Created

--*/

#ifndef _EAPOL_DIALOG_H_
#define _EAPOL_DIALOG_H_

#pragma once

typedef enum _EAPOL_NCS_STATUS
{
    EAPOL_NCS_NOTIFICATION,
    EAPOL_NCS_AUTHENTICATING,
    EAPOL_NCS_AUTHENTICATION_SUCCEEDED,
    EAPOL_NCS_AUTHENTICATION_FAILED,
    EAPOL_NCS_CRED_REQUIRED
} EAPOL_NCS_STATUS;

HRESULT 
WZCNetmanConnectionStatusChanged (
    IN  GUID            *pGUIDConn,
    IN  NETCON_STATUS   ncs
    );

HRESULT 
WZCNetmanShowBalloon (
    IN  GUID            *pGUIDConn,
    IN  BSTR            pszCookie,
    IN  BSTR            pszBalloonText
    );

HRESULT 
EAPOLQueryGUIDNCSState ( 
    IN  GUID            * pGuidConn, 
    OUT NETCON_STATUS   * pncs 
    );

VOID
EAPOLTrayIconReady (
    IN const WCHAR      * pszUserName
    );

DWORD
WINAPI
EAPOLTrayIconReadyWorker (
        IN PVOID    pvContext
        );

#endif // _EAPOL_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\elip6.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    elip6.c

Abstract:

    This module contains the interface to the IPv6 stack.

    Required, since the IPv6 stack needs restart its protocol
    mechanisms on the link once authentication succeeds.

Author:

    Mohit Talwar (mohitt) Fri Apr 20 12:05:23 2001

--*/

#include "pcheapol.h"
#pragma hdrstop

//
// Ip6RenewInterface
//
// Description:
//
// Function called from within FSMAutheticated i.e. once authentication
// has completed successfully.  The IPv6 stack is instructed to restart
// its protocol mechanism on the indicated interface.
//
// Arguments:
//      pwszInterface   - Adapter name (GUID identifying the interface).
//
// Return values:
//      NO_ERROR on success, Error code o/w.
//

DWORD
Ip6RenewInterface (
    IN  WCHAR           *pwszInterface
    )
{
    HANDLE                  hIp6Device;
    IPV6_QUERY_INTERFACE    Query;
    UINT                    BytesReturned;
    DWORD                   dwError = NO_ERROR;

    do
    {
    
        // We could make the hIp6Device handle a global/static variable.
        // The first successful call to CreateFileW in Ip6RenewInterface
        // would initialize it with a handle to the IPv6 Device.  This would
        // be used for all subsequent DeviceIoControl requests.
        //
        // Since this function is not called in a thread safe environment,
        // we would need to perform an InterlockedCompareExchange after
        // calling CreateFileW.  This is needed to ensure that no handles
        // are leaked.  Also, since this service would have an open handle
        // to tcpip6.sys, we would not be able to unload that driver.
        //
        // For now, however, we keep things simple and open and close this
        // handle every time Ip6RenewInterface is called.
        hIp6Device = CreateFileW(
            WIN_IPV6_DEVICE_NAME,
            GENERIC_WRITE,          // requires administrator privileges
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,                   // security attributes
            OPEN_EXISTING,
            0,                      // flags & attributes
            NULL);                  // template file        
        if (hIp6Device == INVALID_HANDLE_VALUE)
        {
            dwError = GetLastError();
            TRACE1 (ANY, "Ip6RenewInterface: CreateFileW failed with error %ld",
                    dwError);
            break;
        }
    
        // Pretend as though the interface was reconnected.  This causes
        // IPv6 to resend Router Solicitation|Advertisement, Multicast
        // Listener Discovery, and Duplicate Address Detection messages.
        Query.Index = 0;
        if ((dwError = ElGuidFromString (&(Query.Guid), pwszInterface)) != NO_ERROR)
        {
            TRACE1 (ANY, "Ip6RenewInterface: ElGuidFromString failed with error %ld",
                    dwError);
            break;
        }
    
        if (!DeviceIoControl(
            hIp6Device, 
            IOCTL_IPV6_RENEW_INTERFACE,
            &Query, 
            sizeof Query,
            NULL, 
            0, 
            &BytesReturned, 
            NULL))
        {
            dwError = GetLastError();
            TRACE1 (ANY, "Ip6RenewInterface: DeviceIoControl failed with error %ld",
                    dwError);
            break;
        }
    }
    while (FALSE);

    if (hIp6Device != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hIp6Device);
    }
        
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eleap.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eleap.c

Abstract:
    Module that will do interfacing between the EAPOL engine and the EAP
    implementations

Revision History:

    sachins, May 04 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>
#include <raseapif.h>


//
// ElLoadEapDlls
//
// Description: 
//
// Function called to load all the EAP dlls installed in the PPP
// configuration in the registry
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElLoadEapDlls (
    VOID 
    )
{
    HKEY        hKeyEap             = (HKEY)NULL;
    LPWSTR      pEapDllPath         = (LPWSTR)NULL;
    LPWSTR      pEapDllExpandedPath = (LPWSTR)NULL;
    HKEY        hKeyEapDll          = (HKEY)NULL;
    DWORD       dwRetCode;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       dwRolesSupported = 0;
    DWORD       dwSizeOfRolesSupported = 0;
    DWORD       dwKeyIndex;
    WCHAR       wchSubKeyName[200];
    HINSTANCE   hInstance;
    FARPROC     pRasEapGetInfo;
    PPP_EAP_INFO    RasEapInfo = {0};
    DWORD       cbSubKeyName;
    DWORD       dwSecDescLen;
    DWORD       cbSize;
    DWORD       dwType;
    DWORD       dwEapTypeId;

    //
    // Open the EAP key
    //

    dwRetCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              RAS_EAP_REGISTRY_LOCATION,
                              0,
                              KEY_READ,
                              &hKeyEap);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (EAP,"ElLoadEapDlls: RegOpenKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
        return dwRetCode;
    }

    //
    // Find out how many EAP DLLs there are
    //

    dwRetCode = RegQueryInfoKey (
                                hKeyEap,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (EAP,"ElLoadEapDlls: RegQueryInfoKey failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
        RegCloseKey (hKeyEap);

        return dwRetCode;
    }

    //
    // Allocate space in the table to hold information for each one 
    //

    g_pEapTable= (EAP_INFO*) MALLOC (sizeof(EAP_INFO)*dwNumSubKeys);

    if (g_pEapTable == NULL)
    {
        RegCloseKey (hKeyEap);

        return(GetLastError());
    }

    //
    // Read the registry to find out the various EAPs to load.
    //

    for (dwKeyIndex = 0; dwKeyIndex < dwNumSubKeys; dwKeyIndex++)
    {
        cbSubKeyName = sizeof(wchSubKeyName)/sizeof(WCHAR);

        dwRetCode = RegEnumKeyEx (   
                                hKeyEap,
                                dwKeyIndex,
                                wchSubKeyName,
                                &cbSubKeyName,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if ((dwRetCode != NO_ERROR)      &&
             (dwRetCode != ERROR_NO_MORE_ITEMS))
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegEnumKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
            break;
        }
        else
        {
            if (dwRetCode == ERROR_NO_MORE_ITEMS)
            {
                dwRetCode = NO_ERROR;
                break;
            }
        }

        do 
        {

        dwRetCode = RegOpenKeyEx (
                                hKeyEap,
                                wchSubKeyName,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyEapDll);


        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegOpenKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION\\dll with error = %ld", 
                dwRetCode);
            break;
        }

        //
        // Read in the role of the dll
        //

        dwRolesSupported = RAS_EAP_ROLE_AUTHENTICATEE;
        dwSizeOfRolesSupported = sizeof(DWORD);
        dwRetCode = RegQueryValueEx (
                                hKeyEapDll,
                                RAS_EAP_VALUENAME_ROLES_SUPPORTED,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwRolesSupported,
                                &dwSizeOfRolesSupported);

        if (dwRetCode != NO_ERROR)
        {
            // If no key, then it is an old dll, assume it will work
            // for client
            if (dwRetCode == ERROR_FILE_NOT_FOUND)
            {
                dwRetCode = NO_ERROR;
                dwRolesSupported = RAS_EAP_ROLE_AUTHENTICATEE;
            }
            else
            {
                TRACE1 (EAP,"ElLoadEapDlls: RegQueryValueEx failed for hKeyEapDll\\RAS_EAP_VALUENAME_ROLES_SUPPORTED with error = %ld", 
                    dwRetCode);
                break;
            }
        }

        if (!(dwRolesSupported & RAS_EAP_ROLE_AUTHENTICATEE))
        {
            TRACE1 (EAP, "ElLoadEapDlls: RolesSupported = (%0lx), not Authenticatee type, ignoring dll",
                    dwRolesSupported);
            break;
        }

        dwEapTypeId = _wtol (wchSubKeyName);

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey (
                                hKeyEapDll,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegQueryInfoKey failed for hKeyEapDll with error = %ld", 
                dwRetCode);
            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        cbMaxValueDataSize += sizeof (WCHAR);

        pEapDllPath = (LPWSTR) MALLOC (cbMaxValueDataSize);

        if (pEapDllPath == (LPWSTR)NULL)
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx (
                                hKeyEapDll,
                                RAS_EAP_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                (LPBYTE)pEapDllPath,
                                &cbMaxValueDataSize);

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegQueryValueEx failed for hKeyEapDll\\RAS_EAP_VALUENAME_PATH with error = %ld", 
                dwRetCode);
            break;
        }

        if ((dwType != REG_EXPAND_SZ) && (dwType != REG_SZ))
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            TRACE1 (EAP,"ElLoadEapDlls: Registry corrupt for hKeyEapDll\\RAS_EAP_VALUENAME_PATH with error = %ld", 
                dwRetCode);
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings (pEapDllPath, NULL, 0);

        if (cbSize == 0)
        {
            dwRetCode = GetLastError();
            break;
        }

        pEapDllExpandedPath = (LPWSTR) MALLOC (cbSize*sizeof(WCHAR));

        if (pEapDllExpandedPath == (LPWSTR)NULL)
        {
            dwRetCode = GetLastError();
            break;
        }

        cbSize = ExpandEnvironmentStrings (pEapDllPath,
                                           pEapDllExpandedPath,
                                           cbSize);
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            break;
        }

        hInstance = LoadLibrary (pEapDllExpandedPath);

        if (hInstance == (HINSTANCE)NULL)
        {
            dwRetCode = GetLastError();
            TRACE2 (EAP,"ElLoadEapDlls: LoadLibrary for (%ws) failed with error = %ld", 
                pEapDllExpandedPath, dwRetCode);
            break;
        }

        pRasEapGetInfo = GetProcAddress (hInstance, "RasEapGetInfo");

        if (pRasEapGetInfo == (FARPROC)NULL)
        {
            dwRetCode = GetLastError();

            TRACE1 (EAP,"ElLoadEapDlls: GetProcAddress failed with error = %ld", 
                dwRetCode);
            break;
        }

        dwRetCode = (DWORD) (*pRasEapGetInfo) (dwEapTypeId,
                                        &RasEapInfo);

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: pRasEapGetInfo failed with error = %ld", 
                dwRetCode);
            break;
        }

        if (RasEapInfo.RasEapInitialize != NULL)
        {
            dwRetCode = RasEapInfo.RasEapInitialize (
                            TRUE);

            if (dwRetCode != NO_ERROR)
            {
                TRACE1 (EAP,"ElLoadEapDlls: RasEapInitialize failed with error = %ld", 
                dwRetCode);
                break;
            }
        }

        g_pEapTable[g_dwNumEapProtocols].hInstance = hInstance;

        memcpy ((PVOID)&(g_pEapTable[g_dwNumEapProtocols].RasEapInfo),
                (PVOID)&RasEapInfo,
                sizeof(PPP_EAP_INFO));
        ZeroMemory ((PVOID)&RasEapInfo, sizeof(PPP_EAP_INFO));

        g_pEapTable[g_dwNumEapProtocols].RasEapInfo.dwSizeInBytes = 
                                                    sizeof(PPP_EAP_INFO);

        g_dwNumEapProtocols++;


        TRACE1 (EAP,"ElLoadEapDlls: Successfully loaded EAP DLL type id = %d", 
                dwEapTypeId );

        } while (FALSE);

        if (dwRetCode != NO_ERROR)
        {
            if (hInstance != NULL)
            {
                FreeLibrary (hInstance);
            }
            hInstance = NULL;
        }

        if (hKeyEapDll != NULL)
        {
            RegCloseKey (hKeyEapDll);
            hKeyEapDll = (HKEY)NULL;
        }

        if (pEapDllExpandedPath != NULL)
        {
            FREE( pEapDllExpandedPath );
            pEapDllExpandedPath = NULL;
        }

        if (pEapDllPath != NULL)
        {
            FREE (pEapDllPath);
            pEapDllPath = (LPWSTR)NULL;
        }

        // Reset error code and continue loading next EAP Dll
        dwRetCode = NO_ERROR;

    }

    if (hKeyEap != (HKEY)NULL)
    {
        RegCloseKey (hKeyEap);
    }

    if (hKeyEapDll != (HKEY)NULL)
    {
        RegCloseKey (hKeyEapDll);
    }

    if (pEapDllPath != (LPWSTR)NULL)
    {
        FREE (pEapDllPath);
    }

    if (pEapDllExpandedPath != NULL)
    {
        FREE (pEapDllExpandedPath);
    }

    return dwRetCode;
}


//
// ElEapInit
//
// Description: 
// Function called to initialize/uninitialize EAP module.
// In the former case, fInitialize will be TRUE; in the latter case, 
// it will be FALSE.
//
// Arguments:
//      fInitialize - TRUE - initialize EAP
//                    FALSE - uninitialize EAP
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapInit (
    IN  BOOL        fInitialize
    )
{
    DWORD   dwRetCode = NO_ERROR;

    if (fInitialize)
    {
        // Initialize EAP globals 
            
        g_dwNumEapProtocols = 0;
        g_pEapTable = NULL;
        g_dwEAPUIInvocationId = 1;

        if ((dwRetCode = ElLoadEapDlls()) != NO_ERROR)
        {
            if (g_pEapTable != NULL)
            {
                FREE (g_pEapTable);

                g_pEapTable = NULL;
            }

            g_dwNumEapProtocols = 0;

            return dwRetCode;
        }
    }
    else
    {
        if (g_pEapTable != NULL)
        {
            DWORD dwIndex;

            //
            // Unload loaded DLLs
            //

            for (dwIndex = 0; dwIndex < g_dwNumEapProtocols; dwIndex++)
            {
                if (g_pEapTable[dwIndex].hInstance != NULL)
                {
                    if (g_pEapTable[dwIndex].RasEapInfo.RasEapInitialize !=
                         NULL)
                    {
                        dwRetCode = g_pEapTable[dwIndex].RasEapInfo.
                                        RasEapInitialize (
                                            FALSE);

                        if (dwRetCode != NO_ERROR)
                        {
                            TRACE2 (EAP,
                                "RasEapInitialize(%d) failed and returned %d",
                                g_pEapTable[dwIndex].RasEapInfo.dwEapTypeId,
                                dwRetCode);
                        }
                    }

                    FreeLibrary (g_pEapTable[dwIndex].hInstance);
                    g_pEapTable[dwIndex].hInstance = NULL;
                }
            }

            FREE(g_pEapTable);

            g_pEapTable = NULL;
        }

        g_dwNumEapProtocols = 0;
        g_dwEAPUIInvocationId = 1;
    }

    return (NO_ERROR);
}


//
// EapBegin
//
// Description: 
//
// Function called by the EAPOL engine to initialize an EAP session for
// a particular port.
//
// Arguments:
//      pPCB - Pointer to PCB for port on which EAP is to be initialized
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapBegin (
        IN  EAPOL_PCB       *pPCB
    )
{
    DWORD        dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapBegin entered");

    if (pPCB->dwEapTypeToBeUsed != -1)
    {
        //
        // First check if we support this EAP type
        //

        if (ElGetEapTypeIndex((BYTE)(pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE0 (EAP, "ElEapBegin: EAPType not supported");
            return (ERROR_NOT_SUPPORTED);
        }
    }

    pPCB->fEapInitialized = TRUE;

    TRACE0 (EAP,"ElEapBegin done");

    return (NO_ERROR);
}


//
// ElEapEnd
//
// Description: 
//
// Function called to end the Eap session initiated by an ElEapBegin.
// Called when port goes down
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which EAP session is to be
//      shut-down.
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapEnd (
    IN EAPOL_PCB    *pPCB
    )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapEnd entered");

    if ((pPCB == NULL) || (!(pPCB->fEapInitialized)))
    {
        return( NO_ERROR );
    }

    if ((dwRetCode = ElEapDllEnd (pPCB)) != NO_ERROR)
    {
        TRACE1 (EAP, "ElEapEnd: Error in ElEapDllEnd %ld", dwRetCode);
    }

    if (pPCB->EapUIData.pEapUIData != NULL)
    {
        FREE( pPCB->EapUIData.pEapUIData );
        pPCB->EapUIData.pEapUIData = NULL;
    }

    pPCB->fEapInitialized = FALSE;

    return (NO_ERROR);
}

//
// ElEapExtractMessage
//
// Description: 
//
// If there is any message in the Request/Notification packet, then
// save the string in pResult->pszReplyMessage
//
// Arguments:
//      pReceiveBuf - Pointer to EAP packet received
//      pResult - Pointer to result structure
//
// Return values:
//

VOID
ElEapExtractMessage (
    IN  PPP_EAP_PACKET  *pReceiveBuf,
    OUT ELEAP_RESULT    *pResult 
    )
{
    DWORD   dwNumBytes = 0;
    CHAR*   pszReplyMessage  = NULL;
    WORD    cbPacket;

    do 
    {

        cbPacket = WireToHostFormat16 (pReceiveBuf->Length);

        if (PPP_EAP_PACKET_HDR_LEN + 1 >= cbPacket)
        {
            TRACE2 (EAP, "ElEapExtractMessage: Packet length %ld less than minimum %ld",
                    cbPacket, PPP_EAP_PACKET_HDR_LEN+1);
            break;
        }

        dwNumBytes = cbPacket - PPP_EAP_PACKET_HDR_LEN - 1;

        //
        // One more for the terminating NULL.
        //

        pszReplyMessage = (CHAR *) MALLOC (dwNumBytes+1);

        if (pszReplyMessage == NULL)
        {
            TRACE0 (EAP, "ElEapExtractMessage: MALLOC failed. Cannot extract server's message." );
            break;
        }

        CopyMemory (pszReplyMessage, pReceiveBuf->Data + 1, dwNumBytes);

        pszReplyMessage[dwNumBytes] = '\0';

        // FREE( pResult->pszReplyMessage );

        pResult->pszReplyMessage = pszReplyMessage;

        pszReplyMessage = NULL;

    } while (FALSE);

    return;
}


//
// ElParseIdentityString
//
// Description: 
// Parse the identity string
//
// Arguments:
//      pReceiveBuf - Pointer to EAP packet received
//      pPCB - Pointer to PCB for port on which data is being processed
//
// Return values:
//

DWORD
ElParseIdentityString (
    IN      PPP_EAP_PACKET  *pReceiveBuf,
    IN OUT  EAPOL_PCB       *pPCB 
    )
{
    DWORD   dwNumBytes = 0;
    WORD    cbPacket = 0;
    CHAR    *pszLocalIdString = NULL;
    WCHAR   *pwszLocalIdString = NULL;
    WCHAR   *pwszDisplayString = NULL;
    WCHAR   *pwszDisplayStringEnd = NULL;
    WCHAR   *pwszTupleValueStart = NULL;
    WCHAR   *pwszTupleTypeStart = NULL;
    WCHAR   *pwszTupleTypeEnd = NULL;
    WCHAR   *pwszTupleValueEnd = NULL;
    WCHAR   *pwszNetworkId = NULL;
    DWORD   dwNetworkIdLen = 0;
    WCHAR   *pwszNASId = NULL;
    WCHAR   *pwszPortId = NULL;
    WCHAR   *pwczNetworkId = L"NetworkId";
    WCHAR   *pwczNASId = L"NASId";
    WCHAR   *pwczPortId = L"PortId";
    LOCATION_802_1X location;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    DWORD   dwRetCode = NO_ERROR;

    do 
    {

        cbPacket = WireToHostFormat16 (pReceiveBuf->Length);

        if (PPP_EAP_PACKET_HDR_LEN + 1 >= cbPacket)
        {
            TRACE2 (EAP, "ElParseIdentityString: Packet length %ld less than minimum %ld",
                    cbPacket, PPP_EAP_PACKET_HDR_LEN+1);
            break;
        
        }

        dwNumBytes = cbPacket - PPP_EAP_PACKET_HDR_LEN - 1;

        pszLocalIdString = MALLOC (dwNumBytes + 2);
        if (pszLocalIdString == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszLocalIdString");
            break;
        }

        pwszLocalIdString = MALLOC ((dwNumBytes + 2)*sizeof(WCHAR));
        if (pwszLocalIdString == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszLocalIdString");
            break;
        }
        
        memcpy (pszLocalIdString, pReceiveBuf->Data + 1, dwNumBytes);
        pszLocalIdString[dwNumBytes] = '\0';

        if (0 == MultiByteToWideChar (
                CP_ACP,
                0,
                pszLocalIdString,
                dwNumBytes+1,
                pwszLocalIdString, 
                dwNumBytes + 2))
        {
            dwRetCode = GetLastError();

            TRACE2 (EAP,"ElParseIdentityString: MultiByteToWideChar(%s) failed for pszLocalIdString with error (%ld)",
                                        pszLocalIdString,
                                        dwRetCode);
            break;
        }

        pwszDisplayStringEnd = wcschr (pwszLocalIdString, L'\0');

        if (pwszDisplayStringEnd == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (EAP, "ElParseIdentityString: Identity string does not contain mandatory NULL character");
            break;
        }

        pwszDisplayString = MALLOC ((pwszDisplayStringEnd - pwszLocalIdString + 1) * sizeof(WCHAR));
        if (pwszDisplayString == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszDisplayString");
            break;
        }

        wcscpy (pwszDisplayString, pwszLocalIdString);

        TRACE1 (EAP, "ElParseIdentityString: DisplayString = %ws",
                pwszDisplayString);
        TRACE1 (EAP, "ElParseIdentityString: LocalIdString = %ws",
                pwszDisplayStringEnd+1);
        TRACE1 (EAP, "ElParseIdentityString: LocalIdString Length = %ld",
                dwNumBytes);

        // If only Display String is received, bail out
        if (pwszDisplayStringEnd == (pwszLocalIdString+dwNumBytes))
        {
            dwRetCode = NO_ERROR;

            TRACE0 (EAP, "ElParseIdentityString: Identity string does not contain tuples");
    
            break;
        }

        pwszTupleTypeStart = pwszDisplayStringEnd + 1;

        while (TRUE)
        {
            pwszTupleTypeEnd = wcschr (pwszTupleTypeStart, L'=');

            if (!(_wcsnicmp (pwszTupleTypeStart, pwczNetworkId, wcslen(pwczNetworkId))))
            {
                pwszTupleValueStart = pwszTupleTypeEnd + 1;
                pwszTupleValueEnd = wcschr (pwszTupleValueStart, L',');
                if (pwszTupleValueEnd == NULL)
                {
                    // End-of-string
                    pwszTupleValueEnd = &pwszLocalIdString[dwNumBytes];
                }
                TRACE1 (ANY, "ElParseIdentityString: NetworkID Size = %ld",
                        pwszTupleValueEnd - pwszTupleValueStart + 1);
                pwszNetworkId = 
                    MALLOC ((pwszTupleValueEnd - pwszTupleValueStart + 1)*sizeof(WCHAR));
                if (pwszNetworkId == NULL)
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszNetworkId");
                    break;
                }
                memcpy ((VOID *)pwszNetworkId, (VOID *)pwszTupleValueStart, (pwszTupleValueEnd - pwszTupleValueStart)*sizeof(WCHAR));
                pwszNetworkId[pwszTupleValueEnd - pwszTupleValueStart] = L'\0';
                dwNetworkIdLen = (DWORD)(pwszTupleValueEnd - pwszTupleValueStart);

                TRACE1 (EAP, "Got NetworkId = %ws", pwszNetworkId);
            }
            else
            {
                if (!(_wcsnicmp (pwszTupleTypeStart, pwczNASId, wcslen (pwczNASId))))
                {
                    pwszTupleValueStart = pwszTupleTypeEnd + 1;
                    pwszTupleValueEnd = wcschr (pwszTupleValueStart, L',');
                    if (pwszTupleValueEnd == NULL)
                    {
                        // End-of-string
                        pwszTupleValueEnd = &pwszLocalIdString[dwNumBytes];
                    }
                    pwszNASId = MALLOC ((pwszTupleValueEnd - pwszTupleValueStart + 1) * sizeof(WCHAR));
                    if (pwszNASId == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszNASId");
                        break;
                    }
                    memcpy ((VOID *)pwszNASId, (VOID *)pwszTupleValueStart, (pwszTupleValueEnd - pwszTupleValueStart)*sizeof(WCHAR));
                    pwszNASId[(pwszTupleValueEnd - pwszTupleValueStart)] = L'\0';
                    TRACE1 (EAP, "Got NASId = %ws", pwszNASId);
                }
                else
                {
                    if (!(_wcsnicmp (pwszTupleTypeStart, pwczPortId, wcslen (pwczPortId))))
                    {
                        pwszTupleValueStart = pwszTupleTypeEnd + 1;
                        pwszTupleValueEnd = wcschr (pwszTupleValueStart, L',');
                        if (pwszTupleValueEnd == NULL)
                        {
                            // End-of-string
                            pwszTupleValueEnd = &pwszLocalIdString[dwNumBytes];
                        }

                        TRACE1 (EAP, "ElParseIdentityString: For PortId, length = %ld",
                                pwszTupleValueEnd - pwszTupleValueStart);
                        pwszPortId = MALLOC ((pwszTupleValueEnd - pwszTupleValueStart + 1) * sizeof(WCHAR));
                        if (pwszPortId == NULL)
                        {
                            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszPortId");
                            break;
                        }
                        memcpy ((VOID *)pwszPortId, (VOID *)pwszTupleValueStart, (pwszTupleValueEnd - pwszTupleValueStart)*sizeof(WCHAR));
                        pwszPortId[pwszTupleValueEnd - pwszTupleValueStart] = L'\0';
                        TRACE1 (EAP, "Got PortId = %ws", pwszPortId);
                    }
                    else
                    {
                        dwRetCode = ERROR_INVALID_DATA;
                        TRACE0 (EAP, "ElParseIdentityString: Invalid tuple type");
                        break;
                    }
                }
            }

            if (*pwszTupleValueEnd == L'\0')
            {
                TRACE0 (EAP, "ElParseIdentityString: End of String reached");
                break;
            }
            else
            {
                // Position pointer beyond ','
                pwszTupleTypeStart = pwszTupleValueEnd+1;

            }
        }

        TRACE0 (EAP, "ElParseIdentityString: Out of while loop");

        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        TRACE0 (EAP, "ElParseIdentityString: Out of while loop: NO ERROR");

        // Mandatory tuples
        
        if (pwszNetworkId == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (EAP, "ElParseIdentityString: Invalid NetworkId = NULL");
            break;
        }

        // Network is the SSID for wired networks
        if (pPCB->PhysicalMediumType != NdisPhysicalMediumWirelessLan)
        {
            
        pPCB->fAuthenticationOnNewNetwork = FALSE;

        // Free previous instance of SSID if any

        if (pPCB->pwszSSID  != NULL)
        {
            // Verify if NetworkId has changed i.e. we are on a new network

            if (wcscmp (pPCB->pwszSSID, pwszNetworkId))
            {
                pPCB->fAuthenticationOnNewNetwork = TRUE;
    
                TRACE2 (EAP, "ElParseIdentityString: SSIDs are different, old= %ws, new= %ws",
                        pPCB->pwszSSID, pwszNetworkId);
            }

            FREE (pPCB->pwszSSID);
            pPCB->pwszSSID = NULL;
        }

        // New instance of SSID will be freed either on receipt of next SSID
        // or user logoff

        pPCB->pwszSSID = 
            (WCHAR *) MALLOC((wcslen(pwszNetworkId) + 1)*sizeof(WCHAR));

        if (pPCB->pwszSSID == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed. Cannot extract SSID" );
            break;
        }

        if (pPCB->pSSID)
        {
            FREE (pPCB->pSSID);
            pPCB->pSSID = NULL;
        }

        if ((dwNetworkIdLen > 0) && (dwNetworkIdLen <= MAX_SSID_LEN))
        {
            if ((pPCB->pSSID = MALLOC (NDIS_802_11_SSID_LEN)) == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (PORT, "ElParseIdentityString: MALLOC failed for pSSID");
                break;
            }

            if (0 == WideCharToMultiByte (
                        CP_ACP,
                        0,
                        pwszNetworkId,
                        dwNetworkIdLen,
                        pPCB->pSSID->Ssid,
                        dwNetworkIdLen,
                        NULL, 
                        NULL ))
            {
                dwRetCode = GetLastError();
     
                TRACE2 (ANY, "ElParseIdentityString: WideCharToMultiByte (%ws) failed for SSID: (%ld)",
                        pwszNetworkId, dwRetCode);
                break;
            }
            pPCB->pSSID->SsidLength = dwNetworkIdLen;
    
            wcscpy (pPCB->pwszSSID, pwszNetworkId);
        }

        // Retrieve the current interface params

        ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
        EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
        EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
        if (pPCB->pSSID != NULL)
        {
            memcpy (EapolIntfParams.bSSID, pPCB->pSSID->Ssid, pPCB->pSSID->SsidLength);
            EapolIntfParams.dwSizeOfSSID = pPCB->pSSID->SsidLength;
        }
        if ((dwRetCode = ElGetInterfaceParams (
                                pPCB->pwszDeviceGUID,
                                &EapolIntfParams
                                )) != NO_ERROR)
        {
            TRACE1 (PORT, "ElParseIdentityString: ElGetInterfaceParams failed with error %ld",
                    dwRetCode);
            if (dwRetCode == ERROR_FILE_NOT_FOUND)
            {
                pPCB->dwEapFlags = DEFAULT_EAPOL_STATE;
                pPCB->dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
        }
        else
        {
            pPCB->dwEapFlags = EapolIntfParams.dwEapFlags;
            pPCB->dwEapTypeToBeUsed = EapolIntfParams.dwEapType;
        }
        if (!IS_EAPOL_ENABLED(pPCB->dwEapFlags))
        {
            TRACE0 (PORT, "ElParseIdentityString: Marking port as disabled");
            pPCB->dwFlags &= ~EAPOL_PORT_FLAG_ACTIVE;
            pPCB->dwFlags |= EAPOL_PORT_FLAG_DISABLED;
        }

        TRACE1 (EAP, "ElParseIdentityString: Got SSID %ws", pPCB->pwszSSID);

        }

        //
        // Send type=value tuple string to NLA for processing
        //

        RtlZeroMemory(&location, sizeof(location));

        if (0 == WideCharToMultiByte (
                    CP_ACP,
                    0,
                    pPCB->pwszDeviceGUID,
                    -1,
                    location.adapterName,
                    wcslen(pPCB->pwszDeviceGUID)+1,
                    NULL, 
                    NULL ))
        {
            dwRetCode = GetLastError();
 
            TRACE2 (ANY, "ElParseIdentityString: WideCharToMultiByte (%ws) failed: (%ld)",
                    pPCB->pwszDeviceGUID, dwRetCode);
            break;
        }
        location.adapterName[wcslen(pPCB->pwszDeviceGUID)] = '\0';

        wcsncpy (location.information, pwszDisplayStringEnd + 1, 2048);


        TRACE2 (EAP, "ElParseIdentityString: Calling NLARegister_802_1X with params %ws and %ws",
                pPCB->pwszDeviceGUID, location.information);

        ElNLARegister_802_1X(&location);

        TRACE0 (EAP, "ElParseIdentityString: Returned after calling NLARegister_802_1X");

    } while (FALSE);

    if (pszLocalIdString != NULL)
    {
        FREE (pszLocalIdString);
    }

    if (pwszLocalIdString != NULL)
    {
        FREE (pwszLocalIdString);
    }

    if (pwszDisplayString != NULL)
    {
        FREE (pwszDisplayString);
    }

    if (pwszNetworkId != NULL)
    {
        FREE (pwszNetworkId);
    }

    if (pwszNASId != NULL)
    {
        FREE (pwszNASId);
    }

    if (pwszPortId != NULL)
    {
        FREE (pwszPortId);
    }

    return dwRetCode;
}


//
// ElEapMakeMessage
//
// Description: 
//
// Function called to process a received EAP packet and/or to send 
// out an EAP packet.
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapMakeMessage (
    IN  EAPOL_PCB           *pPCB,
    IN  PPP_EAP_PACKET      *pReceiveBuf,
    IN  OUT PPP_EAP_PACKET  *pSendBuf,
    IN  DWORD               dwSizeOfSendBuf,
    OUT ELEAP_RESULT        *pResult
    )
{
    DWORD       dwIdentityLength = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapMakeMessage entered");

    if ((pReceiveBuf != NULL) && (pReceiveBuf->Code == EAPCODE_Request))
    {
        //
        // Always respond to notitication request, with a notification response
        //

        if (pReceiveBuf->Data[0] == EAPTYPE_Notification) 
        {
            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            HostToWireFormat16 (PPP_EAP_PACKET_HDR_LEN + 1, pSendBuf->Length);

            pSendBuf->Data[0] = EAPTYPE_Notification;   

            pResult->Action = ELEAP_Send;

            // Indicate to EAPOL what is length of the EAP packet
            pResult->wSizeOfEapPkt = PPP_EAP_PACKET_HDR_LEN + 1;

            // Extract the notification message from server and save
            // it in the result struct for display to the user
            ElEapExtractMessage (pReceiveBuf, pResult);

            return (NO_ERROR);
        }

        //
        // Always respond to Identity request, with an Identity response
        //

        if (pReceiveBuf->Data[0] == EAPTYPE_Identity)
        {
            // Extract SSID out of the body of the received packet
            // and save it in the SSID field of the PCB
            // Also, save the SSID received as the last used SSID

            if ((dwRetCode = ElParseIdentityString (
                                    pReceiveBuf,
                                    pPCB)) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapMakeMessage: Error in ElParseIdentityString = %ld",
                        dwRetCode);
                return dwRetCode;
            }

            // Check if Identity is being fetched for same EAP-Id
            if ((pReceiveBuf->Id == pPCB->bCurrentEAPId) &&
                    (pPCB->EapUIState == EAPUISTATE_WAITING_FOR_IDENTITY))
            {
                // Restart PCB timer since authtimer has already been set
                RESTART_TIMER (pPCB->hTimer,
                        INFINITE_SECONDS, 
                        "PCB",
                        &dwRetCode);
                if (dwRetCode != NO_ERROR)
                {
                    TRACE1 (EAP, "ElEapMakeMessage: RESTART_TIMER during re-xmit failed with error %ld",
                            dwRetCode);
                }

                TRACE0 (EAP, "ElEapMakeMessage: Ignoring re-transmit while waiting for Identity UI");
                return (dwRetCode);
            };

            pPCB->bCurrentEAPId = pReceiveBuf->Id;

            if ((dwRetCode = ElGetIdentity (
                                pPCB)) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapMakeMessage: Error in ElGetIdentity %ld",
                        dwRetCode);
                return dwRetCode;
            }

            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            if (pPCB->pszIdentity != NULL)
            {
                dwIdentityLength = strlen (pPCB->pszIdentity);
            }
            else
            {
                dwIdentityLength = 0;
            }

            HostToWireFormat16 (
                (WORD)(PPP_EAP_PACKET_HDR_LEN+1+dwIdentityLength),
                pSendBuf->Length );

            strncpy ((CHAR *)pSendBuf->Data+1, (CHAR *)pPCB->pszIdentity, 
                    dwIdentityLength);

            TRACE1 (EAPOL, "Identity sent out = %s", pPCB->pszIdentity);

            pSendBuf->Data[0] = EAPTYPE_Identity;

            pResult->Action = ELEAP_Send;

            // Indicate to EAPOL what is length of the EAP packet
            pResult->wSizeOfEapPkt = (WORD)(PPP_EAP_PACKET_HDR_LEN+
                                        1+dwIdentityLength);

            return( NO_ERROR );
        }
    }

    return
        ElMakeSupplicantMessage (
                pPCB, pReceiveBuf, pSendBuf, dwSizeOfSendBuf, pResult);
}


//
// ElMakeSupplicantMessage
//
// Description: 
//
// EAP Supplicant engine. Can be part of ElEapMakeMessage, but separated for
// readability
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElMakeSupplicantMessage (
    IN      EAPOL_PCB       *pPCB,
    IN      PPP_EAP_PACKET* pReceiveBuf,
    IN  OUT PPP_EAP_PACKET* pSendBuf,
    IN      DWORD           dwSizeOfSendBuf,
    IN  OUT ELEAP_RESULT*   pResult
    )
{
    DWORD   dwEapIndex;
    DWORD   dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElMakeSupplicantMessage entered");

    switch (pPCB->EapState)
    {
    case EAPSTATE_Initial:

        TRACE0 (EAP,"EAPSTATE_Initial");

        if (pReceiveBuf == NULL)
        {
            //
            // Do nothing. Wait for request from authenticator
            //

            TRACE0 (EAP, "ElMakeSupplicantMessage: Received NULL EAP pkt, No Action");
            pResult->Action = ELEAP_NoAction;

            break;
        }
        else
        {
            if (pReceiveBuf->Code != EAPCODE_Request)
            {
                //
                // We are authenticatee side so drop everything other than
                // requests, since we do not send requests
                //

                pResult->Action = ELEAP_NoAction;

                break;
            }

            //
            // We got a packet, see if we support this EAP type, also that  
            // we are authorized to use it
            //

            dwEapIndex = ElGetEapTypeIndex (pReceiveBuf->Data[0]);

            if ((dwEapIndex == -1) ||
                ((pPCB->dwEapTypeToBeUsed != -1) &&
                  (dwEapIndex != ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed))))
            {
                //
                // We do not support this type or we are not authorized to use
                // it so we NAK with a type we support
                //

                pSendBuf->Code  = EAPCODE_Response;
                pSendBuf->Id    = pReceiveBuf->Id;

                HostToWireFormat16 (PPP_EAP_PACKET_HDR_LEN + 2, 
                        pSendBuf->Length);

                pSendBuf->Data[0] = EAPTYPE_Nak;

                if (pPCB->dwEapTypeToBeUsed != -1)
                {
                    pSendBuf->Data[1] = (BYTE)pPCB->dwEapTypeToBeUsed;
                }
                else
                {
                    pSendBuf->Data[1] = 
                                (BYTE)g_pEapTable[0].RasEapInfo.dwEapTypeId;
                }

                pResult->Action = ELEAP_Send;

                TRACE2 (EAP, "ElMakeSupplicantMessage: Send NAK, Got EAP type (%ld), Expected (%ld)",
                        pReceiveBuf->Data[0], pPCB->dwEapTypeToBeUsed);

                DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, 
                        EAPOL_INVALID_EAP_TYPE, 
                        pReceiveBuf->Data[0], pPCB->dwEapTypeToBeUsed);

                break;
            }
            else
            {
                //
                // The EAP type is acceptable to us so we begin authentication
                //

                if ((dwRetCode = ElEapDllBegin (pPCB, dwEapIndex)) != NO_ERROR)
                {
                    break;
                }

                pPCB->EapState = EAPSTATE_Working;

                //
                // Fall thru
                //
            }
        }

    case EAPSTATE_Working:

        TRACE0 (EAP,"EAPSTATE_Working");

        if (pReceiveBuf != NULL)
        {
            if ((pReceiveBuf->Code != EAPCODE_Request) &&
                 (pReceiveBuf->Code != EAPCODE_Success) &&
                 (pReceiveBuf->Code != EAPCODE_Failure))
            {
                //
                // We are supplicant side so drop everything other than
                // request/success/failure 
                //

                TRACE0 (EAP,"ElMakeSupplicantMessage: Dropping invalid packet not request/success/failure");

                pResult->Action = ELEAP_NoAction;

                break;
            }

            if ((pReceiveBuf->Code == EAPCODE_Request) &&
                 (pReceiveBuf->Data[0] != 
                     g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId))
            {
                TRACE0 (EAP,"ElMakeSupplicantMessage: Dropping invalid request packet with unknown Id");

                pResult->Action = ELEAP_NoAction;

                break;
            }
        }

        dwRetCode = ElEapDllWork (pPCB, 
                                pReceiveBuf, 
                                pSendBuf, 
                                dwSizeOfSendBuf, 
                                pResult
                                );

        break;

    default:

        TRACE0 (EAP, "ElMakeSupplicantMessage: Invalid EAP State");

        break;
    }

    return dwRetCode;
}


//
//
// ElEapDllBegin
//
// Description: 
//
// Function called to initiate an EAP session for a certain EAP type
//
// Arguments:
//      pPCB - Pointer to PCB for the port in context
//      dwEapIndex - EAP type for which a session has to be started
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
//

DWORD
ElEapDllBegin (
    IN EAPOL_PCB    *pPCB,
    IN DWORD        dwEapIndex
    )
{
    PPP_EAP_INPUT   PppEapInput;
    WCHAR           *pwszIdentity = NULL;
    DWORD           dwIdentityLength = 0;
    WCHAR           *pwszPassword = NULL;
    BOOLEAN         fRevertToSelf = FALSE;
    DWORD           dwPasswordLen = 0;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAP,"ElEapDllBegin called for EAP Type %d",  
            g_pEapTable[dwEapIndex].RasEapInfo.dwEapTypeId);

    do 
    {

        // Format the identity string correctly.
        // For EAP-TLS, it will be the identity on the chosen certificate
        // For EAP-CHAP, it will be domain\username

        if (pPCB->pszIdentity != NULL)
        {
            dwIdentityLength = strlen (pPCB->pszIdentity);
        }
        else
        {
            dwIdentityLength = 0;
        }

        pwszIdentity = MALLOC ((dwIdentityLength+2) * sizeof(WCHAR));

        if (pwszIdentity == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElEapDllBegin: MALLOC failed for pwszIdentity");
            break;
        }
        
        if (dwIdentityLength > 0)
        {
            if (0 == MultiByteToWideChar (
                    CP_ACP,
                    0,
                    pPCB->pszIdentity,
                    -1,
                    pwszIdentity, 
                    dwIdentityLength+2))
            {
                dwRetCode = GetLastError();
    
                TRACE2 (EAP,"MultiByteToWideChar(%s) failed: %d",
                                            pPCB->pszIdentity,
                                            dwRetCode);
                break;
            }
        }
        else
        {
            pwszIdentity[0] = L'\0';
        }
    
        // Unhash password stored locally

        if (pPCB->PasswordBlob.cbData > 0)
        {
            // Impersonate the user first, since the password has been 
            // encrypted using the password
    
            if (!ImpersonateLoggedOnUser (pPCB->hUserToken))
            {
                dwRetCode = GetLastError ();
                TRACE1 (EAP, "ElEapDllBegin: ImpersonateLoggedOnUser failed with error %ld",
                        dwRetCode);
                break;
            }

            fRevertToSelf = TRUE;

            if ((dwRetCode = ElSecureDecodePw (
                            &(pPCB->PasswordBlob), 
                            &((BYTE *)pwszPassword),
                            &dwPasswordLen
                            )) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapDllBegin: ElSecureDecodePw failed with error %ld",
                        dwRetCode);
                break;
            }

            fRevertToSelf = FALSE;

            if (!RevertToSelf ())
            {
                dwRetCode = GetLastError ();
                TRACE1 (EAP, "ElEapDllBegin: RevertToSelf failed with error %ld",
                        dwRetCode);
                dwRetCode = ERROR_BAD_IMPERSONATION_LEVEL;
                break;
            }
        }
        else
        {
            pwszPassword = MALLOC (sizeof(WCHAR));
            if (pwszPassword == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (EAP, "ElEapDllBegin: MALLOC failed for pwszPassword");
                break;
            }

            pwszPassword[0] = L'\0';
        }

        ZeroMemory (&PppEapInput, sizeof (PppEapInput));
    
        PppEapInput.dwSizeInBytes = sizeof (PPP_EAP_INPUT);
    
        if (IS_MACHINE_AUTH_ENABLED(pPCB->dwEapFlags))
        {
            // Set flag to indicate machine cert is to be picked up for machine
            // authentication
    
            if (pPCB->PreviousAuthenticationType == 
                                        EAPOL_MACHINE_AUTHENTICATION)
            {
                TRACE0 (EAP, "ElEapDllBegin: Going for machine authentication");
                PppEapInput.fFlags |= RAS_EAP_FLAG_MACHINE_AUTH;
            }
        }
        if (IS_GUEST_AUTH_ENABLED(pPCB->dwEapFlags))
        {
            if (pPCB->pszIdentity == NULL)
            {
                PppEapInput.fFlags |= RAS_EAP_FLAG_GUEST_ACCESS;
            }
        }
    
        PppEapInput.fFlags                  |= RAS_EAP_FLAG_8021X_AUTH;
        PppEapInput.fAuthenticator          = FALSE;    // Always supplicant
        PppEapInput.pwszIdentity            = pwszIdentity;
        PppEapInput.pwszPassword            = pwszPassword;
        PppEapInput.hTokenImpersonateUser   = pPCB->hUserToken;
        PppEapInput.fAuthenticationComplete = FALSE;
        PppEapInput.dwAuthResultCode        = NO_ERROR;
    
        if (pPCB->pCustomAuthConnData != NULL)
        {
            if (pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData != 0)
            {
            PppEapInput.pConnectionData =
                pPCB->pCustomAuthConnData->pbCustomAuthData;
            PppEapInput.dwSizeOfConnectionData =
                pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData;
            }
        }
    
        if (pPCB->pCustomAuthUserData != NULL)
        {
            if (pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData != 0)
            {
                PppEapInput.pUserData =
                    pPCB->pCustomAuthUserData->pbCustomAuthData;
                PppEapInput.dwSizeOfUserData =
                    pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData;
            }
        }
    
        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            PppEapInput.pDataFromInteractiveUI   = 
                                        pPCB->EapUIData.pEapUIData;
            PppEapInput.dwSizeOfDataFromInteractiveUI =
                                        pPCB->EapUIData.dwSizeOfEapUIData;
        }

        if (pPCB->dwEapTypeToBeUsed == EAP_TYPE_TLS)
        {
            if ((dwRetCode = ElLogCertificateDetails (pPCB))
                    == ERROR_BAD_IMPERSONATION_LEVEL)
            {
                TRACE0 (EAP, "ElEapDllBegin: ElLogCertificateDetails failed with RevertToSelf error");
                break;
            }
            dwRetCode = NO_ERROR;
        }

        // Call the RasEapBegin API
    
        dwRetCode = g_pEapTable[dwEapIndex].RasEapInfo.RasEapBegin ( 
                                                    &pPCB->lpEapDllWorkBuffer,   
                                                    &PppEapInput);
    
        if (pwszPassword != NULL)
        {
            FREE (pwszPassword);
            pwszPassword = NULL;
        }
    
        if (dwRetCode == NO_ERROR)
        {
            pPCB->dwEapIndex = dwEapIndex;
        }
        else
        {
            TRACE1 (EAP, "ElEapDllBegin: RasEapBegin failed with error %ld",
                    dwRetCode);
            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, 
                    EAPOL_ERROR_AUTH_PROCESSING, dwRetCode);
            pPCB->dwEapIndex = (DWORD)-1;
        }
    
    }
    while (FALSE);

    if (fRevertToSelf)
    {
        if (!RevertToSelf ())
        {
            dwRetCode = GetLastError ();
            TRACE1 (EAP, "ElEapDllBegin: RevertToSelf failed with error %ld",
                    dwRetCode);
            dwRetCode = ERROR_BAD_IMPERSONATION_LEVEL;
        }
    }

    if (pwszPassword != NULL)
    {
        FREE (pwszPassword);
    }

    if (pwszIdentity != NULL)
    {
        FREE (pwszIdentity);
    }

    return dwRetCode;
}


//
// ElEapDllEnd
//
// Description: 
//
// Function called to end an EAP session 
//
// Arguments:
//      pPCB - Pointer to the PCB for the port in context
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapDllEnd (
    EAPOL_PCB       *pPCB
    )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE1 (EAP, "ElEapDllEnd called for EAP Index %d", pPCB->dwEapIndex );

    if (pPCB->lpEapDllWorkBuffer != NULL)
    {
        if (pPCB->dwEapIndex != (DWORD)-1)
        {
            dwRetCode = g_pEapTable[pPCB->dwEapIndex].RasEapInfo.RasEapEnd (
                                                    pPCB->lpEapDllWorkBuffer);
        }

        pPCB->lpEapDllWorkBuffer = NULL;
    }

    pPCB->dwEapIndex = (DWORD)-1;
    pPCB->EapState = EAPSTATE_Initial;

    return dwRetCode;
}


//
// ElEapDllWork
//
// Description: 
//
// Function called to process an incoming packet or timeout etc
// The RasEapMakeMessage entrypoint in the appropriate EAP DLL is called 
// to process the packet.
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapDllWork ( 
    IN      EAPOL_PCB           *pPCB,    
    IN      PPP_EAP_PACKET      *pReceiveBuf,
    IN OUT  PPP_EAP_PACKET      *pSendBuf,
    IN      DWORD               dwSizeOfSendBuf,
    IN OUT  ELEAP_RESULT        *pResult
    )
{
    PPP_EAP_OUTPUT  PppEapOutput;
    PPP_EAP_INPUT   PppEapInput;
    CHAR *          pChar = NULL;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAP, "ElEapDllWork called for EAP Type %d", 
            g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId);

    ZeroMemory (&PppEapOutput, sizeof (PppEapOutput));
    PppEapOutput.dwSizeInBytes = sizeof (PppEapOutput);

    ZeroMemory (&PppEapInput, sizeof (PppEapInput));
    PppEapInput.dwSizeInBytes = sizeof (PPP_EAP_INPUT);

    PppEapInput.fAuthenticator = FALSE; // We are always supplicant
    PppEapInput.hTokenImpersonateUser = pPCB->hUserToken;

    if (pPCB->fEapUIDataReceived)
    {

        if (pPCB->EapUIData.dwContextId != pPCB->dwUIInvocationId)
        {
            // Ignore this data received

            pPCB->fEapUIDataReceived = FALSE;

            TRACE0 (EAP,"ElEapDllWork: Out of date data received from UI");

            return(NO_ERROR);
        }

        PppEapInput.fDataReceivedFromInteractiveUI = TRUE;

        PppEapInput.pDataFromInteractiveUI   = 
                                    pPCB->EapUIData.pEapUIData;
        PppEapInput.dwSizeOfDataFromInteractiveUI =
                                    pPCB->EapUIData.dwSizeOfEapUIData;

        pPCB->fEapUIDataReceived = FALSE;

    }

    dwRetCode = g_pEapTable[pPCB->dwEapIndex].RasEapInfo.RasEapMakeMessage (
                                                pPCB->lpEapDllWorkBuffer,   
                                                (PPP_EAP_PACKET *)pReceiveBuf,
                                                (PPP_EAP_PACKET *)pSendBuf,
                                                dwSizeOfSendBuf,
                                                &PppEapOutput,
                                                &PppEapInput);

    // Free InvokeInteractive UI data since we no longer need it
    if (pPCB->EapUIData.pEapUIData != NULL)
    {
        FREE (pPCB->EapUIData.pEapUIData);
        pPCB->EapUIData.pEapUIData = NULL;
    }


    if (dwRetCode != NO_ERROR)
    {
        switch (dwRetCode)
        {
        case ERROR_PPP_INVALID_PACKET:

            TRACE0 (EAP,"Silently discarding invalid EAP packet");

            pResult->Action = ELEAP_NoAction;

            return (NO_ERROR);
        
        default:

            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, 
                    EAPOL_ERROR_AUTH_PROCESSING, dwRetCode);

            TRACE2 (EAP,"EapDLLMakeMessage for type %d returned %d",
                    g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId,
                    dwRetCode );
            break;
        }

        return dwRetCode;
    }

    switch (PppEapOutput.Action)
    {
    case EAPACTION_NoAction:

        pResult->Action = ELEAP_NoAction;
        TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_NoAction" );
        break;

    case EAPACTION_Send:

        pResult->Action = ELEAP_Send;
        TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_Send" );
        break;

    case EAPACTION_Done:
    case EAPACTION_SendAndDone:

        if (PppEapOutput.Action == EAPACTION_SendAndDone)
        {
            pResult->Action = ELEAP_SendAndDone;
            TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_SendAndDone" );
        }
        else
        {
            pResult->Action = ELEAP_Done;
            TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_Done" );
        }

        // These are the attributes that are filled in by the EAP-DLL
        // e.g in EAP-TLS it will be MPPE Keys
        pResult->dwError         = PppEapOutput.dwAuthResultCode; 
        pResult->pUserAttributes = PppEapOutput.pUserAttributes;

        if (pPCB->pszIdentity != NULL)
        {
            strncpy (pResult->szUserName, pPCB->pszIdentity, UNLEN);
            pResult->szUserName[UNLEN] = '\0';
        }
        else
        {
            pResult->szUserName[0] = '\0';
        }

        break;

    case EAPACTION_SendWithTimeout:
    case EAPACTION_SendWithTimeoutInteractive:
    case EAPACTION_Authenticate:

        TRACE1 (EAP, "EAP Dll returned disallowed Action=%d",    
                                                    PppEapOutput.Action);
        break;

    default:

        TRACE1 (EAP, "EAP Dll returned unknown Action=%d", PppEapOutput.Action);
        break;
    }
    
    //
    // Check to see if EAP dll wants to bring up UI
    //

    if (PppEapOutput.fInvokeInteractiveUI)
    {
        if (PppEapOutput.pUIContextData != NULL)
        {
            pResult->InvokeEapUIData.dwSizeOfUIContextData =
                                            PppEapOutput.dwSizeOfUIContextData;

            // The context data memory is freed after the InvokeUI entrypoint
            // in the EAP DLL is called
            pResult->InvokeEapUIData.pbUIContextData 
                      = MALLOC (PppEapOutput.dwSizeOfUIContextData);

            if (pResult->InvokeEapUIData.pbUIContextData == NULL)
            {
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
        
            CopyMemory (pResult->InvokeEapUIData.pbUIContextData,
                        PppEapOutput.pUIContextData, 
                        pResult->InvokeEapUIData.dwSizeOfUIContextData);
        }
        else
        {
            pResult->InvokeEapUIData.pbUIContextData        = NULL;
            pResult->InvokeEapUIData.dwSizeOfUIContextData = 0;
        }

        pResult->fInvokeEapUI               = TRUE;
        pPCB->dwUIInvocationId              = 
            InterlockedIncrement(&(g_dwEAPUIInvocationId));
        pResult->InvokeEapUIData.dwContextId = pPCB->dwUIInvocationId;
        pResult->InvokeEapUIData.dwEapTypeId = 
                    g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId;

        TRACE0 (EAP, "EAP Dll wants to invoke interactive UI" );

        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_DESKTOP_REQUIRED_LOGON);

    }

    pResult->dwEapTypeId      = pPCB->dwEapTypeToBeUsed;
    pResult->fSaveUserData    = PppEapOutput.fSaveUserData;
    pResult->pUserData        = PppEapOutput.pUserData;
    pResult->dwSizeOfUserData = PppEapOutput.dwSizeOfUserData;

    pResult->fSaveConnectionData    = PppEapOutput.fSaveConnectionData;
    pResult->SetCustomAuthData.pConnectionData =
                                    PppEapOutput.pConnectionData;
    pResult->SetCustomAuthData.dwSizeOfConnectionData =
                                    PppEapOutput.dwSizeOfConnectionData;

    TRACE2 (EAP,"ElEapDllWork finished for EAP Type %d with error %ld", 
            g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId,
            dwRetCode);
    return dwRetCode;
}


//
// ElGetEapIndex
//
// Description: 
//
// Function called to get the index into the global EAP dll table for the 
// specified EAP type
//
// Arguments:
//      dwEapTypeId - Index into the EAP table for the input EAP type
//                    e.g. TLS = 13, MD5 = 4
//

DWORD
ElGetEapTypeIndex ( 
    IN  DWORD   dwEapTypeId
    )
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < g_dwNumEapProtocols; dwIndex++)
    {
        if (g_pEapTable[dwIndex].RasEapInfo.dwEapTypeId == dwEapTypeId)
        {
            return(dwIndex);
        }
    }

    return((DWORD)-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\elnotify.cpp ===
/*++
Copyright (c) 2000, Microsoft Corporation

Module Name:
    elnotify.cpp

Abstract:
    Module to handle the notification from 802.1X state machine to netshell

Revision History:

    sachins, Jan 04, 2001, Created

--*/

#include "pcheapol.h"
#pragma hdrstop
#include <netconp.h>
#include <dbt.h>
#include "elnotify.h"


HRESULT QueueEvent(EAPOLMAN_EVENT * pEvent)
{
    HRESULT hr = S_OK;
    INetConnectionEAPOLEventNotify *pEAPOLNotify = NULL;

    TRACE0 (NOTIFY, "QueueEvent: Entered");

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED (hr))
    {

        hr = CoCreateInstance (
                CLSID_EAPOLManager,
                NULL,
                CLSCTX_ALL,
                IID_INetConnectionEAPOLEventNotify, 
                (LPVOID *)&pEAPOLNotify);

        if (SUCCEEDED (hr))
        {
            TRACE0 (NOTIFY, "QueueEvent: CoCreateInstance succeeded");
            pEAPOLNotify->UpdateEAPOLInfo (pEvent);
            pEAPOLNotify->Release ();
        }
        else
        {
            TRACE0 (NOTIFY, "QueueEvent: CoCreateInstance failed");
        }
    
        CoUninitialize ();
    }
    else
    {
        TRACE0 (NOTIFY, "QueueEvent: CoInitializeEx failed");
    }


    TRACE0 (NOTIFY, "QueueEvent completed");

    CoTaskMemFree (pEvent);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  EAPOLMANAuthenticationStarted
//
//  Purpose:    Called by EAPOL module to indicate to netshell that
//              authentication has started
//
//  Arguments:
//      Interface GUID
//
//  Returns:    nothing
//
//

HRESULT EAPOLMANAuthenticationStarted(GUID * InterfaceId)
{
    EAPOLMAN_EVENT * pEvent = NULL;
    HRESULT hr = S_OK;

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationStarted entered");

    pEvent = (EAPOLMAN_EVENT *) CoTaskMemAlloc (sizeof (EAPOLMAN_EVENT));
    if(!pEvent)
    {
        TRACE0 (NOTIFY, "EAPOLMANAuthenticationStarted: Out of memory for pEvent");
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pEvent, sizeof(EAPOLMAN_EVENT));

    pEvent->Type = EAPOLMAN_STARTED;
    memcpy ((BYTE *)&pEvent->InterfaceId, (BYTE *)InterfaceId, sizeof (GUID));

    hr = QueueEvent(pEvent);

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationStarted completed");

    return hr;
}


//
//
//  EAPOLMANAuthenticationSucceeded
//
//  Purpose:    Called by EAPOL module to indicate to netshell that
//              authentication succeeded
//
//  Arguments:
//      Interface GUID
//
//  Returns:    nothing
//

HRESULT EAPOLMANAuthenticationSucceeded(GUID * InterfaceId)
{
    EAPOLMAN_EVENT * pEvent = NULL;
    HRESULT hr = S_OK;

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationSucceeded entered");

    pEvent = (EAPOLMAN_EVENT *) CoTaskMemAlloc (sizeof (EAPOLMAN_EVENT));
    if(!pEvent)
    {
        TRACE0 (NOTIFY, "EAPOLMANAuthenticationSucceeded: Out of memory for pEvent");
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pEvent, sizeof(EAPOLMAN_EVENT));

    pEvent->Type = EAPOLMAN_SUCCEEDED;
    memcpy ((BYTE *)&pEvent->InterfaceId, (BYTE *)InterfaceId, sizeof (GUID));

    hr = QueueEvent(pEvent);

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationSucceeded completed");

    return hr;
}


//
//
//  EAPOLMANAuthenticationFailed
//
//  Purpose:    Called by EAPOL module to indicate to netshell that
//              authentication failed
//
//  Arguments:
//      InterfaceId - Interface GUID
//      dwType - Type of error
//
//  Returns:    nothing
//

HRESULT EAPOLMANAuthenticationFailed(
    GUID * InterfaceId,
    DWORD dwType)
{
    EAPOLMAN_EVENT * pEvent = NULL;
    HRESULT hr = S_OK;

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationFailed entered");

    pEvent = (EAPOLMAN_EVENT *) CoTaskMemAlloc (sizeof (EAPOLMAN_EVENT));
    if(!pEvent)
    {
        return E_OUTOFMEMORY;
    }
    
    ZeroMemory(pEvent, sizeof(EAPOLMAN_EVENT));

    pEvent->Type = EAPOLMAN_FAILED;
    memcpy ((BYTE *)&pEvent->InterfaceId, (BYTE *)InterfaceId, sizeof (GUID));
    pEvent->dwType = dwType;

    hr = QueueEvent(pEvent);

    TRACE0 (NOTIFY, "EAPOLMANAuthenticationFailed completed");

    return hr;
}


//
//
//  EAPOLMANNotification
//
//  Purpose:    Called by EAPOL module to indicate to netshell that
//              notification message needs to be displayed
//
//  Arguments:
//      InterfaceId - Interface GUID
//      pszwNotificationMessage - Pointer to notification string to be displayed
//      dwType - Type of error
//
//  Returns:    nothing
//

HRESULT EAPOLMANNotification(
    GUID * InterfaceId,
    LPWSTR pszwNotificationMessage,
    DWORD dwType)
{
    EAPOLMAN_EVENT * pEvent = NULL;
    HRESULT hr = S_OK;

    TRACE0 (NOTIFY, "EAPOLMANNotification entered");

    pEvent = (EAPOLMAN_EVENT *) CoTaskMemAlloc (sizeof (EAPOLMAN_EVENT));
    if(!pEvent)
    {
        return E_OUTOFMEMORY;
    }
    
    ZeroMemory(pEvent, sizeof(EAPOLMAN_EVENT));

    pEvent->Type = EAPOLMAN_NOTIFICATION;
    memcpy ((BYTE *)&pEvent->InterfaceId, (BYTE *)InterfaceId, sizeof (GUID));
    pEvent->dwType = dwType;
    wcscpy (pEvent->szwMessage, pszwNotificationMessage);

    TRACE2 (NOTIFY, "EAPOLMANNotification: Got string = %ws :: Event string = %ws", pszwNotificationMessage, pEvent->szwMessage);

    hr = QueueEvent(pEvent);

    TRACE0 (NOTIFY, "EAPOLMANNotification completed");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\ellogon.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:


Abstract:



Revision History:

    timmoore, sachins, May 19 2000, Created

--*/

#include "pcheapol.h"

#pragma hdrstop


LONG_PTR FAR PASCAL 
WndProc(
        HWND hWnd, 
        unsigned message, 
        WPARAM wParam, 
        LPARAM lParam
        );

#define TASK_BAR_CREATED    L"TaskbarCreated"

TCHAR                       EAPOLClassName[] = TEXT("EAPOLClass");

UINT                        g_TaskbarCreated;
HWND                        g_hWnd = 0;
HINSTANCE                   g_hInstance;
HANDLE                      g_UserToken;

HWINSTA                     hWinStaUser = 0;
HWINSTA                     hSaveWinSta = 0;
HDESK                       hDeskUser = 0;
HDESK                       hSaveDesk = 0;


//
// WindowInit
//
// Description:
//
// Function called create the taskbar used to detect user logon/logoff
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
WindowInit ()
{
    WNDCLASS        Wc;
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into WindowInit ========================\n");

    do
    {
	    if ((g_TaskbarCreated = RegisterWindowMessage(TASK_BAR_CREATED)) 
			== 0)
	    {
            	dwRetCode = GetLastError ();
		TRACE1 (ANY, "WindowInit: RegisterWindowMessage failed with error %ld\n",
		dwRetCode);
            	break;
	    }

        TRACE1 (ANY, "WindowInit: TaskbarCreated id = %ld", 
                g_TaskbarCreated);

        // save current desktop and window station
        // so that it can be restored when we shutdown
        
        if ((hSaveWinSta = GetProcessWindowStation()) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: GetProcessWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
    
        if ((hSaveDesk = GetThreadDesktop(GetCurrentThreadId())) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: GetThreadDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        // Open the current user's window station and desktop
     
        if ((hWinStaUser = OpenWindowStation(L"WinSta0", FALSE, MAXIMUM_ALLOWED)) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: OpenWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        if (!SetProcessWindowStation(hWinStaUser))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: SetProcessWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
        else 
        {
		    TRACE0 (ANY, "WindowInit: SetProcessWindowStation succeeded\n");
        }
    
        if ((hDeskUser = OpenDesktop(L"Default", 0 , FALSE, MAXIMUM_ALLOWED))
                == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: OpenDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        if (!SetThreadDesktop(hDeskUser))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: SetThreadDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
        else
        {
            TRACE0 (ANY, "WindowInit: SetThreadDesktop succeeded\n");
        }
    
        //
        // Register the class for the window
        //

	    Wc.style            = CS_NOCLOSE;
	    Wc.cbClsExtra       = 0;
	    Wc.cbWndExtra       = 0;
	    Wc.hInstance        = g_hInstance;
	    Wc.hIcon            = NULL;
	    Wc.hCursor          = NULL;
	    Wc.hbrBackground    = NULL;
	    Wc.lpszMenuName     = NULL;
	    Wc.lpfnWndProc      = WndProc;
	    Wc.lpszClassName    = EAPOLClassName;
    
	    if (!RegisterClass(&Wc))
	    {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: RegisterClass failed with error %ld\n",
                    dwRetCode);
            if (dwRetCode == ERROR_CLASS_ALREADY_EXISTS)
            {
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
	    }

	    // Create the window that will receive the taskbar menu messages.
	    // The window has to be created after opening the user's desktop
    
	    if ((g_hWnd = CreateWindow(
                EAPOLClassName,
		        L"EAPOLWindow",
		        WS_OVERLAPPEDWINDOW,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        NULL,
		        NULL,
		        g_hInstance,
		        NULL)) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: CreateWindow failed with error %ld\n",
                    dwRetCode);
            break;
        }

        // We don't care about the return value, since we just want it to
        // be hidden and it will always succeed

	    ShowWindow(g_hWnd, SW_HIDE);
    
	    if (!UpdateWindow(g_hWnd))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: UpdateWindow failed with error %ld\n",
                    dwRetCode);
            break;
        }
    
        TRACE0 (ANY, "WindowInit: CreateWindow succeeded\n");

    } while (FALSE);

//    return dwRetCode;
    return NO_ERROR;
}


//
// WindowShut
//
// Description:
//
// Function called to delete the task bar created to detect user logon/logoff
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
WindowShut ()
{
    DWORD       dwRetCode = NO_ERROR;

    do
    {

        if (g_hWnd)
        {
            if (!DestroyWindow (g_hWnd))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: DestroyWindow failed with error %ld\n",
                        dwRetCode);
                // log
            }
        }

        if (g_hInstance)
        {
            if (!UnregisterClass (
                    EAPOLClassName,
                    g_hInstance))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: UnregisterClass failed with error %ld\n",
                        dwRetCode);
                // log
            }
            g_hInstance = NULL;
        }
            
        if (hDeskUser)
        {
            if (CloseDesktop(hDeskUser) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseDesktop-hDeskUser failed with error %ld\n",
                        dwRetCode);
                // log
            }
            hDeskUser = 0;
        }
     
        if (hWinStaUser)
        {
            if (CloseWindowStation(hWinStaUser) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseWindowStation-hWinStaUser failed with error %ld\n",
                        dwRetCode);
                // log
            }
            hWinStaUser = 0;
        }


        if (hSaveDesk)
        {
            if (!SetThreadDesktop(hSaveDesk))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: SetThreadDesktop failed with error %ld\n",
                        dwRetCode);
                // log
            }
    
            if (hSaveWinSta)
            {
                if (SetProcessWindowStation(hSaveWinSta) == 0)
                {
                    TRACE1 (ANY, "WindowShut: SetProcessWindowStation failed with error %ld\n",
                            dwRetCode);
                    dwRetCode = GetLastError ();
                    // log
                }
            }
     
            if (CloseDesktop(hSaveDesk) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseDesktop-hSaveDesk failed with error %ld\n",
                        dwRetCode);
                // log
            }

            hSaveDesk = 0;
     
            if (hSaveWinSta)
            {
                if (CloseWindowStation(hSaveWinSta) == 0)
                {
                    dwRetCode = GetLastError ();
		            TRACE1 (ANY, "WindowShut: CloseWindowStation-hSaveWinSta failed with error %ld\n",
                            dwRetCode);
                    // log
                }
                hSaveWinSta = 0;
            }

        }
    } while (FALSE);

    return dwRetCode;

}


//
// UserLogon
//
// Description:
//
// Function called to do processing when user logs on
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
UserLogon ()
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into UserLogon ===================\n");

    do 
    {
#if 0
        ElUserLogonCallback (
                NULL,
                TRUE
                );
        TRACE0 (ANY, "UserLogon: ElUserLogonCallback completed");
#endif

    } while (FALSE);

    return dwRetCode;

}


//
// UserLogoff
//
// Description:
//
// Function called to do processing when user logs off
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
UserLogoff ()
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into UserLogoff ===================\n");

    do 
    {
#if 0
        ElUserLogoffCallback (
                NULL,
                TRUE
                );
        TRACE0 (ANY, "UserLogoff: ElUserLogoffCallback completed");
#endif

    } while (FALSE);

    return dwRetCode;
}


//
// ElWaitOnEvent
//
// Description:
//
// Function called to wait on taskbar event changes
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
ElWaitOnEvent () 
{
    MSG         Msg;
    HANDLE      hEvents[1];
    BOOL        fExitThread = FALSE;
    DWORD       dwStatus = NO_ERROR;
    DWORD       dwRetCode = NO_ERROR;

    // Check if 802.1X service has stopped
    // Exit if so

    if (( dwStatus = WaitForSingleObject (
                g_hEventTerminateEAPOL,
                0)) == WAIT_FAILED)
    {
        dwRetCode = GetLastError ();
        if ( g_dwTraceId != INVALID_TRACEID )
	    {
            TRACE1 (INIT, "ElWaitOnEvent: WaitForSingleObject failed with error %ld, Terminating cleanup",
                dwRetCode);
        }

        // log

        return dwRetCode;
    }

    if (dwStatus == WAIT_OBJECT_0)
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            dwRetCode = NO_ERROR;
            TRACE0 (INIT, "ElWaitOnEvent: g_hEventTerminateEAPOL already signaled, returning");
        }
        return dwRetCode;
    }

    if (!g_dwMachineAuthEnabled)
    {
	    if ((dwRetCode = UserLogon()) != NO_ERROR)
        {
            TRACE1 (ANY, "ElWaitOnEvent: UserLogon failed with error %ld",
                    dwRetCode);
            return dwRetCode;
        }
    }

    do
    {
		do 
        {
            hEvents[0] = g_hEventTerminateEAPOL;

			dwStatus = MsgWaitForMultipleObjects(
                            1, 
                            hEvents, 
                            FALSE, 
                            INFINITE, 
                            QS_ALLINPUT | QS_ALLEVENTS | QS_ALLPOSTMESSAGE);

            if (dwStatus == WAIT_FAILED)
            {
                dwRetCode = GetLastError ();
                TRACE1 (ANY, "ElWaitOnEvent: MsgWaitForMultipleObjects failed with error %ld",
                        dwRetCode);
                // log
                break;
            }

			switch (dwStatus)
			{
			    case WAIT_OBJECT_0:
                    // Service exit detected
                    fExitThread = TRUE;
                    TRACE0 (ANY, "ElWaitOnEvent: Service exit detected");
				    break;

			    default:
				    while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))
				    {
					    if (Msg.message == WM_QUIT)
					    {
						    break;
					    }
    
                        TRACE3 (ANY, "ElWaitonEvent: Mesg %ld, wparam %lx, lparam %lx",
                                (DWORD)Msg.message, Msg.wParam, Msg.lParam);
					    if (!IsDialogMessage(g_hWnd, &Msg))
					    {
						    TranslateMessage(&Msg);
						    DispatchMessage(&Msg);
					    }
                    }
                    break;
            }

		} while (dwStatus != WAIT_OBJECT_0);

        if ((dwRetCode != NO_ERROR) || (fExitThread))
        {
            TRACE0 (ANY, "ElWaitOnEvent: Exit wait loop");
            break;
        }

    } while (TRUE);

    return dwRetCode;

}


//
// WndProc
//
// Description:
//
// Function called to process taskbar events
//
// Arguments:
//
// Return values:
//

LONG_PTR FAR PASCAL 
WndProc (
        IN  HWND        hWnd, 
        IN  unsigned    message, 
        IN  WPARAM      wParam, 
        IN  LPARAM      lParam
        )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE1 (ANY, "WndProc: Came into WndProc %ld", (DWORD)message );

    switch (message)
    {
        case WM_ENDSESSION:
			TRACE2 (ANY, "WndProc: Endsession (logoff) %x %x\n", 
                    wParam, lParam);
			if(wParam)
            {
                // Only user session logoff
                if (lParam & ENDSESSION_LOGOFF)
                {
				    if ((dwRetCode = UserLogoff()) != NO_ERROR)
                    {
                        TRACE1 (ANY, "WndProc: UserLogoff failed with error %ld",
                                dwRetCode);
                    }
                }
            }
            break;

        default:
            if (message == g_TaskbarCreated)
            {
				TRACE0 (ANY, "WndProc: Taskbar created (Logon)\n");
				if ((dwRetCode = UserLogon()) != NO_ERROR)
                {
                    TRACE1 (ANY, "WndProc: UserLogon failed with error %ld",
                            dwRetCode);
                }
            }
    }

    return (DefWindowProc(hWnd, message, wParam, lParam));
}


//
// ElUserLogonDetection
//
// Description:
//
// Function called to initialize module detecting user logon/logoff
//
// Arguments:
//      pvContext - Unused
//
// Return values:
//

VOID 
ElUserLogonDetection (
        PVOID pvContext
        )
{
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

        if ((dwRetCode = WindowInit()) != NO_ERROR)
        {
            break;
        }


        if ((dwRetCode = ElWaitOnEvent()) != NO_ERROR)
        {
            // no action
        }

    } while (FALSE);

    dwRetCode = WindowShut();

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (ANY, "ElUserLogonDetection: Error in processing = %ld",
                dwRetCode);
        // log
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\elkey.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    elkey.h

Abstract:
    This module contains declarations for key management for EAPOL


Revision History:

    Dec 26 2001, Created

--*/


#ifndef _EAPOL_KEY_H_
#define _EAPOL_KEY_H_

DWORD
ElQueryMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN OUT  SESSION_KEYS    *pSessionKeys
        );

DWORD
ElSetMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN      SESSION_KEYS    *pSessionKeys
        );

DWORD
ElQueryEAPOLMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN OUT  SESSION_KEYS    *pSessionKeys
        );

DWORD
ElSetEAPOLMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN      SESSION_KEYS    *pSessionKeys
        );

DWORD
ElQueryWZCMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN OUT  SESSION_KEYS    *pSessionKeys
        );

DWORD
ElSetWZCMasterKeys (
        IN      EAPOL_PCB       *pPCB,
        IN      SESSION_KEYS    *pSessionKeys
        );

DWORD
ElReloadMasterSecrets (
        IN      EAPOL_PCB       *pPCB
        );

#endif  // _EAPOL_KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\layer2svc\eapol\service\eloptimize.c ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:
    
    eloptimize.c


Abstract:

    The module deals with functions related to user identity 
    selection optimization


Revision History:

    sachins, July 26 2001, Created

--*/


#include "pcheapol.h"
#pragma hdrstop

//
// ElGetUserIdentityOptimized
//
// Description:
//
// Function called to fetch identity of the user
// If UI is required then send identity request to user module
// 
// Arguments:
//      pPCB - Current interface context
//
// Return values:
//      ERROR_REQUIRE_INTERACTIVE_WORKSTATION - User interaction required
//      Other - can send out user identity without user interaction
//
//

DWORD
ElGetUserIdentityOptimized (
        IN  EAPOL_PCB   *pPCB
        )
{
    DWORD                   dwIndex = 0;
    CHAR                    *pszIdentity = NULL;
    BYTE                    *pUserDataOut = NULL;
    DWORD                   dwSizeOfUserDataOut = 0;
    LPWSTR                  lpwszIdentity = NULL;
    HWND                    hwndOwner = NULL;
    PBYTE                   pbUserIn = NULL;
    DWORD                   cbData = 0;
    DWORD                   dwInSize = 0;
    PBYTE                   pbAuthData = NULL;
    HANDLE                  hLib = NULL;
    RASEAPFREE              pFreeFunc = NULL;
    RASEAPGETIDENTITY       pIdenFunc = NULL;
    BYTE                    *pbSSID = NULL;
    DWORD                   dwSizeOfSSID = 0;
    BOOLEAN                 fVerifyPhase = TRUE;
    DWORD                   dwRetCode1 = NO_ERROR;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        if (pPCB->pSSID)
        {
            pbSSID = pPCB->pSSID->Ssid;
            dwSizeOfSSID = pPCB->pSSID->SsidLength;
        }

        // Get the size of the user blob
        if ((dwRetCode = ElGetEapUserInfo (
                        pPCB->hUserToken,
                        pPCB->pwszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        dwSizeOfSSID,
                        pbSSID,
                        NULL,
                        &dwInSize
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (dwInSize <= 0)
                {
                    // No blob stored in the registry
                    // Continue processing
                    TRACE0 (USER, "ElGetUserIdentityOptimized: NULL sized user data");
                    pbUserIn = NULL;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbUserIn = MALLOC (dwInSize);
                    if (pbUserIn == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentityOptimized: Error in memory allocation for User data");
                        break;
                    }
                    if ((dwRetCode = ElGetEapUserInfo (
                                pPCB->hUserToken,
                                pPCB->pwszDeviceGUID,
                                pPCB->dwEapTypeToBeUsed,
                                dwSizeOfSSID,
                                pbSSID,
                                pbUserIn,
                                &dwInSize
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentityOptimized: ElGetEapUserInfo failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // User info may not have been created till now
                // which is valid condition to proceed
                if (dwRetCode != ERROR_FILE_NOT_FOUND)
                {
                    TRACE1 (USER, "ElGetUserIdentityOptimized: ElGetEapUserInfo size estimation failed with error %ld",
                            dwRetCode);
                    break;
                }
                else
                {
                    dwRetCode = NO_ERROR;
                }
            }
        }

        // The EAP dll has already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElGetUserIdentityOptimized: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hLib = g_pEapTable[dwIndex].hInstance;

        pIdenFunc = (RASEAPGETIDENTITY)GetProcAddress(hLib, 
                                                    "RasEapGetIdentity");
        pFreeFunc = (RASEAPFREE)GetProcAddress(hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pIdenFunc == NULL))
        {
            TRACE0 (USER, "ElGetUserIdentityOptimized: pIdenFunc or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get the size of the EAP blob
        if ((dwRetCode = ElGetCustomAuthData (
                        pPCB->pwszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        dwSizeOfSSID,
                        pbSSID,
                        NULL,
                        &cbData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (cbData == 0)
                {
                    // No EAP blob stored in the registry
                    TRACE0 (USER, "ElGetUserIdentityOptimized: NULL sized EAP blob");
                    pbAuthData = NULL;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbAuthData = MALLOC (cbData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentityOptimized: Error in memory allocation for EAP blob");
                        break;
                    }
                    if ((dwRetCode = ElGetCustomAuthData (
                                        pPCB->pwszDeviceGUID,
                                        pPCB->dwEapTypeToBeUsed,
                                        dwSizeOfSSID,
                                        pbSSID,
                                        pbAuthData,
                                        &cbData
                                        )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentityOptimized: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (USER, "ElGetUserIdentityOptimized: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        if (!ImpersonateLoggedOnUser (pPCB->hUserToken))
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserIdentityOptimized: ImpersonateLoggedOnUser failed with error %ld",
                    dwRetCode);
            break;
        }

        if (pIdenFunc)
        if ((dwRetCode = (*(pIdenFunc))(
                        pPCB->dwEapTypeToBeUsed,
                        fVerifyPhase?NULL:hwndOwner, // hwndOwner
                        ((fVerifyPhase?RAS_EAP_FLAG_NON_INTERACTIVE:0) | RAS_EAP_FLAG_8021X_AUTH), // dwFlags
                        NULL, // lpszPhonebook
                        pPCB->pwszFriendlyName, // lpszEntry
                        pbAuthData, // Connection data
                        cbData, // Count of pbAuthData
                        pbUserIn, // User data for port
                        dwInSize, // Size of user data
                        &pUserDataOut,
                        &dwSizeOfUserDataOut,
                        &lpwszIdentity
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserIdentityOptimized: Error in calling GetIdentity = %ld",
                    dwRetCode);

            if (!RevertToSelf())
            {
                dwRetCode = GetLastError();
                TRACE1 (USER, "ElGetUserIdentity: Error in RevertToSelf = %ld",
                    dwRetCode);
                dwRetCode = ERROR_BAD_IMPERSONATION_LEVEL;
                break;
            }

            if (fVerifyPhase)
            {
                if (dwRetCode == ERROR_NO_EAPTLS_CERTIFICATE)
                {
                    DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_NO_CERTIFICATE_USER);
                }
                if (dwRetCode == ERROR_INTERACTIVE_MODE)
                {
                    DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_DESKTOP_REQUIRED_IDENTITY);
                }

                // If interactive mode is required, return error accordingly
                if ((dwRetCode == ERROR_INTERACTIVE_MODE) || 
                    (dwRetCode == ERROR_NO_EAPTLS_CERTIFICATE) ||
                    (dwRetCode == ERROR_NO_SMART_CARD_READER))
                {
                    dwRetCode = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                    break;
                }

                DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_ERROR_GET_IDENTITY, 
                        EAPOLAuthTypes[EAPOL_USER_AUTHENTICATION], dwRetCode);
            }
            break;
        }

        if (!RevertToSelf())
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserIdentityOptimized: Error in RevertToSelf = %ld",
                dwRetCode);
            dwRetCode = ERROR_BAD_IMPERSONATION_LEVEL;
            break;
        }

        // Fill in the returned information into the PCB fields for 
        // later authentication

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        pPCB->pCustomAuthUserData = MALLOC (dwSizeOfUserDataOut + sizeof (DWORD));
        if (pPCB->pCustomAuthUserData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentityOptimized: Error in allocating memory for UserInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData = dwSizeOfUserDataOut;

        if ((dwSizeOfUserDataOut != 0) && (pUserDataOut != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthUserData->pbCustomAuthData, 
                (BYTE *)pUserDataOut, 
                dwSizeOfUserDataOut);
        }

        if (lpwszIdentity != NULL)
        {
            pszIdentity = MALLOC (wcslen(lpwszIdentity)*sizeof(CHAR) + sizeof(CHAR));
            if (pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentityOptimized: MALLOC failed for pszIdentity");
                break;
            }

            if (0 == WideCharToMultiByte (
                        CP_ACP,
                        0,
                        lpwszIdentity,
  