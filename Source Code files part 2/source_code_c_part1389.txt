diaInfo_GetDiscInfo(This,pinfo)	\
    (This)->lpVtbl -> GetDiscInfo(This,pinfo)

#define IWMPCDMediaInfo_GetDiscIdentifier(This,pbstrIdentifier)	\
    (This)->lpVtbl -> GetDiscIdentifier(This,pbstrIdentifier)

#define IWMPCDMediaInfo_GetTrackCount(This,pcTrack)	\
    (This)->lpVtbl -> GetTrackCount(This,pcTrack)

#define IWMPCDMediaInfo_GetTrackInfo(This,iTrack,pinfo)	\
    (This)->lpVtbl -> GetTrackInfo(This,iTrack,pinfo)

#define IWMPCDMediaInfo_GetTrackURL(This,iTrack,pbstrURL)	\
    (This)->lpVtbl -> GetTrackURL(This,iTrack,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetDiscInfo_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDMediaInfo_GetDiscInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetDiscIdentifier_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrIdentifier);


void __RPC_STUB IWMPCDMediaInfo_GetDiscIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackCount_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcTrack);


void __RPC_STUB IWMPCDMediaInfo_GetTrackCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackInfo_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDMediaInfo_GetTrackInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackURL_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPCDMediaInfo_GetTrackURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDMediaInfo_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDeviceList_INTERFACE_DEFINED__
#define __IWMPCDDeviceList_INTERFACE_DEFINED__

/* interface IWMPCDDeviceList */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDeviceList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5BEC04A2-A90D-4AB0-BAC0-17D15979B26E")
    IWMPCDDeviceList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pcDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [in] */ DWORD iDevice,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDevice( 
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindDevice( 
            /* [in] */ WCHAR chDrive,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDeviceList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDeviceList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ DWORD iDevice,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ WCHAR chDrive,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IWMPCDDeviceListVtbl;

    interface IWMPCDDeviceList
    {
        CONST_VTBL struct IWMPCDDeviceListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDeviceList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDeviceList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDeviceList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDeviceList_GetDeviceCount(This,pcDevice)	\
    (This)->lpVtbl -> GetDeviceCount(This,pcDevice)

#define IWMPCDDeviceList_GetDevice(This,iDevice,ppDevice)	\
    (This)->lpVtbl -> GetDevice(This,iDevice,ppDevice)

#define IWMPCDDeviceList_GetDefaultDevice(This,ppDevice)	\
    (This)->lpVtbl -> GetDefaultDevice(This,ppDevice)

#define IWMPCDDeviceList_FindDevice(This,chDrive,ppDevice)	\
    (This)->lpVtbl -> FindDevice(This,chDrive,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDeviceCount_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcDevice);


void __RPC_STUB IWMPCDDeviceList_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [in] */ DWORD iDevice,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_GetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDefaultDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_GetDefaultDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_FindDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [in] */ WCHAR chDrive,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_FindDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDeviceList_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDevice_INTERFACE_DEFINED__
#define __IWMPCDDevice_INTERFACE_DEFINED__

/* interface IWMPCDDevice */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E723F9DE-9EDE-4364-BBA1-D984E5716F00")
    IWMPCDDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIndex( 
            /* [out] */ DWORD __RPC_FAR *piDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceDrive( 
            /* [out] */ WCHAR __RPC_FAR *pchDrive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceOptions( 
            /* [out] */ DWORD __RPC_FAR *pflOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceOptions( 
            /* [in] */ DWORD flOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceInfo( 
            /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestDevice( 
            /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireMediaChange( 
            BOOL fMediaPresent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CalibrateDevice( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMediaLoaded( 
            /* [out] */ BOOL __RPC_FAR *pfMediaLoaded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMedia( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadMedia( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaInfo( 
            /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReader( 
            /* [in] */ DWORD iTrack,
            /* [in] */ WMPCD_READER_TYPE rt,
            /* [in] */ DWORD fl,
            /* [in] */ DWORD iPriority,
            /* [in] */ DWORD cmsBuffer,
            /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
            /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBusy( 
            /* [out] */ BOOL __RPC_FAR *pfIsBusy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceIdle( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIndex )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *piDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceDrive )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pchDrive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceOptions )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pflOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeviceOptions )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD flOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceInfo )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestDevice )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireMediaChange )( 
            IWMPCDDevice __RPC_FAR * This,
            BOOL fMediaPresent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CalibrateDevice )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsMediaLoaded )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfMediaLoaded);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadMedia )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnloadMedia )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaInfo )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReader )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [in] */ WMPCD_READER_TYPE rt,
            /* [in] */ DWORD fl,
            /* [in] */ DWORD iPriority,
            /* [in] */ DWORD cmsBuffer,
            /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
            /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBusy )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsBusy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ForceIdle )( 
            IWMPCDDevice __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDDeviceVtbl;

    interface IWMPCDDevice
    {
        CONST_VTBL struct IWMPCDDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDevice_GetDeviceIndex(This,piDevice)	\
    (This)->lpVtbl -> GetDeviceIndex(This,piDevice)

#define IWMPCDDevice_GetDeviceDrive(This,pchDrive)	\
    (This)->lpVtbl -> GetDeviceDrive(This,pchDrive)

#define IWMPCDDevice_GetDeviceOptions(This,pflOptions)	\
    (This)->lpVtbl -> GetDeviceOptions(This,pflOptions)

#define IWMPCDDevice_SetDeviceOptions(This,flOptions)	\
    (This)->lpVtbl -> SetDeviceOptions(This,flOptions)

#define IWMPCDDevice_GetDeviceInfo(This,pinfo)	\
    (This)->lpVtbl -> GetDeviceInfo(This,pinfo)

#define IWMPCDDevice_TestDevice(This,pinfo)	\
    (This)->lpVtbl -> TestDevice(This,pinfo)

#define IWMPCDDevice_FireMediaChange(This,fMediaPresent)	\
    (This)->lpVtbl -> FireMediaChange(This,fMediaPresent)

#define IWMPCDDevice_CalibrateDevice(This)	\
    (This)->lpVtbl -> CalibrateDevice(This)

#define IWMPCDDevice_IsMediaLoaded(This,pfMediaLoaded)	\
    (This)->lpVtbl -> IsMediaLoaded(This,pfMediaLoaded)

#define IWMPCDDevice_LoadMedia(This)	\
    (This)->lpVtbl -> LoadMedia(This)

#define IWMPCDDevice_UnloadMedia(This)	\
    (This)->lpVtbl -> UnloadMedia(This)

#define IWMPCDDevice_GetMediaInfo(This,ppMediaInfo)	\
    (This)->lpVtbl -> GetMediaInfo(This,ppMediaInfo)

#define IWMPCDDevice_CreateReader(This,iTrack,rt,fl,iPriority,cmsBuffer,pCallback,ppReader)	\
    (This)->lpVtbl -> CreateReader(This,iTrack,rt,fl,iPriority,cmsBuffer,pCallback,ppReader)

#define IWMPCDDevice_Advise(This,pCallback,pdwCookie)	\
    (This)->lpVtbl -> Advise(This,pCallback,pdwCookie)

#define IWMPCDDevice_Unadvise(This,dwCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#define IWMPCDDevice_GetBusy(This,pfIsBusy)	\
    (This)->lpVtbl -> GetBusy(This,pfIsBusy)

#define IWMPCDDevice_ForceIdle(This)	\
    (This)->lpVtbl -> ForceIdle(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceIndex_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *piDevice);


void __RPC_STUB IWMPCDDevice_GetDeviceIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceDrive_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pchDrive);


void __RPC_STUB IWMPCDDevice_GetDeviceDrive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceOptions_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pflOptions);


void __RPC_STUB IWMPCDDevice_GetDeviceOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_SetDeviceOptions_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD flOptions);


void __RPC_STUB IWMPCDDevice_SetDeviceOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceInfo_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDDevice_GetDeviceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_TestDevice_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDDevice_TestDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_FireMediaChange_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    BOOL fMediaPresent);


void __RPC_STUB IWMPCDDevice_FireMediaChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_CalibrateDevice_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_CalibrateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_IsMediaLoaded_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfMediaLoaded);


void __RPC_STUB IWMPCDDevice_IsMediaLoaded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_LoadMedia_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_LoadMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_UnloadMedia_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_UnloadMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetMediaInfo_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo);


void __RPC_STUB IWMPCDDevice_GetMediaInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_CreateReader_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [in] */ WMPCD_READER_TYPE rt,
    /* [in] */ DWORD fl,
    /* [in] */ DWORD iPriority,
    /* [in] */ DWORD cmsBuffer,
    /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
    /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader);


void __RPC_STUB IWMPCDDevice_CreateReader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_Advise_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IWMPCDDevice_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_Unadvise_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IWMPCDDevice_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetBusy_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsBusy);


void __RPC_STUB IWMPCDDevice_GetBusy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_ForceIdle_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_ForceIdle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDevice_INTERFACE_DEFINED__ */


#ifndef __IWMPCDMixer_INTERFACE_DEFINED__
#define __IWMPCDMixer_INTERFACE_DEFINED__

/* interface IWMPCDMixer */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDMixer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F8A62F06-32FD-45C3-8079-F846C988D059")
    IWMPCDMixer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLevel( 
            /* [out] */ DWORD __RPC_FAR *pdwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLevel( 
            /* [in] */ DWORD dwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayBalance( 
            /* [out] */ LONG __RPC_FAR *plBalance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayBalance( 
            /* [in] */ LONG lBalance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLevel( 
            /* [out] */ DWORD __RPC_FAR *pdwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecordLevel( 
            /* [in] */ DWORD dwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MutePlay( 
            /* [in] */ BOOL fMute) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SoloRecord( 
            /* [in] */ BOOL fSolo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDMixerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDMixer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDMixer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ DWORD dwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayBalance )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *plBalance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayBalance )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ LONG lBalance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecordLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecordLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ DWORD dwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MutePlay )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ BOOL fMute);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SoloRecord )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ BOOL fSolo);
        
        END_INTERFACE
    } IWMPCDMixerVtbl;

    interface IWMPCDMixer
    {
        CONST_VTBL struct IWMPCDMixerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDMixer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDMixer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDMixer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDMixer_GetPlayLevel(This,pdwLevel)	\
    (This)->lpVtbl -> GetPlayLevel(This,pdwLevel)

#define IWMPCDMixer_SetPlayLevel(This,dwLevel)	\
    (This)->lpVtbl -> SetPlayLevel(This,dwLevel)

#define IWMPCDMixer_GetPlayBalance(This,plBalance)	\
    (This)->lpVtbl -> GetPlayBalance(This,plBalance)

#define IWMPCDMixer_SetPlayBalance(This,lBalance)	\
    (This)->lpVtbl -> SetPlayBalance(This,lBalance)

#define IWMPCDMixer_GetRecordLevel(This,pdwLevel)	\
    (This)->lpVtbl -> GetRecordLevel(This,pdwLevel)

#define IWMPCDMixer_SetRecordLevel(This,dwLevel)	\
    (This)->lpVtbl -> SetRecordLevel(This,dwLevel)

#define IWMPCDMixer_MutePlay(This,fMute)	\
    (This)->lpVtbl -> MutePlay(This,fMute)

#define IWMPCDMixer_SoloRecord(This,fSolo)	\
    (This)->lpVtbl -> SoloRecord(This,fSolo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetPlayLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLevel);


void __RPC_STUB IWMPCDMixer_GetPlayLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetPlayLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ DWORD dwLevel);


void __RPC_STUB IWMPCDMixer_SetPlayLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetPlayBalance_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *plBalance);


void __RPC_STUB IWMPCDMixer_GetPlayBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetPlayBalance_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ LONG lBalance);


void __RPC_STUB IWMPCDMixer_SetPlayBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetRecordLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLevel);


void __RPC_STUB IWMPCDMixer_GetRecordLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetRecordLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ DWORD dwLevel);


void __RPC_STUB IWMPCDMixer_SetRecordLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_MutePlay_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ BOOL fMute);


void __RPC_STUB IWMPCDMixer_MutePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SoloRecord_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ BOOL fSolo);


void __RPC_STUB IWMPCDMixer_SoloRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDMixer_INTERFACE_DEFINED__ */


#ifndef __IWMPCDReader_INTERFACE_DEFINED__
#define __IWMPCDReader_INTERFACE_DEFINED__

/* interface IWMPCDReader */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34B59B58-D03D-455F-9A14-52D43FD39B40")
    IWMPCDReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderInfo( 
            /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReaderState( 
            WMPCD_READER_STATE __RPC_FAR *prs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReading( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SeekReading( 
            /* [in] */ LONGLONG iTick) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseReading( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeReading( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopReading( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReaderInfo )( 
            IWMPCDReader __RPC_FAR * This,
            /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReaderState )( 
            IWMPCDReader __RPC_FAR * This,
            WMPCD_READER_STATE __RPC_FAR *prs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartReading )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SeekReading )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ LONGLONG iTick);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDReaderVtbl;

    interface IWMPCDReader
    {
        CONST_VTBL struct IWMPCDReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDReader_GetReaderInfo(This,pinfo)	\
    (This)->lpVtbl -> GetReaderInfo(This,pinfo)

#define IWMPCDReader_GetReaderState(This,prs)	\
    (This)->lpVtbl -> GetReaderState(This,prs)

#define IWMPCDReader_StartReading(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> StartReading(This,iTick,cTick,fRate)

#define IWMPCDReader_SeekReading(This,iTick)	\
    (This)->lpVtbl -> SeekReading(This,iTick)

#define IWMPCDReader_PauseReading(This)	\
    (This)->lpVtbl -> PauseReading(This)

#define IWMPCDReader_ResumeReading(This)	\
    (This)->lpVtbl -> ResumeReading(This)

#define IWMPCDReader_StopReading(This)	\
    (This)->lpVtbl -> StopReading(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDReader_GetReaderInfo_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDReader_GetReaderInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_GetReaderState_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    WMPCD_READER_STATE __RPC_FAR *prs);


void __RPC_STUB IWMPCDReader_GetReaderState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_StartReading_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReader_StartReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_SeekReading_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [in] */ LONGLONG iTick);


void __RPC_STUB IWMPCDReader_SeekReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_PauseReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_PauseReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_ResumeReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_ResumeReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_StopReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_StopReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDReader_INTERFACE_DEFINED__ */


#ifndef __IWMPCDRecorder_INTERFACE_DEFINED__
#define __IWMPCDRecorder_INTERFACE_DEFINED__

/* interface IWMPCDRecorder */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDRecorder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5E8649E-30C4-4408-B18E-F75EAC29628D")
    IWMPCDRecorder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopRecording( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDRecorderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDRecorder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDRecorderVtbl;

    interface IWMPCDRecorder
    {
        CONST_VTBL struct IWMPCDRecorderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDRecorder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDRecorder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDRecorder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDRecorder_StartRecording(This)	\
    (This)->lpVtbl -> StartRecording(This)

#define IWMPCDRecorder_PauseRecording(This)	\
    (This)->lpVtbl -> PauseRecording(This)

#define IWMPCDRecorder_ResumeRecording(This)	\
    (This)->lpVtbl -> ResumeRecording(This)

#define IWMPCDRecorder_StopRecording(This)	\
    (This)->lpVtbl -> StopRecording(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDRecorder_StartRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_StartRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_PauseRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_PauseRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_ResumeRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_ResumeRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_StopRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_StopRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDRecorder_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDeviceCallback_INTERFACE_DEFINED__
#define __IWMPCDDeviceCallback_INTERFACE_DEFINED__

/* interface IWMPCDDeviceCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDeviceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63C780F9-0F40-4E4A-8C9E-91F7A48D5946")
    IWMPCDDeviceCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnMediaChange( 
            /* [in] */ IWMPCDDevice __RPC_FAR *pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDeviceCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDeviceCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDeviceCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnMediaChange )( 
            IWMPCDDeviceCallback __RPC_FAR * This,
            /* [in] */ IWMPCDDevice __RPC_FAR *pDevice);
        
        END_INTERFACE
    } IWMPCDDeviceCallbackVtbl;

    interface IWMPCDDeviceCallback
    {
        CONST_VTBL struct IWMPCDDeviceCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDeviceCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDeviceCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDeviceCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDeviceCallback_OnMediaChange(This,pDevice)	\
    (This)->lpVtbl -> OnMediaChange(This,pDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDDeviceCallback_OnMediaChange_Proxy( 
    IWMPCDDeviceCallback __RPC_FAR * This,
    /* [in] */ IWMPCDDevice __RPC_FAR *pDevice);


void __RPC_STUB IWMPCDDeviceCallback_OnMediaChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDeviceCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPCDReaderCallback_INTERFACE_DEFINED__
#define __IWMPCDReaderCallback_INTERFACE_DEFINED__

/* interface IWMPCDReaderCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3916E26F-36A1-4F16-AC1F-B59590A51727")
    IWMPCDReaderCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnReadStart( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadSeek( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadPause( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadResume( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadStop( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnReadSample( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ IWMSBuffer __RPC_FAR *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadStart )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadSeek )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadPause )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadResume )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadStop )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnReadSample )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ IWMSBuffer __RPC_FAR *pBuffer);
        
        END_INTERFACE
    } IWMPCDReaderCallbackVtbl;

    interface IWMPCDReaderCallback
    {
        CONST_VTBL struct IWMPCDReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDReaderCallback_OnReadStart(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> OnReadStart(This,iTick,cTick,fRate)

#define IWMPCDReaderCallback_OnReadSeek(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> OnReadSeek(This,iTick,cTick,fRate)

#define IWMPCDReaderCallback_OnReadPause(This)	\
    (This)->lpVtbl -> OnReadPause(This)

#define IWMPCDReaderCallback_OnReadResume(This)	\
    (This)->lpVtbl -> OnReadResume(This)

#define IWMPCDReaderCallback_OnReadStop(This,hr)	\
    (This)->lpVtbl -> OnReadStop(This,hr)

#define IWMPCDReaderCallback_OnReadSample(This,iTick,cTick,pBuffer)	\
    (This)->lpVtbl -> OnReadSample(This,iTick,cTick,pBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadStart_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReaderCallback_OnReadStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadSeek_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReaderCallback_OnReadSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadPause_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDReaderCallback_OnReadPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadResume_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDReaderCallback_OnReadResume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadStop_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IWMPCDReaderCallback_OnReadStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadSample_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ IWMSBuffer __RPC_FAR *pBuffer);


void __RPC_STUB IWMPCDReaderCallback_OnReadSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPCDRecorderCallback_INTERFACE_DEFINED__
#define __IWMPCDRecorderCallback_INTERFACE_DEFINED__

/* interface IWMPCDRecorderCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDRecorderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D3084B23-8DF9-4CAE-BCE1-CF847D2C1870")
    IWMPCDRecorderCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnRecordStart( 
            /* [in] */ LONGLONG cTick) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordPause( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordResume( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordStop( 
            HRESULT hr) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordProgress( 
            /* [in] */ LONGLONG iTick) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDRecorderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordStart )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG cTick);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordPause )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordResume )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordStop )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            HRESULT hr);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordProgress )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick);
        
        END_INTERFACE
    } IWMPCDRecorderCallbackVtbl;

    interface IWMPCDRecorderCallback
    {
        CONST_VTBL struct IWMPCDRecorderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDRecorderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDRecorderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDRecorderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDRecorderCallback_OnRecordStart(This,cTick)	\
    (This)->lpVtbl -> OnRecordStart(This,cTick)

#define IWMPCDRecorderCallback_OnRecordPause(This)	\
    (This)->lpVtbl -> OnRecordPause(This)

#define IWMPCDRecorderCallback_OnRecordResume(This)	\
    (This)->lpVtbl -> OnRecordResume(This)

#define IWMPCDRecorderCallback_OnRecordStop(This,hr)	\
    (This)->lpVtbl -> OnRecordStop(This,hr)

#define IWMPCDRecorderCallback_OnRecordProgress(This,iTick)	\
    (This)->lpVtbl -> OnRecordProgress(This,iTick)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordStart_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG cTick);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordPause_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordResume_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordResume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordStop_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    HRESULT hr);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordProgress_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDRecorderCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\flashproxyplayer.h ===
#pragma once

#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"

/////////////////////////////////////////////////////////////////////////////
// CFlashProxy
class CFlashProxy : 
    public CProxyBaseImpl<&CLSID_FlashProxy, &LIBID_FLASHLib>,
    public IConnectionPointContainerImpl<CFlashProxy>,
    public IPropertyNotifySinkCP<CFlashProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl
{
private:
    typedef CProxyBaseImpl<&CLSID_FlashProxy, &LIBID_FLASHLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;

protected:
    CComPtr<IDispatch> m_pdispFlash;

    STDMETHOD(CreateContainedControl)(void);
    STDMETHOD(CallMethod)(OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1);
    STDMETHOD(PutBstrProp)(OLECHAR* pwzProp, BSTR bstrValue);
private:

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    void DeinitPropSink();

public:
    CFlashProxy();
    virtual ~CFlashProxy();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

DECLARE_REGISTRY_RESOURCEID(IDR_FLASHPROXY)
DECLARE_NOT_AGGREGATABLE(CFlashProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFlashProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CFlashProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Flash.rc
//
#define IDS_PROJNAME                    100
#define IDR_FLASHPROXY                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\flashpxy.cpp ===
// Flash.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Flashps.mk in the project directory.

#include "stdafx.h"
#include <initguid.h>
#include "FlashPxy.h"
#include "FlashPxy_i.c"
#include "FlashProxyPlayer.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FlashProxy, CFlashProxy)
END_OBJECT_MAP() //lint !e785

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance/*, &LIBID_FLASHLib*/);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\flashproxyplayer.cpp ===
// FlashProxy.cpp : Implementation of CFlashProxy
#include "stdafx.h"
#include "FlashPxy.h"
#include "FlashProxyPlayer.h"

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

const GUID GUID_ShockwaveFlash = {0xD27CDB6E,0xAE6D,0x11CF,{0x96,0xB8,0x44,0x45,0x53,0x54,0x00,0x00}};

/////////////////////////////////////////////////////////////////////////////
// CFlashProxy

CFlashProxy::CFlashProxy() :
    m_pdispFlash(0)
{
}

CFlashProxy::~CFlashProxy()
{
    m_pdispFlash = 0;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::PutBstrProp(OLECHAR* pwzProp, BSTR bstrValue)
{
    VARIANTARG  vararg;
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    DISPPARAMS  params      = {&vararg, &dispidPut, 1, 1};

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = bstrValue;

    hr = m_pdispFlash->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
        goto exit;

    hr = m_pdispFlash->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYPUT,
            &params, NULL, NULL, NULL);
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::CallMethod(OLECHAR* pwzMethod, VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    hr = m_pdispFlash->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
        goto exit;

    hr = m_pdispFlash->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT             hr = S_OK;
    CComBSTR            bstrHigh(L"high");
    CComBSTR            bstrTransparent(L"transparent");


    hr = CreateControl(GUID_ShockwaveFlash, IID_IDispatch,
            reinterpret_cast<void**>(&m_pdispFlash));
    
    if (FAILED(hr))
        goto exit;                

    hr = PutBstrProp(L"WMode",   bstrTransparent);
    if (FAILED(hr)) goto exit;

//    hr = PutBstrProp(L"Quality", bstrHigh);       // yields a type mismatch... 
//    if (FAILED(hr)) goto exit;                    // ....do we want to set this anyway?

    hr = S_OK;

exit:
    return hr;
}


HRESULT STDMETHODCALLTYPE CFlashProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;

    hr = SUPER::begin();
    if (FAILED(hr))
        goto exit;


    VARIANT varArg;
    varArg.vt       = VT_I4;
    varArg.intVal   = 0;

    hr = CallMethod(L"GotoFrame", NULL, &varArg);
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::end(void)
{
    ATLTRACE(_T("end\n"));  //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::end();
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Stop");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));   //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::resume();
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::pause();
    if (FAILED(hr))
        goto exit;

    if (m_fSuspended)
    {
        hr = CallMethod(L"Stop");
        if (FAILED(hr))
            goto exit;
    }
    else
    {
        hr = CallMethod(L"Play");
        if (FAILED(hr))
            goto exit;
    }

    hr = S_OK;

exit:
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::put_src(BSTR   bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::put_src(bstrURL);
    if (FAILED(hr)) 
        goto exit;

    hr = PutBstrProp(L"Movie", bstrURL);
    if (FAILED(hr)) 
        goto exit;

    NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    hr = S_OK;

exit:
    return hr;
}


HRESULT STDMETHODCALLTYPE CFlashProxy::put_CurrentTime(double dblCurrentTime)
{
    HRESULT hr      = S_OK;
    VARIANT varArg;

    m_dblTime   = dblCurrentTime;

    varArg.vt   = VT_I4;
    varArg.lVal = static_cast<long>(dblCurrentTime * NUM_FRAMES_PER_SEC);

    hr = CallMethod(L"GotoFrame", NULL, &varArg);
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::get_CurrentTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    VARIANT varResult;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto exit;
    }

    hr = CallMethod(L"CurrentFrame", &varResult);
    if (FAILED(hr))
        goto exit;

    *pdblCurrentTime = varResult.lVal * NUM_SEC_PER_FRAME;

exit:
    return S_OK;
}

STDMETHODIMP CFlashProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }
    InitPropSink();
done:

    CreateContainedControl();
    return S_OK;
}

STDMETHODIMP CFlashProxy::Detach(void)
{
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    DeinitPropSink();

    return S_OK;
}


STDMETHODIMP CFlashProxy::reset(void) 
{

    HRESULT hr = S_OK;
    //This is an example of how the proxy has to maintain state
    //consistency between the flash player and the timenode state.
    //The proxy player is encoded by the boolean m_fRunning while 
    //the timenode state is recovered with bNeedActive and bNeedPause.
    //The player current time must be the same as the segmentTime recovered from
    //the time node with the get_segmentTime.

#if 0
    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;

    if(!m_fInPlaceActivated)
    {
        goto done;
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (flTeSpeed <= 0.0)
    {
        hr = S_OK;
        pause();
        goto done;
    }
    if (m_dblScaleFactor != flTeSpeed)
    {
        put_scaleFactor((double)flTeSpeed);
    }


    if( !m_fRunning)
    {
        begin(); // add a seek after this

        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        pause();
    }
    else
    {
        resume();
    }
done:
#endif // NEVER
    return hr;
}

STDMETHODIMP CFlashProxy::repeat(void)
{
    OutputDebugString(L"CScalePlayer::repeat\n");
    return begin();
}


STDMETHODIMP CFlashProxy::seek(double dblSeekTime)
{

    return S_OK;
}


STDMETHODIMP CFlashProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    // In this function, convert from frames to seconds and return 
    // the current playback time.
    hr = S_OK;

done:

    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP CFlashProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;

    return hr;
}


STDMETHODIMP CFlashProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    if(state == NULL)
    {
        goto done;
    }

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    if(plist == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    *pvar = VARIANT_TRUE;

done:
    return hr;
}


STDMETHODIMP CFlashProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }
    *pl = -1;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }

    *pl = -1;
done:
    return hr;
}


STDMETHODIMP CFlashProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = E_NOTIMPL;

    *ppdisp = NULL;
    return hr;
}

STDMETHODIMP CFlashProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);

    return hr;
}


HRESULT CFlashProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


HRESULT CFlashProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

HRESULT CFlashProxy::InitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void CFlashProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}


STDMETHODIMP
CFlashProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CFlashProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_)
#define AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#define _ATL_DEBUG_QI
//#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_LEVEL 5

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

#define ASSERT(expr) if (!(expr)) { __asm int 3 }

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}


template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    operator T*() const { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T& operator*() const { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator->() const { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

//
// This is copied almost directly from atlcom.h.  It only changes the
// way we load the typelib to not use the registry but the current
// DLL.
//

// Create our own CComTypeInfoHolder so we can ensure which typelib is
// loaded

class CTIMEComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
        const GUID* m_pguid;
        const TCHAR * m_ptszIndex;

        ITypeInfo* m_pInfo;
        long m_dwRef;

public:
        HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

        void AddRef();
        void Release();
        HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid);
        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// ITIMEDispatchImpl

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex = NULL,
          class tihclass = CTIMEComTypeInfoHolder>
class ATL_NO_VTABLE ITIMEDispatchImpl : public T
{
public:
        typedef tihclass _tihclass;
        ITIMEDispatchImpl() {_tih.AddRef();}
        virtual ~ITIMEDispatchImpl() {_tih.Release();}

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {*pctinfo = 1; return S_OK;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {return _tih.GetTI(lcid, ppInfo);}
};

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex,
          class tihclass>
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tihclass
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tih =
{piid, ptszIndex, NULL, 0};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************

#pragma once

#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86



class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    virtual ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

#ifdef NO_COPY
    NO_COPY(CImplAry);
#endif
protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry
/*lint --flb*/

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry
/*lint --flb*/

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
    CBaseEnum();
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\browsewm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: BrowseWM.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "w95wraps.h"
#include "shlwapi.h"
#include "stdafx.h"
#include <initguid.h>
#include "BrowseWM.h"
#include "BrowseWM_i.c"
#include "WMPProxyPlayer.h"
#include "ContentProxy.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ContentProxy, CContentProxy)
    OBJECT_ENTRY(CLSID_WMPProxy, CWMPProxy)
END_OBJECT_MAP() //lint !e785

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include <stdafx.h>
#include "array.h"
#include <windowsx.h>

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return (ULONG) GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND); //lint !e666 !e522
                if (pTemp == NULL)
                {
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        return hr;
    }

    // ISSUE - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    // bug #14220, ie6 
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = new CImplAry;
        if (rgCopy == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{ //lint !e1538
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
    m_piid = NULL;
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
    CEnumGeneric();
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    if ((c > 0) && (reelt == NULL))
    {
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);
    CEnumVARIANT();

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = new CEnumVARIANT(cb, vt, fDelete);
    if (penum == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    
    if ((c > 0) && (reelt == NULL))
    {
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\comutil.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: comutil.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "stdafx.h"
#include "comutil.h"
#include <shlwapi.h>

/////////////////////////////////////////////////////////////////////////////
// CTIMEComTypeInfoHolder

void CTIMEComTypeInfoHolder::AddRef()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        m_dwRef++;
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CTIMEComTypeInfoHolder::Release()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (--m_dwRef == 0)
        {
                if (m_pInfo != NULL)
                        m_pInfo->Release();
                m_pInfo = NULL;
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CTIMEComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    _ASSERTE(m_pguid != NULL);
    _ASSERTE(ppInfo != NULL);
    USES_CONVERSION; //lint !e522
    *ppInfo = NULL;

    HRESULT hRes = E_FAIL;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (m_pInfo == NULL)
    {
        TCHAR szModule[MAX_PATH];

        GetModuleFileName(_Module.m_hInstTypeLib, szModule, MAX_PATH);

        if (m_ptszIndex != NULL)
        {
            PathAppend(szModule, m_ptszIndex);
        }
            
        ITypeLib* pTypeLib;
        LPOLESTR lpszModule = T2OLE(szModule);
        hRes = LoadTypeLib(lpszModule, &pTypeLib);

        if (SUCCEEDED(hRes))
        {
            ITypeInfo* pTypeInfo;
            hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
            if (SUCCEEDED(hRes))
            {
                m_pInfo = pTypeInfo;
            }
            pTypeLib->Release();
        }
    }
    *ppInfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hRes = S_OK;
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
} //lint !e550

HRESULT CTIMEComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
        ITypeInfo** pptinfo)
{
        HRESULT hRes = E_POINTER;
        if (pptinfo != NULL)
                hRes = GetTI(lcid, pptinfo);
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
        UINT cNames, LCID lcid, DISPID* rgdispid)
{
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                pInfo->Release();
        }
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        SetErrorInfo(0, NULL);
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                pInfo->Release();
        }
        return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\contentproxy.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: ContentProxy.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#include "stdafx.h"
#include "browsewm.h"
#include "contentproxy.h"

#define NO_COOKIE   -1
#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

#define TIME_INFINITE HUGE_VAL

const GUID SID_STimeContent = {0x1ae98e18, 0xc527, 0x4f78, {0xb2, 0xa2, 0x6a, 0x81, 0x7f, 0x9c, 0xd4, 0xf8}};

#define WZ_ONMEDIACOMPLETE      L"onmediacomplete"
#define WZ_ONMEDIAERROR         L"onmediaerror"
#define WZ_ONBEGIN              L"onbegin"
#define WZ_ONEND                L"onend"
#define WZ_ONPAUSE              L"onpause"
#define WZ_ONRESUME             L"onresume"
#define WZ_ONSEEK               L"onseek"

#define WZ_MEDIACOMPLETE        L"mediacomplete"
#define WZ_MEDIAERROR           L"mediaerror"
#define WZ_BEGIN                L"begin"
#define WZ_END                  L"end"
#define WZ_PAUSE                L"pause"
#define WZ_RESUME               L"resume"
#define WZ_SEEK                 L"seek"

static const PWSTR ppszInterestingEvents[] = 
{ 
    WZ_ONMEDIACOMPLETE,
    WZ_ONMEDIAERROR,
    WZ_ONBEGIN,
    WZ_ONEND,
    WZ_ONPAUSE,
    WZ_ONRESUME,
    WZ_ONSEEK
};

/////////////////////////////////////////////////////////////////////////////
// CContentProxy

CContentProxy::CContentProxy() :
    m_spMediaHost(0),
    m_spTimeElement(0),
    m_dblClipDur(TIME_INFINITE),
    m_fEventsHooked(false)
{
}

CContentProxy::~CContentProxy()
{
}

//
// CContentProxy::GetMediaHost
//
HRESULT CContentProxy::GetMediaHost()
{
    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        // Get the Mediahost Service Interface
        hr = QueryService(SID_STimeContent, IID_TO_PPV(IMediaHost, &m_spMediaHost));
        if (FAILED(hr))
        {   
            goto done;
        }   

        if (m_spMediaHost)
        {
            hr = m_spMediaHost->addProxy(GetUnknown());
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CContentProxy::CreateContainedControl
//
HRESULT STDMETHODCALLTYPE CContentProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
    }

    return hr;
}

//
// CContentProxy::fireEvent
//
HRESULT STDMETHODCALLTYPE CContentProxy::fireEvent(enum fireEvent event)
{
    return E_NOTIMPL;
}

//
// CContentProxy::detachPlayer
//
HRESULT STDMETHODCALLTYPE CContentProxy::detachPlayer()
{
    HRESULT hr = S_OK;

    // we will get this call when the media bar behavior needs
    // to unload. To prevent leaking, we should just let go of
    // it.

    UnHookEvents();

    // need to release time player
    m_spTimeElement = NULL;

    if (m_spMediaHost)
    {
        m_spMediaHost->removeProxy(GetUnknown());
    }

    // need to release media band
    m_spMediaHost = NULL;
    
    return hr;
}

// If the client site is changed then an init call must be made.
STDMETHODIMP CContentProxy::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto punt;
    }

punt:
    hr = CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>::SetClientSite(pClientSite);
    
done:
    return hr;
}

//
// CContentProxy::HookupEvents
//
HRESULT CContentProxy::HookupEvents()
{
    // should only get called from OnCreatedPlayer
    HRESULT hr = S_OK;
    CComPtr<ITIMEContentPlayerSite> spContentPlayerSite;
    CComPtr<IUnknown> spUnk;
    CComPtr<IElementBehaviorSite> spElmSite;
    CComPtr<IHTMLElement> spHTMLElm;
    CComPtr<IHTMLElement2> spHTMLElm2;

    if (!m_spTimeElement)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_fEventsHooked)
    {
        UnHookEvents();
    }

    hr = m_spTimeElement->QueryInterface(IID_TO_PPV(ITIMEContentPlayerSite, &spContentPlayerSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spContentPlayerSite->GetEventRelaySite(&spUnk);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spUnk->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &spElmSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spElmSite->GetElement(&spHTMLElm);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spHTMLElm->QueryInterface(IID_TO_PPV(IHTMLElement2, &spHTMLElm2));
    if (FAILED(hr))
    {
        goto done;
    }

    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        VARIANT_BOOL bSuccess = FALSE;
        // Try to attach all events. We don't care if they fail
        if (FAILED(spHTMLElm2->attachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this), &bSuccess)))
        {
            hr = S_FALSE;
        }
    }

    m_fEventsHooked = true;

done:
    return hr;
}

//
// CContentProxy::UnHookEvents
//
HRESULT CContentProxy::UnHookEvents()
{
    // should only get called from OnCreatedPlayer
    HRESULT hr = S_OK;
    CComPtr<ITIMEContentPlayerSite> spContentPlayerSite;
    CComPtr<IElementBehaviorSite> spElmSite;
    CComPtr<IHTMLElement> spHTMLElm;
    CComPtr<IHTMLElement2> spHTMLElm2;

    if (!m_spTimeElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTimeElement->QueryInterface(IID_TO_PPV(ITIMEContentPlayerSite, &spContentPlayerSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spContentPlayerSite->GetEventRelaySite((IUnknown**)&spElmSite);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spElmSite->GetElement(&spHTMLElm);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spHTMLElm->QueryInterface(IID_TO_PPV(IHTMLElement2, &spHTMLElm2));
    if (FAILED(hr))
    {
        goto done;
    }

    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        VARIANT_BOOL bSuccess = FALSE;
        // Try to attach all events. We don't care if they fail
        spHTMLElm2->detachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this));
    }

    m_fEventsHooked = false;

done:
    return hr;
}

//
// CContentProxy::OnCreatedPlayer
//
HRESULT STDMETHODCALLTYPE CContentProxy::OnCreatedPlayer()
{
    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    // hook up to the media player here
    if (m_spMediaHost)
    {
        // if we already have one, get rid of it
        if (m_spTimeElement)
        {
            m_spTimeElement = NULL;
        }

        // this should return a ITIMEMediaElement
        hr = m_spMediaHost->getMediaPlayer(&m_spTimeElement);
        if (FAILED(hr))
        {
            // we could not get the media player
            // maybe we asked too soon
            goto done;
        }

        hr = HookupEvents();
    }

done:
    return hr;
}

//
// CContentProxy::begin
//
HRESULT STDMETHODCALLTYPE CContentProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;
    CComVariant spVarURL;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_bstrURL == NULL)
    {
        if (!m_spTimeElement)
        {
            OnCreatedPlayer();
            if (!m_spTimeElement)
            {
                hr = S_FALSE;
                goto done;
            }

            m_spTimeElement->get_src(&spVarURL);
        }

        if (spVarURL.bstrVal == NULL || V_VT(&spVarURL) != VT_BSTR)
        {
            hr = S_FALSE;
            goto done;
        }

        m_bstrURL.Empty();
        m_bstrURL = spVarURL.bstrVal;

    }


    hr = m_spMediaHost->playURL(m_bstrURL, L"audio/x-ms-asx");
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CContentProxy::end
//
HRESULT STDMETHODCALLTYPE CContentProxy::end(void)
{
    ATLTRACE(_T("end\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::resume
//
HRESULT STDMETHODCALLTYPE CContentProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::pause
//
HRESULT STDMETHODCALLTYPE CContentProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::put_src
//
HRESULT STDMETHODCALLTYPE CContentProxy::put_src(BSTR bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    VARIANT_BOOL vb;

    m_bstrURL.Empty();
    m_bstrURL = bstrURL;

    m_dblClipDur = TIME_INFINITE;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    m_spTIMEState->get_isActive(&vb);
    if (vb == VARIANT_TRUE)
    {
        hr = m_spMediaHost->playURL(bstrURL, L"audio/x-ms-asx");
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    return hr;
}

//
// CContentProxy::put_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CContentProxy::put_CurrentTime(double dblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CContentProxy::get_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CContentProxy::get_CurrentTime(double* pdblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CContentProxy::Init
// Sets up everything
//
STDMETHODIMP CContentProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = InitPropSink();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateContainedControl();
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return S_OK;
}

//
// CContentProxy::Detach
// Cleans up anything we are holding on to
//
STDMETHODIMP CContentProxy::Detach(void)
{
    UnHookEvents();

    // need to release time player
    m_spTimeElement = NULL;

    if (m_spMediaHost)
    {
        m_spMediaHost->removeProxy(GetUnknown());
    }

    // need to release media band
    m_spMediaHost = NULL;
    

    // call this before releasing everything else.
    DeinitPropSink();

    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    return S_OK;
}

//
// CContentProxy::reset
// 
STDMETHODIMP CContentProxy::reset(void) 
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::repeat
//
STDMETHODIMP CContentProxy::repeat(void)
{
    return begin();
}

//
// CContentProxy::seek
//
STDMETHODIMP CContentProxy::seek(double dblSeekTime)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::put_clipBegin
// Not implemented
//
STDMETHODIMP CContentProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

//
// CContentProxy::put_clipEnd
// Not implemented
//
STDMETHODIMP CContentProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

//
// CContentProxy::get_currTime
//
STDMETHODIMP CContentProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEState> spTimeState;

    if (pdblCurrentTime == NULL)
    {
        return E_POINTER;
    }

    if (!m_spTimeElement)
    {
        OnCreatedPlayer();
        hr = S_OK;
        goto done;
    }

    hr = m_spTimeElement->get_currTimeState(&spTimeState);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spTimeState->get_activeTime(pdblCurrentTime);

done:
    return hr;
}

//
// CContentProxy::get_clipDur
//
STDMETHODIMP CContentProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;

    *pdbl = m_dblClipDur;

    return hr;
}

//
// CContentProxy::get_mediaDur
// Not implemented
//
STDMETHODIMP CContentProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_state
//
STDMETHODIMP CContentProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_playList
//
STDMETHODIMP CContentProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_abstract
//
STDMETHODIMP CContentProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_author
//
STDMETHODIMP CContentProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_copyright
//
STDMETHODIMP CContentProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_rating
//
STDMETHODIMP CContentProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_title
//
STDMETHODIMP CContentProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_canPause
//
STDMETHODIMP CContentProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_canSeek
//
STDMETHODIMP CContentProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_hasAudio
//
STDMETHODIMP CContentProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_hasVisual
//
STDMETHODIMP CContentProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_mediaHeight
//
STDMETHODIMP CContentProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_mediaWidth
//
STDMETHODIMP CContentProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_customObject
//
STDMETHODIMP CContentProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;

    return SUPER::get_playerObject(ppdisp);
}

//
// CContentProxy::getControl
//
STDMETHODIMP CContentProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CContentProxy::Invoke
// 
STDMETHODIMP
CContentProxy::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{
    HRESULT hr = S_OK;
    CComBSTR sbstrEvent;
    CComPtr <IHTMLEventObj> pEventObj;
            
    if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
        (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
    {
        hr = (pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj);
        if (SUCCEEDED(hr))
        {
            hr = pEventObj->get_type(&sbstrEvent);
        
            if (!sbstrEvent)
            {
                goto punt;
            }

            // relay these
            if (0 == lstrcmpiW(WZ_MEDIACOMPLETE, sbstrEvent))
            {
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
            }
            else if (0 == lstrcmpiW(WZ_MEDIAERROR, sbstrEvent))
            {
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);
            }
            else if (0 == lstrcmpiW(WZ_BEGIN, sbstrEvent))
            {
            }
            else if (0 == lstrcmpiW(WZ_END, sbstrEvent))
            {
                if (m_spTIMEState)
                {
                    m_spTIMEState->get_simpleTime(&m_dblClipDur);
                }
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }
            else if (0 == lstrcmpiW(WZ_PAUSE, sbstrEvent))
            {
                if (m_spTIMEElement)
                {
                    m_spTIMEElement->pauseElement();
                }
            }
            else if (0 == lstrcmpiW(WZ_RESUME, sbstrEvent))
            {
                if (m_spTIMEElement)
                {
                    m_spTIMEElement->resumeElement();
                }
            }
            else if (0 == lstrcmpiW(WZ_SEEK, sbstrEvent))
            {
                double dblTime;
                if (get_currTime(&dblTime) == S_OK)
                {
                    if (m_spTIMEElement)
                    {
                        m_spTIMEElement->seekActiveTime(dblTime);
                    }
                }
            }
        }
    }

punt:
    // Punt it!
    hr = CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>::Invoke(dispIDMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr);
    return hr;
} // Invoke

//
// CContentProxy::GetConnectionPoint
//
HRESULT CContentProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//
// CContentProxy::NotifyPropertyChanged
// notifies all the connections that one of the property has changed
//
HRESULT CContentProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP = NULL;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

//
// CContentProxy::InitPropSink
//
HRESULT CContentProxy::InitPropSink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

//
// CContentProxy::DeinitPropSink
//
void CContentProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

//
// CContentProxy::OnRequestEdit
//
STDMETHODIMP
CContentProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

//
// CContentProxy::OnChanged
//
STDMETHODIMP
CContentProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            //hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\errbase.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Jan 29 14:04:27 2001
 */
/* Compiler settings for .\errbase.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __errbase_h__
#define __errbase_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPErrorItemInternal_FWD_DEFINED__
#define __IWMPErrorItemInternal_FWD_DEFINED__
typedef interface IWMPErrorItemInternal IWMPErrorItemInternal;
#endif 	/* __IWMPErrorItemInternal_FWD_DEFINED__ */


#ifndef __IWMPErrorEventSink_FWD_DEFINED__
#define __IWMPErrorEventSink_FWD_DEFINED__
typedef interface IWMPErrorEventSink IWMPErrorEventSink;
#endif 	/* __IWMPErrorEventSink_FWD_DEFINED__ */


#ifndef __IWMPErrorManager_FWD_DEFINED__
#define __IWMPErrorManager_FWD_DEFINED__
typedef interface IWMPErrorManager IWMPErrorManager;
#endif 	/* __IWMPErrorManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmp.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IWMPErrorItemInternal_INTERFACE_DEFINED__
#define __IWMPErrorItemInternal_INTERFACE_DEFINED__

/* interface IWMPErrorItemInternal */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorItemInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12664C8E-FF07-447d-A272-BF6706795267")
    IWMPErrorItemInternal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetError( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ BSTR bstrCustomUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeInternal( 
            /* [out] */ long __RPC_FAR *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebHelpURL( 
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorItemInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorItemInternal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorItemInternal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetError )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ BSTR bstrCustomUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorCodeInternal )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorDescriptionInternal )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebHelpURL )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        END_INTERFACE
    } IWMPErrorItemInternalVtbl;

    interface IWMPErrorItemInternal
    {
        CONST_VTBL struct IWMPErrorItemInternalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorItemInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorItemInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorItemInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorItemInternal_SetError(This,hr,lRemedy,bstrDescription,pvarContext,bstrCustomUrl)	\
    (This)->lpVtbl -> SetError(This,hr,lRemedy,bstrDescription,pvarContext,bstrCustomUrl)

#define IWMPErrorItemInternal_GetErrorCodeInternal(This,phr)	\
    (This)->lpVtbl -> GetErrorCodeInternal(This,phr)

#define IWMPErrorItemInternal_GetErrorDescriptionInternal(This,pbstrDescription)	\
    (This)->lpVtbl -> GetErrorDescriptionInternal(This,pbstrDescription)

#define IWMPErrorItemInternal_GetWebHelpURL(This,pbstrURL)	\
    (This)->lpVtbl -> GetWebHelpURL(This,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_SetError_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ BSTR bstrCustomUrl);


void __RPC_STUB IWMPErrorItemInternal_SetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetErrorCodeInternal_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phr);


void __RPC_STUB IWMPErrorItemInternal_GetErrorCodeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetErrorDescriptionInternal_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IWMPErrorItemInternal_GetErrorDescriptionInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetWebHelpURL_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPErrorItemInternal_GetWebHelpURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorItemInternal_INTERFACE_DEFINED__ */


#ifndef __IWMPErrorEventSink_INTERFACE_DEFINED__
#define __IWMPErrorEventSink_INTERFACE_DEFINED__

/* interface IWMPErrorEventSink */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A53CD8E6-384B-4e80-A5E0-9E869716440E")
    IWMPErrorEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnErrorEvent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnErrorEvent )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPErrorEventSinkVtbl;

    interface IWMPErrorEventSink
    {
        CONST_VTBL struct IWMPErrorEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorEventSink_OnErrorEvent(This)	\
    (This)->lpVtbl -> OnErrorEvent(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPErrorEventSink_OnErrorEvent_Proxy( 
    IWMPErrorEventSink __RPC_FAR * This);


void __RPC_STUB IWMPErrorEventSink_OnErrorEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorEventSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_errbase_0272 */
/* [local] */ 

typedef 
enum eErrorManagerCaller
    {	eEMCallerAll	= 0,
	eEMCallerScript	= eEMCallerAll + 1,
	eEMCallerInternal	= eEMCallerScript + 1,
	eEMCallerLast	= eEMCallerInternal + 1
    }	eErrorManagerCaller;



extern RPC_IF_HANDLE __MIDL_itf_errbase_0272_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_errbase_0272_v0_0_s_ifspec;

#ifndef __IWMPErrorManager_INTERFACE_DEFINED__
#define __IWMPErrorManager_INTERFACE_DEFINED__

/* interface IWMPErrorManager */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2440E4D-75EF-43e5-86CA-0C2EFE4CCAF3")
    IWMPErrorManager : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCount( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetError( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorWithCustomUrl( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet,
            /* [in] */ BSTR bstrCustomUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterErrorSink( 
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterErrorSink( 
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendErrorEvents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeErrorEvents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebHelpURL( 
            /* [out] */ BSTR __RPC_FAR *pbstrURL,
            /* [in] */ eErrorManagerCaller eCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearErrorQueue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireEventIfErrors( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateErrorItem( 
            /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorManager __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCount )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetError )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorWithCustomUrl )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet,
            /* [in] */ BSTR bstrCustomUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterErrorSink )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterErrorSink )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SuspendErrorEvents )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeErrorEvents )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebHelpURL )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrURL,
            /* [in] */ eErrorManagerCaller eCaller);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearErrorQueue )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireEventIfErrors )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorDescription )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateErrorItem )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal);
        
        END_INTERFACE
    } IWMPErrorManagerVtbl;

    interface IWMPErrorManager
    {
        CONST_VTBL struct IWMPErrorManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorManager_get_ErrorCount(This,pdwNumErrors)	\
    (This)->lpVtbl -> get_ErrorCount(This,pdwNumErrors)

#define IWMPErrorManager_SetError(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet)	\
    (This)->lpVtbl -> SetError(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet)

#define IWMPErrorManager_SetErrorWithCustomUrl(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet,bstrCustomUrl)	\
    (This)->lpVtbl -> SetErrorWithCustomUrl(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet,bstrCustomUrl)

#define IWMPErrorManager_Item(This,dwIndex,ppErrorItem)	\
    (This)->lpVtbl -> Item(This,dwIndex,ppErrorItem)

#define IWMPErrorManager_RegisterErrorSink(This,pEventSink)	\
    (This)->lpVtbl -> RegisterErrorSink(This,pEventSink)

#define IWMPErrorManager_UnregisterErrorSink(This,pEventSink)	\
    (This)->lpVtbl -> UnregisterErrorSink(This,pEventSink)

#define IWMPErrorManager_SuspendErrorEvents(This)	\
    (This)->lpVtbl -> SuspendErrorEvents(This)

#define IWMPErrorManager_ResumeErrorEvents(This)	\
    (This)->lpVtbl -> ResumeErrorEvents(This)

#define IWMPErrorManager_GetWebHelpURL(This,pbstrURL,eCaller)	\
    (This)->lpVtbl -> GetWebHelpURL(This,pbstrURL,eCaller)

#define IWMPErrorManager_ClearErrorQueue(This)	\
    (This)->lpVtbl -> ClearErrorQueue(This)

#define IWMPErrorManager_FireEventIfErrors(This)	\
    (This)->lpVtbl -> FireEventIfErrors(This)

#define IWMPErrorManager_GetErrorDescription(This,hr,lRemedy,pbstrURL)	\
    (This)->lpVtbl -> GetErrorDescription(This,hr,lRemedy,pbstrURL)

#define IWMPErrorManager_CreateErrorItem(This,pErrorItemInternal)	\
    (This)->lpVtbl -> CreateErrorItem(This,pErrorItemInternal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IWMPErrorManager_get_ErrorCount_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors);


void __RPC_STUB IWMPErrorManager_get_ErrorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SetError_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ VARIANT_BOOL vbQuiet);


void __RPC_STUB IWMPErrorManager_SetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SetErrorWithCustomUrl_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ VARIANT_BOOL vbQuiet,
    /* [in] */ BSTR bstrCustomUrl);


void __RPC_STUB IWMPErrorManager_SetErrorWithCustomUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_Item_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);


void __RPC_STUB IWMPErrorManager_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_RegisterErrorSink_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IWMPErrorManager_RegisterErrorSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_UnregisterErrorSink_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IWMPErrorManager_UnregisterErrorSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SuspendErrorEvents_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_SuspendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_ResumeErrorEvents_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_ResumeErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_GetWebHelpURL_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrURL,
    /* [in] */ eErrorManagerCaller eCaller);


void __RPC_STUB IWMPErrorManager_GetWebHelpURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_ClearErrorQueue_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_ClearErrorQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_FireEventIfErrors_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_FireEventIfErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_GetErrorDescription_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPErrorManager_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_CreateErrorItem_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal);


void __RPC_STUB IWMPErrorManager_CreateErrorItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDS_PROJNAME                    100
#define IDR_WMPPROXY                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\playlist.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "stdafx.h"
#include "browsewm.h"
#include "playlist.h"
#include "shlwapi.h"

//*******************************************************************************
// *  CPlayList
// *******************************************************************************
CPlayList::CPlayList()
: m_rgItems(NULL),
  m_player(NULL),
  m_fLoaded(false)
{
}

///////////////////////////////////////////////////////////////
//  Name: ~CPlayList
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CPlayList::~CPlayList()
{
    Deinit();

    delete m_rgItems;
    m_rgItems = NULL;
    m_player = NULL;
}

///////////////////////////////////////////////////////////////
//  Name: Init
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT
CPlayList::Init(CWMPProxy & player)
{
    HRESULT hr;

    m_player = &player;
    
    if (m_rgItems == NULL)
    {
        m_rgItems = new CPtrAry<CPlayItem *>;
        if (m_rgItems == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::Deinit()
{
    m_player = NULL;

    Clear();
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoaded(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;

        if (m_fLoaded && V_VT(&m_vNewTrack) != VT_NULL)
        {
            put_activeTrack(m_vNewTrack);
        }

        m_vNewTrack.Clear();
    }
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoadedFlag(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get_length(long *len)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(len);

    *len = GetLength();

    hr = S_OK;

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get__newEnum(IUnknown** p)
{
    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(p);

    hr = CComObject<CPlayListEnum>::CreateInstance(&pNewEnum);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*this);

    hr = pNewEnum->QueryInterface(IID_IUnknown, (void **)p);
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             varIndex must be a valid integer value.or 
//             valid string title
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::item(VARIANT varIndex, ITIMEPlayItem **pPlayItem)
{
    HRESULT hr;
    VARIANT vIndex;

    CHECK_RETURN_SET_NULL(pPlayItem);

    VariantInit(&vIndex);

    hr = VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4);
    if (SUCCEEDED(hr)) //handle the case of an index.
    {
        if (vIndex.lVal >= 0 && vIndex.lVal < m_rgItems->Size())
        {
            *pPlayItem = m_rgItems->Item(vIndex.lVal);
        } 
    }
    else
    {
        long lIndex;
        
        hr = VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_BSTR);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        lIndex = GetIndex(vIndex.bstrVal);
        if (lIndex != -1)
        {
            *pPlayItem = m_rgItems->Item(lIndex);
        }
    }
    
    if (*pPlayItem != NULL)
    {
        (*pPlayItem)->AddRef();
    } 
    
    hr = S_OK;
  done:

    VariantClear(&vIndex);
    return hr;
}

STDMETHODIMP
CPlayList::put_activeTrack(/*[in]*/ VARIANT vTrack)
{
    CComPtr <ITIMEPlayItem> pPlayItem;
    long index;
    HRESULT hr;

    // If not active then just ignore everything
    if (m_player == NULL ||
        !m_player->IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // if this is not loaded, then delay setting of the track
    if (!m_fLoaded)
    {
        m_vNewTrack = vTrack;
        hr = S_OK;
        goto done; 
    }

    hr = item(vTrack, &pPlayItem);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&index);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_player->SetActiveTrack(index);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayList::get_activeTrack(/*[out, retval]*/ ITIMEPlayItem **pPlayItem)
{
    HRESULT hr;
    CPlayItem * p;

    CHECK_RETURN_SET_NULL(pPlayItem);

    if (m_player == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    p = GetActiveTrack();
    if (p == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = p->QueryInterface(IID_ITIMEPlayItem,
                               (void **) pPlayItem);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//Advances the active Track by one
STDMETHODIMP
CPlayList::nextTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_player->SetActiveTrack(lIndex + 1);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//moves the active track to the previous track
STDMETHODIMP
CPlayList::prevTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    if (lIndex > 0) //if this is not the first track
    {
        lIndex--;
    }

    hr = m_player->SetActiveTrack(lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//returns the duration of the entire playlist if it is known or -1 if it is not.
STDMETHODIMP
CPlayList::get_dur(double *dur)
{
    HRESULT hr;
    int i;
    double totalDur = 0;

    CHECK_RETURN_NULL(dur);

    *dur = TIME_INFINITE;

    //loop through all playitems.  
    for (i = 0; i < GetLength(); i++)
    {
        double duration;
        CPlayItem * pPlayItem = GetItem(i);

        hr = pPlayItem->get_dur(&duration);
        if (FAILED(hr))
        {
            goto done;          
        }
        
        if (duration == TIME_INFINITE)
        {
            goto done;      
        }
        
        totalDur += duration;
    }
    
    *dur = totalDur;

    hr = S_OK;
  done:
    return hr;
}

// ========================================
// Internal functions
// ========================================
/*
HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL)
{
    USES_CONVERSION; //lint !e522
    HINSTANCE hInst = 0;
    TCHAR szDesc[1024];
    szDesc[0] = NULL;
    // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
    if (ULONG_PTR( msg ) < 0x10000) // id
    {
        UINT nID = LOWORD((ULONG_PTR)msg);
        _ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
        if (LoadString(hInst, nID, szDesc, 1024) == 0)
        {
            _ASSERTE(FALSE);
            lstrcpy(szDesc, _T("Unknown Error"));
        }
        //this is a lint problem with the macro expansion.
        msg = T2OLE(szDesc); //lint !e506
        if (hr == 0)
        {
            //another lint problem with the macro expansion
            hr = MAKE_HRESULT(3, FACILITY_ITF, nID); //lint !e648
        }
    }
    CComPtr<ICreateErrorInfo> pICEI;
    if (SUCCEEDED(CreateErrorInfo(&pICEI)))
    {
        CComPtr<IErrorInfo> pErrorInfo;
        pICEI->SetGUID(GUID_NULL);
        LPOLESTR lpsz;
        ProgIDFromCLSID(CLSID_TIME, &lpsz);
        if (lpsz != NULL)
        {
            pICEI->SetSource(lpsz);
        }

        pICEI->SetHelpContext(hr);

        CoTaskMemFree(lpsz);
        pICEI->SetDescription((LPOLESTR)msg);
        if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
        {
            SetErrorInfo(0, pErrorInfo);
        }
    }

    return (hr == 0) ? DISP_E_EXCEPTION : hr;
} //lint !e550
*/
HRESULT NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid)
{
    HRESULT hr = E_FAIL;
    CComPtr<IEnumConnections> pEnum;

    CHECK_RETURN_NULL(pICP);

    // #14222, ie6
    // dilipk: there are too many copies of this code lying around.
    //                 all objects should use this helper function.
    //

    hr = pICP->EnumConnections(&pEnum);
    if (FAILED(hr))
    {
//        TIMESetLastError(hr);
        goto done;
    }

    CONNECTDATA cdata;

    hr = pEnum->Next(1, &cdata, NULL);
    while (hr == S_OK)
    {
        // check cdata for the object we need
        IPropertyNotifySink *pNotify;

        hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
//            TIMESetLastError(hr);
            goto done;
        }

        hr = pNotify->OnChanged(dispid);
        ReleaseInterface(pNotify);
        if (FAILED(hr))
        {
//            TIMESetLastError(hr);
            goto done;
        }

        // and get the next enumeration
        hr = pEnum->Next(1, &cdata, NULL);
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged

//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayList::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayList::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = NotifyPropertySinkCP(pICP, dispid);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged


CPlayItem *
CPlayList::GetActiveTrack()
{
    HRESULT hr;
    long l;
    CPlayItem * ppiRet = NULL;
    
    hr = m_player->GetActiveTrack(&l);
    if (FAILED(hr))
    {
        goto done;
    }

    ppiRet = GetItem(l);
  done:
    return ppiRet;
}

CPlayItem *
CPlayList::GetItem(long index)
{
    CPlayItem * ppiRet = NULL;

    if (index >= 0 && index < m_rgItems->Size())
    {
        ppiRet = m_rgItems->Item(index);
    }

    return ppiRet;
}

HRESULT
CPlayList::Add(CPlayItem *pPlayItem, long index)
{
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pPlayItem->AddRef();
    if (index == -1)
    {
        m_rgItems->Append(pPlayItem);
    }
    else
    {
        m_rgItems->Insert(index, pPlayItem);
    }

    // notify that length changed
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH);

    SetIndex();
  done:
    return hr;
}


HRESULT
CPlayList::Remove(long index)
{
    HRESULT hr;
    
    if (index >= 0 && index < m_rgItems->Size())
    {
        m_rgItems->Item(index)->Deinit();
        m_rgItems->ReleaseAndDelete(index);
    }

    // notify that length changed
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH);

    SetIndex();
    hr = S_OK;

    return hr;
}


//empties the current playlist.
void
CPlayList::Clear()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->Item(0)->Deinit();
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }
    }

    m_vNewTrack.Clear();
}


////////////////////////////////////////////////////////////////////////////////
// creates an empty playitem.  The info in this needs to be filled by the player.
// This also needs to be added to the playlist collection by the player.
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPlayList::CreatePlayItem(CPlayItem **pPlayItem)
{   
    HRESULT hr;
    CComObject<CPlayItem> * pItem;
    
    Assert(pPlayItem != NULL);

    hr = CComObject<CPlayItem>::CreateInstance(&pItem);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pItem->Init(*this);

    *pPlayItem = static_cast<CPlayItem *>(pItem);
    pItem->AddRef();
    
    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::SetIndex()
{
    long i = 0;
    long length = m_rgItems->Size();

    for (i = length-1; i >= 0; i--)
    {
        m_rgItems->Item(i)->PutIndex(i);
    }
}

long 
CPlayList::GetIndex(LPOLESTR lpstrTitle)
{
    long curIndex = -1;

    for(long i = GetLength()-1; i >= 0; i--)
    {
        CPlayItem * pItem = m_rgItems->Item(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwTitle = pItem->GetTitle();
            
            if (lpwTitle != NULL &&
                StrCmpIW(lpwTitle, lpstrTitle) == 0)
            {
                curIndex = i;
                break;
            }
        }
    }

    return curIndex;
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CPlayListEnum::CPlayListEnum()
: m_lCurElement(0)
{
}



CPlayListEnum::~CPlayListEnum()
{
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Clone(IEnumVARIANT **ppEnum)
{
    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppEnum);

    hr = CComObject<CPlayListEnum>::CreateInstance(&pNewEnum);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*m_playList);

    pNewEnum->SetCurElement(m_lCurElement);

    hr = pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum);
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long iCount = 0;
    
    CHECK_RETURN_NULL(rgVar);
    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        if (m_lCurElement < m_playList->GetLength())
        {
            CPlayItem * pPlayItem = m_playList->GetItem(m_lCurElement);

            Assert(pPlayItem != NULL);
            
            rgVar[i].vt = VT_DISPATCH;
            hr = pPlayItem->QueryInterface(IID_IDispatch, (void **) &(rgVar[i].pdispVal));
            if (FAILED(hr))
            {
                goto done;
            }

            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Skip(unsigned long celt)
{
    HRESULT hr;
    long lLen = m_playList->GetLength();
    
    m_lCurElement += (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CPlayListEnum::SetCurElement(unsigned long celt)
{
    long lLen = m_playList->GetLength();

    m_lCurElement = (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

    return;
}

//////////////////////////////////////////////////////
//  CPlayItem methods
//
CPlayItem::CPlayItem()
:   m_pPlayList(NULL),
    m_src(NULL),
    m_title(NULL),
    m_copyright(NULL),
    m_author(NULL),
    m_abstract(NULL),
    m_rating(NULL),
    m_lIndex(-1),
    m_dur(valueNotSet),
    m_fCanSkip(true),
    m_banner(NULL),
    m_bannerAbstract(NULL),
    m_bannerMoreInfo(NULL)
{
}

CPlayItem::~CPlayItem() 
{
    m_pPlayList = NULL;
    delete [] m_src;
    delete [] m_title;
    delete [] m_copyright;
    delete [] m_author;
    delete [] m_abstract;
    delete [] m_rating;
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
}

void 
CPlayItem::PutDur(double dur)
{ 
    m_dur = dur; 

    // notify that playlist's dur has changed
    if (m_pPlayList)
    {
        m_pPlayList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_DUR);
    }

    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_DUR);
}


void 
CPlayItem::PutIndex(long index) 
{ 
    m_lIndex = index; 
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_INDEX);
}


STDMETHODIMP
CPlayItem::setActive()
{
    VARIANT vIndex;
    HRESULT hr = S_OK;

    VariantInit(&vIndex);
    vIndex.vt = VT_I4;
    vIndex.lVal = m_lIndex;

    hr = m_pPlayList->put_activeTrack(vIndex);
    VariantClear(&vIndex);
    if (FAILED(hr))
    {   
        goto done;
    }   

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_index(long *index)
{
    HRESULT hr;

    CHECK_RETURN_NULL(index);

    *index = m_lIndex;

    hr = S_OK;
    return hr;
}

STDMETHODIMP
CPlayItem::get_dur(double *dur)
{
    HRESULT hr;

    CHECK_RETURN_NULL(dur);

    if (valueNotSet == m_dur)
    {
        *dur = TIME_INFINITE;
    }
    else
    {
        *dur = m_dur;
    }

    hr = S_OK;
    return hr;
}

STDMETHODIMP
CPlayItem::get_src(LPOLESTR *src)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(src);

    *src = SysAllocString(m_src?m_src:L"");

    if (*src == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_title(LPOLESTR *title)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(title);

    *title = SysAllocString(m_title?m_title:L"");
    if (*title == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_copyright(LPOLESTR *cpyrght)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(cpyrght);

    *cpyrght = SysAllocString(m_copyright?m_copyright:L"");
    if (*cpyrght == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CPlayItem::get_author(LPOLESTR *auth)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(auth);

    *auth = SysAllocString(m_author?m_author:L"");
    if (*auth == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_banner(LPOLESTR *banner)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(banner);

    *banner = SysAllocString(m_banner?m_banner:L"");
    if (*banner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_bannerAbstract(LPOLESTR *abstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_bannerAbstract?m_bannerAbstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_bannerMoreInfo(LPOLESTR *moreInfo)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(moreInfo);

    *moreInfo = SysAllocString(m_bannerMoreInfo?m_bannerMoreInfo:L"");
    if (*moreInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_abstract(LPOLESTR *abstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_abstract?m_abstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_rating(LPOLESTR *rate)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(rate);

    *rate = SysAllocString(m_rating?m_rating:L"");
    if (*rate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CPlayItem::PutSrc(LPOLESTR src)
{
    HRESULT hr;
    
    delete m_src;
    m_src = NULL;
    
    if (src)
    {
        m_src = CopyString(src);
        if (m_src == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_SRC);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutTitle(LPOLESTR title)
{
    HRESULT hr;
    
    delete m_title;
    m_title = NULL;
    
    if (title)
    {
        m_title = CopyString(title);
        if (m_title == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_TITLE);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutCopyright(LPOLESTR copyright)
{
    HRESULT hr;
    
    delete m_copyright;
    m_copyright = NULL;
    
    if (copyright)
    {
        m_copyright = CopyString(copyright);
        if (m_copyright == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_COPYRIGHT);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutAuthor(LPOLESTR author)
{
    HRESULT hr;
    
    delete m_author;
    m_author = NULL;
    
    if (author)
    {
        m_author = CopyString(author);
        if (m_author == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_AUTHOR);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutAbstract(LPOLESTR abstract)
{
    HRESULT hr;
    
    delete m_abstract;
    m_abstract = NULL;
    
    if (abstract)
    {
        m_abstract = CopyString(abstract);
        if (m_abstract == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_ABSTRACT);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutRating(LPOLESTR rating)
{
    HRESULT hr;
    
    delete m_rating;
    m_rating = NULL;
    
    if (rating)
    {
        m_rating = CopyString(rating);
        if (m_rating == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_RATING);

    hr = S_OK;
  done:
    return hr;
}

HRESULT 
CPlayItem::PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo)
{

    HRESULT hr;
    
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
    
    m_banner = NULL;
    m_bannerAbstract = NULL;
    m_bannerMoreInfo = NULL;
    
    if (banner)
    {
        m_banner = CopyString(banner);
        if (m_banner == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (abstract)
        {
            m_bannerAbstract = CopyString(abstract);
            if (m_bannerAbstract == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
        
        if (moreInfo)
        {
            m_bannerMoreInfo = CopyString(moreInfo);
            if (m_bannerMoreInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_BANNER);

    hr = S_OK;
  done:
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayItem::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayItem::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = NotifyPropertySinkCP(pICP, dispid);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\contentproxy.h ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: ContentProxy.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#include "w95wraps.h"
#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"
#include "array.h"
#include "mediaprivate.h"
#include "mshtml.h"

interface IMediaHost;

/**************************************************************************************************
 * DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER *
 *                                                                                                *
 * not using the IDL from shell/browseUI -- this is BAD!!                                         *
 **************************************************************************************************/


const GUID IID_IMediaHost = {0xEF508010,0xC806,0x4356,{0x84,0x92,0xD1,0x5E,0x61,0x6F,0x6F,0x37}};

interface IMediaHost : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE getMediaPlayer(ITIMEMediaElement **ppPlayer) = 0;
        virtual HRESULT STDMETHODCALLTYPE playURL(BSTR bstrURL, BSTR bstrMIME) = 0;
        virtual HRESULT STDMETHODCALLTYPE addProxy(IUnknown *pProxy) = 0;
        virtual HRESULT STDMETHODCALLTYPE removeProxy(IUnknown *pProxy) = 0;
};

/* END OF DANGER **********************************************************************************/

// Need to link -- dunno why its not linking...
DEFINE_GUID(IID_IContentProxy,0xEF508011,0xC806,0x4356,0x84,0x92,0xD1,0x5E,0x61,0x6F,0x6F,0x37);
DEFINE_GUID(IID_ITIMEContentPlayerSite,0x911A444E,0xB951,0x43ea,0xB3,0xAA,0x17,0xEF,0xC2,0x87,0x98,0x31);


/////////////////////////////////////////////////////////////////////////////
// CContentProxy
class CContentProxy : 
    public CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>,
    public IConnectionPointContainerImpl<CContentProxy>,
    public IPropertyNotifySinkCP<CContentProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl,
    public IContentProxy
{
private:
    typedef CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;

protected:
    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;

    STDMETHOD(CreateContainedControl)(void);
private:
    CComPtr<IMediaHost> m_spMediaHost;
    CComPtr<ITIMEMediaElement> m_spTimeElement;
    CComBSTR m_bstrURL;
    double m_dblClipDur;
    bool m_fEventsHooked;

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();

    void DeinitPropSink();

    HRESULT HookupEvents();
    HRESULT UnHookEvents();
    HRESULT GetMediaHost();

public:
    CContentProxy();
    virtual ~CContentProxy();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    // IContentProxy
    STDMETHOD(OnCreatedPlayer)();
    STDMETHOD(fireEvent)(enum fireEvent event);
    STDMETHOD(detachPlayer)();

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(Invoke)(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

DECLARE_REGISTRY_RESOURCEID(IDR_WMPPROXY)
DECLARE_NOT_AGGREGATABLE(CContentProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CContentProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY(IContentProxy)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_IID(IID_ITIMEMediaElement, IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CContentProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\playlist.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYLIST_H
#define _PLAYLIST_H

#include "WMPProxyPlayer.h"

class CWMPProxy;
class CPlayItem;

#define TIME_INFINITE HUGE_VAL
#define valueNotSet -1
#define LCID_SCRIPTING 0x0409
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86

#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayList :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayList, &__uuidof(CPlayList)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayList>,
    public IPropertyNotifySinkCP<CPlayList>
{
  public:
    CPlayList();
    virtual ~CPlayList();
    HRESULT ConstructArray();
        
    HRESULT Init(CWMPProxy & player);
    void Deinit();
    
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    //returns the duration of the entire playlist if it is known or -1 if it is not.
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayList)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CPlayList)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

    void Clear();
    void SetLoaded(bool bLoaded);
    void SetLoadedFlag(bool bLoaded);
    long GetLength() { return m_rgItems->Size(); }

    CPlayItem * GetActiveTrack();
    CPlayItem * GetItem(long index);
    
    HRESULT Add(CPlayItem *pPlayItem,
                long index);
    HRESULT Remove(long index);

    void SetIndex();
    long GetIndex(LPOLESTR name);

    HRESULT CreatePlayItem(CPlayItem **pPlayItem);
        
  protected:
    CPtrAry<CPlayItem *>      *m_rgItems;
    CWMPProxy *                m_player;
    bool                       m_fLoaded;
    CComVariant                m_vNewTrack;

}; //lint !e1712


class CPlayListEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
  public:
    CPlayListEnum();
    virtual ~CPlayListEnum();

    void Init(CPlayList &playList) { m_playList = &playList; }
    
    // IEnumVARIANT methods
    STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
    STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset)();
    STDMETHOD(Skip)(unsigned long celt);
    void SetCurElement(unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CPlayListEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:
    long                        m_lCurElement;
    DAComPtr<CPlayList>         m_playList;
}; //lint !e1712

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayItem :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayItem, &__uuidof(CPlayItem)>,
    public ITIMEDispatchImpl<ITIMEPlayItem2, &IID_ITIMEPlayItem2>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayItem2>,
    public IConnectionPointContainerImpl<CPlayItem>,
    public IPropertyNotifySinkCP<CPlayItem>
{
  public:
    CPlayItem();
    virtual ~CPlayItem();

    void Init(CPlayList & pPlayList) { m_pPlayList = &pPlayList; }
    void Deinit() { m_pPlayList = NULL; }
    
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // ITIMEPlayItem interface
    //
    STDMETHOD(get_abstract)(LPOLESTR *abs);
    STDMETHOD(get_author)(LPOLESTR *auth);
    STDMETHOD(get_copyright)(LPOLESTR *cpyrght);
    STDMETHOD(get_dur)(double *dur);
    STDMETHOD(get_index)(long *index);
    STDMETHOD(get_rating)(LPOLESTR *rate);
    STDMETHOD(get_src)(LPOLESTR *src);
    STDMETHOD(get_title)(LPOLESTR *title);
    STDMETHOD(setActive)();

    
    //
    // ITIMEPlayItem2 interface
    //
    STDMETHOD(get_banner)(LPOLESTR *banner);
    STDMETHOD(get_bannerAbstract)(LPOLESTR *abstract);
    STDMETHOD(get_bannerMoreInfo)(LPOLESTR *moreInfo);
    
    //
    
    LPCWSTR GetAbstract() const { return m_abstract; }
    HRESULT PutAbstract(LPWSTR abstract);

    LPCWSTR GetAuthor() const { return m_author; }
    HRESULT PutAuthor(LPWSTR author);

    LPCWSTR GetCopyright() const { return m_copyright; }
    HRESULT PutCopyright(LPWSTR copyright);

    double GetDur() const { return m_dur; }
    void PutDur(double dur);

    long GetIndex() const { return m_lIndex; }
    void PutIndex(long index);

    LPCWSTR GetRating() const { return m_rating; }
    HRESULT PutRating(LPWSTR rating);

    LPCWSTR GetSrc() const { return m_src; }
    HRESULT PutSrc(LPWSTR src);

    LPCWSTR GetTitle() const { return m_title; }
    HRESULT PutTitle(LPWSTR title);

    bool GetCanSkip() const { return m_fCanSkip; }
    HRESULT PutCanSkip(bool fCanSkip) { m_fCanSkip = fCanSkip; return S_OK; }

    LPCWSTR GetBanner() const { return m_banner; };
    LPCWSTR GetBannerAbstract() const { return m_bannerAbstract; };
    LPCWSTR GetBannerMoreInfo() const { return m_bannerMoreInfo; };
    HRESULT PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo);

    // QI Map
    BEGIN_COM_MAP(CPlayItem)
        COM_INTERFACE_ENTRY(ITIMEPlayItem2)
        COM_INTERFACE_ENTRY(ITIMEPlayItem)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CPlayItem)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

  protected:
    CPlayList            *m_pPlayList;
    LPWSTR                m_abstract;
    LPWSTR                m_author;
    LPWSTR                m_copyright;
    double                m_dur;
    int                   m_lIndex;
    LPWSTR                m_rating;
    LPWSTR                m_src;
    LPWSTR                m_title;
    bool                  m_fCanSkip;
    LPWSTR                m_banner;
    LPWSTR                m_bannerAbstract;
    LPWSTR                m_bannerMoreInfo;


};  //lint !e1712

#endif /* _PLAYLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_)
#define AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "w95wraps.h"

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#define _ATL_DEBUG_QI
//#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_LEVEL 5

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

#if defined(_M_IX86)
    #define ASSERT(expr) if (!(expr)) { __asm int 3 }
    #define Assert(expr) if (!(expr)) { __asm int 3 }
#else
    #define ASSERT(expr) DebugBreak()
    #define Assert(expr) DebugBreak()
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\rsrc\makefile.inc ===
datime.rc : $(SDK_LIB_PATH)\mstime.tlb $(TIMEIDLROOT)\mediaprivate.tlb datime.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\wmpids.h ===
//*****************************************************************************
//
// Microsoft Windows Media Player
// Copyright (C) Microsoft Corporation, 2001
//
// FileName:            wmpids.h
//
// Abstract:            Dispatch ID definitions for all public Windows Media
//                      Player Interfaces
//
//*****************************************************************************



//////////////////////////////////////////////////////////////////////
// Definitions
//////////////////////////////////////////////////////////////////////
#define DISPID_DELTA                            50


//////////////////////////////////////////////////////////////////////
// IWMPCore
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE_BASE                     0
#define DISPID_WMPCORE_URL                      DISPID_WMPCORE_BASE + 1
#define DISPID_WMPCORE_OPENSTATE                DISPID_WMPCORE_BASE + 2
#define DISPID_WMPCORE_CLOSE                    DISPID_WMPCORE_BASE + 3
#define DISPID_WMPCORE_CONTROLS                 DISPID_WMPCORE_BASE + 4
#define DISPID_WMPCORE_SETTINGS                 DISPID_WMPCORE_BASE + 5
#define DISPID_WMPCORE_CURRENTMEDIA             DISPID_WMPCORE_BASE + 6
#define DISPID_WMPCORE_NETWORK                  DISPID_WMPCORE_BASE + 7
#define DISPID_WMPCORE_MEDIACOLLECTION          DISPID_WMPCORE_BASE + 8
#define DISPID_WMPCORE_PLAYLISTCOLLECTION       DISPID_WMPCORE_BASE + 9
#define DISPID_WMPCORE_PLAYSTATE                DISPID_WMPCORE_BASE + 10
#define DISPID_WMPCORE_VERSIONINFO              DISPID_WMPCORE_BASE + 11
#define DISPID_WMPCORE_LAUNCHURL                DISPID_WMPCORE_BASE + 12
#define DISPID_WMPCORE_CURRENTPLAYLIST          DISPID_WMPCORE_BASE + 13
#define DISPID_WMPCORE_CDROMCOLLECTION          DISPID_WMPCORE_BASE + 14
#define DISPID_WMPCORE_CLOSEDCAPTION            DISPID_WMPCORE_BASE + 15
#define DISPID_WMPCORE_ISONLINE                 DISPID_WMPCORE_BASE + 16
#define DISPID_WMPCORE_ERROR                    DISPID_WMPCORE_BASE + 17
#define DISPID_WMPCORE_STATUS                   DISPID_WMPCORE_BASE + 18
#define DISPID_WMPCORE_LAST                     DISPID_WMPCORE_STATUS

//////////////////////////////////////////////////////////////////////
// IPlayer
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPOCX_BASE                  (DISPID_WMPCORE_LAST)
#define DISPID_WMPOCX_ENABLED               (DISPID_WMPOCX_BASE + 1)
#define DISPID_WMPOCX_TRANSPARENTATSTART    (DISPID_WMPOCX_BASE + 2)
#define DISPID_WMPOCX_FULLSCREEN            (DISPID_WMPOCX_BASE + 3)
#define DISPID_WMPOCX_ENABLECONTEXTMENU     (DISPID_WMPOCX_BASE + 4)
#define DISPID_WMPOCX_UIMODE                (DISPID_WMPOCX_BASE + 5)
#define DISPID_WMPOCX_LAST                  DISPID_WMPOCX_UIMODE

#define DISPID_WMPOCX2_BASE                 (DISPID_WMPOCX_LAST)
#define DISPID_WMPOCX2_STRETCHTOFIT         (DISPID_WMPOCX2_BASE + 1)
#define DISPID_WMPOCX2_WINDOWLESSVIDEO      (DISPID_WMPOCX2_BASE + 2)



//////////////////////////////////////////////////////////////////////
// IWMPCore2
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE2_BASE                    (DISPID_WMPCORE_BASE + 39)
#define DISPID_WMPCORE2_DVD                     (DISPID_WMPCORE2_BASE + 1)



//////////////////////////////////////////////////////////////////////
// IWMPControl
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCONTROLS_BASE                 DISPID_WMPCORE_BASE + DISPID_DELTA
#define DISPID_WMPCONTROLS_PLAY                 DISPID_WMPCONTROLS_BASE + 1
#define DISPID_WMPCONTROLS_STOP                 DISPID_WMPCONTROLS_BASE + 2
#define DISPID_WMPCONTROLS_PAUSE                DISPID_WMPCONTROLS_BASE + 3
#define DISPID_WMPCONTROLS_FASTFORWARD          DISPID_WMPCONTROLS_BASE + 4
#define DISPID_WMPCONTROLS_FASTREVERSE          DISPID_WMPCONTROLS_BASE + 5
#define DISPID_WMPCONTROLS_CURRENTPOSITION      DISPID_WMPCONTROLS_BASE + 6
#define DISPID_WMPCONTROLS_CURRENTPOSITIONSTRING DISPID_WMPCONTROLS_BASE + 7
#define DISPID_WMPCONTROLS_NEXT                 DISPID_WMPCONTROLS_BASE + 8
#define DISPID_WMPCONTROLS_PREVIOUS             DISPID_WMPCONTROLS_BASE + 9
#define DISPID_WMPCONTROLS_CURRENTITEM          DISPID_WMPCONTROLS_BASE + 10
#define DISPID_WMPCONTROLS_CURRENTMARKER        DISPID_WMPCONTROLS_BASE + 11
#define DISPID_WMPCONTROLS_ISAVAILABLE          DISPID_WMPCONTROLS_BASE + 12
#define DISPID_WMPCONTROLS_PLAYITEM             DISPID_WMPCONTROLS_BASE + 13
#define DISPID_WMPCONTROLS2_STEP                DISPID_WMPCONTROLS_BASE + 14

//////////////////////////////////////////////////////////////////////
// IWMPSettings
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPSETTINGS_BASE                 DISPID_WMPCONTROLS_BASE + DISPID_DELTA
#define DISPID_WMPSETTINGS_AUTOSTART            DISPID_WMPSETTINGS_BASE + 1
#define DISPID_WMPSETTINGS_BALANCE              DISPID_WMPSETTINGS_BASE + 2
#define DISPID_WMPSETTINGS_INVOKEURLS           DISPID_WMPSETTINGS_BASE + 3
#define DISPID_WMPSETTINGS_MUTE                 DISPID_WMPSETTINGS_BASE + 4
#define DISPID_WMPSETTINGS_PLAYCOUNT            DISPID_WMPSETTINGS_BASE + 5
#define DISPID_WMPSETTINGS_RATE                 DISPID_WMPSETTINGS_BASE + 6
#define DISPID_WMPSETTINGS_VOLUME               DISPID_WMPSETTINGS_BASE + 7
#define DISPID_WMPSETTINGS_BASEURL              DISPID_WMPSETTINGS_BASE + 8
#define DISPID_WMPSETTINGS_DEFAULTFRAME         DISPID_WMPSETTINGS_BASE + 9
#define DISPID_WMPSETTINGS_GETMODE              DISPID_WMPSETTINGS_BASE + 10
#define DISPID_WMPSETTINGS_SETMODE              DISPID_WMPSETTINGS_BASE + 11
#define DISPID_WMPSETTINGS_ENABLEERRORDIALOGS   DISPID_WMPSETTINGS_BASE + 12
#define DISPID_WMPSETTINGS_ISAVAILABLE          DISPID_WMPSETTINGS_BASE + 13

//////////////////////////////////////////////////////////////////////
// IWMPPlayList
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPPLAYLIST_BASE                 DISPID_WMPSETTINGS_BASE + DISPID_DELTA + DISPID_DELTA
#define DISPID_WMPPLAYLIST_COUNT                DISPID_WMPPLAYLIST_BASE + 1
#define DISPID_WMPPLAYLIST_NAME                 DISPID_WMPPLAYLIST_BASE + 2
#define DISPID_WMPPLAYLIST_GETITEMINFO          DISPID_WMPPLAYLIST_BASE + 3
#define DISPID_WMPPLAYLIST_SETITEMINFO          DISPID_WMPPLAYLIST_BASE + 4
#define DISPID_WMPPLAYLIST_CLEAR                DISPID_WMPPLAYLIST_BASE + 5
#define DISPID_WMPPLAYLIST_INSERTITEM           DISPID_WMPPLAYLIST_BASE + 6
#define DISPID_WMPPLAYLIST_APPENDITEM           DISPID_WMPPLAYLIST_BASE + 7
#define DISPID_WMPPLAYLIST_REMOVEITEM           DISPID_WMPPLAYLIST_BASE + 8
#define DISPID_WMPPLAYLIST_MOVEITEM             DISPID_WMPPLAYLIST_BASE + 9
#define DISPID_WMPPLAYLIST_ATTRIBUTECOUNT       DISPID_WMPPLAYLIST_BASE + 10
#define DISPID_WMPPLAYLIST_ATTRIBUTENAME        DISPID_WMPPLAYLIST_BASE + 11
#define DISPID_WMPPLAYLIST_ITEM                 DISPID_WMPPLAYLIST_BASE + 12
#define DISPID_WMPPLAYLIST_ISIDENTICAL          DISPID_WMPPLAYLIST_BASE + 13

//////////////////////////////////////////////////////////////////////
// IWMPCdrom
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPCDROM_BASE                    DISPID_WMPPLAYLIST_BASE + DISPID_DELTA
#define DISPID_WMPCDROM_DRIVESPECIFIER          DISPID_WMPCDROM_BASE + 1
#define DISPID_WMPCDROM_PLAYLIST                DISPID_WMPCDROM_BASE + 2
#define DISPID_WMPCDROM_EJECT                   DISPID_WMPCDROM_BASE + 3
#define DISPID_WMPCDROM_BUSY                    DISPID_WMPCDROM_BASE + 4

//////////////////////////////////////////////////////////////////////
// IWMPCdromCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPCDROMCOLLECTION_BASE                   DISPID_WMPCDROM_BASE + DISPID_DELTA
#define DISPID_WMPCDROMCOLLECTION_COUNT                  DISPID_WMPCDROMCOLLECTION_BASE + 1
#define DISPID_WMPCDROMCOLLECTION_ITEM                   DISPID_WMPCDROMCOLLECTION_BASE + 2
#define DISPID_WMPCDROMCOLLECTION_GETBYDRIVESPECIFIER    DISPID_WMPCDROMCOLLECTION_BASE + 3
#define DISPID_WMPCDROMCOLLECTION_STARTMONITORINGCDROMS  DISPID_WMPCDROMCOLLECTION_BASE + 4
#define DISPID_WMPCDROMCOLLECTION_STOPMONITORINGCDROMS   DISPID_WMPCDROMCOLLECTION_BASE + 5

//////////////////////////////////////////////////////////////////////
// IWMPStringCollection
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPSTRINGCOLLECTION_BASE                  (DISPID_WMPCDROMCOLLECTION_BASE + DISPID_DELTA + DISPID_DELTA)
#define DISPID_WMPSTRINGCOLLECTION_COUNT                 DISPID_WMPSTRINGCOLLECTION_BASE + 1
#define DISPID_WMPSTRINGCOLLECTION_ITEM                  DISPID_WMPSTRINGCOLLECTION_BASE + 2

//////////////////////////////////////////////////////////////////////
// IWMPMediaCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPMEDIACOLLECTION_BASE              DISPID_WMPSTRINGCOLLECTION_BASE + DISPID_DELTA          
#define DISPID_WMPMEDIACOLLECTION_ADD               DISPID_WMPMEDIACOLLECTION_BASE + 2
#define DISPID_WMPMEDIACOLLECTION_GETALL            DISPID_WMPMEDIACOLLECTION_BASE + 3
#define DISPID_WMPMEDIACOLLECTION_GETBYNAME         DISPID_WMPMEDIACOLLECTION_BASE + 4
#define DISPID_WMPMEDIACOLLECTION_GETBYGENRE        DISPID_WMPMEDIACOLLECTION_BASE + 5
#define DISPID_WMPMEDIACOLLECTION_GETBYAUTHOR       DISPID_WMPMEDIACOLLECTION_BASE + 6
#define DISPID_WMPMEDIACOLLECTION_GETBYALBUM        DISPID_WMPMEDIACOLLECTION_BASE + 7
#define DISPID_WMPMEDIACOLLECTION_GETBYATTRIBUTE    DISPID_WMPMEDIACOLLECTION_BASE + 8
#define DISPID_WMPMEDIACOLLECTION_REMOVE            DISPID_WMPMEDIACOLLECTION_BASE + 9
#define DISPID_WMPMEDIACOLLECTION_GETATTRIBUTESTRINGCOLLECTION DISPID_WMPMEDIACOLLECTION_BASE + 11
#define DISPID_WMPMEDIACOLLECTION_NEWQUERY          DISPID_WMPMEDIACOLLECTION_BASE + 12
#define DISPID_WMPMEDIACOLLECTION_STARTMONITORING   DISPID_WMPMEDIACOLLECTION_BASE + 13
#define DISPID_WMPMEDIACOLLECTION_STOPMONITORING    DISPID_WMPMEDIACOLLECTION_BASE + 14
#define DISPID_WMPMEDIACOLLECTION_STARTCONTENTSCAN  DISPID_WMPMEDIACOLLECTION_BASE + 15
#define DISPID_WMPMEDIACOLLECTION_STOPCONTENTSCAN   DISPID_WMPMEDIACOLLECTION_BASE + 16
#define DISPID_WMPMEDIACOLLECTION_STARTSEARCH       DISPID_WMPMEDIACOLLECTION_BASE + 17
#define DISPID_WMPMEDIACOLLECTION_STOPSEARCH        DISPID_WMPMEDIACOLLECTION_BASE + 18
#define DISPID_WMPMEDIACOLLECTION_UPDATEMETADATA    DISPID_WMPMEDIACOLLECTION_BASE + 19
#define DISPID_WMPMEDIACOLLECTION_GETMEDIAATOM      DISPID_WMPMEDIACOLLECTION_BASE + 20
#define DISPID_WMPMEDIACOLLECTION_SETDELETED        DISPID_WMPMEDIACOLLECTION_BASE + 21
#define DISPID_WMPMEDIACOLLECTION_ISDELETED         DISPID_WMPMEDIACOLLECTION_BASE + 22
#define DISPID_WMPMEDIACOLLECTION_GETBYQUERYDESCRIPTION DISPID_WMPMEDIACOLLECTION_BASE + 23
#define DISPID_WMPMEDIACOLLECTION_FREEZECOLLECTIONCHANGE  DISPID_WMPMEDIACOLLECTION_BASE + 24
#define DISPID_WMPMEDIACOLLECTION_UNFREEZECOLLECTIONCHANGE DISPID_WMPMEDIACOLLECTION_BASE + 25
#define DISPID_WMPMEDIACOLLECTION_POSTCOLLECTIONCHANGE DISPID_WMPMEDIACOLLECTION_BASE + 26

//////////////////////////////////////////////////////////////////////
// IWMPPlaylistCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPPLAYLISTARRAY_BASE                DISPID_WMPMEDIACOLLECTION_BASE + DISPID_DELTA
#define DISPID_WMPPLAYLISTARRAY_COUNT               DISPID_WMPPLAYLISTARRAY_BASE + 1
#define DISPID_WMPPLAYLISTARRAY_ITEM                DISPID_WMPPLAYLISTARRAY_BASE + 2

//////////////////////////////////////////////////////////////////////
// IWMPPlaylistCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPPLAYLISTCOLLECTION_BASE           DISPID_WMPPLAYLISTARRAY_BASE + DISPID_DELTA
#define DISPID_WMPPLAYLISTCOLLECTION_NEWPLAYLIST    DISPID_WMPPLAYLISTCOLLECTION_BASE + 2
#define DISPID_WMPPLAYLISTCOLLECTION_GETALL         DISPID_WMPPLAYLISTCOLLECTION_BASE + 3
#define DISPID_WMPPLAYLISTCOLLECTION_GETBYNAME      DISPID_WMPPLAYLISTCOLLECTION_BASE + 4
#define DISPID_WMPPLAYLISTCOLLECTION_GETBYQUERYDESCRIPTION DISPID_WMPPLAYLISTCOLLECTION_BASE + 5
#define DISPID_WMPPLAYLISTCOLLECTION_REMOVE         DISPID_WMPPLAYLISTCOLLECTION_BASE + 6
#define DISPID_WMPPLAYLISTCOLLECTION_NEWQUERY       DISPID_WMPPLAYLISTCOLLECTION_BASE + 7
#define DISPID_WMPPLAYLISTCOLLECTION_STARTMONITORING DISPID_WMPPLAYLISTCOLLECTION_BASE + 8
#define DISPID_WMPPLAYLISTCOLLECTION_STOPMONITORING DISPID_WMPPLAYLISTCOLLECTION_BASE + 9
#define DISPID_WMPPLAYLISTCOLLECTION_SETDELETED     DISPID_WMPPLAYLISTCOLLECTION_BASE + 10
#define DISPID_WMPPLAYLISTCOLLECTION_ISDELETED      DISPID_WMPPLAYLISTCOLLECTION_BASE + 11
#define DISPID_WMPPLAYLISTCOLLECTION_IMPORTPLAYLIST DISPID_WMPPLAYLISTCOLLECTION_BASE + 12

//////////////////////////////////////////////////////////////////////
//  IWMPMedia
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPMEDIA_BASE                            (DISPID_WMPPLAYLISTCOLLECTION_BASE + (4 * DISPID_DELTA))
#define DISPID_WMPMEDIA_SOURCEURL                       DISPID_WMPMEDIA_BASE + 1
#define DISPID_WMPMEDIA_IMAGESOURCEWIDTH                DISPID_WMPMEDIA_BASE + 2
#define DISPID_WMPMEDIA_IMAGESOURCEHEIGHT               DISPID_WMPMEDIA_BASE + 3
#define DISPID_WMPMEDIA_MARKERCOUNT                     DISPID_WMPMEDIA_BASE + 4
#define DISPID_WMPMEDIA_GETMARKERTIME                   DISPID_WMPMEDIA_BASE + 5
#define DISPID_WMPMEDIA_GETMARKERNAME                   DISPID_WMPMEDIA_BASE + 6
#define DISPID_WMPMEDIA_DURATION                        DISPID_WMPMEDIA_BASE + 7
#define DISPID_WMPMEDIA_DURATIONSTRING                  DISPID_WMPMEDIA_BASE + 8
#define DISPID_WMPMEDIA_ATTRIBUTECOUNT                  DISPID_WMPMEDIA_BASE + 9
#define DISPID_WMPMEDIA_GETATTRIBUTENAME                DISPID_WMPMEDIA_BASE + 10
#define DISPID_WMPMEDIA_GETITEMINFO                     DISPID_WMPMEDIA_BASE + 11
#define DISPID_WMPMEDIA_SETITEMINFO                     DISPID_WMPMEDIA_BASE + 12
#define DISPID_WMPMEDIA_ISIDENTICAL                     DISPID_WMPMEDIA_BASE + 13
#define DISPID_WMPMEDIA_NAME                            DISPID_WMPMEDIA_BASE + 14
#define DISPID_WMPMEDIA_GETITEMINFOBYATOM               DISPID_WMPMEDIA_BASE + 15
#define DISPID_WMPMEDIA_ISMEMBEROF                      DISPID_WMPMEDIA_BASE + 16
#define DISPID_WMPMEDIA_ISREADONLYITEM                  DISPID_WMPMEDIA_BASE + 17
#define DISPID_WMPMEDIA2_ERROR                          DISPID_WMPMEDIA_BASE + 18

//////////////////////////////////////////////////////////////////////
//  IWMPNetwork
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPNETWORK_BASE                            DISPID_WMPMEDIA_BASE + DISPID_DELTA
#define DISPID_WMPNETWORK_BANDWIDTH                       DISPID_WMPNETWORK_BASE + 1
#define DISPID_WMPNETWORK_RECOVEREDPACKETS                DISPID_WMPNETWORK_BASE + 2
#define DISPID_WMPNETWORK_SOURCEPROTOCOL                  DISPID_WMPNETWORK_BASE + 3
#define DISPID_WMPNETWORK_RECEIVEDPACKETS                 DISPID_WMPNETWORK_BASE + 4
#define DISPID_WMPNETWORK_LOSTPACKETS                     DISPID_WMPNETWORK_BASE + 5
#define DISPID_WMPNETWORK_RECEPTIONQUALITY                DISPID_WMPNETWORK_BASE + 6
#define DISPID_WMPNETWORK_BUFFERINGCOUNT                  DISPID_WMPNETWORK_BASE + 7
#define DISPID_WMPNETWORK_BUFFERINGPROGRESS               DISPID_WMPNETWORK_BASE + 8
#define DISPID_WMPNETWORK_BUFFERINGTIME                   DISPID_WMPNETWORK_BASE + 9
#define DISPID_WMPNETWORK_FRAMERATE                       DISPID_WMPNETWORK_BASE + 10
#define DISPID_WMPNETWORK_MAXBITRATE                      DISPID_WMPNETWORK_BASE + 11
#define DISPID_WMPNETWORK_BITRATE                         DISPID_WMPNETWORK_BASE + 12
#define DISPID_WMPNETWORK_GETPROXYSETTINGS                DISPID_WMPNETWORK_BASE + 13
#define DISPID_WMPNETWORK_SETPROXYSETTINGS                DISPID_WMPNETWORK_BASE + 14
#define DISPID_WMPNETWORK_GETPROXYNAME                    DISPID_WMPNETWORK_BASE + 15
#define DISPID_WMPNETWORK_SETPROXYNAME                    DISPID_WMPNETWORK_BASE + 16
#define DISPID_WMPNETWORK_GETPROXYPORT                    DISPID_WMPNETWORK_BASE + 17
#define DISPID_WMPNETWORK_SETPROXYPORT                    DISPID_WMPNETWORK_BASE + 18
#define DISPID_WMPNETWORK_GETPROXYEXCEPTIONLIST           DISPID_WMPNETWORK_BASE + 19
#define DISPID_WMPNETWORK_SETPROXYEXCEPTIONLIST           DISPID_WMPNETWORK_BASE + 20
#define DISPID_WMPNETWORK_GETPROXYBYPASSFORLOCAL          DISPID_WMPNETWORK_BASE + 21
#define DISPID_WMPNETWORK_SETPROXYBYPASSFORLOCAL          DISPID_WMPNETWORK_BASE + 22
#define DISPID_WMPNETWORK_MAXBANDWIDTH                    DISPID_WMPNETWORK_BASE + 23
#define DISPID_WMPNETWORK_DOWNLOADPROGRESS                DISPID_WMPNETWORK_BASE + 24
#define DISPID_WMPNETWORK_ENCODEDFRAMERATE                DISPID_WMPNETWORK_BASE + 25
#define DISPID_WMPNETWORK_FRAMESSKIPPED                   DISPID_WMPNETWORK_BASE + 26

//////////////////////////////////////////////////////////////////////
// IWMPError
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPERROR_BASE                            DISPID_WMPNETWORK_BASE + DISPID_DELTA
#define DISPID_WMPERROR_CLEARERRORQUEUE                 DISPID_WMPERROR_BASE + 1
#define DISPID_WMPERROR_ERRORCOUNT                      DISPID_WMPERROR_BASE + 2
#define DISPID_WMPERROR_ITEM                            DISPID_WMPERROR_BASE + 3
#define DISPID_WMPERROR_WEBHELP                         DISPID_WMPERROR_BASE + 4

//////////////////////////////////////////////////////////////////////
// IWMPErrorItem
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPERRORITEM_BASE                    DISPID_WMPERROR_BASE + DISPID_DELTA
#define DISPID_WMPERRORITEM_ERRORCODE               DISPID_WMPERRORITEM_BASE + 1
#define DISPID_WMPERRORITEM_ERRORDESCRIPTION        DISPID_WMPERRORITEM_BASE + 2
#define DISPID_WMPERRORITEM_ERRORCONTEXT            DISPID_WMPERRORITEM_BASE + 3
#define DISPID_WMPERRORITEM_REMEDY                  DISPID_WMPERRORITEM_BASE + 4
#define DISPID_WMPERRORITEM_CUSTOMURL               DISPID_WMPERRORITEM_BASE + 5

/////////////////////////////////////////////////////////////////////////
// IWMPClosedCaption
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPCLOSEDCAPTION_BASE                   DISPID_WMPERRORITEM_BASE + DISPID_DELTA
#define DISPID_WMPCLOSEDCAPTION_SAMISTYLE              DISPID_WMPCLOSEDCAPTION_BASE + 1
#define DISPID_WMPCLOSEDCAPTION_SAMILANG               DISPID_WMPCLOSEDCAPTION_BASE + 2
#define DISPID_WMPCLOSEDCAPTION_SAMIFILENAME           DISPID_WMPCLOSEDCAPTION_BASE + 3
#define DISPID_WMPCLOSEDCAPTION_CAPTIONINGID           DISPID_WMPCLOSEDCAPTION_BASE + 4

/////////////////////////////////////////////////////////////////////////
// IWMPDVD
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPDVD_BASE                              DISPID_WMPCLOSEDCAPTION_BASE + DISPID_DELTA
#define DISPID_WMPDVD_ISAVAILABLE                       DISPID_WMPDVD_BASE + 1
#define DISPID_WMPDVD_DOMAIN                            DISPID_WMPDVD_BASE + 2
#define DISPID_WMPDVD_TOPMENU                           DISPID_WMPDVD_BASE + 3
#define DISPID_WMPDVD_TITLEMENU                         DISPID_WMPDVD_BASE + 4
#define DISPID_WMPDVD_BACK                              DISPID_WMPDVD_BASE + 5
#define DISPID_WMPDVD_RESUME                            DISPID_WMPDVD_BASE + 6

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE_MIN                      1
#define DISPID_WMPCORE_MAX                      DISPID_WMPDVD_RESUME


//////////////////////////////////////////////////////////////////////
// DIID_WMPCoreEvents
//////////////////////////////////////////////////////////////////////
#define WMPCOREEVENT_BASE                       5000
#define DISPID_WMPCOREEVENT_OPENSTATECHANGE     (WMPCOREEVENT_BASE + 1)
#define DISPID_WMPCOREEVENT_STATUSCHANGE        (WMPCOREEVENT_BASE + 2)


#define WMPCOREEVENT_CONTROL_BASE               5100
#define DISPID_WMPCOREEVENT_PLAYSTATECHANGE     (WMPCOREEVENT_CONTROL_BASE + 1)

#define WMPCOREEVENT_SEEK_BASE                  5200
#define DISPID_WMPCOREEVENT_ENDOFSTREAM         (WMPCOREEVENT_SEEK_BASE + 1)
#define DISPID_WMPCOREEVENT_POSITIONCHANGE      (WMPCOREEVENT_SEEK_BASE + 2)
#define DISPID_WMPCOREEVENT_MARKERHIT           (WMPCOREEVENT_SEEK_BASE + 3)
#define DISPID_WMPCOREEVENT_DURATIONUNITCHANGE  (WMPCOREEVENT_SEEK_BASE + 4)

#define WMPCOREEVENT_CONTENT_BASE               5300
#define DISPID_WMPCOREEVENT_SCRIPTCOMMAND       (WMPCOREEVENT_CONTENT_BASE + 1)

#define WMPCOREEVENT_NETWORK_BASE               5400
#define DISPID_WMPCOREEVENT_DISCONNECT          (WMPCOREEVENT_NETWORK_BASE + 1)
#define DISPID_WMPCOREEVENT_BUFFERING           (WMPCOREEVENT_NETWORK_BASE + 2)
#define DISPID_WMPCOREEVENT_NEWSTREAM           (WMPCOREEVENT_NETWORK_BASE + 3)

#define WMPCOREEVENT_ERROR_BASE                 5500
#define DISPID_WMPCOREEVENT_ERROR               (WMPCOREEVENT_ERROR_BASE + 1)

#define WMPCOREEVENT_WARNING_BASE               5600
#define DISPID_WMPCOREEVENT_WARNING             (WMPCOREEVENT_WARNING_BASE + 1)

#define WMPCOREEVENT_CDROM_BASE                 5700
#define DISPID_WMPCOREEVENT_CDROMMEDIACHANGE    (WMPCOREEVENT_CDROM_BASE + 1)

#define WMPCOREEVENT_PLAYLIST_BASE                                      5800
#define DISPID_WMPCOREEVENT_PLAYLISTCHANGE                              (WMPCOREEVENT_PLAYLIST_BASE + 1)
#define DISPID_WMPCOREEVENT_MEDIACHANGE                                 (WMPCOREEVENT_PLAYLIST_BASE + 2)
#define DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE                   (WMPCOREEVENT_PLAYLIST_BASE + 3)
#define DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE                       (WMPCOREEVENT_PLAYLIST_BASE + 4)
#define DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE                (WMPCOREEVENT_PLAYLIST_BASE + 5)
#define DISPID_WMPCOREEVENT_CURRENTITEMCHANGE                           (WMPCOREEVENT_PLAYLIST_BASE + 6)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE                       (WMPCOREEVENT_PLAYLIST_BASE + 7)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED         (WMPCOREEVENT_PLAYLIST_BASE + 8)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED       (WMPCOREEVENT_PLAYLIST_BASE + 9)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE                    (WMPCOREEVENT_PLAYLIST_BASE + 10)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED             (WMPCOREEVENT_PLAYLIST_BASE + 11)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED           (WMPCOREEVENT_PLAYLIST_BASE + 12)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANADDEDITEM         (WMPCOREEVENT_PLAYLIST_BASE + 13)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANPROGRESS          (WMPCOREEVENT_PLAYLIST_BASE + 14)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHFOUNDITEM              (WMPCOREEVENT_PLAYLIST_BASE + 15)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHPROGRESS               (WMPCOREEVENT_PLAYLIST_BASE + 16)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHCOMPLETE               (WMPCOREEVENT_PLAYLIST_BASE + 17)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED      (WMPCOREEVENT_PLAYLIST_BASE + 18)
#define DISPID_WMPCOREEVENT_MODECHANGE                                  (WMPCOREEVENT_PLAYLIST_BASE + 19)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGCHANGED       (WMPCOREEVENT_PLAYLIST_BASE + 20)
#define DISPID_WMPCOREEVENT_MEDIAERROR                                  (WMPCOREEVENT_PLAYLIST_BASE + 21)
#define DISPID_WMPCOREEVENT_DOMAINCHANGE                                (WMPCOREEVENT_PLAYLIST_BASE + 22)
#define DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH                          (WMPCOREEVENT_PLAYLIST_BASE + 23)


//*****************************************************************************
//
//  End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\wmpproxyplayer.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: WMPProxyPlayer.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#include "stdafx.h"
#include "BrowseWM.h"
#include "WMPProxyPlayer.h"
#include "wmpids.h"

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

// WMP 7/8 GUID
const GUID GUID_WMP = {0x6BF52A52,0x394A,0x11d3,{0xB1,0x53,0x00,0xC0,0x4F,0x79,0xFA,0xA6}};

/////////////////////////////////////////////////////////////////////////////
// CWMPProxy

CWMPProxy::CWMPProxy() :
    m_pdispWmp(0),
    m_fNewPlaylist(false),
    m_fPlaylist(false),
    m_fPaused(false),
    m_fRunning(false),
    m_fSrcChanged(false),
    m_fResumedPlay(false),
    m_fAudio(true),
    m_fBuffered(false),
    m_dblPos(0.0),
    m_dblClipDur(TIME_INFINITE),
    m_dwMediaEventsCookie(0),
    m_fEmbeddedPlaylist(false),
    m_fCurrLevelSet(false),
    m_lTotalNumInTopLevel(0),
    m_lDoneTopLevel(0)
{
}

CWMPProxy::~CWMPProxy()
{
    m_pdispWmp = 0;
}

//
// Put Property
//
HRESULT STDMETHODCALLTYPE CWMPProxy::PutProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* vararg)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    DISPPARAMS  params      = {vararg, &dispidPut, 1, 1};

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYPUT,
            &params, NULL, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// Get Property
//
HRESULT STDMETHODCALLTYPE CWMPProxy::GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult,
                                             DISPPARAMS* pParams = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {NULL, NULL, 0, 0};

    if (!pParams)
    {
        pParams = &params;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
            pParams, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// Call Method
//
HRESULT STDMETHODCALLTYPE CWMPProxy::CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, 
                                                VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::CreateContainedControl
// Creates the WMP Control
//
HRESULT STDMETHODCALLTYPE CWMPProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT hr = S_OK;
    VARIANT vararg = {0};

    if (!m_pdispWmp)
    {
        hr = CreateControl(GUID_WMP, IID_IDispatch,
                reinterpret_cast<void**>(&m_pdispWmp));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Need to change the UIMode to None, so that WMP does not show its own controls
    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"none";

    hr = PutProp(m_pdispWmp, L"uiMode", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

// If the client site is changed then an init call must be made.
STDMETHODIMP CWMPProxy::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto punt;
    }

punt:
    hr = CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>::SetClientSite(pClientSite);
    
done:
    return hr;
}

//
// CWMPProxy::begin
// Starts playing the media item.
//
HRESULT STDMETHODCALLTYPE CWMPProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT mediaitem = {0};
    VARIANT position = {0};

    hr = SUPER::begin();
    if (FAILED(hr))
    {
        goto done;
    }

    // get the control object
    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    // we need to seek to 0 to start playing.
    // there was an issue with play-pause-play,
    // so this is our hack around it.
    position.vt = VT_R8;
    position.dblVal = 0.0;

    hr = PutProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"play");
    if (FAILED(hr))
    {
        goto done;
    }

    m_fRunning = true;

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::end
// Stops playing the media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::end(void)
{
    ATLTRACE(_T("end\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    long lIndex;

    hr = SUPER::end();
    if (FAILED(hr))
    {
        goto done;
    }

    // need to reset the playlist back to track 0
    GetActiveTrack(&lIndex);
    if (lIndex != 0)
    {
        SetActiveTrack(0);
    }

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"stop");
    if (FAILED(hr))
    {
        goto done;
    }

    m_fRunning = false;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::resume
// Resumes playback of a paused media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT mediaitem = {0};
    VARIANT control = {0};
    VARIANT position = {0};

    hr = SUPER::resume();
    if (FAILED(hr))
    {
        goto done;
    }

    // if its not paused, exit
    if (m_fPaused)
    {
        m_fPaused = false;

        // everytime to resume play, we get a PlayStateChange event
        // we use that event to fire up some other events within mstime.
        // in order to avoid screwing up our state, we need this
        // to ignore the PlayStateChangeEvent
        m_fResumedPlay = true;

        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;    
        }

        hr = CallMethod(control.pdispVal, L"play");
        if (FAILED(hr))
        {
            goto done;
        }

        // seek back to the location we were previously paused at
        // and resume playback from there.
        position.vt = VT_R8;
        position.dblVal = m_dblPos;

        hr = PutProp(control.pdispVal, L"currentPosition", &position);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::pause
// Pauses playback of a media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT position = {0};

    hr = SUPER::pause();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"pause");
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the current location of the item
    // resumes at current location
    // some flakiness here...on a resume, we can
    // see the item go back maybe a millisecond or so.
    hr = GetProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    // no need to set paused to true it we are at 0.0
    m_fPaused = false;
    if (position.dblVal > 0)
    {
        m_fPaused = true;
        m_dblPos = position.dblVal;
    }

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::put_src
// Tells WMP what source to use for the media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::put_src(BSTR bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    VARIANT vararg = {0};
    VARIANT control = {0};
    VARIANT settings = {0};
    VARIANT isPlaylist = {0};

    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    hr = SUPER::put_src(bstrURL);
    if (FAILED(hr))
    {
        goto done;
    }

    // need to set autostart to false.
    // we should ONLY play when we get a begin
    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"false";
    hr = PutProp(settings.pdispVal, L"autoStart", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = PutProp(settings.pdispVal, L"enableErrorDialogs", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"true";
    hr = PutProp(m_pdispWmp, L"stretchToFit", &vararg);
    // This property is not in WMP7 yet, so it will fail
    // so lets ignore the HRESULT we get back.
    /*
    if (FAILED(hr))
    {
        goto done;
    }
    */

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = bstrURL;

    hr = PutProp(m_pdispWmp, L"URL", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    // if we have a playlist from out previous item,
    // release it.
    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    // tells us that our source has just changed.
    // this way, we don't fire a mediacomplete
    // event more than once for any item.
    m_fSrcChanged = true;

    m_fEmbeddedPlaylist = false;
    m_fCurrLevelSet = false;
    m_lTotalNumInTopLevel = 0;
    m_lDoneTopLevel = 0;

done:
    VariantClear(&control);
    VariantClear(&settings);

    return hr;
}

//
// CWMPProxy::put_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CWMPProxy::put_CurrentTime(double dblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::get_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CWMPProxy::get_CurrentTime(double* pdblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::Init
// Sets up everything
//
STDMETHODIMP CWMPProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = InitPropSink();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateContainedControl();
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return S_OK;
}

//
// CWMPProxy::Detach
// Cleans up anything we are holding on to
//
STDMETHODIMP CWMPProxy::Detach(void)
{
    // need to unadvise from WMP
    if ((m_pcpMediaEvents) && (m_dwMediaEventsCookie != 0))
    {
        m_pcpMediaEvents->Unadvise(m_dwMediaEventsCookie);
        m_pcpMediaEvents.Release();
        m_dwMediaEventsCookie = 0;
    }

    // Clean up playlist
    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    // we should close the WMP player
    // who knows what they might hold on to if we don't call this
    CallMethod(m_pdispWmp, L"close");
    m_pdispWmp = NULL;

    // call this before releasing everything else.
    DeinitPropSink();

    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    return S_OK;
}

//
// CWMPProxy::reset
// 
//
STDMETHODIMP CWMPProxy::reset(void) 
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0;

    // apparently we have to wait until the script engine is hooked up
    // before we can hook ourseleves up to the events.
    // we should be ok here.
    if(m_dwMediaEventsCookie == 0)
    {
        hr = m_pdispWmp->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = pcpc->FindConnectionPoint(DIID__WMPOCXEvents, &m_pcpMediaEvents);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        hr = m_pcpMediaEvents->Advise(GetUnknown(), &m_dwMediaEventsCookie);
        if (FAILED(hr))
        {
            hr = S_OK;
            m_pcpMediaEvents.Release();
            m_dwMediaEventsCookie = 0;
            goto done;
        }
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }

    if (!bNeedActive) // see if we need to stop the media.
    {
        if(m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (!m_fRunning)
    {
        begin(); // add a seek after this
        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
        m_dblPos = dblSegTime;
    }

    //Now see if we need to change the pause state.

    if (bNeedPause && !m_fPaused)
    {
        pause();
    }
    else if (!bNeedPause && m_fPaused)
    {
        resume();
    }

done:
    return hr;
}

//
// CWMPProxy::repeat
// Repeats the media item
//
STDMETHODIMP CWMPProxy::repeat(void)
{
    return begin();
}

//
// CWMPProxy::seek
// Seeks to a location within a media item
//
STDMETHODIMP CWMPProxy::seek(double dblSeekTime)
{
    HRESULT hr = S_OK;
    VARIANT mediaitem = {0};
    VARIANT control = {0};
    VARIANT position = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;    
    }

    // hmmm, I wonder if WMP will crap out if this value is something stupid
    // do we need bounds checking?
    position.vt = VT_R8;
    position.dblVal = dblSeekTime;

    hr = PutProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::put_clipBegin
// Not implemented
//
STDMETHODIMP CWMPProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::put_clipEnd
// Not implemented
//
STDMETHODIMP CWMPProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::put_volume
// Sets volume for current media item
//
STDMETHODIMP CWMPProxy::put_volume(float flVolume)
{
    HRESULT hr = S_OK;
    VARIANT settings = {0};
    VARIANTARG vararg = {0};

    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_I4;
    vararg.lVal = (long) (flVolume*100);
    
    hr = PutProp(settings.pdispVal, L"volume", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&settings);

    return hr;
}
 
//
// CWMPProxy::put_mute
// Sets Mute for audio
//

STDMETHODIMP CWMPProxy::put_mute(VARIANT_BOOL bMute)
{
    HRESULT hr = S_OK;
    VARIANT settings = {0};
    VARIANTARG vararg = {0};

    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BOOL;
    vararg.boolVal = bMute;
    
    hr = PutProp(settings.pdispVal, L"mute", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&settings);

    return hr;
}

//
// CWMPProxy::get_hasDownloadProgress
// returns if there is any download progress or not
//
STDMETHODIMP CWMPProxy::get_hasDownloadProgress(VARIANT_BOOL * bProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *bProgress = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"downloadProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }
    

    if (progress.lVal > 0 && progress.lVal < 100)
    {
        *bProgress = VARIANT_TRUE;
    }

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_DownloadProgress
// returns download progress (percent)
//
STDMETHODIMP CWMPProxy::get_downloadProgress(long * lProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *lProgress = 0;

    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"downloadProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }

    *lProgress = progress.lVal;

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_isBuffered
// returns if object if buffered
//
STDMETHODIMP CWMPProxy::get_isBuffered(VARIANT_BOOL * bBuffered)
{
    *bBuffered = (m_fBuffered ? VARIANT_TRUE : VARIANT_FALSE);
    return S_OK;
}

//
// CWMPProxy::get_bufferingProgress
// returns buffering progress (percent)
//
STDMETHODIMP CWMPProxy::get_bufferingProgress(long * lProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *lProgress = 0;


    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"bufferingProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }

    *lProgress = progress.lVal;

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_currTime
//
STDMETHODIMP CWMPProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT position = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    *pdblCurrentTime = position.dblVal;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_clipDur
// Returns the current duration of the clip
//
STDMETHODIMP CWMPProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if (!pdbl)
    {
        return E_POINTER;
    }

    *pdbl = m_dblClipDur;
    return hr;
}

//
// CWMPProxy::get_mediaDur
// Not implemented
//
STDMETHODIMP CWMPProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CWMPProxy::get_state
// Gets the current state of the player
//
STDMETHODIMP CWMPProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    VARIANT playstate = {0};

    hr = GetProp(m_pdispWmp, L"playstate", &playstate);
    if (FAILED(hr))
    {
        goto done;
    }

    switch(playstate.lVal)
    {
    case wmppsUndefined:
        *state = TS_Inactive;
        break;
    case wmppsStopped:
    case wmppsPlaying:
    case wmppsMediaEnded:
    case wmppsReady:
        *state = TS_Active;
        break;
    case wmppsBuffering:
    case wmppsWaiting:
        *state = TS_Cueing;
        break;
    case wmppsScanForward:
    case wmppsScanReverse:
        *state = TS_Seeking;
        break;
    default:
        *state = TS_Active;
        break;
    }

done:
    return hr;
}

//
// CWMPProxy::get_playList
// Gets the current playlist
//
STDMETHODIMP CWMPProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(plist);

    // this is not a playlist source
    if (!m_fPlaylist)
    {
        goto done;
    }
 
    if (m_playList.p)
    {
        hr = m_playList->QueryInterface(IID_ITIMEPlayList, (void**)plist);
        goto done;
    }

    // create a playlist
    hr = CreatePlayList();
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    // fill it
    hr = FillPlayList(m_playList);
    if (FAILED(hr))
    {
        goto done;
    }

    // set loaded to true
    m_playList->SetLoadedFlag(true);

    hr = m_playList->QueryInterface(IID_ITIMEPlayList, (void**)plist);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::get_abstract
// Get media item info
//
STDMETHODIMP CWMPProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"abstract";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_author
// Get media item info
//
STDMETHODIMP CWMPProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"author";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_copyright
// Get media item info
//
STDMETHODIMP CWMPProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"copyright";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_rating
// Get media item info
//
STDMETHODIMP CWMPProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"rating";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_title
// Get media item info
//
STDMETHODIMP CWMPProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"title";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_canPause
// Checks to see it the media item can be paused
//
STDMETHODIMP CWMPProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT pause = {0};
    VARIANTARG vararg = {0};
    DISPID dispidGet = DISPID_UNKNOWN;
    DISPPARAMS params = {&vararg, &dispidGet, 1, 0};

    if(pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *pvar = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"Pause";

    // WMP docs lie!
    // They say that isAvailable is a Method, rather than a property
    // took me 1/2 hour to figure out that I was doing the wrong thing.
    hr = GetProp(control.pdispVal, L"isAvailable", &pause, &params);
    if (FAILED(hr))
    {
        goto done;
    }

    *pvar = pause.boolVal;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_canSeek
// Checks to see if we can seek in the media item
// hard coded to return true
//
STDMETHODIMP CWMPProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    CComVariant control;
    CComVariant seek;
    VARIANTARG vararg = {0};
    DISPID dispidGet = DISPID_UNKNOWN;
    DISPPARAMS params = {&vararg, &dispidGet, 1, 0};

    if(pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *pvar = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr) || (V_VT(&control) != VT_DISPATCH))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"CurrentPosition";

    hr = GetProp(V_DISPATCH(&control), L"isAvailable", &seek, &params);
    if (FAILED(hr) || (V_VT(&seek) != VT_BOOL))
    {
        goto done;
    }

    *pvar = V_BOOL(&seek);

done:
    return hr;
}

//
// CWMPProxy::get_hasAudio
// Checks to see if media item has audio?
// hard coded to return false... (?)
//
STDMETHODIMP CWMPProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

//
// CWMPProxy::get_hasVisual
// Checks to see if media item has visual
//
STDMETHODIMP CWMPProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    // If its a audio file, we should have no visual
    // WMP shows visualizations by default, and we dont
    // want that.
    *pvar = m_fAudio ? VARIANT_FALSE : VARIANT_TRUE;

done:
    return hr;
}

//
// CWMPProxy::get_mediaHeight
// Gets the current media height
//
STDMETHODIMP CWMPProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT itemheight = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(media.pdispVal, L"imageSourceHeight", &itemheight);
    if (FAILED(hr))
    {
        goto done;
    }

    *pl = itemheight.lVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_mediaWidth
// Gets the current media width
//
STDMETHODIMP CWMPProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT itemwidth = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(media.pdispVal, L"imageSourceWidth", &itemwidth);
    if (FAILED(hr))
    {
        goto done;
    }

    *pl = itemwidth.lVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_customObject
// Return the WMP dispatch object
//
STDMETHODIMP CWMPProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;

    return SUPER::get_playerObject(ppdisp);
}

//
// CWMPProxy::getControl
// Return the control
//
STDMETHODIMP CWMPProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::Invoke
// 
STDMETHODIMP
CWMPProxy::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{
    HRESULT hr = S_OK;

    // We need to process events that we use and punt the rest
    // hmmm, if ProcessEvent returns a failure, should we still punt it?
    // yeah probably, just in case if our parent knows what the hell
    // to do with it.
    hr = ProcessEvent(dispIDMember,
                        pDispParams->cArgs, 
                        pDispParams->rgvarg);

    // Punt it!
    hr = CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>::Invoke(dispIDMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr);
    return hr;
} // Invoke

//
// CWMPProxy::ProcessEvent
// Process events that we need
//
HRESULT
CWMPProxy::ProcessEvent(DISPID dispid,
                               long lCount, 
                               VARIANT varParams[])
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
      case DISPID_WMPCOREEVENT_BUFFERING:
          if (varParams[0].boolVal == VARIANT_TRUE)
          {
              m_fBuffered = true;
          }
          break;
      case DISPID_WMPCOREEVENT_PLAYSTATECHANGE:
          hr = OnPlayStateChange(lCount, varParams);
          break;
      case DISPID_WMPCOREEVENT_OPENSTATECHANGE:
          hr = OnOpenStateChange(lCount, varParams);
          break;
      case DISPID_WMPCOREEVENT_ERROR:
          hr = NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);
          break;
      default:
          break;
    }

    return hr;
}

//
// CWMPProxy::OnPlayStateChange
// Handles the Play state change events
//
HRESULT
CWMPProxy::OnPlayStateChange(long lCount, VARIANT varParams[])
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT mediaitem = {0};
    VARIANT duration = {0};
 
    Assert(lCount == 1);
    
    // MediaPlaying
    if (varParams[0].lVal == wmppsPlaying)
    {
        // media just started playing
        // if it was resumed, then ignore
        if (m_fResumedPlay)
        {
            m_fResumedPlay = false;
            goto done;
        }

        // if we have a playlist,
        // we need to check if the item that is playing is
        // the first one, and only fire a duration change event
        // in that case
        if (m_fPlaylist)
        {
            long lindex;
            CPlayItem * pPlayItem;

            hr = GetActiveTrack(&lindex);
            if (FAILED(hr))
            {
                goto done;
            }

            if (lindex == 0)
            {
                // set initial clip duration to infinite
                m_dblClipDur = TIME_INFINITE;
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }

            // we need to update the duration in playitem so that
            // someone can grab it.
            hr = GetProp(m_pdispWmp, L"controls", &control);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(mediaitem.pdispVal, L"duration", &duration);
            if (FAILED(hr))
            {
                goto done;
            }

            pPlayItem = m_playList->GetActiveTrack();
            if (!pPlayItem)
            {
                goto done;
            }

            pPlayItem->PutDur(duration.dblVal);

            goto done;
        }

        // if its not a playlist,
        // we can just the clip duration from WMP
        // and give that to mstime.
        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(mediaitem.pdispVal, L"duration", &duration);
        if (FAILED(hr))
        {
            goto done;
        }

        m_dblClipDur = duration.dblVal;
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
    }

    // MediaEnded
    if (varParams[0].lVal == wmppsMediaEnded)
    {
        // if its a playlist,
        // we need to check if the item is the last item
        // on the playlist and then
        // we need to get the total media time
        // from mstime and just fire a clip duration
        // change event.
        if (m_fPlaylist)
        {
            long lindex, lcount;

            hr = GetActiveTrack(&lindex);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetTrackCount(&lcount);
            if (FAILED(hr))
            {
                goto done;
            }

            if ((lcount-1 == lindex && m_lTotalNumInTopLevel-1 <= m_lDoneTopLevel) ||
                (lcount-1 == lindex && !m_fEmbeddedPlaylist))
            {
                end();
                m_fPlaylist = false;
                if (m_playList)
                {
                    m_playList->Deinit();
                    m_playList.Release();
                }
                m_spTIMEState->get_simpleTime(&m_dblClipDur);
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }

            goto done;
        }

        // if its a single media item
        // even though we got the duration from WMP
        // there is a lag between the media item actually playing
        // and WMP booting up (and sometimes large in some cases)
        // so to be on the safe side, we will just get the time from
        // mstime and use that instead.
        m_spTIMEState->get_segmentTime(&m_dblClipDur);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
    }
 
done:
    VariantClear(&mediaitem);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::OnOpenStateChange
// Handles the Open State Change events
//
HRESULT
CWMPProxy::OnOpenStateChange(long lCount, VARIANT varParams[])
{
    HRESULT hr = S_OK;

    Assert(lCount == 1);

    if (!m_fRunning && !m_fSrcChanged)
    {
        goto done;
    }
    
    // Playlist Changing
    if (varParams[0].lVal == wmposPlaylistChanging)
    {
        // we have a new playlist
        m_fNewPlaylist = true;
    }
    if (varParams[0].lVal == wmposPlaylistChanged)
    {
        m_fNewPlaylist = true;
        if (m_varPlaylist.vt != VT_EMPTY)
        {
            m_fEmbeddedPlaylist = true;
        }

        CComVariant playlist;

        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        if (playlist.pdispVal == m_varPlaylist.pdispVal)
        {
            ++m_lDoneTopLevel;
        }
    }
    // Playlist Opened
    if (varParams[0].lVal == wmposPlaylistOpenNoMedia)
    {
        // our new playlist has opened, so we need to get all the info for it
        if (m_fNewPlaylist)
        {
            DAComPtr<ITIMEPlayList> spPlaylist;
            CComVariant playlist, count;

            // recalulate playlists..
            m_fNewPlaylist = false;
            m_fPlaylist = true;
            
            if (m_playList)
            {
                m_playList->Deinit();
                m_playList.Release();
            }

            hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(playlist.pdispVal, L"count", &count);
            if (FAILED(hr))
            {
                goto done;
            }

            // if we are at the top level
            // get the playlist info for top level
            if (!m_fCurrLevelSet)
            {
                m_varPlaylist.Copy(&playlist);
                m_fCurrLevelSet = true;
                m_lTotalNumInTopLevel = count.lVal;
            }

            get_playList(&spPlaylist);
        }
    }
    // Media Opened
    else if (varParams[0].lVal == wmposMediaOpen)
    {
        // set the default size of the video
        RECT rectSize;

        rectSize.top = rectSize.left = 0;
        get_mediaHeight(&rectSize.bottom);
        get_mediaWidth(&rectSize.right);

        // new media...set buffered to false by default
        // event will capture if its actually buffered or not.
        m_fBuffered = false;

        if ((rectSize.bottom == 0) && (rectSize.right == 0))
        {
            m_fAudio = true;
        }
        else
        {
            m_fAudio = false;
        }

        m_spOleInPlaceSite->OnPosRectChange(&rectSize);

        // this fires the ONMEDIACOMPLETE event
        // so we should only fire it once
        if (m_fSrcChanged)
        {
            NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
            m_fSrcChanged = false;
        }
        else if (m_fPlaylist)
        {
            // we just got a media open event
            // but it was not a new src
            // so it was obviously a track change
            NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);
        }

        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_TITLE);
    }

done:
    return hr;
}

//
// CWMPProxy::GetConnectionPoint
//
HRESULT CWMPProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//
// CWMPProxy::NotifyPropertyChanged
// notifies all the connections that one of the property has changed
//
HRESULT CWMPProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

//
// CWMPProxy::InitPropSink
//
HRESULT CWMPProxy::InitPropSink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

//
// CWMPProxy::DeinitPropSink
//
void CWMPProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

//
// CWMPProxy::OnRequestEdit
//
STDMETHODIMP
CWMPProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

//
// CWMPProxy::OnChanged
//
STDMETHODIMP
CWMPProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}

//
// CWMPProxy::GetTrackCount
// gets the number of tracks in the current playlist
//
HRESULT CWMPProxy::GetTrackCount(long* lCount)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT count = {0};

    if (m_fPlaylist && m_playList)
    {
        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(playlist.pdispVal, L"count", &count);
        if (FAILED(hr))
        {
            goto done;
        }

        if (lCount)
        {
            *lCount = count.lVal;
        }
    }

done:
    VariantClear(&playlist);

    return hr;
}

//
// CWMPProxy::GetActiveTrack
// gets the active track number
//
HRESULT CWMPProxy::GetActiveTrack(long* index)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT playlist = {0};
    VARIANT playitem1 = {0};
    VARIANT playitem2 = {0};
    VARIANT count = {0};

    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    if (m_fPlaylist && m_playList)
    {
        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        // retrieve the current item
        hr = GetProp(control.pdispVal, L"currentItem", &playitem1);
        if (FAILED(hr))
        {
            goto done;
        }

        // retrieve the current playlist
        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        // gets the number of tracks
        hr = GetProp(playlist.pdispVal, L"count", &count);
        if (FAILED(hr))
        {
            goto done;
        }

        // search for the current item in the current playlist
        for (int i = 0; i < count.lVal; ++i)
        {
            vararg.vt       = VT_UINT;
            vararg.uintVal    = i;

            hr = GetProp(playlist.pdispVal, L"item", &playitem2, &params);
            if (FAILED(hr))
            {
                goto done;
            }

            if (playitem1.pdispVal == playitem2.pdispVal)
            {
                *index = i;
                break;
            }
        }
    }

done:
    VariantClear(&control);
    VariantClear(&playlist);
    VariantClear(&playitem1);
    VariantClear(&playitem2);

    return hr;
}

//
// CWMPProxy::IsActive
//
bool CWMPProxy::IsActive()
{
    return true;
}

//
// CWMPProxy::SetActiveTrack
// set the active track number
//
HRESULT CWMPProxy::SetActiveTrack(long index)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT playitem = {0};
    VARIANT control = {0};
    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    if (m_fPlaylist && m_playList)
    {

        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        // set the active track number
        // do we need bounds checking here?
        // probably not, but maybe an assert?
        vararg.vt       = VT_UINT;
        vararg.uintVal    = index;

        hr = GetProp(playlist.pdispVal, L"item", &playitem, &params);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CallMethod(control.pdispVal, L"playItem", NULL, &playitem);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    VariantClear(&playlist);
    VariantClear(&playitem);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::CreatePlayList
// create the playlist object
//
HRESULT CWMPProxy::CreatePlayList()
{
    HRESULT hr = S_OK;

    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = CComObject<CPlayList>::CreateInstance(&pPlayList);
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = pPlayList->Init(*this);
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = S_OK;

done:
    return hr;
}

//
// CWMPProxy::FillPlayList
// fill the playlist object
//
HRESULT CWMPProxy::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT media = {0};
    VARIANT count = {0};
    VARIANT iteminfo = {0};
    VARIANT duration = {0};
    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    // we changed our source. need to clear out playlist stuff
    hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(playlist.pdispVal, L"count", &count);
    if (FAILED(hr))
    {
        goto done;
    }

    for (int i = 0; i < count.lVal; ++i)
    {
        CComPtr<CPlayItem> pPlayItem;

        vararg.vt       = VT_BSTR;

        //create the playitem
        hr = pPlayList->CreatePlayItem(&pPlayItem);
        if (FAILED(hr))
        {
            goto done; //can't create playitems.
        }

        // get all the info and fill it in
        vararg.vt = VT_UINT;
        vararg.uintVal = i;
        hr = GetProp(playlist.pdispVal, L"item", &media, &params);
        hr = GetProp(media.pdispVal, L"sourceURL", &iteminfo);
        if (hr == S_OK)
        {
            pPlayItem->PutSrc(iteminfo.bstrVal);
        }

        hr = GetProp(media.pdispVal, L"duration", &duration);
        if (hr == S_OK)
        {
            pPlayItem->PutDur(duration.dblVal);
        }

        vararg.vt       = VT_BSTR;
        vararg.bstrVal  = L"title";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutTitle(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"author";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutAuthor(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"copyright";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutCopyright(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"abstract";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutAbstract(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"rating";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutRating(iteminfo.bstrVal);
        }

        //add the playitem to the playlist.
        pPlayList->Add(pPlayItem, -1);
    }

done:
    VariantClear(&playlist);
    VariantClear(&media);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\wmp\wmpproxyplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: WMPProxyPlayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#include "w95wraps.h"
#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"
#include "array.h"
#include "playlist.h"
#include "wmp_i.c"
#include "wmp.h"

class CPlayList;

/////////////////////////////////////////////////////////////////////////////
// CWMPProxy
class CWMPProxy : 
    public CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>,
    public IConnectionPointContainerImpl<CWMPProxy>,
    public IPropertyNotifySinkCP<CWMPProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl,
    public ITIMEMediaPlayerAudio,
    public ITIMEMediaPlayerNetwork
{
private:
    typedef CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;
    DWORD m_dwMediaEventsCookie;
    DAComPtr<IConnectionPoint> m_pcpMediaEvents;

protected:
    CComPtr<IDispatch> m_pdispWmp;

    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;

    STDMETHOD(CreateContainedControl)(void);
    STDMETHOD(CallMethod)(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1);
    STDMETHOD(PutProp)(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* vararg);
    STDMETHOD(GetProp)(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams);
private:

    bool m_fNewPlaylist;
    bool m_fPlaylist;
    bool m_fPaused;
    bool m_fRunning;
    bool m_fSrcChanged;
    bool m_fResumedPlay;
    bool m_fAudio;
    bool m_fBuffered;
    bool m_fCurrLevelSet;
    bool m_fEmbeddedPlaylist;
    double m_dblPos;
    double m_dblClipDur;
    long m_lDoneTopLevel;
    long m_lTotalNumInTopLevel;
    CComVariant m_varPlaylist;
    DAComPtr<CPlayList> m_playList;

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    HRESULT CreatePlayList();
    HRESULT FillPlayList(CPlayList *pPlayList);
    HRESULT ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[]);
    HRESULT OnOpenStateChange(long lCount, VARIANT varParams[]);
    HRESULT OnPlayStateChange(long lCount, VARIANT varParams[]);
    HRESULT GetTrackCount(long* lCount);

    void DeinitPropSink();

public:
    CWMPProxy();
    virtual ~CWMPProxy();

    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long* index);
    bool IsActive();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(put_volume)(float f);
    STDMETHOD(put_mute)(VARIANT_BOOL m);

    STDMETHOD(get_hasDownloadProgress)(VARIANT_BOOL * b);
    STDMETHOD(get_downloadProgress)(long * l);
    STDMETHOD(get_isBuffered)(VARIANT_BOOL * b);
    STDMETHOD(get_bufferingProgress)(long * l);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(Invoke)(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

DECLARE_REGISTRY_RESOURCEID(IDR_WMPPROXY)
DECLARE_NOT_AGGREGATABLE(CWMPProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMPProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerAudio)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerNetwork)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_IID(DIID__WMPOCXEvents, IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CWMPProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\tags\factory.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1998 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "factory.h"
#include "..\timebvr\timeelm.h"
#include "bodyelm.h"
#include "..\media\mediaelm.h"
#include "..\anim\animelm.h"
#include "..\anim\animmotion.h"
#include "..\anim\animset.h"
#include "..\anim\animcolor.h"
#include "..\anim\animfilter.h"

DeclareTag(tagFactory, "TIME", "CTIMEFactory methods");

CTIMEFactory::CTIMEFactory()
: m_dwSafety(0)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::CTIMEFactory()",
              this));
}

CTIMEFactory::~CTIMEFactory()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::~CTIMEFactory()",
              this));
}

STDMETHODIMP 
CTIMEFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP
CTIMEFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{       
        // If we're being asked to set our safe for scripting or
        // safe for initialization options then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
        {
                // Store our current safety level to return in GetInterfaceSafetyOptions
                m_dwSafety = dwEnabledOptions & dwOptionSetMask;
                return S_OK;
        }

        return E_NOINTERFACE;
}

//+-----------------------------------------------------------
//
// Member:  behavior desc map macros
//
//------------------------------------------------------------

typedef HRESULT FN_CREATEINSTANCE (IElementBehavior ** ppBehavior);

struct BEHAVIOR_DESC
{
    LPCWSTR                 pszTagName;
    FN_CREATEINSTANCE *     pfnCreateInstance;
};

#if 0
// This template should work but for some reason I cannot initialize
// the variable in the struct.  It would make everything a 1 step
// process

template <class className>
HRESULT ElmBvrCreateInstance(IElementBehavior ** ppBehavior)
{
    HRESULT                 hr;
    CComObject<className> * pInstance;
    
    hr = THR(CComObject<className>::CreateInstance(&pInstance));
    if (S_OK != hr)                                                 
    {                                                               
        goto done;                                                  
    }                                                               
                                                                        
    hr = THR(pInstance->QueryInterface(IID_IElementBehavior,        
                                       (void**) ppBehavior));       
    if (S_OK != hr)                                                 
    {                                                               
        goto done;                                                  
    }                                                               
                                                                        
    hr = S_OK;                                                      
  done:                                                               
    if (S_OK != hr)                                                 
    {                                                               
        delete pInstance;                                           
    }
    
    return hr;                                                      
}                                                                   
#endif

#define BEHAVIOR_CREATEINSTANCE(className) className##_CreateInstance

#define DECLARE_BEHAVIOR(className)                                     \
    HRESULT BEHAVIOR_CREATEINSTANCE(className)(IElementBehavior ** ppBehavior)  \
    {                                                                   \
        HRESULT                 hr;                                     \
        CComObject<className> * pInstance;                              \
                                                                        \
        hr = THR(CComObject<className>::CreateInstance(&pInstance));    \
        if (S_OK != hr)                                                 \
        {                                                               \
            goto done;                                                  \
        }                                                               \
                                                                        \
        hr = THR(pInstance->QueryInterface(IID_IElementBehavior,        \
                                           (void**) ppBehavior));       \
        if (S_OK != hr)                                                 \
        {                                                               \
            goto done;                                                  \
        }                                                               \
                                                                        \
        hr = S_OK;                                                      \
    done:                                                               \
        if (S_OK != hr)                                                 \
        {                                                               \
            delete pInstance;                                           \
        }                                                               \
        return hr;                                                      \
    }                                                                   \


#define BEGIN_BEHAVIORS_MAP(x)                         static BEHAVIOR_DESC x[] = {
#define END_BEHAVIORS_MAP()                            { NULL, NULL }}
#define BEHAVIOR_ENTRY(className, tagName)             { tagName, BEHAVIOR_CREATEINSTANCE(className)}

//+-----------------------------------------------------------
//
//  Behaviors map
//
//  To add a new entry: execute steps 1 and 2
//
//------------------------------------------------------------

//
// STEP 1.
//

DECLARE_BEHAVIOR(CTIMEElement);
DECLARE_BEHAVIOR(CTIMEBodyElement);
DECLARE_BEHAVIOR(CTIMEMediaElement);
DECLARE_BEHAVIOR(CTIMEAnimationElement);
DECLARE_BEHAVIOR(CTIMESetAnimation);
DECLARE_BEHAVIOR(CTIMEColorAnimation);
DECLARE_BEHAVIOR(CTIMEMotionAnimation);
DECLARE_BEHAVIOR(CTIMEFilterAnimation);
    
//
// STEP 2.
//

BEGIN_BEHAVIORS_MAP(_BehaviorDescMap)

    //              className               tagName
    //              =========               =======
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_PAR              ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_SEQUENCE         ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_EXCL             ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_SWITCH           ),

    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_REF              ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_MEDIA            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_IMG              ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_AUDIO            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_VIDEO            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_ANIMATION        ),

    BEHAVIOR_ENTRY( CTIMEAnimationElement,  WZ_ANIMATE          ),
    BEHAVIOR_ENTRY( CTIMESetAnimation,      WZ_SET              ),
    BEHAVIOR_ENTRY( CTIMEColorAnimation,    WZ_COLORANIM        ),
    BEHAVIOR_ENTRY( CTIMEMotionAnimation,   WZ_MOTIONANIM       ),
    BEHAVIOR_ENTRY( CTIMEFilterAnimation,   WZ_TRANSITIONFILTER ),
    
END_BEHAVIORS_MAP();

bool
IsBodyElement(IHTMLElement * pElm)
{
    HRESULT hr;
    CComPtr<IHTMLBodyElement> spBody;

    hr = pElm->QueryInterface(IID_IHTMLBodyElement, (void**)&spBody);

    // For some reason this supposedly can succeed and return NULL
    return (S_OK == hr);
}    


bool HasBody(IHTMLElement *spElement)
{
    HRESULT hr = S_OK;
    bool bReturn = false;
    CComPtr <IHTMLElement> pParent = spElement;
    CComPtr <IHTMLElement> pNext;

    while (pParent != NULL)
    {        
        if (IsBodyElement(pParent))
        {
            bReturn = true;
            goto done;
        }        
        hr = THR(pParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            goto done;
        }   
        pParent.Release();
        pParent = pNext;
        pNext.Release();
    }

    bReturn = false;

  done:

    return bReturn;
}


HRESULT
LookupTag(IHTMLElement * pElm,
          IElementBehavior ** ppBehavior)
{
    HRESULT         hr;
    CComBSTR        bstrTagName;
    CComBSTR        bstrTagURNName;
    CComBSTR        bstrScopeName;
    BEHAVIOR_DESC   *pDesc;

    //
    // Get the tag name
    //
    
    {
        hr = THR(pElm->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            goto done;
        }

        if (bstrTagName == NULL)
        {
            hr = E_UNEXPECTED;
            goto done;
        }
    }

    //
    // Get the tag's URN and scope.
    //

    {
        CComPtr<IHTMLElement2> spElm2;
        hr = THR(pElm->QueryInterface(IID_IHTMLElement2, 
                                      (void **) &spElm2));
        if (SUCCEEDED(hr))
        {
            hr = THR(spElm2->get_tagUrn(&bstrTagURNName));       
            if (FAILED(hr))
            {
                goto done;
            }
            
            hr = THR(spElm2->get_scopeName(&bstrScopeName));       
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            goto done;
        }
    }
       
    // Detect whether or not to consult our element behavior factory list.
    // If this tag has no scope name, or the scope is the default
    // then bail out.
    // If there's a URN associated with this tag, and it is not 
    // ours, bail out.
    if ((bstrScopeName == NULL) ||
        (StrCmpIW(bstrScopeName, WZ_DEFAULT_SCOPE_NAME) == 0) ||
        ((bstrTagURNName != NULL) &&
         (StrCmpIW(bstrTagURNName, WZ_TIME_TAG_URN) != 0)))
    {
        hr = S_FALSE;
        goto done;
    }

    //
    // lookup
    //
        
    for (pDesc = _BehaviorDescMap; pDesc->pszTagName; pDesc++)
    {
        if (0 == StrCmpIW(bstrTagName, pDesc->pszTagName))
        {
            hr = THR(pDesc->pfnCreateInstance(ppBehavior));
            goto done;
        }
    }

    hr = S_FALSE;
    
  done:

    RRETURN1(hr, S_FALSE);
}

//+-----------------------------------------------------------
//
// Member:      CTIMEFactory::FindBehavior
//
//------------------------------------------------------------

STDMETHODIMP
CTIMEFactory::FindBehavior(LPOLESTR pszName,
                           LPOLESTR pszUrl,
                           IElementBehaviorSite * pSite,
                           IElementBehavior ** ppBehavior)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, pszName, pszUrl, pSite));

    HRESULT               hr;
    CComPtr<IHTMLElement> spElement;
    CComBSTR              sBSTR;
    
    CHECK_RETURN_SET_NULL(ppBehavior);

    //
    // Get the element
    //
    
    hr = THR(pSite->GetElement(&spElement));
    if (FAILED(hr))
    {
        goto done;
    }


    //check for body element on page.  If no body then bail.
    if (!HasBody(spElement))
    {
        hr = E_FAIL;
        goto done;
    }


    if (::IsElementPriorityClass(spElement))
    {
        hr = E_FAIL;
        goto done;
    }
    if (::IsElementTransition(spElement))
    {
        hr = E_FAIL;
        goto done;
    }

    //
    // Now create the correct behavior
    //
    
    if (IsBodyElement(spElement))
    {
        hr = THR(BEHAVIOR_CREATEINSTANCE(CTIMEBodyElement)(ppBehavior));
        goto done;
    }
    else
    {
        hr = THR(LookupTag(spElement, ppBehavior));

        // If we fail or return success then we are finished
        // If it returns S_FALSE it means the lookup failed
        if (S_FALSE != hr)
        {
            goto done;
        }
    }
    
    // Just create a normal behavior
    hr = THR(BEHAVIOR_CREATEINSTANCE(CTIMEElement)(ppBehavior));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------
//
// Member:      CTIMEFactory::Create, per IElementNamespaceFactory
//
//------------------------------------------------------------

STDMETHODIMP
CTIMEFactory::Create(IElementNamespace * pNamespace)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::Create(%#x)",
              this,
              pNamespace));

    HRESULT             hr;
    BEHAVIOR_DESC *     pDesc;

    for (pDesc = _BehaviorDescMap; pDesc->pszTagName; pDesc++)
    {
        BSTR bstrTagName = SysAllocString(pDesc->pszTagName);

        hr = THR(pNamespace->AddTag(bstrTagName, 0));

        SysFreeString(bstrTagName);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\tags\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#pragma once

#ifndef _FACTORY_H
#define _FACTORY_H

class ATL_NO_VTABLE CTIMEFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>,
      public IElementBehaviorFactory,
      public IElementNamespaceFactory,
      public IObjectSafety,
      public ITIMEFactory
{
  public:
    CTIMEFactory();
    virtual ~CTIMEFactory();

    DECLARE_NOT_AGGREGATABLE(CTIMEFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior);

    //
    // IElementNamespaceFactory
    //

    STDMETHOD(Create)(IElementNamespace * pNamespace);

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid,
                                         DWORD dwOptionSetMask,
                                         DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);
    
    // ITIMEFactory

    DECLARE_REGISTRY(CLSID_TIMEFactory,
                     LIBID __T(".TIMEFactory.1"),
                     LIBID __T(".TIMEFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CTIMEFactory)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
        COM_INTERFACE_ENTRY(IElementNamespaceFactory)
        COM_INTERFACE_ENTRY(ITIMEFactory)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP();

  protected:
    long m_dwSafety;
};

#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\tags\bodyelm.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\bodyelm.cpp
//
//  Contents: TIME Body behavior
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "bodyelm.h"
#include "timeparser.h"

DeclareTag(tagTimeBodyElm, "TIME: Behavior", "CTIMEBodyElement methods")

// static class data.
DWORD CTIMEBodyElement::ms_dwNumBodyElems = 0;

#define MAX_REG_VALUE_LENGTH   50

class CInternalEventNode
{
  public:
    CInternalEventNode(ITIMEInternalEventSink * pSink, double dblTime) :
           m_dblTime(dblTime), m_spSink(pSink) {}
    ~CInternalEventNode() {}

    ITIMEInternalEventSink * GetSink() { return m_spSink; }
    double GetTime() { return m_dblTime; }

  protected:
    CInternalEventNode();
        
  private:
    CComPtr<ITIMEInternalEventSink> m_spSink;
    double                      m_dblTime;
};

CTIMEBodyElement::CTIMEBodyElement() :
    m_player(*this),
    m_bodyPropertyAccesFlags(0),
    m_fStartRoot(false),
    m_bInSiteDetach(false),
    m_fRegistryRead(false),
    m_fPlayVideo(true),
    m_fShowImages(true),
    m_fPlayAudio(true),
    m_fPlayAnimations(true),
    m_bIsLoading(false)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::CTIMEBodyElement()",
              this));

    m_clsid = __uuidof(CTIMEBodyElement);
    CTIMEBodyElement::ms_dwNumBodyElems++;
}

CTIMEBodyElement::~CTIMEBodyElement()
{
    CTIMEBodyElement::ms_dwNumBodyElems--;

    if(!m_spBodyElemExternal)
    {
        Assert(0 == m_compsites.size());
        DetachComposerSites();
    }
}


STDMETHODIMP
CTIMEBodyElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    return hr;
}

HRESULT
CTIMEBodyElement::InitTimeline()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::InitTimeline()", this));
    HRESULT hr;

    hr = CTIMEElementBase::InitTimeline();
    if (FAILED(hr))
    {
        goto done;
    }

    if(m_spBodyElemExternal)
    {
        //if this body is a child in another time tree do not start time event.
        goto done;
    }

    Assert(m_timeline);
    
    if (!m_player.Init(*m_timeline))
    {
        hr = TIMEGetLastError();
        goto done;
    }

    Assert(!m_fStartRoot);

    if (GetElement())
    {
        CComBSTR pbstrReadyState;
        IHTMLElement *pEle = GetElement();
        hr = GetReadyState(pEle, &pbstrReadyState);
        if (FAILED(hr))
        {
            goto done;
        }
        if (StrCmpIW(pbstrReadyState, L"complete") == 0)
        {
            OnLoad();
        }
    }

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************

void
CTIMEBodyElement::DetachComposerSites (void)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::DetachComposerSites()",
              this));

    if (!InsideSiteDetach())
    {
        // Protect against reentrancy from a site's Unregister call.
        m_bInSiteDetach = true;
    
        // Do not allow any failure to abort the detach cycle.
        for (ComposerSiteList::iterator i = m_compsites.begin(); 
             i != m_compsites.end(); i++)
        {
            (*i)->ComposerSiteDetach();
            IGNORE_RETURN((*i)->Release());
        }
        m_compsites.clear();

        m_bInSiteDetach = false;
    }
} // CTIMEBodyElement::DetachComposerSites 

//*****************************************************************************

STDMETHODIMP
CTIMEBodyElement::Detach()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::Detach()", this));
    
    HRESULT hr;

    if(!m_spBodyElemExternal)
    {
        m_fDetaching = true;
        NotifyBodyDetaching();

        // This protects against a bug in trident that causes us to not get
        // the onUnload event before detach.
        if (!IsUnloading())
        {
            NotifyBodyUnloading();
        }

        if (m_fStartRoot)
        {
            Assert(m_timeline != NULL);
            StopRootTime(NULL);
        }

        m_player.Deinit();
    
        DetachComposerSites();
    }

    THR(CTIMEElementBase::Detach());

    if(!m_spBodyElemExternal)
    {
        std::list<CInternalEventNode * >::iterator iter;

        for(;;)
        {
            iter = m_listInternalEvent.begin();
            if (iter == m_listInternalEvent.end())
            {
                break;
            }

            ITIMEInternalEventSink * pIterSink = NULL;

            pIterSink = (*iter)->GetSink();

            IGNORE_HR(RemoveInternalEventSink(pIterSink));
        }    
    }
    
    hr = S_OK;

    return hr;
}


void
CTIMEBodyElement::OnLoad()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnLoad()", this));

    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;

    m_bIsLoading = true;
    // start root time now.
    if (!m_fStartRoot)
    {
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoad - StartRootTime() failed!"));
            goto done;
        }
    }
    
    ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    if (!fPlayAudio)
    {
        VARIANT vTrue;
        VariantInit(&vTrue);
        vTrue.vt = VT_BOOL;
        vTrue.boolVal = VARIANT_TRUE;
        base_put_mute(vTrue);
        VariantClear(&vTrue);
    }

  done:
    CTIMEElementBase::OnLoad();
    m_bIsLoading = false;
    NotifyBodyLoading();

    // This is needed since we may have skipped the call in the unload
    // due to a reentrant call during the load
    if (IsUnloading())
    {
        StopRootTime(NULL);
    }
    
    return;
}

void
CTIMEBodyElement::OnUnload()
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::OnUnload()",
              this));

    NotifyBodyUnloading();

    CTIMEElementBase::OnUnload();

    // Do this here to protect against a call to unload while we are
    // loading.  We do not do this in stoproottime itself since it is
    // used to cleanup from partial initializations
    if (m_fStartRoot)
    {
        StopRootTime(NULL);
    }
}


//+-----------------------------------------------------------------------
//
//  Member:    OnTick
//
//  Overview:  Walks the time-sorted list of internal event callbacks, 
//             looking to see if any element needs a callback this tick
//             After the object is calledback, it is removed from the list
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::OnTick()
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElem(%lx)::OnTick()",
              this));

    std::list<CInternalEventNode * >::iterator iter;
    CInternalEventNode *pEvNode = NULL;
    double dblSimpleTime;

    if(m_spBodyElemExternal)
    {
        goto done;
    }


    dblSimpleTime = GetMMBvr().GetSimpleTime();

    iter = m_listInternalEvent.begin();
    while (m_listInternalEvent.size() != 0 && 
           iter != m_listInternalEvent.end())
    {
        double dblIterTime = 0.0;
        ITIMEInternalEventSink * pIterSink = NULL;
        
        dblIterTime = (*iter)->GetTime();
        if (dblSimpleTime < dblIterTime)
        {
            // no events to fire at this time
            break;
        }

        pIterSink = (*iter)->GetSink();

        if (NULL != pIterSink)
        {
            IGNORE_HR(pIterSink->InternalEvent());
        }

        pEvNode = (*iter);
        
        // By post incrementing the iterator will be updated before it
        // is erased
        m_listInternalEvent.erase(iter++);

        delete pEvNode;
    }    
done:
    return;
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::IsPrintMedia
//
//------------------------------------------------------------------------------
bool 
CTIMEBodyElement::IsPrintMedia()
{
    bool bPrinting = false;
    CComPtr<IHTMLDocument2> spDoc2 = GetDocument();
    CComPtr<IHTMLDocument4> spDoc4;
    CComBSTR bstrMedia;

    if (!spDoc2)
    {
        goto done;
    }

    {
        HRESULT hr = S_OK;

        hr = THR(spDoc2->QueryInterface(IID_TO_PPV(IHTMLDocument4, &spDoc4)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spDoc4->get_media(&bstrMedia));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (   (::SysStringLen(bstrMedia) > 0) 
        && (0 == StrCmpIW(bstrMedia, WZ_MEDIA_PRINTING)) )
    {
        bPrinting = true;
    }

done :
    return bPrinting;
}
//  Method: CTIMEBodyElement::IsPrintMedia


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::GetTransitionDependencyMgr
//
//------------------------------------------------------------------------------
CTransitionDependencyManager *
CTIMEBodyElement::GetTransitionDependencyMgr()
{
    return &m_TransitionDependencyMgr;
}
//  Method: CTIMEBodyElement::GetTransitionDependencyMgr


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::QueryPlayOnStart
//
//------------------------------------------------------------------------------
bool
CTIMEBodyElement::QueryPlayOnStart()
{
    return ((!IsDocumentInEditMode()) && (!IsPrintMedia()) && (!IsThumbnail()));
} 
//  Method: CTIMEBodyElement::QueryPlayOnStart


//*****************************************************************************

HRESULT
CTIMEBodyElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr;
    
    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }

    if(m_spBodyElemExternal)
    {
        goto done;
    }

    if (QueryPlayOnStart())
    {
        if (!m_player.Play())
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }
    else
    {
        // always tick at 0
        m_player.OnTimer(0.0);

        if (!m_player.Pause())
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }

    // always tick at 0
    m_player.OnTimer(0.0);

    hr = S_OK;
    m_fStartRoot = true;
  done:

    if (FAILED(hr) && !m_spBodyElemExternal)
    {
        StopRootTime(tl);
    }
    
    return hr;
}

void
CTIMEBodyElement::StopRootTime(MMTimeline * tl)
{
    m_fStartRoot = false;

    if(!m_spBodyElemExternal)
    {
        m_player.Stop();
    }

    CTIMEElementBase::StopRootTime(tl);
}


HRESULT
CTIMEBodyElement::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>::Error(str, IID_ITIMEBodyElement, hr);
        delete [] str;
    }
        
    return hr;
}

//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//*****************************************************************************

bool
CTIMEBodyElement::IsDocumentStarted()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsDocumentStarted"));
    bool frc = false;
    BSTR bstrState = NULL;
    // get state
    HRESULT hr = GetDocument()->get_readyState(&bstrState);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEBodyElement::IsDocumentStarted - get_readyState() failed!"));
        goto done;
    }

    Assert(bstrState != NULL);

    if (StrCmpIW(bstrState, L"complete") == 0)
    {
        frc = true;
    }

    SysFreeString(bstrState);

done:
    return frc;
}

//*****************************************************************************

bool
CTIMEBodyElement::HaveAnimationsRegistered (void)
{
    return (0 < m_compsites.size());
} // HaveAnimationsRegistered


STDMETHODIMP
CTIMEBodyElement::RegisterComposerSite (IUnknown *piunkComposerSite)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::RegisterComposerSite(%#lx) precondition : %ld sites registered", 
              piunkComposerSite, m_compsites.size()));

    HRESULT hr;

    // If we're currently detaching our sites, there is no 
    // work to do here.
    if (!InsideSiteDetach())
    {
        CComPtr<IAnimationComposerSiteSink> piSiteSink;

        hr = piunkComposerSite->QueryInterface(IID_TO_PPV(IAnimationComposerSiteSink, 
                                                          &piSiteSink));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }
        IGNORE_RETURN(piSiteSink->AddRef());
        // @@ Need to handle memory error.
        m_compsites.push_back(piSiteSink);

        TraceTag((tagTimeBodyElm, "CTIMEBodyElement::RegisterComposerSite(%#lx) postcondition : %ld sites registered", 
                  piunkComposerSite, m_compsites.size()));
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
}  // CTIMEBodyElement::RegisterComposerSite

//*****************************************************************************

STDMETHODIMP
CTIMEBodyElement::UnregisterComposerSite (IUnknown *piunkComposerSite)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::UnregisterComposerSite(%#lx) precondition : %ld sites registered", 
              piunkComposerSite, m_compsites.size()));

    HRESULT hr;

    // If we're currently detaching our sites, there is no 
    // work to do here.
    if (!InsideSiteDetach())
    {
        CComPtr<IAnimationComposerSiteSink> piSiteSink;

        hr = piunkComposerSite->QueryInterface(IID_TO_PPV(IAnimationComposerSiteSink, 
                                                          &piSiteSink));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        {
            for (ComposerSiteList::iterator i = m_compsites.begin(); 
                 i != m_compsites.end(); i++)
            {
                if(MatchElements(*i, piSiteSink))
                {
                    // We don't want to let a release on the (*i) 
                    // be the final release for the sink object.
                    CComPtr<IAnimationComposerSiteSink> spMatchedSiteSink = (*i);
                    IGNORE_RETURN(spMatchedSiteSink->Release());
                    m_compsites.remove(spMatchedSiteSink);
                    break;
                }
            }

            // If we did not find the site in our list, return S_FALSE.
            if (m_compsites.end() == i)
            {
                hr = S_FALSE;
                goto done;
            }
            TraceTag((tagTimeBodyElm, "CTIMEBodyElement::UnregisterComposerSite(%#lx) postcondition : %ld sites registered", 
                      piunkComposerSite, m_compsites.size()));
        }

    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_INVALIDARG);
}  // CTIMEBodyElement::UnregisterComposerSite

//+-----------------------------------------------------------------------
//
//  Member:    ReadRegistryMediaSettings
//
//  Overview:  Discover registry settings for playing video and showing images
//
//  Arguments: fPlayVideo   [out] should videos be played
//             fShowImages  [out] should images be displayed
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool & fPlayAnimations)
{
    LONG lRet;
    HKEY hKeyRoot = NULL;

    if (m_fRegistryRead)
    {
        goto done;
    }
    
    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Explorer\\Main"), 0, KEY_READ, &hKeyRoot);
    if (ERROR_SUCCESS != lRet)
    {
        TraceTag((tagError, "CTIMEBodyElement::ReadRegistry, couldn't open Key for registry settings"));
        goto done;
    }

    Assert(NULL != hKeyRoot);

    IsValueTrue(hKeyRoot, _T("Display Inline Images"), m_fShowImages);

    IsValueTrue(hKeyRoot, _T("Display Inline Videos"), m_fPlayVideo);

    IsValueTrue(hKeyRoot, _T("Play_Background_Sounds"), m_fPlayAudio);

    IsValueTrue(hKeyRoot, _T("Play_Animations"), m_fPlayAnimations);



    m_fRegistryRead = true;
done:
    if (hKeyRoot)
    {
        RegCloseKey(hKeyRoot);
    }

    fPlayVideo = m_fPlayVideo;
    fShowImages = m_fShowImages;
    fPlayAudio = m_fPlayAudio;
    fPlayAnimations = m_fPlayAnimations;
    return;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsValueTrue
//
//  Overview:  Read a given value from the opened key
//
//  Arguments: hKeyRoot     Key to read from
//             pchSubKey    value to read out
//             fTrue        [out] true or false value
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::IsValueTrue(HKEY hKeyRoot, TCHAR * pchSubKey, bool & fTrue)
{
    DWORD dwSize = MAX_REG_VALUE_LENGTH;
    DWORD dwType;
    BYTE bDataBuf[MAX_REG_VALUE_LENGTH];
    LONG lRet;

    Assert(NULL != hKeyRoot);

    lRet = RegQueryValueEx(hKeyRoot, pchSubKey, 0, &dwType, bDataBuf, &dwSize);
    if (ERROR_SUCCESS != lRet)
    {
        TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsValueTrue failedRegQueryValueEx"));
        goto done;
    }

    if (REG_DWORD == dwType)
    {
        fTrue = (*(DWORD*)bDataBuf != 0);
    }
    else if (REG_SZ == dwType)
    {
        TCHAR ch = (TCHAR)(*bDataBuf);

        if (_T('1') == ch ||
            _T('y') == ch ||
            _T('Y') == ch)
        {
            fTrue = true;
        }
        else
        {
            fTrue = false;
        }
    }
    else if (REG_BINARY == dwType)
    {
        fTrue = (*(BYTE*)bDataBuf != 0);
    }
    
done:
    return;
}

//*****************************************************************************

void
CTIMEBodyElement::UpdateAnimations (void)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%p)::UpdateAnimations()", 
        this));

    ComposerSiteList listCompSites;

    // Make sure we can remove composer sites as we see fit.
    for (ComposerSiteList::iterator i = m_compsites.begin(); 
         i != m_compsites.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listCompSites.push_back(*i);
    }

    for (i = listCompSites.begin(); i != listCompSites.end(); i++)
    {
        IGNORE_RETURN((*i)->UpdateAnimations());
    }

    for (i = listCompSites.begin(); i != listCompSites.end(); i++)
    {
        IGNORE_RETURN((*i)->Release());
    }
    listCompSites.clear();

    return;
} // CTIMEBodyElement::UpdateAnimations

//*****************************************************************************


STDMETHODIMP
CTIMEBodyElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEBodyElement::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
done:
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = THR(::TimeSave(this, CTIMEBodyElement::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member: AddInternalEventSink, ITIMEInternalEventGenerator
//
//  Overview:  AddRef's objects into a sorted list based on time to fire events.
//
//  Arguments: pSink    pointer to object to receive event
//             dblTime  Body time when passed event should be fired
//
//  Returns:   S_OK if added to list, otherwise E_OUTOFMEMORY
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::AddInternalEventSink(ITIMEInternalEventSink * pSink, double dblTime)
{
    HRESULT hr = S_OK;

    bool fInserted = false;

    CInternalEventNode * pNode = NULL;
    
    std::list<CInternalEventNode * >::iterator iter;

    if (NULL == pSink)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    pNode = new CInternalEventNode(pSink, dblTime);
    if (NULL == pNode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    iter = m_listInternalEvent.begin();
    while (iter != m_listInternalEvent.end())
    {                
        double dblIterTime = (*iter)->GetTime();

        if (dblTime < dblIterTime)
        {
            // insert before
            m_listInternalEvent.insert(iter, pNode);
            fInserted = true;
            break;
        }
        iter++;
    }
    
    if (!fInserted)
    {
        // place at end
        m_listInternalEvent.insert(iter, pNode);
    }    

    hr = S_OK;

done:

    return hr; //lint !e429
}
//  Member: AddInternalEventSink, ITIMEInternalEventGenerator


//+-----------------------------------------------------------------------------
//
//  Member: RemoveInternalEventSink, ITIMEInternalEventGenerator
//
//  Overview:  Removes object from list of events to fire
//
//  Arguments: pSink    pointer to object to be removed
//             dblTime  Body time when passed event should be fired
//
//  Returns:   S_OK if added to list, otherwise E_OUTOFMEMORY
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::RemoveInternalEventSink(ITIMEInternalEventSink * pSink)
{
    HRESULT hr = S_OK;

    std::list<CInternalEventNode * >::iterator iter;
    if (m_listInternalEvent.size() == 0)
    {
        goto done;
    }

    iter = m_listInternalEvent.begin();
    while (iter != m_listInternalEvent.end())
    {
        ITIMEInternalEventSink * pIterSink = NULL;
        pIterSink = (*iter)->GetSink();
        if (pIterSink == pSink)
        {
            delete (*iter);
            m_listInternalEvent.erase(iter);
            hr = S_OK;
            goto done;
        }
        iter++;
    }

    // element wasn't found in list
    hr = S_FALSE;

done:

    return hr;
}
//  Member: RemoveInternalEventSink, ITIMEInternalEventGenerator


//+-----------------------------------------------------------------------------
//
//  Member: EvaluateTransitionTarget, ITIMETransitionDependencyMgr
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::EvaluateTransitionTarget(
                                        IUnknown *  punkTransitionTarget,
                                        void *      pvTransitionDependencyMgr)
{
    Assert(punkTransitionTarget);
    Assert(pvTransitionDependencyMgr);

    CTransitionDependencyManager * pTransitionDependencyMgr
        = (CTransitionDependencyManager *)pvTransitionDependencyMgr;

    return m_TransitionDependencyMgr.EvaluateTransitionTarget(
                                                    punkTransitionTarget,
                                                    *pTransitionDependencyMgr);
}
//  Member: EvaluateTransitionTarget, ITIMETransitionDependencyMgr


//+-----------------------------------------------------------------------------
//
//  Member: RegisterElementForSync
//
//------------------------------------------------------------------------------
void
CTIMEBodyElement::RegisterElementForSync(CTIMEElementBase *pelem)
{
    m_syncList.push_back(pelem);
}
//  Member: RegisterElementForSync


void
CTIMEBodyElement::UnRegisterElementForSync(CTIMEElementBase *pelem)
{
    UpdateSyncList::iterator iter;

    for (iter = m_syncList.begin();iter != m_syncList.end(); iter++)
    {
        if(pelem == *iter)
        {
            m_syncList.erase(iter);
            goto done;
        }
    }
done:
    return;
}

void
CTIMEBodyElement::UpdateSyncNotify()
{
    UpdateSyncList::iterator iter;

    for (iter = m_syncList.begin();iter != m_syncList.end(); iter++)
    {
        (*iter)->UpdateSync();
    }
}

HRESULT WINAPI
CTIMEBodyElement::BodyBaseInternalQueryInterface(CTIMEBodyElement* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEBodyElementBaseGUID))) 
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return BaseInternalQueryInterface(pThis, pv, pEntries, iid, ppvObject);
}

bool
CTIMEBodyElement::IsBody() const
{
    if(m_spBodyElemExternal.p == NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool
CTIMEBodyElement::IsEmptyBody() const
{
    if(m_spBodyElemExternal.p != NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\tags\bodyelm.h ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\bodyelm.h
//
//  Contents: TIME Body behavior
//
//------------------------------------------------------------------------------


#pragma once

#ifndef _BODYELM_H
#define _BODYELM_H

#include "timeelmimpl.h"
#include "mmutil.h"
#include "timebvr\mmtimeline.h"
#include "timebvr\mmplayer.h"
#include "timebvr\transdepend.h"
#include "MediaPrivate.h"

class __declspec(uuid("7f94c186-69bb-43c8-bc43-2787f18e4631"))
TIMEBodyElementBaseGUID {}; //lint !e753

//+-----------------------------------------------------------------------------
//
// CTIMEBodyElement
//
//------------------------------------------------------------------------------

typedef std::list<IAnimationComposerSiteSink*> ComposerSiteList;
typedef std::list<CTIMEElementBase*> UpdateSyncList;

class CInternalEventNode;    

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEBodyElement :
    public CTIMEElementImpl<ITIMEBodyElement, &IID_ITIMEBodyElement>,
    public CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEBodyElement>,
    public IConnectionPointContainerImpl<CTIMEBodyElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEBodyElement>,
    public IAnimationRoot,
    public ITIMEInternalEventGenerator,
    public ITIMETransitionDependencyMgr
{
public:

    CTIMEBodyElement();
    virtual ~CTIMEBodyElement();
    
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEBodyElement"); }
#endif

    // IElementBehavior methods.

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Detach)();

    // IPersistPropertyBag2 methods.

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)() { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)() { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IAnimationRoot methods.

    STDMETHOD(RegisterComposerSite) (IUnknown *piunkComposerSite);
    STDMETHOD(UnregisterComposerSite) (IUnknown *piunkComposerSite);

    // ITIMEInternalEventGenerator methods.

    STDMETHOD(AddInternalEventSink)(ITIMEInternalEventSink * pSink, double dblTime);
    STDMETHOD(RemoveInternalEventSink)(ITIMEInternalEventSink * pSink);
    
    // ITIMETransitionDependencyMgr methods.

    STDMETHOD(EvaluateTransitionTarget)(IUnknown *  punkTransitionTarget,
                                        void *      pvTransitionDependencyMgr);

    // Event Handlers

    virtual void OnLoad();
    virtual void OnUnload();
    virtual void UpdateAnimations();
    virtual void OnTick();

    // QI Map

    BEGIN_COM_MAP(CTIMEBodyElement)
        COM_INTERFACE_ENTRY(ITIMEBodyElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IAnimationRoot)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY(ITIMETransitionDependencyMgr)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink

    BEGIN_CONNECTION_POINT_MAP(CTIMEBodyElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEBodyElement* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);
    static HRESULT WINAPI
    BodyBaseInternalQueryInterface(CTIMEBodyElement* pThis,
                               void * pv,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    // Needed by CBvrBase

    void *          GetInstance() { return (ITIMEBodyElement *) this; }
    HRESULT         GetTypeInfo(ITypeInfo ** ppInfo) 
                    { 
                        return GetTI(GetUserDefaultLCID(), ppInfo); 
                    }

    // Misc. methods

    virtual HRESULT InitTimeline();
    MMPlayer &      GetPlayer() { return m_player; }
    virtual bool    IsGroup() const { return true; }
    virtual bool    IsBody() const;
    virtual bool    IsEmptyBody() const;
    float           GetDefaultSyncTolerance() 
                    { 
                        return DEFAULT_SYNC_TOLERANCE_S; 
                    }
    TOKEN           GetDefaultSyncBehavior() { return CANSLIP_TOKEN; }

    bool            IsDocumentStarted();
    bool            IsRootStarted() const { return m_fStartRoot; }
    void            ReadRegistryMediaSettings(bool & fPlayVideo, 
                                              bool & fShowImages, 
                                              bool & fPlayAudio, 
                                              bool & fPlayAnimations);

    void            RegisterElementForSync(CTIMEElementBase * pelem);
    void            UnRegisterElementForSync(CTIMEElementBase * pelem);
    void            UpdateSyncNotify();

    bool            IsPrintMedia();
    bool            IsBodyLoading() { return m_bIsLoading; };

    CTransitionDependencyManager * GetTransitionDependencyMgr();

protected:

    //+-------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //--------------------------------------------------------------------------

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    // Animation stuff
    //

    void DetachComposerSites(void);
    bool InsideSiteDetach(void) { return m_bInSiteDetach; }
    bool HaveAnimationsRegistered (void);

    //
    // Misc. methods
    //

    HRESULT Error();
    bool    QueryPlayOnStart (void);
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void StopRootTime(MMTimeline * tl);
    virtual bool NeedSyncCB() { return true; }

    //+-------------------------------------------------------------------------
    //
    // Protected Data
    //
    //--------------------------------------------------------------------------

    // Attributes

    // Internal variables
    MMPlayer                m_player;
    DWORD                   m_bodyPropertyAccesFlags;
    static DWORD            ms_dwNumBodyElems;
    ComposerSiteList        m_compsites;
    bool                    m_bInSiteDetach;
    UpdateSyncList          m_syncList;

private:

    //+-------------------------------------------------------------------------
    //
    // Private methods
    //
    //--------------------------------------------------------------------------
    void IsValueTrue(HKEY hKeyRoot, TCHAR * pchSubKey, bool & fTrue);

    //+-------------------------------------------------------------------------
    //
    // Private Data
    //
    //--------------------------------------------------------------------------

    bool                            m_fRegistryRead;
    bool                            m_fPlayVideo;
    bool                            m_fShowImages;
    bool                            m_fStartRoot;
    bool                            m_fPlayAudio;
    bool                            m_fPlayAnimations;
    bool                            m_bIsLoading;

    CTransitionDependencyManager    m_TransitionDependencyMgr;

    static TIME_PERSISTENCE_MAP     PersistenceMap[];

    std::list<CInternalEventNode*>  m_listInternalEvent;

}; 
// CTIMEBodyElement


//+-----------------------------------------------------------------------------
//  CTIMEBodyElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//------------------------------------------------------------------------------


inline 
HRESULT WINAPI
CTIMEBodyElement::InternalQueryInterface(CTIMEBodyElement* pThis,
                                         const _ATL_INTMAP_ENTRY* pEntries,
                                         REFIID iid,
                                         void** ppvObject)
{ 
    return BodyBaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); 
}



#endif /* _BODYELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\activeele.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: ActiveEle.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _ACTIVEELE_H
#define _ACTIVEELE_H

#include "timeelmbase.h"

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CActiveElementCollection :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CActiveElementCollection, &__uuidof(CActiveElementCollection)>,
    public ITIMEDispatchImpl<ITIMEActiveElementCollection, &IID_ITIMEActiveElementCollection>
{
    public:
        CActiveElementCollection(CTIMEElementBase & elm);
        virtual ~CActiveElementCollection();
        HRESULT ConstructArray();
        //ITimeActiveElementCollection methods
        
        STDMETHOD(get_length)(/*[out, retval]*/ long* len);
        STDMETHOD(get__newEnum)(/*[out, retval]*/ IUnknown** p);
        STDMETHOD(item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ VARIANT* pvarResult);

        STDMETHOD(addActiveElement)(IUnknown *pUnk);
        STDMETHOD(removeActiveElement)(IUnknown *pUnk);
        
        //IUnknown interface
        STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject)
        {   return _InternalQueryInterface(iid, ppvObject); };
        STDMETHOD_(ULONG, AddRef)()
        {   return InternalAddRef(); };
        STDMETHOD_(ULONG, Release)()
        { 
            ULONG l = InternalRelease();
            if (l == 0) delete this;
            return l;
        };


        // QI Map
        BEGIN_COM_MAP(CActiveElementCollection)
            COM_INTERFACE_ENTRY(ITIMEActiveElementCollection)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP();

    protected:
        CPtrAry<IUnknown *>      *m_rgItems;  //an array of IUnknown pointers
        CTIMEElementBase &        m_elm;

}; //lint !e1712


class CActiveElementEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
   public:
        CActiveElementEnum(CActiveElementCollection &EleCol);
        virtual ~CActiveElementEnum();

        // IEnumVARIANT methods
        STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
        STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
        STDMETHOD(Reset)();
        STDMETHOD(Skip)(unsigned long celt);
        void SetCurElement(unsigned long celt);
                        
        //IUnknown interface
        STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject)
        {   return _InternalQueryInterface(iid, ppvObject); };
        STDMETHOD_(ULONG, AddRef)()
        {   return InternalAddRef(); };
        STDMETHOD_(ULONG, Release)()
        { 
            ULONG l = InternalRelease();
            if (l == 0) delete this;
            return l;
        };

        // QI Map
        BEGIN_COM_MAP(CActiveElementEnum)
            COM_INTERFACE_ENTRY(IEnumVARIANT)
        END_COM_MAP();

    protected:
        long                        m_lCurElement;
        CActiveElementCollection  & m_EleCollection;
}; //lint !e1712



#endif /* _ACTIVEELE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\tags\tagsattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tagsattr.cpp
//
//  Contents: attributes for tags
//
//------------------------------------------------------------------------------------

#include "headers.h"
//#include "eventelm.h"
#include "bodyelm.h"
#include "tokens.h"
#include "attr.h"


//+-----------------------------------------------------------------------------------
//
// Time body Element Attributes
//
//------------------------------------------------------------------------------------

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TBE CTIMEBodyElement

                // Function Name    // Class // Attr Accessor      // COM put_ fn     // COM get_ fn   // IDL Arg type

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEBodyElement)
                           // Attr Name      // Function Name

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\activeele.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: ActiveEle.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "activeele.h"

//*******************************************************************************
// *  CActiveElementCollection
// *******************************************************************************
CActiveElementCollection::CActiveElementCollection(CTIMEElementBase & elm)
: m_rgItems(NULL),
  m_elm(elm)
{
    
}

///////////////////////////////////////////////////////////////
//  Name: ConstructArray
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT CActiveElementCollection::ConstructArray()
{
    HRESULT hr = S_OK;

    m_rgItems = NEW CPtrAry<IUnknown *>;
    if (m_rgItems == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CActiveElementCollection
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CActiveElementCollection::~CActiveElementCollection()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }

        // delete array
        delete m_rgItems;
        m_rgItems = NULL;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::get_length(long *len)
{
    HRESULT hr = S_OK;

    if (len == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    *len = m_rgItems->Size();

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::get__newEnum(IUnknown** p)
{
    HRESULT hr = S_OK;
    CActiveElementEnum *pNewEnum = NULL;
    
    if (p == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pNewEnum = NEW CActiveElementEnum(*this);
    if (pNewEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNewEnum->QueryInterface(IID_IUnknown, (void **)p));
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    if (FAILED(hr))
    {
        if (pNewEnum != NULL)
        {
            delete pNewEnum;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             pvarIndex must be a valid integer value.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::item(VARIANT varIndex, VARIANT* pvarResult)
{
    HRESULT hr = S_OK;
    VARIANT vIndex;
    IUnknown *pUnk = NULL;  //do not free this, it is not referenced.
    IDispatch *pDisp = NULL; //do not free this, it is passed as a return value.

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (pvarResult == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    VariantInit(&vIndex);

    hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4));
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (vIndex.lVal >= 0 && vIndex.lVal <= m_rgItems->Size() - 1)
    {
        pUnk = m_rgItems->Item(vIndex.lVal);
        
        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)&pDisp));
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
        VariantClear(pvarResult);
        pvarResult->vt = VT_DISPATCH;
        pvarResult->pdispVal = pDisp;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
    
  done:

    VariantClear(&vIndex);

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: addActiveElement
// 
//  Abstract:  Adds an element to the list by adding it's 
//             IUnknown pointer.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::addActiveElement(IUnknown *pUnk)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    long lIndex = 0;
    bool bInList = false;

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //check to see if the element is already in the list    
    lCount = m_rgItems->Size();
    lIndex = lCount - 1;
    while (lIndex >= 0 && bInList == false)
    {
        //compare to find the right object
        IUnknown *pItem = m_rgItems->Item(lIndex);
        if (pItem == pUnk)
        {
            bInList = true;
        }
        lIndex--;
    }
    //only add the element if it is not already in the list
    if (bInList == false)
    {
        pUnk->AddRef();
        m_rgItems->Append(pUnk);
        m_elm.NotifyPropertyChanged(DISPID_TIMEELEMENT_ACTIVEELEMENTS);
    }

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: removeActiveElement
// 
//  Abstract:  Removes an element to the list by searching for 
//             matching IUnknown pointers.  This is only valid
//             if the pointers remain IUnknown pointers because
//             an object must always return the same IUnknown
//             pointer, but that is not true for other interfaces.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::removeActiveElement(IUnknown *pUnk)
{
    HRESULT hr;
    long lCount = 0, lIndex = 0;

    if (m_rgItems == NULL)
    {
        hr = S_OK;
        goto done;
    }

    lCount = m_rgItems->Size();
    for (lIndex = lCount - 1; lIndex >= 0; lIndex--)
    {
        //compare to find the right object
        IUnknown *pItem = m_rgItems->Item(lIndex);
        if (pItem == pUnk)
        {
            m_rgItems->ReleaseAndDelete(lIndex);
            m_elm.NotifyPropertyChanged(DISPID_TIMEELEMENT_ACTIVEELEMENTS);
        }
    }
    
    hr = S_OK;

  done:
    RRETURN(hr);
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CActiveElementEnum::CActiveElementEnum(CActiveElementCollection & EleCol)
: m_EleCollection(EleCol),
  m_lCurElement(0)
{
    m_EleCollection.AddRef();
}



CActiveElementEnum::~CActiveElementEnum()
{
    m_EleCollection.Release();
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Clone(IEnumVARIANT **ppEnum)
{
    HRESULT hr = S_OK;
    CActiveElementEnum *pNewEnum = NULL;
    if (ppEnum == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pNewEnum = NEW CActiveElementEnum(m_EleCollection);
    if (pNewEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    pNewEnum->SetCurElement(m_lCurElement);
    hr = THR(pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum));
    if (FAILED(hr))
    {
        *ppEnum = NULL;
        goto done;
    }

  done:
    if (FAILED(hr))
    {
        if (pNewEnum != NULL)
        {
            delete pNewEnum;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long len = 0;
    long iCount = 0;

    if (rgVar == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        CComVariant vCount;
        VariantInit(&vCount);
     
        hr = THR(m_EleCollection.get_length(&len));
        if (FAILED(hr))
        {
            goto done;
        }
        if (m_lCurElement < len)
        {
            vCount.vt = VT_I4;
            vCount.lVal = m_lCurElement;
            hr = THR(m_EleCollection.item(vCount, &rgVar[i]));
            if (FAILED(hr))
            {
                goto done;
            }
            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

  done:

    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Skip(unsigned long celt)
{
    HRESULT hr = S_OK;
    long lLen = 0;

    m_lCurElement = m_lCurElement + (long)celt;
    hr = THR(m_EleCollection.get_length(&lLen));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
    }

  done:

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CActiveElementEnum::SetCurElement(unsigned long celt)
{
    HRESULT hr = S_OK;
    long lLen = 0;

    m_lCurElement = (long)celt;
    hr = THR(m_EleCollection.get_length(&lLen));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

  done:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\collect.cpp ===
//************************************************************
//
// Filename:    collect.cpp
//
// Created:     09/25/98
//
// Author:      twillie
//
//              Collection implementation.
//
//************************************************************

#include "headers.h"
#include "collect.h"

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

#define TYPELIB_VERSION_MAJOR 1
#define TYPELIB_VERSION_MINOR 0

#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

//
// local prototypes
//
static HRESULT PropertyStringToLong(const WCHAR   *nptr,
                                    WCHAR        **endptr,
                                    int            ibase,
                                    int            flags,
                                    unsigned long *plNumber);


DeclareTag(tagTimeCollection, "TIME: Behavior", "CTIMEElementCollection methods")
DeclareTag(tagCollectionCache, "TIME: Behavior", "CCollectionCache methods")


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    check to see if string is number
//************************************************************

static HRESULT
ttol_with_error(const WCHAR *pStr, long *plValue)
{
    // Always do base 10 regardless of contents of
    return PropertyStringToLong(pStr, NULL, 10, 0, (unsigned long *)plValue);
} // ttol_with_error

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    try to convert string to number
//************************************************************
static HRESULT
PropertyStringToLong(const WCHAR   *nptr,
                     WCHAR        **endptr,
                     int            ibase,
                     int            flags,
                     unsigned long *plNumber)
{
    const WCHAR *p;
    WCHAR c;
    unsigned long number;
    unsigned digval;
    unsigned long maxval;

    *plNumber = 0;                  /* on error result is 0 */

    p = nptr;                       /* p is our scanning pointer */
    number = 0;                     /* start with zero */

    c = *p++;                       /* read char */
    while (_istspace(c))
        c = *p++;                   /* skip whitespace */

    if (c == '-')
    {
        flags |= FL_NEG;        /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;               /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36)
    {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = (WCHAR *)nptr;
        return E_POINTER;              /* return 0 */
    }
    else if (ibase == 0)
    {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase = 10;
        else if (*p == L'x' || *p == L'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16)
    {
        /* we might have 0x in front of number; remove if there */
        if (c == L'0' && (*p == L'x' || *p == L'X'))
        {
            ++p;
            c = *p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = ULONG_MAX / ibase; //lint !e573


    for (;;)
    {      /* exit in middle of loop */
        /* convert c to value */
        if (IsCharAlphaNumeric(c))
            digval = c - L'0';
        else if (IsCharAlpha(c))
        {
            if (ibase > 10)
            {
                digval = (unsigned) PtrToUlong(CharUpper((LPTSTR)(LONG_PTR)c)) - L'A' + 10;
            }
            else
            {
                return E_INVALIDARG;              /* return 0 */
            }
        }
        else
            break;

        if (digval >= (unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) //lint !e573
        {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else
        {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT))
    {
        number = 0L;                        /* return 0 */

        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;

        return E_INVALIDARG;            // Return error not a number
    }
    else if ((flags & FL_OVERFLOW) ||
              (!(flags & FL_UNSIGNED) &&
                (((flags & FL_NEG) && (number > -LONG_MIN)) || //lint !e648 !e574
                  (!(flags & FL_NEG) && (number > LONG_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno = ERANGE;
        if (flags & FL_UNSIGNED)
            number = ULONG_MAX;
        else if (flags & FL_NEG)
            number = (unsigned long)(-LONG_MIN); //lint !e648
        else
            number = LONG_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = (WCHAR *)p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned long)(-(long)number);

    *plNumber = number;
    return S_OK;                  /* done. */
} // PropertyStringToLong

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    constructor
//************************************************************

CTIMEElementCollection::CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex) :
    m_pCollectionCache(pCollectionCache),
    m_lCollectionIndex(lIndex),
    m_pInfo(NULL),
    m_cRef(0)
{
} // CTIMEElementCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    destructor
//************************************************************

CTIMEElementCollection::~CTIMEElementCollection()
{
    ReleaseInterface(m_pInfo);
    m_pCollectionCache = NULL;
} // ~CTIMEElementCollection

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::AddRef(void)
{
    return m_cRef++;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CTIMEElementCollection::Release - YIKES! Trying to decrement when Ref count is zero"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CTIMEElementCollection::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST((ITIMEElementCollection*)this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST(this, IDispatchEx*);
    }
    else if (IsEqualIID(riid, IID_ITIMEElementCollection))
    {
        *ppv = SAFECAST(this, ITIMEElementCollection*);
    }

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetTypeInfoCount
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetTypeInfoCount(UINT FAR *pctinfo)
{
    if (pctinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfoCount - Invalid param (UINT FAR *)"));
        return TIMESetLastError(E_POINTER);
    }

    *pctinfo = 1;
    return S_OK;
} // GetTypeInfoCount

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetTypeInfo
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (pptinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfo - Invalid param (ITypeInfo**)"));
        return TIMESetLastError(E_POINTER);
    }

    return GetTI(pptinfo);
} // GetTypeInfo

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetIDsOfNames
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                                  UINT cNames, LCID lcid, DISPID FAR *rgdispid)
{
    // punt to IDispatchEx impl.
    return GetDispID(rgszNames[0], cNames, rgdispid);
} // GetIDsOfNames

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - Invoke
//************************************************************

STDMETHODIMP
CTIMEElementCollection::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags,
                           DISPPARAMS *pdispparams, VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo, UINT *pArg)
{
    // punt to IDispatchEx impl.
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
} // Invoke

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - InvokeEx
//************************************************************

STDMETHODIMP
CTIMEElementCollection::InvokeEx(DISPID            dispidMember,
                             LCID              lcid,
                             WORD              wFlags,
                             DISPPARAMS       *pdispparams,
                             VARIANT          *pvarResult,
                             EXCEPINFO        *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    hr = m_pCollectionCache->InvokeEx(m_lCollectionIndex, dispidMember, lcid, wFlags,
                                      pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    // if that failed, try typelib
    if (FAILED(hr))
    {
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        UINT* puArgErr = NULL;

        IDispatch *pDisp = NULL;
        hr = QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
            return TIMESetLastError(hr);

        Assert(pInfo != NULL);

        hr = pInfo->Invoke(pDisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        ReleaseInterface(pInfo);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - Invoke failed on Typelib"));
            return TIMESetLastError(hr);
        }
    }

    return hr;
} // InvokeEx

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = m_pCollectionCache->GetDispID(m_lCollectionIndex, bstrName, grfdex, pid);

    // if we failed or found nothing, try typelib
    if ((FAILED(hr)) || (*pid == DISPID_UNKNOWN))
    {
        // have string, see if it's a member function/property in typelib
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::GetDispID - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        Assert(pInfo != NULL);

        LPOLESTR rgszNames[1];
        rgszNames[0] = bstrName;

        hr = pInfo->GetIDsOfNames(rgszNames, 1, pid);
        ReleaseInterface(pInfo);
    }

    return hr;
} // GetDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - deleteMemberByName
//************************************************************

STDMETHODIMP
CTIMEElementCollection::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByName(m_lCollectionIndex, bstrName, grfdex));
} // deleteMemberByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - deleteMemberByDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::DeleteMemberByDispID(DISPID id)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByDispID(m_lCollectionIndex, id));
} // deleteMemberByDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetMemberProperties
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberProperties(m_lCollectionIndex, id, grfdexFetch, pgrfdex));
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetMemberName
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberName(m_lCollectionIndex, id, pbstrName));
} // GetMemberName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetNextDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    return TIMESetLastError(m_pCollectionCache->GetNextDispID(m_lCollectionIndex, grfdex, id, prgid));
} // GetNextDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetNameSpaceParent
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNameSpaceParent(IUnknown **ppUnk)
{
    HRESULT hr = m_pCollectionCache->GetNameSpaceParent(m_lCollectionIndex, ppUnk);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // GetNameSpaceParent

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - get_length
//************************************************************

STDMETHODIMP
CTIMEElementCollection::get_length(long *plSize)
{
    HRESULT hr = m_pCollectionCache->get_length(m_lCollectionIndex, plSize);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // get_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - put_length
//************************************************************

STDMETHODIMP
CTIMEElementCollection::put_length(long lSize)
{
    return TIMESetLastError(m_pCollectionCache->put_length(m_lCollectionIndex, lSize));
} // put_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - item
//************************************************************

STDMETHODIMP
CTIMEElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT hr = m_pCollectionCache->item(m_lCollectionIndex, var1, var2, ppDisp);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // item

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - tags
//************************************************************

STDMETHODIMP
CTIMEElementCollection::tags(VARIANT var1, IDispatch **ppDisp)
{
    
    HRESULT hr = m_pCollectionCache->tags(m_lCollectionIndex, var1, ppDisp);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // tags

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - get__newEnum
//************************************************************

STDMETHODIMP
CTIMEElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    
    HRESULT hr = m_pCollectionCache->get__newEnum(m_lCollectionIndex, ppEnum);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // get__newEnum

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    helper function for typeinfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTI(ITypeInfo **pptinfo)
{
    HRESULT hr = E_FAIL;

    Assert(pptinfo != NULL);  //GetTI is an private internal function.  pptinfo should always be valid

    *pptinfo = NULL;

    if (m_pInfo == NULL)
    {
        ITypeLib* pTypeLib = NULL;

        hr = LoadRegTypeLib(LIBID_MSTIME, TYPELIB_VERSION_MAJOR, TYPELIB_VERSION_MINOR, LCID_SCRIPTING, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            ITypeInfo* pTypeInfo = NULL;

            hr = pTypeLib->GetTypeInfoOfGuid(IID_ITIMEElementCollection, &pTypeInfo);
            if (SUCCEEDED(hr))
            {
                m_pInfo = pTypeInfo;
            }

            ReleaseInterface(pTypeLib);
        }
    }

    *pptinfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hr = S_OK;
    }

    return hr;
} // GetTI

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Constructor
//************************************************************

CCollectionCache::CCollectionCache(CTIMEElementBase *pBase,
                                   CAtomTable *pAtomTable /* = NULL */,
                                   PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
                                   PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
                                   PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,
                                   PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */) :
    m_pBase(pBase),
    m_pAtomTable(pAtomTable),
    m_pfnEnsure(pfnEnsure),
    m_pfnCreateCollection(pfnCreation),
    m_pfnRemoveObject(pfnRemove),
    m_pfnAddNewObject(pfnAddNewObject),
    m_lReservedSize(0),
    m_lCollectionVersion(0),
    m_lDynamicCollectionVersion(0),
    m_rgItems(NULL),
    m_pElemEnum(NULL),
    m_lEnumItem(0)
{
    Assert(m_pBase != NULL);
} // CCollectionCache

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Destructor
//************************************************************

CCollectionCache::~CCollectionCache()
{
    if (m_rgItems)
    {
        long lSize = m_rgItems->Size();

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            CCacheItem *pce = (*m_rgItems)[lIndex];
            if (pce->m_fOKToDelete)
            {
                // delete CCacheItem
                delete pce;
                pce = NULL;
            }
        }

        // delete array of CCacheItems
        delete m_rgItems;
        m_rgItems = NULL;
    }
    m_pElemEnum = NULL;
    m_pBase = NULL;
    m_pAtomTable = NULL;
    m_pfnEnsure = NULL;
    m_pfnRemoveObject = NULL;
    m_pfnCreateCollection = NULL;
    m_pfnAddNewObject = NULL;
} // ~CCollectionCache

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Initialize class
//************************************************************

HRESULT
CCollectionCache::Init(long lReservedSize, long lIdentityIndex /* = -1 */)
{
    HRESULT hr = E_INVALIDARG;

    m_lReservedSize = lReservedSize;

    // Clear the reserved part of the cache.
    if (m_lReservedSize >= 0)
    {
        m_rgItems = NEW CPtrAry<CCacheItem *>;
        if (m_rgItems == NULL)
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }

        // this is a speed thing.  Since we know we need a certain size,
        // make it so.
        hr = m_rgItems->EnsureSize(m_lReservedSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to init array to reserved size"));
            return hr;
        }

        // loop through initializing each reserved array
        for (long lIndex = 0; lIndex < lReservedSize; lIndex++)
        {
            // create new cache item
            CCacheItem *pce = NEW CCacheItem();
            if (pce == NULL)
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array (CCacheItem)"));
                return E_OUTOFMEMORY;
            }

            // add item to array
            hr = m_rgItems->Append(pce);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to add cache item"));
                delete pce;
                return hr;
            }

            // attach CTIMEElementCollection to item
            hr = CreateCollectionHelper(&pce->m_pDisp, lIndex);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - CreateCollectionHelper() failed"));
                return hr; //lint !e429
            }
        } //lint !e429

        // handle identity flag
        if ((lIdentityIndex >= 0) && (lIdentityIndex < m_lReservedSize))
        {
            (*m_rgItems)[lIdentityIndex]->m_fIdentity = true;
        }
    }

    return S_OK;
} // Init

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch for collection index
//************************************************************

HRESULT
CCollectionCache::GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    // fetch particular Collection
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];

    // if identity, QI for IDispatch and return
    if (pce->m_fIdentity)
    {
        return GetOuterDisp(lCollectionIndex, m_pBase, ppDisp);
    }

    // if not identity and there is a collection, addref and return it
    Assert(pce->m_pDisp != NULL);

    pce->m_pDisp->AddRef();
    *ppDisp = pce->m_pDisp;

    return S_OK;
} // GetCollectionDisp

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Set collection cache type
//************************************************************

HRESULT
CCollectionCache::SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::SetCollectionType - Invalid index"));
        return E_INVALIDARG;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    pce->m_cctype = cctype;
    return S_OK;
} // SetCollectionType

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    given an index, see if it's a child collection
//************************************************************

bool
CCollectionCache::IsChildrenCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctChildren)
            return true;
    }
    return false;
} // IsChildrenCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    given an index, see if it's an all collection
//************************************************************

bool
CCollectionCache::IsAllCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctAll)
            return true;
    }
    return false;
} // IsAllCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetDispID
//************************************************************

HRESULT
CCollectionCache::GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    long    lItemIndex = 0;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *pid = 0;

    // make sure array is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - EnsureArray() failed"));
        return hr;
    }

    // check for index (number) - which equates to an ordinal
    hr = ttol_with_error(bstrName, &lItemIndex);
    if (hr == S_OK)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteOrdinals)
        {
            return DISP_E_UNKNOWNNAME;
        }

        if (m_pfnAddNewObject)
        {
            // The presence of m_pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex))
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        // Without a m_pfnAddNewObject, the collection only supports
        // access to ordinals in the current range. Other accesses
        // become expando.
        if ((lItemIndex >= 0) &&
            (lItemIndex < Size(lCollectionIndex)))
        {
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex) )
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        return DISP_E_UNKNOWNNAME;
    }

    // see if it's an expando

    // If we don't promote named items - nothing more to do
    if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteNames)
        return DISP_E_UNKNOWNNAME;

    CTIMEElementBase *pElem = NULL;
    long lIndex = 0;
    bool fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;

    // check to make sure min/max are not wacky
    Assert((*m_rgItems)[lCollectionIndex]->m_dispidMin != 0);
    Assert(((*m_rgItems)[lCollectionIndex]->m_dispidMax != 0) &&
            ((*m_rgItems)[lCollectionIndex]->m_dispidMax > (*m_rgItems)[lCollectionIndex]->m_dispidMin));

    hr = GetItemByName(lCollectionIndex, bstrName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);  // double check to make sure we found something

    // add name to table
    long lOffset = 0;
    hr =  m_pAtomTable->AddNameToAtomTable(bstrName, &lOffset);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - AddNameToAtomTable() failed"));
        return hr;
    }

    // cook up an ID based on offset plus case sensitivity
    long lMax;
    if (fCaseSensitive)
    {
        lOffset += GetSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetSensitiveNamedMemberMax(lCollectionIndex);
    }
    else
    {
        lOffset += GetNotSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetNotSensitiveNamedMemberMax(lCollectionIndex);
    }

    *pid = lOffset;

    // if id greater than the max, punt
    if (*pid > lMax)
    {
        hr = DISP_E_UNKNOWNNAME;
    }
    return hr;
} // GetDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - InvokeEx
//************************************************************

HRESULT
CCollectionCache::InvokeEx(long lCollectionIndex, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    // validate params
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pdispparams == NULL)
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (DISPPARAMS*)"));
        return E_POINTER;
    }

    // make sure array is up-to-date
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - unable to ensure array index"));
        return hr;
    }

    // make sure ID is in collection range
    // Note: this stop's requests for length which is handled
    //       in CTIMEElementCollection
    if ((id < (*m_rgItems)[lCollectionIndex]->m_dispidMin) ||
        (id > (*m_rgItems)[lCollectionIndex]->m_dispidMax))
        return DISP_E_MEMBERNOTFOUND;

    //
    // check for ordinal
    //
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        if (wFlags & DISPATCH_PROPERTYPUT )
        {
            if (!m_pfnAddNewObject)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid arg passed to invoke"));
                return E_INVALIDARG;
            }

            if (!(pdispparams && pdispparams->cArgs == 1)) //lint !e774
                // No result type we need one for the get to return.
                return DISP_E_MEMBERNOTFOUND;

            // Only allow VARIANT of type IDispatch to be put
            if (pdispparams->rgvarg[0].vt == VT_NULL)
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if ((*m_rgItems)[lCollectionIndex]->m_fSettableNULL)
                {
                    hr = Remove(lCollectionIndex, id - GetOrdinalMemberMin(lCollectionIndex));

                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        return S_OK;
                    return hr;
                }
                return E_INVALIDARG;
            }
            else if (pdispparams->rgvarg[0].vt != VT_DISPATCH)
            {
                return E_INVALIDARG;
            }

            // All OK, let the collection cache validate the Put
            return ((CVoid *)((void *)m_pBase)->*m_pfnAddNewObject)(lCollectionIndex, //lint !e10
                                                                    V_DISPATCH(pdispparams->rgvarg),
                                                                    id - GetOrdinalMemberMin(lCollectionIndex));
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            VARIANTARG      v1;
            VARIANTARG      v2;
            long            lIndex = id - GetOrdinalMemberMin(lCollectionIndex);

            if (!((lIndex >= 0) && (lIndex < Size(lCollectionIndex))))
            {
                hr = S_OK;
                if (pvarResult)
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    return S_OK;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIndex;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (SUCCEEDED(hr))
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
            return hr;
        }

        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of ordinal ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    //
    // check for expando
    //
    if (IsNamedCollectionMember(lCollectionIndex, id))
    {
        bool  fCaseSensitive;
        long  lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, id, &fCaseSensitive);

        const WCHAR  *pwszName;
        hr = m_pAtomTable->GetNameFromAtom(id - lOffset, &pwszName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - GetNameFromAtom() failed"));
            return hr;
        }

        // find name
        IDispatch *pDisp = NULL;
        hr = GetDisp(lCollectionIndex,
                     pwszName,
                     false,
                     &pDisp,
                     fCaseSensitive);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - unable to GetDisp for expando"));
            return hr;
        }

        Assert(pDisp != NULL);
        UINT* puArgErr = NULL;

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (pvarResult == NULL)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid param (VARIANT*)"));
                return E_POINTER;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on get_/method call"));
                return DISP_E_BADPARAMCOUNT;
            }
            else if (pdispparams->cArgs == 1)
            {
                return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                return S_OK;
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
                 wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on put_ call"));
                return DISP_E_BADPARAMCOUNT;
            }

            return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        }

        // Any other kind of invocation is not valid.
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of Named ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // punt back to outer Invoke...
    return DISP_E_MEMBERNOTFOUND;
} // InvokeEx

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByName
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByName(long lCollectionIndex, BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
} // deleteMemberByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByDispID
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByDispID(long lCollectionIndex, DISPID id)
{
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberProperties
//              Not needed
//************************************************************

HRESULT
CCollectionCache::GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD* pgrfdex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pgrfdex == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (DWORD*)"));
        return E_POINTER;
    }

    *pgrfdex = 0;
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberName
//************************************************************

HRESULT
CCollectionCache::GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pbstrName == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (BSTR*)"));
        return E_POINTER;
    }

    *pbstrName = NULL;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if DISPID is an ordinal
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        long lOffset = id - GetOrdinalMemberMin(lCollectionIndex);
        CTIMEElementBase *pElem = NULL;

        // element
        hr = GetItemByIndex(lCollectionIndex, lOffset, &pElem);
        if (FAILED(hr) || (pElem == NULL))
        {
            TraceTag((tagError, "CCollectionCache::GetMemberName - GetItemByIndex() failed"));
            return DISP_E_MEMBERNOTFOUND;
        }

        Assert(pElem != NULL);

        if ((*m_rgItems[lCollectionIndex])->m_fPromoteNames)
        {
            // get ID string
            hr = pElem->getIDString(pbstrName);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - unable to find ID for element"));
                return DISP_E_MEMBERNOTFOUND;
            }
        }

        // check to see that it's either NULL or ""
        // if so, stick offset in string
        if ((*pbstrName == NULL) || (lstrlenW(*pbstrName) == 0))
        {
            // set offset as text
            VARIANT varData;
            VariantInit(&varData);

            V_VT(&varData) = VT_I4;
            V_I4(&varData) = lOffset;

            VARIANT varNew;
            VariantInit(&varNew);
            hr = VariantChangeTypeEx(&varNew, &varData, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - Unable to coerce long to BSTR"));
                // NOTE: we return DISP_E_MEMBERNOTFOUND instead of hr
                //       due to predefined method constraints
                return DISP_E_MEMBERNOTFOUND;
            }

            // Since we are going to return the BSTR, no need calling ClearVariant(&varNew).
            VariantClear(&varData);
            *pbstrName = V_BSTR(&varNew);
            return S_OK;
        }

        return S_OK;
    }

    // unable to find DISPID
    return DISP_E_MEMBERNOTFOUND;
} // GetMemberName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetNextDispID
//************************************************************

HRESULT
CCollectionCache::GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (prgid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *prgid = 0;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if we are have been sent the enumerator index. (FFFFFFFF)
    if (id == DISPID_STARTENUM)
    {
         // move to the beginning of the array (0)
         *prgid = GetOrdinalMemberMin(lCollectionIndex);
         return S_OK;
    }

    // validate that we are working with ordinals
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        // calc new offset
        long lItemIndex = id - GetOrdinalMemberMin(lCollectionIndex) + 1;

        // Is the number within range for an item in the collection?
        // We *must* call GetItemCount to be exact.
        long lSize = 0;
        hr = GetItemCount(lCollectionIndex, &lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::GetNextDispID - GetItemCount() failed"));
            return S_FALSE;
        }

        // this is usually were we stop
        if ((lItemIndex < 0) || (lItemIndex >= lSize))
        {
            return S_FALSE;
        }

        // calc new DISPID
        *prgid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;

        // check to see if calc DISPID is out of range
        if (*prgid > GetOrdinalMemberMax(lCollectionIndex))
        {
            // this signal's that we are done.
            *prgid = DISPID_UNKNOWN;
        }
        return S_OK;
    }

    // not found
    return S_FALSE;
} // GetNextDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CCollectionCache::GetNameSpaceParent(long lCollectionIndex, IUnknown **ppUnk)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;
    return S_OK;
} // GetNameSpaceParent

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of standard Collection - get_length
//************************************************************

HRESULT
CCollectionCache::get_length(long lCollectionIndex, long *pretval)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pretval == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (long*)"));
        return E_POINTER;
    }

    *pretval = 0;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get_length - unable to ensure array"));
        return hr;
    }

    return GetItemCount(lCollectionIndex, pretval);
} // get_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of standard Collection - put_length
//              not needed.
//************************************************************

HRESULT
CCollectionCache::put_length(long lCollectionIndex, long retval)
{
    return E_NOTIMPL;
} // put_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    item is a standard method for collections
//              which looks up an item in a collection using
//              either a name or a numeric index.
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//************************************************************

HRESULT
CCollectionCache::item(long lCollectionIndex, VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT   hr;
    VARIANT  *pvarName = NULL;
    VARIANT  *pvarIndex = NULL;
    VARIANT  *pvar = NULL;
    long     lItemIndex = 0;

    // validate out param
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    // initialize out param
    *ppDisp = NULL;

    pvar = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1; //lint !e655

    // check to see if first param is a string
    if ((V_VT(pvar) == VT_BSTR) || V_VT(pvar) == (VT_BYREF|VT_BSTR)) //lint !e655
    {
        pvarName = (V_VT(pvar) & VT_BYREF) ? V_VARIANTREF(pvar) : pvar; //lint !e655

        // check second param.  If valid, it must be a secondary index (numeric)
        if ((V_VT(&var2) != VT_ERROR) && (V_VT(&var2) != VT_EMPTY))
        {
            pvarIndex = &var2;
        }
    }
    // first param is an index.
    // NOTE: we blow off the second param
    else if ((V_VT(&var1) != VT_ERROR) && (V_VT(&var1) != VT_EMPTY))
    {
        pvarIndex = &var1;
    }

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // if we have a pvarIndex, get it
    if (pvarIndex)
    {
        VARIANT varNum;

        VariantInit(&varNum);

        hr = VariantChangeTypeEx(&varNum, pvarIndex, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::item - unable to convert variant to index"));
            return hr;
        }

        lItemIndex = V_I4(&varNum);

        VariantClear(&varNum);
    }

    // First, see if we have a string as first param
    if (pvarName)
    {
        BSTR bstrName = V_BSTR(pvarName);

        // NOTE: lItemIndex is always passed in.  In the case
        // were we have no secondary index specifed, it will
        // always be zero.
        if (pvarIndex)
        {
            // this ALWAYS returns a single CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, lItemIndex, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
        else
        {
            // this could return either a collection or an CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, false, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
    }
    else if (pvarIndex)
    {
        // this ALWAYS returns a single CTIMEElementBase
        hr = GetDisp(lCollectionIndex, lItemIndex, ppDisp);
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
        return hr;
    }

    TraceTag((tagError, "CCollectionCache::item - Invalid args passed in to ::item"));
    return E_INVALIDARG;
} //item

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    get__NewEnum is a standard method for collections
//              returns an enumeration of all the items in a
//              collection.
//************************************************************

HRESULT
CCollectionCache::get__newEnum(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
        return hr;
    }

    // Create new array
    CPtrAry<IUnknown *> *prgElem = NEW CPtrAry<IUnknown *>;
    if (prgElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to alloc mem for ptr array"));
        return E_OUTOFMEMORY;
    }

    // child collection
    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        // loop through, adding children
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);
            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElemChild, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    }
    else if (IsAllCollection(lCollectionIndex)) // is it all collection?
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - EnumNextElement() failed"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElem, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

        }
    }
    else // must be an array impl
    {
        long lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();

        // This is a speed thing.  Since we know the size, alloc now for
        // array.
        hr = prgElem->EnsureSize(lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
            prgElem->ReleaseAll();
            delete prgElem;
            return hr;
        }

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            IDispatch * pdisp;

            hr = GetDisp(lCollectionIndex, lIndex, &pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - GetDisp() failed for index"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            hr = prgElem->Append(pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append item"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    } // end of "else everything"

    // Turn the snapshot into an enumerator.
    hr = prgElem->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **)ppUnk, FALSE, TRUE);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - EnumVARIANT() failed"));
        prgElem->ReleaseAll();
        delete prgElem;
    }

    return hr;
} // get__newEnum

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Return a subcollection containing only the
//              elements of this collection that have the
//              specified tag name.
//************************************************************

HRESULT
CCollectionCache::tags(long lCollectionIndex, VARIANT var1, IDispatch** ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (Collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    VARIANT *pvarName = NULL;
    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1; //lint !e655

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR)) //lint !e655
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ? V_VARIANTREF(pvarName) : pvarName; //lint !e655
    }
    else
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // Get a collection of the specified tags.
    // NOTE: ALWAYS returns a collection
    return GetDisp(lCollectionIndex, V_BSTR(pvarName), true, ppDisp);
} //get_tags

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    returns Size of a collection
//************************************************************

long
CCollectionCache::Size(long lCollectionIndex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::Size - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Size - unable to ensure array"));
        return hr;
    }

    // if all or children collection, use GetItemCount
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        long    cElem = 0;
        hr = GetItemCount(lCollectionIndex, &cElem);
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::Size - GetItemCount() failed"));
        }

        return cElem;
    }
    else
    {
        // must be an array. return size.
        return (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
    }
}

HRESULT
CCollectionCache::GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (CTIMEElementBase**)"));
        return E_POINTER;
    }

    // if all or children collection, use GetItemByIndex
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        HRESULT hr = GetItemByIndex(lCollectionIndex, i, ppElem);
        if (FAILED(hr))
        {
            if (hr == DISP_E_MEMBERNOTFOUND)
                TraceTag((tagCollectionCache, "CCollectionCache::GetItem - GetItemByIndex didn't find anything!"));
            else
                TraceTag((tagError, "CCollectionCache::GetItem - GetItemByIndex() failed"));
        }
        return hr;
    }
    else
    {
        // must be array.  access index.
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        Assert(pce != NULL);
        *ppElem = (*pce->m_rgElem)[i];
        return S_OK;
    }
} // GetItem

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Validate the given collection Index
//************************************************************

HRESULT
CCollectionCache::EnsureArray(long lCollectionIndex)
{
    HRESULT hr = S_OK;

    if (m_pfnEnsure)
    {
        hr = (((CVoid *)(void *)m_pBase)->*m_pfnEnsure)(&m_lCollectionVersion);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::EnsureArray - outer Ensure function failed"));
            return hr;
        }
    }

    // used for customized collections
    //
    // if versions don't match invalidate everything
    if (m_lCollectionVersion != m_lDynamicCollectionVersion)
    {
        long lSize = m_rgItems->Size();
        for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
            (*m_rgItems)[lIndex]->m_fInvalid = true;

        // reset version number
        m_lDynamicCollectionVersion = m_lCollectionVersion;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lCollectionIndex >= m_lReservedSize) && pce->m_fInvalid)
    {
        // Ensure the collection we're based upon
        // note that this is a recursive call
        hr = EnsureArray(pce->m_lDependentIndex);
        if (FAILED(hr))
            return hr;

        switch (pce->m_cctype)
        {
        case ctTag:
            // Rebuild based on name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 true,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;

        case ctNamed:
            // Rebuild based on tag name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 false,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;


            // all && children collection is dynamic, no need to rebuild
        case ctChildren:
        case ctAll:
            TraceTag((tagError, "CCollectionCache::EnsureArray - This is odd.  Why are we doing this?"));
            Assert(false);
            break;

        case ctFreeEntry:
            // Free collection waiting to be reused
            break;

        default:
            TraceTag((tagError, "CCollectionCache::EnsureArray - invalid cache type"));
            Assert(false);
            break;
        }
    }

    return hr;
} // EnsureArray

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This gets the out IDispatch for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp)
{
    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    IHTMLElement *pHTMLElem = pElem->GetElement();
    Assert(NULL != pHTMLElem);
    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp)));

    return hr;
} //lint !e529

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Creates a new collection
//************************************************************

HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch **ppDisp, long lCollectionIndex)
{
    HRESULT hr;

    *ppDisp = NULL;

    if (m_pfnCreateCollection)
    {
        return (((CVoid *)(void *)m_pBase)->*m_pfnCreateCollection)(ppDisp, lCollectionIndex);
    }

    CTIMEElementCollection *pobj = NEW CTIMEElementCollection(this, lCollectionIndex);
    if (pobj == NULL)
    {
        TraceTag((tagError, "CCollectionCache::CreateCollectionHelper - unable to alloc mem for collection"));
        return E_OUTOFMEMORY;
    }

    hr = pobj->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    return hr; //lint !e429
} // CreateCollectionHelper

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    retrieved offset of Named Member, given a DISPID
//************************************************************

long
CCollectionCache::GetNamedMemberOffset(long    lCollectionIndex,
                                       DISPID  id,
                                       bool   *pfCaseSensitive /* = NULL */)
{
    long lOffset;
    bool fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, id));

    // Check to see wich half of the dispid space the value goes
    if (IsSensitiveNamedCollectionMember(lCollectionIndex, id))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = true;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = false;
    }

    // return the sensitivity flag if required
    if (pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
} // GetNamedMemberOffset

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Compares names
//************************************************************

bool
CCollectionCache::CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive /* = false */)
{
    if (pwszName == NULL)
        return false;

    BSTR bstrSrcName = NULL;
    HRESULT hr;
    if (fTagName)
        hr = pElem->getTagString(&bstrSrcName);
    else
        hr = pElem->getIDString(&bstrSrcName);

    if (FAILED(hr))
    {
        TraceTag((tagError, "Unable to retrieve src name from element"));
        return false;
    }

    if (bstrSrcName == NULL)
        return false;

    long lCompare;
    if (fCaseSensitive)
        lCompare = StrCmpW(bstrSrcName, pwszName);
    else
        lCompare = StrCmpIW(bstrSrcName, pwszName);

    // free bstr
    SysFreeString(bstrSrcName);

    return (lCompare == 0);
} // CompareName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    removes an item from collection.
//              NOTE: that in order to do this, caller (owner
//              of the cache) need to provide Remove function.
//************************************************************

HRESULT
CCollectionCache::Remove(long lCollectionIndex, long lItemIndex)
{
    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Remove - unable to ensure array"));
        return hr;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lItemIndex < 0) || (lItemIndex >= pce->m_rgElem->Size()))
    {
        TraceTag((tagError, "CCollectionCache::Remove - invalid index"));
        return E_INVALIDARG;
    }

    if (!m_pfnRemoveObject)
    {
        TraceTag((tagError, "CCollectionCache::Remove - outer function not defined"));
        return CTL_E_METHODNOTAPPLICABLE;
    }

    return ((CVoid *)((void *)m_pBase)->*m_pfnRemoveObject)(lCollectionIndex, lItemIndex); //lint !e10
} // Remove

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Builds a Named array from a given collection
//************************************************************

HRESULT
CCollectionCache::BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgTemp = *prgNamed;
    HRESULT                      hr = S_OK;

    // if this array already exists, clear it.
    // Otherwise create a new array.
    if (rgTemp)
    {
        rgTemp->SetSize(0);
    }
    else
    {
        rgTemp = NEW CPtrAry<CTIMEElementBase *>;
        if (rgTemp == NULL)
        {
            TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    // figure out which collection we are looking at,
    // look for matches, and build array

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);

            if (CompareName(pElemChild, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElemChild);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::BuildNamedArray - EnumNextElement() failed"));
                delete rgTemp;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // compare name
            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else
    {
        // Must be a named array
        // Build a list of named elements.
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];
            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }

        *prgNamed = rgTemp;
        return hr;
    }
} //lint !e429

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    return IUnknown Interface for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk)
{
    Assert(ppUnk != NULL);
    *ppUnk = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    IHTMLElement *pHTMLElem = pElem->GetElement();
    Assert(NULL != pHTMLElem);
    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk)));

    return hr;
} //lint !e529

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given an Index into a collection
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByIndex(lCollectionIndex, lItemIndex, &pElem);
    if (FAILED(hr) ||
        pElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByIndex() failed"));
        return (pElem==NULL)?E_FAIL:hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, long, IDispatch **)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given a name and index
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lIndex, IDispatch **ppDisp, bool fCaseSensitive /*= false */)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByName(lCollectionIndex, pwszName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr) ||
        pElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByName() failed"));
        return (pElem==NULL)?E_FAIL:hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, const WCHAR *, long, IDispatch **, bool)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given a name.  Could return
//              either a CTIMEElementBase or sub collection depending
//              on results.
//************************************************************

HRESULT
CCollectionCache::GetDisp(long         lCollectionIndex,
                          const WCHAR *pwszName,
                          bool         fTagName,
                          IDispatch  **ppDisp,
                          bool         fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgNamed = NULL;
    HRESULT                      hr = S_OK;

    // figure out if we have this collection already built
    // return this named collection if it already exists.
    CCacheItem *pce = NULL;

    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    long lSize = m_rgItems->Size();
    for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
    {
        pce = (*m_rgItems)[lIndex];

        // if CaseSensitivites match and
        //    Index matches DependentIndex
        //    either a tag or named collection
        bool fIsCaseSensitive = pce->m_fIsCaseSensitive ? true : false;

        if ((fIsCaseSensitive == fCaseSensitive) && //lint !e731
            (lCollectionIndex == pce->m_lDependentIndex) &&
            ((fTagName && pce->m_cctype == ctTag) ||
             (!fTagName && pce->m_cctype == ctNamed)))
        {
            // compare names
            long lCompare;
            if (fCaseSensitive)
                lCompare = StrCmpW(pwszName, pce->m_bstrName);
            else
                lCompare = StrCmpIW(pwszName, pce->m_bstrName);

            // if we found a match, we are done
            if (lCompare == 0)
            {
                // addref IDispatch since we returning it
                pce->m_pDisp->AddRef();
                *ppDisp = pce->m_pDisp;
                return S_OK;
            }
        }
    }

    // Build a list of named elements.
    hr = BuildNamedArray(lCollectionIndex, pwszName, fTagName, &rgNamed, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - BuildNamedArray() failed"));
        return hr;
    }

    // if we found nothing and are NOT enumerating tags, return
    // not a failure case
    if ((rgNamed->Size() == 0) && !fTagName)
    {
        delete rgNamed;
        return DISP_E_MEMBERNOTFOUND;
    }

    // if only one element was found and we are NOT
    // enumerating tags, then QI for IDispatch for that
    // element and return it.  This only happens in ::item.
    if ((rgNamed->Size() == 1) && !fTagName)
    {
        hr = GetOuterDisp(lCollectionIndex, (*rgNamed)[0], ppDisp);
        Assert(ppDisp != NULL);

        // return ppDisp and release the array.
        delete rgNamed;
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetDisp - GetOuterDisp() failed"));
        }
        return hr;
    }

    // We found more than one item.  Initialize global list
    // and return IDispatch of collection.
    long lNewIndex = m_rgItems->Size();

    // create new cache item
    pce = NEW CCacheItem();
    if (pce == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc memory for cache item"));
        delete rgNamed;
        return E_OUTOFMEMORY;
    }

    // assign pointer to new cache item
    hr = m_rgItems->Append(pce);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - Append() failed"));
        delete pce;
        delete rgNamed;
        return hr;
    }

    hr = CreateCollectionHelper(ppDisp, lNewIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - CreateCollectionHelper() failed"));
        delete rgNamed;
        return hr; //lint !e429
    }

    Assert(*ppDisp != NULL);

    // init name
    pce->m_bstrName = SysAllocString(pwszName);
    if (pce->m_bstrName == NULL)
    {
        ReleaseInterface(*ppDisp);
        delete rgNamed;
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc mem for string"));
        return E_OUTOFMEMORY; //lint !e429
    }

    pce->m_pDisp            = *ppDisp;
    pce->m_rgElem           = rgNamed;
    pce->m_lDependentIndex  = lCollectionIndex;       // Remember the index we depend on.
    pce->m_cctype           = fTagName ? ctTag : ctNamed;
    pce->m_fInvalid         = false;
    pce->m_fIsCaseSensitive = fCaseSensitive;

    // The collection this named collection was built from is now
    // used to rebuild (ensure) this collection. so we need to
    // put a reference on it so that it will not go away.
    // The matching Release() will be done in the dtor
    // although it is not necessary to addref the reserved collections
    // it is done anyhow, simply for consistency.  This addref
    // only needs to be done for non-reserved collections
    if (lNewIndex >= m_lReservedSize)
    {
        (*ppDisp)->AddRef();
    }

    return S_OK; //lint !e429
} // GetDisp (long, const WCHAR *, bool, IDispatch **, bool)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get the number of items in this collection.
//              The default implementation of this method uses
//              EnumStart and EnumNextElement to tally the number
//              of items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the item count may be stored explicitly.)
//************************************************************

HRESULT
CCollectionCache::GetItemCount(long lCollectionIndex, long *plCount)
{
    Assert(plCount != NULL);
    *plCount = 0;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetImmediateChildCount();
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetAllChildCount();
        return S_OK;
    }
    else
    {
        Assert( ((*m_rgItems)[lCollectionIndex]->m_cctype == ctNamed) ||
                ((*m_rgItems)[lCollectionIndex]->m_cctype == ctTag) );

        // must be standard array.  (i.e. sub-collection
        // move to correct offset and find size of array
        *plCount = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        return S_OK;
    }
} // GetItemCount

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get an indexed item.  The default implementation
//              uses EnumStart and EnumNextElement to scan through
//              the items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the items are stored in a contiguous array, making
//              random access of the items trivial.)  If the index
//              is out of range, this method will still return
//              S_OK, but pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByIndex(long lCollectionIndex, long lElementIndex, CTIMEElementBase **ppElem, bool fContinueFromPreviousSearch, long lLast)
{
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // check to see if index is greater than count
        long lChildCount = m_pBase->GetImmediateChildCount();
        if (lElementIndex < 0 || lElementIndex >= lChildCount)
        {
            return E_INVALIDARG;
        }

        *ppElem = m_pBase->GetChild(lElementIndex);
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        // All Collection
        // Note: since this is iterative, check to see if we start at the
        //       beginning or from a previous spot.
        long lCount = lLast;
        Assert(lElementIndex >= lLast);
        if (!fContinueFromPreviousSearch)
        {
            lCount = 0;
            EnumStart();
        }

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError,  "CCollectionCache::GetItemByIndex - EnumNextElement() failed"));
                return hr;
            }

            Assert(ppElem != NULL);
            if (*ppElem == NULL)
            {
                // we have exceeded the bounds of the collection,
                // and therefor this is an invalid index
                return E_INVALIDARG;
            }

            // Keep scanning until we reach lElementIndex or the
            // last item in the collection.
            if (lElementIndex == lCount)
                break;
            lCount++;
        }
        return S_OK;
    }
    else
    {
        // must be standard array
        // get element at index
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if ( (lElementIndex < 0) ||
             (lElementIndex >= pce->m_rgElem->Size()) )
        {
            TraceTag((tagError, "CCollectionCache::GetItemByIndex - invalid index"));
            return E_INVALIDARG;
        }

        *ppElem = (*pce->m_rgElem)[lElementIndex];
        return S_OK;
    }
} // GetItemByIndex


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Return an item in the collection with a
//              specified id.  If no such item is found,
//              pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByName(long lCollectionIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **ppElem, bool fCaseSensitive)
{
    long    lItem = 0;

    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsAllCollection(lCollectionIndex) ||
        IsChildrenCollection(lCollectionIndex))
    {
        EnumStart();

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetItemByName - EnumNextElement() failed"));
                return hr;
            }

            // See if this was the last item in the collection
            if (*ppElem == NULL)
                break;

            // Compare the element's id to the target id
            if (CompareName(*ppElem, pwszName, false, fCaseSensitive))
            {
                // check to see if we are on specified index
                if (lElementIndex == lItem)
                    return S_OK;

                // continue looking
                lItem++;
            }
        }
        // not an error condition
        return DISP_E_MEMBERNOTFOUND;
    }
    else
    {
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        // loop thru array, looking for a match.
        // if an index is specified, then keep looking until index condition is met.
        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];

            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, false, fCaseSensitive))
            {
                    // check to see if we are on specified index
                    if (lElementIndex == lItem)
                    {
                        *ppElem = pElem;
                        return S_OK;
                    }

                    // continue looking
                    lItem++;
            }
        }

        // NOTE: if we got here, we didn't find anything
        return DISP_E_MEMBERNOTFOUND;
    }
} // GetItemByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This function initializes variables so we can
//              start walking the tree.
//************************************************************

void
CCollectionCache::EnumStart()
{
    m_pElemEnum = m_pBase;
    m_lEnumItem = 0;
} // EnumStart


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This function does the walking of our heirarchial
//              tree.
//************************************************************

HRESULT
CCollectionCache::EnumNextElement(long lCollectionIndex, CTIMEElementBase **ppElem)
{
    HRESULT hr;
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        hr = GetItemByIndex(lCollectionIndex, m_lEnumItem, ppElem);
        m_lEnumItem++;
        return hr;
    }
    else
    {
        long lChildCount = m_pElemEnum->GetImmediateChildCount();
        while (m_lEnumItem == lChildCount)
        {
            // We're one past the last element in the current child element
            // being enumerated.
            if (m_pElemEnum == m_pBase)
            {
                // We're done if we reached the last item in the
                // root element.
                *ppElem = NULL;
                return S_OK;
            }
            else
            {
                // Otherwise, back up the tree until we find some children
                // that we haven't traversed yet.
                CTIMEElementBase *pElemParent = m_pElemEnum->GetParent();
                Assert(pElemParent != NULL);

                // It's probably better if we maintain a stack of offsets
                // during traversal, but since no element can appear more
                // than once in the scene graph, we can scan to find our
                // offset in the parent's child array.
                lChildCount = pElemParent->GetImmediateChildCount();
                m_lEnumItem = 0;

                while (m_lEnumItem < lChildCount)
                {
                    CTIMEElementBase *pElemChild = pElemParent->GetChild(m_lEnumItem);
                    m_lEnumItem++;
                    if (pElemChild == m_pElemEnum)
                        break;
                }

                m_pElemEnum = pElemParent;
            }
        }

        // This can only be the result of scene graph corruption
        // during traversal.
        Assert(m_lEnumItem < lChildCount);

        if (NULL == m_pElemEnum)
        {
            return E_UNEXPECTED;
        }

        *ppElem = m_pElemEnum->GetChild(m_lEnumItem);
        Assert(*ppElem != NULL);

        // Advance to the next element.  If the current element is
        // has children, we move down the tree and start enumerating its
        // children.  Otherwise, we'll move on to the next child
        // of m_pElemEnum.
        if ((*ppElem)->GetImmediateChildCount() == 0)
        {
            m_lEnumItem++;
        }
        else
        {
            m_lEnumItem = 0;
            m_pElemEnum = *ppElem;
        }

        return S_OK;
    }
} // EnumNextElement


//************************************************************
//
// End of File
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\currtimestate.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\currtimestate.cpp
//
//  Contents: TIME currTimeState object
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "currtimestate.h"

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::CTIMECurrTimeState
//
//  Synopsis:   init member variables
//
//  Arguments:  none
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
CTIMECurrTimeState::CTIMECurrTimeState() :
    m_pTEB(NULL)
{
    // do nothing
} // CTIMECurrTimeState

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::~CTIMECurrTimeState
//
//  Synopsis:   free member variables
//
//  Arguments:  none
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
CTIMECurrTimeState::~CTIMECurrTimeState()
{
    m_pTEB = NULL;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::Init
//
//  Synopsis:   Store weak ref to containing CTIMEElementBase
//
//  Arguments:  pointer to containing CTIMEElementBase
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void
CTIMECurrTimeState::Init(CTIMEElementBase * pTEB) 
{ 
    Assert(pTEB);
    m_pTEB = pTEB; 
} // Init


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::Deinit
//
//  Synopsis:   Null out weak ref to containing CTIMEElementBase
//
//  Arguments:  pointer to containing CTIMEElementBase
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void
CTIMECurrTimeState::Deinit()
{ 
    m_pTEB = NULL; 
} // Deinit


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isActive
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isActive(/*[retval, out]*/ VARIANT_BOOL * pvbActive) 
{ 
    CHECK_RETURN_NULL(pvbActive);

    *pvbActive = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bool bIsActive = m_pTEB->GetMMBvr().IsActive();
        *pvbActive = bIsActive ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isActive


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isOn
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isOn(/*[retval, out]*/ VARIANT_BOOL * pvbOn) 
{ 
    CHECK_RETURN_NULL(pvbOn);

    *pvbOn = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bool bIsOn = m_pTEB->GetMMBvr().IsOn();
        *pvbOn = bIsOn ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isOn


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isPaused
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isPaused(/*[retval, out]*/ VARIANT_BOOL * pvbPaused) 
{ 
    CHECK_RETURN_NULL(pvbPaused);

    *pvbPaused = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pvbPaused = m_pTEB->IsCurrPaused() ? VARIANT_TRUE : VARIANT_FALSE;
    }

    if (m_pTEB->GetParent() && *pvbPaused == VARIANT_TRUE)
    {
        *pvbPaused = m_pTEB->GetParent()->IsActive() || m_pTEB->GetParent()->GetMMBvr().IsDisabled() ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isPaused


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_repeatCount
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_repeatCount(/*[retval, out]*/ long * plCount)
{
    CHECK_RETURN_NULL(plCount);

    *plCount = 1L;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *plCount = m_pTEB->GetMMBvr().GetCurrentRepeatCount();
    }

    RRETURN(S_OK);
} // get_repeatCount


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_speed
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_speed(/*[retval, out]*/ float * pflSpeed) 
{ 
    CHECK_RETURN_NULL(pflSpeed);

    *pflSpeed = 1.0f;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pflSpeed = m_pTEB->GetMMBvr().GetCurrSpeed();
    }

    RRETURN(S_OK);
} // get_speed


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_simpleTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_simpleTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSimpleTime();
    }

    RRETURN(S_OK);
} // get_simpleTime

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_segmentTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_segmentTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSegmentTime();
    }

    RRETURN(S_OK);
} // get_segmentTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_activeTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveTime();
    }

    RRETURN(S_OK);
} // get_activeTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeBeginTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_parentTimeBegin(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveBeginTime();
    }

    RRETURN(S_OK);
} // get_activeBeginTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeEndTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_parentTimeEnd(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveEndTime();
    }

    RRETURN(S_OK);
} // get_activeEndTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_activeDur(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveDur();
    }

    RRETURN(S_OK);
} // get_activeDur


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_segmentDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_segmentDur(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSegmentDur();
    }

    RRETURN(S_OK);
} // get_segmentDur

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//              (Copied from CBaseBehavior)
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CTIMECurrTimeState::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            //DPF_ERR("Error finding connection enumerator");
            //return SetErrorInfo(hr);
            TIMESetLastError(hr);
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                //DPF_ERR("Error invalid object found in connection enumeration");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                //DPF_ERR("Error calling Notify sink's on change");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        ReleaseInterface(pEnum);
    }

    return hr;
} // NotifyPropertyChanged


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::GetConnectionPoint
//
//  Synopsis:   Gets the connection point for the given outgoing interface. This is abstracted
//              out to allow for future modifications to the inheritance hierarchy.
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMECurrTimeState::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_simpleDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_simpleDur(/*[retval, out]*/ double * pdblDur) 
{ 
    CHECK_RETURN_NULL(pdblDur);

    *pdblDur = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblDur = m_pTEB->GetMMBvr().GetSimpleDur();
    }

    RRETURN(S_OK);
} // get_simpleDur

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_state
//
//  Synopsis:   Returns timeState of this element (active, inactive or holding)
//
//  Arguments:  [ptsState]     out param
//
//  Returns:    [E_POINTER]     bad arg 
//              [S_OK]          success
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMECurrTimeState::get_state(TimeState * ptsState)
{
    CHECK_RETURN_NULL(ptsState);

    *ptsState = m_pTEB->GetTimeState();

    RRETURN(S_OK);
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_stateString
//
//  Synopsis:   Gets timeState and translates it to the appropriate string (active, inactive or holding)
//
//  Arguments:  [pbstrState]     out param
//
//  Returns:    [E_POINTER]     bad arg 
//              [S_OK]          success
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMECurrTimeState::get_stateString(BSTR * pbstrState)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(pbstrState);

    switch (m_pTEB->GetTimeState())
    {
      case TS_Active:
      {
          *pbstrState = SysAllocString(WZ_STATE_ACTIVE);
          break;
      }

      default:
      case TS_Inactive:
      {
          *pbstrState = SysAllocString(WZ_STATE_INACTIVE);
          break;
      }

      case TS_Holding:
      {
          *pbstrState = SysAllocString(WZ_STATE_HOLDING);
          break;
      }

      case TS_Cueing:
      {
          *pbstrState = SysAllocString(WZ_STATE_CUEING);
          break;
      }

      case TS_Seeking:
      {
          *pbstrState = SysAllocString(WZ_STATE_SEEKING);
          break;
      }
    } // switch

    if (NULL == *pbstrState)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_progress
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_progress(double * pdblProgress)
{
    CHECK_RETURN_NULL(pdblProgress);

    *pdblProgress = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblProgress = m_pTEB->GetMMBvr().GetProgress();
    }

    RRETURN(S_OK);
} // get_progress

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_volume
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_volume(float * pfltVol)
{
    CHECK_RETURN_NULL(pfltVol);

    *pfltVol = 1.0f;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pfltVol = m_pTEB->GetCascadedVolume() * 100;
    }

    RRETURN(S_OK);
} // get_volume

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isMuted
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isMuted(VARIANT_BOOL * pvbMuted)
{
    CHECK_RETURN_NULL(pvbMuted);
    bool bIsMuted = false;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bIsMuted = m_pTEB->GetCascadedMute();
    }

    *pvbMuted = (bIsMuted)?VARIANT_TRUE:VARIANT_FALSE;

    RRETURN(S_OK);
    
} // get_isMuted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\collect.h ===
#ifndef __COLLECT_H_
#define __COLLECT_H_

//************************************************************
//
// Filename:    collect.h
//
// Created:     09/25/97
//
// Author:      twillie
//
// Abstract:    Collection implementation.
//              
//************************************************************

#include "dispex.h"
#include "atomtable.h"
#include "timeelmbase.h"
#include "array.h"
#include "mstimeid.h"


#define NOT_DEPENDENT_COLLECTION   -1
#define CTL_E_METHODNOTAPPLICABLE  STD_CTL_SCODE(444)

class CTIMEElementBase;

//
// A class for declaring poiners to member functions
//
class CVoid
{
}; // CVoid

//
// prototype macros for function over rides
// These are used when owner of collection wants to customize it.
//
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ENSURE)(long *plVersionCookie);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_CREATECOL)(IDispatch **pDisp,
                                                      long        lIndex);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_REMOVEOBJECT)(long lCollection,
                                                         long lIndex);
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ADDNEWOBJECT)(long       lIndex, 
                                                         IDispatch *pObject, 
                                                         long       index);

typedef enum COLLECTIONCACHETYPE
{
    ctFreeEntry,
    ctNamed,
    ctTag,
    ctAll,
    ctChildren
} tagCOLLECTIONCACHETYPE;

//
// CCollectionCache
//
class CCollectionCache
{
    class CCacheItem
    {
    public:
        CCacheItem() :
            m_pDisp(NULL),
            m_rgElem(NULL),
            m_cctype(ctFreeEntry),
            m_bstrName(NULL),
            m_lDependentIndex(NOT_DEPENDENT_COLLECTION),
            m_dispidMin(DISPID_COLLECTION_RESERVED_MIN),
            m_dispidMax(DISPID_COLLECTION_RESERVED_MAX),
            m_fInvalid(true),
            m_fIdentity(false),
            m_fOKToDelete(true),
            m_fNeedRebuild(false),
            m_fPromoteNames(true),
            m_fPromoteOrdinals(true),
            m_fGetLastCollectionItem(false),
            m_fIsCaseSensitive(false),
            m_fSettableNULL(false)
        {
        } // constructor

        virtual ~CCacheItem()
        {
            if (m_rgElem)
            {
                delete m_rgElem;
                m_rgElem = NULL;
            }

            ReleaseInterface(m_pDisp);

            if (m_bstrName)
            {
                SysFreeString(m_bstrName);
                m_bstrName = NULL;
            }
        } // destructor

        IDispatch                   *m_pDisp;           // IDispatch for ICrElementCollection
        CPtrAry<CTIMEElementBase *> *m_rgElem;          // array of elements in collection
        COLLECTIONCACHETYPE          m_cctype;          // cache type
        BSTR                         m_bstrName;        // Name if name-based
        long                         m_lDependentIndex; // Index of item that this depends.
        DISPID                       m_dispidMin;       // Offset to add/subtract
        DISPID                       m_dispidMax;       // Offset to add/subtract

        // bit flags
        bool  m_fInvalid:1;      // set for named collections only
        bool  m_fIdentity:1;     // set when a collection is Identity with its container/base object
        bool  m_fOKToDelete:1;   // true for collections that the cache cooks up false when Base Obj provided this CPtrAry
        bool  m_fNeedRebuild:1;  // true is collection need to be rebuilt.
        bool  m_fPromoteNames:1;    // true if we promote names from the object
        bool  m_fPromoteOrdinals:1; // true if we promote ordinals from the object
        bool  m_fGetLastCollectionItem:1; // true to fetch last item only in collection
        bool  m_fIsCaseSensitive:1;       // true if item's name must be compared in case sensitive manner
        bool  m_fSettableNULL:1;          // true when collection[n]=NULL is valid. normally false.
    }; // CCacheItem

public:
    //
    // Constructor/Destructor
    //    
    CCollectionCache(CTIMEElementBase *pBase,
                     CAtomTable *pAtomTable = NULL,
                     PFN_CVOID_ENSURE pfnEnsure = NULL,
                     PFN_CVOID_CREATECOL pfnCreation = NULL,
                     PFN_CVOID_REMOVEOBJECT pfnRemove = NULL,
                     PFN_CVOID_ADDNEWOBJECT pfnAddNewObject = NULL);
    virtual ~CCollectionCache();

    //
    // internal methods
    //
    HRESULT Init(long lReservedSize, long lIdentityIndex = -1);
    HRESULT GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp);
    HRESULT SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype);
    long Size(long lCollectionIndex);
    HRESULT GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem);
    void Invalidate();
    void BumpVersion();

    //
    // IDispatchEx methods
    //
    HRESULT GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid);
    HRESULT InvokeEx(long                 lCollectionIndex, 
                     DISPID               dispidMember,
                     LCID                 lcid,
                     WORD                 wFlags,
                     DISPPARAMS          *pdispparams,
                     VARIANT             *pvarResult,
                     EXCEPINFO           *pexcepinfo,
                     IServiceProvider    *pSrvProvider);
    HRESULT DeleteMemberByName(long lCollectionIndex, BSTR bstr,DWORD grfdex);
    HRESULT DeleteMemberByDispID(long lCollectionIndex, DISPID id);
    HRESULT GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    HRESULT GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName);
    HRESULT GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid);
    HRESULT GetNameSpaceParent(long lCollectionIndex, IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    HRESULT put_length(long lIndex, long retval);
    HRESULT get_length(long lIndex, long *retval);
    HRESULT get__newEnum(long lIndex, IUnknown **retval);
    HRESULT item(long lIndex, VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    HRESULT tags(long lIndex, VARIANT varName, IDispatch **pDisp);

private:
    // private functions
    HRESULT EnsureArray(long lCollectionIndex);
    void EnumStart(void);
    HRESULT EnumNextElement(long lCollectionIndex, CTIMEElementBase **pElem);

    HRESULT GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp);
    HRESULT Remove(long lCollection, long lItemIndex);
    HRESULT CreateCollectionHelper(IDispatch **ppDisp, long lIndex);

    bool CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive = false);

    HRESULT BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive = false);
    HRESULT GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk);    
    
    HRESULT GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lItemIndex, IDispatch **ppDisp, bool fCaseSensitive = false);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, IDispatch **ppDisp, bool fCaseSensitive = false);

    HRESULT GetItemCount(long lIndex, long *plCount);
    HRESULT GetItemByIndex(long lIndex, long lElementIndex, CTIMEElementBase **pElem, bool fContinueFromPreviousSearch = false, long lLast = 0);
    HRESULT GetItemByName(long lIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **pElem, bool fCaseSensitive = false);

    bool IsChildrenCollection(long lCollectionIndex);
    bool IsAllCollection(long lCollectionIndex);
    
    bool ValidateCollectionIndex(long lCollectionIndex);

    DISPID GetNamedMemberMin(long lCollectionIndex);
    DISPID GetNamedMemberMax(long lCollectionIndex);
    DISPID GetOrdinalMemberMin(long lCollectionIndex);
    DISPID GetOrdinalMemberMax(long lCollectionIndex);
    bool IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember);
    DISPID GetSensitiveNamedMemberMin (long lCollectionIndex);
    DISPID GetSensitiveNamedMemberMax(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMin(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMax(long lCollectionIndex);
    bool IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember);
    long GetNamedMemberOffset(long lCollectionIndex, DISPID id, bool *pfCaseSensitive = NULL);

private:
    CTIMEElementBase       *m_pElemEnum;        // Used as a place holder when we walk the tree
    long                    m_lEnumItem;        // Used as a place holder when we walk the tree
    long                    m_lReservedSize;    // number of CElementCollections that are reserved

    CPtrAry<CCacheItem *>  *m_rgItems;          // array of CCachItems

    long                    m_lCollectionVersion;
    long                    m_lDynamicCollectionVersion;

    CTIMEElementBase       *m_pBase;
    CAtomTable             *m_pAtomTable;       // array of named elements which we have DISPID's for
    
    // functions used to over ride default collection behavior                      
    PFN_CVOID_ENSURE        m_pfnEnsure;
    PFN_CVOID_REMOVEOBJECT  m_pfnRemoveObject; 
    PFN_CVOID_CREATECOL     m_pfnCreateCollection;
    PFN_CVOID_ADDNEWOBJECT  m_pfnAddNewObject;
protected:
    CCollectionCache();
}; // CCollectionCache

//
// CTIMEElementCollection
//
class CTIMEElementCollection : 
    public IDispatchEx,
    public ITIMEElementCollection,
    public ISupportErrorInfoImpl<&IID_ITIMEElementCollection>
{
public:
    CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex);

    //
    // IUnknown Methods
    //
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, void**);

    //
    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT FAR *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID                riid,
                             LPOLESTR             *rgszNames,
                             UINT                  cNames,
                             LCID                  lcid,
                             DISPID FAR           *rgdispid);
    STDMETHOD(Invoke)(DISPID          dispidMember,
                      REFIID          riid,
                      LCID            lcid,
                      WORD            wFlags,
                      DISPPARAMS     *pdispparams,
                      VARIANT        *pvarResult,
                      EXCEPINFO      *pexcepinfo,
                      UINT           *puArgErr);

    //
    // IDispatchEx methods
    //
    STDMETHOD(GetDispID)(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHOD(InvokeEx)(DISPID               dispidMember,
                       LCID                 lcid,
                       WORD                 wFlags,
                       DISPPARAMS          *pdispparams,
                       VARIANT             *pvarResult,
                       EXCEPINFO           *pexcepinfo,
                       IServiceProvider    *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(BSTR bstr,DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(DISPID id);
    STDMETHOD(GetMemberProperties)(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHOD(GetMemberName)(DISPID id, BSTR *pbstrName);
    STDMETHOD(GetNextDispID)(DWORD grfdex, DISPID id, DISPID *prgid);
    STDMETHOD(GetNameSpaceParent)(IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    STDMETHOD(put_length)(long retval);
    STDMETHOD(get_length)(long *retval);
    STDMETHOD(get__newEnum)(IUnknown **retval);
    STDMETHOD(item)(VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    STDMETHOD(tags)(VARIANT varName, IDispatch **pDisp);

private:
    virtual ~CTIMEElementCollection();
    HRESULT GetTI(ITypeInfo **pptinfo);

private:
    CCollectionCache *m_pCollectionCache;  // pointer to the cache
    long              m_lCollectionIndex;  // denotes which collection we are
    ULONG             m_cRef;
    ITypeInfo        *m_pInfo;             // our TypeInfo Interface
protected:
    CTIMEElementCollection();
}; // CTIMEElementCollection

//************************************************************
// inline's for CCollectionCache
//************************************************************
inline void CCollectionCache::Invalidate()
{
    m_lCollectionVersion        = 0;
    m_lDynamicCollectionVersion = 0;        
} // Invalidate

inline void CCollectionCache::BumpVersion()
{
    m_lCollectionVersion++;
} // BumpVersion

inline bool CCollectionCache::ValidateCollectionIndex(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && (lCollectionIndex < m_rgItems->Size()))
        return true;
    return false;
} // ValidateCollectionIndex

inline DISPID CCollectionCache::GetNamedMemberMin(long lCollectionIndex) 
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMin; 
} // GetNamedMemberMin

inline DISPID CCollectionCache::GetNamedMemberMax(long lCollectionIndex)
{ 
    return ((*m_rgItems)[lCollectionIndex]->m_dispidMin + 
            (((*m_rgItems)[lCollectionIndex]->m_dispidMax - (*m_rgItems)[lCollectionIndex]->m_dispidMin) / 2));
} // GetNamedMemberMax

inline DISPID CCollectionCache::GetOrdinalMemberMin(long lCollectionIndex)
{
    return GetNamedMemberMax(lCollectionIndex) + 1;
} // GetOrdinalMemberMin

inline DISPID CCollectionCache::GetOrdinalMemberMax(long lCollectionIndex)
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMax;
} // GetOrdinalMemberMax

inline bool CCollectionCache::IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNamedMemberMin(lCollectionIndex)) &&
            (dispidMember <= GetNamedMemberMax(lCollectionIndex)));
} // IsNamedCollectionMember

inline bool CCollectionCache::IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetOrdinalMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetOrdinalMemberMax(lCollectionIndex)));
} // IsOrdinalCollectionMember

inline DISPID CCollectionCache::GetSensitiveNamedMemberMin (long lCollectionIndex)
{
    return GetNamedMemberMin(lCollectionIndex);
} // GetSensitiveNamedMemberMin

inline DISPID CCollectionCache::GetSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return (GetNamedMemberMin(lCollectionIndex) + 
            ((GetNamedMemberMax(lCollectionIndex) - GetNamedMemberMin(lCollectionIndex)) / 2));
} // GetSensitiveNamedMemberMax

inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMin(long lCollectionIndex)
{
    return GetSensitiveNamedMemberMax(lCollectionIndex) + 1;
} // GetNotSensitiveNamedMemberMin
 
inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return GetNamedMemberMax(lCollectionIndex);
} // GetNotSensitiveNamedMemberMax

inline bool CCollectionCache::IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsSensitiveNamedCollectionMember

inline bool CCollectionCache::IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNotSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetNotSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsNotSensitiveNamedCollectionMember

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\currtimestate.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\currtimestate.h
//
//  Contents: TIME currTimeState object
//
//------------------------------------------------------------------------------------


#pragma once

#ifndef _CURRTIMESTATE_H
#define _CURRTIMESTATE_H

class CTIMEElementBase;

//+-------------------------------------------------------------------------------------
//
// CTIMETimeState
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("275CE6A0-7D26-41f9-B5E6-57EE053C5A0E")) 
CTIMECurrTimeState :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTIMECurrTimeState, &__uuidof(CTIMECurrTimeState)>,
    public ITIMEDispatchImpl<ITIMEState, &IID_ITIMEState>,
    public ISupportErrorInfoImpl<&IID_ITIMEState>,
    public IConnectionPointContainerImpl<CTIMECurrTimeState>,
    public IPropertyNotifySinkCP<CTIMECurrTimeState>
{

  public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMECurrTimeState();
    virtual ~CTIMECurrTimeState();

    void Init(CTIMEElementBase * pTEB);
    void Deinit();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMECurrTimeState"); }
#endif

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // ITimeState
    //

    STDMETHOD(get_activeDur)(double * pdblDuration);

    STDMETHOD(get_activeTime)(double * pdblTime);

    STDMETHOD(get_isActive)(VARIANT_BOOL * vbActive);

    STDMETHOD(get_isOn)(VARIANT_BOOL * pvbOn);

    STDMETHOD(get_isPaused)(VARIANT_BOOL * pvbPaused);

    STDMETHOD(get_isMuted)(VARIANT_BOOL * muted);

    STDMETHOD(get_parentTimeBegin)(double * pdblTime);

    STDMETHOD(get_parentTimeEnd)(double * pdblTime);

    STDMETHOD(get_progress)(double * progress);

    STDMETHOD(get_repeatCount)(long * plCount);

    STDMETHOD(get_segmentDur)(double * pdblDuration);

    STDMETHOD(get_segmentTime)(double * pdblTime);

    STDMETHOD(get_simpleTime)(double * pdblTime);

    STDMETHOD(get_simpleDur)(double * dur);

    STDMETHOD(get_speed)(float * pflSpeed);

    STDMETHOD(get_state)(TimeState * timeState);

    STDMETHOD(get_stateString)(BSTR * state);

    STDMETHOD(get_volume)(float * vol);

    //
    // ATL Maps
    //

    BEGIN_COM_MAP(CTIMECurrTimeState)
        COM_INTERFACE_ENTRY(ITIMEState)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CTIMECurrTimeState)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // Property Change Notification
    //

    HRESULT NotifyPropertyChanged(DISPID dispid);

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // Notification Helper
    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    CTIMEElementBase * m_pTEB;


  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

}; // CTIMECurrTimeState


//+---------------------------------------------------------------------------------
//  CTIMECurrTimeState inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------


#endif /* _CURRTIMESTATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmexcl.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\timebvr\mmexcl.cpp
//
//  Contents: implementation of MMExcl and CExclStacc
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "mmexcl.h"
#include "timeelmbase.h"

DeclareTag(tagMMUTILExcl, "TIME: Behavior", "MMExcl methods")

#define SUPER MMTimeline


//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::MMExcl
//
//  Overview:  constructor
//
//  Arguments: elm  element this bvr is associated with
//             bFireEvents  whether or not to fire events
//             
//  Returns:   void
//
//------------------------------------------------------------------------
MMExcl::MMExcl(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents),
    m_pPlaying(NULL),
    m_baseTIMEEelm (elm)
{
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::~MMExcl
//
//  Overview:  destructor
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
MMExcl::~MMExcl()
{
    m_pPlaying = NULL;
    
    ClearQueue();
}
    
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::Init
//
//  Overview:  initialized the stack for excl
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
bool 
MMExcl::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
        goto done;
    }

    ok = true;
 done:
    return ok;
}
    
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::RemoveBehavior
//
//  Overview:  Removes children
//
//  Arguments: bvr  element to remove
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::RemoveBehavior(MMBaseBvr & bvr)
{
    long lPriIndex = m_children.Find(&bvr);
    if ((0 <= lPriIndex) && (m_pbIsPriorityClass.Size() > lPriIndex))
    {
        m_pbIsPriorityClass.DeleteItem(lPriIndex);
    }
    
    SUPER::RemoveBehavior(bvr);

    long lIndex = m_pPendingList.Find(&bvr);
    if ((lIndex >= 0) && (lIndex < m_pPendingState.Size()))
    {
        m_pPendingList.DeleteByValue(&bvr); 
        m_pPendingState.DeleteItem(lIndex);
    }
}

HRESULT 
MMExcl::AddBehavior(MMBaseBvr & bvr)
{
    HRESULT hr = S_OK;
    bool bIsPriority = false;
    hr = SUPER::AddBehavior(bvr);

    if (SUCCEEDED(hr))
    {
        bIsPriority = IsPriorityClass(&bvr);
        m_pbIsPriorityClass.AppendIndirect(&bIsPriority, NULL);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::ArePeers
//
//  Overview:  determines if two HTML Elements have the same parent or
//             are the same depth from the t:excl tag.
//
//  Arguments: pEl1, pElm2 - elements to compare
//             
//  Returns:   true if parents are same, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::ArePeers(IHTMLElement * pElm1, IHTMLElement * pElm2)
{
    HRESULT hr = S_OK;
    IHTMLElement *spParent1 = NULL;
    IHTMLElement *spParent2 = NULL;
    CComPtr <IUnknown> pUnk1;
    CComPtr <IUnknown> pUnk2;
    CComPtr<IHTMLElement> spNext;
    bool fArePeers = false;

    Assert(NULL != pElm1);
    Assert(NULL != pElm2);

    //otherwise determine if the elements have the same priority class.
    spParent1 = GetParentElement(pElm1);
    spParent2 = GetParentElement(pElm2);

    if (spParent1 == NULL && spParent2 == NULL)
    {
        fArePeers = true;
    }
    else if (spParent1 == NULL || spParent2 == NULL)
    {
        fArePeers = false;
    }
    else 
    {
        hr = THR(spParent1->QueryInterface(IID_IUnknown, (void**)&pUnk1));
        if (FAILED(hr))
        {
            fArePeers = false;
            goto done;
        }
        hr = THR(spParent2->QueryInterface(IID_IUnknown, (void**)&pUnk2));
        if (FAILED(hr))
        {
            fArePeers = false;
            goto done;
        }
        
        fArePeers = (pUnk1 == pUnk2);
        
    }

    
done:

    if (spParent1)
    {
        spParent1->Release();
    }
    if (spParent2)
    {
        spParent2->Release();
    }
    return fArePeers;
}

//returns either the parent priority class or the parent excl if no priority class exists.
IHTMLElement *
MMExcl::GetParentElement(IHTMLElement *pEle)
{
    IHTMLElement *pReturnEle = NULL;
    CComPtr<IHTMLElement> pEleParent;
    CComPtr <IHTMLElement> pNext;
    CComPtr <IHTMLElement> pExclEle;
    CComPtr <IUnknown> pUnkExclEle;

    BSTR bstrTagName = NULL;
    HRESULT hr = S_OK;
    bool bDone = false;

    hr = THR(pEle->get_parentElement(&pEleParent));
    if (FAILED(hr))
    {
        pReturnEle = NULL;
        goto done;        
    }

    //get the element associated with this timeline
    pExclEle = m_baseTIMEEelm.GetElement();
    if (pExclEle == NULL)
    {
        pReturnEle = NULL;
        goto done;                
    }
    hr = THR(pExclEle->QueryInterface (IID_IUnknown, (void**)&pUnkExclEle));
    if (FAILED(hr))
    {
        pReturnEle = NULL;
        goto done;                        
    }


    while (pEleParent != NULL && bDone != true)
    {
        hr = THR(pEleParent->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            pReturnEle = NULL;
            goto done;        
        }
        if (bstrTagName != NULL)
        {
            // if this is a priority class then return it.
            if (StrCmpIW(bstrTagName, WZ_PRIORITYCLASS_NAME) == 0)
            {
                pReturnEle = pEleParent;
                pReturnEle->AddRef();
                bDone = true;
            }
            else
            {
                // else determine if this is the excl element.
                //NOTE: it will not work to just check for 
                //the excl tagname because it could be any tag with 
                //timecontainer=excl
                CComPtr <IUnknown> pUnk;
                hr = THR(pEleParent->QueryInterface(IID_IUnknown, (void**)&pUnk));
                if (FAILED(hr))
                {
                    pReturnEle = NULL;
                    bDone = true;
                }
                if (pUnkExclEle == pUnk)
                {
                    pReturnEle = pEleParent;
                    pReturnEle->AddRef();
                    bDone = true;
                }
            }
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
        }
        
        hr = THR(pEleParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            pReturnEle = NULL;
            goto done;        
        }
        pEleParent.Release();
        pEleParent = pNext;
        pNext.Release();
     }

  done:

    if (bstrTagName)
    {
        SysFreeString(bstrTagName);
    }
    return pReturnEle;
}


//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::IsHigherPriority
//
//  Overview:  determines if the elements passed in are related such that:
//              pElmLeft > pElmRight where > mean higher priority
//
//  Arguments: pElmLeft, pElmRight - element to compare
//             
//  Returns:   true if pElmLeft > pElmRight, otherwise false
//
//------------------------------------------------------------------------
bool 
MMExcl::IsHigherPriority(IHTMLElement * pElmLeft, IHTMLElement * pElmRight)
{
    Assert(NULL != pElmLeft);
    Assert(NULL != pElmRight);
    Assert(!ArePeers(pElmLeft, pElmRight));

    HRESULT hr = S_OK;
    
    bool fIsHigher = false;

    CComPtr<IHTMLElement> spExcl;
    CComPtr<IHTMLElement> spParentLeft;
    CComPtr<IHTMLElement> spParentRight;
    CComPtr<IDispatch>  spDispCollection;
    CComPtr<IHTMLElementCollection> spCollection;
    
    // guarantee that the parents are peers     
    hr = pElmLeft->get_parentElement(&spParentLeft);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = pElmRight->get_parentElement(&spParentRight);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!ArePeers(spParentLeft, spParentRight))
    {
        // the parent elements are not peers
        goto done;
    }

    // guarantee the parents are children of this excl

    hr = spParentLeft->get_parentElement(&spExcl);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!MatchElements(spExcl, GetElement().GetElement()))
    {
        // the parent of the parents is not this excl
        goto done;
    }

    hr = spExcl->get_children(&spDispCollection);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDispCollection->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &spCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        long lCollectionLength;
        long lCount;
        hr = spCollection->get_length(&lCollectionLength);
        if (FAILED(hr))
        {
            goto done;
        }
        
        for(lCount = 0; lCount < lCollectionLength; lCount++)
        {
            CComPtr<IDispatch> spDispatch;
            CComVariant varName(lCount);
            CComVariant varIndex;
            
            hr = spCollection->item(varName, varIndex, &spDispatch);
            if (FAILED(hr))
            {
                goto done;
            }

            if (MatchElements(spDispatch, spParentLeft))
            {
                fIsHigher = true;
                break;
            }
            else if (MatchElements(spDispatch, spParentRight))
            {
                fIsHigher = false;
                break;
            }
        }
    }
    
done:
    return fIsHigher;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::GetRelationShip
//
//  Overview:  Determines the relationship between elements
//
//  Arguments: pBvrRunning, pBvrInterrupting - elements to decide relationship
//             rel - where to store the relationship
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::GetRelationship(MMBaseBvr * pBvrRunning, 
                        MMBaseBvr * pBvrInterrupting, 
                        RELATIONSHIP & rel)
{
    // choose a default
    rel = PEERS;

    IHTMLElement * pElmRunning = pBvrRunning->GetElement().GetElement();
    IHTMLElement * pElmInterrupting = pBvrInterrupting->GetElement().GetElement();
    if (NULL == pElmRunning || NULL == pElmInterrupting)
    {
        goto done;
    }

    if (ArePeers(pElmRunning, pElmInterrupting))
    {
        rel = PEERS;
        goto done;
    }

    if (IsHigherPriority(pElmRunning, pElmInterrupting))
    {
        rel = LOWER;
        goto done;
    }

    //Assert(IsHigherPriority(pElmInterrupting, pElmRunning));
    rel = HIGHER;
    
done:
    return;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::childEventNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving event
//             dblLocalTime - time at which the event occurred
//             et - event that occurred
//             
//  Returns:   true if event should be processed, false otherwise
//
//------------------------------------------------------------------------
bool
MMExcl::childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    TraceTag((tagMMUTILExcl, 
        "MMExcl::childEventNotify(%p) event %d on element %ls",
        this,
        et,
        pBvr->GetID() ? pBvr->GetID() : L"Unknown" ));

    Assert(NULL != pBvr);

    bool fProcessEvent = true;

    fProcessEvent = SUPER::childEventNotify(pBvr, dblLocalTime, et);
    if (false == fProcessEvent)
    {
        goto done;
    }

    if ( m_pPlaying != pBvr && IsInBeingAdjustedList(pBvr))
    {
        fProcessEvent = false;
        goto done;
    }

    switch(et)
    {
        case TE_EVENT_RESUME:
        {
            long lChild = m_pPendingList.Find(pBvr);
            if (lChild == -1 && pBvr != m_pPlaying)
            {
                goto done;
            }
        }
        case TE_EVENT_BEGIN:
        {
            long lChild = -1;
            int l = m_children.Size();
            int i = 0;

            for (i = 0; i < l; i++)
            {
                MMBaseBvr *pBvr2 = m_children.Item(i);
                
                if (pBvr2->GetElement().GetFill() == FREEZE_TOKEN)
                {
                    pBvr2->GetElement().ToggleTimeAction(false);
                }
            }

            //if the exlcusive is using priority classes and this is not a priority class
            //then the begin on it needs to be cancelled and ignored.
            if (UsingPriorityClasses() && !IsPriorityClass(pBvr)) 
            { 
                StopBegin(pBvr);
                fProcessEvent = false;
                break;
            }


            if (NULL == m_pPlaying)
            {
                m_pPlaying = pBvr;
                break;
            }
            if (pBvr == m_pPlaying)
            {
                m_pPlaying->GetElement().ToggleTimeAction(true);
                break;
            }
        
            
            RELATIONSHIP rel;
            GetRelationship(m_pPlaying, pBvr, rel);
            TOKEN action;

            switch(rel)
            {
            case HIGHER:
            {
                action = m_pPlaying->GetElement().GetPriorityClassHigher();
                if ( STOP_TOKEN == action )
                {
                    EndCurrent();
                } 
                else if ( PAUSE_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    {
                        DeferBeginAndAddToQueue(pBvr);
                        fProcessEvent = false;
                    }
                    else
                    {
                        PauseCurrentAndAddToQueue();
                    }
                }
                else
                {
                    // should never get here
                    Assert(false);
                }
                break; // HIGHER
            }    
            case PEERS:
            {
                action = m_pPlaying->GetElement().GetPriorityClassPeers();
                if ( STOP_TOKEN == action )
                {
                    EndCurrent();
                }
                else if ( PAUSE_TOKEN == action )
                {
                    
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                        fProcessEvent = false;
                    }
                    else
                    {
                        PauseCurrentAndAddToQueue();
                    }
                }
                else if ( DEFER_TOKEN == action )
                {
                    DeferBeginAndAddToQueue(pBvr);
                    fProcessEvent = false;
                }
                else if ( NEVER_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                    }
                    else
                    {                    
                        StopBegin(pBvr);
                    }
                    fProcessEvent = false;
                }
                else
                {
                    // should never get here
                    Assert(false);
                }
                break; // PEERS
            }
            case LOWER:
            {
                action = m_pPlaying->GetElement().GetPriorityClassLower();
                if ( DEFER_TOKEN == action )
                {
                    DeferBeginAndAddToQueue(pBvr);
                    fProcessEvent = false;
                }
                else if ( NEVER_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                    }
                    else
                    {                    
                        StopBegin(pBvr);
                    }
                    fProcessEvent = false;
                }
                else 
                {
                    // should never get here
                    Assert(false);
                }
                break; // LOWER
            }
            default:
            {
                // should never get here
                Assert(false);
                break;
            }
        }  // switch(rel)

        if (fProcessEvent)
        {
            m_pPlaying = pBvr;
        }

        lChild = m_pPendingList.Find(m_pPlaying);
        if (lChild != -1)
        {
            m_pPendingList.DeleteItem(lChild);
        }
        m_pPlaying->Enable();
        m_pPlaying->GetElement().ToggleTimeAction(true);
        break; // TE_EVENT_BEGIN
    }

    case TE_EVENT_END:    
    {
        if (m_pPlaying == pBvr && !IsInBeingAdjustedList(m_pPlaying))
        {
            // check to see if there was a previously playing item
            EXCL_STATE state;
         
            MMBaseBvr * pPrevPlaying = NULL;
            if (m_pPendingList.Size() > 0)
            {
                pPrevPlaying = m_pPendingList.Item(0);
                state = m_pPendingState.Item(0);
                m_pPendingList.DeleteByValue(pPrevPlaying);    
                m_pPendingState.DeleteItem(0);
            }
            m_pPlaying = pPrevPlaying;
            if ((pPrevPlaying != NULL))
            {
                if (PAUSED == state)
                {
                    TraceTag((tagMMUTILExcl, 
                        "MMExcl::childEventNotify(%d) toggling %ls on",
                        this,
                        pPrevPlaying->GetID() ? pPrevPlaying->GetID() : L"Unknown" ));
                    
                    // For now the order is important since the event
                    // is used in the media portion and not the
                    // property change notification
                    pPrevPlaying->Enable();
                    pPrevPlaying->Resume();
                }
                else if (STOPPED == state)
                {
                    TraceTag((tagMMUTILExcl, 
                        "MMExcl::childEventNotify(%d) beginning %ls ",
                        this,
                        pPrevPlaying->GetID() ? pPrevPlaying->GetID() : L"Unknown" ));

                    pPrevPlaying->Enable();
                    pPrevPlaying->GetElement().FireEvent(TE_ONBEGIN, 0.0, 0, 0);
                }
            }
        }
        else
        {
            long lCurBvr = m_pPendingList.Find(pBvr);
            if (lCurBvr != -1)
            {
                m_pPendingList.DeleteByValue(m_pPendingList.Item(lCurBvr));
                m_pPendingState.DeleteItem(lCurBvr);
                pBvr->Enable();
            }
            fProcessEvent = true;
        }
        break; //TE_EVENT_END
    }
    default:
        break;
    } // switch

done:

    return fProcessEvent;
}


bool 
MMExcl::IsAtEndTime(MMBaseBvr *pBvr)
{
    double dblActiveEndTime = m_pPlaying->GetActiveEndTime();
    double dblCurrParentTime = m_pPlaying->GetCurrParentTime();

    if (dblActiveEndTime <= dblCurrParentTime)
    { //this is the case of events coming in in an incorrect order
        return true;
    }
    else
    {                    
        return false;
    } 
}
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::childPropNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving notification
//             tePropType - type of notification occurring
//
//  Returns:   true if element should process notification, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    Assert(NULL != pBvr);

    bool fProcessNotify = true;
    DWORD dwTemp = *tePropType & TE_PROPERTY_ISON;

    if (!SUPER::childPropNotify(pBvr, tePropType))
    {
        fProcessNotify = false;
        goto done;
    }

    if (IsInBeingAdjustedList(pBvr))
    {
        if (dwTemp == TE_PROPERTY_ISON && pBvr == m_pPlaying)    
        {
            fProcessNotify = true;
        }
        else
        {
            fProcessNotify = false;
        }
        goto done;
    }

    fProcessNotify = true;
done:
    return fProcessNotify;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::IsInBeingAdjustedList
//
//  Overview:  Determine if element is currently being adjusted
//
//  Arguments: pBvr - element to check if in list
//             
//  Returns:   true if element is in list, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::IsInBeingAdjustedList(MMBaseBvr * pBvr)
{
    std::list<MMBaseBvr*>::iterator iter;
    iter = m_beingadjustedlist.begin();
    while(iter != m_beingadjustedlist.end())
    {
        if ((*iter) == pBvr)
        {
            return true;
        }
        iter++;
    }
    return false;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::EndCurrent
//
//  Overview:  Ends the currently running element
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::EndCurrent()
{
    MMBaseBvr * pBvr = m_pPlaying;
    m_beingadjustedlist.push_front(pBvr);

    pBvr->End(0.0);

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::ClearQueue()
//
//  Overview:  Clears the Queue
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::ClearQueue()
{
    while (m_pPendingList.Size() > 0)
    {
        m_pPendingList.DeleteByValue(m_pPendingList.Item(0));
        m_pPendingState.DeleteItem(0);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::PauseCurrentAndAddToQueue
//
//  Overview:  Pause the current element, toggle it's timeaction off, 
//              and add it to the Queue in a paused state
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::PauseCurrentAndAddToQueue()
{
    MMBaseBvr * pBvr = m_pPlaying;
    m_beingadjustedlist.push_front(pBvr);
    
    IGNORE_HR(pBvr->Pause());
    IGNORE_HR(pBvr->Disable());
    AddToQueue(pBvr, PAUSED);

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::DeferBeginAndAddToQueue
//
//  Overview:  end element element passed in and 
//              add it to the Queue in a stopped stade.
//
//  Arguments: pBvr - element to defer begin on
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::DeferBeginAndAddToQueue(MMBaseBvr * pBvr)
{
    long lCurIndex = 0;
    m_beingadjustedlist.push_front(pBvr);
    
    //need to check to see if this is already in the queue and if so, what it's state is.
    AddToQueue(pBvr, STOPPED);
    lCurIndex = m_pPendingList.Find(pBvr);
    if (lCurIndex != -1)
    {
        EXCL_STATE curState = m_pPendingState.Item(lCurIndex);
        if (curState == PAUSED)
        {
            if (!pBvr->IsPaused())
            {
                pBvr->Pause();
            }

            if (!pBvr->IsDisabled())
            {
                pBvr->Disable();
            }
        }
        else
        {        
            pBvr->Disable();
            pBvr->GetElement().ToggleTimeAction(false);
        }
    }

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::StopBegin
//
//  Overview:  stop an element from beginning
//
//  Arguments: pBvr - element to stop
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::StopBegin(MMBaseBvr * pBvr)
{
    long lCurBvr = m_pPendingList.Find(pBvr);
    long lSize = m_pPendingList.Size();
    m_beingadjustedlist.push_front(pBvr);
    if (lCurBvr < 0 || lCurBvr >= lSize)
    {
        pBvr->End(0.0);
    }

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::AddToQueue
//
//  Overview:  Add element to Queue in the correct order.
//
//  Arguments: pBvr - element to add
//             state - state to add element in
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::AddToQueue(MMBaseBvr * pBvr, EXCL_STATE state)
{
    bool bDone = false;
    long lCurElement = -1;

    while (lCurElement < m_pPendingList.Size()-1 && !bDone)
    {
        RELATIONSHIP rel;
        TOKEN action;
        
        lCurElement++;
        MMBaseBvr *pCurBvr = m_pPendingList.Item(lCurElement);
        GetRelationship(pBvr, pCurBvr, rel);
        switch (rel)
        {
        case HIGHER:
            //never insert before an element of higher priority.
            break;
        case PEERS:
            if (state == PAUSED)  //only insert before peers if state is paused.
            {
                bDone = true;
            }
            break;
        case LOWER:
            bDone = true;  //insert before any element of a lower priority.
            //insert here.
            break;
        }
    }
    
    if (lCurElement == -1)
    {
        lCurElement = 0;
    }
    if (bDone == true)
    {
        m_pPendingList.Insert(lCurElement, pBvr);
        m_pPendingState.InsertIndirect(lCurElement, &state);
    }
    else
    {
        m_pPendingList.Append(pBvr);
        m_pPendingState.AppendIndirect(&state, NULL);
    }
   
    RemoveDuplicates(pBvr);
}

void 
MMExcl::RemoveDuplicates(MMBaseBvr *pBvr)
{
    bool bFirstInstance = true;
    int i = 0;
    while (i < m_pPendingList.Size())
    {
        MMBaseBvr *curBvr = m_pPendingList.Item(i);

        if (curBvr == pBvr)
        {
            if (bFirstInstance)
            {
                bFirstInstance = false;
                i++;
            }
            else
            {
                m_pPendingList.DeleteItem(i);    
                m_pPendingState.DeleteItem(i);
            }
        }
        else if (curBvr == m_pPlaying)
        {
            m_pPendingList.DeleteItem(i);    
            m_pPendingState.DeleteItem(i);
        }
        else
        {
            i++;
        }
    }
}

bool 
MMExcl::UsingPriorityClasses()
{
    bool bUsingPri = false;
    int i = 0;

    for(i = 0; i < m_pbIsPriorityClass.Size(); i++)
    {
        bUsingPri |= m_pbIsPriorityClass.Item(i);
    }

    return bUsingPri;
}

bool 
MMExcl::IsPriorityClass(MMBaseBvr *pBvr)
{
    bool bIsPriClass = false;
    IHTMLElement *pEle = NULL;  //this is a weak reference and will not be released.
    CComPtr<IHTMLElement> pEleParent;
    CComPtr <IHTMLElement> pNext;
    BSTR bstrTagName = NULL;
    HRESULT hr = S_OK;
    bool bDone = false;

    pEle = pBvr->GetElement().GetElement();
    if (pEle == NULL)

    {
        bIsPriClass = false;
        goto done;
    }

    hr = THR(pEle->get_parentElement(&pEleParent));
    if (FAILED(hr))
    {
        bIsPriClass = false;
        goto done;        
    }

    while (pEleParent != NULL && bDone != true)
    {
        hr = THR(pEleParent->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            bIsPriClass = false;
            goto done;        
        }
        if (bstrTagName != NULL)
        {
            if (StrCmpIW(bstrTagName, WZ_PRIORITYCLASS_NAME) == 0)
            {
                bIsPriClass = true;
                bDone = true;
            }
            else if (StrCmpIW(bstrTagName, WZ_EXCL) == 0)
            {
                bIsPriClass = false;
                bDone = true;
            }
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
        }
        
        hr = THR(pEleParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            bIsPriClass = false;
            goto done;        
        }
        pEleParent.Release();
        pEleParent = pNext;
        pNext.Release();
     }

  done:

    if (bstrTagName)
    {
        SysFreeString(bstrTagName);
    }
    return bIsPriClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmmedia.h ===
#ifndef _MMMEDIA_H__
#define _MMMEDIA_H__

#pragma once

#include "mmtimeline.h"

class MMMedia :
    public MMTimeline
{
  public:
    MMMedia(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMMedia();

    virtual bool Init();
    virtual HRESULT Update(bool bBegin,
                           bool bEnd);

  protected:
    MMMedia();
  
  private:
};

#endif // _MMMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmmedia.cpp ===
#include "headers.h"
#include "mmmedia.h"
#include "timeelmbase.h"

#define SUPER MMTimeline

MMMedia::MMMedia(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents)
{
}

MMMedia::~MMMedia()
{
}

bool
MMMedia::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
        goto done;
    }

    ok = true;
done:
    return ok;
}    

HRESULT
MMMedia::Update(bool bBegin,
                bool bEnd)
{
    HRESULT hr = S_OK;
    LPWSTR str = NULL;

    hr = SUPER::Update(bBegin, bEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    str = m_elm.GetEndSync();
    if (NULL == str)
    {
        m_mes = MEF_MEDIA;
        IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_MEDIA));
        UpdateEndSync();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmseq.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMSEQ_H
#define _MMSEQ_H

#include "mmtimeline.h"

class MMSeq :
    public MMTimeline
{
  public:
    MMSeq(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMSeq();
    
    virtual bool Init();

    virtual bool childEventNotify(MMBaseBvr * bvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et);
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);

    virtual HRESULT prevElement();
    virtual HRESULT nextElement();
    virtual HRESULT reverse();
    virtual HRESULT load();
    virtual HRESULT begin();

    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    virtual HRESULT updateSyncArc(bool bBegin, MMBaseBvr *bvr);
    virtual HRESULT Update(bool bUpdateBegin, bool bUpdateEnd);

  protected:
      MMSeq();
      long FindBvr(MMBaseBvr *bvr);
      double GetOffset(MMBaseBvr *bvr, bool bBegin);
      bool GetEvent(MMBaseBvr *bvr, bool bBegin);
      void FindDurations();
      long GetNextElement(long lCurElement, bool bForward);
      bool IsSet(MMBaseBvr *bvr);
      void updateSyncArcs(bool bSet, bool bReset); //updates all sync arcs in the sequence
      long FindFirstDuration();
      long FindLastDuration();
      bool isLastElement(long nIndex);
      long GetPredecessorForSyncArc (long nCurr);
      
  private:

      bool                      m_bDisallowEnd;
      bool                      m_bIgnoreNextEnd;
      long                      m_lActiveElement;
      CTIMEElementBase &        m_baseTIMEEelm;
      bool                      m_bReversing;
      double                   *m_pdblChildDurations; //the duration of the child element
      bool                     *m_fMediaHasDownloaded; //flags whether the media has downloaded.  For non-media elements this will be set to true
      bool                     *m_fAddByOffset; //flags whether the element duration is by offset
      bool                      m_bLoaded;
      bool                      m_bInPrev;
};

#endif /* _MMSEQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmexcl.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMEXCL_H
#define _MMEXCL_H

#include "mmtimeline.h"

typedef enum EXCL_STATE
{
    PAUSED,
    STOPPED,
    NUM_STATES
} tag_EXCL_STATE;
    
class MMExcl :
    public MMTimeline
{
  public:
    MMExcl(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMExcl();
    
    virtual bool Init();
    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    
    virtual bool childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);

  protected:
    MMExcl();
 
  private:
    CPtrAry<MMBaseBvr *> m_pPendingList;
    CDataAry<EXCL_STATE> m_pPendingState;
    CDataAry<bool> m_pbIsPriorityClass;
    MMBaseBvr * m_pPlaying;
    CTIMEElementBase &   m_baseTIMEEelm;

    typedef enum RELATIONSHIP
    {
        HIGHER,
        PEERS,
        LOWER,
        NUM_RELATIONSHIPS
    };

    void GetRelationship(MMBaseBvr * pBvrRunning, 
                         MMBaseBvr * pBvrInterrupting, 
                         RELATIONSHIP & rel);
    bool ArePeers(IHTMLElement * pElm1, IHTMLElement * pElm2);
    bool IsHigherPriority(IHTMLElement * pElmLeft, IHTMLElement * pElmRight);

    void EndCurrent();
    void ClearQueue();
    void PauseCurrentAndAddToQueue();
    void DeferBeginAndAddToQueue(MMBaseBvr * pBvr);
    void StopBegin(MMBaseBvr * pBvr);

    void AddToQueue(MMBaseBvr * pBvr, EXCL_STATE state);

    bool IsInBeingAdjustedList(MMBaseBvr * pBvr);
    bool IsAtEndTime(MMBaseBvr *pBvr);
    void RemoveDuplicates(MMBaseBvr *pBvr);
    bool UsingPriorityClasses();
    bool IsPriorityClass(MMBaseBvr *pBvr);
    IHTMLElement *GetParentElement(IHTMLElement *pEle);
    std::list<MMBaseBvr*> m_beingadjustedlist;
};

#endif /* _MMEXCL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmseq.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmseq.h"
#include "timeelmbase.h"

DeclareTag(tagMMUTILSeq, "TIME: Behavior", "MMSeq methods")

#define SUPER MMTimeline

const double cfSmallTimeDelta = (DBL_EPSILON);
// =======================================================================
//
// MMSeq
//
// =======================================================================

MMSeq::MMSeq(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents),
    m_bDisallowEnd(false),
    m_lActiveElement(-1),
    m_baseTIMEEelm(elm),
    m_bReversing(false),
    m_pdblChildDurations(NULL),
    m_fMediaHasDownloaded(NULL),
    m_bLoaded(false),
    m_fAddByOffset(NULL),
    m_bIgnoreNextEnd(false),
    m_bInPrev(false)
{

}

MMSeq::~MMSeq()
{
    delete [] m_pdblChildDurations;
    m_pdblChildDurations = NULL;
    delete [] m_fMediaHasDownloaded;
    m_fMediaHasDownloaded = NULL;
    delete [] m_fAddByOffset;
    m_fAddByOffset = NULL;    
}


bool 
MMSeq::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
    }

    ok = true;
 done:
    return ok;
}
    

//+-----------------------------------------------------------------------
//
//  Member:    MMSeq::childEventNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving event
//             dblLocalTime - time at which the event occurred
//             et - event that occurred
//             
//  Returns:   true if event should be processed, false otherwise
//
//------------------------------------------------------------------------
bool
MMSeq::childEventNotify(MMBaseBvr * bvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    TraceTag((tagMMUTILSeq,
              "MMSeq(%p, %ls)::childEventNotify(%p, %ls): localTime = %g, event = %s",
              this,
              GetElement().GetID(),
                          bvr,
                          bvr->GetElement().GetID(),
                          dblLocalTime,
                          EventString(et)));

    bool fProcessEvent = true;
        
    fProcessEvent = SUPER::childEventNotify(bvr, dblLocalTime, et);
    if (fProcessEvent == false)
    {
        goto done;
    }

    switch(et)
    {
        case TE_EVENT_BEGIN:
        {
            
            //check that this is a valid element to be firing a begin event
            long lCurChild = FindBvr(bvr);
            long lNextChild = GetNextElement(m_lActiveElement, !m_bReversing);

            //the active element hasn't been updated yet.
            if (m_lActiveElement >= 0 && m_lActiveElement < m_children.Size()) 
            {
                MMBaseBvr *pBvr = m_children.Item(m_lActiveElement);
                if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
                {
                    pBvr->GetElement().ToggleTimeAction(false);
                }
            }
            //update the active element
            m_lActiveElement = lCurChild;
        }
            break;

        case TE_EVENT_END:
        {
    
            //check that this is a valid element to be firing an end event
            long lCurChild = FindBvr(bvr);

            if (m_bReversing)
            {
                long lPrevChild = GetNextElement(m_lActiveElement, true);
                if (m_lActiveElement != -1 && m_children.Item(m_lActiveElement)->IsActive())
                {
                    if (lCurChild != lPrevChild)
                    {
                        fProcessEvent = false;
                        goto done;
                    }
                }
                else if (lCurChild != FindFirstDuration())
                {
                    fProcessEvent = false;
                    goto done;
                }
            }
            else
            {
                long lPrevChild = m_lActiveElement;
                if (m_bInPrev)
                {
                    lPrevChild = GetNextElement(m_lActiveElement, true);
                }
                
                if (lCurChild != lPrevChild &&  lCurChild != m_lActiveElement )
                {
                    fProcessEvent = false;
                    goto done;
                }
            }

            if (m_bIgnoreNextEnd == false && m_bInPrev == false)
            {
                long lCurChild = FindBvr(bvr);
                if (isLastElement(lCurChild))
                {
                    m_lActiveElement = -1;
                }
            }
            m_bIgnoreNextEnd = false;
        }
            break;
        default:
            break;
    }


    fProcessEvent = true;

done:

    if (et == TE_EVENT_END && fProcessEvent == false)
    {
        long lCurChild = FindBvr(bvr);
        if (lCurChild != m_lActiveElement && m_lActiveElement != -1) 
        {
            MMBaseBvr *pBvr = m_children.Item(m_lActiveElement);
            if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
            {
                pBvr->GetElement().ToggleTimeAction(false);
            }
        }
    }

    return fProcessEvent;
}

bool 
MMSeq::childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et)
{
    switch (et)
    {
        case TE_ONMEDIACOMPLETE:
        {
            long lCurBvr = FindBvr(pBvr);
            if (m_fMediaHasDownloaded != NULL)
            {
                m_fMediaHasDownloaded[lCurBvr] = true;               
            }
            if (m_pdblChildDurations != NULL)
            {   
                CComPtr <ITIMEMediaElement> pMediaElm;
                double dblMediaDur = 0.0;
                HRESULT hr = S_OK;
                hr = THR(pBvr->GetElement().QueryInterface(IID_ITIMEMediaElement, (void**)&pMediaElm));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pMediaElm->get_mediaDur(&dblMediaDur));
                    if (SUCCEEDED(hr))
                    {
                        m_pdblChildDurations[lCurBvr] = dblMediaDur;
                        if (m_lActiveElement == lCurBvr && m_pdblChildDurations[lCurBvr] == HUGE_VAL)
                        {
                            //need to end this element and begin the next one.
                            m_pdblChildDurations[lCurBvr] = 0.0;
                            pBvr->GetElement().base_endElement(cfSmallTimeDelta);
                            pBvr->Reset(false);
                        }
                    }
                }
            
            }
        }
        break;
    
        case TE_ONMEDIAERROR:
        {
            long lCurBvr = FindBvr(pBvr);
            if (m_pdblChildDurations != NULL)
            {   
                if (m_pdblChildDurations[lCurBvr] == HUGE_VAL)
                {
                    m_pdblChildDurations[lCurBvr] = 0.0;
                    if (m_lActiveElement == lCurBvr)
                    {
                        //need to end this element and begin the next one.
                        pBvr->GetElement().base_endElement(cfSmallTimeDelta);
                        pBvr->Reset(false);
                    }
                }
            }
        }
        break;

        default:
            break;
    }

    return true;
}

long 
MMSeq::GetNextElement(long lCurElement, bool bForward)
{
    long lNextElement = lCurElement;
    long lNextInc = (bForward) ? 1 : -1;
    lNextElement += lNextInc;

    if (lNextElement >= m_children.Size() || lNextElement < 0)
    {
        lNextElement = -1;
    }
     
    return lNextElement;    
}

HRESULT
MMSeq::prevElement()
{
    HRESULT hr = S_OK;
    long lLength = 0;
    int i = 0;
    MMBaseBvr *bvr = NULL;

    lLength = m_children.Size();
 
    if (m_lActiveElement == -1)
    {
        goto done;
    }

    bvr = m_children.Item(m_lActiveElement);
    if (bvr == NULL)
    {
        goto done;
    }

    m_bDisallowEnd = true;
    if (m_bReversing == false)
    {
        if (bvr->IsActive())
        {
            m_bInPrev = true;
            if (m_lActiveElement == FindFirstDuration())
            {
                // If the element is locked it needs to seek the timeline to 
                // zero.  This is for bug #107744 (ie5 DB)
                if (bvr->GetElement().IsLocked() == true)
                {
                    //m_elm.GetMMBvr().Reset(false); // For bug 20073
                    m_elm.GetMMBvr().SeekSegmentTime(0.0);
                }
                else
                {
                    bvr->SeekSegmentTime(0.0);
                }
            }
            else
            {
                long lLastElement = FindLastDuration();
                double dblSimpleTime = m_baseTIMEEelm.GetMMBvr().GetSimpleTime();
                long lNextPlaying = GetNextElement(m_lActiveElement, false);
                bool m_bIgnoreNextEnd = (lLastElement == m_lActiveElement);
                Assert(lNextPlaying != -1);
                
                MMBaseBvr *pNextPlaying = m_children.Item(lNextPlaying);
                pNextPlaying->BeginAt(dblSimpleTime, 0.0);
                bvr->Reset(false);
            }    
            m_bInPrev = false;
        }
    }
    else
    {
        // ISSUE: doesn't work for autoreverse
    }

    hr = S_OK;

  done:
    m_bDisallowEnd = false;
    return hr;
}


HRESULT
MMSeq::nextElement()
{
    HRESULT hr = S_OK;
    long lLength = 0;
    int i = 0;
    MMBaseBvr *bvr = NULL;

    if (m_lActiveElement == -1)
    {
        goto done;
    }

    bvr = m_children.Item(m_lActiveElement);
    if (bvr == NULL)
    {
        goto done;
    }

    if (bvr->IsActive())
    {
        if (m_bReversing == false)
        {
            double dblSimpleTime = m_baseTIMEEelm.GetMMBvr().GetSimpleTime();
            bvr->EndAt(dblSimpleTime, 0.0);        
        }
        else
        {
            // ISSUE : Doesn't work for autoreverse.     
        }
    }

    hr = S_OK;

  done:

    return hr;
}



long 
MMSeq::FindBvr(MMBaseBvr *bvr)
{
    long i = 0;
    long lIndex = m_children.Find(bvr);

    return lIndex;
}


bool
MMSeq::GetEvent(MMBaseBvr *bvr, bool bBegin)
{

    bool bEvent = false;
    TimeValueList *tv;
    TimeValueSTLList *l;
    TimeValueSTLList::iterator iter;

    if (bBegin == true)
    {
        tv = &(bvr->GetElement().GetRealBeginValue());
    }
    else
    {
        tv = &(bvr->GetElement().GetRealEndValue());
    }
    l = &(tv->GetList());

    long x = l->size();
    if ( x <= 0)
    {
        goto done;
    }
    for (iter = l->begin(); iter != l->end(); iter++)
    {
        TimeValue *p = (*iter);
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
    
        if (p->GetEvent() != NULL)
        {
            bEvent = true;
            goto done;
        }
    }

    bEvent = false;

  done:

    return bEvent;
}

double 
MMSeq::GetOffset(MMBaseBvr *bvr, bool bBegin)
{
    double dblBeginTime = 0.0;
    TimeValueList *tv;
    TimeValueSTLList *l;
    TimeValueSTLList::iterator iter;

    if (bBegin == true)
    {
        tv = &(bvr->GetElement().GetRealBeginValue());
    }
    else
    {
        tv = &(bvr->GetElement().GetRealEndValue());
    }
    l = &(tv->GetList());

    long x = l->size();
    if ( x <= 0)
    {
        goto done;
    }
    for (iter = l->begin(); iter != l->end(); iter++)
    {
        TimeValue *p = (*iter);
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
    
        if (p->GetEvent() == NULL)
        {
            Assert(p->GetElement() == NULL);
            dblBeginTime = dblOffset;
            goto done;
        }
    }

    dblBeginTime = 0.0;

  done:

    return dblBeginTime;
}

HRESULT 
MMSeq::reverse()
{
    m_bReversing = !m_bReversing;
    m_lActiveElement = -1; 
    return S_OK;
}


HRESULT 
MMSeq::begin()
{
    if (!m_bLoaded)  //this handles the case of being dynamically added to the page
    {
        load();
    }
    m_baseTIMEEelm.GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
    return S_OK;
}



HRESULT
MMSeq::AddBehavior(MMBaseBvr & bvr)
{
    bool ok = false;
    CComPtr <IUnknown> pUnk;
    CComPtr <IDispatch> pChildColDisp;
    CComPtr <IHTMLElementCollection> pChildCol;    
    VARIANT vName, vIndex, vClass;
    CComBSTR bstrClassName = L"classname";
    CComBSTR bstrClass = L"class";
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    long lChildCount = 0;
    bool bInserted = false;
    bool *fMediaHasDownloaded = NULL;
    bool bAppended = false;

    CTIMEElementBase *pelm = NULL;

    fMediaHasDownloaded = NEW bool [m_children.Size() + 1];
    if (fMediaHasDownloaded == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ZeroMemory(fMediaHasDownloaded, sizeof(bool) * (m_children.Size() + 1));

    VariantInit(&vClass);
    VariantInit(&vName);
    VariantInit(&vIndex);
    vName.vt = VT_I4;
    vName.lVal = 0;

    pelm = &bvr.GetElement();

    // Make sure that my element is the parent of the element
    Assert(pelm->GetParent() == &GetElement());

    UpdateChild(bvr);
    
    hr = THR(m_timeline->addNode(bvr.GetMMBvr()));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the IUnknown of the element that this behavior is attached to.
    hr = THR(pelm->GetElement()->QueryInterface(IID_IUnknown, (void **) &pUnk));
    if (FAILED(hr))
    {
        goto done;
    }   

    //get all of the html children of this element.
    hr = GetElement().GetElement()->get_children(&pChildColDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildColDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pChildCol);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildCol->get_length(&lChildCount);
    if (FAILED(hr))
    {
        goto done;
    }

    //get the collection of all top level time children of this element.
    i = 0;
    j = 0;
    while (i < lChildCount)
    {
        CComPtr <IDispatch> pChildDisp;
        CComPtr <IHTMLElement> pChild;      
        CComPtr <ITIMEElement> pTimeElement;  
        
        vName.lVal = i;
    
        hr = pChildCol->item(vName, vIndex, &pChildDisp);
        if (FAILED(hr) || pChildDisp == NULL)
        {
            continue;
        }


        hr = FindBehaviorInterface(m_baseTIMEEelm.GetBehaviorName(),
                                   pChildDisp,
                                   IID_ITIMEElement,
                                   (void**)&pTimeElement);
        if (FAILED(hr))
        {
            CComPtr <IHTMLElement> pChildEle;

            hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void **)&pChildEle));
            if (SUCCEEDED(hr))
            {
                hr = pChildEle->getAttribute(bstrClassName, 0, &vClass);
                if (SUCCEEDED(hr))
                {
                    if ((vClass.vt == VT_BSTR) && (vClass.bstrVal != NULL) && StrCmpIW(vClass.bstrVal, L"time") == 0)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                        VariantClear(&vClass);
                        hr = pChildEle->getAttribute(bstrClass, 0, &vClass);
                        if (SUCCEEDED(hr))
                        {
                            if ((vClass.vt == VT_BSTR) && (vClass.bstrVal != NULL) && StrCmpIW(vClass.bstrVal, L"time") == 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CComPtr <IUnknown> pTimeChildUnk;

            hr = THR(pChildDisp->QueryInterface(IID_IUnknown, (void**)&pTimeChildUnk));
            if (SUCCEEDED(hr))
            {
                if (pUnk == pTimeChildUnk)
                {
                    if (j < m_children.Size())
                    {
                        hr = THR(m_children.Insert(j, &bvr));
                    }
                    else
                    {
                        hr = THR(m_children.Append(&bvr));
                        m_bIgnoreNextEnd = true;
                        bAppended = true;
                    }
                    bInserted = true;
                    break;
                }
            }
            j++;
        }
        i++;
    }

    if (m_fMediaHasDownloaded != NULL)
    {
        for (i = 0; i < m_children.Size(); i++)
        {
            if (i == j)
                fMediaHasDownloaded[i] = false;
            if (i > j)
            {
                fMediaHasDownloaded[i] = m_fMediaHasDownloaded[i - 1];
            }
            else
            {
                fMediaHasDownloaded[i] = m_fMediaHasDownloaded[i];
            }
        }
        delete [] m_fMediaHasDownloaded;
        m_fMediaHasDownloaded = fMediaHasDownloaded;
        fMediaHasDownloaded = NULL;
    }
    else
    {
        m_fMediaHasDownloaded = fMediaHasDownloaded;
        fMediaHasDownloaded = NULL;
    }

    if (!bInserted)
    {
        hr = THR(m_children.Append(&bvr));
        bAppended = true;
    }
    
    
    if (m_bLoaded == true) //adding a behavior at runtime
    {
        m_bDisallowEnd = true;
        FindDurations();    
        updateSyncArcs(false, false); //clear the syncArcs
        updateSyncArcs(true, true); //reset the syncArcs
        m_bDisallowEnd = false;
    }

    hr = S_OK;
  done:

    VariantClear(&vName);
    VariantClear(&vIndex);
    VariantClear(&vClass);
    
    if (FAILED(hr))
    {
        RemoveBehavior(bvr);
    }
    
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMSeq::childPropNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving notification
//             tePropType - type of notification occurring
//
//  Returns:   true if element should process notification, otherwise false
//
//------------------------------------------------------------------------
bool
MMSeq::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    Assert(NULL != pBvr);

    bool fProcessNotify = true;
    DWORD dwTemp = *tePropType & TE_PROPERTY_ISON;

    if (dwTemp == TE_PROPERTY_ISON)
    {
        if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
        {
            *tePropType = *tePropType - TE_PROPERTY_ISON;
        }
    }

    if (!SUPER::childPropNotify(pBvr, tePropType))
    {
        fProcessNotify = false;
        goto done;
    }

    fProcessNotify = true;
done:
    return fProcessNotify;
}


void 
MMSeq::FindDurations()
{
    long lLength = m_children.Size();
    long i = 0;

    delete [] m_pdblChildDurations;
    m_pdblChildDurations = NULL;

    delete [] m_fAddByOffset;
    m_fAddByOffset = NULL;

    m_pdblChildDurations = NEW double [lLength];
    if (m_pdblChildDurations == NULL)
    {
        goto done; //out of memory.
    }
    ZeroMemory(m_pdblChildDurations, sizeof(double) * lLength);

    
    m_fAddByOffset = NEW bool [lLength];
    if (m_fAddByOffset == NULL)
    {
        goto done; //out of memory.
    }
    ZeroMemory(m_fAddByOffset, sizeof(bool) * lLength);

    for (i = 0; i < lLength; i++)
    {
        MMBaseBvr *pBvr = m_children.Item(i);

        if (pBvr == NULL)
        {
            m_pdblChildDurations[i] = 0.0;
            continue;
        }

        m_pdblChildDurations[i] = pBvr->GetActiveDur();

        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            m_pdblChildDurations[i] = pBvr->GetActiveEndTime();
        }
        else if (m_pdblChildDurations[i] == 0.0)
        {
            CTIMEElementBase & elm = pBvr->GetElement();
            // need to check for dur and repeatdur properties.
            if (elm.GetEndAttr().IsSet() == true && 
                (elm.GetDurAttr().IsSet() == false ||
                 elm.GetDuration() == 0.0))
            {
                m_pdblChildDurations[i] = pBvr->GetActiveEndTime();
            }
        }

              
        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            double dblEndOffset = GetOffset(pBvr, false);
            if (dblEndOffset != 0.0)
            {
                m_pdblChildDurations[i] = dblEndOffset;
            }
        }
        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            HRESULT hr = S_OK;
            CComPtr <ITIMEMediaElement> pMediaElm;
            CTIMEElementBase & elm = pBvr->GetElement();

            // need to check for dur and repeatdur properties.
            if (elm.GetRepeatDur() == valueNotSet && 
                (elm.GetDuration() == valueNotSet ||
                 elm.GetDuration() == HUGE_VAL))
            {
                // need to check if this is a media element
                hr = elm.QueryInterface(IID_ITIMEMediaElement, (void **)&pMediaElm);
                if (FAILED(hr)) 
                {
                    // this is not a media element 
                    //m_pdblChildDurations[i] = 0.0;
                    m_fMediaHasDownloaded[i] = true;
                }
                else
                {
                    double dblMediaDur = 0.0;
                    hr = THR(pMediaElm->get_mediaDur(&dblMediaDur));
                    if (SUCCEEDED(hr) && dblMediaDur != -1)
                    {   
                        m_pdblChildDurations[i] = dblMediaDur;
                        m_fMediaHasDownloaded[i] = true;
                    }
                }
            }
        }

        if (m_pdblChildDurations[i] == HUGE_VAL && m_fMediaHasDownloaded[i] == true)
        {   //need to check for an end event.
            bool bHasEnd = GetEvent(pBvr, false);
            if (bHasEnd == false && GetElement().IsGroup() == false)
            {
                m_pdblChildDurations[i] = -1.0;
            }
        }

        if (m_pdblChildDurations[i] == -1.0)
        {
            
            if (i+1 < m_children.Size())
            {
                MMBaseBvr *pNextBvr = m_children.Item(i+1);
                double dblOffset = GetOffset(pNextBvr, true);
                if (dblOffset > 0.0)
                {
                    m_pdblChildDurations[i] = dblOffset;
                    m_fAddByOffset[i] = true;
                }
            }
        }
        if (m_pdblChildDurations[i] == 0.0 && pBvr->GetElement().IsGroup())
        {
            m_pdblChildDurations[i] = HUGE_VAL;
        }
        if (i == m_children.Size() - 1 && m_pdblChildDurations[i] == 0.0)
        {
            MMBaseBvr *pChildBvr = m_children.Item(i);
            TOKEN tFill = pChildBvr->GetElement().GetFill();

            // We do not have an easy way of 
            // determining what the proper duration
            // of a child with a transition fill
            // value is.  It may be latched to 
            // a transition living completely
            // outside this container.  It's 
            // also possible that the transition
            // has not even been added to the graph 
            // at all yet.
            if (   (tFill == HOLD_TOKEN)
                || (tFill == TRANSITION_TOKEN))
            {
                m_pdblChildDurations[i] = HUGE_VAL;
            }
        }
    }

  done:

    return;
}


void 
MMSeq::RemoveBehavior(MMBaseBvr & bvr)
{
    if (bvr.IsActive() == true)
    {
        nextElement();
    }

    SUPER::RemoveBehavior(bvr);

    updateSyncArcs(false, false);
    updateSyncArcs(true, true);

}

HRESULT
MMSeq::load()
{
    HRESULT hr = S_OK;

    if (!m_bLoaded)
    {
        m_bLoaded = true;
        FindDurations();    
        updateSyncArcs(true, true);
    }
    return hr;
}

bool 
MMSeq::isLastElement(long nIndex)
{
    long lIndex = 0;
    long lNextChild = 0;
    bool bFirst = true;
    bool bMatch = false;
     
    while (lNextChild != -1) //loop to find the last valid child in the sequence
    {
        lNextChild = GetNextElement(lNextChild, true); 
        if (lNextChild != -1)
        {
            bFirst = false;
            lIndex = lNextChild;
        }
    }
    if (bFirst && m_pdblChildDurations[0] != 0.0)
    {
        lIndex = 0;
    }

    if (lIndex == nIndex)
    {
        bMatch = true;
    }

    return bMatch;
}

void 
MMSeq::updateSyncArcs(bool bSet, bool bReset)
{
    long lSize = m_children.Size();
    for(int i = 0; i < lSize; i++)
    {
        MMBaseBvr *pBvr = m_children.Item(i);

        Assert(NULL != pBvr);
        if (bSet && (pBvr->GetEnabled())) 
        {
            updateSyncArc(true, pBvr);
        }
        else //clear
        {
            pBvr->ClearSyncArcs(true);
            pBvr->ClearSyncArcs(false);
        }
        if (bReset == true)
        {
            pBvr->Reset(false);
        }
    }
}

long 
MMSeq::FindFirstDuration()
{
    bool bFirst = false;
    int i = 0;

    while (i < m_children.Size() && bFirst == false)
    {
        //if this has a duration of has not downloaded media then it is the first duration.
        if ((m_pdblChildDurations[i] != 0.0) || 
            ((m_fMediaHasDownloaded[i] == false) && (m_pdblChildDurations[i] == HUGE_VAL)))
        {
             bFirst = true;
        }
        else
        {
            i++;
        }
    }

    if (i == m_children.Size())
    {
         i = -1;
    }

    return i;
}

long 
MMSeq::FindLastDuration()
{
    bool bLast = false;
    int i = m_children.Size() - 1;

    while (i >= 0 && bLast == false)
    {
        //if this has a duration of has not downloaded media then it is the first duration.
        if ((m_pdblChildDurations[i] != 0.0) || 
            ((m_fMediaHasDownloaded[i] == false) && (m_pdblChildDurations[i] == HUGE_VAL)))
        {
             bLast = true;
        }
        else
        {
            i--;
        }
    }

    return i;
}

long
MMSeq::GetPredecessorForSyncArc (long nCurr)
{
    long lPrev = nCurr;
    MMBaseBvr *pmmbvrPrev = NULL;

    do
    {
        lPrev = GetNextElement(lPrev, false);
        if (lPrev < 0)
        {
            break;
        }
        pmmbvrPrev = m_children.Item(lPrev);
        if (NULL == pmmbvrPrev)
        {
            lPrev = -1;
            break;
        }
    } while (!pmmbvrPrev->GetEnabled());

    return lPrev;
}

HRESULT 
MMSeq::updateSyncArc(bool bBegin, MMBaseBvr *pBvr)
{
    TE_TIMEPOINT tetp;
    MMBaseBvr * pmmbvr = NULL;
    double dblOffset = 0.0;
    HRESULT hr = S_OK;  

    
    // get index of current child from parent
    int nIndex = FindBvr(pBvr);
    //get the element behind the current element
    long lNext = GetPredecessorForSyncArc(nIndex); 

    if (m_pdblChildDurations == NULL || m_fAddByOffset == NULL)
    {
        goto done;
    }
    // It better have been in the list
    if (nIndex == -1)
    {
        goto done;
    }
    
    dblOffset = GetOffset(pBvr, true);

    if (   (nIndex == 0)
        || (-1 == lNext))
    {
        tetp = TE_TIMEPOINT_NONE;
        pmmbvr = NULL;
    }
    else
    {
        tetp = TE_TIMEPOINT_END;
        
        if (lNext >= 0)
        {
            if (m_fAddByOffset[lNext] == true)
            {
                if (m_pdblChildDurations[lNext] != 0.0)
                {
                    dblOffset = cfSmallTimeDelta;
                }
            }
        }
        pmmbvr = m_children.Item(lNext);

        if (dblOffset == 0.0)
        {
            dblOffset = cfSmallTimeDelta;
        }
    }

    pBvr->AddOneTimeValue(pmmbvr,
                          tetp,
                          dblOffset,
                          true);

    //if this is beginning because of an offset then set it's end point to be
    //it's begin point + it's duration
    if (m_fAddByOffset[nIndex] == true && m_pdblChildDurations[nIndex] != 0.0) 
    {                                   
        pBvr->AddOneTimeValue(pBvr,
                              TE_TIMEPOINT_BEGIN,
                              m_pdblChildDurations[nIndex] ,
                              false);
    }
    else if (m_fAddByOffset[nIndex] == true && m_pdblChildDurations[nIndex] == 0.0) 
    {
        pBvr->AddOneTimeValue(pBvr,
                              TE_TIMEPOINT_BEGIN,
                              cfSmallTimeDelta,
                              false);

    }
    else if (m_pdblChildDurations[nIndex] == 0.0 )
    {   
        if (!(FindFirstDuration() == -1 && nIndex == m_children.Size() - 1))
        {
            //pBvr->SetZeroRepeatDur(true);
            pBvr->Update(false, true);
        }
        else if (nIndex == m_children.Size() - 1)
        {
            pBvr->AddOneTimeValue(pBvr,
                                  TE_TIMEPOINT_BEGIN,
                                  cfSmallTimeDelta,
                                 false);
        }
    }


  done:
    return hr;
}


HRESULT
MMSeq::Update(bool bUpdateBegin,
              bool bUpdateEnd)
{
    HRESULT hr = S_OK;
    TE_ENDSYNC endSync = TE_ENDSYNC_LAST;
    m_mes = MEF_ALL;

    // First turn it off, then update the children, and then add back
    // the new value
    
    IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_NONE));

    UpdateEndSync();
    
    IGNORE_HR(m_timeline->put_endSync(endSync));

    hr = THR(MMBaseBvr::Update(bUpdateBegin, bUpdateEnd));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmtimeline.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmtimeline.h"
#include "timeelm.h"

#include "mmplayer.h"

DeclareTag(tagMMUTILTimeline, "TIME: Behavior", "MMTimeline methods")


// =======================================================================
//
// MMTimeline
//
// =======================================================================

MMTimeline::MMTimeline(CTIMEElementBase & elm, bool bFireEvents)
: MMBaseBvr(elm,bFireEvents),
  m_player(NULL),
  m_mes(MEF_NONE)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::MMTimeline(%p,%d,%d)",
              this,
              &elm,
              bFireEvents,
              m_mes));
}

MMTimeline::~MMTimeline()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::~MMTimeline()",
              this));
    if (m_player != NULL)
    {
        m_player->ClearTimeline();
        m_player = NULL;
    }
}

bool
MMTimeline::Init()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Init()",
              this));

    bool ok = false;
    HRESULT hr;
    DAComPtr<ITIMENode> tn;
    
    hr = THR(TECreateTimeline(m_elm.GetID(), &m_timeline));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(m_timeline->QueryInterface(IID_ITIMENode,
                                        (void **) &tn));
    
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    if (!MMBaseBvr::Init(tn))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

HRESULT
MMTimeline::AddBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::AddBehavior(%p)",
              this,
              &bvr));

    bool ok = false;
    HRESULT hr;

    CTIMEElementBase *pelm = &bvr.GetElement();

    // Make sure that my element is the parent of the element
    Assert(pelm->GetParent() == &GetElement());

    UpdateChild(bvr);
    
    hr = THR(m_timeline->addNode(bvr.GetMMBvr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_children.Append(&bvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        RemoveBehavior(bvr);
    }
    
    RRETURN(hr);
}

void
MMTimeline::RemoveBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::RemoveBehavior(%p)",
              this,
              &bvr));

    if (bvr.GetMMBvr())
    {
        m_timeline->removeNode(bvr.GetMMBvr());
    }

    m_children.DeleteByValue(&bvr);
}

void
MMTimeline::Clear()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Clear()",
              this));

    // TODO: Need to flesh this out
}

void
MMTimeline::UpdateEndSync()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::UpdateEndSync()",
              this));

    MMBaseBvr **ppBvr;
    int i;

    for (i = m_children.Size(), ppBvr = m_children;
         i > 0;
         i--, ppBvr++)
    {
        UpdateChild(**ppBvr);
    }
}
    
void
MMTimeline::UpdateChild(MMBaseBvr & pChild)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::UpdateChild(%p)",
              this,
              &pChild));

    bool bSet = false;
    
    switch (m_mes)
    {
      default:
        AssertStr(false, "Invalid endsync value in MMTimeline");
      case MEF_MEDIA:
      case MEF_NONE:
        bSet = false;
        break;
      case MEF_ALL:
        bSet = true;
        break;
      case MEF_ID:
        {
            LPCWSTR str = m_elm.GetEndSync();
            LPCWSTR id = pChild.GetElement().GetID();

            bSet = (str != NULL &&
                    id != NULL &&
                    StrCmpIW(str, id) == 0);
        }
        break;
    }

    pChild.SetEndSync(bSet);
}

HRESULT
MMTimeline::Update(bool bUpdateBegin,
                   bool bUpdateEnd)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Update(%d, %d)",
              this,
              bUpdateBegin,
              bUpdateEnd));

    HRESULT hr;
        
    // Now update the timeline properties

    // Handle endsync
    LPOLESTR str = m_elm.GetEndSync();
    TE_ENDSYNC endSync = TE_ENDSYNC_LAST;
    
    if (str == NULL)
    {
        if (m_elm.IsBody())
        {
            endSync = TE_ENDSYNC_NONE;
            m_mes = MEF_NONE;
        }
        else
        {
            endSync = TE_ENDSYNC_LAST;
            m_mes = MEF_ALL;
        }
    }
    else if (StrCmpIW(str, WZ_LAST) == 0)
    {
        endSync = TE_ENDSYNC_LAST;
        m_mes = MEF_ALL;
    }
    else if (StrCmpIW(str, WZ_NONE) == 0)
    {
        endSync = TE_ENDSYNC_NONE;
        m_mes = MEF_NONE;
    }
    else if (StrCmpIW(str, WZ_FIRST) == 0)
    {
        endSync = TE_ENDSYNC_FIRST;
        m_mes = MEF_ALL;
    }
    else if (StrCmpIW(str, WZ_ALL) == 0)
    {
        endSync = TE_ENDSYNC_ALL;
        m_mes = MEF_ALL;
    }
    else
    {
        endSync = TE_ENDSYNC_FIRST;
        m_mes = MEF_ID;
    }

    // First turn it off, then update the children, and then add back
    // the new value
    
    IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_NONE));

    UpdateEndSync();
    
    IGNORE_HR(m_timeline->put_endSync(endSync));

    hr = THR(MMBaseBvr::Update(bUpdateBegin, bUpdateEnd));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

bool
MMTimeline::childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    Assert(NULL != pBvr);

    bool fProcessEvent = false;

    fProcessEvent = true;
done:
    return fProcessEvent;
}

bool 
MMTimeline::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    return m_elm.ChildPropNotify(pBvr->GetElement(),
                                 *tePropType);
}

HRESULT 
MMTimeline::toggleTimeAction(bool bOn)
{
    if (!bOn)
    {
        int i = 0;
        while (i < m_children.Size())
        {
            MMBaseBvr *pBvr = m_children.Item(i);
            pBvr->GetElement().ToggleTimeAction(bOn);
            i++;
        }    
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmutil.h"

class CTIMEBodyElement;

class MMPlayer
    : public ClockSink
{
  public:
    MMPlayer(CTIMEBodyElement & elm);
    ~MMPlayer();
    
    bool Init(MMTimeline & tl);
    void Deinit();

    bool Play();
    bool Stop();
    bool Pause();
    bool Resume();
    bool Tick(double gTime);
    // This forces one tick, so updates will be drawn even 
    // when the clock and player are paused (used for editing)
    bool TickOnceWhenPaused(void);
    
    inline HRESULT AddBehavior(MMBaseBvr & bvr)
    { return m_timeline->AddBehavior(bvr); }
    inline void RemoveBehavior(MMBaseBvr & bvr)
    { m_timeline->RemoveBehavior(bvr); }

    inline void Clear()
    { m_timeline->Clear(); }
    
    inline HRESULT Update(bool bBegin,
                          bool bEnd)
    { return m_timeline->Update(bBegin, bEnd); }
    
    ITIMENodeMgr * GetMMPlayer()
    { return m_player; }
    MMTimeline & GetTimeline()
    { return *m_timeline; }

    double GetCurrentTime()
    { if (m_clock) return m_clock->GetCurrentTime(); else return 0; }

    void ClearTimeline()
    { m_timeline = NULL; }

    void OnTimer(double time);

  protected:
    CTIMEBodyElement & m_elm;
    bool m_fReleased;
    MMTimeline * m_timeline;
    CComPtr<ITIMENodeMgr> m_player;
    Clock                 *m_clock;
    MMPlayer();
};

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmtimeline.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmutil.h"
#include "eventmgr.h"

class MMTimeline :
    public MMBaseBvr
{
  public:
    MMTimeline(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMTimeline();
    
    virtual bool Init();
    
    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    virtual void Clear();
    
    virtual HRESULT Update(bool bBegin,
                           bool bEnd);

    virtual bool childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et) 
        { return true; };
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);
    
    ITIMEContainer * GetMMTimeline()
    { return m_timeline; }
    void put_Player(MMPlayer *player)
    { m_player = player; }

    virtual HRESULT prevElement() 
        { return E_NOTIMPL; };
    virtual HRESULT nextElement() 
        { return E_NOTIMPL; };
    virtual HRESULT begin() 
        { return S_OK; };
    virtual HRESULT reverse() 
        { return S_OK; };
    virtual HRESULT end()
        { return S_OK; };
    virtual HRESULT seek(double dblTime)
        { return S_OK; };
    virtual HRESULT repeat()
        { return S_OK; };
    virtual HRESULT load()
        { return S_OK; };
    virtual HRESULT toggleTimeAction(bool bOn);
    virtual HRESULT updateSyncArc(bool bBegin, MMBaseBvr *bvr)
        { return S_OK; };

  protected:
    CComPtr<ITIMEContainer> m_timeline;

    // These are the children we have already added because we found
    // their base
    CPtrAry<MMBaseBvr *> m_children;

    enum MM_ENDSYNC_FLAGS
    {
        MEF_NONE  = 0,
        MEF_ALL   = 1,
        MEF_ID    = 2,
        MEF_MEDIA = 3,
    };
    
    MM_ENDSYNC_FLAGS m_mes;
    
    void UpdateEndSync();
    
    virtual void UpdateChild(MMBaseBvr &);
    
  private:
     MMPlayer * m_player;
  protected:
      MMTimeline();
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\mmutil.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmutil.h"
#include "timeelm.h"
#include "..\tags\bodyelm.h"

DeclareTag(tagMMUTILBvr, "TIME: Behavior", "MMBvr methods")
DeclareTag(tagMMUTILBaseBvr, "TIME: Behavior", "MMBaseBvr methods")
DeclareTag(tagMMUTILPlayer, "TIME: Behavior", "MMPlayer methods")
DeclareTag(tagMMUTILEvents, "TIME: Behavior", "MMBaseBvr Events")

MMBaseBvr::MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents)
: m_elm(elm),
#if DBG
  m_id(NULL),
#endif //DBG
  m_bFireEvents(bFireEvents),
  m_bEnabled(true),
  m_bZeroRepeatDur(false)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::MMBaseBvr(%p,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBaseBvr::~MMBaseBvr()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::~MMBaseBvr()",
              this));

    if (m_teb)
    {
        m_teb->SetMMBvr(NULL);
        m_bvr->removeBehavior((ITIMENodeBehavior *) m_teb);
        m_teb.Release();
    }

    ClearSyncArcs(true);
    ClearSyncArcs(false);
#if DBG
    if (NULL != m_id)
    {
        delete[] m_id;
        m_id = NULL;
    }
#endif //DBG
}

bool
MMBaseBvr::Init(ITIMENode * node)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Init(%p)",
              this,
              node));

    bool ok = false;
    HRESULT hr;
    
    Assert(node != NULL);
    
    m_bvr = node;

#if DBG
    if (NULL != m_elm.GetID())
    {
        m_id = CopyString(m_elm.GetID());
        if (NULL == m_id)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
#endif DBG

    if (m_bFireEvents)
    {
        m_teb = NEW TEBvr;
        
        if (!m_teb)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        m_teb->SetMMBvr(this);

        hr = THR(m_bvr->addBehavior((ITIMENodeBehavior *) m_teb));
        if (FAILED(hr))
        {
            TIMESetLastError(hr, NULL);
            goto done;
        }
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_teb.Release();
        m_bvr.Release();
    }
    
    return ok;
}

HRESULT
MMBaseBvr::Begin(double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Begin(%g)",
              this,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        double dblParentTime = GetCurrParentTime();
    
        hr = THR(m_bvr->beginAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Reset(bool bLightweight)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Reset(%d)",
              this,
              bLightweight));

    HRESULT hr;

    if (bLightweight)
    {
        hr = THR(m_bvr->update(0));
    }
    else
    {
        hr = THR(m_bvr->reset());
    }

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::End(double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::End(%g)",
              this,
              dblOffset));

    HRESULT hr;
    
    if (m_bvr)
    {
        double dblParentTime = GetCurrParentTime();
    
        hr = THR(m_bvr->endAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Pause()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Pause()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->pause());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Resume()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Resume()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->resume());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Disable()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Disable()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->disable());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Enable()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Enable()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->enable());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekSegmentTime(double dblSegmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekSegmentTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekSegmentTime(dblSegmentTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekActiveTime(double dblActiveTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekActiveTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekActiveTime(dblActiveTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekTo(long lRepeatCount, double dblSegmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekTo(%ld, %g)",
              this,
              lRepeatCount,
              dblSegmentTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekTo(lRepeatCount, dblSegmentTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetActiveTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currActiveTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetProgress() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetProgress()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currProgress(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSegmentDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSegmentDur(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSegmentTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSegmentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetSimpleDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSimpleDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSimpleDur(&d));
    }

    return d;
}

double
MMBaseBvr::GetSimpleTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSimpleTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSimpleTime(&d));
    }

    return d;
}

LONG
MMBaseBvr::GetCurrentRepeatCount() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetCurrentRepeatCount()",
              this));

    LONG l = 1;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currRepeatCount(&l));
    }

    return l;
}

double
MMBaseBvr::GetRepeatCount() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetRepeatCount()",
              this));

    double d = 1;
    
    if (m_bvr)
    {
        THR(m_bvr->get_repeatCount(&d));
    }

    return d;
}

double
MMBaseBvr::GetRepeatDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetRepeatDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_repeatDur(&d));
    }

    return d;
}

float 
MMBaseBvr::GetSpeed() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSpeed()",
              this));

    float fl = 1.0f;
    
    if (m_bvr)
    {
        THR(m_bvr->get_speed(&fl));
    }

    return fl;
}

float 
MMBaseBvr::GetCurrSpeed() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSpeed()",
              this));

    float fl = 1.0f;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSpeed(&fl));
    }

    return fl;
}

double
MMBaseBvr::GetActiveBeginTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveBeginTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_beginParentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetActiveEndTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveEndTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_endParentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetActiveDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveDur()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_activeDur(&d));

        if (d == TIME_INFINITE)
        {
            double dbTime = valueNotSet;
            HRESULT hr = THR(m_bvr->get_naturalDur(&dbTime));
            if (SUCCEEDED(hr) && dbTime != valueNotSet)
            {
                d = dbTime;
            }
        }
    }

    return d;
}


TE_STATE
MMBaseBvr::GetPlayState() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetPlayState()",
              this));

    TE_STATE s = TE_STATE_INACTIVE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_stateFlags(&s));
    }

    return s;
}

HRESULT
MMBaseBvr::BeginAt(double dblParentTime, double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::BeginAt(%g, %g)",
              this,
              dblParentTime,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        hr = THR(m_bvr->beginAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::EndAt(double dblParentTime, double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::EndAt(%g, %g)",
              this,
              dblParentTime,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        hr = THR(m_bvr->endAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetCurrParentTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetCurrParentTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currParentTime(&d));
    }

    return d;
}

void
MMBaseBvr::AddOneTimeValue(MMBaseBvr * pmmbvr,
                           TE_TIMEPOINT tetp,
                           double dblOffset,
                           bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::AddOneTimeValue(%p, %d, %g, %d)",
              this,
              pmmbvr,
              tetp,
              dblOffset,
              bBegin));

    HRESULT hr;
    
    if (tetp == TE_TIMEPOINT_NONE)
    {
        if (bBegin)
        {
            IGNORE_HR(m_bvr->addBegin(dblOffset, NULL));
        }
        else
        {
            IGNORE_HR(m_bvr->addEnd(dblOffset, NULL));
        }
    }
    else
    {
        LONG lCookie;
        ITIMENode * ptn = pmmbvr->GetMMBvr();
        
        if (bBegin)
        {
            hr = THR(m_bvr->addBeginSyncArc(ptn,
                                            tetp,
                                            dblOffset,
                                            &lCookie));

            if (SUCCEEDED(hr))
            {
                // @@ ISSUE : This does not detect memory failures (bug 14217, ie6)
                m_cmBegin.insert(CookieMap::value_type(&pmmbvr->GetElement(), lCookie));
            }
        }
        else
        {
            hr = THR(m_bvr->addEndSyncArc(ptn,
                                          tetp,
                                          dblOffset,
                                          &lCookie));

            if (SUCCEEDED(hr))
            {
                // @@ ISSUE : This does not detect memory failures (bug 14217, ie6)
                m_cmEnd.insert(CookieMap::value_type(&pmmbvr->GetElement(), lCookie));
            }
        }
    }
    
  done:
    return;
}

void
MMBaseBvr::AddSyncArcs(bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::AddSyncArcs(%d)",
              this,
              bBegin));

    
    CTIMEElementBase * ptebParent = GetElement().GetParent();
    TimelineType tt = ptebParent?ptebParent->GetTimeContainer():ttPar;
    
    TimeValueList & tvl = bBegin?GetElement().GetRealBeginValue():GetElement().GetRealEndValue();
    TimeValueSTLList & l = tvl.GetList();
    long lBeginAddCount = 0;
    TimeValueSTLList::iterator iter;
    bool bHaveEvent = false;
    bool bHaveIndefinite = false;
    
    ClearSyncArcs(bBegin);
    
    if (l.size() == 0)
    {
        if (bBegin)
        {
            switch(tt)
            {
              case ttPar:
              //case ttExcl:
                AddOneTimeValue(NULL,
                                TE_TIMEPOINT_NONE,
                                0.0,
                                true);
                break;
              case ttSeq:
                {
                    ptebParent->GetMMTimeline()->updateSyncArc(bBegin, this);
                }
                break;

              default:
                break;
            }
        }
        
        goto done;
    }
    
    for (iter = l.begin();
         iter != l.end();
         iter++)
    {
        TimeValue *p = (*iter);

        TE_TIMEPOINT tetp = TE_TIMEPOINT_NONE;
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
        
        if (p->GetEvent() == NULL)
        {
            Assert(p->GetElement() == NULL);
            
            tetp = TE_TIMEPOINT_NONE;

            if (dblOffset == TIME_INFINITE)
            {
                bHaveIndefinite = true;
            }
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) == 0)
        {
            //if there is no element associated with this event then do not add it.
            if (p->GetElement() == NULL)
            {
                continue;
            }
            tetp = TE_TIMEPOINT_BEGIN;
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) == 0)
        {
            //if there is no element associated with this event then do not add it.
            if (p->GetElement() == NULL)
            {
                continue;
            }
            tetp = TE_TIMEPOINT_END;
        }
        else
        {
            // This was an event and not a sync arc - set flag and continue

            bHaveEvent = true;
            continue;
        }

        if (tt == ttSeq && bBegin)
        {
            continue;
        }
        else
        {
            if (p->GetElement() != NULL)
            {
                if (GetElement().GetBody() == NULL)
                {
                    continue;
                }
                
                // TODO: We should return all the ids which match the
                // sync arc since dynamically added elements add any duplicates
                CTIMEElementBase * pteb = GetElement().GetBody()->FindID(p->GetElement());
                
                if (pteb == NULL)
                {
                    // Simply ignore and move on
                    continue;
                }

                pmmbvr = &pteb->GetMMBvr();
            }
            else
            {
                pmmbvr = this;
            }
        
            Assert(pmmbvr != NULL);
        }

        AddOneTimeValue(pmmbvr,
                        tetp,
                        dblOffset,
                        bBegin);
    }    

    // If there are events and no indefinite was added then we need to
    // make sure we add an indefinite ourselves
    // We only need to do this for end since begin will be unaffected
    if (!bBegin && bHaveEvent && !bHaveIndefinite)
    {
        AddOneTimeValue(NULL,
                        TE_TIMEPOINT_NONE,
                        TIME_INFINITE,
                        bBegin);
    }

  done:
    return;
}

void
MMBaseBvr::ClearSyncArcs(bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::ClearSyncArcs(%d)",
              this,
              bBegin));

    if (bBegin)
    {
        m_bvr->removeBegin(0);
        m_cmBegin.clear();
    }
    else
    {
        m_bvr->removeEnd(0);
        m_cmEnd.clear();
    }
}

HRESULT
MMBaseBvr::Update(bool bUpdateBegin,
                  bool bUpdateEnd)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::Update(%d, %d)",
              this,
              bUpdateBegin,
              bUpdateEnd));

    HRESULT hr;
    double d;
    
    if (m_bEnabled == false)
    {
        ClearSyncArcs(true);
        ClearSyncArcs(false);
    
        
        TE_TIMEPOINT tetp = TE_TIMEPOINT_NONE;
        double dblOffset = INDEFINITE;
        MMBaseBvr * pmmbvr = this;

        AddOneTimeValue(pmmbvr,
                        tetp,
                        dblOffset,
                        true);

        IGNORE_HR(m_bvr->put_dur(0.0));
        IGNORE_HR(m_bvr->put_restart(TE_RESTART_NEVER));
        hr = S_OK;
        goto done;
    }

    if (bUpdateBegin)
    {
        AddSyncArcs(true);
    }
    
    if (bUpdateEnd)
    {
        AddSyncArcs(false);
    }
    
    if (m_elm.GetDurAttr().IsSet())
    {
        d = m_elm.GetDurAttr();
        if (d != 0.0 && d < 0.001)  //clamp the duration to prevent the browser from appearing to hang.
        {
            d = 0.001;
        }
    }
    else if (m_elm.GetRepeatDurAttr().IsSet() == false && 
             m_elm.GetRepeatAttr().IsSet() == false && 
             m_elm.GetEndAttr().IsSet() == true )         
    {   
        d = HUGE_VAL;
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_dur(d));
    
    if (m_elm.GetRepeatAttr().IsSet())
    {
        d = m_elm.GetRepeatAttr();
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_repeatCount(d));
    
    if (m_bZeroRepeatDur == true)
    {
        d = 0;
    }
    else if (m_elm.GetRepeatDurAttr().IsSet())
    {
        d = m_elm.GetRepeatDurAttr();
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_repeatDur(d));

    IGNORE_HR(m_bvr->put_accelerate(m_elm.GetAccel()));
    IGNORE_HR(m_bvr->put_decelerate(m_elm.GetDecel()));

    IGNORE_HR(m_bvr->put_autoReverse(m_elm.GetAutoReverse()));
    IGNORE_HR(m_bvr->put_speed(m_elm.GetSpeed()));

    DWORD flags;

    flags = 0;

    if (m_elm.IsLocked())
    {
        flags |= TE_FLAGS_LOCKED;
    }
    
    if (m_elm.IsSyncMaster())
    {
        flags |= TE_FLAGS_MASTER;
    }

    IGNORE_HR(m_bvr->put_flags(flags));
 
    bool bNeedFill;
    bNeedFill = (   (m_elm.GetFill() == HOLD_TOKEN) || (m_elm.GetFill() == FREEZE_TOKEN) 
                 || (m_elm.GetFill() == TRANSITION_TOKEN));
    IGNORE_HR(m_bvr->put_fill((bNeedFill)?TE_FILL_FREEZE:TE_FILL_REMOVE));

    {
        TE_RESTART_FLAGS ter;

        if (m_elm.GetRestart() == WHENNOTACTIVE_TOKEN)
        {
            ter = TE_RESTART_WHEN_NOT_ACTIVE;
        }
        else if (m_elm.GetRestart() == NEVER_TOKEN)
        {
            ter = TE_RESTART_NEVER;
        }
        else
        {
            ter = TE_RESTART_ALWAYS;
        }
        
        IGNORE_HR(m_bvr->put_restart(ter));
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::DocumentTimeToParentTime(double documentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::DocumentTimeToParentTime(%g)",
              this,
              documentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->documentTimeToParentTime(documentTime, &d));
    }

    return d;
}

double
MMBaseBvr::ParentTimeToDocumentTime(double parentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ParentTimeToDocumentTime(%g)",
              this,
              parentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->parentTimeToDocumentTime(parentTime, &d));
    }

    return d;
}

        
double
MMBaseBvr::ParentTimeToActiveTime(double parentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ParentTimeToActiveTime(%g)",
              this,
              parentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->parentTimeToActiveTime(parentTime, &d));
    }

    return d;
}

double
MMBaseBvr::ActiveTimeToParentTime(double activeTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ActiveTimeToParentTime(%g)",
              this,
              activeTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->activeTimeToParentTime(activeTime, &d));
    }

    return d;
}


double
MMBaseBvr::ActiveTimeToSegmentTime(double activeTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ActiveTimeToSegmentTime(%g)",
              this,
              activeTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->activeTimeToSegmentTime(activeTime, &d));
    }

    return d;
}

double
MMBaseBvr::SegmentTimeToActiveTime(double segmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SegmentTimeToActiveTime(%g)",
              this,
              segmentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->segmentTimeToActiveTime(segmentTime, &d));
    }

    return d;
}


double
MMBaseBvr::SegmentTimeToSimpleTime(double segmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SegmentTimeToSimpleTime(%g)",
              this,
              segmentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->segmentTimeToSimpleTime(segmentTime, &d));
    }

    return d;
}

double
MMBaseBvr::SimpleTimeToSegmentTime(double simpleTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SimpleTimeToSegmentTime(%g)",
              this,
              simpleTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->simpleTimeToSegmentTime(simpleTime, &d));
    }

    return d;
}

HRESULT
MMBaseBvr::PutNaturalDur(double dblNaturalDur)
{
    HRESULT hr;
    
    if (!m_bvr)
    {
        hr = E_FAIL;
        goto done;
    }

    if (0.0 == dblNaturalDur)
    {
        double dblRepeatCount = 0.0;
        double dblRepeatDur = 0.0;

        hr = THR(m_bvr->get_repeatCount(&dblRepeatCount));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_bvr->get_repeatDur(&dblRepeatDur));
        if (FAILED(hr))
        {
            goto done;
        }

        //
        // timing engine can not handle indefinite repeat with zero natural duration
        // nor can it handle any repeat duration with zero natural duration
        //
        if (TIME_INFINITE == dblRepeatCount || TE_UNDEFINED_VALUE != dblRepeatDur)
        {
            hr = S_OK;
            goto done;
        }
    }

    //if the current element is a sequence then do not allow the natural duration to be set 
    //unless the natural duration is being cleared.  
    //NOTENOTE:  this will have to be revisited if dur="media" is allowed as a value that 
    //           affects the duration of sequences.
    if (GetElement().IsSequence() && dblNaturalDur != TE_UNDEFINED_VALUE)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(m_bvr->put_naturalDur(dblNaturalDur));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetNaturalDur()
{
    double dblRet = TIME_INFINITE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_naturalDur(&dblRet));
    }
    
  done:
    return dblRet;
}

void
MMBaseBvr::SetEndSync(bool b)
{
    DWORD dwFlags = 0;
    
    IGNORE_HR(m_bvr->get_flags(&dwFlags));

    if (b)
    {
        dwFlags |= TE_FLAGS_ENDSYNC;
    }
    else
    {
        dwFlags &= ~TE_FLAGS_ENDSYNC;
    }

    IGNORE_HR(m_bvr->put_flags(dwFlags));
}

void
MMBaseBvr::SetSyncMaster(bool b)
{
    DWORD dwFlags = 0;
    
    IGNORE_HR(m_bvr->get_flags(&dwFlags));

    if (b)
    {
        dwFlags |= TE_FLAGS_MASTER;
    }
    else
    {
        dwFlags &= ~TE_FLAGS_MASTER;
    }

    IGNORE_HR(m_bvr->put_flags(dwFlags));
}

void
MMBaseBvr::ElementChangeNotify(CTIMEElementBase & teb,
                               ELM_CHANGE_TYPE ect)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ElementChangeNotify(%p, %d)",
              this,
              &teb,
              ect));
    
    bool bNeedUpdate = false;
    
    switch(ect)
    {
      case ELM_ADDED:
        {
            CTIMEElementBase * ptebParent = GetElement().GetParent();
            TimelineType tt = ptebParent?ptebParent->GetTimeContainer():ttPar;

            if (tt != ttSeq)
            {
                if (CheckForSyncArc(true, teb))
                {
                    bNeedUpdate = true;
                }
            }

            if (CheckForSyncArc(false, teb))
            {
                bNeedUpdate = true;
            }
        }
        
        break;
      case ELM_DELETED:
        {
            if (DeleteFromCookieMap(true, teb))
            {
                bNeedUpdate = true;
            }
            
            if (DeleteFromCookieMap(false, teb))
            {
                bNeedUpdate = true;
            }
        }

        break;
    }

    if (bNeedUpdate)
    {
        IGNORE_HR(m_bvr->update(0));
    }
}

bool
MMBaseBvr::CheckForSyncArc(bool bBegin,
                           CTIMEElementBase & teb)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::CTIMEElementBase(%d, %p)",
              this,
              bBegin,
              &teb));

    LPCWSTR lpwStr = teb.GetID();
    bool bRet = false;
    
    // Now iterate through the list to see if we care about this string
    TimeValueList & tvl = bBegin?GetElement().GetRealBeginValue():GetElement().GetRealEndValue();
    TimeValueSTLList & l = tvl.GetList();
    TimeValueSTLList::iterator i;

    for (i = l.begin();
         i != l.end();
         i++)
    {
        TimeValue *p = (*i);

        if (p->GetElement() == NULL &&
            lpwStr == NULL)
        {
            // do nothing
        }
        else if (p->GetEvent() == NULL ||
                 p->GetElement() == NULL ||
                 lpwStr == NULL ||
                 StrCmpIW(p->GetElement(), lpwStr) != 0)
        {
            continue;
        }

        
        TE_TIMEPOINT tetp;

        if  (p->GetEvent() == NULL)
        {
            continue;
        }
        
        if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) == 0)
        {
            tetp = TE_TIMEPOINT_BEGIN;
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) == 0)
        {
            tetp = TE_TIMEPOINT_END;
        }
        else
        {
            // This was an event and not a sync arc - ignore it
            continue;
        }

        double dblOffset = p->GetOffset();
        MMBaseBvr & mmbvr = teb.GetMMBvr();

        AddOneTimeValue(&mmbvr,
                        tetp,
                        dblOffset,
                        bBegin);

        bRet = true;
    }    
    
  done:
    return bRet;
}

bool
MMBaseBvr::DeleteFromCookieMap(bool bBegin,
                               CTIMEElementBase & teb)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::DeleteFromCookieMap(%d, %p)",
              this,
              bBegin,
              &teb));

    bool bRet = false;
    
    CookieMap & cm = bBegin?m_cmBegin:m_cmEnd;
    
    CookieMap::iterator i = cm.find(&teb);

    while (i != cm.end() && (*i).first == &teb)
    {
        bRet = true;
        
        if (bBegin)
        {
            IGNORE_HR(m_bvr->removeBegin((*i).second));
        }
        else
        {
            IGNORE_HR(m_bvr->removeEnd((*i).second));
        }

        cm.erase(i++);
    }

    return bRet;
}

//
//
//

MMBaseBvr::TEBvr::TEBvr()
: m_mmbvr(NULL),
  m_cRef(0)
{
}

MMBaseBvr::TEBvr::~TEBvr()
{
    Assert (m_cRef == 0);
    m_mmbvr = NULL;
}
        
STDMETHODIMP_(ULONG)
MMBaseBvr::TEBvr::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
MMBaseBvr::TEBvr::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
MMBaseBvr::TEBvr::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ITIMENodeBehavior))
    {
        *ppv = (void *)(ITIMENodeBehavior *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TEBvr::eventNotify(double dblLocalTime,
                              TE_EVENT_TYPE et,
                              long lRepeatCount)
{
    TraceTag((tagMMUTILEvents,
              "MMBaseBvr(%p, %ls)::eventNotify(localTime = %g, event = %s)",
              this,
              m_mmbvr->GetElement().GetID(),
              dblLocalTime,
              EventString(et)));

    if (!m_mmbvr)
    {
        goto done;
    }

    Assert(m_mmbvr->m_bFireEvents);

    if (NULL != m_mmbvr->GetElement().GetParent())
    {
        MMTimeline * pMMParent = m_mmbvr->GetElement().GetParent()->GetMMTimeline();
        if (NULL != pMMParent)
        {
            bool bFireOut = pMMParent->childEventNotify(m_mmbvr, dblLocalTime, et);
            if (false == bFireOut)
            {
                goto done;
            }
        }
    }
    
    TIME_EVENT newet;
        
    switch(et)
    {
      case TE_EVENT_BEGIN:
        newet = TE_ONBEGIN;
        break;
      case TE_EVENT_END:
        newet = TE_ONEND;
        break;
      case TE_EVENT_REPEAT:
        newet = TE_ONREPEAT;
        break;
      case TE_EVENT_AUTOREVERSE:
        newet = TE_ONREVERSE;
        break;
      case TE_EVENT_PAUSE:
        newet = TE_ONPAUSE;
        break;
      case TE_EVENT_RESUME:
        newet = TE_ONRESUME;
        break;
      case TE_EVENT_RESET:
        newet = TE_ONRESET;
        break;
      case TE_EVENT_UPDATE:
        newet = TE_ONUPDATE;
        break;
      case TE_EVENT_SEEK:
        newet = TE_ONSEEK;
        break;
      default:
        goto done;
    }
        
    // The reason we check again is that our parent could have done
    // something which causes us to shut down.
    if (m_mmbvr)
    {
        THR(m_mmbvr->m_elm.FireEvent(newet, dblLocalTime, 0, lRepeatCount));
    }
    
  done:
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TEBvr::getSyncTime(double * dblNewTime,
                              LONG * lNewRepeatCount,
                              VARIANT_BOOL * vbCueing)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(dblNewTime);
    CHECK_RETURN_NULL(lNewRepeatCount);
    CHECK_RETURN_NULL(vbCueing);

    // Initialize to the same time
    
    *dblNewTime = TE_UNDEFINED_VALUE;
    *lNewRepeatCount = TE_UNDEFINED_VALUE;
    *vbCueing = VARIANT_FALSE;

    bool bCueing = false;
    
    if (!m_mmbvr)
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = THR(m_mmbvr->m_elm.GetSyncMaster(*dblNewTime,
                                          *lNewRepeatCount,
                                          bCueing));
    if (S_OK != hr)
    {
        if (E_NOTIMPL == hr)
        {
            hr = S_FALSE;
        }
        
        goto done;
    }
    
    *vbCueing = bCueing?VARIANT_TRUE:VARIANT_FALSE;
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
MMBaseBvr::TEBvr::tick()
{
    if (!m_mmbvr)
    {
        goto done;
    }

    m_mmbvr->m_elm.OnTick();
  
  done:
    return S_OK;
}

void 
MMBaseBvr::SetEnabled(bool bEnabled)
{
    m_bEnabled = bEnabled;
}

STDMETHODIMP
MMBaseBvr::TEBvr::propNotify(DWORD tePropType)
{
    if (!m_mmbvr)
    {
        goto done;
    }

    if (NULL != m_mmbvr->GetElement().GetParent())
    {
        MMTimeline * pMMParent = m_mmbvr->GetElement().GetParent()->GetMMTimeline();
        if (NULL != pMMParent)
        {
            bool bFireOut = pMMParent->childPropNotify(m_mmbvr, &tePropType);
            if (false == bFireOut)
            {
                goto done;
            }
        }
    }

    // The reason we check again is that our parent could have done
    // something which causes us to shut down.
    if (m_mmbvr)
    {
        m_mmbvr->m_elm.OnTEPropChange(tePropType);
    }

  done:
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// MMBvr
/////////////////////////////////////////////////////////////////////

MMBvr::MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB)
: MMBaseBvr(elm,bFireEvents),
  m_fNeedSyncCB(fNeedSyncCB)
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::MMBvr(%p,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBvr::~MMBvr()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::~MMBvr()",
              this));
}

bool
MMBvr::Init()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::Init()",
              this));

    bool ok = false;
    HRESULT hr;
    DAComPtr<ITIMENode> tn;
    
    hr = THR(TECreateBehavior(m_elm.GetID(), &tn));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
      
    if (!MMBaseBvr::Init(tn))
    {
        hr = TIMEGetLastError();
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

//
// MMPlayer
//

MMPlayer::MMPlayer(CTIMEBodyElement & elm)
: m_elm(elm),
  m_fReleased(false),
  m_timeline(NULL),
  m_clock(NULL)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::MMPlayer(%p)",
              this,
              &elm));
}

MMPlayer::~MMPlayer()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::~MMPlayer()",
              this));

    if (m_timeline)
    {
        m_timeline->put_Player(NULL);
    }

    Deinit();
    m_timeline = NULL;
    ReleaseInterface(m_clock);
}

bool
MMPlayer::Init(MMTimeline & tl)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Init(%p)",
              this,
              &tl));

    bool ok = false;
    HRESULT hr;
    
    m_timeline = &tl;
    if (m_timeline != NULL) //lint !e774
    {
        m_timeline->put_Player(this);
    }

    hr = THR(TECreatePlayer(m_elm.GetID(),
                            m_timeline->GetMMTimeline(),
                            &m_elm,
                            &m_player));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    m_clock = new Clock;
    if (NULL == m_clock)
    {
        TIMESetLastError(E_OUTOFMEMORY, NULL);
        goto done;
    }

    m_clock->SetSink(this);
    
    hr = THR(m_clock->SetITimer(&m_elm, 20));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_player.Release();
    }
    
    return ok;
}

void
MMPlayer::Deinit()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Deinit()",
              this));

    if (!m_fReleased)
    {
        m_fReleased = true;
    }

    if (m_clock)
    {
        m_clock->Stop();
        m_clock->SetSink(NULL);
    }
    ReleaseInterface(m_clock);

    m_player.Release();
}

bool
MMPlayer::Play()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Play()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->begin());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (NULL == m_clock)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }

    hr = THR(m_clock->Start());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    if (!ok)
    {
        if (!m_player)
        {
            m_player->end();
        }
        if (m_clock)
        {
            m_clock->Stop();
        }
    }
    
    return ok;
}

bool
MMPlayer::Pause()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Pause()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->pause());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Resume()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Resume()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->resume());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Stop()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Stop()",
              this));

    bool ok = false;

    if (m_player)
    {
        IGNORE_HR(m_player->end());
    }
    
    if (NULL != m_clock)
    {
        IGNORE_HR(m_clock->Stop());
    }

    ok = true;

    return ok;
}

bool
MMPlayer::Tick(double gTime)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->tick(gTime));

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool 
MMPlayer::TickOnceWhenPaused()
{
    // DBL_EPSILON is defined in float.h such that
    // 1.0 + DBL_EPSILON != 1.0
    return Tick(GetCurrentTime() + DBL_EPSILON);
}


void
MMPlayer::OnTimer(double time)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::OnTimer(%g)",
              this,
              time));

    Tick(time);
    if (!m_fReleased)
    {
        m_elm.UpdateAnimations();
        m_elm.UpdateSyncNotify();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeaction.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeaction.h
//
//  Contents: Class that encapsulates timeAction functionality
//
//  Note: This is meant to be nested in CTIMEElementBase. It maintains a weak reference to 
//        it's container CTIMEElementBase.
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEACTION_H
#define _TIMEACTION_H

#include "tokens.h"

class CTIMEElementBase;

//+-------------------------------------------------------------------------------------
//
// CTIMEAction
//
//--------------------------------------------------------------------------------------

class CTimeAction
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTimeAction(CTIMEElementBase * pTEB);
    virtual ~CTimeAction();

    bool Init();
    bool Detach();

    // Accessors
    HRESULT SetTimeAction(LPWSTR pstrAction);
    TOKEN GetTimeAction();

    IHTMLElement * GetElement();

    // Initialization/Deinitialization
    bool AddTimeAction();
    bool RemoveTimeAction();

    // notification that the element has loaded
    void OnLoad();

    // Apply the time action
    bool ToggleTimeAction(bool on);

    bool UpdateDefaultTimeAction();

    bool IsTimeActionOn() { return m_bTimeActionOn; }

    LPWSTR GetTimeActionString();

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // These are not meant to be used
    CTimeAction();
    CTimeAction(const CTimeAction&);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    // Is this a "class: ..." timeAction
    bool IsClass(LPOLESTR pstrAction, size_t * pOffset);
    // Remove time action classes from original classes string
    HRESULT RemoveClasses(/*in*/  LPWSTR    pstrOriginalClasses, 
                          /*in*/  LPWSTR    pstrTimeActionClasses, 
                          /*out*/ LPWSTR *  ppstrUniqueClasses);

    TOKEN GetDefaultTimeAction();

    bool AddIntrinsicTimeAction();
    bool RemoveIntrinsicTimeAction();
    bool ToggleIntrinsicTimeAction(bool on);

    bool ToggleBold(bool on);
    bool ToggleAnchor(bool on);
    bool ToggleItalic(bool on);

    bool ToggleStyleSelector(bool   on, 
                             BSTR   bstrPropertyName, 
                             LPWSTR pstrActive, 
                             LPWSTR pstrInactive);

    bool EnableStyleInheritance(BSTR bstrPropertyName);
    void DisableStyleInheritance(BSTR bstrPropertyName);
    
    bool SetStyleProperty(BSTR      bstrPropertyName, 
                          VARIANT & varPropertyValue);

    bool CacheOriginalExpression(BSTR bstrPropertyName);
    bool RestoreOriginalExpression(LPWSTR pstrPropertyName);

    bool IsInSequence();
    bool IsContainerTag(); 
    bool IsSpecialTag();
    bool IsGroup();
    bool IsMedia();
    bool IsPageUnloading();
    bool IsDetaching();
    bool IsLoaded();

    void ParseTagName();


    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    // Enum for tag type
    enum TagType 
    {
        TAGTYPE_UNINITIALIZED,
        TAGTYPE_B, 
        TAGTYPE_A, 
        TAGTYPE_I, 
        TAGTYPE_EM, 
        TAGTYPE_AREA, 
        TAGTYPE_STRONG,
        TAGTYPE_OTHER 
    };

    // timeAction attribute string
    LPWSTR              m_pstrTimeAction;
    // index of start of classNames substring in m_pstrTimeAction 
    int                 m_iClassNames;
    // Tokenized timeAction
    TOKEN               m_timeAction;
    // Cached original value of affected property
    LPWSTR              m_pstrOrigAction;
    // Original Classes minus timeAction classes
    LPWSTR              m_pstrUniqueClasses;
    // Pointer to container (weak ref)  
    CTIMEElementBase *  m_pTEB;
    // enum that stores the HTML tagName
    TagType             m_tagType;
    // Cache original expression set on a property
    LPWSTR              m_pstrOrigExpr;
    // Cache the current expression set on a property (set by us)
    LPWSTR              m_pstrTimeExpr;
    // the cached intrinsic timeAction property
    LPWSTR              m_pstrIntrinsicTimeAction;
    bool                m_fContainerTag;
    bool                m_fUseDefault;
    bool                m_bTimeActionOn;
}; // CTimeAction


//+---------------------------------------------------------------------------------
//  CTIMEAction inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\tebcollect.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: tebcollect.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelmbase.h"


DeclareTag(tagTEBCollect, "TIME: Behavior", "CTIMEElementBase collection methods");


// CAtomTable is used as a static object by CTIMEElementBase and needs to be 
// thread safe since we can have multiple trident threads in the same process
static CritSect g_TEBCriticalSection;


STDMETHODIMP CTIMEElementBase::CreateActiveEleCollection()
{
    HRESULT hr = S_OK;
    
    //create the ActiveElementCollection for any timeline element
    if (((m_TTATimeContainer != ttUninitialized && m_TTATimeContainer != ttNone) ||
        (m_bIsSwitch == true)) &&
        !m_activeElementCollection)
    {
        m_activeElementCollection = NEW CActiveElementCollection(*this);
        if (!m_activeElementCollection)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

  done:
    return hr;
}

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    helper function to wade thru cache.
//************************************************************

HRESULT
CTIMEElementBase::GetCollection(COLLECTION_INDEX index, ITIMEElementCollection ** ppDisp)
{
    HRESULT hr;

    // validate out param
    if (ppDisp == NULL)
        return TIMESetLastError(E_POINTER);

    *ppDisp = NULL;

    hr = EnsureCollectionCache();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEElementBase::GetCollection - EnsureCollectionCache() failed"));
        return hr;
    }

    // call in
    return m_pCollectionCache->GetCollectionDisp(index, (IDispatch **)ppDisp);
} // GetCollection

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    Make sure collection cache is up
//************************************************************

HRESULT 
CTIMEElementBase::EnsureCollectionCache()
{
    // check to see if collection cache has been created
    if (m_pCollectionCache == NULL)
    {
        // bring up collection cache
        // NOTE: we need to handle TIMESetLastError here as
        // cache object doesn't have that concept.
        m_pCollectionCache = NEW CCollectionCache(this, GetAtomTable());
        if (m_pCollectionCache == NULL)
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - Unable to create Collection Cache"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }

        HRESULT hr = m_pCollectionCache->Init(NUM_COLLECTIONS);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - collection cache init failed"));
            delete m_pCollectionCache;
            return TIMESetLastError(hr);
        }

        // set collection types
        m_pCollectionCache->SetCollectionType(ciAllElements, ctAll);
        m_pCollectionCache->SetCollectionType(ciChildrenElements, ctChildren);
    }

    return S_OK;
} // EnsureCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    invalidate all collection cache's that might
//              reference this object.
//************************************************************

HRESULT 
CTIMEElementBase::InvalidateCollectionCache()
{
    CTIMEElementBase *pelem = this;

    // walk up tree, invalidating CollectionCache's
    // we skip if the collection is not initialized
    // we walk until we run out of parent's.  In this
    // manner, we keep the collectioncache fresh, even
    // if the object branch is orphaned.
    while (pelem != NULL)
    {
        // not everybody will have the collection cache
        // initialized
        CCollectionCache *pCollCache = pelem->GetCollectionCache();        
        if (pCollCache != NULL)
            pCollCache->BumpVersion();
        
        // move to parent
        pelem = pelem->GetParent();
    }

    return S_OK;
} // InvalidateCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    init Atom Table
//              Note:  this is only done once and then addref'd.
//************************************************************

HRESULT 
CTIMEElementBase::InitAtomTable()
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_TEBCriticalSection);
    
    if (s_cAtomTableRef == 0)
    {
        Assert(s_pAtomTable == NULL);

        s_pAtomTable = NEW CAtomTable();
        if (s_pAtomTable == NULL)
        {
            TraceTag((tagError, "CElement::InitAtomTable - alloc failed for CAtomTable"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }
        s_pAtomTable->AddRef();
    }

    s_cAtomTableRef++;
    return S_OK;
} // InitAtomTable

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    release Atom Table
//              Note: this decrement's until zero and then
//              releases the Atom table.
//************************************************************

void 
CTIMEElementBase::ReleaseAtomTable()
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_TEBCriticalSection);

    Assert(s_pAtomTable != NULL);
    Assert(s_cAtomTableRef > 0);
    if (s_cAtomTableRef > 0)
    {
        s_cAtomTableRef--;
        if (s_cAtomTableRef == 0)
        {
            if (s_pAtomTable != NULL)
            {
                s_pAtomTable->Release();
                s_pAtomTable = NULL;
            }
        }
    }
    return;
} // ReleaseAtomTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeaction.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeaction.cpp
//
//  Contents: Class that encapsulates timeAction functionality
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "timeaction.h"
#include "timeelmbase.h"


DeclareTag(tagTimeAction, "TIME: Behavior", "CTimeAction methods");


static const LPWSTR WZ_BLANK    = L"";
static const LPWSTR WZ_SPACE    = L" ";
static const LPWSTR WZ_B        = L"B";
static const LPWSTR WZ_I        = L"I";
static const LPWSTR WZ_A        = L"A";
static const LPWSTR WZ_EM       = L"EM";
static const LPWSTR WZ_AREA     = L"AREA";
static const LPWSTR WZ_STRONG   = L"STRONG";
static const LPWSTR WZ_HTML     = L"HTML";
static const LPWSTR WZ_NORMAL   = L"normal";
static const LPWSTR WZ_ITALIC   = L"italic";
static const LPWSTR WZ_BOLD     = L"bold";
static const LPWSTR WZ_HREF     = L"href";
static const LPWSTR WZ_JSCRIPT  = L"JScript";

static const LPWSTR WZ_PARENT_CURRSTYLE     = L"parentElement.currentStyle.";
static const LPWSTR WZ_FONTWEIGHT           = L"fontWeight";
static const LPWSTR WZ_FONTSTYLE            = L"fontStyle";

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::CTimeAction
//
//  Synopsis:   Constructor
//
//  Arguments:  [pTEB]          pointer to container
//
//------------------------------------------------------------------------------------
CTimeAction::CTimeAction(CTIMEElementBase * pTEB) :
    m_pTEB(pTEB),
    m_timeAction(NULL),
    m_pstrTimeAction(NULL),
    m_iClassNames(0),
    m_pstrOrigAction(NULL),
    m_pstrUniqueClasses(NULL),
    m_tagType(TAGTYPE_UNINITIALIZED),
    m_pstrOrigExpr(NULL),
    m_pstrTimeExpr(NULL),
    m_pstrIntrinsicTimeAction(NULL),
    m_fContainerTag(false),
    m_fUseDefault(true),
    m_bTimeActionOn(false)
{

} // CTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::~CTimeAction
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------------
CTimeAction::~CTimeAction()
{
    delete [] m_pstrTimeAction;
    m_pstrTimeAction = 0;

    delete [] m_pstrOrigAction;
    m_pstrOrigAction = 0;

    delete [] m_pstrUniqueClasses;
    m_pstrUniqueClasses = 0;

    delete [] m_pstrOrigExpr;
    m_pstrOrigExpr = 0;

    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = 0;

    delete [] m_pstrIntrinsicTimeAction;
    m_pstrIntrinsicTimeAction = 0;

    m_timeAction = 0;

    // weak ref
    m_pTEB = NULL; 
} // ~CTimeAction


bool
CTimeAction::Init()
{
    if (!AddIntrinsicTimeAction())
    {
        Assert("Could not add intrinsic timeAction" && false);
    }

    return UpdateDefaultTimeAction();

} // Init


bool
CTimeAction::Detach()
{
    bool ok;

    ok = RemoveIntrinsicTimeAction();
    Assert(ok);

    ok = RemoveTimeAction();
done:
    return ok;
} // Detach



//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetElement
//
//  Synopsis:   Accessor for HTML element
//
//  Arguments:  none
//
//  Returns:    pointer to containing HTML element
//
//------------------------------------------------------------------------------------
IHTMLElement * 
CTimeAction::GetElement()
{
    Assert(NULL != m_pTEB);
    return m_pTEB->GetElement(); 
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetTimeAction
//
//  Synopsis:   Accessor for m_timeAction
//
//  Arguments:  none
//
//  Returns:    current timeAction
//
//------------------------------------------------------------------------------------
TOKEN 
CTimeAction::GetTimeAction()
{ 
    return m_timeAction; 
} // GetTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     OnLoad
//
//  Synopsis:   notification that element has loaded. This is required because
//              this is the earliest we can know that Element Behaviors have finished initalizing.
//
//  Arguments:  none
//
//  Returns:    void
//
//------------------------------------------------------------------------------------
void 
CTimeAction::OnLoad()
{ 
    // Init the timeAction
    if (NULL == m_pstrOrigAction)
    {
        AddTimeAction();
    }
} // OnLoad


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::IsClass
//
//  Synopsis:   Checks if the given string begins with CLASS_TOKEN followed by SEPARATOR_TOKEN
//              (ignoring leading and trailing whitespace around CLASS_TOKEN). Comparisons are
//              case in-sensitive, 
//
//  Arguments:  [pstrAction]    String to be tested
//              [pOffset]       If this is NULL, it is ignored. If it is non-NULL, then if return 
//                              value is [true], this points to the index of the first char 
//                              after SEPARATOR_TOKEN
//
//  Returns:    [true]      if there is a positive match (see synopsis)
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::IsClass(LPOLESTR pstrAction, size_t * pOffset)
{
    bool ok = false;
    size_t index, length;

    // check args
    if (NULL == pstrAction)
    {
        goto done;
    }

    if (NULL != pOffset)
    {
        // intialize to some value
        *pOffset = 0;
    }

    // done if string length is less than minimum length 
    length = wcslen(pstrAction);
    if (length < static_cast<size_t>(nCLASS_TOKEN_LENGTH + nSEPARATOR_TOKEN_LENGTH))
    {
        goto done;
    }

    // find first non-whitespace character
    index = StrSpnW(pstrAction, WZ_SPACE);

    // done if remaining string isn't long enough
    if (length < index + nCLASS_TOKEN_LENGTH + nSEPARATOR_TOKEN_LENGTH)
    {
        goto done;
    }

    // check that the following chars match CLASS_TOKEN 
    if (StrCmpNIW(static_cast<WCHAR*>(CLASS_TOKEN), &(pstrAction[index]), nCLASS_TOKEN_LENGTH) == 0)
    {
        // advance to next char after CLASS_TOKEN
        index += nCLASS_TOKEN_LENGTH;
    }
    else
    {
        goto done;
    }

    // find the first non-whitespace char after CLASS_TOKEN
    index += StrSpnW(&(pstrAction[index]), WZ_SPACE);

    // done if remaining string isn't long enough
    if (length < index + nSEPARATOR_TOKEN_LENGTH)
    {
        goto done;
    }

    // check that the following chars match SEPARATOR_TOKEN 
    if (StrCmpNIW(static_cast<WCHAR*>(SEPARATOR_TOKEN), &(pstrAction[index]), nSEPARATOR_TOKEN_LENGTH) == 0)
    {
        // advance to next char after SEPARATOR_TOKEN
        index += nSEPARATOR_TOKEN_LENGTH;
    }
    else
    {
        goto done;
    }

    if (NULL != pOffset)
    {
        // return the first char after ":"
        *pOffset = index;
    }

    ok = true;
done:
    return ok;
} // IsClass

    

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::SetTimeAction
//
//  Synopsis:   sets the time action (also removes and adds the timeAction)
//
//  Arguments:  [pstrAction]    time action to be set
//
//  Returns:    [S_OK]      if successful
//              Failure     otherwise    
//
//------------------------------------------------------------------------------------
HRESULT
CTimeAction::SetTimeAction(LPWSTR pstrAction)
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::SetTimeAction(%ls) id=%ls",
              this,
              pstrAction,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));

    HRESULT hr = S_OK;
    TOKEN tok_action;
    size_t offset = 0;

    Assert(pstrAction);

    //
    // check for timeaction="class: ..."
    //

    // verify that this is a valid "class:" timeAction (colon is REQUIRED) and 
    // get the offset of the the class names substring
    if (IsClass(pstrAction, &offset))
    {
        tok_action = CLASS_TOKEN;

        // store the timeaction string
        if (m_pstrTimeAction)
        {
            delete [] m_pstrTimeAction;
        }
        m_pstrTimeAction = CopyString(pstrAction);
        if (m_pstrTimeAction == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // store the offset of the className substring
        m_iClassNames = offset;
    }
    else
    {
        tok_action = StringToToken(pstrAction);

        //
        // Validate the token 
        //

        if (DISPLAY_TOKEN == tok_action     ||
            VISIBILITY_TOKEN == tok_action  ||
            STYLE_TOKEN == tok_action       ||
            (NONE_TOKEN == tok_action && IsGroup()))
        {
            // valid
            m_fUseDefault = false;
        }
        else
        {
            // invalid, use default
            tok_action = GetDefaultTimeAction();
            m_fUseDefault = true;
        }
    }
    
    //
    // Update the timeAction 
    //

    if (m_timeAction != tok_action || CLASS_TOKEN == tok_action)
    {
        RemoveTimeAction();
        m_timeAction = tok_action;
        AddTimeAction();
    }
    
    hr = S_OK;
done:
    return hr;
} // SetTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetDefaultTimeAction
//
//  Synopsis:   Returns the default timeAction
//
//  Arguments:  none
//
//  Returns:    timeAction
//
//------------------------------------------------------------------------------------
TOKEN
CTimeAction::GetDefaultTimeAction()
{
    TOKEN tokTimeAction;

    if (IsContainerTag() || IsSpecialTag())
    {
        tokTimeAction = NONE_TOKEN;
    }
    else
    {
        if(IsInSequence())
        {
            tokTimeAction = DISPLAY_TOKEN;
        }
        else
        {
            if (IsMedia())
            {
                tokTimeAction = NONE_TOKEN;
            }
            else
            {
                tokTimeAction = VISIBILITY_TOKEN;
            }
        }
    }

    return tokTimeAction;
} // GetDefaultTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveClasses
//
//  Synopsis:   Returns a string that contains classes that are in the className string
//              but not in the timeAction string.
//
//  Arguments:  [pstrOriginalClasses]   className attribute set on the HTML element (1)
//              [pstrTimeActionClasses] classes in the timeAction string (2)
//              [ppstrUniqueClasses]    string containing classes in (1) but not in (2)
//
//  Returns:    [S_OK]      if successful
//              Failure     otherwise    
//
//  Note:       1. returns space separated string
//              2. Memory mgmt: If method returns success, caller needs to free memory in ppstrUniqueClasses
//
//------------------------------------------------------------------------------------
HRESULT 
CTimeAction::RemoveClasses(/*in*/  LPWSTR    pstrOriginalClasses, 
                           /*in*/  LPWSTR    pstrTimeActionClasses, 
                           /*out*/ LPWSTR *  ppstrUniqueClasses)
{
    HRESULT hr = E_FAIL;
    CPtrAry<STRING_TOKEN*> aryTokens1;
    CPtrAry<STRING_TOKEN*> aryTokens2;
    CPtrAry<STRING_TOKEN*> ary1Minus2;

    CHECK_RETURN_SET_NULL(ppstrUniqueClasses);

    // if pstrOriginalClasses is NULL or an Empty string, difference = NULL
    if (NULL == pstrOriginalClasses || NULL == pstrOriginalClasses[0])
    {
        *ppstrUniqueClasses = NULL;
        hr = S_OK;
        goto done;
    }

    // if pstrTimeActionClasses is NULL or an Empty string, difference = pstrOriginalClasses
    if (NULL == pstrTimeActionClasses || NULL == pstrTimeActionClasses[0])
    {
        *ppstrUniqueClasses = CopyString(pstrOriginalClasses);
        if (NULL == *ppstrUniqueClasses)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    //
    // Parse Class Names into tokens
    //

    // parse pstrOriginalClasses into tokens
    hr = THR(::StringToTokens(pstrOriginalClasses, WZ_SPACE, &aryTokens1));
    if (FAILED(hr))
    {
        goto done;
    }

    // parse pstrTimeActionClasses into tokens
    hr = THR(::StringToTokens(pstrTimeActionClasses, WZ_SPACE, &aryTokens2));
    if (FAILED(hr))
    {
        goto done;
    }

    //
    // do set difference (aryTokens1 - aryTokens2)
    //

    hr = THR(::TokenSetDifference(&aryTokens1, pstrOriginalClasses, &aryTokens2, pstrTimeActionClasses, &ary1Minus2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::TokensToString(&ary1Minus2, pstrOriginalClasses, ppstrUniqueClasses));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens1));
    IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    IGNORE_HR(::FreeStringTokenArray(&ary1Minus2));
    return hr;
} // RemoveClasses


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::AddTimeAction
//
//  Synopsis:   Caches the original state of the target element
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::AddTimeAction()
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::AddTimeAction() id=%ls",
              this,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    BSTR bstr = NULL;
    HRESULT hr;
    CComPtr<IHTMLStyle> s;

    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        hr = THR(s->get_cssText(&bstr));
        if (FAILED(hr))
        {
            goto done;
        }
            
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }

        if (NULL == bstr)
        {
            m_pstrOrigAction = NULL;
            goto done;
        }
        m_pstrOrigAction = CopyString(bstr);

        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        hr = THR(m_pTEB->GetRuntimeStyle(&s));
        if (FAILED(hr))
        {
            goto done;
        }

        if (FAILED(THR(s->get_display(&bstr))))
        {
            goto done;
        }
        
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->get_className(&bstr));
        if (FAILED(hr))
        {
            goto done;
        }

        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // Compute (Original Classes) - (TimeAction Classes)
        if (m_pstrUniqueClasses)
        {
            delete [] m_pstrUniqueClasses;
            m_pstrUniqueClasses = NULL;
        }
        hr = RemoveClasses(m_pstrOrigAction, 
                           &(m_pstrTimeAction[m_iClassNames]), 
                           &m_pstrUniqueClasses);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(m_pTEB->GetRuntimeStyle(&s));
        if (FAILED(hr))
        {
            goto done;
        }

        if (FAILED(THR(s->get_visibility(&bstr))))
        {
            goto done;
        }
       
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }

    ok = true;
done:
    SysFreeString(bstr);
    return ok;
} // AddTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::AddIntrinsicTimeAction
//
//  Synopsis:   Cache the original value of the affected attribute
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::AddIntrinsicTimeAction()
{   
    bool ok = false;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComBSTR sbstrOriginal;
    
    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // check if we have anything to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    //
    // Get the attribute value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            hr = THR(m_pTEB->GetRuntimeStyle(&s));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(s->get_fontWeight(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            hr = THR(m_pTEB->GetRuntimeStyle(&s));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(s->get_fontStyle(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }
            
            break;
        }

        case TAGTYPE_A:
        {
            if (!GetElement())
            {
                goto done;
            }

            CComPtr<IHTMLAnchorElement> spAnchorElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAnchorElem->get_href(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }

        case TAGTYPE_AREA:
        {
            if (!GetElement())
            {
                goto done;
            }

            CComPtr<IHTMLAreaElement> spAreaElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAreaElem->get_href(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            goto done;
        }

    } // switch (m_tagType)

    //
    // Save the attribute value
    //

    if (m_pstrIntrinsicTimeAction)
    {
        delete [] m_pstrIntrinsicTimeAction;
    }
    m_pstrIntrinsicTimeAction = CopyString(sbstrOriginal);
    if (NULL == m_pstrIntrinsicTimeAction)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // AddIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveTimeAction
//
//  Synopsis:   Restores target element to its original state
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::RemoveTimeAction()
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::RemoveTimeAction() id=%ls",
              this,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    CComPtr<IHTMLStyle> s;

    if (IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    if (NULL == m_pstrOrigAction)
    {
        // Nothin to remove
        ok = true;
        goto done;
    }
    
    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
        
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_cssText(bstr));
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_display(bstr));
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        bstr = SysAllocString(m_pstrOrigAction);
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        hr = THR(GetElement()->put_className(bstr));

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_visibility(bstr));
    }

    ok = true;
done:
    SysFreeString(bstr);
    if (m_pstrOrigAction)
    {
        delete [] m_pstrOrigAction;
        m_pstrOrigAction = 0;
    }
    return ok;
} // RemoveTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveIntrinsicTimeAction
//
//  Synopsis:   Restore the affected attribute to its original value 
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::RemoveIntrinsicTimeAction()
{   
    bool ok = false;
    HRESULT hr = S_OK;
    CComBSTR sbstrOriginal;
    
    if (IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // check if we have anything to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    if (m_pstrIntrinsicTimeAction)
    {
        // Allocate BSTR value
        sbstrOriginal = SysAllocString(m_pstrIntrinsicTimeAction);
        if (sbstrOriginal == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    //
    // Restore attribute to original value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                CComPtr<IHTMLStyle> s;
                hr = THR(m_pTEB->GetRuntimeStyle(&s));
                if (FAILED(hr))
                {
                    goto done;
                }

                hr = THR(s->put_fontWeight(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            // restore the original expression set on the property
            if (!RestoreOriginalExpression(WZ_FONTWEIGHT))
            {
                hr = TIMEGetLastError();
                goto done;
            }

            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                CComPtr<IHTMLStyle> s;
                hr = THR(m_pTEB->GetRuntimeStyle(&s));
                if (FAILED(hr))
                {
                    goto done;
                }

                hr = THR(s->put_fontStyle(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            // restore the original expression set on the property
            if (!RestoreOriginalExpression(WZ_FONTSTYLE))
            {
                hr = TIMEGetLastError();
                goto done;
            }

            break;
        }

        case TAGTYPE_A:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                if (!GetElement())
                {
                    goto done;
                }

                CComPtr<IHTMLAnchorElement> spAnchorElem;
                hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
                if (FAILED(hr))
                {
                    // This has to succeed
                    Assert(false);
                    goto done;
                }

                hr = THR(spAnchorElem->put_href(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            break;
        }

        case TAGTYPE_AREA:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                if (!GetElement())
                {
                    goto done;
                }

                CComPtr<IHTMLAreaElement> spAreaElem;
                hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
                if (FAILED(hr))
                {
                    // This has to succeed
                    Assert(false);
                    goto done;
                }

                hr = THR(spAreaElem->put_href(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            goto done;
        }

    } // switch (m_tagType)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // RemoveIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleTimeAction
//
//  Synopsis:   Applies the time action to the target element
//
//  Arguments:  [on]        [true] => Element is active, and vice-versa
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::ToggleTimeAction(bool on)
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::ToggleTimeAction(%d) id=%ls",
              this,
              on,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    BSTR bstr = NULL;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;

    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // Always apply the intrinsic timeAction
    ToggleIntrinsicTimeAction(on);

    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        if (NULL == m_pstrOrigAction)
        {
            // nothing to toggle
            ok = true;
            goto done;
        }
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(NONE_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_cssText(bstr));
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        bool bFocus = m_pTEB->HasFocus();
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(NONE_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    

        THR(s->put_display(bstr));
        if (bFocus == true)
        {
            ReleaseCapture();
        }
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        CComBSTR sbstrTemp;

        if (NULL == m_pstrUniqueClasses)
        {
            sbstrTemp = L"";
        }
        else
        {
            sbstrTemp = m_pstrUniqueClasses;
        }

        if (!sbstrTemp)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (on)
        {
            sbstrTemp.Append(WZ_SPACE);
            sbstrTemp.Append(&(m_pstrTimeAction[m_iClassNames]));
            if (!sbstrTemp)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        hr = THR(GetElement()->put_className(sbstrTemp));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        bool bFocus = m_pTEB->HasFocus();
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(HIDDEN_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_visibility(bstr));
        if (bFocus == true)
        {
            ReleaseCapture();
        }
    }

    ok = true;
done:

    m_bTimeActionOn = on; 

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    SysFreeString(bstr);
    return ok;
} // ToggleTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::CacheOriginalExpression
//
//  Synopsis:   Caches any expression set on the given runtimeStyle property.
//
//  Arguments:  property name
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::CacheOriginalExpression(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComVariant          svarExpr;

    // Done if we've already cached the expression.
    if (m_pstrOrigExpr)
    {
        ok = true;
        goto done;
    }

    Assert(bstrPropertyName);

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle2->getExpression(bstrPropertyName, &svarExpr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // done if there was no expression
    if (VT_EMPTY == V_VT(&svarExpr))
    {
        ok = true;
        goto done;
    }

    // change type to VT_BSTR
    if (VT_BSTR != V_VT(&svarExpr))
    {
        hr = THR(VariantChangeTypeEx(&svarExpr, &svarExpr, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // check if an expression is set
    if (V_BSTR(&svarExpr) && (0 != StrCmpIW(WZ_BLANK, V_BSTR(&svarExpr))))
    {
        // cache if it has been set externally
        if (!m_pstrTimeExpr || (0 != StrCmpIW(V_BSTR(&svarExpr), m_pstrTimeExpr)))
        {
            delete [] m_pstrOrigExpr;

            m_pstrOrigExpr = CopyString(V_BSTR(&svarExpr));
            if (NULL == m_pstrOrigExpr)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
    }
    
    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // CacheOriginalExpression


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RestoreOriginalExpression
//
//  Synopsis:   Restores any expression that was cached.
//
//  Arguments:  property name
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::RestoreOriginalExpression(LPWSTR pstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComBSTR             sbstrPropertyName;

    Assert(pstrPropertyName);

    sbstrPropertyName = pstrPropertyName;
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }


    if (m_pstrOrigExpr)
    {
        CComBSTR sbstrExpression(m_pstrOrigExpr);
        CComBSTR sbstrLanguage(WZ_JSCRIPT);
        if (!sbstrExpression || !sbstrLanguage)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = THR(spStyle2->setExpression(sbstrPropertyName, sbstrExpression, sbstrLanguage));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        DisableStyleInheritance(sbstrPropertyName);
    }

    //
    // Indicate that we have restored the original expression 
    //

    delete [] m_pstrOrigExpr;
    m_pstrOrigExpr = NULL;

    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = NULL;

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // RestoreOriginalExpression


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::EnableStyleInheritance
//
//  Synopsis:   Sets an expression on the runtimeStyle property to be the parent's 
//              currentStyle property.
//
//  Arguments:  runtimeStyle property that needs to inherit
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::EnableStyleInheritance(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComBSTR             sbstrExpression;
    CComBSTR             sbstrLanguage;

    // Done if we've already set the expression.
    if (m_pstrTimeExpr)
    {
        ok = true;
        goto done;
    }

    // don't set expressions unless the page has loaded
    // This is due to possible existence of multiple elements
    // sharing the same id (108705)
    if (!IsLoaded())
    {
        goto done;
    }

    Assert(bstrPropertyName);

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an expression on the runtimeStyle property
    sbstrExpression.Append(WZ_PARENT_CURRSTYLE);
    sbstrExpression.Append(bstrPropertyName);
    sbstrLanguage = WZ_JSCRIPT;
    if (!sbstrExpression || !sbstrLanguage)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // cache the original expression before blowing it away
    if (!CacheOriginalExpression(bstrPropertyName))
    {
        IGNORE_HR(TIMEGetLastError());
    }


    hr = THR(spStyle2->setExpression(bstrPropertyName, sbstrExpression, sbstrLanguage));
    if (FAILED(hr))
    {
        goto done;
    }

    // store the expression we have set
    m_pstrTimeExpr = CopyString(sbstrExpression);
    if (NULL == m_pstrTimeExpr)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // EnableStyleInheritance


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::DisableStyleInheritance
//
//  Synopsis:   Removes the expression on the runtimeStyle property
//
//  Arguments:  runtimeStyle property that needs to not inherit
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
void 
CTimeAction::DisableStyleInheritance(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    VARIANT_BOOL         vbSuccess;

    Assert(bstrPropertyName);

    // Done if we've not set an expression.
    if (!m_pstrTimeExpr)
    {
        goto done;
    }

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the original expression before blowing it away
    if (!CacheOriginalExpression(bstrPropertyName))
    {
        IGNORE_HR(TIMEGetLastError());
    }

    IGNORE_HR(spStyle2->removeExpression(bstrPropertyName, &vbSuccess));

    // Indicate that we have removed our custom expression
    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = NULL;

done:
    if (FAILED(hr))
    {
        // For tracing
        IGNORE_HR(hr);
    }
    return;
} // DisableStyleInheritance


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::SetStyleProperty
//
//  Synopsis:   sets the given value on the given runtimeStyle property 
//
//  Arguments:  property name and value
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::SetStyleProperty(BSTR bstrPropertyName, VARIANT & varPropertyValue)
{
    bool ok = false;
    HRESULT hr = E_FAIL;
    CComPtr<IHTMLStyle> spStyle;
    
    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->setAttribute(bstrPropertyName, varPropertyValue, VARIANT_FALSE));
    if (FAILED(hr))
    {
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // SetRuntimeProperty


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleStyleSelector
//
//  Synopsis:   When toggling on, set the active value on the runtimeStyle.
//              When toggling off, set an expression on the runtime style property 
//              to fake inheritance when inactive
//
//  Arguments:  on/off, property name, active and inactive value.
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleStyleSelector(bool on, BSTR bstrPropertyName, LPWSTR pstrActive, LPWSTR pstrInactive)
{
    bool ok = false;
    HRESULT hr = S_OK;
    CComVariant svarPropertyValue;
  
    if (on)
    {
        // Remove any expression set on the runtimeStyle property
        DisableStyleInheritance(bstrPropertyName);

        // Set the active value on the runtimeStyle property
        svarPropertyValue = pstrActive;
        if (NULL == V_BSTR(&svarPropertyValue))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (!SetStyleProperty(bstrPropertyName, svarPropertyValue))  
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }
    else
    {
        // Make the property inherit its value from the parent
        if (!EnableStyleInheritance(bstrPropertyName))
        {
            // If property could not be made to inherit, just set the inactive value
            svarPropertyValue = pstrInactive;

            if (NULL == V_BSTR(&svarPropertyValue))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            if (!SetStyleProperty(bstrPropertyName, svarPropertyValue))  
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleStyleSelector


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleBold
//
//  Synopsis:   Delegate to ToggleStyleSelector()
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleBold(bool on)
{
    HRESULT hr = S_OK;
    bool ok = false;

    CComBSTR sbstrPropertyName(WZ_FONTWEIGHT);
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = ToggleStyleSelector(on, sbstrPropertyName, WZ_BOLD, WZ_NORMAL);

done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleBold


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleItalic
//
//  Synopsis:   Delegate to ToggleStyleSelector()
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleItalic(bool on)
{
    HRESULT hr = S_OK;
    bool ok = false;

    CComBSTR sbstrPropertyName(WZ_FONTSTYLE);
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = ToggleStyleSelector(on, sbstrPropertyName, WZ_ITALIC, WZ_NORMAL);

done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleItalic


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleAnchor
//
//  Synopsis:   Handles A and AREA tags. Removes/Applies the href property. 
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleAnchor(bool on)
{
    bool ok = false;
    CComBSTR sbstr;
    HRESULT hr = S_OK;

    if (NULL == m_pstrIntrinsicTimeAction)
    {
        // nothing to toggle
        hr = S_OK;
        ok = true;
        goto done;
    }

    if (!GetElement())
    {
        goto done;
    }

    // dilipk: This will cause incorrect persistence if we save when element is inactive (ie6 bug #14218)
    if (on)
    {
        sbstr = SysAllocString(m_pstrIntrinsicTimeAction);
        if (sbstr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (TAGTYPE_A == m_tagType)
        {
            CComPtr<IHTMLAnchorElement> spAnchorElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAnchorElem->put_href(sbstr));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            // This is TAGTYPE_AREA

            CComPtr<IHTMLAreaElement> spAreaElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAreaElem->put_href(sbstr));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        // toggle timeAction off
        CComBSTR sbstrAttrName;
        sbstrAttrName = SysAllocString(WZ_HREF);
        if (sbstrAttrName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        VARIANT_BOOL vbSuccess = VARIANT_FALSE;
        hr = THR(GetElement()->removeAttribute(sbstrAttrName, VARIANT_FALSE, &vbSuccess));
        if (FAILED(hr))
        {
            goto done;
        }
        if (VARIANT_FALSE == vbSuccess)
        {
            hr = E_FAIL;
            goto done;
        }
    } // if (on)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleAnchor


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleIntrinsicTimeAction
//
//  Synopsis:   toggles the intrinsic timeAction values. 
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleIntrinsicTimeAction(bool on)
{
    bool ok = false;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComBSTR sbstr;
    CComPtr<IHTMLStyle2> spStyle2;
    
    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // if this is not a special tag, we have no work to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    //
    // Toggle the attribute value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            if (!ToggleBold(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            if (!ToggleItalic(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }

        case TAGTYPE_A:
        case TAGTYPE_AREA:
        {
            if (!ToggleAnchor(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    } // switch (m_tagType)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // ToggleIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::UpdateDefaultTimeAction
//
//  Synopsis:   Determines the default timeAction for the time element and sets it
//
//  Arguments:  none
//
//  Returns:    true  - Success
//              false - Failure   
//
//------------------------------------------------------------------------------------
bool
CTimeAction::UpdateDefaultTimeAction()
{
    TOKEN tokDefaultTimeAction;

    if (IsDetaching() || IsPageUnloading())
    {
        goto done;
    }

    // if the timeAction is set to the default, update it
    if (m_fUseDefault)
    {
        tokDefaultTimeAction = GetDefaultTimeAction();

        if (m_timeAction != tokDefaultTimeAction)
        {
            RemoveTimeAction();
            m_timeAction = tokDefaultTimeAction;
            AddTimeAction();
        }
    }

done:
    return true;
} // UpdateDefaultTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ParseTagName
//
//  Synopsis:   Parses the tag name and checks the scopeName to be "HTML" where required
//
//  Arguments:  none
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
void
CTimeAction::ParseTagName()
{
    CComBSTR sbstrTagName;

    if (TAGTYPE_UNINITIALIZED != m_tagType)
    {
        return;
    }

    // initialize tag type
    m_tagType = TAGTYPE_OTHER;

    if (GetElement() == NULL)
    {
        return;
    }

    // Get the tag name
    IGNORE_HR(GetElement()->get_tagName(&sbstrTagName));
    Assert(sbstrTagName.m_str);
    if (sbstrTagName)
    {
        // Parse the tag name
        if (0 == StrCmpIW(sbstrTagName, WZ_B))
        {
            m_tagType = TAGTYPE_B;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_I))
        {
            m_tagType = TAGTYPE_I;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_A))
        {
            m_tagType = TAGTYPE_A;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_EM))
        {
            m_tagType = TAGTYPE_EM;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_AREA))
        {
            m_tagType = TAGTYPE_AREA;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_STRONG))
        {
            m_tagType = TAGTYPE_STRONG;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_BODY) ||
                 0 == StrCmpIW(sbstrTagName, WZ_EXCL) ||
                 0 == StrCmpIW(sbstrTagName, WZ_PAR)  ||
                 0 == StrCmpIW(sbstrTagName, WZ_SEQUENCE))
        {
            // Is it better to use urn to differentiate time tags? (bug 14219, ie6)
            m_fContainerTag = true;
        }
    }

    // if it is special tag, try to ensure that the scopeName is "HTML"
    if (m_tagType != TAGTYPE_OTHER)
    {
        CComPtr<IHTMLElement2> spElement2;

        // Try to get the namespace
        HRESULT hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
        if (SUCCEEDED(hr))
        {
            CComBSTR sbstrScopeName;

            IGNORE_HR(spElement2->get_scopeName(&sbstrScopeName));
            // make sure the scope name is HTML
            if (sbstrScopeName && 0 != StrCmpIW(sbstrScopeName, WZ_HTML))
            {
                m_tagType = TAGTYPE_OTHER;
            }
        }

    }
} // ParseTagName


LPWSTR 
CTimeAction::GetTimeActionString()
{
    return m_pstrOrigAction;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::IsSpecialTag
//
//  Synopsis:   Checks the parsed tagName
//
//  Arguments:  none
//
//  Returns:    [true]      if the tag is a special tag (B, STRONG, I, EM, A, AREA) 
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::IsSpecialTag() 
{ 
    // Parse the HTML tag
    ParseTagName();

    return (m_tagType != TAGTYPE_OTHER); 
}


inline
bool
CTimeAction::IsInSequence()
{
    Assert(m_pTEB);
    return (m_pTEB->GetParent() && 
            m_pTEB->GetParent()->IsSequence());
}


inline
bool 
CTimeAction::IsContainerTag() 
{     
    // Parse the HTML tag
    ParseTagName();

    return m_fContainerTag; 
}


inline
bool 
CTimeAction::IsGroup() 
{     
    return (m_pTEB && m_pTEB->IsGroup());
}


inline
bool
CTimeAction::IsMedia()
{
    return (m_pTEB && m_pTEB->IsMedia());
}


inline
bool 
CTimeAction::IsPageUnloading()
{
    Assert(m_pTEB);
    return (m_pTEB->IsUnloading() || m_pTEB->IsBodyUnloading());
}


inline
bool 
CTimeAction::IsDetaching()
{
    Assert(m_pTEB);
    return (m_pTEB->IsDetaching());
}

inline
bool 
CTimeAction::IsLoaded()
{
    Assert(m_pTEB);
    return (m_pTEB->IsLoaded());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timeattr.cpp
//
//  Contents: ITIMEElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "tokens.h"


//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TEB CTIMEElementBase

                // Function Name // Class // Attr Accessor      // COM put_ fn          // COM get_ fn   // IDL Arg type
TIME_PERSIST_FN(TEB_Accelerate,    TEB,   GetAccelerateAttr,    base_put_accelerate,    base_get_accelerate,    VARIANT);
TIME_PERSIST_FN(TEB_AutoReverse,   TEB,   GetAutoReverseAttr,   base_put_autoReverse,   base_get_autoReverse,   VARIANT);
TIME_PERSIST_FN(TEB_Begin,         TEB,   GetBeginAttr,         base_put_begin,         base_get_begin,         VARIANT);
TIME_PERSIST_FN(TEB_Decelerate,    TEB,   GetDecelerateAttr,    base_put_decelerate,    base_get_decelerate,    VARIANT);
TIME_PERSIST_FN(TEB_Dur,           TEB,   GetDurAttr,           base_put_dur,           base_get_dur,           VARIANT);
TIME_PERSIST_FN(TEB_End,           TEB,   GetEndAttr,           base_put_end,           base_get_end,           VARIANT);
TIME_PERSIST_FN(TEB_EndSync,       TEB,   GetEndSyncAttr,       base_put_endSync,       base_get_endSync,       VT_BSTR);
TIME_PERSIST_FN(TEB_Fill,          TEB,   GetFillAttr,          base_put_fill,          base_get_fill,          VT_BSTR);
TIME_PERSIST_FN(TEB_Mute,          TEB,   GetMuteAttr,          base_put_mute,          base_get_mute,          VARIANT);
TIME_PERSIST_FN(TEB_RepeatCount,   TEB,   GetRepeatAttr,        base_put_repeatCount,   base_get_repeatCount,   VARIANT);
TIME_PERSIST_FN(TEB_RepeatDur,     TEB,   GetRepeatDurAttr,     base_put_repeatDur,     base_get_repeatDur,     VARIANT);
TIME_PERSIST_FN(TEB_Restart,       TEB,   GetRestartAttr,       base_put_restart,       base_get_restart,       VT_BSTR);
TIME_PERSIST_FN(TEB_Speed,         TEB,   GetSpeedAttr,         base_put_speed,         base_get_speed,         VARIANT);
TIME_PERSIST_FN(TEB_SyncTolerance, TEB,   GetSyncToleranceAttr, base_put_syncTolerance, base_get_syncTolerance, VARIANT);
TIME_PERSIST_FN(TEB_SyncBehavior,  TEB,   GetSyncBehaviorAttr,  base_put_syncBehavior,  base_get_syncBehavior,  VT_BSTR);
TIME_PERSIST_FN(TEB_SyncMaster,    TEB,   GetSyncMasterAttr,    base_put_syncMaster,    base_get_syncMaster,    VARIANT);
TIME_PERSIST_FN(TEB_TimeAction,    TEB,   GetTimeActionAttr,    base_put_timeAction,    base_get_timeAction,    VT_BSTR);
TIME_PERSIST_FN(TEB_TimeContainer, TEB,   GetTimeContainerAttr, base_put_timeContainer, base_get_timeContainer, VT_BSTR);
TIME_PERSIST_FN(TEB_UpdateMode,    TEB,   GetUpdateModeAttr,    base_put_updateMode,    base_get_updateMode,    VT_BSTR);
TIME_PERSIST_FN(TEB_Volume,        TEB,   GetVolumeAttr,        base_put_volume,        base_get_volume,        VARIANT);
TIME_PERSIST_FN(TEB_TransIn,       TEB,   GetTransInAttr,       base_put_transIn,       base_get_transIn,       VARIANT);
TIME_PERSIST_FN(TEB_TransOut,      TEB,   GetTransOutAttr,      base_put_transOut,      base_get_transOut,      VARIANT);



//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

//
// NOTE: timeContainer must preceed timeAction in the persistence map for correct results. (103374)
//

BEGIN_TIME_PERSISTENCE_MAP(CTIMEElementBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_ACCELERATE,       TEB_Accelerate )
    PERSISTENCE_MAP_ENTRY( WZ_AUTOREVERSE,      TEB_AutoReverse )
    PERSISTENCE_MAP_ENTRY( WZ_BEGIN,            TEB_Begin )
    PERSISTENCE_MAP_ENTRY( WZ_DECELERATE,       TEB_Decelerate )
    PERSISTENCE_MAP_ENTRY( WZ_DUR,              TEB_Dur )
    PERSISTENCE_MAP_ENTRY( WZ_END,              TEB_End )
    PERSISTENCE_MAP_ENTRY( WZ_ENDSYNC,          TEB_EndSync )
    PERSISTENCE_MAP_ENTRY( WZ_FILL,             TEB_Fill )
    PERSISTENCE_MAP_ENTRY( WZ_MUTE,             TEB_Mute )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATCOUNT,      TEB_RepeatCount )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATDUR,        TEB_RepeatDur )
    PERSISTENCE_MAP_ENTRY( WZ_RESTART,          TEB_Restart )
    PERSISTENCE_MAP_ENTRY( WZ_SPEED,            TEB_Speed )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCTOLERANCE,    TEB_SyncTolerance )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCBEHAVIOR,     TEB_SyncBehavior )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCMASTER,       TEB_SyncMaster )
    PERSISTENCE_MAP_ENTRY( WZ_TIMECONTAINER,    TEB_TimeContainer )
    PERSISTENCE_MAP_ENTRY( WZ_TIMEACTION,       TEB_TimeAction ) /* This should always come after timeContainer */
    PERSISTENCE_MAP_ENTRY( WZ_UPDATEMODE,       TEB_UpdateMode )
    PERSISTENCE_MAP_ENTRY( WZ_VOLUME,           TEB_Volume )
    PERSISTENCE_MAP_ENTRY( WZ_TRANSIN,          TEB_TransIn )
    PERSISTENCE_MAP_ENTRY( WZ_TRANSOUT,         TEB_TransOut )
    
END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelm.h"

DeclareTag(tagTimeElm, "TIME: Behavior", "CTIMEElement methods");

// static class data.
DWORD CTIMEElement::ms_dwNumTimeElems = 0;

CTIMEElement::CTIMEElement()
{
    m_clsid = __uuidof(CTIMEElement);
    TraceTag((tagTimeElm,
              "CTIMEElement(%lx)::CTIMEElement()",
              this));
    CTIMEElement::ms_dwNumTimeElems++;
}

CTIMEElement::~CTIMEElement()
{
    CTIMEElement::ms_dwNumTimeElems--;
}


HRESULT
CTIMEElement::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>::Error(str, IID_ITIMEElement, hr);
        delete [] str;
    }

    return hr;
}

//*****************************************************************************

HRESULT 
CTIMEElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


STDMETHODIMP
CTIMEElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
}

STDMETHODIMP
CTIMEElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\timeelm.h
//
//  Contents: TIME behavior
//
//------------------------------------------------------------------------------------


#pragma once


#ifndef _TIMEELM_H
#define _TIMEELM_H

#include "timeelmimpl.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEElement
//
//--------------------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEElement :
    public CTIMEElementImpl<ITIMEElement, &IID_ITIMEElement>,
    public CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEElement>,
    public IConnectionPointContainerImpl<CTIMEElement>,
    public IPersistPropertyBag2,
    public ITIMETransitionSite,
    public IPropertyNotifySinkCP<CTIMEElement>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEElement();
    virtual ~CTIMEElement();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEElement"); }
#endif

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite)(void)
    { return CTIMEElementBase::InitTransitionSite(); }
    STDMETHOD(DetachTransitionSite)(void)
    { return CTIMEElementBase::DetachTransitionSite(); }
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b)
    { return CTIMEElementBase::SetDrawFlag(b); }
    STDMETHOD(get_node)(ITIMENode ** ppNode)
    { return CTIMEElementBase::get_node(ppNode); }
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode)
    { return CTIMEElementBase::get_timeParentNode(ppNode); }
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event)
    { return CTIMEElementBase::FireTransitionEvent(event); }

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMETransitionSite)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEElement* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:
    
    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    // Misc. methods
    //

    HRESULT Error();

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    static DWORD            ms_dwNumTimeElems;

private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------
 
}; // CTIMEElement




//+---------------------------------------------------------------------------------
//  CTIMEElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEElement::InternalQueryInterface(CTIMEElement* pThis,
                                     const _ATL_INTMAP_ENTRY* pEntries,
                                     REFIID iid,
                                     void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}


#endif /* _TIMEELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeelmbase.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: timeelmbase.cpp
//
//  Contents: TIME Behavior base class
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "..\tags\bodyelm.h"
#include "currtimestate.h"
#include "util.h"
#include "mmseq.h"
#include "mmexcl.h"
#include "mmmedia.h"
#include "trans.h"
#include "transdepend.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

static OLECHAR *g_szRepeatCount = L"Iteration";

//+-----------------------------------------------------------------------------
//
//  Trace Tags
//
//------------------------------------------------------------------------------
DeclareTag(tagTimeElmBase, "TIME: Behavior", "CTIMEElementBase methods");
DeclareTag(tagTimeElmBaseEvents, "TIME: Behavior", "CTIMEElementBase Events");
DeclareTag(tagTimeElmUpdateTimeAction, "TIME : Behavior", "UpdateTimeAction");
DeclareTag(tagTimeElmBaseNeedFill, "TIME: Behavior", "CTIMEElementBase::NeedFill");
DeclareTag(tagTimeTransitionFill, "SMIL Transitions", "Transition fill dependents");

//+-----------------------------------------------------------------------------
//
//  Static Variables
//
//------------------------------------------------------------------------------
DWORD CTIMEElementBase::s_cAtomTableRef = 0;
CAtomTable *CTIMEElementBase::s_pAtomTable = NULL;

static const IID IID_IThumbnailView = {0x7bb0b520,0xb1a7,0x11d2,{0xbb,0x23,0x0,0xc0,0x4f,0x79,0xab,0xcd}};
// Error strings used when  string table resource fails to load
static const LPWSTR WZ_ERROR_STRING_FORMAT  = L"Invalid argument! ID:'%.100ls'; Member:'%.100ls'; Value:'%.800ls'";
static const long MAX_ERR_STRING_LEN = 1024;

//+-----------------------------------------------------------------------------
//
//  Default Values for properties
//
//------------------------------------------------------------------------------
#define DEFAULT_M_DUR valueNotSet
#define DEFAULT_M_END NULL
#define DEFAULT_M_ENDSYNC NULL
#define DEFAULT_M_REPEAT 1
#define DEFAULT_M_REPEATDUR valueNotSet
#define DEFAULT_M_TIMELINETYPE ttUninitialized
#define DEFAULT_M_SYNCBEHAVIOR INVALID_TOKEN
#define DEFAULT_M_SYNCTOLERANCE valueNotSet
#define DEFAULT_M_PTIMEPARENT NULL
#define DEFAULT_M_ID NULL
#define DEFAULT_M_MMBVR NULL
#define DEFAULT_M_BSTARTED false
#define DEFAULT_M_PCOLLECTIONCACHE NULL
#define DEFAULT_M_TIMELINE NULL
#define DEFAULT_M_ACCELERATE 0.0f
#define DEFAULT_M_DECELERATE 0.0f
#define DEFAULT_M_BAUTOREVERSE false
#define DEFAULT_M_FLTSPEED 1.0f
#define DEFAULT_M_BLOADED false,
#define DEFAULT_M_FILL REMOVE_TOKEN
#define DEFAULT_M_RESTART ALWAYS_TOKEN
#define DEFAULT_M_FTIMELINEINITIALIZED false
#define DEFAULT_M_REALBEGINTIME valueNotSet
#define DEFAULT_M_REALDURATION valueNotSet
#define DEFAULT_M_REALREPEATTIME valueNotSet
#define DEFAULT_M_REALREPEATCOUNT valueNotSet
#define DEFAULT_M_REALREPEATINTERVALDURATION valueNotSet
#define DEFAULT_M_PROPERTYACCESFLAGS 0
#define DEFAULT_M_MLOFFSETWIDTH 0
#define DEFAULT_M_FLVOLUME 1.0f
#define DEFAULT_M_VBMUTE VARIANT_FALSE
#define DEFAULT_M_UPDATEMODE AUTO_TOKEN
#define DEFAULT_M_TRANSIN   NULL
#define DEFAULT_M_TRANSOUT  NULL


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::CTIMEElementBase
//
//  Synopsis:   Default Constructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------
CTIMEElementBase::CTIMEElementBase() :
    m_SABegin(NULL),
    m_FADur(DEFAULT_M_DUR), //lint !e747
    m_SAEnd(DEFAULT_M_END),
    m_SAEndSync(DEFAULT_M_ENDSYNC),
    m_FARepeat(DEFAULT_M_REPEAT), //lint !e747
    m_FARepeatDur(DEFAULT_M_REPEATDUR), //lint !e747
    m_privateRepeat(0),
    m_SATimeAction(NULL),
    m_timeAction(this),
    m_TTATimeContainer(ttUninitialized),
    m_TASyncBehavior(INVALID_TOKEN),
    m_FASyncTolerance(valueNotSet), //lint !e747
    m_pTIMEParent(DEFAULT_M_PTIMEPARENT),
    m_id(DEFAULT_M_ID),
    m_mmbvr(DEFAULT_M_MMBVR),
    m_bStarted(DEFAULT_M_BSTARTED),
    m_pCollectionCache(DEFAULT_M_PCOLLECTIONCACHE),
    m_timeline(DEFAULT_M_TIMELINE),
    m_FAAccelerate(DEFAULT_M_ACCELERATE),
    m_FADecelerate(DEFAULT_M_DECELERATE),
    m_BAAutoReverse(DEFAULT_M_BAUTOREVERSE),
    m_FASpeed(DEFAULT_M_FLTSPEED),
    m_TARestart(DEFAULT_M_RESTART),
    m_bLoaded(false),
    m_bUnloading(false),
    m_TAFill(DEFAULT_M_FILL),
    m_fTimelineInitialized(false),
    m_realDuration(valueNotSet),
    m_realRepeatTime(valueNotSet),
    m_realRepeatCount(valueNotSet),
    m_realIntervalDuration(valueNotSet),
    m_propertyAccesFlags(0),
    m_FAVolume(DEFAULT_M_FLVOLUME),
    m_BAMute(DEFAULT_M_VBMUTE),
    m_dLastRepeatEventNotifyTime(0.0),
    m_BASyncMaster(false),
    m_fCachedSyncMaster(false),
    m_sHasSyncMMediaChild(-1),
    m_fDetaching(false),
    m_TAUpdateMode(DEFAULT_M_UPDATEMODE),
    m_tokPriorityClassPeers(STOP_TOKEN),
    m_tokPriorityClassHigher(PAUSE_TOKEN),
    m_tokPriorityClassLower(DEFER_TOKEN),
    m_bIsSwitch(false),
    m_bBodyUnloading(false),
    m_bNeedDetach(false),
    m_bBodyDetaching(false),
    m_fUseDefaultFill(false),
    m_fHasPlayed(false),
    m_enumIsThumbnail(TSB_UNINITIALIZED),
    m_bReadyStateComplete(false),
    m_bAttachedAtomTable(false),
    m_fInTransitionDependentsList(false),
    m_fEndingTransition(false),
    m_ExtenalBodyTime(valueNotSet),
    m_SAtransIn(DEFAULT_M_TRANSIN),
    m_SAtransOut(DEFAULT_M_TRANSOUT),
    m_sptransIn(NULL),
    m_sptransOut(NULL),
    m_vbDrawFlag(VARIANT_TRUE),
    m_fHasWallClock(false),
    m_fLocalTimeDirty(true)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::CTIMEElementBase()",
              this));
 
    GetLocalTime(&m_timeSystemBeginTime);

    TEM_DECLARE_EVENTMGR();
} // CTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::~CTIMEElementBase
//
//  Synopsis:   Default Destructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------
CTIMEElementBase::~CTIMEElementBase()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::~CTIMEElementBase()",
              this));

    // delete attribute strings
    delete [] m_SABegin.GetValue();
    delete [] m_SAEnd.GetValue();
    delete [] m_SAEndSync.GetValue();
    delete [] m_SATimeAction.GetValue();
    delete [] m_SAtransIn.GetValue();
    delete [] m_SAtransOut.GetValue();

    // delete other strings
    delete [] m_id;
    delete m_mmbvr;

    // !!! Do not delete m_timeline since m_mmbvr points to the same
    // object
    m_mmbvr = NULL;
    m_timeline = NULL;

    if (m_pCollectionCache != NULL)
    {
        delete m_pCollectionCache;
        m_pCollectionCache = NULL;
    }
        
    m_pTIMEParent = NULL;

    TEM_FREE_EVENTMGR();

    // double check the children list
    Assert(m_pTIMEChildren.Size() == 0);

    if (m_pCurrTimeState)
    {
        m_pCurrTimeState->Deinit();
        m_pCurrTimeState.Release();
    }
    m_tokPriorityClassPeers = NULL;
    m_tokPriorityClassHigher = NULL;
    m_tokPriorityClassLower = NULL;
} // ~CTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::Init, IElementBehavior
//
//  Synopsis:   First method called by MSHTML after creation of this behavior
//
//  Arguments:  pointer to our bvr site
//
//  Returns:    [HRESULT]
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::Init(%p)",
              this,
              pBehaviorSite));
    
    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrTagName = NULL;
    CTIMEBodyElement *pBodyElement;
    CComPtr<ITIMEElement> pTIMEElem = NULL;
    CComPtr<IHTMLElement> spHTMLBodyElm;
    CComPtr<ITIMEBodyElement> spTIMEBodyElement;


    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetSyncBaseBody(GetElement(), &m_spBodyElemExternal);
    if(SUCCEEDED(hr) && m_spBodyElemExternal)
    {
        pBodyElement = GetTIMEBodyElement(m_spBodyElemExternal);
        if(pBodyElement && pBodyElement->IsReady())
        {
            m_ExtenalBodyTime = pBodyElement->GetMMBvr().GetActiveTime();
        }
    }

    // since we support t:par and t:sequence, get tag name and
    // see if we are one of the above.  By default, we are ttNone.
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_TTATimeContainer == ttUninitialized);

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttPar);
    }
    else if (StrCmpIW(bstrTagName, WZ_EXCL) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttExcl);
    }
    else if (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttSeq);
    }
    else if (StrCmpIW(bstrTagName, WZ_BODY) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttPar);
    }
    else if (StrCmpIW(bstrTagName, WZ_SWITCH) == 0)
    {
        m_bIsSwitch = true;
    }

    SysFreeString(bstrTagName);

    hr = CreateActiveEleCollection();
    if (FAILED(hr))
    {   
        goto done;
    }   

    // get ID of element and cache it
    hr = THR(GetElement()->get_id(&bstrID));
    if (SUCCEEDED(hr) && bstrID)
    {
        m_id = CopyString(bstrID);
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    SysFreeString(bstrID);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = TEM_INIT_EVENTMANAGER(m_pHTMLEle, pBehaviorSite);
    if (FAILED(hr))
    {
        goto done;
    }

    m_bAttachedAtomTable = true;
    // init atom table for collections
    hr = THR(InitAtomTable());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!IsBody())
    {
        hr = THR(AddBodyBehavior(GetElement()));
        if (FAILED(hr))
        {
            goto done;
        }

        if(!m_spBodyElemExternal)
        {
            // if we are not a body element, walk up the HTML tree looking for our TIME parent.
            hr = ParentElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            if (IsEmptyBody())
            {
                hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement,
                                        reinterpret_cast<void **>(&spHTMLBodyElm)));
                if(FAILED(hr))
                {
                    spHTMLBodyElm = NULL;
                }
                if (m_spBodyElemExternal && spHTMLBodyElm)
                {
                    hr = THR(m_spBodyElemExternal->QueryInterface(IID_ITIMEElement, (void **)&pTIMEElem));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    // get TIME interface
                    hr = FindBehaviorInterface(GetBehaviorName(),
                                               spHTMLBodyElm,
                                               IID_ITIMEBodyElement,
                                               (void**)&spTIMEBodyElement);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    pBodyElement = GetTIMEBodyElement(spTIMEBodyElement);
                    if(!pBodyElement)
                    {
                        goto done;
                    }
                    hr = pBodyElement->SetParent(pTIMEElem);

                    hr = THR(AddBodyBehavior(GetElement()));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
            }
            else
            {
                hr = ParentElement();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
    }

    // init the timeAction and toggle it
    m_timeAction.Init();
    UpdateTimeAction();

    SetupPriorityClassParent();
    
    hr = S_OK;
  done:
    return hr;
} // Init


void
CTIMEElementBase::SetupPriorityClassParent()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spParentElement;
    CComBSTR sBSTR;
    CComVariant sVariant;
    TOKEN tempToken;

    hr = m_pHTMLEle->get_parentElement(&spParentElement);
    if (FAILED(hr) || spParentElement == NULL)
    {
        goto done;
    }

    if (!::IsElementPriorityClass(spParentElement))
    {
        goto done;
    }

    // the parent of this element is a priority class element
    hr = spParentElement->getAttribute(L"peers", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr))
        {
            m_tokPriorityClassPeers = tempToken;
        }
    }
    
    hr = spParentElement->getAttribute(L"higher", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr) && 
            ( STOP_TOKEN == tempToken || PAUSE_TOKEN == tempToken ))
        {
            m_tokPriorityClassHigher = tempToken;
        }
    }
    hr = spParentElement->getAttribute(L"lower", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr) && 
            ( DEFER_TOKEN == tempToken || NEVER_TOKEN == tempToken ))
        {
            m_tokPriorityClassLower = tempToken;
        }
    }

done:
    return;    
}

STDMETHODIMP
CTIMEElementBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));

    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::Detach()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase(%p)::Detach()", this));
    CComPtr<ITIMEElement> pTIMEParent;

    if (GetBody() != NULL && GetBody()->IsBodyLoading() == true)
    {
        m_bNeedDetach = true;
        goto done;
    }

    m_fDetaching = true; // This flag is used to indicate that the element is gone
                         // do not remove or change the meaning of this flag.
    
    if (GetParent() != NULL && !IsUnloading())
    {
        IGNORE_HR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEParent)));
    }

    m_activeElementCollection.Release();

    IGNORE_HR(UnparentElement());

    // clear all children from holding a reference to ourselves
    // NOTE: this is a weak reference
    while (m_pTIMEChildren.Size() > 0)
    {
        CTIMEElementBase *pChild = m_pTIMEChildren[0];
        pChild->AddRef();
        pChild->SetParent(pTIMEParent, false);
            
        if (!IsUnloading())
        {
            // if we found a parent and it's timeline is present,
            // kick-start our root time.
            CTIMEElementBase *pElemNewParent = pChild->GetParent();
            if (pElemNewParent != NULL)
            {
                MMTimeline *tl = pElemNewParent->GetMMTimeline();
                if (tl != NULL)
                    pChild->StartRootTime(tl);
            }
        }
        pChild->Release();
    }
    m_pTIMEChildren.DeleteAll();

    CTIMEElementBase ** ppElm;
    int i;

    for (i = m_pTIMEZombiChildren.Size(), ppElm = m_pTIMEZombiChildren;
         i > 0;
         i--, ppElm++)
    {
        Assert(ppElm);
        if ((*ppElm))
        {
            (*ppElm)->Release();
        }
    }

    m_pTIMEZombiChildren.DeleteAll();

    //delete m_mmbvr;
    //m_mmbvr = NULL;

    // Do not delete m_timeline since it is the same object as
    // m_mmbvr
    m_timeline = NULL;
    
    m_timeAction.Detach();
    
    TEM_CLEANUP_EVENTMANAGER();

    IGNORE_HR(CBaseBvr::Detach());
    
    if (m_bAttachedAtomTable)
    {
        ReleaseAtomTable();
        m_bAttachedAtomTable = false;
    }

    RemoveFromTransitionDependents();

    RemoveTrans();

  done:

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// ITIMEElement base interfaces
/////////////////////////////////////////////////////////////////////

HRESULT
CTIMEElementBase::base_get_begin(VARIANT * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_get_begin()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_SABegin);

    hr = S_OK;
  done:
    return hr;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_put_begin
//
//  Synopsis:   Internal method for setting Begin
//
//  Arguments:  time    Variant that contains the attribute value string
//
//  Returns:    S_OK, Error
//
//------------------------------------------------------------------------------

HRESULT
CTIMEElementBase::base_put_begin(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_begin()",
              this));

    HRESULT hr;
    // Reset the old values
    m_realBeginValue.Clear();
    
    // prevent memory leak on 2nd+ calls
    delete [] m_SABegin.GetValue();
    m_SABegin.Reset(NULL);
    if (m_fLocalTimeDirty)
    {
        GetLocalTime(&m_timeSystemBeginTime);
        m_fLocalTimeDirty = false;
    }

    if(V_VT(&time) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &time,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }
    
        {
            LPWSTR lpwStr = CopyString(V_BSTR(&v));

            if (lpwStr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            m_SABegin.SetValue(lpwStr);
        }

        {
            CTIMEParser pParser(&v);
            
            IGNORE_HR(pParser.ParseTimeValueList(m_realBeginValue, &m_fHasWallClock, &m_timeSystemBeginTime));

            if (IsValidtvList(&m_realBeginValue) != true)
            {
                m_realBeginValue.Clear();
            }
        }
    }


    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(true, false));
    if (GetParent() && GetParent()->IsSequence() == false)
    {
        IGNORE_HR(TEM_SET_TIME_BEGINEVENT(m_realBeginValue));
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT_BEGIN);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_dur(VARIANT * time)
{
    HRESULT hr = S_OK;
    VARIANT fTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&fTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_FADur;

    if( m_FADur != INDEFINITE &&
        m_FADur >= 0.0 )
    {
        hr = THR(VariantChangeTypeEx(time, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (!SUCCEEDED(hr))
        {
            VariantClear(&fTemp);
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    VariantClear(&fTemp);
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_dur(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_dur()",
              this));

    HRESULT hr = E_FAIL;
    double dblTemp = DEFAULT_M_DUR;

    m_FADur.Reset(static_cast<float>(DEFAULT_M_DUR));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);
        
        hr = THR(pParser.ParseDur(dblTemp));
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblTemp < 0.0)
        {
            IGNORE_HR(ReportInvalidArg(WZ_DUR, time));
            // ignoring invalid arg as per smil-boston spec
        }
        else
        {
            m_FADur.SetValue(static_cast<float>(dblTemp));
        }
    }

    hr = S_OK;

  done:

    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_DUR);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_end(VARIANT * time)
{
    HRESULT hr;
    
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_SAEnd);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_end(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_end()",
              this));

    HRESULT hr;
    
    // Reset the old values
    m_realEndValue.Clear();
    m_SAEnd.Reset(NULL);

    if(V_VT(&time) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &time,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }

        {
            CTIMEParser pParser(&v);
            
            IGNORE_HR(pParser.ParseTimeValueList(m_realEndValue));
            
            if (IsValidtvList(&m_realEndValue) != true)
            {
                m_realEndValue.Clear();
            }
            else
            {
                LPWSTR lpwStr = CopyString(V_BSTR(&v));

                if (lpwStr == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                m_SAEnd.SetValue(lpwStr);
            }
        }
    }


    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, true));
    IGNORE_HR(TEM_SET_TIME_ENDEVENT(m_realEndValue));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_END);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_endSync(BSTR * time)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(time);

    *time = SysAllocString(m_SAEndSync);

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endSync(BSTR time)
{
    CComVariant v;
    HRESULT hr = S_OK;
    
    delete [] m_SAEndSync.GetValue();
    m_SAEndSync.Reset(DEFAULT_M_ENDSYNC);

    if (time != NULL)
    {
        LPWSTR pstrTemp = CopyString(time);
        if (NULL != pstrTemp)
        {
            m_SAEndSync.SetValue(pstrTemp);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_ENDSYNC);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeatCount(VARIANT * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_get_repeatCount(%g)",
              this,
              time));
    HRESULT hr = S_OK;
    // Still need to take in to consideration "infinite"
    
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if(m_FARepeat != INDEFINITE)
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_FARepeat;
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatCount(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_put_repeatCount(%g)",
              this,
              time));

    HRESULT hr = E_FAIL;
    
    m_FARepeat.Reset(static_cast<float>(DEFAULT_M_REPEAT));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);

        double dblTemp;
        hr = THR(pParser.ParseNumber(dblTemp));
        if (SUCCEEDED(hr))
        {
            if (0.0 < dblTemp)
            {
                m_FARepeat.SetValue((float) dblTemp);
            }
            else
            {
                IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, time));
            }
        }
    }

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_REPEATCOUNT);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_repeatDur(VARIANT * time)
{
    HRESULT hr = S_OK;
    VARIANT fTemp, bstrTemp;

    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if(m_FARepeatDur != INDEFINITE &&
       m_FARepeatDur >= 0.0f)
    {
        VariantInit(&fTemp);
        VariantInit(&bstrTemp);
        fTemp.vt = VT_R4;
        fTemp.fltVal = m_FARepeatDur;

        hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            time->vt = VT_BSTR;
            time->bstrVal = SysAllocString(bstrTemp.bstrVal);
        }
        else
        {
            time->vt = VT_R4;
            time->fltVal = fTemp.fltVal;
        }
        VariantClear(&fTemp);
        SysFreeString(bstrTemp.bstrVal);
        VariantClear(&bstrTemp);
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatDur(VARIANT time)
{
    HRESULT hr = E_FAIL;

    m_FARepeatDur.Reset(static_cast<float>(DEFAULT_M_REPEATDUR));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);

        double dblTemp = DEFAULT_M_REPEATDUR;
        hr = THR(pParser.ParseRepeatDur(dblTemp));
        if (S_OK == hr)
        {
            if (dblTemp < 0.0)
            {
                // don't want to pass negative values to the timing engine.
                IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, time));
            }
            else
            {
                m_FARepeatDur.SetValue((float) dblTemp);
            }
        }
    }

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_REPEATDUR);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_accelerate(VARIANT * v)
{
    HRESULT hr;

    CHECK_RETURN_NULL(v);

    hr = THR(VariantClear(v));
    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(v) = VT_R4;
    V_R4(v) = m_FAAccelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_accelerate(VARIANT v)
{
    HRESULT hr = S_OK;
    double e;

    m_FAAccelerate.Reset(DEFAULT_M_ACCELERATE);

    CTIMEParser pParser(&v);
            
    hr = pParser.ParseNumber(e);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }
    
    if (e < 0.0 || e > 1.0)
    {
        IGNORE_HR(ReportInvalidArg(WZ_ACCELERATE, v));
        goto done;
    }
    
    m_FAAccelerate.SetValue((float) e);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));
    
    NotifyPropertyChanged(DISPID_TIMEELEMENT_ACCELERATE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_decelerate(VARIANT * v)
{
    HRESULT hr;

    CHECK_RETURN_NULL(v);

    hr = THR(VariantClear(v));
    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(v) = VT_R4;
    V_R4(v) = m_FADecelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_decelerate(VARIANT v)
{
    HRESULT hr = S_OK;
    double e;
    
    m_FADecelerate.Reset(DEFAULT_M_DECELERATE);

    CTIMEParser pParser(&v);
            
    hr = pParser.ParseNumber(e);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }
    
    if (e < 0.0 || e > 1.0)
    {
        IGNORE_HR(ReportInvalidArg(WZ_DECELERATE, v));
        goto done;
    }
    
    m_FADecelerate.SetValue((float) e);
    
    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_DECELERATE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_autoReverse(VARIANT * b)
{
    CHECK_RETURN_NULL(b);

    VariantInit(b);
    b->vt = VT_BOOL;
    b->boolVal = m_BAAutoReverse?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_autoReverse(VARIANT b)
{
    HRESULT hr;
    bool fTemp = false;
    if (b.vt != VT_BOOL)
    {
        CTIMEParser pParser(&b);
        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = b.boolVal?true:false;
    }

    m_BAAutoReverse.SetValue(fTemp);

    hr = S_OK;

  done:
    // We always set the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_AUTOREVERSE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_speed(VARIANT * f)
{
    CHECK_RETURN_NULL(f);

    VariantInit(f);
    f->vt = VT_R4;
    f->fltVal = m_FASpeed;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_speed(VARIANT f)
{
    HRESULT hr = S_OK;
    float fltSpeed = 0.0;

    m_FASpeed.Reset(DEFAULT_M_FLTSPEED);    
    if (f.vt != VT_R4)
    {
        double dblTemp = 0.0;
        CTIMEParser pParser(&f);
        hr = pParser.ParseNumber(dblTemp, true);
        if (FAILED(hr))
        {
            hr = S_OK;
            IGNORE_HR(ReportInvalidArg(WZ_SPEED, f));
            goto done;
        }
        fltSpeed = (float)dblTemp;
    }
    else
    {
        fltSpeed = f.fltVal;
    }

    if (fltSpeed == 0.0f)
    {
        IGNORE_HR(ReportInvalidArg(WZ_SPEED, f));
        goto done;
    }
    
    m_FASpeed.SetValue(fltSpeed);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SPEED);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_fill (BSTR *pbstrFill)
{
    HRESULT hr;

    CHECK_RETURN_NULL(pbstrFill);

    *pbstrFill = ::SysAllocString(TokenToString(m_TAFill));

    hr = S_OK;
done:
    RRETURN(hr);
} // base_get_fill

HRESULT
CTIMEElementBase::base_put_fill (BSTR bstrFill)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_fill(%ls)",
              this,
              bstrFill));

    HRESULT hr;

    m_TAFill.Reset(DEFAULT_M_FILL);

    if (bstrFill != NULL)
    {
        TOKEN tokFillVal;
        CTIMEParser pParser(bstrFill);

        hr = THR(pParser.ParseFill(tokFillVal));
        if (S_OK == hr)
        {
            m_TAFill.SetValue(tokFillVal);
        }
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));
    UpdateTimeAction();

    NotifyPropertyChanged(DISPID_TIMEELEMENT_FILL);
    RRETURN(hr);
} // base_put_fill

HRESULT
CTIMEElementBase::base_get_restart (LPOLESTR *pRestart)
{
    HRESULT hr;

    CHECK_RETURN_NULL(pRestart);

    *pRestart = ::SysAllocString(TokenToString(m_TARestart));

    hr = S_OK;
  done:
    RRETURN(hr);
} // base_get_restart

HRESULT
CTIMEElementBase::base_put_restart(LPOLESTR pRestart)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_restart(%ls)",
              this,
              pRestart));

    HRESULT hr;

    m_TARestart.Reset(DEFAULT_M_RESTART);

    if (pRestart != NULL)
    {
        TOKEN tokRestartVal;
        CTIMEParser pParser(pRestart);

        hr = THR(pParser.ParseRestart(tokRestartVal));

        if (S_OK == hr)
        {
            m_TARestart.SetValue(tokRestartVal);
        }
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_RESTART);
    RRETURN(hr);
} // base_put_restart


HRESULT
CTIMEElementBase::base_get_timeAction(BSTR * pbstrTimeAction)
{
    CHECK_RETURN_NULL(pbstrTimeAction);

    *pbstrTimeAction = SysAllocString(m_SATimeAction.GetValue());
    RRETURN(S_OK);
}


HRESULT
CTIMEElementBase::base_put_timeAction(BSTR bstrTimeAction)
{
    HRESULT hr;
    LPOLESTR pstrTimeAction = NULL;

    // reset the attribute
    delete [] m_SATimeAction.GetValue();
    m_SATimeAction.Reset(NULL);

    // ISSUE: dilipk: this should be delayed till all of persistence is complete (for timeContainer)
    // also should use the parser here

    pstrTimeAction = TrimCopyString(bstrTimeAction);
    if (!pstrTimeAction)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
  
    // delegate to helper
    hr = m_timeAction.SetTimeAction(pstrTimeAction);
    if (FAILED(hr))
    {
        // fire error event
        CComVariant svarTimeAction(bstrTimeAction);
        ReportInvalidArg(WZ_TIMEACTION, svarTimeAction);
        goto done;
    }

    // update the timeAction
    UpdateTimeAction();

    // Update the attribute
    m_SATimeAction.SetValue(pstrTimeAction);

    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMEACTION);

    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeContainer(LPOLESTR * pbstrTimeLine)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(pbstrTimeLine);
    LPWSTR wszTimelineString = WZ_NONE;

    switch(m_TTATimeContainer)
    {
      case ttPar :
        wszTimelineString = WZ_PAR;
        break;
      case ttExcl:
        wszTimelineString = WZ_EXCL;
        break;
      case ttSeq :
        wszTimelineString = WZ_SEQUENCE;
        break;
      default:
        wszTimelineString = WZ_NONE;
    }

    *pbstrTimeLine = SysAllocString(wszTimelineString);
    if (NULL == *pbstrTimeLine)
        hr = E_OUTOFMEMORY;

    return hr;
} // base_get_timeContainer


// Note this is a DOM-read-only property. It can only be set through persistence.
HRESULT
CTIMEElementBase::base_put_timeContainer(LPOLESTR bstrNewTimeline)
{
    HRESULT      hr = S_OK;
    BSTR         bstrTagName = NULL;
    TimelineType newTimelineType = ttNone;
    TimelineType oldTimelineType = m_TTATimeContainer.GetValue();

    CHECK_RETURN_NULL(bstrNewTimeline);

    if (m_TTATimeContainer.IsSet() == false && m_TTATimeContainer != ttUninitialized && !IsBody())
    {
        goto done;
    }
    
    // Bail if property is being dynamically changed. It can only be set through persistence.
    // Just being defensive here (property is read-only in the IDL) since bad things 
    // can happen if this property is changed outside of persistence.
    if (m_fTimelineInitialized)
    {
        hr = E_FAIL;
        goto done;
    }
    
    // Parse the property
    {
        CTIMEParser pParser(bstrNewTimeline);
        
        hr = THR(pParser.ParseTimeLine(newTimelineType));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //
    // Check for early exit
    //

    // Bail if old and new value are same
    if (oldTimelineType == newTimelineType)
    {
        hr = S_OK;
        goto done;
    }
    // Bail if TagName is invalid
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }
    if (StrCmpIW(bstrTagName, WZ_PAR) == 0 || 
        StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0 || 
        StrCmpIW(bstrTagName, WZ_EXCL) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    m_TTATimeContainer.Reset(ttUninitialized);
    // Store the new attribute value
    m_TTATimeContainer.SetValue(newTimelineType);

    hr = CreateActiveEleCollection();
    if (FAILED(hr))
    {   
        goto done;
    }   


    hr = S_OK;
done:
    SysFreeString(bstrTagName);
    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECONTAINER);
    RRETURN(hr);
} // base_put_timeContainer

HRESULT
CTIMEElementBase::base_get_syncBehavior(LPOLESTR * ppstrSync)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(ppstrSync);

    if (DEFAULT_M_SYNCBEHAVIOR == m_TASyncBehavior.GetValue())
    {
        *ppstrSync = SysAllocString(TokenToString(CANSLIP_TOKEN));
    }
    else
    {
        *ppstrSync = SysAllocString(TokenToString(m_TASyncBehavior.GetValue()));
    }

    if (*ppstrSync == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncBehavior(LPOLESTR pstrSync)
{
    HRESULT hr;

    m_TASyncBehavior.Reset(NULL);

    {
        TOKEN tok_sync;
        CTIMEParser pParser(pstrSync);
        
        hr = THR(pParser.ParseSyncBehavior(tok_sync));
        if (S_OK == hr)
        {
            m_TASyncBehavior.SetValue(tok_sync);
        }
    }
    
    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCBEHAVIOR);
    RRETURN(hr);
}


HRESULT
CTIMEElementBase::base_get_syncTolerance(VARIANT * time)
{
    HRESULT hr;
    CComVariant varTemp;
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(&varTemp) = VT_R4;
    V_R4(&varTemp)= m_FASyncTolerance.GetValue();

    hr = THR(VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        hr = ::VariantCopy(time, &varTemp);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_FASyncTolerance.GetValue();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_put_syncTolerance(VARIANT time)
{
    HRESULT hr = S_OK;
    double dblTemp;

    m_FASyncTolerance.Reset((float)valueNotSet);

    CTIMEParser pParser(&time);
        
    hr = THR(pParser.ParseClockValue(dblTemp));
    if (S_OK == hr)
    {
        m_FASyncTolerance.SetValue((float) dblTemp);
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCTOLERANCE);
    RRETURN(hr);
}


HRESULT 
CTIMEElementBase::base_get_volume(VARIANT * vVal)
{
    CHECK_RETURN_NULL(vVal);

    VariantInit(vVal);
    vVal->vt = VT_R4;
    vVal->fltVal = m_FAVolume * 100;

    return S_OK;
}


HRESULT 
CTIMEElementBase::base_put_volume(VARIANT vVal)
{
    HRESULT hr = S_OK;
    float fltVol = 0.0;

    m_FAVolume.Reset(DEFAULT_M_FLVOLUME);
    if (vVal.vt != VT_R4)
    {
        double dblTemp = 0.0;
        CTIMEParser pParser(&vVal);
        hr = pParser.ParseNumber(dblTemp, true);
        if (FAILED(hr))
        {
            hr = S_OK;
            IGNORE_HR(ReportInvalidArg(WZ_VOLUME, vVal));
            goto done;
        }
        fltVol = (float)dblTemp;
    }
    else
    {
        fltVol = vVal.fltVal;
    }

    if (fltVol < 0.0f || fltVol > 100.0f)
    {
        IGNORE_HR(ReportInvalidArg(WZ_VOLUME, vVal));
        goto done;
    }
    
    fltVol = fltVol / 100.0f;
    m_FAVolume.SetValue(fltVol);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call CascadedPropertyChanged
    IGNORE_HR(CascadedPropertyChanged(true));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_VOLUME);
    return hr;
}

    
HRESULT 
CTIMEElementBase::base_get_mute(VARIANT * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);

    VariantInit(pvbVal);
    pvbVal->vt = VT_BOOL;
    pvbVal->boolVal = m_BAMute ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


HRESULT 
CTIMEElementBase::base_put_mute(VARIANT vbVal)
{
    HRESULT hr;
    bool fTemp = false;    

    if (vbVal.vt != VT_BOOL)
    {
        CTIMEParser pParser(&vbVal);
        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = vbVal.boolVal?true:false;
    }
        
    m_BAMute.SetValue(fTemp);

    hr = S_OK;
done:
    // We always set the attribute, so we should always call CascadedPropertyChanged
    hr = THR(CascadedPropertyChanged(true));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_MUTE);
    return hr;
}

HRESULT
CTIMEElementBase::base_pauseElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_pauseElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Pause());
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_resumeElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_resumeElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Resume());
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_resetElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_resetElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Reset(false));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// Update animation on seek if we are in edit mode since the timer is disabled. 
// Taking the conservative approach of detecting
// seeks at the seek methods instead of responding to the seek event.
void            
CTIMEElementBase::HandleAnimationSeek()
{
    if (IsDocumentInEditMode())
    {
        CTIMEBodyElement * pBody = GetBody();

        if (pBody)
        {
            // need to update twice to account for time boundaries
            pBody->UpdateAnimations();
            pBody->UpdateAnimations();
        }
    }
}


HRESULT
CTIMEElementBase::base_seekSegmentTime(double segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekSegmentTime(%g)",
              this,
              segmentTime));
 
    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekSegmentTime(segmentTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_seekActiveTime(double activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekActiveTime(%g)",
              this,
              activeTime));
 
    HRESULT hr;

    if (!IsReady() || !IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekActiveTime(activeTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_seekTo(LONG lRepeatCount,
                              double segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekSegmentTime(%ld, %g)",
              this,
              lRepeatCount,
              segmentTime));
 
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekTo(lRepeatCount, segmentTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_beginElement(double dblOffset)
{
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    if (GetParent() && GetParent()->IsSequence())
    {
        hr = S_OK;
        goto done;
    }

    hr =THR(BeginElement(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_endElement(double dblOffset)
{
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->End(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_nextElement()
{
    HRESULT hr;

    if (IsSequence())
    {
        if (m_timeline)
        {
            hr = m_timeline->nextElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_prevElement()
{
    HRESULT hr;

    if (IsSequence())
    {
        if (m_timeline)
        {
            hr = m_timeline->prevElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    hr = S_OK;

  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_get_currTimeState
//
//  Synopsis:   Returns currTimeState object for this element
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER, E_OUTOFMEMORY
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::base_get_currTimeState(ITIMEState ** ppTimeState) 
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppTimeState);

    //
    // Do lazy creation of currTimeState object
    //

    if (!m_pCurrTimeState)
    {
        CComObject<CTIMECurrTimeState> * pTimeState = NULL;

        hr = THR(CComObject<CTIMECurrTimeState>::CreateInstance(&pTimeState));
        if (FAILED(hr))
        {
            goto done;
        }

        // cache a pointer to the timeState object
        m_pCurrTimeState = static_cast<CTIMECurrTimeState*>(pTimeState);

        // Init the currTimeState object
        m_pCurrTimeState->Init(this);
    }

    // Return the dispatch
    hr = THR(m_pCurrTimeState->QueryInterface(IID_TO_PPV(ITIMEState, ppTimeState)));
    if (FAILED(hr))
    {
        // This should not happen
        Assert(false);
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} // base_get_currTimeState


HRESULT 
CTIMEElementBase::base_get_activeElements(ITIMEActiveElementCollection **ppDisp)
{

    HRESULT hr = S_OK;
    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::base_get_activeElements - invalid arg"));
        hr = E_POINTER;
        goto done;
    }
    
    *ppDisp = NULL;

    if (m_activeElementCollection)
    {
        hr = THR(m_activeElementCollection->QueryInterface(IID_ITIMEActiveElementCollection, (void**)ppDisp));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_hasMedia(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);

    *pvbVal = (ContainsMediaElement() ? VARIANT_TRUE : VARIANT_FALSE);

    return S_OK;
}


HRESULT
CTIMEElementBase::base_get_timeAll(ITIMEElementCollection **allColl)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeAll"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(allColl);

    hr = THR(GetCollection(ciAllElements, allColl));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeChildren(ITIMEElementCollection **childColl)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeChildren"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(childColl);

    hr = THR(GetCollection(ciChildrenElements, childColl));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeParent(ITIMEElement **ppElm)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeParent"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppElm);

    if (m_pTIMEParent != NULL)
    {
        hr = THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)ppElm));
        if (FAILED(hr))
        {
            goto done;
        } 
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_get_isPaused
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_get_isPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_isPaused"));

    HRESULT hr;

    CHECK_RETURN_NULL(b);

    *b = IsPaused() ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_syncMaster(VARIANT *pfSyncMaster)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_syncMaster"));

    HRESULT hr;

    CHECK_RETURN_NULL(pfSyncMaster);

    VariantInit(pfSyncMaster);
    pfSyncMaster->vt = VT_BOOL;
    pfSyncMaster->boolVal = m_BASyncMaster ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::ClearCachedSyncMaster()
{
    HRESULT hr = S_OK;

    if (m_fCachedSyncMaster != m_BASyncMaster)
    {
        m_fCachedSyncMaster = m_BASyncMaster;

        hr = THR(m_mmbvr->Update(false, false));
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::PutCachedSyncMaster(bool fSyncMaster)
{
    HRESULT hr = S_OK;
    m_fCachedSyncMaster = fSyncMaster;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    SetSyncMaster(fSyncMaster);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncMaster(VARIANT vSyncMaster)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_put_syncMaster"));
    HRESULT hr;
    bool fTemp = false;
    CTIMEElementBase *syncRootNode = NULL;
    std::list<CTIMEElementBase*> syncList;
    std::list<CTIMEElementBase*>::iterator iter;
    bool fFound = false;

    if (vSyncMaster.vt != VT_BOOL)
    {

        CTIMEParser pParser(&vSyncMaster);

        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = vSyncMaster.boolVal?true:false;
    }

    if(!IsReady()) //set the persisted value only when loading the page.
    {
        m_BASyncMaster.SetValue(fTemp);
    }

    if(!IsMedia() || !IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    syncRootNode = FindLockedParent();
    if(syncRootNode == NULL)
    {
        hr = S_OK;
        goto done;
    }
    syncRootNode->GetSyncMasterList(syncList);
    if(fTemp)
    {
        for (iter = syncList.begin();iter != syncList.end(); iter++)
        {
            if((*iter)->IsSyncMaster())
            {
                (*iter)->SetSyncMaster(false);
            }
        }
        SetSyncMaster(true);
    }
    else
    {
        SetSyncMaster(false);
        if(syncList.size() >= 1)
        {
            for (iter = syncList.begin();iter != syncList.end(); iter++)
            {
                if((*iter)->m_BASyncMaster && ((*iter) != this))
                {
                    (*iter)->SetSyncMaster(true);
                    fFound = true;
                    break;
                }
            }
            if(!fFound)
            {
                for (iter = syncList.begin();iter != syncList.end(); iter++)
                {
                    if((*iter) != this)
                    {
                        (*iter)->SetSyncMaster(true);
                        fFound = true;
                        break;
                    }
                }
            }

        }
    }


    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCMASTER);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_documentTimeToParentTime(double documentTime,
                                                double * parentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_documentTimeToParentTime(%g)",
              documentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(parentTime);

    if (!IsReady())
    {
        *parentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *parentTime = m_mmbvr->DocumentTimeToParentTime(documentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_parentTimeToDocumentTime(double parentTime,
                                                double * documentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_parentTimeToDocumentTime(%g)",
              parentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(documentTime);

    if (!IsReady())
    {
        *documentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *documentTime = m_mmbvr->ParentTimeToDocumentTime(parentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_parentTimeToActiveTime(double parentTime,
                                              double * activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_parentTimeToActiveTime(%g)",
              parentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(activeTime);

    if (!IsReady())
    {
        *activeTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *activeTime = m_mmbvr->ParentTimeToActiveTime(parentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_activeTimeToParentTime(double activeTime,
                                              double * parentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_activeTimeToParentTime(%g)",
              activeTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(parentTime);

    if (!IsReady())
    {
        *parentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *parentTime = m_mmbvr->ActiveTimeToParentTime(activeTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_activeTimeToSegmentTime(double activeTime,
                                               double * segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_activeTimeToSegmentTime(%g)",
              activeTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(segmentTime);

    if (!IsReady())
    {
        *segmentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *segmentTime = m_mmbvr->ActiveTimeToSegmentTime(activeTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_segmentTimeToActiveTime(double segmentTime,
                                               double * activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_segmentTimeToActiveTime(%g)",
              segmentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(activeTime);

    if (!IsReady())
    {
        *activeTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *activeTime = m_mmbvr->SegmentTimeToActiveTime(segmentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_segmentTimeToSimpleTime(double segmentTime,
                                               double * simpleTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_segmentTimeToSimpleTime(%g)",
              segmentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(simpleTime);

    if (!IsReady())
    {
        *simpleTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *simpleTime = m_mmbvr->SegmentTimeToSimpleTime(segmentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_simpleTimeToSegmentTime(double simpleTime,
                                               double * segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_simpleTimeToSegmentTime(%g)",
              simpleTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(segmentTime);

    if (!IsReady())
    {
        *segmentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *segmentTime = m_mmbvr->SimpleTimeToSegmentTime(simpleTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::BeginElement(double dblOffset)
{
    HRESULT hr;

    m_mmbvr->Resume();
    
    hr = THR(m_mmbvr->Begin(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
    

HRESULT
CTIMEElementBase::AddTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    elm->AddRef(); // add refing for m_pTIMEChildren
 
    hr = THR(m_pTIMEChildren.Append(elm));
    if (FAILED(hr))
    {
        goto done;
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECHILDREN);

done:
    return hr;
}

HRESULT
CTIMEElementBase::RemoveTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    bool bFound = m_pTIMEChildren.DeleteByValue(elm);
    if (!bFound)
    {
        // no real error returned.  should fix up the array code...
        goto done;
    }

    IGNORE_HR(m_pTIMEZombiChildren.Append(elm));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECHILDREN);

done:
    return hr;
}

//*****************************************************************************
// method:   ReparentChildren()
//
// abstract: this method walks down an HTML tree, reparenting children that
//           have TIME behaviors to this TIME element.
//           Note:  if we find a TIME element that is a group, we need to stop.
//*****************************************************************************
HRESULT
CTIMEElementBase::ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pElem)
{
    CComPtr<IDispatch>               pChildrenDisp;
    CComPtr<IHTMLElementCollection>  pChildrenCollection;
    VARIANT varName;
    VARIANT varIndex;
    HRESULT hr;
    long    lChildren = 0;
    long    i;

    if (pElem == NULL)
    {
        hr = E_FAIL;
        Assert(false && "CTIMEElementBase::ReparentChildren was passed a NULL!");
        goto done;
    }

    // get pointer to children
    hr = THR(pElem->get_children(&pChildrenDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenDisp.p != NULL);

    // move to collection interface
    hr = THR(pChildrenDisp->QueryInterface(IID_IHTMLElementCollection, (void**)&pChildrenCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenCollection.p != NULL);

    // get length
    hr = THR(pChildrenCollection->get_length(&lChildren));
    if (FAILED(hr))
    {
        goto done;     
    }

    // Variants for IHTMLElementCollection->item() call.
    // NOTE: we are using first Variant as an index.  The second variant
    //       is along for the ride.  The second variant only comes into play
    //       when you use the first variant as a name and multiple names exist.
    //       Then, the second can act as a index.
    VariantInit(&varName);
    varName.vt = VT_I4;
    varName.lVal = 0;

    VariantInit(&varIndex);

    // loop thru children
    for (i = 0; i < lChildren; i++)
    {
        CComPtr<IDispatch>       pChildDisp;
        CComPtr<ITIMEElement>    pTIMEElem;
        CComPtr<IHTMLElement>    pChildElement;
        CTIMEElementBase *pTempTEB = NULL;

        varName.lVal = i;

        // get indexed child
        hr = THR(pChildrenCollection->item(varName, varIndex, &pChildDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(pChildDisp.p != NULL);

        // get IHTMLElement
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChildElement));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // Is there a TIME behavior on this element
        pTIMEElem = NULL;
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pChildElement,
                                   IID_ITIMEElement,
                                   (void**)&pTIMEElem);
        if (SUCCEEDED(hr))
        {
            Assert(pTIMEElem.p != NULL);
            pTempTEB = GetTIMEElementBase(pTIMEElem);
            
            Assert(pTempTEB != NULL);

            // set parent.  do not set children
            hr = pTempTEB->SetParent(pTIMEParent, false);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        // if NO TIME was found or the TIME element is not a group
        // continue walking down the tree
        if ( (pTIMEElem.p == NULL) || 
             ((pTempTEB != NULL) && !pTempTEB->IsGroup()) )
        {
            hr = ReparentChildren(pTIMEParent, pChildElement);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // for loop

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************
// method:   UnparentElement()
//
// abstract: this is a centralized method that knows how to detach a TIME element
//           from it's parent (if it has one).  There only two cases when this is
//           called.  Either you are shutting down (ie ::detach()) or you are being
//           reparented (ie SetParent() with new parent).
//*****************************************************************************
HRESULT
CTIMEElementBase::UnparentElement()
{
    HRESULT hr;

    // stop timeline
    if (m_bStarted)
    {
        MMTimeline * tl = NULL;
        if (m_pTIMEParent != NULL)
            tl = m_pTIMEParent->GetMMTimeline();
        StopRootTime(tl);
    }

    if (m_pTIMEParent != NULL)
    {
        // if the parent is around, traverse back up, invalidating the collection cache.
        THR(InvalidateCollectionCache());
    
        // clear ourselves from our parents list
        hr = THR(m_pTIMEParent->RemoveTIMEElement(this));
        if (FAILED(hr))
        {
            goto done;
        }
    
        // these are both week references and we should NULL them since
        // we have no parent and are not associated with the inner TIME
        // heirarchy.
        m_pTIMEParent = NULL;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::SetParent(ITIMEElement *pElem, bool fReparentChildren /* true */)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pTempTEB = NULL;

    // for the body return with an error
    if (IsBody())
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - error trying to parent a body element"));
        hr = E_UNEXPECTED;
        goto done;
    }

    // if we already have a parent, remove ourselves from it's child list
    if (m_pTIMEParent != NULL)
    {
        CComPtr<ITIMEElement> pParent;

        // PERF: if the parent coming in is equal to current parent, make it a nop
        // NOTE: this can never fail!
        THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)&pParent));
        if (pParent == pElem)
        {
            hr = S_OK;
            goto done;
        }

        // need to unparent element.
        hr = UnparentElement();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::SetParent(%p) - UnparentElement() failed", this));
            goto done;
        }
    }

    Assert(m_pTIMEParent == NULL);

    // if NULL was passed in, our work is done
    if (pElem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    // move from the interface pointer to the class pointer
    pTempTEB = GetTIMEElementBase(pElem);
    if (pTempTEB == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - GetTIMEElementBase() failed"));
        hr = E_INVALIDARG;
        goto done;
    }

    // add ourselves as a child
    hr = THR(pTempTEB->AddTIMEElement(this));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the parent
    // this is a weak reference
    m_pTIMEParent = pTempTEB;

    // Force an update of the default timeAction
    m_timeAction.UpdateDefaultTimeAction();
    UpdateTimeAction();

    // reparent any children of this HTML element that have children, if we
    // are a group.
    if (fReparentChildren && IsGroup())
    {
        CComPtr<ITIMEElement> pTIMEElem;

        // This should ALWAYS work
        THR(QueryInterface(IID_ITIMEElement, (void**)&pTIMEElem));
        Assert(pTIMEElem.p != NULL);
        hr = ReparentChildren(pTIMEElem, GetElement());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Tell subtree to recalculate cascaded properties
    THR(hr = CascadedPropertyChanged(true));

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::ParentElement()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement"));
    // Loop thru parents until one is found with TIME on it
    bool fFound = false;
    bool fBehaviorExists = false;
    CComPtr<IHTMLElement> pElem = GetElement();
    CComPtr<IHTMLElement> pElemParent = NULL;
    CComPtr<ITIMEElement> pTIMEElem = NULL;
    HRESULT hr = S_FALSE;

    Assert(!IsBody());

    // walk up the HTML tree, looking for element's with TIME behaviors on them
    while (!fFound)
    {
        CComPtr<ITIMEElement> spTIMEParent;

        hr = THR(pElem->get_parentElement(&pElemParent));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - get_parentElement() failed"));
            goto done;
        }

        // see if we have a parent
        // If not, this is an orphaned case
        if (pElemParent.p == NULL)
        {
            TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement - orphaned node!!!"));
            hr = S_FALSE;
            goto done;
        }

        // see if TIME behavior exists on parent
        fBehaviorExists = false;
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pElemParent,
                                   IID_ITIMEElement,
                                   (void**)&spTIMEParent);
        if (FAILED(hr))
        {
            fBehaviorExists = false;
        }
        else
        {
            fBehaviorExists = true;
        }

        // if this element has a TIME behavior and is either a 
        // par or seq, then we have found our parent.
        if (fBehaviorExists && IsGroup(pElemParent))
        {
            fFound = true;
        }
        else
        {
            // continue walking up the tree
            pElem = pElemParent;
            pElemParent.Release();
        }
    }

    // if we found a parent with TIME, add our selves to it's children

    Assert(fFound);
    if (pElemParent.p != NULL)
    {
        // get TIME interface
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pElemParent,
                                   IID_ITIMEElement,
                                   (void**)&pTIMEElem);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - FindTIMEInterface() failed"));
            goto done;
        }
        
        Assert(pTIMEElem.p != NULL);

        // set our parent
        hr = THR(SetParent(pTIMEElem));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - SetParent() failed"));
            goto done;
        }
        hr = S_OK;
    }

done:

    return hr;
}

HRESULT
CTIMEElementBase::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        goto done;
    }

    Assert(!m_bStarted);

    if (m_bIsSwitch)
    {
        SwitchInnerElements();
    }
    else
    {
        IHTMLElement *pEle = GetElement();  //do not release this pointer
        if (pEle != NULL)
        {
            CComPtr <IHTMLElement> pEleParent;
            hr = THR(pEle->get_parentElement(&pEleParent));
            if (SUCCEEDED(hr) && pEleParent != NULL)
            {
                CComBSTR bstrTagName;
                hr = THR(pEleParent->get_tagName(&bstrTagName));
                if (SUCCEEDED(hr))
                {
                    if (StrCmpIW(bstrTagName, WZ_SWITCH) != 0)
                    {
                        CComPtr <IDispatch> pDisp;
                        hr = THR(pEle->QueryInterface(IID_IDispatch, (void**)&pDisp));
                        if (SUCCEEDED(hr))
                        {
                            //bool bMatch = true;
                            bool bMatch = MatchTestAttributes(pDisp);
                            if (bMatch == false)
                            {
                                DisableElement(pDisp);
                            }
                        }
                    }
                }
            }
        }
    }

    m_bStarted = true;

    hr = THR(Update());
    if (FAILED(hr))
    {
        goto done;
    } 

    Assert(tl || m_timeline);
    Assert(NULL != m_mmbvr);

    // Need to make sure the timeline passed in
    if (tl != NULL)
    {
        hr = THR(tl->AddBehavior(*m_mmbvr));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        // Usually the add does the reset (automatic when a parent is
        // changed
        // However, this is the root and it does not get updated until
        // too late so update here

        hr = THR(m_mmbvr->Reset(false));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (GetBody() && GetBody()->IsRootStarted())
    {
        GetBody()->ElementChangeNotify(*this, ELM_ADDED);
    }
    
    // is this element a par or seq
    if (IsGroup())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(m_timeline);
        
            hr = THR((*ppElm)->StartRootTime(m_timeline));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        // If we are not par then we should not have children
        Assert(m_pTIMEChildren.Size() == 0);
    }

    if(GetBody() != NULL)
    {
        if(IsMedia() && !IsThumbnail())
        {
            GetBody()->RegisterElementForSync(this);
        }
    }

    short i;
    CTIMEElementBase **ppElm;

    for (i = 0, ppElm = m_pTIMEChildren; i < m_pTIMEChildren.Size();i++, ppElm++)
    {
        if((*ppElm)->IsLocked() && (m_sHasSyncMMediaChild == -1))
        {
            if((*ppElm)->IsSyncMaster() || ((*ppElm)->m_sHasSyncMMediaChild != -1))
            {
                m_sHasSyncMMediaChild = i;
            }
        }
        else if((*ppElm)->IsLocked() && (m_sHasSyncMMediaChild != -1))
        {
            if((*ppElm)->IsSyncMaster() || ((*ppElm)->m_sHasSyncMMediaChild != -1))
            {
                RemoveSyncMasterFromBranch(*ppElm);
            }
        }
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        StopRootTime(tl);
    }
    
    RRETURN(hr);
}

void
CTIMEElementBase::StopRootTime(MMTimeline * tl)
{
    CTIMEElementBase *pElem = NULL;
    Assert(NULL != m_mmbvr);

    // Begin Sync master code
    if(IsSyncMaster() || m_sHasSyncMMediaChild != -1)
    {
        if(((pElem = GetParent()) != NULL) && (pElem->m_sHasSyncMMediaChild != -1))
        {
            if(pElem->m_pTIMEChildren[pElem->m_sHasSyncMMediaChild] == this)
            {
                pElem->m_sHasSyncMMediaChild = -1;
            }
        }
    }
    // End Sync master code

    if(IsMedia() && !IsThumbnail() && GetBody() != NULL)
    {
        GetBody()->UnRegisterElementForSync(this);
    }

    if (tl != NULL)
    {
        tl->RemoveBehavior(*m_mmbvr);
    }

    // if this a par or seq, then process children
    if (IsGroup())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(m_timeline);
            (*ppElm)->StopRootTime(m_timeline);
        }
    }
    else
    {
        // If we are not par then we should not have children
        Assert(m_pTIMEChildren.Size() == 0);
    }
    
    if (GetBody() && GetBody()->IsRootStarted() && !IsUnloading())
    {
        GetBody()->ElementChangeNotify(*this, ELM_DELETED);
    }
    
    m_bStarted = false;

    return;
}

HRESULT
CTIMEElementBase::Update()
{
    HRESULT hr;

    // bail if still loading properties or we haven't started playing 
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(UpdateMMAPI(true, true));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEElementBase::CalcTimes()
{
    //
    // Since repeat defaults to 1 and the time engine takes the min of repeat and RepeatDur,
    // we need to set repeat to infinity if repeat is not set and repeatDur is set. 
    //

    if (m_FARepeatDur.IsSet())
    {
        if (m_FARepeat.IsSet())
        {
            m_realRepeatCount = m_FARepeat;
        }
        else
        {
            m_realRepeatCount = static_cast<float>(TIME_INFINITE);
        }
    }
    else
    {
        m_realRepeatCount = m_FARepeat;
    }
    
    if (m_FADur != valueNotSet)
    {
        m_realDuration = m_FADur;
    }
    else 
    {
        m_realDuration = INDEFINITE;
    }
    
    if (m_realDuration == 0.0f)
    {
        m_realDuration = INDEFINITE;
    }
 
    if (m_BAAutoReverse && (HUGE_VAL != m_realDuration))
    {
        m_realIntervalDuration = m_realDuration * 2;
    }
    else
    {
        m_realIntervalDuration = m_realDuration;
    }
    
    if (m_FARepeatDur != valueNotSet)
    {
        m_realRepeatTime = m_FARepeatDur;
    }
    else
    {
        m_realRepeatTime = m_FARepeat * m_realIntervalDuration;
    }
    
}


bool
CTIMEElementBase::AddTimeAction()
{
    return m_timeAction.AddTimeAction();
}

bool
CTIMEElementBase::RemoveTimeAction()
{
    return m_timeAction.RemoveTimeAction();
}

bool
CTIMEElementBase::ToggleTimeAction(bool on)
{
    if (m_timeline)
    {
        m_timeline->toggleTimeAction(on);
    }
    return m_timeAction.ToggleTimeAction(on);
}

bool
CTIMEElementBase::IsSequencedElementOn (void)
{
    bool fOn = m_mmbvr->IsOn();
    bool fActive = m_mmbvr->IsActive();

    // IsOn will return true for an element
    // even when the time container's rules
    // dictate that it should be off.
    Assert(GetParent() != NULL);
    Assert(GetParent()->IsSequence());

    if ((fOn) && (!fActive))
    {
        // on and !active and fill=hold --> on
        if (GetFill() == HOLD_TOKEN)
        {
            TraceTag((tagTimeElmUpdateTimeAction, 
                      "SEQ(%ls) : IsOn = %ls fill=hold",
                      GetID(),
                      m_mmbvr->IsOn() ? L"true" : L"false"
                     ));
            goto done;
        }
        // on and !active and fill = transition
        // we're on iff we're still a pending 
        // transition dependent.
        else if (GetFill() == TRANSITION_TOKEN)
        {
            fOn = (fOn && m_fInTransitionDependentsList && (!m_fEndingTransition));
        }
        else if (GetFill() == FREEZE_TOKEN)
        {
            // !active and to the left of the successor element's begin.
            CTIMEElementBase *ptebParent = GetParent();
            CPtrAry<CTIMEElementBase*> *paryPeers = (&ptebParent->m_pTIMEChildren);
            int iThis = paryPeers->Find(this);

            // If we're the last item in the sequence, 
            // assume the IsOn result is good.
            if (ptebParent->GetImmediateChildCount() > (iThis + 1))
            {
                // Get our successor element in the sequence.
                CTIMEElementBase *ptebNext = paryPeers->Item(iThis + 1);

                Assert(NULL != ptebNext);
                if (NULL != ptebNext)
                {
                    // Find out whether we are to the left of 
                    // our successors' begin time.
                    CComPtr<ITIMEState> spParentState;
                    CComPtr<ITIMEState> spSuccessorState;

                    HRESULT hr = THR(ptebParent->base_get_currTimeState(&spParentState));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    
                    hr = THR(ptebNext->base_get_currTimeState(&spSuccessorState));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    {
                        double dblParentTime = 0.0;
                        double dblSuccessorBeginTime = 0.0;

                        THR(spSuccessorState->get_parentTimeBegin(&dblSuccessorBeginTime));
                        THR(spParentState->get_segmentTime(&dblParentTime));

                        // If we're to the left of our successor's begin time,
                        // we should be on.
                        if (dblParentTime >= dblSuccessorBeginTime)
                        {
                            fOn = false;
                            TraceTag((tagTimeElmUpdateTimeAction, 
                                      "SEQ(%ls) : fOn=false fill=freeze parent=%g succ.begin=%g",
                                      GetID(),
                                      dblParentTime, dblSuccessorBeginTime
                                     ));
                        }
                        else
                        {
                            TraceTag((tagTimeElmUpdateTimeAction, 
                                      "SEQ(%ls) : fOn=true fill=freeze parent=%g succ.begin=%g",
                                      GetID(),
                                      dblParentTime, dblSuccessorBeginTime
                                     ));
                        }
                    }
                }
            }
            else
            {
                TraceTag((tagTimeElmUpdateTimeAction, 
                          "SEQ(%ls) : IsOn = %ls last child in sequence",
                          GetID(),
                          m_mmbvr->IsOn() ? L"true" : L"false"
                         ));
            }
        }
    }
    else 
    {
        TraceTag((tagTimeElmUpdateTimeAction, 
                  "SEQ(%ls) : IsOn = %ls IsActive = %ls",
                  GetID(),
                  m_mmbvr->IsOn() ? L"true" : L"false",
                  m_mmbvr->IsActive() ? L"true" : L"false"
                 ));
    }

done :
    return fOn;
}

void
CTIMEElementBase::UpdateTimeAction()
{
    bool fOn = false;

    if (m_mmbvr != NULL)
    {
        fOn = m_mmbvr->IsOn();

        if (GetParent() != NULL)
        {

            // Permit the applicable container to 
            // influence the element's state.
            if (GetParent()->IsSequence() == true)
            {
                fOn = IsSequencedElementOn();
            }
            else if (GetParent()->IsExcl() == true)
            {
                fOn = (   fOn 
                       && (   (m_mmbvr->IsActive() == true) 
                           || (GetFill() != FREEZE_TOKEN))
                      );
            }
            else
            {
                // Catch all for fill=transition.  
                // m_fEndingTransition is only on during OnEndTransition.
                fOn = (fOn && (!m_fEndingTransition));
            }
        }
    }
    else
    {
        fOn = false;
    }

    // If we're shutting ourselves off, and we might be in the 
    // transition dependent list, pull out of it.

    if (false == fOn)
    {
       RemoveFromTransitionDependents();
    }

    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::UpdateTimeAction(%ls, %ls)",
              this, m_id, fOn ? L"on" : L"off"));

    ToggleTimeAction(fOn);    
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::GetRuntimeStyle
//
//  Synopsis:   Tries to get Runtime style. If that fails (IE4), tries to get static style.
//
//  Arguments:  [s]     output variable
//
//  Returns:    [E_POINTER]     if bad arg 
//              [S_OK]          if got runtime or static style
//              [E_FAIL]        otherwise
//
//------------------------------------------------------------------------------

STDMETHODIMP
CTIMEElementBase::GetRuntimeStyle(IHTMLStyle ** s)
{
    CComPtr<IHTMLElement2> pElement2;
    HRESULT hr;

    CHECK_RETURN_SET_NULL(s);

    if (!GetElement())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    
    if (SUCCEEDED(hr))
    {
       if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(s))))
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        // IE4 path
        hr = THR(GetElement()->get_style(s));
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // GetRuntimeStyle


HRESULT
CTIMEElementBase::FireEvent(TIME_EVENT TimeEvent,
                            double dblLocalTime,
                            DWORD flags,
                            long lRepeatCount)
{
    TraceTag((tagTimeElmBaseEvents,
              "CTIMEElementBase(%p, %ls)::FireEvent(%g, %d)",
              this,
              GetID()?GetID():L"Unknown",
              dblLocalTime,
              TimeEvent));
    
    HRESULT hr = S_OK;
    LPWSTR szParamNames[1]; 
    VARIANT varParams[1]; 
    VariantInit(&varParams[0]);
    szParamNames[0] = NULL;
    long lParamCount = 0;

    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }
    InitOnLoad();
    
    switch(TimeEvent)
    {
      case TE_ONBEGIN:
        OnBegin(dblLocalTime, flags);
        break;
      case TE_ONEND:
        OnEnd(dblLocalTime);
        break;
      case TE_ONPAUSE:
        OnPause(dblLocalTime);
        break;
      case TE_ONRESUME:
        OnResume(dblLocalTime);
        break;
      case TE_ONRESET:
        OnReset(dblLocalTime, flags);
        break;
      case TE_ONREPEAT:
        varParams[0].vt = VT_I4;
        varParams[0].lVal = lRepeatCount;
        szParamNames[0] = CopyString(g_szRepeatCount);
        lParamCount = 1;
        OnRepeat(dblLocalTime);
        break;
      case TE_ONSEEK:
        OnSeek(dblLocalTime);
        break;
      case TE_ONREVERSE:
        OnReverse(dblLocalTime);
        break;
      case TE_ONUPDATE:
        OnUpdate(dblLocalTime, flags);
        TimeEvent = TE_ONRESET;
        break;
      default:
        break;
    }

    if (!IsUnloading() && !IsDetaching())
    {        
        hr = FireEvents(TimeEvent, lParamCount, szParamNames, varParams);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (szParamNames[0])
    {
        delete [] szParamNames[0];
    }
    VariantClear(&varParams[0]);
    RRETURN(hr);
}

bool
CTIMEElementBase::ChildPropNotify(CTIMEElementBase & teb,
                                  DWORD & tePropType)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p, %ls)::ChildPropNotify(%p, %d)",
              this,
              GetID(),
              &teb,
              tePropType));

    HRESULT hr;
    
    if ((tePropType & TE_PROPERTY_ISACTIVE) != 0)
    {
        CActiveElementCollection *pElmCol = GetActiveElementCollection();

        if (teb.GetElement() != NULL &&
            pElmCol != NULL)
        {
            CComPtr<IUnknown> pUnk;

            hr = THR(teb.GetElement()->QueryInterface(IID_IUnknown, (void **)&pUnk));
            if (SUCCEEDED(hr))
            {
                if (teb.IsActive())
                {
                    IGNORE_HR(pElmCol->addActiveElement(pUnk));
                }
                else
                {
                    IGNORE_HR(pElmCol->removeActiveElement(pUnk));
                }
            }
        }
    }

    return true;
}

void 
CTIMEElementBase::UpdateEndEvents()
{
    if (IsBodyDetaching() == false)
    {
        TEM_TOGGLE_END_EVENT(IsActive());
    }
}

void 
CTIMEElementBase::OnReverse(double dblLocalTime)
{
    if (m_timeline != NULL)
    {
        m_timeline->reverse();
    }
}

void 
CTIMEElementBase::OnRepeat(double dbllastTime)
{
    if (m_timeline != NULL)
    {
        m_timeline->repeat();
    }
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::AddToTransitionDependents
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::AddToTransitionDependents()
{
    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::AddToTransitionDependents(%p)",
              this, 
              m_pHTMLEle));

    HRESULT             hr      = S_OK;
    CTIMEBodyElement *  pBody   = GetBody();

    Assert(!IsBody());

    AssertSz(pBody,
             "CTIMEElementBase::AddToTransitionDependents called and"
              " there's no CTIMEBodyElement from which we would get"
              " a CTransitionDependencyManager.");

    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->GetTransitionDependencyMgr()->AddDependent(this));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInTransitionDependentsList = true;

done:

    return;
}
//  Method: CTIMEElementBase::AddToTransitionDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::RemoveFromTransitionDependents
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::RemoveFromTransitionDependents()
{
    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::RemoveFromTransitionDependents(%p)",
              this, 
              m_pHTMLEle));

    HRESULT             hr      = S_OK;
    CTIMEBodyElement *  pBody   = GetBody();

    if (!m_fInTransitionDependentsList)
    {
        goto done;
    }

    Assert(!IsBody());

    AssertSz(pBody,
             "CTIMEElementBase::RemoveFromTransitionDependents called and"
              " there's no CTIMEBodyElement from which we would get"
              " a CTransitionDependencyManager.");

    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->GetTransitionDependencyMgr()->RemoveDependent(this));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInTransitionDependentsList = false;

done:

    return;
}
//  Method: CTIMEElementBase::RemoveFromTransitionDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnResolveDependent
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnResolveDependent(
                                    CTransitionDependencyManager * pcNewManager)
{
    // @@ ISSUE do we need to cache the new manager here?
    // All dependents are strongly referenced by their managers,
    // so we may be okay without this complexity.

    return S_OK;
}
//  Method: CTIMEElementBase::OnResolveDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnBeginTransition
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnBeginTransition (void)
{
    return S_OK;
}
//  Method: CTIMEElementBase::OnBeginTransition


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnEndTransition
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnEndTransition (void)
{
    m_fEndingTransition = true;
    UpdateTimeAction();
    m_fEndingTransition = false;

    return S_OK;
}
//  Method: CTIMEElementBase::OnEndTransition


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnBegin
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnBegin()",
              this));

    Assert(NULL != m_mmbvr->GetMMBvr());

    if (m_timeline != NULL)
    {
        m_timeline->begin();
    }

    if( !m_bUnloading)
    {
        UpdateTimeAction();
        m_dLastRepeatEventNotifyTime = 0.0;
    }

    if (IsGroup() && !IsBody())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            if ((*ppElm)->HasWallClock())
            {
                CComVariant beginTime;
                (*ppElm)->SetLocalTimeDirty(true);
                (*ppElm)->base_get_begin(&beginTime);
                (*ppElm)->base_put_begin(beginTime);
            }
        }
    }

    RemoveFromTransitionDependents();

    m_fHasPlayed = true;
}
//  Method: CTIMEElementBase::OnBegin


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnEnd
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnEnd()",
              this));
    
    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    if (m_timeline != NULL)
    {
        m_timeline->end();
    }

    if (GetFill() == TRANSITION_TOKEN)
    {
        AddToTransitionDependents();
    }

    // Code Review: We may have just called AddToTransitionDependents, and 
    // UpdateTimeAction may call RemoveFromTransitionDependents.  Do we know
    // for a fact that we won't accidentally undo our Add?

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnEnd


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnPause
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnPause(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnPause()",
              this)); 

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnPause


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnResume
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnResume(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnResume()",
              this));

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnResume


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnReset
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnReset()",
              this));

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnReset


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetSyncMaster
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::GetSyncMaster(double & dblNewSegmentTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetSyncMaster()",
              this));

    return S_FALSE;
}
//  Method: CTIMEElementBase::GetSyncMaster


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnTick
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnTick()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnTick()",
              this));
}
//  Method: CTIMEElementBase::OnTick


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnTEPropChange
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnTEPropChange(DWORD tePropType)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnTEPropChange(%#x)",
              this,
              tePropType));

    if(m_fDetaching)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SIMPLETIME);
        NotifyTimeStateChange(DISPID_TIMESTATE_SEGMENTTIME);
        NotifyTimeStateChange(DISPID_TIMESTATE_ACTIVETIME);
    }
    
    if ((tePropType & TE_PROPERTY_PROGRESS) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PROGRESS);
    }
    
    // Optimize for the common case of only the time/progress changing
    if (tePropType == (TE_PROPERTY_TIME | TE_PROPERTY_PROGRESS))
    {
        goto done;
    }
    
    if ((tePropType & TE_PROPERTY_REPEATCOUNT) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_REPEATCOUNT);
    }
    
    if ((tePropType & TE_PROPERTY_SEGMENTDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SEGMENTDUR);
    }
    
    if ((tePropType & TE_PROPERTY_IMPLICITDUR) != 0)
    {
    }
    
    if ((tePropType & TE_PROPERTY_SIMPLEDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SIMPLEDUR);
    }
    
    if ((tePropType & TE_PROPERTY_ACTIVEDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_ACTIVEDUR);
    }
    
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SPEED);
    }
    
    if ((tePropType & TE_PROPERTY_BEGINPARENTTIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PARENTTIMEBEGIN);
    }
    
    if ((tePropType & TE_PROPERTY_ENDPARENTTIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PARENTTIMEEND);
    }
    
    if ((tePropType & TE_PROPERTY_ISACTIVE) != 0)
    {
        UpdateEndEvents();
        NotifyTimeStateChange(DISPID_TIMESTATE_ISACTIVE);
    }
    
    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        UpdateTimeAction();
        NotifyTimeStateChange(DISPID_TIMESTATE_ISON);
    }
    
    if ((tePropType & TE_PROPERTY_ISCURRPAUSED) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_ISPAUSED);
    }
    
    if ((tePropType & TE_PROPERTY_ISPAUSED) != 0)
    {
        NotifyPropertyChanged(DISPID_TIMEELEMENT_ISPAUSED);
    }
    
    if ((tePropType & TE_PROPERTY_STATEFLAGS) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
        NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    }

done:

    return;
}
//  Method: CTIMEElementBase::OnTEPropChange


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnSeek
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnSeek(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnSeek()",
              this)); 

    if (m_timeline != NULL)
    {
        m_timeline->seek(dblLocalTime);
    }

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnSeek


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnLoad
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnLoad()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnLoad()",
              this));

    if (m_bLoaded == true)
    {
        //don't load a second time
        goto done;
    }

    m_bLoaded = true;

    if (m_bNeedDetach == true)
    {
        Detach();
        goto done;
    }

    // notify and update the timeAction. This is required because
    // this is the earliest we can know that Element Behaviors have finished initalizing.
    m_timeAction.OnLoad();

    if (m_timeline != NULL)
    {
        m_timeline->load();
    }
    
    UpdateTimeAction();

    //check to see if this element has already been disabled.
    if (GetElement() != NULL)
    {
        CComBSTR bstrSwitch = WZ_SWITCHCHILDDISABLED;
        VARIANT vValue;
        HRESULT hr = S_OK;
        VariantInit(&vValue);
        hr = GetElement()->getAttribute(bstrSwitch, 0, &vValue);
        if (SUCCEEDED(hr))
        {
            if (vValue.vt == VT_BOOL && vValue.boolVal == VARIANT_TRUE)
            {
                CComPtr <IDispatch> pDisp;
                hr = THR(GetElement()->QueryInterface(IID_IDispatch, (void**)&pDisp));
                if (SUCCEEDED(hr))
                {
                    DisableElement(pDisp);
                }
            }
        }
        VariantClear(&vValue);
    }

    if ( IsTransitionPresent() )
    {
        CreateTrans();
    }

done:

    return;
}
//  Method: CTIMEElementBase::OnLoad


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::DisableElement
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::DisableElement(IDispatch *pEleDisp)
{
    //hide the element and set it's begin to indefinite.
    CComPtr <IHTMLStyle> pStyle;
    CComPtr <IHTMLElement> pEle;
    CComPtr <ITIMEElement> pTimeElement;
    CComPtr <IHTMLElement2> pEle2;
    HRESULT hr = S_OK;
    int k = 0;

    if (GetParent() == NULL)
    {
        goto done;
    }

    hr = THR(pEleDisp->QueryInterface(IID_IHTMLElement, (void**)&pEle));
    if (FAILED(hr))
    {
        goto done;
    }       

    hr = FindBehaviorInterface(GetBehaviorName(),
                               pEleDisp,
                               IID_ITIMEElement,
                               (void**)&pTimeElement);
    if (SUCCEEDED(hr))
    {
        //need to find the time element that is associated with this object.
        int iTimeEleCount = GetParent()->m_pTIMEChildren.Size();
        CTIMEElementBase *pEleBase = NULL;
        CComPtr <IUnknown> pTimeEleUnk;

        hr = THR(pTimeElement->QueryInterface(IID_IUnknown, (void**)&pTimeEleUnk));
        if (SUCCEEDED(hr))
        {
            CComPtr<IUnknown> pEleUnk;
            for (k = 0; k < iTimeEleCount; k++)
            {
                pEleBase = GetParent()->m_pTIMEChildren.Item(k);
                if (pEleBase != NULL)
                {   
                    pEleUnk.Release();
                    hr = THR(pEleBase->QueryInterface(IID_IUnknown, (void**)&pEleUnk));
                    if (SUCCEEDED(hr))
                    {
                        if (pEleUnk == pTimeEleUnk)
                        {
                            pEleBase->GetMMBvr().SetEnabled(false);
                            pEleBase->GetMMBvr().Update(true, true);
                        }
                    }
                }
            }
        }
    }

    hr = THR(pEle->QueryInterface(IID_IHTMLElement2, (void**)&pEle2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEle2->get_runtimeStyle(&pStyle));
    if (SUCCEEDED(hr))
    {
        CComBSTR bstrDisplay = WZ_NONE;
        hr = THR(pStyle->put_display(bstrDisplay));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    {
        CComBSTR bstrDisabled = WZ_SWITCHCHILDDISABLED;
        VARIANT vTrue;
        VariantInit(&vTrue);
        vTrue.vt = VT_BOOL;
        vTrue.boolVal = VARIANT_TRUE;
        IGNORE_HR(pEle->setAttribute(bstrDisabled, vTrue, VARIANT_TRUE));
        VariantClear(&vTrue);
    }

    hr = S_OK;

  done:

    return hr;
}
//  Method: CTIMEElementBase::DisableElement


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::MatchTestAttributes
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::MatchTestAttributes(IDispatch *pEleDisp)
{
    HRESULT     hr                      = E_FAIL;
    CComBSTR    bstrLanguage            = L"systemLanguage";
    CComBSTR    bstrCaption             = L"systemCaptions";
    CComBSTR    bstrBitrate             = L"systemBitrate";
    CComBSTR    bstrOverdubOrCaptions   = L"systemOverdubOrSubtitle";
    LPWSTR      lpszUserLanguage        = NULL;
    LPWSTR *    szLanguageArray         = NULL;
    bool        bSystemCaption          = false;
    bool        bSystemOverdub          = false;
    bool        bNeedLanguageMatch      = false;
    bool        bIsLanguageMatch        = false;
    bool        bNeedCaptionMatch       = false;
    bool        bIsCaptionMatch         = false;
    bool        bNeedOverdubMatch       = false;
    bool        bIsOverdubMatch         = false;
    bool        bNeedBitrateMatch       = false;
    bool        bIsBitrateMatch         = false;
    bool        bMatched                = false;
    long        lLangCount              = 0;
    long        lSystemBitrate          = 0;
    int         i                       = 0;
    
    VARIANT     vLanguage;
    VARIANT     vCaption;
    VARIANT     vOverdub;
    VARIANT     vBitrate;    
    CComVariant vDur;
    CComVariant vBegin;

    CComPtr<IHTMLElement> pEle;   
    
    hr = THR(pEleDisp->QueryInterface(IID_IHTMLElement, (void**)&pEle));
    if (FAILED(hr))
    {
        goto done;
    }

    vDur.vt = VT_R4;
    vDur.fltVal = 0.0f;
    vBegin.vt = VT_BSTR;
    vBegin.bstrVal = SysAllocString(WZ_INDEFINITE);
    
    //get the system settings
    bSystemOverdub = GetSystemOverDub();
    bSystemCaption = GetSystemCaption();
    lpszUserLanguage = GetSystemLanguage(pEle);
    if (lpszUserLanguage == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    VariantInit(&vCaption);
    VariantInit(&vLanguage);
    VariantInit(&vOverdub);
    VariantInit(&vBitrate);
        
    //get the language attribute from the element.
    hr = pEle->getAttribute(bstrLanguage, 0, &vLanguage);
    if (SUCCEEDED(hr))
    {
        if (vLanguage.vt == VT_BSTR)
        {
            bNeedLanguageMatch = true;
            CTIMEParser pParser(&vLanguage);
            hr = pParser.ParseSystemLanguages(lLangCount, &szLanguageArray);
            if (SUCCEEDED(hr))
            {
                //determine if there is a match
                for (i = 0; i < lLangCount; i++)
                {
                    if (szLanguageArray[i] != NULL)
                    {
                        if (lstrlenW(szLanguageArray[i]) == 2)
                        {
                            if (StrCmpNIW(szLanguageArray[i], lpszUserLanguage, 2) == 0)
                            {
                                bIsLanguageMatch = true;
                            }
                        }
                        else
                        {
                            if (StrCmpIW(szLanguageArray[i], lpszUserLanguage) == 0)
                            {
                                bIsLanguageMatch = true;
                            }
                        }
                        // clean up the language list.
                        delete [] szLanguageArray[i];
                        szLanguageArray[i] = NULL;
                    }
                }
                delete [] szLanguageArray;
                szLanguageArray = NULL;
            }
        }
    }

    //get caption attribute
    hr = pEle->getAttribute(bstrCaption, 0, &vCaption);
    if (SUCCEEDED(hr))
    {
        if (vCaption.vt == VT_BSTR)
        {
            bNeedCaptionMatch = true;
            if (bSystemCaption)
            {
                bIsCaptionMatch = StrCmpIW(vCaption.bstrVal, L"on") == 0;
            }
            else
            {
                bIsCaptionMatch = StrCmpIW(vCaption.bstrVal, L"off") == 0;
            }
        }
    }

    //get the OverdubOrCaptions attribute
    hr = pEle->getAttribute(bstrOverdubOrCaptions, 0, &vOverdub);
    if (SUCCEEDED(hr))
    {
        if (vOverdub.vt == VT_BSTR)
        {
            bNeedOverdubMatch = true;
            if (bSystemOverdub)
            {
                bIsOverdubMatch = StrCmpIW(vOverdub.bstrVal, L"overdub") == 0;
            }
            else 
            {
                bIsOverdubMatch = StrCmpIW(vOverdub.bstrVal, L"subtitle") == 0;
            }
        }
    }

    //get the SystemBitrate attribute
    hr = pEle->getAttribute(bstrBitrate, 0, &vBitrate);
    if (SUCCEEDED(hr) && vBitrate.vt != VT_NULL)
    {
        bNeedBitrateMatch = true;
        hr = VariantChangeTypeEx(&vBitrate, &vBitrate, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (SUCCEEDED(hr))
        {
            LPWSTR lpszConnectType = GetSystemConnectionType();
            if (StrCmpIW(lpszConnectType, WZ_LAN) == 0)
            {
                bIsBitrateMatch = true;
            }
            else
            {
                long lSystemBitrate = 0;
                hr = GetSystemBitrate(&lSystemBitrate); 
                if (FAILED(hr) || lSystemBitrate >= vBitrate.lVal) 
                {
                    bIsBitrateMatch = true;
                }
            }
            delete [] lpszConnectType;
            lpszConnectType = NULL;
        }
    }

    if ((bIsLanguageMatch == true || bNeedLanguageMatch != true) &&
        (bIsCaptionMatch == true || bNeedCaptionMatch != true) &&
        (bIsOverdubMatch == true || bNeedOverdubMatch != true) &&
        (bIsBitrateMatch == true ||  bNeedBitrateMatch != true))
    {
        bMatched = true;
    }

done:

    VariantClear(&vLanguage);
    VariantClear(&vCaption);
    VariantClear(&vOverdub);
    VariantClear(&vBitrate);

    if (lpszUserLanguage)
    {
        delete [] lpszUserLanguage;
        lpszUserLanguage = NULL;
    }

    return bMatched;
}
//  Method: CTIMEElementBase::MatchTestAttributes


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SwitchInnerElements
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::SwitchInnerElements()
{
    HRESULT hr = E_FAIL;
    IHTMLElement *pEle = NULL; //do not release this
    CComPtr <IDispatch> pChildColDisp;
    CComPtr <IHTMLElementCollection> pChildCol;    
    VARIANT vName, vIndex;
    
    CComPtr <IDispatch> pChildDisp;
    CComPtr <IHTMLElement> pChild;

    long lChildCount = 0;
    bool bMatched = false;
    int j = 0;

    VariantInit(&vName);
    vName.vt = VT_I4;
    VariantInit(&vIndex);
    pEle = GetElement();
    if (pEle == NULL)
    {
        goto done;
    }
    
    //get all of the html children of this element.
    hr = pEle->get_children(&pChildColDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildColDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pChildCol);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = pChildCol->get_length(&lChildCount);
    if (FAILED(hr))
    {
        goto done;
    }

    //loop through the children until they are all queried or a match is found.
    for (j = 0; j < lChildCount; j++)
    {
        CComBSTR bstrTagName;
        pChildDisp.Release();
        pChild.Release();        
    
        vName.lVal = j;
    
        hr = pChildCol->item(vName, vIndex, &pChildDisp);
        if (FAILED(hr) || pChildDisp == NULL)
        {
            continue;
        }
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChild));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pChild->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            goto done;
        }
        if (!bMatched && StrCmpW(L"!", bstrTagName) != 0)
        {
            bMatched = MatchTestAttributes(pChildDisp);        
            if (bMatched == true)
            {
                bMatched = true;
                if (m_activeElementCollection)
                {
                    //do not call pUnk->Release() on add, it will be handled by the ActiveElement Collection
                    CComPtr<IUnknown> pUnk;
                    hr = THR(pChild->QueryInterface(IID_IUnknown, (void **)&pUnk));
                    if (SUCCEEDED(hr))
                    {
                        IGNORE_HR(m_activeElementCollection->addActiveElement(pUnk));
                    }
                }
            }
            else
            {
                hr = DisableElement(pChildDisp);
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        else //if no match then remove.
        { 
            hr = DisableElement(pChildDisp);
            if (FAILED(hr))
            {
                goto done;
            }
        }        
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SwitchInnerElements


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetPlayState
//
//------------------------------------------------------------------------------
TE_STATE
CTIMEElementBase::GetPlayState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetPlayState()",
              this));

    TE_STATE retState = TE_STATE_INACTIVE;

    if (NULL != m_mmbvr)
    {
        retState = m_mmbvr->GetPlayState();
    }

    return retState;
}
//  Method: CTIMEElementBase::GetPlayState


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTimeState
//
//------------------------------------------------------------------------------
TimeState
CTIMEElementBase::GetTimeState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetTimeState()",
              this));

    TimeState ts = TS_Inactive;

    if (!IsReady())
    {
        goto done;
    }

    if (m_mmbvr->IsActive())
    {
        ts = TS_Active;
    }
    else if (m_mmbvr->IsOn())
    {
        bool bTimeAction = m_timeAction.IsTimeActionOn();
        bool bIsInSeq = GetParent()->IsSequence();
        if (bIsInSeq && bTimeAction == false)
        {
            ts = TS_Inactive;
        }
        else
        {
            ts = TS_Holding;
        }
    }

done:

    return ts;
}
//  Method: CTIMEElementBase::GetTimeState

//
// Sneaky way to get a CTIMEElementBase out of an ITIMEElement:
//

class __declspec(uuid("AED49AA3-5C7A-11d2-AF2D-00A0C9A03B8C"))
TIMEElementBaseGUID {}; //lint !e753


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::BaseInternalQueryInterface
//
//------------------------------------------------------------------------------
HRESULT WINAPI
CTIMEElementBase::BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEElementBaseGUID))) 
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
//  Method: CTIMEElementBase::BaseInternalQueryInterface
    
    
//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTIMEElementBase
//
//  Notes:  This function does NOT return an addrefed outgoing CTIMEElementBase
//
//------------------------------------------------------------------------------
CTIMEElementBase *
GetTIMEElementBase(IUnknown * pInputUnknown)
{
    CTIMEElementBase * pTEB = NULL;

    if (pInputUnknown) 
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEElementBaseGUID),(void **)&pTEB);
    }
    
    if (pTEB == NULL) 
    {
        TIMESetLastError(E_INVALIDARG, NULL);
    }
                
    return pTEB;
}
//  Method: CTIMEElementBase::GetTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTIMEBodyElement
//
//  Notes:  This function does NOT return an addrefed outgoing CTIMEBodyElement
//
//------------------------------------------------------------------------------
CTIMEBodyElement *
GetTIMEBodyElement(ITIMEBodyElement * pInputUnknown)
{
    CTIMEBodyElement * pTEB = NULL;

    if (pInputUnknown) 
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEBodyElementBaseGUID),(void **)&pTEB);
    }
                
    return pTEB;
}
//  Method: CTIMEElementBase::GetTIMEBodyElement


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::getTagString
//
//  Overview:
//      Get Tag string from HTML element.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::getTagString(BSTR *pbstrID)
{
    return GetElement()->get_id(pbstrID);
}
//  Method: CTIMEElementBase::getTagString


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::getIDString
//
//  Overview:
//      Get ID string from HTML element.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::getIDString(BSTR *pbstrTag)
{
    return GetElement()->get_id(pbstrTag);
}
//  Method: CTIMEElementBase::getIDString


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::IsGroup
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::IsGroup(IHTMLElement *pElement)
{
    HRESULT hr;
    bool    rc = false;
    CComPtr<ITIMEElement> pTIMEElem;
    CComPtr<ITIMEBodyElement> pTIMEBody;
    BSTR  bstrTimeline = NULL;
    BSTR  bstrTagName = NULL;

    hr = FindBehaviorInterface(GetBehaviorName(),
                               pElement,
                               IID_ITIMEElement,
                               (void**)&pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = pTIMEElem->get_timeContainer(&bstrTimeline);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTimeline != NULL);

    // Check to see what the contents of the BSTR are.
    // If it is a seq, par or excl, we want to return true.
    if ( (bstrTimeline != NULL) && 
         ((StrCmpIW(bstrTimeline, WZ_PAR) == 0) || 
          (StrCmpIW(bstrTimeline, WZ_EXCL) == 0) || 
          (StrCmpIW(bstrTimeline, WZ_SEQUENCE) == 0)) )
    {
         rc = true;
         goto done;
    }
    
    // check to see if it is the body element.
    // if so, then the element is *always" a group.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (SUCCEEDED(hr))
    {
         rc = true;
         goto done;
    }

    // see if the tag name is <t:par> or <t:seq>
    hr = THR(pElement->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTagName != NULL);

    if ( (StrCmpIW(bstrTagName, WZ_PAR) == 0) || 
         (StrCmpIW(bstrTagName, WZ_EXCL) == 0) ||
         (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0) )
    {
         rc = true;
         goto done;
    }

done:

    if (bstrTagName != NULL)
        SysFreeString(bstrTagName);
    if (bstrTimeline != NULL)
        SysFreeString(bstrTimeline);
    return rc;
}
//  Method: CTIMEElementBase::IsGroup


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::IsDocumentInEditMode
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::IsDocumentInEditMode()
{
    HRESULT hr;
    bool fRC = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetElement();
    
    // if there is no pElem, we are not attached to an HTML element, and can't give any information.
    if (NULL == pElem)
        return false;
    
    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto done;
    }

    Assert(pDisp != NULL);

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    Assert(pDoc != NULL);

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }
    
    if (StrCmpIW(bstrMode, L"On") == 0)
    {
        fRC = true;
    }

    SysFreeString(bstrMode);

done:

    return fRC;
}
//  Method: CTIMEElementBase::IsDocumentInEditMode


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetSize
//
//  Overview:        
//      Return return left,top,width,height of element.
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::GetSize(RECT *prcPos)
{
    HRESULT hr;
    long lWidth = 0;
    long lHeight = 0;
    IHTMLElement *pElem = GetElement();
    CComPtr<IHTMLElement2> spElem2;

    CComPtr<IHTMLStyle> spStyle;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    prcPos->left = 0;
    prcPos->top = 0;
    prcPos->right = 0;
    prcPos->bottom = 0;

   
    hr = THR(pElem->get_style(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spStyle->get_pixelWidth(&lWidth));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spStyle->get_pixelHeight(&lHeight));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&spElem2));

    if (SUCCEEDED(hr) &&
       (lWidth  != 0 && lHeight != 0))
    {
        hr = THR(spElem2->get_clientWidth(&lWidth));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(spElem2->get_clientHeight(&lHeight));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // fill in rect
    prcPos->left = prcPos->top = 0;
    prcPos->right = lWidth;
    prcPos->bottom = lHeight;

    TraceTag((tagTimeElmBase, "CTIMEElementBase::GetSize(%d, %d, %d, %d)", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::GetSize


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::ClearSize
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::ClearSize()
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElement2;
    
    HRESULT hr = E_FAIL;

    if (!GetElement())        
    {
        goto done;
    }
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(pElement2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (!pStyle)
    {
        Assert(false);
    }

    hr = pStyle->put_pixelWidth(0);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStyle->put_pixelHeight(0);
    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}
//  Method: CTIMEElementBase::ClearSize


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetWidth
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetWidth(long lwidth)
{
    CComPtr<IHTMLStyle>     pStyle;
    CComPtr<IHTMLElement2>  pElem2;
    IHTMLElement *          pElem   = GetElement();

    HRESULT hr;
    long    lCurWidth       = 0;
    long    lClientWidth    = 0;
    int     i               = 0;

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }


    lClientWidth = lwidth; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth)) && i < 5)
                    // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        Assert(lCurWidth <= lClientWidth);

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);  
        }

        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            hr = THR(pStyle->get_pixelWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {        
            hr = THR(pElem2->get_clientWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if ((lCurWidth != lClientWidth) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SetWidth


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetHeight
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetHeight(long lheight)
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lCurHeight = 0;
    long lClientHeight = 0;
    int i = 0;

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }


    lClientHeight = lheight; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurHeight != lClientHeight)) && i < 5)
                    // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        //Assert(lCurHeight <= lClientHeight);

        i++;
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);  
        }

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            hr = THR(pStyle->get_pixelHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {        
            hr = THR(pElem2->get_clientHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if ((lCurHeight != lClientHeight) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SetHeight


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetSize
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetSize(const RECT *prcPos)
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lLeft = 0;
    long lTop = 0;
    long lCurWidth = 0;
    long lCurHeight = 0;
    long lClientWidth = 0;
    long lClientHeight = 0;
    int i = 0;

    if (prcPos == NULL)    
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // negative size is unexpected
    Assert((prcPos->right - prcPos->left) >= 0);
    Assert((prcPos->bottom - prcPos->top) >= 0);

    // if width or height is zero or less, bail
    if ( ((prcPos->right - prcPos->left) <= 0) ||
         ((prcPos->bottom - prcPos->top) <= 0) )
    {
        hr = ClearSize();
        goto done;
    }

    lClientWidth = prcPos->right - prcPos->left;
    lClientHeight = prcPos->bottom - prcPos->top; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // get offset into document.
    hr = THR(pElem->get_offsetLeft(&lLeft));
    if (FAILED(hr))
        goto done;

    hr = THR(pElem->get_offsetTop(&lTop));
    if (FAILED(hr))
        goto done;

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           i < 5)   // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples in case the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);  
        }
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);  
        }

        // Set the total size (client size + borders etc.)
        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            // IE4 path
            hr = THR(pStyle->get_pixelWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = THR(pStyle->get_pixelHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            //get the current client size
            hr = THR(pElem2->get_clientWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        
            hr = THR(pElem2->get_clientHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    TraceTag((tagTimeElmBase, 
              "CTIMEElementBase::SetSize(%d, %d, %d, %d) [pos(%d, %d)]", 
              prcPos->left, 
              prcPos->top, 
              prcPos->right, 
              prcPos->bottom, 
              lLeft, 
              lTop));

    return hr;
}
//  Method: CTIMEElementBase::SetSize



//+-----------------------------------------------------------------------------------
//
//  Member: CTIMEElementBase::InitTimeline
//
//  Synopsis:   Creates the MMUtils time container and starts root time if body's root
//              time has already started (dynamic creation)
//
//------------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::InitTimeline (void)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        if (IsGroup())
        {
            if (IsExcl())
            {
                m_timeline = NEW MMExcl(*this, true);
            }
            else if (IsSequence())
            {
                m_timeline = NEW MMSeq(*this, true);
            }
            else
            {
                m_timeline = NEW MMTimeline(*this, true);
            }

            if (m_timeline == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction since the m_timeline is ignored
            m_mmbvr = m_timeline;

            if (!m_timeline->Init())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
        else
        {
            MMBaseBvr * b;
            if (IsMedia())
            {
                b = NEW MMMedia(*this, true);
            }
            else
            {
                b = NEW MMBvr(*this, true, IsSyncMaster());
            }

            if (b == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction
            m_mmbvr = b;

            if (!b->Init())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
        m_fTimelineInitialized = true;
    }

    if(m_spBodyElemExternal && (m_ExtenalBodyTime != valueNotSet) && IsEmptyBody())
    {
        TimeValue *tv;

        tv = new TimeValue(NULL,
                           NULL,
                           m_ExtenalBodyTime);

        if (tv == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        m_realBeginValue.GetList().push_back(tv);
     }

    // if we are not the body, have a cached body element pointer, and it is started (i.e. StartRootTimte)
    // then we should start ourselves and do not wait for notification.
    if (!IsBody() && (GetBody() != NULL) && GetBody()->IsRootStarted())
    {
        // being extra careful.  If we have a body cached, we know we are parented and that we can reach
        // back.
        if (GetParent() != NULL)
        {
            hr = THR(StartRootTime(GetParent()->GetMMTimeline()));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::InitTimeline - StartRootTime() failed!"));
                goto done;
            }
        }
    }

done :

    return hr;
}
//  Member: CTIMEElementBase::InitTimeline




////////////////////////////////////////////////////////////////////////////////////////////////////
// Persistance Helpers
////////////////////////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMEElementBase::OnPropertiesLoaded(void)
{
    HRESULT hr;

    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.
    hr = InitTimeline();

    if (IsGroup() == false &&
        m_FADur.IsSet() == false &&
        m_FARepeat.IsSet() == false &&
        m_FARepeatDur.IsSet() == false &&
        m_SAEnd.IsSet() == false &&
        m_TAFill.IsSet() == false)
    {
        m_fUseDefaultFill = true;
        m_TAFill.InternalSet(FREEZE_TOKEN);
    }

    
    if (GetElement())
    {
        CComBSTR pbstrReadyState;
        IHTMLElement *pEle = GetElement();
        hr = GetReadyState(pEle, &pbstrReadyState);
        if (SUCCEEDED(hr))
        {
            if (StrCmpIW(pbstrReadyState, L"complete") == 0)
            {
                OnLoad();
                m_bReadyStateComplete = true;
            }
        }
    }

    return hr;
} // OnPropertiesLoaded


//*****************************************************************************
// if elment doesn't exist in child list, make return -1.
int
CTIMEElementBase::GetTimeChildIndex(CTIMEElementBase *pelm)
{
    if (pelm == NULL)
        return -1;

    long lSize = m_pTIMEChildren.Size();
    for (long i=0; i < lSize; i++)
    {
        if (m_pTIMEChildren[i] == pelm)
             return i;
    }

    // didn't find it
    return -1;
} // GetTimeChildIndex

//
// returns a weak reference to the BodyElement
//
CTIMEBodyElement *
CTIMEElementBase::GetBody()
{
    CTIMEBodyElement * pBody = NULL;

    if (GetParent())
    {
        pBody = GetParent()->GetBody();
    }
    else if (IsBody())
    {
        pBody = (CTIMEBodyElement*)this;
    }
    
done:
    return pBody;
}

MMPlayer *
CTIMEElementBase::GetPlayer()
{
    CTIMEBodyElement * pTIMEBody = GetBody();
    if (pTIMEBody)
    {
        return &(pTIMEBody->GetPlayer());
    }
    else
    {
        return NULL;
    }
}

float
CTIMEElementBase::GetRealSyncTolerance()
{
    if (m_FASyncTolerance == valueNotSet)
    {
        if (GetBody())
        {
            return GetBody()->GetDefaultSyncTolerance();
        }
        else
        {
            return DEFAULT_SYNC_TOLERANCE_S;
        }
    }
    else
    {
        return m_FASyncTolerance;
    }
}
    
TOKEN
CTIMEElementBase::GetRealSyncBehavior()
{
    if (GetParent() != NULL && GetParent()->IsSequence())
    {
        return LOCKED_TOKEN;
    }
    
    if (m_TASyncBehavior == INVALID_TOKEN)
    {
        return GetBody()->GetDefaultSyncBehavior();
    }
    else
    {
        return m_TASyncBehavior;
    }
}    


STDMETHODIMP
CTIMEElementBase::EventNotify(long event)
{
    return S_OK;
}


HRESULT 
CTIMEElementBase::base_beginElementAt(double time, double dblOffset)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_beginElementAt()",
              this));

    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    if (GetParent() && GetParent()->IsSequence())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->BeginAt(time, dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::base_endElementAt(double time, double dblOffset)
{    
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_endElementAt()",
              this));
    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->EndAt(time, dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::IsNodeAtBeginTime
//
//  Synopsis:   Returns true if a node's current time is equal to it's begin time.
//              This happens when a node has been marked active but has not yet started
//              playing (ticking).
//
//  Arguments:  None
//
//  Returns:    bool
//
//------------------------------------------------------------------------------------
bool
CTIMEElementBase::IsNodeAtBeginTime()
{
    double dblActiveBeginTime;
    double dblCurrParentTime;

    if (!IsReady())
    {
        return false;
    }

    dblActiveBeginTime = GetMMBvr().GetActiveBeginTime();
    dblCurrParentTime = GetMMBvr().GetCurrParentTime();

    if (dblActiveBeginTime != TIME_INFINITE &&
        dblCurrParentTime != TIME_INFINITE &&
        dblActiveBeginTime == dblCurrParentTime)
    {
        return true;
    }
    else
    {
        return false;
    }
}

STDMETHODIMP
CTIMEElementBase::onBeginEndEvent(bool bBegin, float beginTime, float beginOffset, 
                                  bool bEnd, float endTime, float endOffset)
{
    HRESULT hr = S_OK;

    if (bBegin && bEnd)
    {
        if (m_TARestart == ALWAYS_TOKEN)
        {
            bEnd = false;  //this cancels the end and allows the begin
        }
        else if (m_TARestart == NEVER_TOKEN)
        {
            if (m_fHasPlayed == true)
            {
                bBegin = false; //this cancels the end and allows the begin
            }
            else
            {
                bEnd = false;
            }
        }
        else if (m_TARestart == WHENNOTACTIVE_TOKEN) //check the active state
        {
            if (IsActive())
            {
                bBegin = false;
            }
            else
            {
                bEnd = false;
            }
        }
        else
        {
            Assert("Invalid restart token during begin event handler" && false);                    
        }

    }

    if (bBegin)
    {
        if (beginTime != valueNotSet)
        {
            double dblParentTime = 0.0;

            dblParentTime = m_mmbvr->DocumentTimeToParentTime(static_cast<double>(beginTime));

            hr = THR(base_beginElementAt(dblParentTime, static_cast<double>(beginOffset)));
        }
        else
        {
            hr = THR(base_beginElement(static_cast<double>(beginOffset)));
        }
    }

    if (bEnd)
    {
        if (IsNodeAtBeginTime() && endOffset == 0.0f && GetParent() && GetParent()->IsSequence())
        {
            goto done;
        }
        // Need to convert the incoming time from global to local to make endAt work.
        if (endTime != valueNotSet)
        {
            double dblParentTime = 0.0;

            dblParentTime = m_mmbvr->DocumentTimeToParentTime(static_cast<double>(endTime));

            hr = THR(base_endElementAt(dblParentTime, static_cast<double>(endOffset)));
        }
        else
        {
            hr = THR(base_endElement(static_cast<double>(endOffset)));
        }
    }
  done:
    return hr;
}


STDMETHODIMP
CTIMEElementBase::onPauseEvent(float time, float fOffset)
{
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onResumeEvent(float time, float fOffset)
{
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onLoadEvent()
{
    if (IsBody())
    {
        OnLoad();
    }
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onUnloadEvent()
{
    OnBeforeUnload();  //signal that the element is unloading now.  No further events
                       //will be fired.
    OnUnload();  
    return S_OK;
}

void
CTIMEElementBase::NotifyBodyUnloading()
{
    m_bBodyUnloading = true;

    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyUnloading();
            }
        }
    }
}

void
CTIMEElementBase::NotifyBodyDetaching()
{
    m_bBodyDetaching = true;

    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyDetaching();
            }
        }
    }
}

void
CTIMEElementBase::NotifyBodyLoading()
{    
    //load the children
    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyLoading();
            }
        }
    }
    
    //load the element;
    if (IsBody() == false)
    {
        OnLoad();
    }
}

STDMETHODIMP
CTIMEElementBase::onReadyStateChangeEvent(LPOLESTR lpstrReadyState)
{
    CComBSTR bstrReadyState;
    if (IsBodyDetaching() == true)
    {
        //this should only be hit in the case of thumbnail view which detachs without unloading
        goto done; 
    }

    GetReadyState  (GetElement(), &bstrReadyState);
    if (bstrReadyState != NULL && StrCmpIW(bstrReadyState, L"complete") == 0)
    {
        m_bReadyStateComplete = true;
    }
    else
    {
        m_bReadyStateComplete = false;
    }

  done:

    return S_OK;

}

STDMETHODIMP
CTIMEElementBase::onStopEvent(float time)
{
    HRESULT hr = S_OK;

    if (IsBody())
    {
        hr = THR(base_pauseElement());
    }
    return hr;
}

STDMETHODIMP
CTIMEElementBase::get_playState(long *State)
{
    HRESULT hr = S_OK;

    TE_STATE CurrState = GetPlayState();
    
    if (State == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *State = (long)CurrState;

  done:

    return hr;
}

float
CTIMEElementBase::GetGlobalTime()
{
    float f = 0;

    MMPlayer * p = GetPlayer();
    
    if (p != NULL)
    {   
        f = static_cast<float>(GetPlayer()->GetCurrentTime());
    }

    return f;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::ReportInvalidArg
//
//  Synopsis:   Wrapper for ReportError; handles "Invalid Argument" error messages.
//
//  Arguments:  property name and invalid value
//
//  Returns:    S_FALSE if English error message was used (localized error message not available)
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::ReportInvalidArg(LPCWSTR pstrPropName, VARIANT & varValue)
{
    Assert(pstrPropName);
    Assert(VT_NULL != varValue.vt);
    Assert(VT_EMPTY != varValue.vt);

    // Convert argument to string
    CComVariant svarTemp;
    HRESULT hr = THR(VariantChangeTypeEx(&svarTemp, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        // conversion failed, null out the variant
        Assert(false && "Unexpected failure converting variant");
        svarTemp.bstrVal = NULL;
        svarTemp.vt = VT_BSTR;
    }

    // load localized message and fire event
    hr = THR(ReportError(IDR_INVALID_ARG, 
                        (GetID() ? GetID() : L""), 
                        pstrPropName, 
                        svarTemp.bstrVal));
    if (FAILED(hr))
    {
        // Couldn't get localized resource, use non-localized error message
        WCHAR strMesg[MAX_ERR_STRING_LEN + 1];
        wnsprintf(
            strMesg,
            MAX_ERR_STRING_LEN + 1,
            WZ_ERROR_STRING_FORMAT,
            GetID() ? GetID() : L"",
            pstrPropName,
            svarTemp.bstrVal);
    
        // fire the error event
        hr = THR(FireErrorEvent(strMesg));
        if (SUCCEEDED(hr))
        {
            // indicate that localized string could not be used
            hr = S_FALSE;
        }
    }

    return hr;
} // ReportInvalidArg


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::ReportError
//
//  Synopsis:   Loads the format string from localized resources and 
//              fires the error event. 
//
//  Arguments:  Resource ID and variable list of format string arguments
//
//  Returns:    E_FAIL if resource could not be loaded
//
//------------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::ReportError(UINT uResID, ...)
{
    USES_CONVERSION; //lint !e522
    HRESULT hr = S_OK;
    va_list args;

    va_start(args, uResID);

    //
    // Load the resource string
    //

    WCHAR pwstrResStr[MAX_ERR_STRING_LEN + 1];
    pwstrResStr[0] = NULL;

    HINSTANCE hInst = _Module.GetResourceInstance();

    // load the localized resource string
    if (!LoadStringW(hInst, uResID, pwstrResStr, MAX_ERR_STRING_LEN))
    {
        // Couldn't load resource
        Assert("Error loading resource string" && false);
        hr = E_FAIL;
        goto done;
    }
    else
    {
        // Format the error message
        WCHAR pstrErrorMsg[MAX_ERR_STRING_LEN + 1];
        wvnsprintf(pstrErrorMsg, MAX_ERR_STRING_LEN, pwstrResStr, args);

        // Fire the error event
        hr = THR(FireErrorEvent(pstrErrorMsg));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // ReportError


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::FireErrorEvent
//
//  Synopsis:   fires the error event on the body. 
//
//  Arguments:  Error message string
//
//  Returns:    
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::FireErrorEvent(LPOLESTR szError)
{
    LPWSTR szParamNames[1] = {{ L"Error" }};
    VARIANT varParams[1];
    HRESULT hr = E_FAIL;
    CTIMEBodyElement *pBody = NULL;

    //initialize the event values
    VariantInit(&varParams[0]);
    varParams[0].vt =  VT_BSTR;
    if (szError)
    {
        varParams[0].bstrVal = SysAllocString(szError);
    }
    else
    {
        varParams[0].bstrVal = SysAllocString(L"");
    }

    pBody = GetBody();
    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->FireEvents(TE_ONTIMEERROR, 1, szParamNames, varParams));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:

    VariantClear(&varParams[0]);
    return hr;
} // FireErrorEvent

    
//////////////////////////////////////////////////////////
//  Wraps the FIRE_EVENT macro into the event manager
//////////////////////////////////////////////////////////
HRESULT 
CTIMEElementBase::FireEvents(TIME_EVENT TimeEvent, 
                             long lCount, 
                             LPWSTR szParamNames[], 
                             VARIANT varParams[])
{
    HRESULT hr = S_OK;
    float fltTime = 0.0f;
    CComBSTR bstrReadyState;
    if (IsBodyDetaching() == true)
    {
        //this should only be hit in the case of thumbnail view which detachs without unloading
        goto done; 
    }

    fltTime = GetGlobalTime();
    if (TimeEvent == TE_ONMEDIACOMPLETE || TimeEvent == TE_ONMEDIAERROR)
    {
        if (GetParent() != NULL && GetParent()->GetMMTimeline() != NULL)
        {
            GetParent()->GetMMTimeline()->childMediaEventNotify(m_mmbvr, 0.0, TimeEvent);
        }
    }

    if (m_bReadyStateComplete == false)
    {
        GetReadyState  (GetElement(), &bstrReadyState);
        if (bstrReadyState != NULL && StrCmpIW(bstrReadyState, L"complete") == 0)
        {
            m_bReadyStateComplete = true;
        }
        else
        {
            m_bReadyStateComplete = false;
        }
    }

    if (m_bReadyStateComplete == true)
    {
        hr = TEM_FIRE_EVENT(TimeEvent, lCount, szParamNames, varParams, fltTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

  done:

    return hr;
}

//Determines if the element associated with this behavior has the focus or not.
bool 
CTIMEElementBase::HasFocus()
{
    CComPtr <IDispatch> pDocDisp;
    CComPtr <IHTMLDocument2> pDoc2;
    CComPtr <IHTMLElement> pEle;
    CComPtr <IUnknown> pUnk1;
    CComPtr <IUnknown> pUnk2;
    HRESULT hr = S_OK;
    bool bFocus = false;

    if (GetElement() == NULL)
    {
        goto done;
    }

    hr = THR(GetElement()->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = pDoc2->get_activeElement(&pEle);
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    //it is possible for the above call to succeed and still not return an element
    if (pEle == NULL)  
    {
        goto done;
    }

    hr = THR(pEle->QueryInterface(IID_IUnknown, (void **)&pUnk1));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = THR(GetElement()->QueryInterface(IID_IUnknown, (void **)&pUnk2));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done; 
    }


    if (pUnk1 == pUnk2)
    {
        bFocus = true;
    }
done:
        
    return bFocus;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::IsReady
//
//  Synopsis:   Returns true if IsStarted is true (this guarantees 1. persistance is done, 
//              2. We have a Time Engine Node, 3. we have a parent and 4. we have a body)
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------
bool
CTIMEElementBase::IsReady() const
{
    bool fIsReady = false;

    if (!IsStarted())
    {
        goto done;
    }

    // TODO: dilipk 10/13/99: eventually need to include a check for ReadyState of the bvr

    // Asserting these just to be safe. These should always succeed if we get here.
    Assert(NULL != m_mmbvr);
    // Check if we have a Time Engine node
    Assert(NULL != m_mmbvr->GetMMBvr());
    // Check if we have a parent
    Assert(NULL != m_pTIMEParent || IsBody());
    
    fIsReady = true;
done:
    return fIsReady;
} // IsReady


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::CascadedPropertyChanged
//
//  Synopsis:   Notify children that a cascaded property has changed on an ancestor (so they can
//              recompute values if necessary). This is recursive,
//              so eventually all of the sub-tree receives notification.
//
//  Returns:    Failure     An overriding method failed (e.g. CTIMEMediaElement::CascadedPropertyChanged)
//              S_OK        Otherwise
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEElementBase::CascadedPropertyChanged(bool fNotifyChildren)
{
    HRESULT hr;
    CTIMEElementBase **ppElm;
    int i;

    if (fNotifyChildren)
    {
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            hr = THR((*ppElm)->CascadedPropertyChanged(fNotifyChildren));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
done:
    return hr;
}


void
CTIMEElementBase::GetCascadedAudioProps(float * pflCascadedVolume, bool * pfCascadedMute)
{
    float flVolume = 0.0;
    bool bMuted = false;
    Assert(pflCascadedVolume);
    Assert(pfCascadedMute);

    flVolume = GetVolumeAttr().GetValue();
    bMuted = GetMuteAttr().GetValue();

    CTIMEElementBase * pTEBParent = GetParent();
    while(NULL != pTEBParent)
    {
        flVolume *= pTEBParent->GetVolumeAttr().GetValue();
        if (pTEBParent->GetMuteAttr().GetValue())
        {
            bMuted = true;
        }

        // early termination
        if (0.0f == flVolume &&  bMuted)
        {
            *pflCascadedVolume = 0.0f;
            *pfCascadedMute = true;
            return;
        }

        pTEBParent = pTEBParent->GetParent();
    }
    
    *pflCascadedVolume = flVolume;
    *pfCascadedMute = bMuted;

}


float
CTIMEElementBase::GetCascadedVolume()
{
    float flVolume;
    bool fMute;

    GetCascadedAudioProps(&flVolume, &fMute);

    return flVolume;
}


bool
CTIMEElementBase::GetCascadedMute()
{
    float flVolume;
    bool fMute;

    GetCascadedAudioProps(&flVolume, &fMute);

    return fMute;
}


//+-----------------------------------------------------------------------
//
//  Member:    base_get_updateMode
//
//  Overview:  alloc a bstr that represents the updateMode
//
//  Arguments: pbstrUpdateMode  where to store the BSTR
//             
//  Returns:   S_OK on Success, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_get_updateMode(BSTR * pbstrUpdateMode)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pbstrUpdateMode);

    *pbstrUpdateMode = ::SysAllocString(TokenToString(m_TAUpdateMode));
    
    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    base_put_updateMode
//
//  Overview:  changes mode used when attributes are changed
//
//  Arguments: bstrUpdateMode   Mode to change to, one of Reset, Auto, or manual
//             
//  Returns:   S_OK on Success, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_put_updateMode(BSTR bstrUpdateMode)
{
    HRESULT hr = S_OK;

    m_TAUpdateMode.Reset(DEFAULT_M_UPDATEMODE);
    
    if (NULL != bstrUpdateMode)
    {
        TOKEN tokUpdateModeVal;
        CTIMEParser pParser(bstrUpdateMode);

        hr = THR(pParser.ParseUpdateMode(tokUpdateModeVal));
        if (S_OK == hr)
        {
            m_TAUpdateMode.SetValue(tokUpdateModeVal);
        }
    }
    
    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_UPDATEMODE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::UpdateMMAPI(bool bUpdateBegin,
                              bool bUpdateEnd)
{
    HRESULT hr = S_OK;

    if (!IsReady() ||
        (MANUAL_TOKEN == m_TAUpdateMode))
    {
        hr = S_OK;
        goto done;
    }

    if (m_FADur.IsSet() && m_FADur == 0.0)
    {
        if (m_FARepeat.IsSet() && TIME_INFINITE == m_FARepeat)
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeat;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, v));
            goto done;
        }
            
        if (TE_UNDEFINED_VALUE != m_FARepeatDur)
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeatDur;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, v));
            goto done;
        }
    }

    if (m_SABegin.GetValue() && !StrCmpIW(m_SABegin, WZ_INDEFINITE))
    {
        // cannot have begin == indefinte with repeatDur == indefinite and dur == unknown
        if (m_FARepeatDur.IsSet() && m_FARepeatDur == TIME_INFINITE && !m_FADur.IsSet())
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeatDur;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, v));
            goto done;
        }

        // cannot have begin == indefinte with repeatCount == indefinite and dur == unknown
        if (m_FARepeat.IsSet() && m_FARepeat == TIME_INFINITE && !m_FADur.IsSet())
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeat;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, v));
            goto done;
        }
    }

    CalcTimes();

    // Force updating of the timing structures

    IGNORE_HR(m_mmbvr->Update(bUpdateBegin, bUpdateEnd));

    if (AUTO_TOKEN == m_TAUpdateMode)
    {
        IGNORE_HR(m_mmbvr->Reset(true));
    }
    else if (RESET_TOKEN == m_TAUpdateMode)
    {
        IGNORE_HR(m_mmbvr->Reset(false));
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEElementBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEElementBase::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CBaseBvr::Load(pPropBag, pErrorLog));
done:
    return hr;
}

STDMETHODIMP
CTIMEElementBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    hr = THR(::TimeSave(this, CTIMEElementBase::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    {
        goto done;
    }

    if (GetTimeAction() == STYLE_TOKEN && 
        m_timeAction.IsTimeActionOn() == false && 
        m_timeAction.GetTimeActionString() != NULL)
    {
        CComPtr <IHTMLStyle> pStyle;
        CComBSTR bstr;
        if (GetElement())
        {
            hr = THR(GetElement()->get_style(&pStyle));
            if (SUCCEEDED(hr))
            {
                hr = THR(pStyle->get_cssText(&bstr));
                if (SUCCEEDED(hr))
                {
                    if (bstr.m_str == NULL)
                    {
                        VARIANT vValue;
                        PROPBAG2 propbag;
                        propbag.vt = VT_BSTR;
                        propbag.pstrName = (LPWSTR)STYLE_TOKEN;
                        VariantInit(&vValue);
                        vValue.vt = VT_BSTR;
                        vValue.bstrVal = SysAllocString(m_timeAction.GetTimeActionString());
                        pPropBag->Write(1, &propbag, &vValue);
                        VariantClear(&vValue);
                    }
                }
            }
        }   
    }

    hr = THR(CBaseBvr::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;

}

//+-----------------------------------------------------------------------
//
//  Member:    FindID
//
//  Overview:  Looks for an ID in the current element and its children
//
//  Arguments: lpwId     The id to look for
//             
//  Returns:   The element if it is found otherwise NULL
//
//------------------------------------------------------------------------
CTIMEElementBase *
CTIMEElementBase::FindID(LPCWSTR lpwId)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::FindID(%ls)",
              this,
              lpwId));

    Assert(lpwId != NULL);
    
    CTIMEElementBase * ptebRet;

    CTIMEElementBase **ppElm;
    int i;
    
    if (GetID() != NULL && StrCmpIW(lpwId, GetID()) == 0)
    {
        ptebRet = this;
        goto done;
    }
    
    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
         i > 0;
         i--, ppElm++)
    {
        ptebRet = (*ppElm)->FindID(lpwId);

        if (ptebRet != NULL)
        {
            goto done;
        }
    }
    
    ptebRet = NULL;
  done:
    return ptebRet;
}

//+-----------------------------------------------------------------------
//
//  Member:    ElementChangeNotify
//
//  Overview:  This will notify an element and its children that a
//  change occurred to another element
//
//  Arguments: pteb     The element which changed
//             tct      The change that occurred
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEElementBase::ElementChangeNotify(CTIMEElementBase & teb,
                                      ELM_CHANGE_TYPE ect)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::FindID(%p, %d)",
              this,
              &teb,
              ect));

    if (m_mmbvr == NULL)
    {
        goto done;
    }
    
    m_mmbvr->ElementChangeNotify(teb, ect);
    
    CTIMEElementBase **ppElm;
    int i;

    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
         i > 0;
         i--, ppElm++)
    {
        (*ppElm)->ElementChangeNotify(teb, ect);
    }

  done:
    return;
}

bool            
CTIMEElementBase::NeedFill()
{ 
    bool bNeedFill = false;

    if (GetFill() == REMOVE_TOKEN)
    {
        bNeedFill = false;
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(fill==remove, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }
    else if (GetParent() == NULL)
    {
        bNeedFill = true;
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(parent==NULL, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }
    else if (GetParent()->IsActive())
    {
        if (GetParent()->IsSequence())
        {
            bool bIsOn = m_timeAction.IsTimeActionOn();
            if(   (GetFill() == HOLD_TOKEN) 
               || (   ((GetFill() == FREEZE_TOKEN) || (m_fInTransitionDependentsList)) 
                   && (bIsOn == true)
                  )
              )
            {
                bNeedFill = true;
                TraceTag((tagTimeElmBaseNeedFill,
                          "CTIMEElementBase(%p, %ls)::NeedFill(parent==sequence, %ls)",
                          this, GetID(), bNeedFill ? L"true" : L"false"));
            }
            else
            {
                bNeedFill = false;
                TraceTag((tagTimeElmBaseNeedFill,
                          "CTIMEElementBase(%p, %ls)::NeedFill(parent==sequence, %ls)",
                          this, GetID(), bNeedFill ? L"true" : L"false"));
            }
        }
        else
        {
            bNeedFill = true;
            TraceTag((tagTimeElmBaseNeedFill,
                      "CTIMEElementBase(%p, %ls)::NeedFill(parent!=sequence, %ls)",
                      this, GetID(), bNeedFill ? L"true" : L"false"));
        }
    }
    else //the parent is not active
    {
        bNeedFill = GetParent()->NeedFill();
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(parent not active, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }

    return bNeedFill; 
}


TOKEN    
CTIMEElementBase::GetFill()
{ 
    return m_TAFill; 
}

//*****************************************************************************

bool 
CTIMEElementBase::IsThumbnail()
{
    HRESULT hr;
    bool fThumbnail = false;

    switch (m_enumIsThumbnail)
    {
        // Uninitialized. Check if we are a thumbnail.
        case TSB_UNINITIALIZED:
        {
            CComPtr<IDispatch> spDispDoc;
            CComPtr<IHTMLDocument> spDoc;
            CComPtr<IHTMLDocument2> spDoc2;
            CComPtr<IOleObject> spOleObj;
            CComPtr<IOleClientSite> spClientSite;
            CComPtr<IUnknown> spUnkThumbnail;

            Assert(GetElement());

            hr = GetElement()->get_document(&spDispDoc);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDispDoc->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDoc2));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDoc2->QueryInterface(IID_TO_PPV(IOleObject, &spOleObj));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spOleObj->GetClientSite(&spClientSite);
            if (FAILED(hr) || spClientSite == NULL)
            {
                goto done;
            }

            hr = spClientSite->QueryInterface(IID_IThumbnailView, reinterpret_cast<void**>(&spUnkThumbnail));
            if (FAILED(hr))
            {
                goto done;
            }

            if (spUnkThumbnail.p)
            {
                fThumbnail = true;
            }
        }
        break;

        // Already checked, and we are NOT a thumbnail
        case TSB_FALSE:
        {
            fThumbnail = false;
        }
        break;

        // Already checked, and we ARE a thumbnail
        case TSB_TRUE:
        {
            fThumbnail = true;
        }
        break;

        default:
        {
            Assert(false);
        }
        break;
    } // switch

done:
    m_enumIsThumbnail = (fThumbnail ? TSB_TRUE : TSB_FALSE);

    return fThumbnail;
} // IsThumbnail


void
CTIMEElementBase::NotifyPropertyChanged(DISPID dispid)
{
    if (IsDetaching() || IsUnloading() || IsBodyUnloading())
    {
        return;
    }

    CBaseBvr::NotifyPropertyChanged(dispid);
}


void
CTIMEElementBase::SetSyncMaster(bool b)
{
    m_fCachedSyncMaster = b;

    if (!IsReady())
    {
        goto done;
    }
    
    m_mmbvr->SetSyncMaster(b);
done:
    return;
}

CTIMEElementBase*
CTIMEElementBase::FindLockedParent()
{
    CTIMEElementBase *pelem = this;

    while(pelem->GetParent())
    {
        if(pelem->IsBody())
        {
            break;
        }
        if(!pelem->IsLocked())
        {
            break;
        }
        pelem = pelem -> GetParent();
    }

    return pelem;
}

void
CTIMEElementBase::RemoveSyncMasterFromBranch(CTIMEElementBase *pElmStart)
{
    CTIMEElementBase *pElm = pElmStart;
    int childNr;

    while(1) //lint !e716
    {
        childNr = pElm->m_sHasSyncMMediaChild;
        pElm->m_sHasSyncMMediaChild = -1;

        if((childNr == -1) || ((pElm->m_pTIMEChildren).Size() == 0))
        {
            if(pElm->IsSyncMaster())
            {
                pElm->SetSyncMaster(false);
            }
            break;
        }
        pElm = pElm->m_pTIMEChildren[childNr];
    }

done:
    return;
}

void
CTIMEElementBase::GetSyncMasterList(std::list<CTIMEElementBase*> &syncList)
{
    int i;
    CTIMEElementBase **ppElm;

    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren; i > 0;i--, ppElm++)
    {
        if((*ppElm)->IsLocked())
        {
            (*ppElm)->GetSyncMasterList(syncList);
        }
    }

    if((m_BASyncMaster && IsMedia()) || m_fCachedSyncMaster || IsMedia())
    {
        syncList.push_back(this);
    }

}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_get_transIn (VARIANT * transIn)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    HRESULT hr;
    
    if (transIn == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(transIn))))
    {
        goto done;
    }
    
    V_VT(transIn) = VT_BSTR;
    V_BSTR(transIn) = SysAllocString(m_SAtransIn);

    hr = S_OK;
  done:
    return hr;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_put_transIn(VARIANT transIn)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;

    if(V_VT(&transIn) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &transIn);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_SAtransIn.GetValue();

    if(!clearFlag)
    {
        m_SAtransIn.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SAtransIn.Reset(DEFAULT_M_TRANSIN);
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT2_TRANSIN);

done:
    return S_OK;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_get_transOut(VARIANT * transOut)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    HRESULT hr;
    
    if (transOut == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(transOut))))
    {
        goto done;
    }
    
    V_VT(transOut) = VT_BSTR;
    V_BSTR(transOut) = SysAllocString(m_SAtransOut);

    hr = S_OK;
  done:
    return hr;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_put_transOut(VARIANT transOut)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;

    if(V_VT(&transOut) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &transOut);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_SAtransOut.GetValue();

    if(!clearFlag)
    {
        m_SAtransOut.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SAtransOut.Reset(DEFAULT_M_TRANSOUT);
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT2_TRANSOUT);

done:
    return S_OK;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::RemoveTrans()
{
    if (m_sptransIn)
    {
        m_sptransIn->Detach();
    }
    if (m_sptransOut)
    {
        m_sptransOut->Detach();
    }

    m_sptransIn = NULL;
    m_sptransOut = NULL;

    return S_OK;
}

//*****************************************************************************

HRESULT 
CreateAndPopulateTrans(ITransitionElement ** ppTransition, 
                       ITIMEElement * piTarget, 
                       IHTMLElement * pHTML,
                       VARIANT_BOOL vbIsTransIn)
{
    HRESULT hr = S_OK;
    
    CComPtr<ITransitionElement> spTransition;

    if (VARIANT_TRUE == vbIsTransIn)
    {
        hr = THR(CreateTransIn(&spTransition));
    }
    else
    {
        hr = THR(CreateTransOut(&spTransition));
    }

    if (FAILED(hr))
    {
        goto done;
    }
        
    hr = THR(spTransition->put_htmlElement(pHTML));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(spTransition->put_timeElement(piTarget));
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppTransition)
    {
        *ppTransition = spTransition;
        (*ppTransition)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//*****************************************************************************

HRESULT
CTIMEElementBase::CreateTrans()
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEElement> spte;

    hr = THR(QueryInterface(IID_TO_PPV(ITIMEElement, &spte)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_SAtransIn)
    {
        // Transition in
        hr = CreateAndPopulateTrans(&m_sptransIn, spte, GetElement(), VARIANT_TRUE);
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransIn->put_template(m_SAtransIn));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransIn->Init());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_SAtransOut)
    {
        // Transition out
        hr = CreateAndPopulateTrans(&m_sptransOut, spte, GetElement(), VARIANT_FALSE);
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransOut->put_template(m_SAtransOut));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransOut->Init());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        RemoveTrans();
    }

    RRETURN(hr);
}

//*****************************************************************************

bool
CTIMEElementBase::IsTransitionPresent()
{
    bool bRet = false;

    // check if there is a Transition attribute set
    if (m_SAtransIn || m_SAtransOut)
    {
        bRet = true;
        goto done;
    }

done:
    return bRet;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::InitTransitionSite (void)
{
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::DetachTransitionSite (void)
{
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(void)
CTIMEElementBase::SetDrawFlag(VARIANT_BOOL vb)
{
    m_vbDrawFlag = vb;
    return;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::get_timeParentNode (ITIMENode  ** ppNode)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pcParent = GetParent();

    if (NULL == pcParent)
    {
        hr = E_FAIL;
        goto done;
    }

    {
        ITIMENode * pNode = pcParent->GetMMBvr().GetMMBvr();

        if ((NULL == pNode) || (NULL == ppNode))
        {
            hr = E_UNEXPECTED;
            goto done;
        }

        pNode->AddRef();
        *ppNode = pNode;
    }

    hr = S_OK;
done : 
    return hr;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::get_node(ITIMENode  ** ppNode)
{
    Assert(ppNode);
    
    ITIMENode * pNode = GetMMBvr().GetMMBvr();
    if (pNode && ppNode)
    {
        pNode->AddRef();
        *ppNode = pNode;
        return S_OK;
    }

    return E_FAIL;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::FireTransitionEvent (TIME_EVENT event)
{
    return FireEvent(event, 0, 0, 0);
}

//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\transdepend.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: transdepend.h
//
//  Contents: Transition Dependency Manager
//
//------------------------------------------------------------------------------

#pragma once

#ifndef _TRANSDEPEND_H
#define _TRANSDEPEND_H

typedef std::list<CTIMEElementBase*> TransitionDependentsList;

class CTransitionDependencyManager
{
private:

    TransitionDependentsList m_listDependents;

public:

    CTransitionDependencyManager();
    virtual ~CTransitionDependencyManager();

    // CTransitionDependencyManager methods 

    HRESULT AddDependent(CTIMEElementBase *  tebDependent);
    HRESULT RemoveDependent(CTIMEElementBase *  tebDependent);

    // Used by the transition object -- determines whether a particular 
    // transition target should assume responsibility for a set of dependencies.
    // Called when the transition begins.

    HRESULT EvaluateTransitionTarget(
                        IUnknown *                      punkTransitionTarget,
                        CTransitionDependencyManager &  crefDependencies);

    // Called when the transition ends.

    HRESULT NotifyAndReleaseDependents();

    void ReleaseAllDependents();
};

#endif // _TRANSDEPEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\timeelmbase.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: timeelmbase.h
//
//  Contents: TIME Element base class
//
//------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEELMBASE_H
#define _TIMEELMBASE_H

#include "resource.h"
#include "basebvr.h"
#include "tokens.h"
#include "eventmgr.h"
#include "mmutil.h"
#include "mmtimeline.h"
#include "collect.h"
#include "activeele.h"
#include "timeaction.h"
#include "timevalue.h"
#include "timeparser.h"
#include "attr.h"
#include "transsite.h"

class CCollectionCache;
class CActiveElementCollection;
class CTIMECurrTimeState;
class CTIMEBodyElement;
class CTransitionDependencyManager;
interface ITransitionElement;

const float DEFAULT_SYNC_TOLERANCE_S = 0.2f;

// disabling because already defined in eventmgr.h
// #define valueNotSet                   -1

//+-----------------------------------------------------------------------------
//
// CTIMEElementBase
//
//------------------------------------------------------------------------------

class
ATL_NO_VTABLE
CTIMEElementBase : 
    public CTIMEEventSite,
    public CBaseBvr
{

  public:

    //+-------------------------------------------------------------------------
    //
    // Public Methods
    //
    //--------------------------------------------------------------------------

    CTIMEElementBase();
    virtual ~CTIMEElementBase();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEElementBase"); }
#endif

    //
    // Enum definitions
    //

    typedef enum COLLECTION_INDEX
    {
        ciAllElements,
        ciChildrenElements,
        NUM_COLLECTIONS
    };

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // ITIMEElement properties
    //
    
    HRESULT base_get_accelerate(VARIANT *);
    HRESULT base_put_accelerate(VARIANT);

    HRESULT base_get_autoReverse(VARIANT *);
    HRESULT base_put_autoReverse(VARIANT );

    HRESULT base_get_begin(VARIANT * time);
    HRESULT base_put_begin(VARIANT time);

    HRESULT base_get_decelerate(VARIANT * );
    HRESULT base_put_decelerate(VARIANT);

    HRESULT base_get_dur(VARIANT * time);
    HRESULT base_put_dur(VARIANT time);

    HRESULT base_get_end(VARIANT * time);
    HRESULT base_put_end(VARIANT time);

    HRESULT base_get_fill(LPOLESTR * f);
    HRESULT base_put_fill(LPOLESTR f);

    HRESULT base_get_mute(VARIANT * b);
    HRESULT base_put_mute(VARIANT b);

    HRESULT base_get_repeatCount(VARIANT * c);
    HRESULT base_put_repeatCount(VARIANT c);

    HRESULT base_get_repeatDur(VARIANT * time);
    HRESULT base_put_repeatDur(VARIANT time);

    HRESULT base_get_restart(LPOLESTR *);
    HRESULT base_put_restart(LPOLESTR );

    HRESULT base_get_speed(VARIANT * speed);
    HRESULT base_put_speed(VARIANT speed);

    HRESULT base_get_syncBehavior(LPOLESTR * sync);
    HRESULT base_put_syncBehavior(LPOLESTR sync);

    HRESULT base_get_syncTolerance(VARIANT * tol);
    HRESULT base_put_syncTolerance(VARIANT tol);

    HRESULT base_get_syncMaster(VARIANT * b);
    HRESULT base_put_syncMaster(VARIANT b);

    HRESULT base_get_timeAction(LPOLESTR * time);
    HRESULT base_put_timeAction(LPOLESTR time);

    HRESULT base_get_timeContainer(LPOLESTR *);
    HRESULT base_put_timeContainer(LPOLESTR );

    HRESULT base_get_volume(VARIANT * val);
    HRESULT base_put_volume(VARIANT val);

    // Basic transition properties
    HRESULT base_get_transIn (VARIANT * val);
    HRESULT base_put_transIn (VARIANT val);
    HRESULT base_get_transOut (VARIANT * val);
    HRESULT base_put_transOut (VARIANT val);

    // Properties
    HRESULT base_get_currTimeState(ITIMEState ** TimeState);

    HRESULT base_get_timeAll(ITIMEElementCollection **allColl);

    HRESULT base_get_timeChildren(ITIMEElementCollection **childColl);
    bool            IsNodeAtBeginTime();

    HRESULT base_get_timeParent(ITIMEElement ** parent);

    HRESULT base_get_isPaused(VARIANT_BOOL * b);

    // Methods
    HRESULT base_beginElement(double dblOffset);

    HRESULT base_beginElementAt(double parentTime, double dblOffset);

    HRESULT base_endElement(double dblOffset);

    HRESULT base_endElementAt(double parentTime, double dblOffset);

    HRESULT base_pauseElement();

    HRESULT base_resetElement();

    HRESULT base_resumeElement();

    HRESULT base_seekActiveTime(double activeTime);
        
    HRESULT base_seekSegmentTime(double segmentTime);
        
    HRESULT base_seekTo(LONG repeatCount, double segmentTime);
        
    HRESULT base_documentTimeToParentTime(double documentTime,
                                          double * parentTime);
        
    HRESULT base_parentTimeToDocumentTime(double parentTime,
                                          double * documentTime);
        
    HRESULT base_parentTimeToActiveTime(double parentTime,
                                        double * activeTime);
        
    HRESULT base_activeTimeToParentTime(double activeTime,
                                        double * parentTime);
        
    HRESULT base_activeTimeToSegmentTime(double activeTime,
                                         double * segmentTime);
        
    HRESULT base_segmentTimeToActiveTime(double segmentTime,
                                         double * activeTime);
        
    HRESULT base_segmentTimeToSimpleTime(double segmentTime,
                                         double * simpleTime);
        
    HRESULT base_simpleTimeToSegmentTime(double simpleTime,
                                         double * segmentTime);
        
    // Container attributes
    HRESULT base_get_endSync(LPOLESTR * es);
    HRESULT base_put_endSync(LPOLESTR es);

    // Container Properties
    HRESULT base_get_activeElements(ITIMEActiveElementCollection **activeColl);
    HRESULT base_get_hasMedia(VARIANT_BOOL * pvbVal);

    // Container Methods
    HRESULT base_nextElement();
    HRESULT base_prevElement();

    HRESULT base_get_updateMode(BSTR * pbstrUpdateMode);
    HRESULT base_put_updateMode(BSTR bstrUpdateMode);
    
    //
    //
    //
    
    HRESULT GetCollection(COLLECTION_INDEX index, ITIMEElementCollection **ppDisp);
    HRESULT BeginElement(double dblOffset);
    HRESULT AddTIMEElement(CTIMEElementBase *bvr);
    HRESULT RemoveTIMEElement(CTIMEElementBase *bvr);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite)(void);
    STDMETHOD(DetachTransitionSite)(void);
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b);
    STDMETHOD(get_node)(ITIMENode ** ppNode);
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode);
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event);

    //
    // CTIMEEventSite methods
    //

    STDMETHOD(EventNotify)(long event);
    STDMETHOD(onBeginEndEvent)(bool bBegin, float beginTime, float beginOffset, bool bend, float endTime, float endOffset);
    STDMETHOD(onPauseEvent)(float time, float fOffset);
    STDMETHOD(onResumeEvent)(float time, float fOffset);
    STDMETHOD(onLoadEvent)();
    STDMETHOD(onUnloadEvent)();
    STDMETHOD(onReadyStateChangeEvent)(LPOLESTR lpstrReadyState);
    STDMETHOD(onStopEvent)(float time);
    STDMETHOD(get_playState)(long *State);
    float GetGlobalTime();
    bool IsThumbnail();

    //
    // QI Stuff
    //

    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
    BaseInternalQueryInterface(CTIMEElementBase* pThis,
                               void * pv,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEElementBase* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Event Handlers
    //

    virtual void OnLoad();
    virtual void OnUnload()                         {}
    virtual void OnBeforeUnload (void)              { m_bUnloading = true; }
    virtual void OnPropChange(LPOLESTR propname)    {}
    virtual void OnReadyStateChange(TOKEN state)    {}
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnReverse(double dblLocalTime);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnUpdate(double dblLocalTime, DWORD flags) {};
    virtual void OnRepeat(double dbllastTime);
    virtual void OnSeek(double dblLocalTime);
    virtual void OnTick();
    virtual void OnTEPropChange(DWORD tePropType);
    virtual void UpdateSync() {}
    virtual void NotifyBodyUnloading();
    virtual void NotifyBodyDetaching();
    virtual void NotifyBodyLoading();

    //
    // State query functions
    //

    bool            IsLocked()              { return GetRealSyncBehavior() == LOCKED_TOKEN; }
    virtual bool    IsGroup() const         { return (m_TTATimeContainer == ttPar) || (m_TTATimeContainer == ttSeq) || (m_TTATimeContainer == ttExcl); }
    bool            IsGroup(IHTMLElement *pElement); // determine if elem passed in is a group
    bool            IsPar() const           { return (m_TTATimeContainer == ttPar); }
    bool            IsSequence() const      { return (m_TTATimeContainer == ttSeq); }
    bool            IsExcl() const          { return (m_TTATimeContainer == ttExcl); }
    TimelineType    GetTimeContainer() const{ return m_TTATimeContainer; }
    virtual bool    IsBody() const          { return false; }
    virtual bool    IsEmptyBody() const          { return false; }
    virtual bool    IsMedia() const          { return false; }

    // Use of IsStarted() will be deprecated, use IsReady() instead 
    bool            IsStarted() const       { return m_bStarted; }
    bool            IsDetaching()           { return m_fDetaching; }
    bool            IsUnloading (void)      { return m_bUnloading; }
    bool            IsBodyUnloading (void)  { return m_bBodyUnloading; }
    bool            IsBodyDetaching (void)  { return m_bBodyDetaching; }
    bool            IsDocumentInEditMode();
    bool            IsPaused() const;
    bool            IsCurrPaused() const;
    virtual bool    isNaturalDuration()     { return false;}
    bool            HasFocus();
    bool            IsReady() const;
    bool            IsActive() const;
    bool            IsOn() const;
    bool            IsSyncMaster() const    { return m_fCachedSyncMaster; } 
    bool            NeedFill();
    bool            GetTESpeed(float &flSpeed);
    double          GetTESimpleTime();
    void            SetSyncMaster(bool b);
    virtual bool    ContainsMediaElement() { return false; }
    bool            IsLoaded() { return m_bLoaded; }
    bool            HasWallClock() { return m_fHasWallClock; }

    //
    // GetXXXAttr Accessors
    //

    CAttr<float>        & GetSpeedAttr()         { return m_FASpeed; }
    CAttr<float>        & GetVolumeAttr()        { return m_FAVolume; }
    CAttr<float>        & GetDurAttr()           { return m_FADur; }
    CAttr<float>        & GetAccelerateAttr()    { return m_FAAccelerate; }
    CAttr<float>        & GetDecelerateAttr()    { return m_FADecelerate; }
    CAttr<float>        & GetRepeatAttr()        { return m_FARepeat; }
    CAttr<float>        & GetRepeatDurAttr()     { return m_FARepeatDur; }
    CAttr<float>        & GetSyncToleranceAttr() { return m_FASyncTolerance; }
    CAttr<bool>         & GetAutoReverseAttr()   { return m_BAAutoReverse; }
    CAttr<bool>         & GetMuteAttr()          { return m_BAMute; }
    CAttr<bool>         & GetSyncMasterAttr()    { return m_BASyncMaster; }
    CAttr<TOKEN>        & GetFillAttr()          { return m_TAFill; } 
    CAttr<TOKEN>        & GetRestartAttr()       { return m_TARestart; } 
    CAttr<TOKEN>        & GetSyncBehaviorAttr()  { return m_TASyncBehavior; } 
    CAttr<LPWSTR>       & GetBeginAttr()         { return m_SABegin; } 
    CAttr<LPWSTR>       & GetEndAttr()           { return m_SAEnd; } 
    CAttr<LPWSTR>       & GetEndSyncAttr()       { return m_SAEndSync; } 
    CAttr<TimelineType> & GetTimeContainerAttr() { return m_TTATimeContainer; }
    CAttr<LPWSTR>       & GetTimeActionAttr()    { return m_SATimeAction; }
    CAttr<TOKEN>        & GetUpdateModeAttr()    { return m_TAUpdateMode; }
    CAttr<LPWSTR>       & GetTransInAttr ()      { return m_SAtransIn; }
    CAttr<LPWSTR>       & GetTransOutAttr ()     { return m_SAtransOut; }
    
    //
    // General Accessors
    //

    // GetXXX 
    LPWSTR   GetBeginTime() const                { return m_SABegin;}
    float    GetDuration() const                 { return m_FADur; } 
    float    GetRepeat() const                   { return m_FARepeat; }
    float    GetRepeatDur() const                { return m_FARepeatDur; }
    float    GetAccel() const                    { return m_FAAccelerate; }
    float    GetDecel() const                    { return m_FADecelerate; }
    bool     GetAutoReverse() const              { return m_BAAutoReverse; }
    float    GetSpeed() const                    { return m_FASpeed; }
    TOKEN    GetTimeAction()                     { return m_timeAction.GetTimeAction(); }
    LPWSTR   GetEnd() const                      { return m_SAEnd; }
    LPWSTR   GetEndSync();                  
    // Be aware that this can return NULL if no ID was set on the element
    LPWSTR   GetID() const                       { return m_id; }
    float    GetVolume() const                   { return m_FAVolume; }
    bool     GetMuted() const                    { return m_BAMute; }
    void     GetCascadedAudioProps(float * pflCascadedVolume, bool * pfCascadedMute);
    float    GetCascadedVolume();
    bool     GetCascadedMute();
    TOKEN    GetFill();
    TOKEN    GetRestart() const                  { return m_TARestart; }
    float    GetRealDuration() const             { return m_realDuration; }
    float    GetRealRepeatTime() const           { return m_realRepeatTime; }
    float    GetRealRepeatCount() const          { return m_realRepeatCount; }
    float    GetRealIntervalDuration(void) const { return m_realIntervalDuration; }
    long     GetImmediateChildCount() const      { return m_pTIMEChildren.Size(); } 
    float    GetRealSyncTolerance();
    TOKEN    GetRealSyncBehavior();
    TE_STATE GetPlayState();
    int      GetTimeChildIndex(CTIMEElementBase *pelm);
    long     GetAllChildCount();
    HRESULT  getTagString(BSTR *pbstrID);
    HRESULT  getIDString(BSTR *pbstrTag);

    TimeValueList & GetRealBeginValue()         { return m_realBeginValue; }
    TimeValueList & GetRealEndValue()           { return m_realEndValue; }

    CActiveElementCollection * 
             GetActiveElementCollection()       { return m_activeElementCollection; }
    CCollectionCache *         
             GetCollectionCache()               { return m_pCollectionCache; }
    CTIMEElementBase *         
             GetChild(long i);
    CTIMEElementBase *         
             GetParent()                        { return m_pTIMEParent; }
    CTIMEBodyElement * GetBody();
    MMPlayer *      GetPlayer();
    MMBaseBvr &     GetMMBvr();
    MMTimeline *    GetMMTimeline()                    { return m_timeline; }
    virtual HRESULT GetSyncMaster(double & dblNewSegmentTime,
                                  LONG & lNewRepeatCount,
                                  bool & bCueing);
    virtual HRESULT GetSize(RECT * prcPos);
    virtual TimeState GetTimeState();
    bool    GetIsSwitch()                       { return m_bIsSwitch; };
    bool    GetUseDefaultFill()                 { return m_fUseDefaultFill; };
    void    UpdateDefaultFill(TOKEN tFill)      { m_TAFill.InternalSet(tFill); };

    // SetXXX/PutXXX
    virtual HRESULT SetSize(const RECT * prcPos);
    HRESULT SetHeight(long lheight);
    HRESULT SetWidth(long lwidth);
    HRESULT PutCachedSyncMaster(bool fSyncMaster);
    void SetLocalTimeDirty(bool fDirty) { m_fLocalTimeDirty = fDirty; }

    //
    // Helpers for dealing with ids of time elements
    //
    
    CTIMEElementBase * FindID(LPCWSTR lpwId);
    void ElementChangeNotify(CTIMEElementBase & teb, ELM_CHANGE_TYPE ect);
    
    //
    // Misc. methods
    //

    HRESULT FireEvents(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    bool ChildPropNotify(CTIMEElementBase & teb,
                         DWORD & tePropType);
    HRESULT ClearSize();
    STDMETHOD(GetRuntimeStyle)(IHTMLStyle ** s);
    HRESULT Update();
    virtual HRESULT InitTimeline(void);
    HRESULT FireEvent(TIME_EVENT TimeEvent, double dblLocalTime, DWORD flags, long lRepeatCount);
    HRESULT EnsureCollectionCache();
    HRESULT InvalidateCollectionCache();
    HRESULT ClearCachedSyncMaster();

    //
    // fill=transition notifications
    //
    HRESULT OnResolveDependent(CTransitionDependencyManager *pcNewManager);
    HRESULT OnBeginTransition (void);
    HRESULT OnEndTransition (void);

    // DOM Error reporting utilities 
    HRESULT FireErrorEvent(LPOLESTR szError);
    HRESULT ReportError(UINT uResID, ...);
    HRESULT ReportInvalidArg(LPCWSTR pstrPropName, VARIANT & varValue);
    void NotifyPropertyChanged(DISPID dispid);

    //sets volume, mute on player
    virtual void UpdatePlayerAudioProperties() {};
        
    bool        IsDetaching() const { return m_fDetaching; }

    CAtomTable *GetAtomTable();

    virtual bool ToggleTimeAction(bool on);

    TOKEN       GetPriorityClassHigher() { return m_tokPriorityClassHigher; }
    TOKEN       GetPriorityClassPeers() { return m_tokPriorityClassPeers; }
    TOKEN       GetPriorityClassLower() { return m_tokPriorityClassLower; }

    void NotifyTimeStateChange(DISPID dispid);
    
    //
    // Accessors
    //

    virtual LPCWSTR GetBehaviorURN() { return WZ_TIME_URN; }
    virtual LPCWSTR GetBehaviorName(void) { return WZ_REGISTERED_TIME_NAME; }
    void            GetSyncMasterList(std::list<CTIMEElementBase*> &syncList);

    HRESULT SetParent(ITIMEElement *pelem, bool fReparentChildren = true);

protected:

    //+-------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //--------------------------------------------------------------------------

    //
    // Event map for the new event manager.
    //

    DECLARE_EVENT_MANAGER() //this must be in the base class, not the child classes.

    BEGIN_TIME_EVENTMAP() 
        TEM_INIT_EVENTMANAGER_SITE() 
        TEM_REGISTER_EVENT(TE_ONBEGIN)
        TEM_REGISTER_EVENT(TE_ONPAUSE)
        TEM_REGISTER_EVENT(TE_ONRESUME)
        TEM_REGISTER_EVENT(TE_ONEND)
        TEM_REGISTER_EVENT(TE_ONREPEAT)
        TEM_REGISTER_EVENT(TE_ONREVERSE)
        TEM_REGISTER_EVENT(TE_ONRESET)
        TEM_REGISTER_EVENT(TE_ONSEEK)
        TEM_REGISTER_EVENT(TE_ONTIMEERROR)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONINBEGIN)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONINEND)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONOUTBEGIN)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONOUTEND)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONREPEAT)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_LOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_UNLOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_READYSTATECHANGE)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_STOP)
    END_TIME_EVENTMAP()

    //
    // Persistence and Notification helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // TimeAction related methods
    //

    bool        AddTimeAction();
    bool        RemoveTimeAction();
    void        UpdateTimeAction();
    void        UpdateEndEvents();

    //
    // TransitionDependentList methods
    //
    void        AddToTransitionDependents      (void);
    void        RemoveFromTransitionDependents (void);

    //
    // State query methods
    //

    virtual bool IsBehaviorAttached(void) { return IsTIMEBehaviorAttached(GetElement()); }

    //
    // Misc. methods
    //

    STDMETHOD(      CreateActiveEleCollection)();
    virtual HRESULT Error(void) = 0;
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void    StopRootTime(MMTimeline * tl);
    void            CalcTimes();
    STDMETHOD(      CascadedPropertyChanged)(bool fNotifyChildren);
    virtual void    InitOnLoad(){};
    void            HandleAnimationSeek();
    VARIANT_BOOL    GetDrawFlag (void)
    { return m_vbDrawFlag; }

    CTIMEElementBase* FindLockedParent();
    void RemoveSyncMasterFromBranch(CTIMEElementBase *pElmStart);
    void SetupPriorityClassParent();

    bool IsSequencedElementOn (void);
    
    //+-------------------------------------------------------------------------
    //
    // Protected Data
    //
    //--------------------------------------------------------------------------

    // Attributes
    CAttr<LPWSTR>   m_SABegin;
    CAttr<float>    m_FADur;
    CAttr<LPWSTR>   m_SAEnd;
    CAttr<LPWSTR>   m_SAEndSync;
    CAttr<TOKEN>    m_TAFill;
    CAttr<TOKEN>    m_TARestart;
    CAttr<float>    m_FARepeat;
    CAttr<float>    m_FARepeatDur;
    CAttr<float>    m_FAAccelerate;
    CAttr<float>    m_FADecelerate;
    CAttr<bool>     m_BAAutoReverse;
    CAttr<float>    m_FASpeed;
    CAttr<TOKEN>    m_TASyncBehavior;
    CAttr<float>    m_FASyncTolerance;
    CAttr<TimelineType> m_TTATimeContainer;
    CAttr<float>    m_FAVolume;
    CAttr<bool>     m_BAMute;
    CAttr<bool>     m_BASyncMaster;
    CAttr<LPWSTR>   m_SATimeAction;
    CAttr<TOKEN>    m_TAUpdateMode;
    CAttr<LPWSTR>   m_SAtransIn;
    CAttr<LPWSTR>   m_SAtransOut;
    
    // internal variables
    LPWSTR          m_id;
    CTimeAction     m_timeAction;
    bool            m_fCachedSyncMaster;
    short           m_sHasSyncMMediaChild;
    bool            m_bLoaded;
    bool            m_bUnloading;
    bool            m_bBodyUnloading;
    bool            m_bBodyDetaching;
    bool            m_fTimelineInitialized;
    TimeValueList   m_realBeginValue;
    TimeValueList   m_realEndValue;
    float           m_realDuration;
    float           m_realRepeatTime;
    float           m_realRepeatCount;
    float           m_realIntervalDuration;
    MMBaseBvr      *m_mmbvr;
    bool            m_bStarted;
    double          m_dLastRepeatEventNotifyTime;
    bool            m_bIsSwitch;
    bool            m_fUseDefaultFill;
    bool            m_fHasPlayed;
    bool            m_fInTransitionDependentsList;
    bool            m_fEndingTransition;
    SYSTEMTIME      m_timeSystemBeginTime;
    bool            m_fLocalTimeDirty;
    bool            m_fHasWallClock;

    CTIMEElementBase            *m_pTIMEParent;
    CPtrAry<CTIMEElementBase*>   m_pTIMEChildren;
    CPtrAry<CTIMEElementBase*>   m_pTIMEZombiChildren;
    MMTimeline                  *m_timeline;
    DAComPtr<CTIMECurrTimeState>          m_pCurrTimeState;
    DAComPtr<CActiveElementCollection>    m_activeElementCollection;
    bool            m_fDetaching;

    TOKEN           m_tokPriorityClassPeers;
    TOKEN           m_tokPriorityClassHigher;
    TOKEN           m_tokPriorityClassLower;
    CComPtr<ITIMEBodyElement>   m_spBodyElemExternal;
    double          m_ExtenalBodyTime;

    
private:

    //+-------------------------------------------------------------------------
    //
    // Private Methods
    //
    //--------------------------------------------------------------------------

    HRESULT UnparentElement();
    HRESULT ParentElement();
    HRESULT ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pelem);
    HRESULT UpdateMMAPI(bool bUpdateBegin,
                        bool bUpdateEnd);
    HRESULT InitAtomTable();
    void    ReleaseAtomTable();
    HRESULT SwitchInnerElements();
    HRESULT DisableElement(IDispatch *pEleDisp);
    bool MatchTestAttributes(IDispatch *pEleDisp);
    HRESULT CreateTrans();
    HRESULT RemoveTrans();
    bool    IsTransitionPresent();

    //+-------------------------------------------------------------------------
    //
    // Private Data
    //
    //--------------------------------------------------------------------------

    static TIME_PERSISTENCE_MAP PersistenceMap[];
    CCollectionCache  *         m_pCollectionCache;
    static CAtomTable *         s_pAtomTable;
    static DWORD                s_cAtomTableRef;

    DWORD                       m_propertyAccesFlags;
    float                       m_privateRepeat;
    bool                        m_bNeedDetach;
    bool                        m_bReadyStateComplete;
    TRI_STATE_BOOL              m_enumIsThumbnail;
    bool                        m_bAttachedAtomTable;
    CComPtr<ITransitionElement> m_sptransIn;
    CComPtr<ITransitionElement> m_sptransOut;

    // for ITIMETransitionSite
    VARIANT_BOOL                m_vbDrawFlag;

}; // CTIMEElementBase

//
// This function does NOT return an addrefed outgoing CTIMEElementBase
//
CTIMEElementBase * GetTIMEElementBase(IUnknown * pInputUnknown);
CTIMEBodyElement * GetTIMEBodyElement(ITIMEBodyElement * pInputUnknown);


//+---------------------------------------------------------------------------------
//  CTIMEElementBase inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
CAtomTable *
CTIMEElementBase::GetAtomTable()
{
    Assert(s_pAtomTable != NULL);
    return s_pAtomTable;
} // GetAtomTable

inline 
long 
CTIMEElementBase::GetAllChildCount()
{
    long lSize = m_pTIMEChildren.Size();
    long lCount = 0;
    for (long i=0; i < lSize; i++)
        lCount += m_pTIMEChildren[i]->GetAllChildCount();
    return lCount + lSize;
} // GetAllChildCount

inline 
CTIMEElementBase * 
CTIMEElementBase::GetChild(long i)
{
    Assert(i >= 0);
    return m_pTIMEChildren[i];
} // GetChild

inline 
HRESULT WINAPI
CTIMEElementBase::InternalQueryInterface(CTIMEElementBase* pThis,
                                         const _ATL_INTMAP_ENTRY* pEntries,
                                         REFIID iid,
                                         void** ppvObject)
{
    AssertStr(false, "InternalQueryInterface not defined in base class");
    return E_FAIL;
}

inline
MMBaseBvr &                
CTIMEElementBase::GetMMBvr() 
{ 
    Assert(m_mmbvr); 
    return *m_mmbvr; 
}

inline bool
CTIMEElementBase::IsActive() const
{
    return (IsReady() && m_mmbvr->IsActive());
}

inline bool
CTIMEElementBase::IsOn() const
{
    return (IsReady() && m_mmbvr->IsOn());
}

inline bool
CTIMEElementBase::IsPaused() const
{
    return (IsReady() && m_mmbvr->IsPaused());
}

inline bool
CTIMEElementBase::IsCurrPaused() const
{
    return (IsReady() && m_mmbvr->IsCurrPaused());
}

inline bool
CTIMEElementBase::GetTESpeed(float &flSpeed)
{
    flSpeed = 1.0;

    if(!IsReady())
    {
        return false;
    }
    flSpeed = m_mmbvr->GetCurrSpeed();
    return true;
}

inline double
CTIMEElementBase::GetTESimpleTime()
{
    double dblRet = 0.0;

    if (IsReady())
    {
        dblRet = m_mmbvr->GetSimpleTime();
    }
    
    return dblRet;
}

#include "currtimestate.h"

inline void
CTIMEElementBase::NotifyTimeStateChange(DISPID dispid)
{
    if (m_pCurrTimeState)
    {
        IGNORE_HR(m_pCurrTimeState->NotifyPropertyChanged(dispid));
    }
}

inline LPWSTR   
CTIMEElementBase::GetEndSync() 
{ 
    if (!IsSequence())
    {
        return m_SAEndSync; 
    }
    else
    {
        return NULL;
    }
}


#endif /* _TIMEELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timebvr\transdepend.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: transdepend.cpp
//
//  Contents: Transition Dependency Manager
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "transdepend.h"

DeclareTag(tagTimeTransitionFillDependent, "SMIL Transitions", "Transition fill dependent manager");




//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::CTransitionDependencyManager
//
//------------------------------------------------------------------------------
CTransitionDependencyManager::CTransitionDependencyManager()
{
}
//  Method: CTransitionDependencyManager::CTransitionDependencyManager


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::~CTransitionDependencyManager
//
//------------------------------------------------------------------------------
CTransitionDependencyManager::~CTransitionDependencyManager()
{
    ReleaseAllDependents();
} 
//  Method: CTransitionDependencyManager::~CTransitionDependencyManager


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::ReleaseAllDependents
//
//------------------------------------------------------------------------------
void
CTransitionDependencyManager::ReleaseAllDependents()
{
    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::ReleaseAllDependents()",
              this));

    while (m_listDependents.size() > 0)
    {
        CTIMEElementBase * pteb = m_listDependents.front();

        pteb->Release();

        m_listDependents.pop_front();
    }
}
//  Method: CTransitionDependencyManager::ReleaseAllDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::AddDependent
//
//------------------------------------------------------------------------------
HRESULT
CTransitionDependencyManager::AddDependent(CTIMEElementBase * ptebDependent)
{
    HRESULT hr = S_OK;

    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::AddDependent(%p)",
              this,
              ptebDependent));

    if (NULL == ptebDependent)
    {
        hr = E_POINTER;

        goto done;
    }

    ptebDependent->AddRef();

    m_listDependents.push_front(ptebDependent);
    
    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTransitionDependencyManager::AddDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::RemoveDependent
//
//------------------------------------------------------------------------------
HRESULT
CTransitionDependencyManager::RemoveDependent(CTIMEElementBase * ptebDependent)
{
    HRESULT hr = S_OK;

    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::RemoveDependent(%p)",
              this, 
              ptebDependent));

    if (NULL == ptebDependent)
    {
        hr = E_POINTER;

        goto done;
    }

    // Find this element in the list.

    for (TransitionDependentsList::iterator i = m_listDependents.begin(); 
         i != m_listDependents.end(); i++)
    {
        CTIMEElementBase * pteb = *i;

        if (ptebDependent == pteb)
        {
            pteb->Release();

            m_listDependents.erase(i);

            break;
        }
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTransitionDependencyManager::RemoveDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::EvaluateTransitionTarget
//
//------------------------------------------------------------------------------
HRESULT 
CTransitionDependencyManager::EvaluateTransitionTarget(
                            IUnknown *                      punkTransitionTarget, 
                            CTransitionDependencyManager &  crefDependencies)
{
    while (m_listDependents.size() > 0)
    {
        // @@ ISSUE pauld
        // Short cut for now.  What we really want to do is to compare the target and 
        // dependent candidate for spatial overlap.  For now, we're going straight to 
        // the lists, and not using the Add/Remove methods.

        CTIMEElementBase * pteb = m_listDependents.front();

        TraceTag((tagTimeTransitionFillDependent,
                  "CTransitionDependencyManager(%p)::EvaluateTransitionTarget"
                   " migrating dependent(%p) to target(%p)",
                  this, 
                  pteb, 
                  punkTransitionTarget));

        crefDependencies.m_listDependents.push_front(pteb);

        m_listDependents.pop_front();
    }

done:

    return S_OK;
}
//  Method: CTransitionDependencyManager::EvaluateTransitionTarget
   

//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::NotifyAndReleaseDependents
//
//------------------------------------------------------------------------------
HRESULT 
CTransitionDependencyManager::NotifyAndReleaseDependents()
{
    while (m_listDependents.size() > 0)
    {
        CTIMEElementBase * pteb = m_listDependents.front();

        pteb->OnEndTransition();
        pteb->Release();

        m_listDependents.pop_front();
    }

done:

    return S_OK;
}
//  Method: CTransitionDependencyManager::NotifyAndReleaseDependents
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\container.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTEContainer, "TIME: Engine", "CTIMEContainer methods")
DeclareTag(tagTEEndSync, "TIME: Engine", "EndSync")

CTIMEContainer::CTIMEContainer()
: m_tesEndSync(TE_ENDSYNC_NONE),
  m_bIgnoreParentUpdate(false)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CTIMEContainer()",
              this));
}

CTIMEContainer::~CTIMEContainer()
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::~CTIMEContainer()",
              this));
}

HRESULT
CTIMEContainer::Init(LPOLESTR id)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = CTIMENode::Init(id);
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void CTIMEContainer::FinalRelease()
{
    TIMENodeList ::iterator i;

    // release bvrs in children list
    for (i = m_children.begin(); i != m_children.end(); i++)
    {
        (*i)->Release();
    }
    m_children.clear();
} // FinalRelease()



STDMETHODIMP
CTIMEContainer::addNode(ITIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::addNode(%p)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    HRESULT hr;
    
    CTIMENode * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (mmbvr->GetMgr() != NULL ||
        mmbvr->GetParent() != NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(Add(mmbvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEContainer::removeNode(ITIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::removeNode(%p)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    HRESULT hr;
    
    CTIMENode * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(Remove(mmbvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEContainer::get_numChildren(long * l)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::get_numChildren(%p)",
              this,
              l));
    
    CHECK_RETURN_NULL(l);

    *l = m_children.size();

    return S_OK;
}

//
// Internal methods
//

HRESULT
CTIMEContainer::Add(CTIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Add(%p)",
              this,
              bvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    HRESULT hr;
    
    bvr->SetParent(this);

    Assert(bvr->GetMgr() == NULL);
    
    if (GetMgr() != NULL)
    {
        hr = bvr->SetMgr(GetMgr());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = THR(AddToChildren(bvr));
    if (FAILED(hr))
    {
        goto done;
    }

    // If I am currently active then I need to tick my child
    if (IsActive())
    {
        CEventList l;
    
        bvr->TickEvent(&l,
                       TE_EVENT_BEGIN,
                       0);

        hr = THR(l.FireEvents());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        IGNORE_HR(Remove(bvr));
    }
    
    RRETURN(hr);
}

HRESULT
CTIMEContainer::Remove(CTIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Remove(%p)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    // TODO: We should probably fire an end event here
    RemoveFromChildren(bvr);

    // The order here is important
    bvr->ClearMgr();
    bvr->ClearParent();
    
    return S_OK;
}

HRESULT
CTIMEContainer::AddToChildren(CTIMENode * bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::AddToChildren(%p)",
              this,
              bvr));

    HRESULT hr;
    
    bvr->AddRef();
    // @@ ISSUE : Need to handle memory error
    m_children.push_back(bvr);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEContainer::RemoveFromChildren(CTIMENode * bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::RemoveFromChildren(%p)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_children.remove(bvr);
}

bool 
CTIMEContainer::IsChild(const CTIMENode & tn) const
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::IsChild(%p)",
              this,
              &tn));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == &tn)
        {
            return true;
        }
    }
    
    return false;
}

HRESULT
CTIMEContainer::SetMgr(CTIMENodeMgr * ptnm)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::SetMgr(%p)",
              this,
              ptnm));

    HRESULT hr;
    
    hr = CTIMENode::SetMgr(ptnm);
    if (FAILED(hr))
    {
        goto done;
    }

    {
        for (TIMENodeList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            hr = (*i)->SetMgr(ptnm);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        ClearMgr();
    }
    RRETURN(hr);
}

void
CTIMEContainer::ClearMgr()
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::ClearMgr()",
              this));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearMgr();
    }

    CTIMENode::ClearMgr();
}

void
CTIMEContainer::ResetChildren(CEventList * l, bool bPropagate)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::ResetChildren(%p, %d)",
              this,
              l,
              bPropagate));

    bool bOld = m_bIgnoreParentUpdate;

    m_bIgnoreParentUpdate = true;
    
    // Need to reset all children
        
    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        // Do not propagate changes until everyone has been reset
        (*i)->ResetNode(l, false, true);
    }
        
    for (i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ResetSinks(l);
    }

    m_bIgnoreParentUpdate = bOld;
    
    if (bPropagate)
    {
        CalcImplicitDur(l);
    }
}

void
CTIMEContainer::TickChildren(CEventList * l,
                             double dblNewSegmentTime,
                             bool bNeedPlay)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::TickChildren(%g, %d, %d, %d)",
              this,
              dblNewSegmentTime,
              GetDirection(),
              m_bFirstTick,
              bNeedPlay));
    
    dblNewSegmentTime = ApplySimpleTimeTransform(dblNewSegmentTime);

    if (CalcSimpleDirection() == TED_Forward)
    {
        for (TIMENodeList::iterator i = m_children.begin();
             i != m_children.end();
             i++)
        {
            (*i)->Tick(l,
                       dblNewSegmentTime,
                       bNeedPlay);
        }
    }
    else
    {
        for (TIMENodeList::reverse_iterator i = m_children.rbegin();
             i != m_children.rend();
             i++)
        {
            (*i)->Tick(l,
                       dblNewSegmentTime,
                       bNeedPlay);
        }
    }
}

void
CTIMEContainer::ParentUpdateSink(CEventList * l,
                                 CTIMENode & tn)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CalcImplicitDur(%p, %p)",
              this,
              &l,
              &tn));

    TEDirection dir = CalcActiveDirection();

    // Never recalc on a child notification when going backwards
    if (!m_bIgnoreParentUpdate && dir == TED_Forward)
    {
        CalcImplicitDur(l);
    }
    
  done:
    return;
}

void
CTIMEContainer::CalcImplicitDur(CEventList * l)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CalcImplicitDur(%p)",
              this,
              l));

    double d = TIME_INFINITE;
    double dblPrevSegmentDur = CalcCurrSegmentDur();
    
    // The rule is:
    //
    // - Start with infinite since if no children have a begin time
    //   endsync does not take effect
    // - Next only consider children who have a begin time and are
    //   playable
    // - For last - take the greatest of the values.  If it is the
    //   first value then use it since infinity will always be greater
    // - For first - take the least of the values
    
    bool bFirst = true;
    
    if (GetEndSync() == TE_ENDSYNC_FIRST ||
        GetEndSync() == TE_ENDSYNC_ALL ||
        GetEndSync() == TE_ENDSYNC_LAST)
    {
        for (TIMENodeList::iterator i = m_children.begin();
             i != m_children.end();
             i++)
        {
            CTIMENode * ptn = *i;
            
            if (!ptn->IsEndSync())
            {
                continue;
            }

            double dblEndSyncTime = ptn->GetLastEndSyncParentTime();

            switch(GetEndSync())
            {
              case TE_ENDSYNC_LAST:
                if (ptn->GetBeginParentTime() != TIME_INFINITE)
                {
                    if (bFirst || dblEndSyncTime > d)
                    {
                        d = dblEndSyncTime;
                        bFirst = false;
                    }
                }

                break;
              case TE_ENDSYNC_FIRST:
                if (ptn->GetBeginParentTime() != TIME_INFINITE)
                {
                    if (dblEndSyncTime < d)
                    {
                        d = dblEndSyncTime;
                    }
                }
                break;
              case TE_ENDSYNC_ALL:
                if (bFirst || dblEndSyncTime > d)
                {
                    d = dblEndSyncTime;
                    bFirst = false;
                }

                break;
            } //lint !e787
        }
    }
    else if (GetEndSync() == TE_ENDSYNC_MEDIA)
    {
        d = TE_UNDEFINED_VALUE;
    }
    
    if (m_dblImplicitDur != d)
    {
        m_dblImplicitDur = d;
        
        PropNotify(l,
                   (TE_PROPERTY_IMPLICITDUR));

        double dblSegmentDur;
        dblSegmentDur = CalcCurrSegmentDur();
    
        if (dblPrevSegmentDur != dblSegmentDur)
        {
            PropNotify(l,
                       (TE_PROPERTY_SEGMENTDUR));
        
            RecalcSegmentDurChange(l, false);
        }
    }

  done:
    return;
}

STDMETHODIMP
CTIMEContainer::get_endSync(TE_ENDSYNC * es)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::get_endSync()",
              this));

    CHECK_RETURN_NULL(es);

    *es = m_tesEndSync;
    
    return S_OK;
}

STDMETHODIMP
CTIMEContainer::put_endSync(TE_ENDSYNC es)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::put_endSync(%d)",
              this,
              es));

    HRESULT hr;
    CEventList l;
    
    m_tesEndSync = es;

    CalcImplicitDur(&l);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEContainer::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    TraceTag((tagError,
              "CTIMEContainer(%p)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
    {
        hr = CComCoClass<CTIMEContainer, &__uuidof(CTIMEContainer)>::Error(str, IID_ITIMEContainer, hr);
        delete [] str;
    }
    
    RRETURN(hr);
}

#if DBG
void
CTIMEContainer::Print(int spaces)
{
    CTIMENode::Print(spaces);
    
    TraceTag((tagPrintTimeTree,
              "%*s{",
              spaces,
              ""));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->Print(spaces + 2);
    }
    
    TraceTag((tagPrintTimeTree,
              "%*s}",
              spaces,
              ""));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\container.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: container.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#ifndef _TECONTAINER_H
#define _TECONTAINER_H

#include "NodeMgr.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CTIMEContainer
    : public CComCoClass<CTIMEContainer, &__uuidof(CTIMEContainer)>,
      public ITIMEContainer,
      public ISupportErrorInfoImpl<&IID_ITIMEContainer>,
      public CTIMENode
{
  public:
    CTIMEContainer();
    virtual ~CTIMEContainer();

    HRESULT Init(LPOLESTR id);
    
    void FinalRelease();

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEContainer"); }
#endif

    BEGIN_COM_MAP(CTIMEContainer)
        COM_INTERFACE_ENTRY2(ITIMENode, CTIMENode)
        COM_INTERFACE_ENTRY(ITIMEContainer)
        COM_INTERFACE_ENTRY2(ISupportErrorInfo,ITIMEContainer)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEContainer* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // ITIMEContainer
    //
    
    STDMETHOD(addNode)(ITIMENode * tn);
    STDMETHOD(removeNode)(ITIMENode * tn);
    STDMETHOD(get_numChildren)(long * l);
    
    STDMETHOD(get_endSync)(TE_ENDSYNC * flags);
    STDMETHOD(put_endSync)(TE_ENDSYNC flags);

    TE_ENDSYNC GetEndSync() { return m_tesEndSync; }

    void ParentUpdateSink(CEventList * l,
                          CTIMENode & tn);

  protected:
    HRESULT Error();

    // Overridden from CTIMENode so we can process our children
    HRESULT SetMgr(CTIMENodeMgr * ptnm);
    void ClearMgr();

    HRESULT Add(CTIMENode *bvr); //lint !e1411
    HRESULT Remove(CTIMENode *bvr); //lint !e1411
    
    bool IsChild(const CTIMENode & tn) const;
    
    HRESULT AddToChildren(CTIMENode * bvr);
    void RemoveFromChildren(CTIMENode * bvr);
    
    void TickChildren(CEventList * l,
                      double dblNewSegmentTime,
                      bool bNeedPlay);
    
    void TickEventChildren(CEventList * l,
                           TE_EVENT_TYPE et,
                           DWORD dwFlags);
    
    virtual void ResetChildren(CEventList * l, bool bPropagate);

    void CalcImplicitDur(CEventList * l);
    
#if DBG
    virtual void Print(int spaces);
#endif
  protected:
    TIMENodeList  m_children;
    TE_ENDSYNC    m_tesEndSync;
    bool          m_bIgnoreParentUpdate;
};

#endif /* _TECONTAINER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\beginend.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: beginend.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagBeginEnd, "TIME: Engine", "CTIMENode begin/end methods");

HRESULT
CTIMENode::AttachToSyncArc()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::AttachToSyncArc()",
              this));
    
    HRESULT hr;
    
    hr = THR(m_saBeginList.Attach());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_saEndList.Attach());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromSyncArc();
    }
    
    RRETURN(hr);
}
    
void
CTIMENode::DetachFromSyncArc()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::DetachFromSyncArc()",
              this));

    m_saBeginList.Detach();
    m_saEndList.Detach();
}

void
CTIMENode::UpdateSinks(CEventList * l, DWORD dwFlags)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateSinks(%p, %x)",
              this,
              l,
              dwFlags));

    m_ptsBeginSinks.Update(l, dwFlags);

    m_ptsEndSinks.Update(l, dwFlags);

    // Only notify parent if this is not a time shift
    if ((dwFlags & TS_TIMESHIFT) == 0 &&
        GetParent())
    {
        GetParent()->ParentUpdateSink(l, *this);
    }

  done:
    return;
}


void
CTIMENode::SyncArcUpdate(CEventList * l,
                         bool bBeginSink,
                         ISyncArc & tb)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::SyncArcUpdate(%p, %d, %p)",
              this,
              l,
              bBeginSink,
              &tb));
    
    Assert(IsReady());
    
    if (bBeginSink)
    {
        RecalcBeginSyncArcChange(l, tb.GetCurrTimeBase());
    }
    else
    {
        RecalcEndSyncArcChange(l, tb.GetCurrTimeBase());
    }
    
  done:
    return;
}

void
CTIMENode::UpdateBeginTime(CEventList * l,
                           double dblTime,
                           bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateBeginTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime != m_dblBeginParentTime)
    {
        m_dblBeginParentTime = dblTime;

        PropNotify(l, TE_PROPERTY_BEGINPARENTTIME);

        if (bPropagate)
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEBEGIN) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateBeginTime: Detected begin cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEBEGIN;
            
            m_ptsBeginSinks.Update(l, 0);

            m_dwUpdateCycleFlags &= ~TE_INUPDATEBEGIN;
        }
    }
    
  done:
    return;
}

void
CTIMENode::UpdateEndTime(CEventList * l, double dblTime, bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateEndTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime < GetBeginParentTime())
    {
        dblTime = GetBeginParentTime();
    }
    
    if (dblTime != m_dblEndParentTime)
    {
        m_dblEndParentTime = dblTime;

        PropNotify(l, TE_PROPERTY_ENDPARENTTIME);

        if (bPropagate)
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEEND) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateEndTime: Detected end cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEEND;
            
            m_ptsEndSinks.Update(l, 0);

            m_dwUpdateCycleFlags &= ~TE_INUPDATEEND;
        }
    }
    
  done:
    return;
}

void
CTIMENode::UpdateEndSyncTime(double dblTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateEndSyncTime(%g)",
              this,
              dblTime));

    if (dblTime < GetBeginParentTime())
    {
        dblTime = GetBeginParentTime();
    }
    
    if (dblTime != m_dblEndSyncParentTime)
    {
        m_dblEndSyncParentTime = dblTime;
    }
    
  done:
    return;
}

void
CTIMENode::UpdateLastEndSyncTime(CEventList * l, double dblTime, bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateLastEndSyncTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime < GetEndSyncParentTime())
    {
        dblTime = GetEndSyncParentTime();
    }
    
    if (dblTime != m_dblLastEndSyncParentTime)
    {
        m_dblLastEndSyncParentTime = dblTime;

        if (bPropagate && IsEndSync())
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEENDSYNC) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateLastEndsyncTime: Detected endsync cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEENDSYNC;
            
            if (GetParent())
            {
                GetParent()->ParentUpdateSink(l, *this);
            }
            
            m_dwUpdateCycleFlags &= ~TE_INUPDATEENDSYNC;
        }
    }
    
  done:
    return;
}

void
SkipTo(DoubleSet & ds,
       DoubleSet::iterator & i,
       double dblTime)
{
    while (i != ds.end())
    {
        if (*i >= dblTime)
        {
            break;
        }
        
        i++;
    }
}

double
CTIMENode::CalcNaturalBeginBound(double dblParentTime,
                                 bool bInclusive,
                                 bool bStrict)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcNaturalBeginBound(%g, %d, %d)",
              this,
              dblParentTime,
              bInclusive,
              bStrict));

    Assert(IsReady());

    double dblRet = TIME_INFINITE;

    DoubleSet dsBegin;
    DoubleSet dsEnd;
    DoubleSet::iterator i;
    DoubleSet::iterator e;
    double dblLocalDur;

    m_saBeginList.GetSortedSet(dsBegin,
                               true);
    m_saEndList.GetSortedSet(dsEnd,
                             false);
    dblLocalDur = CalcCurrLocalDur();
    
    double dblNextEnd;
    double dblNextBegin;

    dblNextBegin = TIME_INFINITE;
    dblNextEnd = -TIME_INFINITE;
    
    i = dsBegin.begin();
    e = dsEnd.begin();

    while(i != dsBegin.end()) //lint !e716
    {
        double t = *i;
        
        // See if there are any end times greater than the begin or
        // that the list of ends is empty
        if (dsEnd.size() != 0)
        {
            SkipTo(dsEnd, e, t);
            
            if (e == dsEnd.end())
            {
                break;
            }
        }
        
        // Update the begin
        dblNextBegin = t;

        // Update the next end time
        dblNextEnd = dblNextBegin + dblLocalDur;

        // Check the end list
        if (e != dsEnd.end() && *e < dblNextEnd)
        {
            Assert(*e >= dblNextBegin);
            
            dblNextEnd = *e;
        }

        // Advance to the next begin value
        // The skipto below will not work by itself when an end time
        // is the same as a begin time so this takes care of that
        i++;

        SkipTo(dsBegin, i, dblNextEnd);

        if (i == dsBegin.end())
        {
            break;
        }
        
        t = *i;
        
        // See if the new time is greater than the parent time
        if (t > dblParentTime ||
            (!bInclusive && t == dblParentTime))
        {
            break;
        }
    }

    dblRet = dblNextBegin;
    
    if (bStrict)
    {
        if (dblRet > dblParentTime || (dblRet == dblParentTime && !bInclusive))
        {
            dblRet = TIME_INFINITE;
        }
    }
    
  done:
    return dblRet;
}

void
CTIMENode::CalcBeginBound(double dblBaseTime,
                          bool bStrict,
                          double & dblBeginBound)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcBeginBound(%g, %d)",
              this,
              dblBaseTime,
              bStrict));

    double dblRet;
    TEDirection dir = GetParentDirection();
    bool bInclusive = (dir == TED_Forward);
    double dblMaxEnd;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        goto done;
    }

    // Get the max end value to use for clamping
    dblMaxEnd = GetMaxEnd();

    // This is based on the restart flag

    switch(GetRestart())
    {
      default:
        AssertStr(false, "Invalid restart flag");
      case TE_RESTART_ALWAYS:  //lint !e616
        if (dblBaseTime > dblMaxEnd)
        {
            dblBaseTime = dblMaxEnd;
        }
        
        dblRet = m_saBeginList.LowerBound(dblBaseTime,
                                          bInclusive,
                                          bStrict,
                                          true,
                                          bInclusive);

        if (dblMaxEnd < dblRet)
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        break;
      case TE_RESTART_NEVER:
        dblRet = m_saBeginList.UpperBound(-TIME_INFINITE,
                                          true,
                                          bStrict,
                                          true,
                                          true);

        if (dblMaxEnd < dblRet)
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        break;
      case TE_RESTART_WHEN_NOT_ACTIVE:
        dblRet = CalcNaturalBeginBound(dblBaseTime, bInclusive, bStrict);

        Assert(dblRet == TIME_INFINITE || dblMaxEnd >= dblRet);
        
        break;
    }

  done:
    dblBeginBound = dblRet;
}

void
CTIMENode::CalcEndBound(double dblParentTime,
                        bool bIncludeOneShots,
                        double & dblEndBound,
                        double & dblEndSyncBound)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcEndBound(%g)",
              this,
              dblParentTime));

    double dblRet;
    double dblEndSyncRet;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        dblEndSyncRet = TIME_INFINITE;
        goto done;
    }

    // We used to reject oneshots on first tick but this breaks the
    // endElement calls.  We need to address the filtering up higher
    // We do this by reseting the end one shots whenever we update the
    // begin time
    
    if (dblParentTime < GetBeginParentTime())
    {
        bIncludeOneShots = false;
    }

    // This is based on the restart flag
    dblRet = m_saEndList.UpperBound(dblParentTime,
                                    true,
                                    true,
                                    bIncludeOneShots,
                                    true);

    dblEndSyncRet = dblRet;

    switch(GetRestart())
    {
      default:
        AssertStr(false, "Invalid restart flag");
      case TE_RESTART_ALWAYS: //lint !e616
        {
            bool bInclusive = (dblParentTime > GetBeginParentTime());
            
            double dblBeginBound = m_saBeginList.UpperBound(dblParentTime,
                                                            bInclusive,
                                                            true,
                                                            bIncludeOneShots,
                                                            bInclusive);
            dblRet = min(dblRet, dblBeginBound);
        }        
        break;
      case TE_RESTART_NEVER:
      case TE_RESTART_WHEN_NOT_ACTIVE:
        // Don't do anything
        break;
    }

  done:
    dblEndBound = dblRet;
    dblEndSyncBound = dblEndSyncRet;
}

void
CTIMENode::CalcBeginTime(double dblBaseTime,
                         double & dblBeginTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcBeginTime(%g)",
              this,
              dblBaseTime));

    CalcBeginBound(dblBaseTime, false, dblBeginTime);
}

void
CTIMENode::CalcNextBeginTime(double dblBaseTime,
                             bool bForceInclusive,
                             double & dblBeginTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcNextBeginTime(%g, %d)",
              this,
              dblBaseTime,
              bForceInclusive));

    double dblRet;
    TEDirection dir = GetParentDirection();
    
    Assert(IsReady());

    if (dir == TED_Forward)
    {
        double dblMaxEnd = GetMaxEnd();
        
        bool bInclusive = (bForceInclusive ||
                           GetBeginParentTime() != GetEndParentTime() ||
                           GetBeginParentTime() != dblBaseTime);

        // One unusual thing here is that we are always inclusive of
        // one shots.  This is because a beginElement can come in at
        // the same time that a previous begin/endelement calls were
        // made.  We want to accept this and it should not cause
        // problems since one shots are reset after we begin
        dblRet = m_saBeginList.UpperBound(dblBaseTime,
                                          bInclusive,
                                          true,
                                          true,
                                          true);

        if (dblRet > dblMaxEnd)
        {
            dblRet = TIME_INFINITE;
        }
    }
    else
    {
        CalcBeginBound(dblBaseTime, true, dblRet);
    }
    
    dblBeginTime = dblRet;
}

double
CalcIntrinsicEndTime(CTIMENode & tn,
                     double dblParentTime,
                     double dblSegmentTime,
                     long lRepeatCount,
                     double dblActiveTime)
{
    TraceTag((tagBeginEnd,
              "CalcIntrinsicEndTime(%p, %g, %g, %ld, %g)",
              &tn,
              dblParentTime,
              dblSegmentTime,
              lRepeatCount,
              dblActiveTime));

    double dblRet;
    double dblSegmentDur = tn.CalcCurrSegmentDur();

    // Figure out how much repeat time is left and then sutract
    // the last current time
    // This is the amount of time remaining from the last tick
    // time is parent time

    // If the segment time is infinite then this will ultimately end
    // up either getting clamp by the active dur below or just ignored
    // later begin the sync arcs ended early.  If the repeat count is
    // expired this will still return infinity since we never reach
    // the repeat count but expect the segment time to be equal to the
    // segment dur.  Again, if the segment dur is infinite then this
    // will cause everything to be ignored.
    dblRet = (tn.CalcRepeatCount() - lRepeatCount) * dblSegmentDur;
            
    // Now subtract the elapsed segment time to get the amount of
    // time left
    dblRet -= dblSegmentTime;
        
    // Now add the elapsed time
    dblRet += dblActiveTime;
        
    // Clamp it
    dblRet = Clamp(0.0,
                   dblRet,
                   tn.GetActiveDur());
        
    // Now transform it into local time
    dblRet = tn.ReverseActiveTimeTransform(dblRet);
    
    // Now figure out how much extra time we added
    dblRet -= tn.ReverseActiveTimeTransform(dblActiveTime);
        
    // Now add the the current parent time
    dblRet += dblParentTime;

    return dblRet;
}

void
CTIMENode::CalcEndTime(double dblBaseTime,
                       bool bIncludeOneShots,
                       double dblParentTime,
                       double dblElapsedSegmentTime,
                       long lElapsedRepeatCount,
                       double dblElapsedActiveTime,
                       double & dblEndTime,
                       double & dblEndSyncTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcEndTime(%g, %d, %g, %g, %ld, %g)",
              this,
              dblBaseTime,
              bIncludeOneShots,
              dblParentTime,
              dblElapsedSegmentTime,
              lElapsedRepeatCount,
              dblElapsedActiveTime));

    double dblEndRet;
    double dblEndSyncRet;
    
    Assert(dblElapsedSegmentTime >= 0.0 &&
           dblElapsedSegmentTime <= CalcCurrSegmentDur());
    Assert(lElapsedRepeatCount >= 0 &&
           lElapsedRepeatCount < CalcRepeatCount());
    
    if (!IsReady())
    {
        dblEndRet = TIME_INFINITE;
        dblEndSyncRet = TIME_INFINITE;
        goto done;
    }

    double dblCalcEnd;
    dblCalcEnd = ::CalcIntrinsicEndTime(*this,
                                        dblParentTime,
                                        dblElapsedSegmentTime,
                                        lElapsedRepeatCount,
                                        dblElapsedActiveTime);
    
    double dblEndBound;
    double dblEndSyncBound;

    CalcEndBound(dblBaseTime,
                 bIncludeOneShots,
                 dblEndBound,
                 dblEndSyncBound);

    // Now take the minimum of the two
    dblEndRet = min(dblEndBound, dblCalcEnd);
    dblEndSyncRet = min(dblEndSyncBound, dblCalcEnd);
    
  done:
    dblEndTime = dblEndRet;
    dblEndSyncTime = dblEndSyncRet;
}

//
// This assume that the begin and end parent times are set so it can
// optimize a little bit
//

double
CTIMENode::CalcLastEndSyncTime()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcLastEndSyncTime()",
              this));

    double dblRet;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        goto done;
    }

    if (GetRestart() == TE_RESTART_NEVER)
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    double dblMaxEnd;
    dblMaxEnd = GetMaxEnd();

    bool bInclusive;
    bInclusive = (dblMaxEnd != TIME_INFINITE);
    
    double dblMaxBegin;
    dblMaxBegin = m_saBeginList.LowerBound(dblMaxEnd,
                                           bInclusive,
                                           true,
                                           true,
                                           bInclusive);

    // If we are in the last instance then use the currently
    // determined value
    if (dblMaxBegin <= GetBeginParentTime())
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    // If we are in the active period for the last begin then it
    // should be ignored if we are restart when not active
    if (GetRestart() == TE_RESTART_WHEN_NOT_ACTIVE &&
        dblMaxBegin < GetEndParentTime())
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    double dblCalcEnd;
    dblCalcEnd = dblMaxBegin + CalcCurrLocalDur();
    
    double dblEndBound;
    dblEndBound = m_saEndList.UpperBound(dblMaxBegin,
                                         true,
                                         true,
                                         false,
                                         false);

    dblRet = min(dblCalcEnd, dblEndBound);
  done:
    return dblRet;
}

void
CTIMENode::ResetBeginTime(CEventList * l,
                          double dblParentTime,
                          bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::ResetBeginTime(%p, %g, %d)",
              this,
              l,
              dblParentTime,
              bPropagate));

    double dblBegin;
            
    CalcBeginTime(dblParentTime, dblBegin);

    // Need to update this now so that the calcendtime gets the
    // correct end point
    UpdateBeginTime(l, dblBegin, bPropagate);
}

void
CTIMENode::ResetEndTime(CEventList * l,
                        double dblParentTime,
                        bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::ResetEndTime(%p, %g, %d)",
              this,
              l,
              dblParentTime,
              bPropagate));

    double dblEnd;
    double dblEndSync;
    TEDirection dir = GetParentDirection();
            
    CalcEndTime(GetBeginParentTime(),
                false,
                GetBeginParentTime(),
                0.0,
                0,
                0.0,
                dblEnd,
                dblEndSync);

    UpdateEndTime(l, dblEnd, bPropagate);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, bPropagate);

    if (dir == TED_Forward)
    {
        if (dblParentTime < GetEndParentTime() ||
            (IsFirstTick() && dblParentTime == GetEndParentTime()))
        {
            UpdateNextBoundaryTime(GetBeginParentTime());
        }
        else
        {
            double dblBegin;
            
            CalcNextBeginTime(dblParentTime, false, dblBegin);
            UpdateNextBoundaryTime(dblBegin);
        }
    }
    else
    {
        UpdateNextBoundaryTime(GetEndParentTime());
    }
}

void
CTIMENode::RecalcEndTime(CEventList * l,
                         double dblBaseTime,
                         double dblParentTime,
                         bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::RecalcEndTime(%p, %g, %g, %d)",
              this,
              l,
              dblBaseTime,
              dblParentTime,
              bPropagate));

    double dblSegmentTime = 0.0;
    long lRepeatCount = 0;
    double dblElapsedActiveTime = 0.0;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);
            
        lRepeatCount = GetSyncRepeatCount();
        dblSegmentTime = GetSyncSegmentTime();
        dblElapsedActiveTime = GetSyncActiveTime();
    }
    else if (IsActive() &&
             -TIME_INFINITE != m_dblCurrParentTime)
    {
        Assert(GetSyncRepeatCount() == TE_UNDEFINED_VALUE);
        Assert(GetSyncSegmentTime() == TIME_INFINITE);
        Assert(GetSyncActiveTime() == TIME_INFINITE);

        dblSegmentTime = m_dblCurrSegmentTime;
        lRepeatCount = m_lCurrRepeatCount;
        dblElapsedActiveTime = CalcElapsedActiveTime();
    }
    
    double dblEnd;
    double dblEndSync;
    
    CalcEndTime(dblBaseTime,
                true,
                dblParentTime,
                dblSegmentTime,
                lRepeatCount,
                dblElapsedActiveTime,
                dblEnd,
                dblEndSync);

    UpdateEndTime(l, dblEnd, bPropagate);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, bPropagate);

  done:
    return;
}

#ifdef _WIN64
#pragma optimize("",off)
#endif

void
CTIMENode::RecalcCurrEndTime(CEventList * l,
                             bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::RecalcEndTime(%p, %d)",
              this,
              l,
              bPropagate));

    double dblParentTime;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        dblParentTime = GetSyncParentTime();
    }
    else if (IsActive() &&
             -TIME_INFINITE != m_dblCurrParentTime)
    {
        dblParentTime = m_dblCurrParentTime;
    }
    else
    {
        dblParentTime = GetBeginParentTime();
    }
    
    RecalcEndTime(l, GetBeginParentTime(), dblParentTime, bPropagate);
}

#ifdef _WIN64
#pragma optimize("",on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\ease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"

void
CTIMENode::CalculateEaseCoeff()
{
    Assert(m_fltAccel >= 0.0f && m_fltAccel <= 1.0f);
    Assert(m_fltDecel >= 0.0f && m_fltDecel <= 1.0f);

    double dblDur = GetSimpleDur();

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentagMMes are non-zero
    
    m_bNeedEase = (dblDur != TIME_INFINITE &&
                   (m_fltAccel > 0.0f || m_fltDecel > 0.0f) &&
                   (m_fltAccel + m_fltDecel <= 1.0f));

    if (!m_bNeedEase) return;
    
    double dblAccelDuration = m_fltAccel * dblDur;
    double dblDecelDuration = m_fltDecel * dblDur;
    double dblMiddleDuration = dblDur - dblAccelDuration - dblDecelDuration;
    
    // Compute B1, the velocity during segment B.
    double flInvB1 = (-0.5f * m_fltAccel +
                     -0.5f * m_fltDecel + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (dblAccelDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = 0;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / dblAccelDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = static_cast<float>(m_flA0 + m_flA1 * dblAccelDuration + m_flA2 * dblAccelDuration * dblAccelDuration);
    
    if (dblDecelDuration != 0.0) {
        m_flC0 = static_cast<float>(m_flB1 * dblMiddleDuration + m_flB0);
        m_flC1 = m_flB1;
        m_flC2 = static_cast<float>(-0.5f * m_flC1 / dblDecelDuration);
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_fltAccelEnd = static_cast<float>(dblAccelDuration);
    m_fltDecelStart = static_cast<float>(dblDur - dblDecelDuration);
}

static double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CTIMENode::ApplySimpleTimeTransform(double time) const
{
    if (!m_bNeedEase || time <= 0 || time >= CalcCurrSegmentDur())
        return time;
    
    if (time <= m_fltAccelEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_fltDecelStart) {
        return Quadratic(time - m_fltAccelEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_fltDecelStart, m_flC2, m_flC1, m_flC0);
    }
}

double
CTIMENode::ReverseSimpleTimeTransform(double time) const
{
    return time;
}

double
CTIMENode::ApplyActiveTimeTransform(double dblTime) const
{
    return dblTime * GetRate();
}

double
CTIMENode::ReverseActiveTimeTransform(double dblTime) const
{
    return dblTime / GetRate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\factory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "Container.h"
#include "NodeMgr.h"

HRESULT
TECreateBehavior(LPOLESTR id, ITIMENode **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    CComObject<CTIMENode> *pNew;
    CComObject<CTIMENode>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(id));
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMENode, (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
TECreateTimeline(LPOLESTR id, ITIMEContainer **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    CComObject<CTIMEContainer> *pNew;
    CComObject<CTIMEContainer>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMEContainer,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
TECreatePlayer(LPOLESTR id,
               IUnknown * punk,
               IServiceProvider * sp,
               ITIMENodeMgr **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    CComObject<CTIMENodeMgr> *pNew;
    CComObject<CTIMENodeMgr>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CComPtr<ITIMENode> bvr;

        hr = THR(punk->QueryInterface(IID_ITIMENode, (void**)&bvr));
        hr = THR(pNew->Init(id,bvr,sp));
        
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMENodeMgr,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\methods.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: methods.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CTIMENode::BaseInternalQueryInterface(CTIMENode* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CTIMENode *
GetBvr(IUnknown * pbvr)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CTIMENode * bvr = NULL;

    if (pbvr)
    {
        // !!!! This does not do an addref
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        TIMESetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

STDMETHODIMP
CTIMENode::beginAt(double dblParentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::beginAt(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return
    if (!IsReady() ||
        !GetContainer().ContainerIsActive())
    {
        hr = S_OK;
        goto done;
    }

    if (IsActive())
    {
        if (GetRestart() != TE_RESTART_ALWAYS)
        {
            hr = S_OK;
            goto done;
        }

        hr = THR(endAt(GetCurrParentTime()));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(pto),
                               true,
                               NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    RecalcBeginSyncArcChange(&l, dblParentTime);
    
    if (m_bFirstTick && IsActive())
    {
        // We need to defer the begin if we are locked, on our begin
        // point, and our parent needs a first tick
        bool bSkip = (IsLocked() &&
                      GetCurrParentTime() == CalcActiveBeginPoint() &&
                      GetContainer().ContainerIsFirstTick());

        if (!bSkip)
        {
            TickEvent(&l, TE_EVENT_BEGIN, 0);
        }
    }
    
            
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

STDMETHODIMP
CTIMENode::addBegin(double dblParentTime,
                    LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBegin(%#x)",
              this,
              dblParentTime));

    HRESULT hr;

    SET_NULL(cookie);

    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(pto),
                               false,
                               cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_BEGIN);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::addBeginSyncArc(ITIMENode * node,
                           TE_TIMEPOINT tep,
                           double dblOffset,
                           LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBeginSyncArc(%p, %#x, %g)",
              this,
              node,
              tep,
              dblOffset));

    HRESULT hr;
    
    CHECK_RETURN_NULL(node);
    SET_NULL(cookie);

    CTIMENode * ptn = GetBvr(node);
    if (!ptn)
    {
        hr = E_INVALIDARG;
        goto done;
    }
     
    CSyncArcTimeBase * ptb;
    ptb = new CSyncArcTimeBase(m_saBeginList,
                               *ptn,
                               tep,
                               dblOffset);

    if (ptb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(ptb),
                               false,
                               cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_BEGIN);
    
    hr = S_OK;
  done:
    RRETURN2(hr, E_OUTOFMEMORY, E_INVALIDARG); //lint !e429
}

STDMETHODIMP
CTIMENode::removeBegin(LONG cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBegin(%#x)",
              this,
              cookie));

    HRESULT hr;
    bool bNeedUpdate = false;

    if (cookie == 0)
    {
        bNeedUpdate = m_saBeginList.Clear();
    }
    else
    {
        bNeedUpdate = m_saBeginList.Remove(cookie, true);
    }
    
    if (bNeedUpdate)
    {
        Invalidate(TE_INVALIDATE_BEGIN);
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::endAt(double dblParentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::endAt(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return
    if (!IsReady() ||
        !GetContainer().ContainerIsActive())
    {
        hr = S_OK;
        goto done;
    }

    // #14226 ie6 DB
    // This causes problems when you call begin immediately
    // followed by an end call from script.  It also will do the
    // wrong thing if you seek to the middle and start playing since
    // you should react to those events.
    // I need to see if we can solve the case of a begin and end event
    // being the same a different way.  It probably needs to go in
    // timeelmbase.cpp
    
#if 0
    // If we are not active or we have not ticked yet (which means
    // that we just became active) then ignore all end ats.
    if (!IsActive() || IsFirstTick())
    {
        hr = S_OK;
        goto done;
    }
#endif
    
    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(pto),
                             true,
                             NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    RecalcEndSyncArcChange(&l, dblParentTime);
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

STDMETHODIMP
CTIMENode::addEnd(double dblParentTime,
                  LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEnd(%#x)",
              this,
              dblParentTime));

    HRESULT hr;

    SET_NULL(cookie);

    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(pto),
                             false,
                             cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_END);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::addEndSyncArc(ITIMENode * node,
                         TE_TIMEPOINT tep,
                         double dblOffset,
                         LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEndSyncArc(%p, %#x, %g)",
              this,
              node,
              tep,
              dblOffset));

    HRESULT hr;

    CHECK_RETURN_NULL(node);
    SET_NULL(cookie);

    CTIMENode * ptn = GetBvr(node);
    if (!ptn)
    {
        hr = E_INVALIDARG;
        goto done;
    }
     
    CSyncArcTimeBase * ptb;
    ptb = new CSyncArcTimeBase(m_saEndList,
                               *ptn,
                               tep,
                               dblOffset);

    if (ptb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(ptb),
                             false,
                             cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_END);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::removeEnd(LONG cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEnd(%#x)",
              this,
              cookie));

    HRESULT hr;
    bool bNeedUpdate = false;

    if (cookie == 0)
    {
        bNeedUpdate = m_saEndList.Clear();
    }
    else
    {
        bNeedUpdate = m_saEndList.Remove(cookie, true);
    }
    
    if (bNeedUpdate)
    {
        Invalidate(TE_INVALIDATE_END);
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::pause()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::pause()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }

    if (!CalcIsPaused())
    {
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_PAUSE);

        m_bIsPaused = true;

        TickEventChildren(&l, TE_EVENT_PAUSE, 0);
    }

    // Set before firing events
    m_bIsPaused = true;
    
    PropNotify(&l, TE_PROPERTY_ISPAUSED | TE_PROPERTY_ISCURRPAUSED);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::resume()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::resume()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be paused
    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // If we were paused and our parent was not paused then fire a
    // resume event
    if (CalcIsPaused() && !GetIsParentPaused())
    {
        m_bIsPaused = false;

        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_RESUME);

        TickEventChildren(&l, TE_EVENT_RESUME, 0);
    }
    
    // Set before firing the event
    m_bIsPaused = false;
    
    PropNotify(&l, TE_PROPERTY_ISPAUSED | TE_PROPERTY_ISCURRPAUSED);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::disable()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::disable()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!CalcIsDisabled())
    {
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_DISABLE);

        m_bIsDisabled = true;

        TickEventChildren(&l, TE_EVENT_DISABLE, 0);
    }

    // Set before firing events
    m_bIsDisabled = true;
    
    PropNotify(&l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::enable()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::enable()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we were enabled and our parent was not enabled then fire an
    // enable event
    if (CalcIsDisabled() && !GetIsParentDisabled())
    {
        m_bIsDisabled = false;

        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_ENABLE);

        TickEventChildren(&l, TE_EVENT_ENABLE, 0);
    }
    
    // Set before firing the event
    m_bIsDisabled = false;
    
    PropNotify(&l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::reset()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::reset()",
              this));

    HRESULT hr;
    CEventList l;
    bool bPrevActive = (IsActive() && !IsFirstTick());
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    ResetNode(&l, true);
    
    if (IsActive())
    {
        if (!bPrevActive)
        {
            TickEvent(&l, TE_EVENT_BEGIN, 0);
        }
        else
        {
            m_bFirstTick = false;
        }
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

// This takes times which are post ease (since this is what the user
// sees)

STDMETHODIMP
CTIMENode::seekSegmentTime(double dblSegmentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekSegmentTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(SeekTo(GetCurrRepeatCount(), dblSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::seekActiveTime(double dblActiveTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekActiveTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    double dblSegmentDur;
    dblSegmentDur = CalcCurrSegmentDur();
    
    LONG lCurrRepeat;
    double dblNewSegmentTime;

    CalcActiveComponents(dblActiveTime,
                         dblNewSegmentTime,
                         lCurrRepeat);

    hr = THR(SeekTo(lCurrRepeat, dblNewSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} //lint !e550

// This takes times which are post ease (since this is what the user
// sees)

STDMETHODIMP
CTIMENode::seekTo(LONG lRepeatCount, double dblSegmentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekTo(%ld, %g)",
              this,
              lRepeatCount,
              dblSegmentTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(SeekTo(lRepeatCount, dblSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::update(DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::update(%x)",
              this,
              dwFlags));

    HRESULT hr;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    Invalidate(dwFlags);
    
    hr = THR(EnsureUpdate());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::addBehavior(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBehavior(%#x)",
              this,
              tnb));
    
    RRETURN(m_nbList.Add(tnb));
}

STDMETHODIMP
CTIMENode::removeBehavior(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::removeBehavior(%#x)",
              this,
              tnb));
    
    RRETURN(m_nbList.Remove(tnb));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\nodebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "Node.h"

DeclareTag(tagTIMENodeBvr, "TIME: Engine", "Behavior methods");

typedef std::list<ITIMENodeBehavior *> TIMENodeBvrList;

CNodeBvrList::CNodeBvrList()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::CNodeBvrList()",
              this));
}

CNodeBvrList::~CNodeBvrList()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::~CNodeBvrList()",
              this));
}

HRESULT
CNodeBvrList::Add(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::Add(%#x)",
              this,
              tnb));
    
    HRESULT hr;

    // TODO: Need to handle out of memory conditions
    m_tnbList.push_back(tnb);
    tnb->AddRef();
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CNodeBvrList::Remove(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::Remove(%#x)",
              this,
              tnb));
    
    HRESULT hr;
    TIMENodeBvrList ::iterator i;

    for (i = m_tnbList.begin(); i != m_tnbList.end(); i++)
    {
        if ((*i) == tnb)
        {
            m_tnbList.erase(i);
            tnb->Release();
            break;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

class Dispatcher
{
  public:
    virtual HRESULT DoIt(ITIMENodeBehavior *) = 0;
};

HRESULT
Dispatch(const TIMENodeBvrList & l,
         HRESULT initialHR,
         Dispatcher & d)
{
    HRESULT hr = initialHR;

    TIMENodeBvrList ::iterator i;

    // Since the user might do something during the callback which can
    // affect this list we copy the list, addref each node bvrs and
    // then and only then call out into the behavior.  This ensures
    // that we have a strong reference and a private data structure
    // which cannot be hurt by reentrancy
    
    // @@ ISSUE : We can run out of memory
    TIMENodeBvrList bvrListCopy(l);

    // Now addref the node bvrs
    for (i = bvrListCopy.begin(); i != bvrListCopy.end(); i++)
    {
        (*i)->AddRef();
    }

    // TODO: We should actually addref our container so that it cannot
    // go away during the callback
    // We do not have the object stored so postpone for now
    
    // Now dispatch and release
    for (i = bvrListCopy.begin(); i != bvrListCopy.end(); i++)
    {
        HRESULT tmphr;

        tmphr = THR(d.DoIt(*i));
        (*i)->Release();
        
        if (S_OK != tmphr)
        {
            hr = tmphr;
        }
    }

  done:
    RRETURN1(hr, initialHR);
}

class TickDispatcher
    : public Dispatcher
{
  public:
    TickDispatcher() {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->tick());
    }
};

HRESULT
CNodeBvrList::DispatchTick()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchTick()",
              this));
    
    HRESULT hr;

    TickDispatcher td;

    hr = THR(Dispatch(m_tnbList, S_OK, td));

    RRETURN(hr);
}

class EventDispatcher
    : public Dispatcher
{
  public:
    EventDispatcher(double eventTime,
                    TE_EVENT_TYPE eventType,
                    long repeatCount) :
    m_eventTime(eventTime),
    m_eventType(eventType),
    m_lRepeatCount(repeatCount)
    {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->eventNotify(m_eventTime, m_eventType, m_lRepeatCount));
    }

    double m_eventTime;
    TE_EVENT_TYPE m_eventType;
    long m_lRepeatCount;
  protected:
    EventDispatcher();
};

HRESULT
CNodeBvrList::DispatchEventNotify(double eventTime,
                                  TE_EVENT_TYPE eventType,
                                  long lRepeatCount)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchEventNotify(%g, %s)",
              this,
              eventTime,
              EventString(eventType)));
    
    HRESULT hr;

    EventDispatcher ed(eventTime, eventType, lRepeatCount);

    hr = THR(Dispatch(m_tnbList, S_OK, ed));
    
    RRETURN(hr);
}

HRESULT
CNodeBvrList::DispatchGetSyncTime(double & dblNewTime,
                                  LONG & lNewRepeatCount,
                                  bool & bCueing)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchGetSyncTime()",
              this));
    
    HRESULT hr;
    TIMENodeBvrList ::iterator i;

    hr = S_FALSE;

    for (i = m_tnbList.begin(); i != m_tnbList.end(); i++)
    {
        VARIANT_BOOL vb;
        HRESULT tmphr;

        tmphr = THR((*i)->getSyncTime(&dblNewTime,
                                      &lNewRepeatCount,
                                      &vb));
        if (tmphr == S_OK)
        {
            hr = S_OK;
            bCueing = (vb == VARIANT_FALSE)?false:true;
            break;
        }
    }
    
    RRETURN1(hr, S_FALSE);
}

class PropDispatcher
    : public Dispatcher
{
  public:
    PropDispatcher(DWORD tePropType)
    : m_tePropType(tePropType)
    {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->propNotify(m_tePropType));
    }

    DWORD m_tePropType;
  protected:
    PropDispatcher();
};

HRESULT
CNodeBvrList::DispatchPropNotify(DWORD tePropType)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchPropNotify(%d)",
              this,
              tePropType));
    
    HRESULT hr;

    PropDispatcher pd(tePropType);

    hr = THR(Dispatch(m_tnbList, S_OK, pd));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\nodecontainer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodecontainer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _NODECONTAINER_H
#define _NODECONTAINER_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class ATL_NO_VTABLE
CNodeContainer
{
  public:
    virtual double ContainerGetSegmentTime() const = 0;
    virtual double ContainerGetSimpleTime() const = 0;
    virtual TEDirection ContainerGetDirection() const = 0;
    virtual float  ContainerGetRate() const = 0;
    virtual bool   ContainerIsActive() const = 0;
    virtual bool   ContainerIsOn() const = 0;
    virtual bool   ContainerIsPaused() const = 0;
    virtual bool   ContainerIsDeferredActive() const = 0;
    virtual bool   ContainerIsFirstTick() const = 0;
    virtual bool   ContainerIsDisabled() const = 0;
};

#endif /* _NODECONTAINER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\node.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: node.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#ifndef _TIMENODE_H
#define _TIMENODE_H

#pragma once

#include "timebase.h"
#include "nodebvr.h"
#include "nodecontainer.h"

class CTIMEContainer;
class CTIMENodeMgr;

extern TRACETAG tagTIMENode;

class CTIMENode;
typedef std::list<CTIMENode*> TIMENodeList;
class CEventList;

#define TE_INVALIDATE_BEGIN      0x00000001
#define TE_INVALIDATE_END        0x00000002
#define TE_INVALIDATE_DUR        0x00000004
#define TE_INVALIDATE_SIMPLETIME 0x00000008
#define TE_INVALIDATE_STATE      0x00000010
    
// This is for detecting cycles
#define TE_INUPDATEBEGIN         0x00000001
#define TE_INUPDATEEND           0x00000002
#define TE_INUPDATEENDSYNC       0x00000004

// Tick Event Flags
// This flags means that we are in a child of the originator of the
// event.  This is used to know why we ended the element (due to the
// element naturally ending or the parent ending).
#define TE_EVENT_INCHILD         0x10000000

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CTIMENode
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMENode, &__uuidof(CTIMENode)>,
      public ITIMENode,
      public ISupportErrorInfoImpl<&IID_ITIMENode>,
      public CNodeContainer
{
  public:
    CTIMENode();
    virtual ~CTIMENode();

    HRESULT Init(LPOLESTR id);
    
#if DBG
    virtual const _TCHAR * GetName() const { return __T("CTIMENode"); }
#endif

    BEGIN_COM_MAP(CTIMENode)
        COM_INTERFACE_ENTRY(ITIMENode)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();


    // Stuff to get ATL working correctly
    
    static HRESULT WINAPI
        BaseInternalQueryInterface(CTIMENode* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMENode* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
        { return BaseInternalQueryInterface(pThis,
                                            (void *) pThis,
                                            pEntries,
                                            iid,
                                            ppvObject); }

    // IUnknown
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // ITIMENode interface
    //
    
    STDMETHOD(get_id)(LPOLESTR * s);
    STDMETHOD(put_id)(LPOLESTR s);
        
    STDMETHOD(get_dur)(double * pdbl);
    STDMETHOD(put_dur)(double dbl);
        
    STDMETHOD(get_repeatCount)(double * pdbl);
    STDMETHOD(put_repeatCount)(double dbl);
       
    STDMETHOD(get_repeatDur)(double * f);
    STDMETHOD(put_repeatDur)(double f);
        
    STDMETHOD(get_fill)(TE_FILL_FLAGS *);
    STDMETHOD(put_fill)(TE_FILL_FLAGS);
    
    STDMETHOD(get_autoReverse)(VARIANT_BOOL * pr);
    STDMETHOD(put_autoReverse)(VARIANT_BOOL r);
        
    STDMETHOD(get_speed)(float *);
    STDMETHOD(put_speed)(float);

    STDMETHOD(get_accelerate)(float *);
    STDMETHOD(put_accelerate)(float);

    STDMETHOD(get_decelerate)(float *);
    STDMETHOD(put_decelerate)(float);

    STDMETHOD(get_flags)(DWORD *);
    STDMETHOD(put_flags)(DWORD);

    STDMETHOD(get_restart)(TE_RESTART_FLAGS * pr);
    STDMETHOD(put_restart)(TE_RESTART_FLAGS r);
        
    //
    // Begin
    //
    STDMETHOD(addBegin)(double dblOffset,
                        LONG * cookie);
    STDMETHOD(addBeginSyncArc)(ITIMENode * node,
                               TE_TIMEPOINT tep,
                               double dblOffset,
                               LONG * cookie);
    // If you specify 0 then we will remove everything
    STDMETHOD(removeBegin)(LONG cookie);
    
    STDMETHOD(beginAt)(double dblParentTime);

    //
    // End
    //
    STDMETHOD(addEnd)(double dblOffset,
                      LONG * cookie);
    STDMETHOD(addEndSyncArc)(ITIMENode * node,
                             TE_TIMEPOINT tep,
                             double dblOffset,
                             LONG * cookie);
    // If you specify 0 then we will remove everything
    STDMETHOD(removeEnd)(LONG cookie);
    
    STDMETHOD(endAt)(double dblParentTime);

    STDMETHOD(pause)();
    STDMETHOD(resume)();
    
    STDMETHOD(enable)();
    STDMETHOD(disable)();
    
    STDMETHOD(seekSegmentTime)(double dblSegmentTime);
    STDMETHOD(seekActiveTime)(double dblActiveTime);
    STDMETHOD(seekTo)(LONG lRepeatCount, double dblSegmentTime);

    //
    // Calculated values
    //

    STDMETHOD(get_beginParentTime)(double * d);
    
    // This is the time on the parents timeline at which the node
    // will or already has ended.  If it is infinite then the end
    // time is unknown.
    // This is in posttransformed parent time.
    STDMETHOD(get_endParentTime)(double * d);
    
    // This is the current simple time of the node.
    STDMETHOD(get_currSimpleTime)(double * d);
    
    // This is the number of times the node has repeated
    STDMETHOD(get_currRepeatCount)(LONG * l);

    // This is the current segment time of the node.
    STDMETHOD(get_currSegmentTime)(double * d);
    
    STDMETHOD(get_currImplicitDur)(double * d);
    
    STDMETHOD(get_currActiveTime)(double * d);

    STDMETHOD(get_currProgress)(double * d);

    STDMETHOD(get_currSegmentDur)(double * d);

    STDMETHOD(get_currSimpleDur)(double * d);

    STDMETHOD(get_currSpeed)(float * speed);

    STDMETHOD(get_naturalDur)(double *);
    STDMETHOD(put_naturalDur)(double);
    
    //
    // These are read-only attributes
    //
    
    // This is the total time during which the element is active.
    // This does not include fill time which extends past the active
    // duration.
    STDMETHOD(get_activeDur)(double *);

    // This is the parent's time when the last tick occurred (when it
    // was currTime)
    STDMETHOD(get_currParentTime)(double * d);

    // This will return whether the node is active.  This will be
    // false if the node is in the fill period
    STDMETHOD(get_isActive)(VARIANT_BOOL * b);

    // This will return true if the node is active or in the fill period
    STDMETHOD(get_isOn)(VARIANT_BOOL * b);

    // This will return whether node itself has been paused explicitly
    STDMETHOD(get_isPaused)(VARIANT_BOOL * b);

    // This will return whether node itself has been paused explicitly
    STDMETHOD(get_isCurrPaused)(VARIANT_BOOL * b);

    // This will return whether node itself has been disabled explicitly
    STDMETHOD(get_isDisabled)(VARIANT_BOOL * b);

    // This will return whether node itself has been disabled explicitly
    STDMETHOD(get_isCurrDisabled)(VARIANT_BOOL * b);

    // This will return the detailed state flags
    STDMETHOD(get_stateFlags)(TE_STATE * lFlags);

    //
    // Methods
    //
    
    STDMETHOD(reset)();

    // This will update the attributes and propagate to the media
    // leaves.
    STDMETHOD(update)(DWORD dwFlags);


    STDMETHOD(addBehavior)(ITIMENodeBehavior * tnb);
    STDMETHOD(removeBehavior)(ITIMENodeBehavior * tnb);
    
    STDMETHOD(documentTimeToParentTime)(double dblDocumentTime,
                                      double * pdblParentTime);
    STDMETHOD(parentTimeToDocumentTime)(double dblParentTime,
                                      double * pdblDocumentTime);
    STDMETHOD(parentTimeToActiveTime)(double dblParentTime,
                                      double * pdblActiveTime);
    STDMETHOD(activeTimeToParentTime)(double dblActiveTime,
                                      double * pdblParentTime);
    STDMETHOD(activeTimeToSegmentTime)(double dblActiveTime,
                                      double * pdblSegmentTime);
    STDMETHOD(segmentTimeToActiveTime)(double dblSegmentTime,
                                      double * pdblActiveTime);
    STDMETHOD(simpleTimeToSegmentTime)(double dblSimpleTime,
                                      double * pdblSegmentTime);
    STDMETHOD(segmentTimeToSimpleTime)(double dblSegmentTime,
                                      double * pdblSimpleTime);

    //
    // CTIMENode virtual methods
    //

    HRESULT DispatchTick(bool bTickChildren,
                         DWORD dwFlags);

    HRESULT DispatchEvent(double time,
                          TE_EVENT_TYPE et,
                          long lRepeatCount);

    HRESULT DispatchPropChange(DWORD tePropTypes);

    HRESULT DispatchGetSyncTime(double & dblNewTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing);
    
    //
    // CNodeContainer
    //
    
    double ContainerGetSegmentTime() const { return GetCurrSegmentTime(); }
    double ContainerGetSimpleTime() const { return CalcCurrSimpleTime(); }
    TEDirection ContainerGetDirection() const { return CalcSimpleDirection(); }
    float  ContainerGetRate() const { return GetCurrRate(); }
    bool   ContainerIsActive() const { return IsActive(); }
    bool   ContainerIsOn() const { return CalcIsOn(); }
    bool   ContainerIsPaused() const { return CalcIsPaused(); }
    bool   ContainerIsDisabled() const { return CalcIsDisabled(); }
    bool   ContainerIsDeferredActive() const { return IsDeferredActive(); }
    bool   ContainerIsFirstTick() const { return IsFirstTick(); }

    //
    // Accessors
    //

    LPCWSTR           GetID() const { return m_pszID; }
    double            GetDur() const { return m_dblDur; }
    double            GetRepeatCount() const { return m_dblRepeatCount; }
    double            GetRepeatDur() const { return m_dblRepeatDur; }
    TE_FILL_FLAGS     GetFill() const { return m_tefFill; }
    bool              GetAutoReverse() const { return m_bAutoReverse; }
    float             GetSpeed() const { return m_fltSpeed; }
    float             GetAccel() const { return m_fltAccel; }
    float             GetDecel() const { return m_fltDecel; }
    DWORD             GetFlags() const { return m_dwFlags; }
    TE_RESTART_FLAGS  GetRestart() const { return m_teRestart; }
    double            GetNaturalDur() const { return m_dblNaturalDur; }
    double            GetImplicitDur() const { return m_dblImplicitDur; }

    // This just returns whether we are currently set to be paused.
    // It does not take into account our parent's pause state.
    bool              GetIsPaused() const { return m_bIsPaused; }

    bool              GetIsDisabled() const { return m_bIsDisabled; }

    //
    // 
    //
    
    inline bool IsSyncMaster() const;
    inline bool IsLocked() const;
    inline bool IsCanSlip() const;
    inline bool IsEndSync() const;
    
    // Parent state
    CTIMEContainer * GetParent() const { return m_ptnParent; }
    void SetParent(CTIMEContainer * ptnParent);
    void ClearParent();

    // We must always set the parent before the node mgr
    // All attaching and sink work is only done when a node mgr exists
    CTIMENodeMgr * GetMgr() const { return m_ptnmNodeMgr; }
    virtual HRESULT SetMgr(CTIMENodeMgr * ptnm);
    virtual void ClearMgr();

    CNodeContainer & GetContainer() const;
    const CNodeContainer * GetContainerPtr() const;
    
    virtual void ResetNode(CEventList * l,
                           bool bPropagate = true,
                           bool bResetOneShot = true); //lint !e1735

    virtual void UpdateNode(CEventList * l);
    virtual void ResetChildren(CEventList * l, bool bPropagate);
    virtual void CalcImplicitDur(CEventList * l) {}

    void UpdateSinks(CEventList * l, DWORD dwFlags);
    void ResetSinks(CEventList * l);
    void ResetOneShots();

    HRESULT EnsureUpdate();
    
    // We are not considered ready until we know our node mgr.
    bool     IsReady() const { return m_ptnmNodeMgr != NULL; }
    bool     IsActive() const { return m_bIsActive; }
    bool     IsDeferredActive() const { return m_bDeferredActive; }
    bool     IsEndedByParent() const { return m_bEndedByParent; }
    bool     CalcIsOn() const;
    bool     CalcIsActive() const;

    // This returns whether we are truly paused or not - regardless of
    // why.  This is true if either we are paused or our parent
    bool     CalcIsPaused() const;
    bool     GetIsParentPaused() const { return m_bIsParentPaused; }

    bool     CalcIsDisabled() const;
    bool     GetIsParentDisabled() const { return m_bIsParentDisabled; }

    double   GetBeginParentTime() const { return m_dblBeginParentTime; }
    double   GetEndParentTime() const { return m_dblEndParentTime; }
    double   CalcActiveBeginPoint(TEDirection ted) const;
    double   CalcActiveEndPoint(TEDirection ted) const;
    double   CalcActiveBeginPoint() const;
    double   CalcActiveEndPoint() const;
    double   GetEndSyncParentTime() const { return m_dblEndSyncParentTime; }
    double   GetLastEndSyncParentTime() const { return m_dblLastEndSyncParentTime; }
    double   GetNextBoundaryParentTime() const { return m_dblNextBoundaryParentTime; }
    double   GetCurrParentTime() const { return m_dblCurrParentTime; }
    LONG     GetCurrRepeatCount() const { return m_lCurrRepeatCount; }
    double   GetCurrSegmentTime() const { return m_dblCurrSegmentTime; }
    double   GetElapsedActiveRepeatTime() const { return m_dblElapsedActiveRepeatTime; }
    double   CalcElapsedActiveTime() const;

    double   GetActiveDur() const { return m_dblActiveDur; }
    double   CalcLocalDur() const;
    double   GetSimpleDur() const { return m_dblSimpleDur; }
    double   GetSegmentDur() const { return m_dblSegmentDur; }
    double   CalcCurrSimpleDur() const;
    double   CalcCurrSegmentDur() const;
    double   CalcCurrLocalDur() const;
    double   CalcCurrActiveDur() const;
    double   CalcEffectiveActiveDur() const;
    double   CalcEffectiveLocalDur() const;
    double   CalcRepeatCount() const;
    
    bool        IsFirstTick() const { return m_bFirstTick; }
    TEDirection GetParentDirection() const { return m_tedParentDirection; }
    TEDirection GetDirection() const { return m_tedDirection; }
    TEDirection CalcActiveDirection() const;
    TEDirection CalcSimpleDirection() const;
    float       GetParentRate() const { return m_fltParentRate; }
    float       GetRate() const { return m_fltRate; }
    float       GetCurrRate() const;
    
    bool        IsInTick() const { return m_bInTick; }

    const CSyncArcList & GetBeginList() const { return m_saBeginList; }
    const CSyncArcList & GetEndList() const { return m_saEndList; }

    //
    // State management methods
    //

    // Invalidate should be called after each inline attribute is
    // changed to ensure that the runtime attributes are updated at
    // the appropriate time
    // The flags indicates which attributes have become dirty.
    virtual void Invalidate(DWORD dwFlags);

    // Dependency management
    inline HRESULT AddBeginTimeSink(ITimeSink * sink);
    inline void RemoveBeginTimeSink(ITimeSink * sink);

    inline HRESULT AddEndTimeSink(ITimeSink* sink);
    inline void RemoveEndTimeSink(ITimeSink* sink);
    
    void SyncArcUpdate(CEventList * l,
                       bool bBeginSink,
                       ISyncArc & tb);
    
    //
    // Ticking and event mgr
    //
    
    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    void TickEvent(CEventList * l,
                   TE_EVENT_TYPE et,
                   DWORD dwFlags);
    
    void Tick(CEventList * l,
              double dblNewParentTime,
              bool bNeedBegin);

    // The time here is the local time
    void EventNotify(CEventList *l,
                     double lTime,
                     TE_EVENT_TYPE et,
                     long lRepeatCount = 0);
    
    void PropNotify(CEventList *l,
                    DWORD pt);
    
    // This will check to see if we are in our active period
    inline bool CheckActiveTime(double t, bool bRespectEndHold) const;

    //
    // Synchronization
    //
    
    double GetSyncSegmentTime() const { return m_dblSyncSegmentTime; }
    LONG   GetSyncRepeatCount() const { return m_lSyncRepeatCount; }
    double GetSyncActiveTime() const { return m_dblSyncActiveTime; }
    double GetSyncParentTime() const { return m_dblSyncParentTime; }
    double GetSyncNewParentTime() const { return m_dblSyncNewParentTime; }
    bool   IsSyncCueing() const { return m_bSyncCueing; }

#if OLD_TIME_ENGINE
    virtual HRESULT OnBvrCB(CEventList * l,
                            double gTime);
#endif
    HRESULT CheckSyncTimes(double & dblNewSegmentTime,
                           LONG & lNewRepeatCount) const;
    HRESULT SyncNode(CEventList * l,
                     double dblNextGlobalTime,
                     double dblNewTime,
                     LONG lNewRepeatCount,
                     bool bCueing);
    HRESULT SetSyncTimes(double dblNewSegmentTime,
                         LONG lNewRepeatCount,
                         double dblNewActiveTime,
                         double dblNewLocalTime,
                         double dblNextLocalTime,
                         bool bCueing);
    void ResetSyncTimes();

#if DBG
    virtual void Print(int spaces);
#endif

    // Timeline methods
    
    double CalcCurrLocalTime() const;
    double CalcCurrSimpleTime() const;
    double CalcElapsedLocalTime() const;

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double ApplySimpleTimeTransform(double time) const;

    // This will take the given time and transform it to the time it
    // would have been w/o an ease
    double ReverseSimpleTimeTransform(double time) const;

    double ApplyActiveTimeTransform(double time) const;
    double ReverseActiveTimeTransform(double time) const;

    //
    // These functions all clamp input and output values to ensure
    // that nothing invalid is returned.  If you need functionality
    // which checks the bounds do so before calling the function
    // 

    double CalcParentTimeFromActiveTime(double time) const;
    double CalcActiveTimeFromParentTime(double time) const;
    double CalcActiveTimeFromParentTimeForSyncArc(double time) const;
    double CalcActiveTimeFromParentTimeNoBounds(double dblParentTime) const;

    double CalcParentTimeFromGlobalTime(double time) const;
    double CalcParentTimeFromGlobalTimeForSyncArc(double time) const;
    double CalcGlobalTimeFromParentTime(double time) const;

    double ActiveTimeToLocalTime(double time) const;
    double LocalTimeToActiveTime(double time) const;

    double CalcActiveTimeFromSegmentTime(double segmentTime) const;
    double CalcSegmentTimeFromActiveTime(double activeTime, bool bTruncate) const;

    double SegmentTimeToSimpleTime(double segmentTime) const;
    double SimpleTimeToSegmentTime(double simpleTime) const;

    bool IsAutoReversing(double dblSegmentTime) const;

    void SetPropChange(DWORD pt);
    void ClearPropChange();
    DWORD GetPropChange() const;
    
  protected:
    // All dependents are added only when we are ready.
    // If the timenode is changed after we are considered ready then
    // it needs to detach and reattach itself.
    HRESULT AttachToSyncArc();
    void DetachFromSyncArc();
    
    double GetMaxEnd() const;
    
    void UpdateBeginTime(CEventList * l, double dblTime, bool bPropagate);
    void UpdateEndTime(CEventList * l, double dblTime, bool bPropagate);
    void UpdateEndSyncTime(double dblTime);
    void UpdateLastEndSyncTime(CEventList * l, double dblTime, bool bPropagate);

    void UpdateNextBoundaryTime(double dblTime);

    // Given the parent time these will calculate the correct bounds
    // from the sync arc lists
    void CalcBeginBound(double dblBaseTime,
                        bool bStrict,
                        double & dblBeginBound);
    void CalcEndBound(double dblParentTime,
                      bool bIncludeOneShots,
                      double & dblEndBound,
                      double & dblEndSyncBound);
    
    double CalcNaturalBeginBound(double dblParentTime,
                                 bool bInclusive,
                                 bool bStrict);

    void CalcBeginTime(double dblBaseTime,
                       double & dblBeginTime);
    void CalcEndTime(double dblBaseTime,
                     bool bIncludeOneShots,
                     double dblParentTime,
                     double dblElapsedSegmentTime,
                     long lElapsedRepeatCount,
                     double dblElapsedActiveTime,
                     double & dblEndTime,
                     double & dblEndSyncTime);

    double CalcLastEndSyncTime();
    
    void CalcNextBeginTime(double dblBaseTime,
                           bool bForceInclusive,
                           double & dblBeginTime);

    void ResetBeginTime(CEventList * l,
                        double dblParentTime,
                        bool bPropagate);
    void ResetEndTime(CEventList * l,
                      double dblParentTime,
                      bool bPropagate);
    void ResetBeginAndEndTimes(CEventList * l,
                               double dblParentTime,
                               bool bPropagate);
    void RecalcEndTime(CEventList * l,
                       double dblBaseTime,
                       double dblParentTime,
                       bool bPropagate);

    // This will conditionally recalc the end time since we should not
    // always allow it unless there is a full reset
    void RecalcCurrEndTime(CEventList * l, bool bPropagate);

    void RecalcSegmentDurChange(CEventList * l,
                                bool bRecalcTiming,
                                bool bForce = false);
    void RecalcBeginSyncArcChange(CEventList * l,
                                  double dblNewTime);
    void RecalcEndSyncArcChange(CEventList * l,
                                double dblNewTime);

    HRESULT SeekTo(LONG lNewRepeatCount,
                   double dblNewSegmentTime,
                   CEventList * l);

    double CalcNewActiveTime(double dblNewSegmentTime,
                             LONG lNewRepeatCount);

    // This needs to be used when calculating the repeat count and
    // segment time since the last repeat boundary should not get
    // rounded up and normal calculations do a mod which is wrong
    // For example, dur=3,r=2.
    //              ActiveTime=6 should result in:
    //              cursegtime=3, currep = 1
    
    void CalcActiveComponents(double dblActiveTime,
                              double & dblSegmentTime,
                              long & lRepeatCount);
    
    // This will update the timing attributes (accel, decel, speed,
    // dur, etc.).

    void CalcTimingAttr(CEventList * l);
    void CalcSimpleTimingAttr();
    void CalculateEaseCoeff();

    HRESULT Error();

    void UpdateNextTickBounds(CEventList * l,
                              double dblBeginTime,
                              double dblParentTime);
    
    bool TickInactivePeriod(CEventList * l,
                            double dblNewParentTime);

    bool TickInstance(CEventList * l,
                      double dblNewParentTime,
                      bool bNeedBegin);
    bool TickSingleInstance(CEventList * l,
                            double dblLastParentTime,
                            double dblNewParentTime,
                            double dblAdjustedParentTime,
                            bool bNeedBegin);
    
    bool TickActive(CEventList * l,
                    double dblNewActiveTime,
                    bool bNeedBegin,
                    bool bNeedEnd);

    bool TickActiveForward(CEventList * l,
                           double dblNewActiveTime,
                           bool bNeedBegin);
    bool TickSegmentForward(CEventList * l,
                            double dblActiveSegmentBound,
                            double dblLastSegmentTime,
                            double dblNewSegmentTime,
                            bool bNeedBegin);

    bool TickActiveBackward(CEventList * l,
                            double dblNewActiveTime,
                            bool bNeedBegin);
    bool TickSegmentBackward(CEventList * l,
                             double dblActiveSegmentBound,
                             double dblLastSegmentTime,
                             double dblNewSegmentTime,
                             bool bNeedBegin);

    virtual void TickChildren(CEventList * l,
                              double dblNewSegmentTime,
                              bool bNeedPlay);

    virtual bool TickEventPre(CEventList * l,
                              TE_EVENT_TYPE et,
                              DWORD dwFlags);
    
    virtual void TickEventChildren(CEventList * l,
                                   TE_EVENT_TYPE et,
                                   DWORD dwFlags);
    
    virtual bool TickEventPost(CEventList * l,
                               TE_EVENT_TYPE et,
                               DWORD dwFlags);
    
    // This will appropriately update due to a seek
    void HandleSeekUpdate(CEventList * l);

    // This will update the node due to a parent time shift
    void HandleTimeShift(CEventList * l);
    
    // This will recalc the runtime state based on the parent's simple time
    // Lag is the extra amount of time which has elapsed.
    void CalcRuntimeState(CEventList * l,
                          double dblParentSimpleTime,
                          double dblLocalLag);
    void CalcCurrRuntimeState(CEventList * l,
                              double dblLocalLag);
    void ResetRuntimeState(CEventList * l,
                           double dblParentSimpleTime);

    // ================================
    // DATA declarations
    // ================================

  protected:
    LPWSTR               m_pszID;
    double               m_dblDur;
    double               m_dblRepeatCount;
    double               m_dblRepeatDur;
    TE_FILL_FLAGS        m_tefFill;
    bool                 m_bAutoReverse;
    float                m_fltSpeed;
    float                m_fltAccel;
    float                m_fltDecel;
    DWORD                m_dwFlags;
    TE_RESTART_FLAGS     m_teRestart;
    double               m_dblNaturalDur;
    double               m_dblImplicitDur;
    
    DWORD                m_dwUpdateCycleFlags;
    
    CTIMEContainer *  m_ptnParent;
    CTIMENodeMgr *    m_ptnmNodeMgr;
    
    DWORD             m_dwInvalidateFlags;
    
    // *** These are the runtime attr - begin
    // These are in parent time space (post accel/decel)
    double            m_dblBeginParentTime;
    double            m_dblEndParentTime;
    double            m_dblEndSyncParentTime;
    double            m_dblLastEndSyncParentTime;

    // When active this is set left at its previous value
    // When not active this is the value to look for to see when we
    // are transitioning into the active period.  When going backwards
    // it is the next end, when going forward it is the next begin
    // If there is no next boundary then this is set to TIME_INFINITE
    double            m_dblNextBoundaryParentTime;

    double            m_dblCurrParentTime;

    LONG              m_lCurrRepeatCount;
    double            m_dblCurrSegmentTime;
    double            m_dblElapsedActiveRepeatTime;
    bool              m_bFirstTick;
    bool              m_bIsActive;
    bool              m_bDeferredActive;
    TEDirection       m_tedDirection;
    TEDirection       m_tedParentDirection;
    float             m_fltRate;
    float             m_fltParentRate;

    double            m_dblSyncSegmentTime;
    LONG              m_lSyncRepeatCount;
    double            m_dblSyncActiveTime;
    double            m_dblSyncParentTime;
    double            m_dblSyncNewParentTime;
    bool              m_bSyncCueing;
    // *** These are the runtime attr - end

    double            m_dblActiveDur;
    double            m_dblSimpleDur;
    double            m_dblSegmentDur;
    
    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    TimeSinkList      m_ptsBeginSinks;
    TimeSinkList      m_ptsEndSinks;

    CSyncArcList m_saBeginList;
    CSyncArcList m_saEndList;

    CNodeBvrList      m_nbList;
#if OLD_TIME_ENGINE
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_fltAccelEnd;
    float m_fltDecelStart;
    bool m_bNeedEase;
#endif

    bool m_bIsPaused;
    bool m_bIsParentPaused;

    bool m_bIsDisabled;
    bool m_bIsParentDisabled;

    DWORD m_dwPropChanges;

    bool  m_bInTick;
    bool  m_bNeedSegmentRecalc;
    bool  m_bEndedByParent;
};


class CEventData;

class CEventList
{
  public:
    CEventList();
    ~CEventList();

    HRESULT FireEvents();
    void Clear();
    HRESULT Add(CTIMENode * node,
                double time,
                TE_EVENT_TYPE et,
                long lRepeatCount);
    HRESULT AddPropChange(CTIMENode * node);
#if DBG
    void Print();
#endif
  protected:
    typedef std::list<CEventData *> CEventDataList;
    typedef std::set<CTIMENode *> CPropNodeSet;

    CEventDataList m_eventList;
    CPropNodeSet m_propSet;
};

CTIMENode * GetBvr(IUnknown *);

#if DBG
char * CreatePropString(DWORD dwFlags, char * pstr, DWORD dwSize);
#endif

// ==========================================
// Inlined functions
// ==========================================

#if DBG
inline char *
EventString(TE_EVENT_TYPE et)
{
    switch(et) {
      case TE_EVENT_BEGIN:
        return "Begin";
      case TE_EVENT_END:
        return "End";
      case TE_EVENT_PAUSE:
        return "Pause";
      case TE_EVENT_RESUME:
        return "Resume";
      case TE_EVENT_REPEAT:
        return "Repeat";
      case TE_EVENT_AUTOREVERSE:
        return "Autoreverse";
      case TE_EVENT_RESET:
        return "Reset";
      case TE_EVENT_SEEK:
        return "Seek";
      case TE_EVENT_PARENT_TIMESHIFT:
        return "ParentTimeShift";
      case TE_EVENT_ENABLE:
        return "Enable";
      case TE_EVENT_DISABLE:
        return "Disable";
      default:
        return "Unknown";
    }
}

inline char *
PropString(TE_PROPERTY_TYPE pt)
{
    switch(pt) {
      case TE_PROPERTY_TIME:
        return "Time";
      case TE_PROPERTY_REPEATCOUNT:
        return "RepeatCount";
      case TE_PROPERTY_SEGMENTDUR:
        return "SegmentDur";
      case TE_PROPERTY_IMPLICITDUR:
        return "ImplicitDur";
      case TE_PROPERTY_SIMPLEDUR:
        return "SimpleDur";
      case TE_PROPERTY_ACTIVEDUR:
        return "ActiveDur";
      case TE_PROPERTY_PROGRESS:
        return "Progress";
      case TE_PROPERTY_SPEED:
        return "Speed";
      case TE_PROPERTY_BEGINPARENTTIME:
        return "BeginParentTime";
      case TE_PROPERTY_ENDPARENTTIME:
        return "EndParentTime";
      case TE_PROPERTY_ISACTIVE:
        return "IsActive";
      case TE_PROPERTY_ISON:
        return "IsOn";
      case TE_PROPERTY_ISPAUSED:
        return "IsPaused";
      case TE_PROPERTY_ISCURRPAUSED:
        return "IsCurrPaused";
      case TE_PROPERTY_ISDISABLED:
        return "IsDisabled";
      case TE_PROPERTY_ISCURRDISABLED:
        return "IsCurrDisabled";
      case TE_PROPERTY_STATEFLAGS:
        return "StateFlags";
      default:
        return "Unknown";
    }
}
#endif

inline bool
CTIMENode::CalcIsPaused() const
{
    return (GetIsPaused() || GetIsParentPaused());
}

inline bool
CTIMENode::CalcIsDisabled() const
{
    return (GetIsDisabled() || GetIsParentDisabled());
}

inline bool
CTIMENode::IsSyncMaster() const
{
    return ((m_dwFlags & TE_FLAGS_MASTER) != 0);
}

inline bool
CTIMENode::IsLocked() const
{
    return ((m_dwFlags & TE_FLAGS_LOCKED) != 0);
}

inline bool
CTIMENode::IsCanSlip() const
{
    return !IsLocked();
}

inline bool
CTIMENode::IsEndSync() const
{
    return ((m_dwFlags & TE_FLAGS_ENDSYNC) != 0);
}

inline void
CTIMENode::SetParent(CTIMEContainer * parent)
{
    Assert(m_ptnParent == NULL);

    m_ptnParent = parent;
}

inline void
CTIMENode::ClearParent()
{
    // We better not have a node mgr if we are clearing the parent
    Assert(m_ptnmNodeMgr == NULL);
    m_ptnParent = NULL;
}

inline HRESULT
CTIMENode::AddBeginTimeSink(ITimeSink * sink)
{
    return m_ptsBeginSinks.Add(sink);
}

inline void
CTIMENode::RemoveBeginTimeSink(ITimeSink * sink)
{
    m_ptsBeginSinks.Remove(sink);
}

inline HRESULT
CTIMENode::AddEndTimeSink(ITimeSink* sink)
{
    return m_ptsEndSinks.Add(sink);
}

inline void
CTIMENode::RemoveEndTimeSink(ITimeSink* sink)
{
    m_ptsEndSinks.Remove(sink);
}

// This is inclusive of the end time
inline bool
CTIMENode::CheckActiveTime(double t, bool bRespectEndHold) const
{
    return (t != TIME_INFINITE &&
            t >= GetBeginParentTime() &&
            (bRespectEndHold || t < GetEndParentTime()));
}

inline double
CTIMENode::CalcElapsedLocalTime() const
{
    return ReverseActiveTimeTransform(CalcElapsedActiveTime());
}

inline HRESULT
CTIMENode::DispatchEvent(double time, TE_EVENT_TYPE et, long lRepeatCount)
{
    return m_nbList.DispatchEventNotify(time, et, lRepeatCount);
}

inline HRESULT
CTIMENode::DispatchGetSyncTime(double & dblNewTime,
                               LONG & lNewRepeatCount,
                               bool & bCueing)
{
    return m_nbList.DispatchGetSyncTime(dblNewTime,
                                        lNewRepeatCount,
                                        bCueing);
}

inline HRESULT
CTIMENode::DispatchPropChange(DWORD tePropType)
{
    return m_nbList.DispatchPropNotify(tePropType);
}

inline double
CTIMENode::CalcCurrSegmentDur() const
{
    double d;
    
    if (GetDur() != TE_UNDEFINED_VALUE)
    {
        d = GetSegmentDur();
    }
    else
    {
        d = CalcCurrSimpleDur();
    }

    return d;
}

inline double
CTIMENode::CalcEffectiveLocalDur() const
{
    return GetEndParentTime() - GetBeginParentTime();
}

inline double
CTIMENode::CalcLocalDur() const
{
    return ReverseActiveTimeTransform(GetActiveDur());
}

inline double
CTIMENode::CalcCurrLocalDur() const
{
    return ReverseActiveTimeTransform(CalcCurrActiveDur());
}

// This is simply the multiplication of our rate and our parent's
// rate
inline float
CTIMENode::GetCurrRate() const
{
    return (GetParentRate() * GetRate());
}

inline double
CTIMENode::CalcCurrLocalTime() const
{
    return GetCurrParentTime() - GetBeginParentTime();
}

inline double
CTIMENode::CalcElapsedActiveTime() const
{
    return GetElapsedActiveRepeatTime() + GetCurrSegmentTime();
}

inline void
CTIMENode::SetPropChange(DWORD pt)
{
    m_dwPropChanges |= pt;
}

inline DWORD
CTIMENode::GetPropChange() const
{
    return m_dwPropChanges;
}

inline void
CTIMENode::ClearPropChange()
{
    m_dwPropChanges = 0;
}

inline void
CTIMENode::ResetOneShots()
{
    m_saBeginList.Reset();
    m_saEndList.Reset();
}

inline void
CTIMENode::ResetSinks(CEventList * l)
{
    UpdateSinks(l, 0);
}

inline void
CTIMENode::UpdateNextBoundaryTime(double dblTime)
{
    m_dblNextBoundaryParentTime = dblTime;
}

inline void
CTIMENode::ResetBeginAndEndTimes(CEventList * l,
                                 double dblParentTime,
                                 bool bPropagate)
{
    ResetBeginTime(l, dblParentTime, bPropagate);
    ResetEndTime(l, dblParentTime, bPropagate);
}

inline double
CTIMENode::CalcRepeatCount() const
{
    double d;
    
    if (GetRepeatCount() != TE_UNDEFINED_VALUE)
    {
        d = GetRepeatCount();
    }
    else if (GetRepeatDur() != TE_UNDEFINED_VALUE)
    {
        d = TIME_INFINITE;
    }
    else
    {
        d = 1.0;
    }

    return d;
}

inline bool
CTIMENode::CalcIsActive() const
{
    return IsActive() && !IsDeferredActive();
}

inline double
CTIMENode::CalcActiveBeginPoint(TEDirection ted) const
{
    if (ted == TED_Forward)
    {
        return GetBeginParentTime();
    }
    else
    {
        return GetEndParentTime();
    }
}

inline double
CTIMENode::CalcActiveEndPoint(TEDirection ted) const
{
    if (ted == TED_Forward)
    {
        return GetEndParentTime();
    }
    else
    {
        return GetBeginParentTime();
    }
}

inline double
CTIMENode::CalcActiveBeginPoint() const
{
    return CalcActiveBeginPoint(GetParentDirection());
}

inline double
CTIMENode::CalcActiveEndPoint() const
{
    return CalcActiveEndPoint(GetParentDirection());
}

inline double
CTIMENode::GetMaxEnd() const
{
    return m_saEndList.LowerBound(TIME_INFINITE,
                                  true,
                                  false,
                                  false,
                                  false);
}

#endif /* _TIMENODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\node.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: node.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMENode, "TIME: Engine", "CTIMENode methods");

CTIMENode::CTIMENode()
: m_pszID(NULL),
  m_dblDur(TE_UNDEFINED_VALUE),
  m_dblRepeatCount(TE_UNDEFINED_VALUE),
  m_dblRepeatDur(TE_UNDEFINED_VALUE),
  m_tefFill(TE_FILL_REMOVE),
  m_bAutoReverse(false),
  m_fltSpeed(1),
  m_fltAccel(0),
  m_fltDecel(0),
  m_dwFlags(0),
  m_teRestart(TE_RESTART_ALWAYS),
  m_dblNaturalDur(TE_UNDEFINED_VALUE),
  m_dblImplicitDur(TE_UNDEFINED_VALUE),

  // Runtime attributes
  // Indicate everything is invalid
  m_dwInvalidateFlags(0xffffffff),
  
  m_dblBeginParentTime(TIME_INFINITE),
  m_dblEndParentTime(TIME_INFINITE),
  m_dblEndSyncParentTime(TIME_INFINITE),
  m_dblLastEndSyncParentTime(TIME_INFINITE),

  m_dblNextBoundaryParentTime(TIME_INFINITE),

  m_dblActiveDur(TIME_INFINITE),
  m_dblCurrParentTime(-TIME_INFINITE),

  m_lCurrRepeatCount(0),
  m_dblElapsedActiveRepeatTime(0.0),
  m_dblCurrSegmentTime(0.0),

  m_dblSyncSegmentTime(TIME_INFINITE),
  m_lSyncRepeatCount(TE_UNDEFINED_VALUE),
  m_dblSyncActiveTime(TIME_INFINITE),
  m_dblSyncParentTime(TIME_INFINITE),
  m_dblSyncNewParentTime(TIME_INFINITE),

  m_dblSimpleDur(0.0),
  m_dblSegmentDur(0.0),
  m_bFirstTick(true),
  m_bIsActive(false),
  m_bDeferredActive(false),
  m_fltRate(1.0f),
  m_fltParentRate(1.0f),
  m_tedDirection(TED_Forward),
  m_tedParentDirection(TED_Forward),
  m_bSyncCueing(false),
  
  // Time base management
  m_saBeginList(*this, true),
  m_saEndList(*this, false),

#if OLD_TIME_ENGINE
  m_flA0(0),
  m_flA1(0),
  m_flA2(0),
  m_flB0(0),
  m_flB1(0),
  m_flC0(0),
  m_flC1(0),
  m_flC2(0),
  m_bNeedEase(false),
  m_fltAccelEnd(0),
  m_fltDecelStart(0),
#endif
  
  m_bIsPaused(false),
  m_bIsParentPaused(false),
    
  m_bIsDisabled(false),
  m_bIsParentDisabled(false),
    
  m_dwPropChanges(0),
  
  m_bInTick(false),
  m_bNeedSegmentRecalc(false),
  m_bEndedByParent(false),

  m_dwUpdateCycleFlags(0),
  
  // Internal state management
  m_ptnParent(NULL),
  m_ptnmNodeMgr(NULL)

#ifdef NEW_TIMING_ENGINE
  m_startOnEventTime(-MM_INFINITE),
#endif // NEW_TIMING_ENGINE

{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CTIMENode()",
              this));
}

CTIMENode::~CTIMENode()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::~CTIMENode()",
              this));

    delete m_pszID;

    Assert(m_ptnParent == NULL);
    m_ptnParent = NULL;

    Assert(m_ptnmNodeMgr == NULL);
    m_ptnmNodeMgr = NULL;
}

HRESULT
CTIMENode::Init(LPOLESTR id)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::Init(%ls)",
              this,
              id));

    HRESULT hr;
    
    // Calculate all the internal timing state
    CalcTimingAttr(NULL);
    
    if (id)
    {
        m_pszID = CopyString(id);
        
        if (m_pszID == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
  
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENode::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    TraceTag((tagError,
              "CTIMENode(%p)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
    {
        hr = CComCoClass<CTIMENode, &__uuidof(CTIMENode)>::Error(str, IID_ITIMENode, hr);
        delete [] str;
    }

    RRETURN(hr);
}

void
CTIMENode::CalcTimingAttr(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcTimingAttr(%#x)",
              this,
              l));
    
    // Determine the simple duration
    if (TE_UNDEFINED_VALUE == m_dblDur)
    {
        m_dblSimpleDur = TIME_INFINITE;
    }
    else
    {
        m_dblSimpleDur = m_dblDur;
    }
    
    // Calculate the time for each iteration of the repeat
    m_dblSegmentDur = m_dblSimpleDur;

    // If we are autoreversing then double the time period for a
    // single repeat
    if (m_bAutoReverse)
    {
        m_dblSegmentDur *= 2;
    }
        
    // Now multiply by the number of repeats we need
    double dblCalcRepDur;
    dblCalcRepDur = m_dblSegmentDur * CalcRepeatCount();
    
    // Now take the least of the calculated duration and the repeatDur
    // property
    if (m_dblRepeatDur == TE_UNDEFINED_VALUE)
    {
        m_dblActiveDur = dblCalcRepDur;
    }
    else
    {
        m_dblActiveDur = min(m_dblRepeatDur, dblCalcRepDur);
    }

    Assert(m_fltSpeed != 0.0f);
    
    m_fltRate = fabs(m_fltSpeed);

    CalcSimpleTimingAttr();

    PropNotify(l,
               (TE_PROPERTY_SEGMENTDUR |
                TE_PROPERTY_SIMPLEDUR |
                TE_PROPERTY_ACTIVEDUR |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_SPEED));
}

void
CTIMENode::CalcSimpleTimingAttr()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcSimpleTimingAttr()",
              this));

    CalculateEaseCoeff();

    Assert(m_fltSpeed != 0.0f);
    m_tedDirection = (m_fltSpeed >= 0.0f)?TED_Forward:TED_Backward;
}

void
CTIMENode::Invalidate(DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::Invalidate(%x)",
              this,
              dwFlags));

    if (IsReady())
    {
        m_dwInvalidateFlags |= dwFlags;
    }
}

//
// NodeMgr code
//

// The key is to ensure everything is connected when a node mgr is
// available.  This is how the IsReady flag is set and causes all
// timebase propagation to occur

HRESULT
CTIMENode::SetMgr(CTIMENodeMgr * mgr)
{
    // Make sure there was not a nodemgr set already
    Assert(m_ptnmNodeMgr == NULL);

    // Either we have a parent set or the node manager is managing us
    Assert(m_ptnParent != NULL ||
           mgr->GetTIMENode() == this);
    
    HRESULT hr;
    
    if (mgr == NULL)
    {
        AssertSz(false, "The node manager was set to NULL");
        hr = E_INVALIDARG;
        goto done;
    }

    // Set the node manager - this makes us ready
    m_ptnmNodeMgr = mgr;
    
    // Now we need to attach to the timebases before we update our
    // internal state variables
    
    // Attach to the time bases
    hr = THR(AttachToSyncArc());
    if (FAILED(hr))
    {
        goto done;
    }
    
    {
        CEventList l;

        // Now update ourselves completely so we get the correct initial
        // state

        ResetNode(&l, true);

        IGNORE_HR(l.FireEvents());
    }

#if OLD_TIME_ENGINE
    // if we need to registered a Timer Event, add it to the player.
    if (IsSyncMaster())
    {
        m_ptnmNodeMgr->AddBvrCB(this);
    }
#endif

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        ClearMgr();
    }
    
    RRETURN(hr);
}

void
CTIMENode::ClearMgr()
{
#if OLD_TIME_ENGINE
    // if we registered a Timer Event, remove it from the player.
    // Make sure we check for the player since we may not have
    // actually set it yet.
    if (IsSyncMaster() && m_ptnmNodeMgr)
    {
        m_ptnmNodeMgr->RemoveBvrCB(this);
    }
#endif

    DetachFromSyncArc();
    
    m_ptnmNodeMgr = NULL;
}

void
CTIMENode::ResetNode(CEventList * l,
                     bool bPropagate,
                     bool bResetOneShot)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::ResetNode(%p, %d, %d)",
              this,
              l,
              bPropagate,
              bResetOneShot));

    double dblParentTime;
    bool bPrevActive = (IsActive() && !IsFirstTick());
    bool bPrevPaused = CalcIsPaused();
    bool bPrevDisabled = CalcIsDisabled();
    
    double dblActiveTime = CalcElapsedActiveTime();
    
    // Reset state variables
    
    if (bResetOneShot)
    {
        ResetOneShots();
    }

    m_bIsActive = false;
    m_bDeferredActive = false;
    m_bEndedByParent = false;
    m_bIsPaused = false;
    m_bFirstTick = true;
    m_dblImplicitDur = TE_UNDEFINED_VALUE;
    ResetSyncTimes();

    {
        const CNodeContainer * pcnc = GetContainerPtr();
        
        if (pcnc)
        {
            m_bIsParentPaused = pcnc->ContainerIsPaused();
            m_bIsParentDisabled = pcnc->ContainerIsDisabled();
            m_fltParentRate = pcnc->ContainerGetRate();
            m_tedParentDirection = pcnc->ContainerGetDirection();
            dblParentTime = pcnc->ContainerGetSimpleTime();
        }
        else
        {
            m_bIsParentPaused = false;
            m_bIsParentDisabled = false;
            m_fltParentRate = 1.0f;
            m_tedParentDirection = TED_Forward;
            dblParentTime = 0.0;
        }
    }
    
    // Update this here since so many places use it
    m_dblCurrParentTime = dblParentTime;

    // Calculate all the internal timing state
    CalcTimingAttr(l);
    
    // Don't propagate since the ResetSink will do that.

    ResetBeginAndEndTimes(l, dblParentTime, false);

    CalcRuntimeState(l, dblParentTime, 0.0);

    m_dwInvalidateFlags = 0;

    if (bPropagate)
    {
        ResetSinks(l);
    }

    // Do this here so state is correct
    
    // Always fire the reset to ensure all peers clear their state
    EventNotify(l, 0.0, TE_EVENT_RESET);

    PropNotify(l,
               (TE_PROPERTY_IMPLICITDUR |
                TE_PROPERTY_ISPAUSED |
                TE_PROPERTY_ISCURRPAUSED |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));
    
    // Do not fire the begin since we may need to cue but we do not
    // find that out until tick time
    
    // This should happen only when we are newly added to an already
    // paused container
    if (!bPrevPaused && CalcIsPaused())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_PAUSE);
    }
    
    if (!bPrevDisabled && CalcIsDisabled())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_DISABLE);
    }
    
    // Now go through our children
    ResetChildren(l, true);
    
    if (bPrevPaused && !CalcIsPaused())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_RESUME);
    }
    
    if (bPrevDisabled && !CalcIsDisabled())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_ENABLE);
    }
    
    if (bPrevActive != IsActive())
    {
        if (!IsActive())
        {
            EventNotify(l, dblActiveTime, TE_EVENT_END);
        }
    }
    else
    {
        m_bFirstTick = false;
    }
    
  done:
    return;
}
    
void
CTIMENode::ResetChildren(CEventList * l, bool bPropagate)
{
}

void
CTIMENode::UpdateNode(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::UpdateNode(%p)",
              this,
              l));

    bool bNeedEndCalc = false;
    bool bNeedBeginCalc = false;
    bool bNeedRuntimeCalc = false;
    bool bNeedTimingCalc = false;
//    double dblSegmentTime = GetCurrSegmentTime();
//    long lRepeatCount = GetCurrRepeatCount();
    double dblLocalSlip = 0.0;
    
    Assert(IsReady());
    
    if (m_dwInvalidateFlags == 0)
    {
        goto done;
    }
    
    if (GetContainer().ContainerIsActive())
    {
        EventNotify(l, 0.0, TE_EVENT_UPDATE);
    }
    
    // Reset state variables
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_BEGIN))
    {
        bNeedEndCalc = true;
        bNeedBeginCalc = true;
        bNeedRuntimeCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_END))
    {
        bNeedEndCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_SIMPLETIME))
    {
        bNeedTimingCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_DUR))
    {
        bNeedTimingCalc = true;
        bNeedRuntimeCalc = true;
        bNeedEndCalc = true;
    }

    // Clear the flags now
    
    m_dwInvalidateFlags = 0;

    if (bNeedRuntimeCalc)
    {
        dblLocalSlip = (CalcCurrLocalTime() -
                        CalcElapsedLocalTime());
    }

    if (bNeedTimingCalc)
    {
        const CNodeContainer * pcnc = GetContainerPtr();
        
        if (pcnc)
        {
            m_fltParentRate = pcnc->ContainerGetRate();
            m_tedParentDirection = pcnc->ContainerGetDirection();
        }
        else
        {
            m_fltParentRate = 1.0f;
            m_tedParentDirection = TED_Forward;
        }
    
        // Calculate all the internal timing state
        CalcTimingAttr(l);
    }
    
    if (bNeedBeginCalc)
    {
        ResetSyncTimes();
        m_bFirstTick = true;

        ResetBeginTime(l, m_dblCurrParentTime, true);
    }

    if (bNeedRuntimeCalc)
    {
        if (bNeedEndCalc)
        {
            ResetEndTime(l, m_dblCurrParentTime, true);
        }

        CalcCurrRuntimeState(l, dblLocalSlip);
    }
    else
    {
        if (bNeedEndCalc)
        {
            RecalcCurrEndTime(l, true);
        }
    }
    
    PropNotify(l,
               (TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));

    // Now go through and reset children
    ResetChildren(l, true);
    
  done:
    return;
}

HRESULT
CTIMENode::EnsureUpdate()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::EnsureUpdate()",
              this));

    HRESULT hr;
    CEventList l;
    
    UpdateNode(&l);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENode::CalcCurrRuntimeState(CEventList *l,
                                double dblLocalLag)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcCurrRuntimeState(%p, %g)",
              this,
              l,
              dblLocalLag));
    
    const CNodeContainer * pcnc = GetContainerPtr();
        
    if (pcnc)
    {
        double dblParentTime = 0.0;

        if (GetSyncParentTime() != TIME_INFINITE)
        {
            dblParentTime = GetSyncParentTime();
        }
        else
        {
            dblParentTime = pcnc->ContainerGetSimpleTime();
        }

        CalcRuntimeState(l, dblParentTime, dblLocalLag);
    }
    else
    {
        ResetRuntimeState(l, -TIME_INFINITE);
    }
}

void
CTIMENode::CalcRuntimeState(CEventList *l,
                            double dblParentSimpleTime,
                            double dblLocalLag)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcRuntimeState(%p, %g, %g)",
              this,
              l,
              dblParentSimpleTime,
              dblLocalLag));
    
    if (dblLocalLag == -TIME_INFINITE)
    {
        dblLocalLag = 0;
    }

    if (!IsReady())
    {
        ResetRuntimeState(l,
                          dblParentSimpleTime);
        goto done;
    }
    
    m_dblCurrParentTime = dblParentSimpleTime;

    if (!GetContainer().ContainerIsActive() ||
        dblParentSimpleTime < GetBeginParentTime() ||
        dblParentSimpleTime > GetEndParentTime() ||
        (!m_bFirstTick && dblParentSimpleTime == GetEndParentTime()))
    {
        m_bIsActive = false;
    }
    else
    {
        // this means we are currently active - set the active
        // flag
        m_bIsActive = true;
    }
        
    // See if we were active but clipped by our parent
    if (!IsActive() &&
        dblParentSimpleTime >= GetBeginParentTime() &&
        dblParentSimpleTime < GetEndParentTime())
    {
        m_bEndedByParent = true;
    }
    else
    {
        m_bEndedByParent = false;
    }

    double dblElapsedActiveTime;
            
    if (GetSyncParentTime() != TIME_INFINITE)
    {
        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);

        m_dblCurrSegmentTime = GetSyncSegmentTime();
        m_lCurrRepeatCount = GetSyncRepeatCount();
        dblElapsedActiveTime = GetSyncActiveTime();
    }
    else
    {
        //
        // We now need to calculate the elapsed active time
        // First get the elapsed local time and then convert it
        // If there is not known active dur then we need to do
        // something reasonable when reversing
        //
        
        // First get the local time
        dblElapsedActiveTime = dblParentSimpleTime - GetBeginParentTime();
            
        // Next remove the lag
        dblElapsedActiveTime -= dblLocalLag;
            
        // Now convert to active time
        // No need to clamp the values since the conversion function does
        // this itself.
        dblElapsedActiveTime = LocalTimeToActiveTime(dblElapsedActiveTime);
            
        CalcActiveComponents(dblElapsedActiveTime,
                             m_dblCurrSegmentTime,
                             m_lCurrRepeatCount);
    }
        
    m_dblElapsedActiveRepeatTime = dblElapsedActiveTime - m_dblCurrSegmentTime;

    Assert(GetCurrRepeatCount() <= CalcRepeatCount());
    Assert(CalcElapsedActiveTime() <= CalcEffectiveActiveDur());

    PropNotify(l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));

  done:
    return;
}


void
CTIMENode::ResetRuntimeState(CEventList *l,
                             double dblParentSimpleTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::ResetRuntimeState(%p, %g)",
              this,
              l,
              dblParentSimpleTime));
    
    double dblSegmentDur = CalcCurrSegmentDur();
    
    m_bIsActive = false;
    m_bEndedByParent = false;
    m_dblCurrParentTime = dblParentSimpleTime;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        m_dblCurrParentTime = GetSyncParentTime();

        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);

        m_dblCurrSegmentTime = GetSyncSegmentTime();
        m_lCurrRepeatCount = GetSyncRepeatCount();
        m_dblElapsedActiveRepeatTime = GetSyncActiveTime() - m_dblCurrSegmentTime;
    }
    else if (CalcActiveDirection() == TED_Forward ||
             dblSegmentDur == TIME_INFINITE)
    {
        m_dblCurrSegmentTime = 0.0;
        m_lCurrRepeatCount = 0;
        m_dblElapsedActiveRepeatTime = 0.0;
    }
    else
    {
        m_dblElapsedActiveRepeatTime = CalcCurrActiveDur();
        CalcActiveComponents(m_dblElapsedActiveRepeatTime,
                             m_dblCurrSegmentTime,
                             m_lCurrRepeatCount);
    }

    PropNotify(l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));
}

void
CTIMENode::RecalcSegmentDurChange(CEventList * l,
                                  bool bRecalcTiming,
                                  bool bForce)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p, %ls)::RecalcSegmentDurChange(%p, %d, %d)",
              this,
              GetID(),
              l,
              bRecalcTiming,
              bForce));

    bool bPrevActive = IsActive();
    double dblLocalSlip;

    if (IsInTick() && !bForce)
    {
        // We do not expect to get called to force timing recalc when
        // we are in tick.  If this fires then we need to cache this
        // flag as well
        Assert(!bRecalcTiming);
        m_bNeedSegmentRecalc = true;
        goto done;
    }
    
    // Clear the segment recalc flag
    m_bNeedSegmentRecalc = false;

    // First calculate the local slip
    dblLocalSlip = (CalcCurrLocalTime() - CalcElapsedLocalTime());

    // Now clamp the segment duration
    {
        double dblSegmentDur = CalcCurrSegmentDur();
        if (m_dblCurrSegmentTime > dblSegmentDur)
        {
            m_dblCurrSegmentTime = dblSegmentDur;
        }
    }

    if (!IsReady())
    {
        RecalcCurrEndTime(l, true);
        goto done;
    }
    
    TEDirection dir;
    dir = CalcActiveDirection();

    if (((dir == TED_Forward) &&
         (GetCurrParentTime() >= GetEndParentTime())) ||
        
        ((dir == TED_Backward) &&
         (GetCurrParentTime() <= GetEndParentTime())))
    {
        goto done;
    }
    
    if (dir == TED_Backward || bRecalcTiming)
    {
        long lPrevRepeatCount = GetCurrRepeatCount();
        
        ResetEndTime(l, GetCurrParentTime(), true);

        CalcCurrRuntimeState(l, dblLocalSlip);


        if (GetCurrRepeatCount() != lPrevRepeatCount)
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_REPEAT, GetCurrRepeatCount());
        }
                
        EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_RESET);

        // Do not propagate the change otherwise this gets recursive
        ResetChildren(l, false);
    }
    else
    {
        RecalcCurrEndTime(l, true);
    }

    if (bPrevActive != IsActive())
    {
        if (IsActive())
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
            TickEvent(l, TE_EVENT_BEGIN, 0);
        }
        else
        {
            TickEvent(l, TE_EVENT_END, 0);
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_END);
        }
    }
    
  done:
    return;
}

void
CTIMENode::RecalcBeginSyncArcChange(CEventList * l,
                                    double dblNewTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::RecalcBeginSyncArcChange(%p, %g)",
              this,
              l,
              dblNewTime));

    Assert(IsReady());
    
    TEDirection dir = CalcActiveDirection();
    
    if (m_dwUpdateCycleFlags != 0)
    {
        goto done;
    }
    
    if (IsActive() ||
        (GetCurrParentTime() >= GetBeginParentTime() &&
         GetCurrParentTime() < GetEndParentTime()))
    {
        // If we are not a restart then we cannot affect the begin or end
        if (GetRestart() != TE_RESTART_ALWAYS)
        {
            goto done;
        }

        if (dir == TED_Forward)
        {
            if (dblNewTime > GetBeginParentTime() &&
                dblNewTime < GetCurrParentTime())
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(dblNewTime);
            }
            else
            {
                RecalcCurrEndTime(l, true);

                if (GetCurrParentTime() >= GetEndParentTime())
                {
                    TickEvent(l, TE_EVENT_END, 0);

                    double dblBegin;
                    CalcNextBeginTime(GetCurrParentTime(),
                                      false,
                                      dblBegin);
            
                    // Indicate that the next tick bounds is the end time
                    UpdateNextBoundaryTime(dblBegin);

                    if (dblBegin == GetCurrParentTime())
                    {
                        // Update the tick bounds passing the new begin time and the
                        // current parent time
                        UpdateNextTickBounds(l,
                                             dblBegin,
                                             GetCurrParentTime());
                    }
                }
            }
        }
        else
        {
            if (dblNewTime <= GetCurrParentTime() &&
                dblNewTime > GetBeginParentTime())
            {
                double dblBegin;
                CalcNextBeginTime(GetCurrParentTime(),
                                  false,
                                  dblBegin);
    
                if (dblBegin != GetBeginParentTime())
                {
                    // Update the tick bounds passing the new begin time and the
                    // current parent time
                    UpdateNextTickBounds(l,
                                         dblBegin,
                                         GetCurrParentTime());

                    // Indicate that the next tick bounds is the end time
                    UpdateNextBoundaryTime(GetEndParentTime());
                }
            }
        }
    }
    else if (GetCurrParentTime() < GetBeginParentTime())
    {
        Assert(!IsActive());
        
        // If we are going forward we should update the times
        // If we are going backwards then only update if the new
        // time is less than the current time
        if (dir == TED_Forward)
        {
            // Use -TIME_INFINITE since the new begin time is in the future which
            // means we have never begin before
            double dblBegin;
            CalcNextBeginTime(-TIME_INFINITE,
                              false,
                              dblBegin);
    
            UpdateNextTickBounds(l,
                                 dblBegin,
                                 GetCurrParentTime());
            UpdateNextBoundaryTime(dblBegin);
        }
        else
        {
            if (dblNewTime <= GetCurrParentTime())
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(GetEndParentTime());
            }
        }
    }
    else
    {
        Assert(!IsActive());
        Assert(GetCurrParentTime() >= GetBeginParentTime());

        if (dir == TED_Forward)
        {
            if (GetRestart() == TE_RESTART_NEVER)
            {
                goto done;
            }
            
            if (dblNewTime <= GetCurrParentTime() &&
                dblNewTime > GetBeginParentTime() &&
                (GetRestart() == TE_RESTART_ALWAYS ||
                 dblNewTime >= GetEndParentTime()))
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(dblNewTime);
            }
            else
            {
                double dblBegin;
                CalcNextBeginTime(GetCurrParentTime(),
                                  false,
                                  dblBegin);

                UpdateNextBoundaryTime(dblBegin);
                
                if (dblBegin == GetCurrParentTime())
                {
                    UpdateNextTickBounds(l,
                                         dblBegin,
                                         GetCurrParentTime());
                }
            }
        }
        else
        {
            // dir == TED_Backward

            double dblBegin;
            CalcNextBeginTime(GetCurrParentTime(),
                              false,
                              dblBegin);
    
            // Update the tick bounds passing the new begin time and the
            // current parent time
            UpdateNextTickBounds(l,
                                 dblBegin,
                                 GetCurrParentTime());

            // Indicate that the next tick bounds is the end time
            UpdateNextBoundaryTime(GetEndParentTime());
        }
    }

  done:
    return;
}

void
CTIMENode::RecalcEndSyncArcChange(CEventList * l,
                                  double dblNewTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::RecalcEndSyncArcChange(%p, %g)",
              this,
              l,
              dblNewTime));

    Assert(IsReady());
    
    TEDirection dir = CalcActiveDirection();
    
    if (m_dwUpdateCycleFlags != 0)
    {
        goto done;
    }
    
    if (dir == TED_Forward)
    {
        // Do not recalc if we passed the end point yet
        if (GetCurrParentTime() >= GetEndParentTime())
        {
            goto done;
        }

        RecalcCurrEndTime(l, true);

        if (IsActive() &&
            GetCurrParentTime() >= GetEndParentTime())
        {
            TickEvent(l, TE_EVENT_END, 0);

            double dblBegin;
            CalcNextBeginTime(GetCurrParentTime(),
                              false,
                              dblBegin);
            
            // Indicate that the next tick bounds is the end time
            UpdateNextBoundaryTime(dblBegin);

            if (dblBegin == GetCurrParentTime())
            {
                // Update the tick bounds passing the new begin time and the
                // current parent time
                UpdateNextTickBounds(l,
                                     dblBegin,
                                     GetCurrParentTime());
            }
        }
    }
    else
    {
        if (GetCurrParentTime() <= GetEndParentTime())
        {
            goto done;
        }
        
        double dblBegin;
        CalcNextBeginTime(GetCurrParentTime(),
                          false,
                          dblBegin);
    
        // Update the tick bounds passing the new begin time and the
        // current parent time
        UpdateNextTickBounds(l,
                             dblBegin,
                             GetCurrParentTime());
        
        // Indicate that the next tick bounds is the end time
        UpdateNextBoundaryTime(GetEndParentTime());
    }

  done:
    return;
}

void
CTIMENode::HandleTimeShift(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::HandleTimeShift(%p)",
              this,
              l));

    // First update ourselves from the time shift
    m_saBeginList.UpdateFromLongSyncArcs(l);
    m_saEndList.UpdateFromLongSyncArcs(l);
    
    // Now notify our syncs that our time has shifted
    UpdateSinks(l, TS_TIMESHIFT);
}

double
CTIMENode::CalcCurrSimpleTime() const
{
    double ret = GetCurrSegmentTime();

    Assert(ret != TIME_INFINITE && ret != -TIME_INFINITE);
    
    ret = SegmentTimeToSimpleTime(ret);

    return ret;
}

double
CTIMENode::CalcCurrSimpleDur() const
{
    double d;
    
    if (GetDur() != TE_UNDEFINED_VALUE)
    {
        d = GetSimpleDur();
    }
    else
    {
        double dblImpl = GetImplicitDur();
        double dblNat = GetNaturalDur();

        if (dblImpl == TE_UNDEFINED_VALUE)
        {
            if (dblNat == TE_UNDEFINED_VALUE)
            {
                d = TIME_INFINITE;
            }
            else
            {
                d = dblNat;
            }
        }
        else if (dblNat == TE_UNDEFINED_VALUE)
        {
            Assert(dblImpl != TE_UNDEFINED_VALUE);
            d = dblImpl;
        }
        else if (dblNat == 0)
        {
            d = dblImpl;
        }
        else
        {
            d = max(dblNat, dblImpl);
        }
    }

    return d;
}

double
CTIMENode::CalcCurrActiveDur() const
{
    double ret = CalcCurrSegmentDur() * CalcRepeatCount();
    
    ret = Clamp(0.0,
                ret,
                GetActiveDur());
    
    return ret;
}

double
CTIMENode::CalcEffectiveActiveDur() const
{
    double dblRet;
    double dblSegmentDur = CalcCurrSegmentDur();

    // Figure out how much repeat time is left and then sutract
    // the last current time
    // This is the amount of time remaining from the last tick
    // time is parent time

    // If the segment time is infinite then this will ultimately end
    // up either getting clamp by the active dur below or just ignored
    // later begin the sync arcs ended early.  If the repeat count is
    // expired this will still return infinity since we never reach
    // the repeat count but expect the segment time to be equal to the
    // segment dur.  Again, if the segment dur is infinite then this
    // will cause everything to be ignored.
    dblRet = (CalcRepeatCount() - GetCurrRepeatCount()) * dblSegmentDur;
            
    // Now add the elapsed repeat time
    dblRet += GetElapsedActiveRepeatTime();
        
    // Clamp it
    dblRet = Clamp(0.0,
                   dblRet,
                   GetActiveDur());

    return dblRet;
}

//
// This needs to be very efficient since we call it a lot and we do
// not want to cache it
//

TEDirection
CTIMENode::CalcActiveDirection() const
{
    TEDirection tedRet;

    // Take our parent direction
    tedRet = GetParentDirection();
    
    // See if we are currently suppose to be reversing and invert our
    // direction
    if (TEIsBackward(GetDirection()))
    {
        tedRet = TEReverse(tedRet);
    }

    return tedRet;
}

bool
CTIMENode::IsAutoReversing(double dblSegmentTime) const
{
    return (GetAutoReverse() &&
            (dblSegmentTime > GetSimpleDur() ||
             (dblSegmentTime == GetSimpleDur() && TEIsForward(CalcActiveDirection()))));
}

TEDirection
CTIMENode::CalcSimpleDirection() const
{
    TEDirection tedRet;

    // Take our initial direction
    tedRet = CalcActiveDirection();
    
    // See if we are currently suppose to be reversing and invert our
    // direction
    if (IsAutoReversing(GetCurrSegmentTime()))
    {
        // Since this is really a bool this will work
        tedRet = TEReverse(tedRet);
    }

    return tedRet;
}

// This is inclusive of the end time
bool
CTIMENode::CalcIsOn() const
{
    bool ok = false;
    
    if (!IsReady())
    {
        goto done;
    }
    
    if (CalcIsActive())
    {
        ok = true;
        goto done;
    }

    if (!GetContainer().ContainerIsOn())
    {
        goto done;
    }
    
    if (IsEndedByParent())
    {
        ok = true;
        goto done;
    }

    if (GetFill() == TE_FILL_FREEZE &&
        GetCurrParentTime() >= GetBeginParentTime())
    {
        ok = true;
        goto done;
    }
    
  done:
    return ok;
}

CNodeContainer &
CTIMENode::GetContainer() const
{
    if (GetParent() != NULL)
    {
        return *(GetParent());
    }
    else
    {
        Assert(GetMgr() != NULL);
        
        return *(GetMgr());
    }
}

const CNodeContainer *
CTIMENode::GetContainerPtr() const
{
    if (GetParent() != NULL)
    {
        return GetParent();
    }
    else if (GetMgr() != NULL)
    {
        return GetMgr();
    }
    else
    {
        return NULL;
    }
}

#if DBG
void
CTIMENode::Print(int spaces)
{
    TraceTag((tagPrintTimeTree,
              "%*s[(%p,%ls): "
              "simpledur = %g, segmentdur = %g, "
              "calcsegmentdur = %g, actDur = %g, "
              "repcnt = %g, repdur = %g, "
              "autoreverse = %d]",
              spaces,
              "",
              this,
              m_pszID,
              m_dblSimpleDur,
              m_dblSegmentDur,
              CalcCurrSegmentDur(),
              m_dblActiveDur,
              m_dblRepeatCount,
              m_dblRepeatDur,
              m_bAutoReverse));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\nodebvr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodebvr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _NODEBVR_H
#define _NODEBVR_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CNodeBvrList
{
  public:
    CNodeBvrList();
    ~CNodeBvrList();

    HRESULT Add(ITIMENodeBehavior * bvr);
    HRESULT Remove(ITIMENodeBehavior * bvr);
    
    HRESULT DispatchTick();

    HRESULT DispatchEventNotify(double eventTime,
                                TE_EVENT_TYPE eventType, 
                                long lRepeatCount = 0);
    HRESULT DispatchGetSyncTime(double & dblNewTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing);
    HRESULT DispatchPropNotify(DWORD tePropType);
  protected:
    typedef std::list<ITIMENodeBehavior *> TIMENodeBvrList;

    TIMENodeBvrList m_tnbList;
};

#endif /* _NODEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\nodemgr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "NodeMgr.h"
#include "Node.h"

DeclareTag(tagMMPlayer, "TIME: Engine", "CTIMENodeMgr methods")
DeclareTag(tagMMDetailNotify, "TIME: Engine", "Detailed notify")
DeclareTag(tagPrintTimeTree, "TIME: Engine", "Print TIME Tree")

CTIMENodeMgr::CTIMENodeMgr()
: m_id(NULL),
  m_bIsActive(false),
  m_bIsPaused(false),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_mmbvr(NULL),
  m_curGlobalTime(0.0),
  m_lastTickTime(0.0),
  m_globalStartTime(0.0)
{
}

CTIMENodeMgr::~CTIMENodeMgr()
{
    Deinit();
} //lint !e1740

HRESULT
CTIMENodeMgr::Init(LPOLESTR id,
                   ITIMENode * bvr,
                   IServiceProvider * sp)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Init(%ls, %#lx, %#lx)",
              this,
              id,
              bvr,
              sp));
    
    HRESULT hr;
    
    Deinit();
    
    if (!bvr || !sp)
    {
        TraceTag((tagError,
                  "CTIMENodeMgr(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    m_sp = sp;
    
    CTIMENode * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CTIMENodeMgr(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetParent(NULL);

    hr = m_mmbvr->SetMgr(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Clean up now
        Deinit();
    }
    
    RRETURN(hr);
}

void
CTIMENodeMgr::Deinit()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Deinit()",
              this));

    // Ensure the player will not try to call us since we are going away

    if (m_mmbvr)
    {
        m_mmbvr->ClearMgr();
        m_mmbvr.Release();
    }

    m_sp.Release();
    
    delete m_id;
    m_id = NULL;

#if OLD_TIME_ENGINE
    BvrCBList::iterator j;
    for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
    {
        (*j)->Release();
    }
#endif
}

STDMETHODIMP
CTIMENodeMgr::get_id(LPOLESTR * p)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::get_id()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::put_id(LPOLESTR s)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::put_id(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
        
STDMETHODIMP
CTIMENodeMgr::get_node(ITIMENode ** pptn)
{
    CHECK_RETURN_SET_NULL(pptn);

    return m_mmbvr->QueryInterface(IID_ITIMENode,
                                   (void **) pptn);
}

STDMETHODIMP
CTIMENodeMgr::get_stateFlags(TE_STATE * lFlags)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::get_stateFlags()",
              this));

    CHECK_RETURN_NULL(lFlags);

    if (!IsActive())
    {
        *lFlags = TE_STATE_INACTIVE;
    }
    else if (IsPaused())
    {
        *lFlags = TE_STATE_PAUSED;
    }
    else
    {
        *lFlags = TE_STATE_ACTIVE;
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENodeMgr::get_currTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curGlobalTime;

    return S_OK;
}

STDMETHODIMP
CTIMENodeMgr::seek(double lTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::seek(%g)",
              this,
              lTime));

    HRESULT hr;

    // Need to update m_curGlobalTime and m_globalStartTime

    // The global time needs to be reset so that the current tick time
    // will put the global time at lTime.
    //

    // The current global time nees to be lTime
    m_curGlobalTime = lTime;

    // Since: m_lastTickTime == m_curGlobalTime - m_globalStartTime
    // then m_globalStartTime = m_curGlobalTime - m_lastTickTime
    m_globalStartTime = m_curGlobalTime - m_lastTickTime;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::begin()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::begin()",
              this));

    HRESULT hr;
    CEventList l;

    if (IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
        
    hr = THR(BeginMgr(l, m_curGlobalTime));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::end()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::end()",
              this));

    HRESULT hr;
    CEventList l;

    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(EndMgr(m_curGlobalTime));
    if (FAILED(hr))
    {
        goto done;
    }

    TickEvent(l, TE_EVENT_END, 0);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::pause()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::lPause()",
              this));

    HRESULT hr;
    CEventList l;

    if (IsPaused())
    {
        hr = S_OK;
        goto done;
    }
    
    if (!IsActive())
    {
        hr = THR(begin());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    Assert(IsActive());
        
    hr = THR(PauseMgr());
    if (FAILED(hr))
    {
        goto done;
    }

    TickEvent(l, TE_EVENT_PAUSE, 0);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::resume()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::resume()",
              this));

    HRESULT hr;
    CEventList l;

    if (!IsActive())
    {
        hr = THR(begin());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (IsPaused())
    {
        hr = THR(ResumeMgr());
        if (FAILED(hr))
        {
            goto done;
        }
        
        TickEvent(l, TE_EVENT_RESUME, 0);
        
        hr = THR(l.FireEvents());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::BeginMgr(CEventList & l,
                       double lTime)
{
    HRESULT hr;
    
    m_bIsActive = true;
    m_bIsPaused = false;

    // We know ticks must start at 0
    m_lastTickTime = 0.0;

    // The global time at tick time 0.0 is lTime
    m_globalStartTime = lTime;

    // The current global time is lTime since it is tick time 0.0
    m_curGlobalTime = lTime;

    m_firstTick = true;

    m_mmbvr->ResetNode(&l);
                                
#if DBG
    if (IsTagEnabled(tagPrintTimeTree))
    {
        m_mmbvr->Print(0);
    }
#endif
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        IGNORE_HR(EndMgr(lTime));
    }
    
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::EndMgr(double lTime)
{
    HRESULT hr;
    
    m_bIsActive = false;
    m_bIsPaused = false;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::PauseMgr()
{
    HRESULT hr;
    
    Assert(IsActive());
    
    m_bIsPaused = true;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::ResumeMgr()
{
    HRESULT hr;
    
    Assert(IsActive());
    Assert(IsPaused());

    m_bIsPaused = false;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::tick(double tickTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::tick(%g)",
              this,
              tickTime));

    HRESULT hr;
    double gTime;
    CEventList l;

    // Make sure the tick times do not go backwards
    if (tickTime < m_lastTickTime)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Convert the new tick time to global time
    gTime = TickTimeToGlobalTime(tickTime);
    
#if OLD_TIME_ENGINE
    {
        BvrCBList::iterator i;

        // @@ ISSUE : We can run out of memory
        BvrCBList bvrCBListCopy(m_bvrCBList);

        // Now addref the node bvrCBs
        for (i = bvrCBListCopy.begin();
             i != bvrCBListCopy.end();
             i++)
        {
            (*i)->AddRef();
        }
        
        // process any callbacks that have been registered
        for (i = bvrCBListCopy.begin();
             i != bvrCBListCopy.end();
             i++)
        {
            (*i)->OnBvrCB(&l, gTime);
            (*i)->Release();
        }
    }
#endif

    // Be aware that the previous calls seems to cause us to get
    // reentered above and can shut us down.  We need to make sure
    // that between there and here we make no assumptions about
    // state.  Currently we do not so it will work fine.
    
    if (gTime != m_curGlobalTime || m_firstTick)
    {
        Tick(l, gTime);

        // Update the variables so any callbacks get the correct info
        m_curGlobalTime = gTime;
        m_lastTickTime = tickTime;
        m_firstTick = false;
    }
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENodeMgr::Tick(CEventList & l,
                   double lTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Tick(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagMMDetailNotify,
              "Tick(%lx): lTime - %g, m_curGlobalTime - %g, firsttick - %d",
              this,
              lTime,
              m_curGlobalTime,
              m_firstTick));
    
    m_mmbvr->Tick(&l,
                  lTime,
                  false);
}

void
CTIMENodeMgr::TickEvent(CEventList &l,
                        TE_EVENT_TYPE event,
                        DWORD dwFlags)
{
    m_mmbvr->TickEvent(&l, event, 0);

    m_firstTick = false;
}

#if OLD_TIME_ENGINE
HRESULT
CTIMENodeMgr::AddBvrCB(CTIMENode *pbvr)
{
    Assert(pbvr != NULL);

    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    pbvr->AddRef();
    m_bvrCBList.push_back(pbvr);
    return S_OK;
} // AddBvrCB

HRESULT
CTIMENodeMgr::RemoveBvrCB(CTIMENode *pbvr)
{
    Assert(pbvr != NULL);
    
    BvrCBList::iterator i;
    for (i = m_bvrCBList.begin(); i != m_bvrCBList.end(); i++)
    {
        if ((*i) == pbvr)
        {
            m_bvrCBList.erase(i);
            pbvr->Release();
            break;
        }
    }
    return S_OK;
} // RemoveBvrCB
#endif

HRESULT
CTIMENodeMgr::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMENodeMgr, &__uuidof(CTIMENodeMgr)>::Error(str, IID_ITIMENodeMgr, hr);
        delete [] str;
    }
    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\runtimeprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: runtimeprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/



#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMENodeRTProps, "TIME: Engine", "CTIMENode runtime props");

STDMETHODIMP
CTIMENode::get_beginParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_beginParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    
    *d = GetBeginParentTime();
    
    return S_OK;
}

// This is the time on the parents timeline at which the node
// will or already has ended.  If it is infinite then the end
// time is unknown.
// This is in posttransformed parent time.
STDMETHODIMP
CTIMENode::get_endParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_endParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    
    *d = GetEndParentTime();
    
    return S_OK;
}

// This is the current simple time of the node.
STDMETHODIMP
CTIMENode::get_currSimpleTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSimpleTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcCurrSimpleTime();
    }
    
    return S_OK;
}

// This is the number of times the node has repeated
STDMETHODIMP
CTIMENode::get_currRepeatCount(LONG * l)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currRepeatCount()",
              this));

    CHECK_RETURN_NULL(l);

    *l = 0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *l = m_lCurrRepeatCount;
    }
    
    return S_OK;
}

// This is the current segment time of the node.
STDMETHODIMP
CTIMENode::get_currSegmentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSegmentTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = GetCurrSegmentTime();
    }

    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currActiveTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currActiveTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcElapsedActiveTime();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currSegmentDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSegmentDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = CalcCurrSegmentDur();
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currImplicitDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currImplicitDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = TIME_INFINITE;
    
    if (GetImplicitDur() != TE_UNDEFINED_VALUE)
    {
        *d = GetImplicitDur();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currSimpleDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSimpleDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = CalcCurrSimpleDur();
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currProgress(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currProgress()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcCurrSimpleTime() / CalcCurrSimpleDur();
    }
    
    return S_OK;
}

// This returns the current speed
STDMETHODIMP
CTIMENode::get_currSpeed(float * speed)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSpeed()",
              this));

    CHECK_RETURN_NULL(speed);
    float fltRet = GetCurrRate();
    
    if (TEIsBackward(CalcSimpleDirection()))
    {
        fltRet *= -1.0f;
    }
    
    *speed = fltRet;

    return S_OK;
}

// This is the total time during which the element is active.
// This does not include fill time which extends past the active
// duration.
STDMETHODIMP
CTIMENode::get_activeDur(double * dbl)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_activeDur()",
              this));

    CHECK_RETURN_NULL(dbl);

    *dbl = CalcEffectiveActiveDur();
    
    return S_OK;
}


// This is the parent's time when the last tick occurred (when it
// was currTime)
STDMETHODIMP
CTIMENode::get_currParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    *d = GetCurrParentTime();
    
    return S_OK;
}


// This will return whether the node is active.  This will be
// false if the node is in the fill period
STDMETHODIMP
CTIMENode::get_isActive(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isActive()",
              this));

    CHECK_RETURN_NULL(b);

    *b = VARIANT_FALSE;

    if (CalcIsActive() && !CalcIsDisabled())
    {
        *b = VARIANT_TRUE;
    }
    
    return S_OK;
}

// This will return true if the node is active or in the fill period
STDMETHODIMP
CTIMENode::get_isOn(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isOn()",
              this));

    CHECK_RETURN_NULL(b);
    *b = VARIANT_FALSE;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *b = VARIANT_TRUE;
    }
    
    return S_OK;
}


// This will return whether node itself has been paused explicitly
STDMETHODIMP
CTIMENode::get_isPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isPaused()",
              this));

    CHECK_RETURN_NULL(b);

    *b = GetIsPaused()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been paused explicitly
STDMETHODIMP
CTIMENode::get_isCurrPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isCurrPaused()",
              this));

    CHECK_RETURN_NULL(b);

    *b = CalcIsPaused()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been disabled explicitly
STDMETHODIMP
CTIMENode::get_isDisabled(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isDisabled()",
              this));

    CHECK_RETURN_NULL(b);

    *b = GetIsDisabled()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been disabled explicitly
STDMETHODIMP
CTIMENode::get_isCurrDisabled(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isCurrDisabled()",
              this));

    CHECK_RETURN_NULL(b);

    *b = CalcIsDisabled()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return the detailed state flags
STDMETHODIMP
CTIMENode::get_stateFlags(TE_STATE * lFlags)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_stateFlags()",
              this));

    CHECK_RETURN_NULL(lFlags);

    if (!CalcIsActive() || CalcIsDisabled())
    {
        *lFlags = TE_STATE_INACTIVE;
    }
    else if (CalcIsPaused())
    {
        *lFlags = TE_STATE_PAUSED;
    }
    else
    {
        *lFlags = TE_STATE_ACTIVE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\notify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagMMNotify, "TIME: Engine", "Notifications")
DeclareTag(tagMMNotifyRepeat, "TIME: Engine", "Notifications - Repeats")
DeclareTag(tagMMNotifyTimeShift, "TIME: Engine", "Notifications - Time Shifts")
DeclareTag(tagMMNotifyReset, "TIME: Engine", "Notifications - Resets")
DeclareTag(tagMMPropNotify, "TIME: Engine", "Property Notifications")

#define MAX_EVENTS_PER_TICK 30000  //this is the maximum allowable events per tick

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

void
CTIMENode::EventNotify(CEventList * l,
                       double evTime,
                       TE_EVENT_TYPE et,
                       long lRepeatCount)
{
#if DBG
    TRACETAG tag;

    switch(et)
    {
      case TE_EVENT_REPEAT:
        tag = tagMMNotifyRepeat;
        break;
      case TE_EVENT_PARENT_TIMESHIFT:
        tag = tagMMNotifyTimeShift;
        break;
      case TE_EVENT_RESET:
        tag = tagMMNotifyReset;
        break;
      default:
        tag = tagMMNotify;
        break;
    }
    
    TraceTag((tag,
              "CTIMENode(%p,%ls)::EventNotify(%p): evTime = %g, evParentTime = %g, event = %s, rc = %d",
              this,
              GetID(),
              l,
              evTime,
              evTime + GetBeginParentTime(),
              EventString(et),
              lRepeatCount));
#endif

    switch (et)
    {
      case TE_EVENT_BEGIN:
        m_bIsActive = true;
        m_bFirstTick = false;
        m_bDeferredActive = false;

        // Reset the flag when we become active
        m_bEndedByParent = false;

        // Clear all the events from the timeline
        ResetOneShots();

        PropNotify(l,
                   (TE_PROPERTY_ISACTIVE | TE_PROPERTY_ISON));
        break;
      case TE_EVENT_END:
        m_bIsActive = false;
        m_bFirstTick = false;
        PropNotify(l,
                   (TE_PROPERTY_ISACTIVE | TE_PROPERTY_ISON));
        break;
      case TE_EVENT_REPEAT:
        if (GetAutoReverse())
        {
            PropNotify(l,
                       TE_PROPERTY_SPEED);
        }
        break;
      case TE_EVENT_AUTOREVERSE:
        PropNotify(l,
                   TE_PROPERTY_SPEED);
        break;
      default:
        break;
    }

    if (l)
    {
        IGNORE_HR(l->Add(this, evTime, et, lRepeatCount));
    }

  done:
    return;
}

void
CTIMENode::PropNotify(CEventList *l,
                      DWORD pt)
{
    char buf[1024];
    
    TraceTag((tagMMPropNotify,
              "CTIMENode(%p, %ls)::PropNotify(%p): prop = %s",
              this,
              GetID(),
              l,
              CreatePropString(pt,
                               buf,
                               ARRAY_SIZE(buf))));

    HRESULT hr;
    
    if (l)
    {
        SetPropChange(pt);

        hr = THR(l->AddPropChange(this));
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return;
} //lint !e529

    
class CEventData
{
  public:
    CEventData(CTIMENode * node,
               double time,
               TE_EVENT_TYPE et,
               long lRepeatCount);
    ~CEventData();

    HRESULT CallEvent();

    CTIMENode* GetNode() { return m_node; }
    TE_EVENT_TYPE GetEventType() { return m_et; }
  protected:
    DAComPtr<CTIMENode> m_node;
    double m_time;
    TE_EVENT_TYPE m_et;
    long m_lRepeatCount;

    CEventData();
};

CEventData::CEventData(CTIMENode * node,
                       double time,
                       TE_EVENT_TYPE et,
                       long lRepeatCount)
: m_node(node),
  m_time(time),
  m_et(et),
  m_lRepeatCount(lRepeatCount)
{
}

CEventData::~CEventData()
{
}

HRESULT
CEventData::CallEvent()
{
    RRETURN(THR(m_node->DispatchEvent(m_time, m_et, m_lRepeatCount)));
}

DeclareTag(tagCEventList, "TIME: Engine", "Event List")

//
// CEventList methods
//
CEventList::CEventList()
{
}

CEventList::~CEventList()
{
    Clear();
}

HRESULT
CEventList::FireEvents()
{
    TraceTag((tagCEventList,
              "CEventList(%p)::FireEvents()",
              this));

    HRESULT hr;
    
    hr = S_OK;

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            HRESULT tmphr = THR((*i)->CallEvent());
            if (FAILED(tmphr))
            {
                hr = tmphr;
            }

            delete (*i);
        }

        m_eventList.clear();
    }
    
    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            CTIMENode * pn = *i;
            
            HRESULT tmphr = THR(pn->DispatchPropChange(pn->GetPropChange()));
            if (FAILED(tmphr))
            {
                hr = tmphr;
            }

            pn->ClearPropChange();
            
            pn->Release();
        }

        m_propSet.clear();
    }
    
    RRETURN(hr);
}

void
CEventList::Clear()
{
    TraceTag((tagCEventList,
              "CEventList(%p)::Clear()",
              this));

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            delete (*i);
        }

        m_eventList.clear();
    }

    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            // Do not clear the prop change since we are not sure we
            // fired the event
            (*i)->Release();
        }

        m_propSet.clear();
    }
}

HRESULT
CEventList::Add(CTIMENode * node,
                double time,
                TE_EVENT_TYPE et,
                long lRepeatCount)
{
    HRESULT hr;
    
    CEventData * data = NEW CEventData(node,
                                       time,
                                       et,
                                       lRepeatCount);
    
    if (NULL == data)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // @@ ISSUE : This does not detect memory failures
    if (m_eventList.size() < MAX_EVENTS_PER_TICK)
    {
        m_eventList.push_back(data);
    }
    
    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

HRESULT
CEventList::AddPropChange(CTIMENode * node)
{
    HRESULT hr;
    
    // @@ ISSUE : This does not detect memory failures
    if (m_propSet.insert(node).second)
    {
        node->AddRef();
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

#if DBG
void
CEventList::Print()
{
    TraceTag((tagMMNotify,
              "Starting PrintCEventList"));

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            TraceTag((tagMMNotify,
                      "CTIMENode(%p)     Event=%d",
                      (*i)->GetNode(),
                      (*i)->GetEventType() ));
        }
    }

    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            CTIMENode * pn = *i;
            char buf[1024];
            
            TraceTag((tagMMNotify,
                      "CTIMENode(%p)     Prop=%s",
                      pn,
                      CreatePropString(pn->GetPropChange(),
                                       buf,
                                       ARRAY_SIZE(buf))));
        }
    }
}

#endif
    
#if DBG
void PrintCEventList(CEventList &l)
{
    l.Print();
}

void
AppendPropString(DWORD dwFlags,
                 TE_PROPERTY_TYPE pt,
                 char *pstr,
                 DWORD dwSize,
                 bool & bFirst)
{
    if ((dwFlags & pt) != 0)
    {
        if (!bFirst)
        {
            StrCatBuffA(pstr, ";", dwSize);
        }

        bFirst = false;
        
        StrCatBuffA(pstr, PropString(pt), dwSize);
    }
}

char *
CreatePropString(DWORD dwFlags, char * pstr, DWORD dwSize)
{
    bool bFirst = true;
    
    if (dwSize >= 1)
    {
        pstr[0] = 0;
    }
    
    AppendPropString(dwFlags, TE_PROPERTY_TIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_REPEATCOUNT, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SEGMENTDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_IMPLICITDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SIMPLEDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ACTIVEDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_PROGRESS, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SPEED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_BEGINPARENTTIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ENDPARENTTIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISACTIVE, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISON, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISPAUSED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISCURRPAUSED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_STATEFLAGS, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISDISABLED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISCURRDISABLED, pstr, dwSize, bFirst);

    return pstr;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\nodemgr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: TIMENodeMgr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "Node.h"
#include <mshtml.h>
#include <vector>
#include "nodecontainer.h"

extern TRACETAG tagPrintTimeTree;

interface ITIMENode;

typedef std::list< CTIMENode * > BvrCBList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CTIMENodeMgr
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMENodeMgr, &__uuidof(CTIMENodeMgr)>,
      public ITIMENodeMgr,
      public ISupportErrorInfoImpl<&IID_ITIMENodeMgr>,
      public CNodeContainer
{
  public:
    CTIMENodeMgr();
    virtual ~CTIMENodeMgr();

    HRESULT Init(LPOLESTR id,
                 ITIMENode * bvr,
                 IServiceProvider * sp);

    void Deinit();
    
#if DBG
    const _TCHAR * GetName() { return __T("CTIMENodeMgr"); }
#endif

    BEGIN_COM_MAP(CTIMENodeMgr)
        COM_INTERFACE_ENTRY(ITIMENodeMgr)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // IUnknown
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    //
    // ITIMEMMPlayer
    //
    
    STDMETHOD(get_id)(LPOLESTR * s);
    STDMETHOD(put_id)(LPOLESTR s);
        
    STDMETHOD(begin)();
    STDMETHOD(end)();
    STDMETHOD(pause)();
    STDMETHOD(resume)();
    STDMETHOD(seek)(double dblTime);
    
    STDMETHOD(get_stateFlags)(TE_STATE *);
        
    STDMETHOD(get_currTime)(double * dblTime);

    STDMETHOD(get_node)(ITIMENode ** pptn);

    STDMETHOD(tick)(double dblTime);
    
    //
    // CNodeContainer
    //
    
    double ContainerGetSegmentTime() const { return GetCurrTime(); }
    double ContainerGetSimpleTime() const { return GetCurrTime(); }
    TEDirection ContainerGetDirection() const { return GetDirection(); }
    float  ContainerGetRate() const { return GetRate(); }
    bool   ContainerIsActive() const { return IsActive(); }
    bool   ContainerIsOn() const { return true; }
    bool   ContainerIsPaused() const { return IsPaused(); }
    bool   ContainerIsDisabled() const { return false; }
    bool   ContainerIsDeferredActive() const { return false; }
    bool   ContainerIsFirstTick() const { return IsFirstTick(); }

    //
    // Accessors
    //

    bool IsActive() const { return m_bIsActive; }
    bool IsPaused() const { return m_bIsPaused; }

    void Invalidate() { m_bNeedsUpdate = true; }

    bool IsFirstTick() const { return m_firstTick; }
    double GetCurrTime() const { return m_curGlobalTime; }
    TEDirection GetDirection() const { return TED_Forward; }
    float GetRate() const { return 1.0f; }
    
    // This indicates that a tick is required to update internal
    // state.  The node mgr needs to request this from the client
    void RequestTick();
    
#if OLD_TIME_ENGINE
    HRESULT AddBvrCB(CTIMENode *pbvr);
    HRESULT RemoveBvrCB(CTIMENode *pbvr);
#endif

    // !!This does not addref!!
    IServiceProvider * GetServiceProvider();
    CTIMENode * GetTIMENode() { return m_mmbvr; }
  protected:
    HRESULT BeginMgr(CEventList &l,
                     double lTime);
    HRESULT EndMgr(double lTime);
    HRESULT PauseMgr();
    HRESULT ResumeMgr();
    
    void TickEvent(CEventList &l,
                   TE_EVENT_TYPE event,
                   DWORD dwFlags);
    
    void Tick(CEventList & l,
              double lTime);
    
    HRESULT Error();
    
  protected:
    DAComPtr<CTIMENode> m_mmbvr;
    CComPtr<IServiceProvider> m_sp;

    bool m_bIsActive;
    bool m_bIsPaused;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    
    //
    // Relationships:
    //    m_lastTickTime - m_tickStartTime == m_curGlobalTime - m_globalStartTime
    //    m_tickStartTime is implicitly 0
    // thus:
    //    m_lastTickTime == m_curGlobalTime - m_globalStartTime
    //
    
    double m_curGlobalTime;
    double m_globalStartTime;
    
    inline double TickTimeToGlobalTime(double tickTime);
  private:
/*lint ++flb*/
    LPWSTR m_id;
    bool m_bForward;
    double m_lastTickTime;
#if OLD_TIME_ENGINE
    BvrCBList m_bvrCBList;
#endif
/*lint --flb*/

};

inline IServiceProvider *
CTIMENodeMgr::GetServiceProvider()
{
    return m_sp;
}

// Since: m_lastTickTime == m_curGlobalTime - m_globalStartTime
// then gTime == tickTime + m_globalStartTime

inline double
CTIMENodeMgr::TickTimeToGlobalTime(double tickTime)
{
    return tickTime + m_globalStartTime;
}

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\seek.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: seek.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "container.h"

DeclareTag(tagTIMESeek, "TIME: Engine", "Seeking");

HRESULT
CTIMENode::SeekTo(LONG lNewRepeatCount,
                  double dblNewSegmentTime,
                  CEventList * l)
{
    TraceTag((tagTIMESeek,
              "CTIMENode(%lx)::SeekTo(%ld,%g,%#x)",
              this,
              lNewRepeatCount,
              dblNewSegmentTime,
              l));

    HRESULT hr;
    double dblSegmentDur = CalcCurrSegmentDur();
    
    Assert(IsActive());

    // Max out at the segment duration
    if (dblNewSegmentTime > dblSegmentDur)
    {
        dblNewSegmentTime = dblSegmentDur;
    }
    else if (dblNewSegmentTime < 0)
    {
        dblNewSegmentTime = 0;
    }
    
    if (lNewRepeatCount >= CalcRepeatCount())
    {
        lNewRepeatCount = CalcRepeatCount() - 1;
    }
    else if (lNewRepeatCount < 0)
    {
        lNewRepeatCount = 0;
    }
    
    // See if we are indeed seeking
    if (GetCurrSegmentTime() == dblNewSegmentTime &&
        GetCurrRepeatCount() == lNewRepeatCount)
    {
        hr = S_OK;
        goto done;
    }

    double dblNewActiveTime;
    dblNewActiveTime = CalcNewActiveTime(dblNewSegmentTime,
                                         lNewRepeatCount);
    double dblNewParentTime;
    dblNewParentTime = CalcParentTimeFromActiveTime(dblNewActiveTime);

    if (IsLocked())
    {
        if (GetParent())
        {
            double dblParentSegmentTime;
            dblParentSegmentTime = GetParent()->SimpleTimeToSegmentTime(dblNewParentTime);

            hr = THR(GetParent()->SeekTo(GetParent()->GetCurrRepeatCount(),
                                         dblParentSegmentTime,
                                         l));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        TE_EVENT_TYPE te = (lNewRepeatCount == GetCurrRepeatCount())?TE_EVENT_SEEK:TE_EVENT_RESET;
         
        m_dblElapsedActiveRepeatTime = dblNewActiveTime - dblNewSegmentTime;

        // This is a very weird way to calculate this but it leads to
        // fewer precision problems.  Since tick calculates things by
        // subtracting active time we should do this as well
        
        m_dblCurrSegmentTime = dblNewActiveTime - m_dblElapsedActiveRepeatTime;
        // Again due to precision problems clamp the segment dur
        m_dblCurrSegmentTime = Clamp(0.0,
                                     m_dblCurrSegmentTime,
                                     dblSegmentDur);
        
        m_lCurrRepeatCount = lNewRepeatCount;
        
        PropNotify(l,
                   (TE_PROPERTY_TIME |
                    TE_PROPERTY_REPEATCOUNT |
                    TE_PROPERTY_PROGRESS));
        
        // Fire a seek event on ourself
        EventNotify(l, CalcElapsedActiveTime(), te);

        // Now recalc our end time and propagate to dependencies
        RecalcCurrEndTime(l, true);

        // Now fire a tick event to our children letting them know the
        // parent time has been changed
        TickEventChildren(l, te, 0);

        if (te == TE_EVENT_SEEK)
        {
            // Fire a parent time shift event
            TickEventChildren(l, TE_EVENT_PARENT_TIMESHIFT, 0);
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENode::HandleSeekUpdate(CEventList * l)
{
    TraceTag((tagTIMESeek,
              "CTIMENode(%lx)::HandleSeekUpdate(%#x)",
              this,
              l));

    double dblParentSimpleTime = GetContainer().ContainerGetSimpleTime();
    double dblSegmentDur = CalcCurrSegmentDur();
    bool bPrevActive = IsActive();
    
    // We really did not seek - just return
    if (dblParentSimpleTime == GetCurrParentTime())
    {
        // we may be in a fill region
        PropNotify(l, TE_PROPERTY_ISON);
        goto done;
    }

    // See if the seek moves us out of the current instance.  If so
    // then we need a full reset
    if (dblParentSimpleTime < GetBeginParentTime() ||
        dblParentSimpleTime > GetEndParentTime())
    {
        ResetNode(l, true, false);
        goto done;
    }
    else if (!IsActive())
    {
        CalcCurrRuntimeState(l, 0.0);
    }

    // See if we are seeking before the current repeat boundary.  If
    // not then we can use this point as the boundary and not do a
    // reset of the repeat boundary
    //
    // If we are passing an earlier repeat boundary then we need to do
    // a repeat boundary recalc

#if 0
    else if (dblNewLocalTime >= m_dblLastLocalRepeatTime)
    {
        double dblNewElapsedTime;
        
        if (dblParentSimpleTime > GetActiveEndTime() ||
            (!m_bFirstTick && dblParentSimpleTime == GetActiveEndTime()))
        {
            m_bIsActive = false;
            dblNewLocalTime = GetActiveEndTime() - GetActiveBeginTime();
        }
        else
        {
            // We should already be active at this point - but check
            // to make sure
            Assert(m_bIsActive);
        }

        dblNewElapsedTime = m_dblLastSegmentTime + (dblNewLocalTime - m_dblLastLocalTime);
        if (dblNewElapsedTime < 0)
        {
            dblNewElapsedTime = 0;
        }
        
        if (dblNewElapsedTime < dblSegmentDur)
        {
            m_dblLastSegmentTime = dblNewElapsedTime;
        }
        else
        {
            long lNewRepeats = int(dblNewElapsedTime / dblSegmentDur);
            double dblNewElapsedRepeatTime = lNewRepeats * dblSegmentDur;

            m_lCurrRepeatCount += lNewRepeats;
            Assert(m_lCurrRepeatCount <= CalcRepeatCount());

            m_dblElapsedRepeatTime += dblNewElapsedRepeatTime;
            Assert(m_dblElapsedRepeatTime <= m_dblActiveDur);
        
            // The segment time is the remainder left
            m_dblLastSegmentTime = dblNewElapsedTime - dblNewElapsedRepeatTime;
            Assert(m_dblLastSegmentTime <= dblSegmentDur);

            // The new repeat time is the time when the segment began
            m_dblLastLocalRepeatTime = dblNewLocalTime - m_dblLastSegmentTime;

            if (0.0 > m_dblLastLocalRepeatTime)
            {
                m_dblLastLocalRepeatTime = 0.0;
            }
        }

        m_dblLastLocalTime = dblNewLocalTime;
    }
#endif
    else
    {
        // Recalc the runtime state taking into account the lag
        CalcCurrRuntimeState(l,
                             CalcCurrLocalTime() - CalcElapsedLocalTime());
    }

    if (bPrevActive != IsActive())
    {
        // Only fire the begin if it lands anywhere but on the begin
        // point
        if (IsActive())
        {
            // We need to defer the begin if we are locked, on our begin
            // point, and our parent needs a first tick
            // TODO: Consider adding a fudge of a little bit to hold
            // off the begin since we get truncation sometimes
            bool bSkip = (IsLocked() &&
                          GetCurrParentTime() == CalcActiveBeginPoint() &&
                          GetContainer().ContainerIsFirstTick());
            if (bSkip)
            {
                // Defer the begin
                m_bFirstTick = true;
            }
            else
            {
                EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
            }
        }
        else
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_END);
        }
    }
    
  done:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\props.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"

STDMETHODIMP
CTIMENode::get_id(LPOLESTR * p)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_id()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_pszID)
    {
        *p = SysAllocString(m_pszID);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMENode::put_id(LPOLESTR s)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_id(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_pszID;
    m_pszID = NULL;

    if (s)
    {
        m_pszID = CopyString(s);

        if (m_pszID == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CTIMENode::get_dur(double * pdur)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_dur()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_dblDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_dur(double dur)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_dur(%g)",
              this,
              dur));

    // TODO: Should this be invalid?
    if (dur != TE_UNDEFINED_VALUE &&
        dur < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblDur != dur)
    {
        m_dblDur = dur;
        
        Invalidate(TE_INVALIDATE_DUR);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_repeatCount(double * prepeat)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_repeatCount()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_dblRepeatCount;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_repeatCount(double repeat)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatCount(%d)",
              this,
              repeat));

    if (repeat != TE_UNDEFINED_VALUE &&
        repeat < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblRepeatCount != repeat)
    {
        m_dblRepeatCount = repeat;
        
        Invalidate(TE_INVALIDATE_DUR);
    }

    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_repeatDur(double * pr)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_repeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_dblRepeatDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_repeatDur(double r)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatDur(%g)",
              this,
              r));

    if (r != TE_UNDEFINED_VALUE &&
        r < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblRepeatDur != r)
    {
        m_dblRepeatDur = r;
        
        Invalidate(TE_INVALIDATE_DUR);
    }

    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_fill(TE_FILL_FLAGS * ptef)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_fill()",
              this));

    CHECK_RETURN_NULL(ptef);

    *ptef = m_tefFill;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_fill(TE_FILL_FLAGS tef)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatDur(%x)",
              this,
              tef));

    if (m_tefFill != tef)
    {
        m_tefFill = tef;
        
        Invalidate(TE_INVALIDATE_STATE);
    }
    
    return S_OK;
}
    
STDMETHODIMP
CTIMENode::get_autoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_autoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_autoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_autoReverse(%d)",
              this,
              autoreverse));

    bool ar = autoreverse?true:false;
    
    if (m_bAutoReverse != ar)
    {
        m_bAutoReverse = ar;
        
        Invalidate(TE_INVALIDATE_DUR);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_speed(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_speed()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltSpeed;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_speed(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_speed(%g)",
              this,
              flt));

    if (flt == 0.0f)
    {
        return E_INVALIDARG;
    }
    
    if (m_fltSpeed != flt)
    {
        Invalidate(TE_INVALIDATE_SIMPLETIME | TE_INVALIDATE_END);

        m_fltSpeed = flt;
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_accelerate(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_accelerate()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltAccel;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_accelerate(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_accelerate(%g)",
              this,
              flt));

    if (flt < 0.0 || flt > 1.0) return E_INVALIDARG;
    
    if (m_fltAccel != flt)
    {
        m_fltAccel = flt;
        
        Invalidate(TE_INVALIDATE_SIMPLETIME);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_decelerate(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_decelerate()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltDecel;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_decelerate(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_decelerate(%g)",
              this,
              flt));

    if (flt < 0.0 || flt > 1.0) return E_INVALIDARG;

    if (m_fltDecel != flt)
    {
        m_fltDecel = flt;
        
        Invalidate(TE_INVALIDATE_SIMPLETIME);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_flags(DWORD * flags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_flags()",
              this));

    CHECK_RETURN_NULL(flags);

    *flags = m_dwFlags;

    return S_OK;
}

STDMETHODIMP
CTIMENode::put_flags(DWORD flags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_flags(%d)",
              this,
              flags));

    // if we need to registered a Timer Callback, add it to the player.
    if (m_ptnmNodeMgr)
    {
        bool newcs = (flags & TE_FLAGS_MASTER) != 0;
        bool oldcs = IsSyncMaster();
        
        // If the clock source parameter changed update ourselves in
        // the player
        if (newcs && !oldcs)
        {
            m_ptnmNodeMgr->AddBvrCB(this);
        }
        else if (oldcs && !newcs)
        {
            m_ptnmNodeMgr->RemoveBvrCB(this);
        }
    }

    m_dwFlags = flags;

    return S_OK;
}

STDMETHODIMP
CTIMENode::get_restart(TE_RESTART_FLAGS * pr)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_restart()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_teRestart;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_restart(TE_RESTART_FLAGS r)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_restart(%#x)",
              this,
              r));

    m_teRestart = r;
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_naturalDur(double * pdbl)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_naturalDur()",
              this));

    CHECK_RETURN_NULL(pdbl);
    *pdbl = m_dblNaturalDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_naturalDur(double dbl)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_naturalDur(%g)",
              this,
              dbl));

    HRESULT hr;
    CEventList l;
    bool bRecalc = false;
    double dblPrevSegmentDur = CalcCurrSegmentDur();
    
    if (dbl != TE_UNDEFINED_VALUE &&
        dbl < 0.0)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_dblNaturalDur == TE_UNDEFINED_VALUE
        && GetCurrRepeatCount() == 0)
    {
        bRecalc = true;
    }
    
    m_dblNaturalDur = dbl;

    double dblSegmentDur;
    dblSegmentDur = CalcCurrSegmentDur();
    
    if (dblPrevSegmentDur == dblSegmentDur)
    {
        hr = S_OK;
        goto done;
    }
    
    PropNotify(&l, TE_PROPERTY_SEGMENTDUR);

    RecalcSegmentDurChange(&l, bRecalc);
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\tick.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tick.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTick, "TIME: Engine", "Tick");

//+-----------------------------------------------------------------------
//
//  Function:  CheckTickBounds
//
//  Overview:  Checks the bounds of the tick to see if we need to do
//             anything
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------

bool
CheckTickBounds(CTIMENode & tn,
                double & dblLastParentTime,
                double & dblNextParentTime,
                bool & bNeedBegin,
                bool & bNeedEnd)
{
    TraceTag((tagTick,
              "CheckTickBounds(%ls,%p,%g,%g)",
              tn.GetID(),
              &tn,
              dblLastParentTime,
              dblNextParentTime));

    bool bRet = true;
    double dblEndParentTime = tn.GetEndParentTime();
    double dblBeginParentTime = tn.GetBeginParentTime();
    bool bFirstTick = tn.IsFirstTick();
    bool bDeferredActive = tn.IsDeferredActive();
    
    bNeedBegin = bNeedEnd = false;
    
    if (tn.GetParentDirection() == TED_Forward)
    {
        Assert(dblLastParentTime <= dblNextParentTime);
        
        if (bDeferredActive &&
            bFirstTick &&
            dblNextParentTime == dblBeginParentTime)
        {
            bRet = false;
            goto done;
        }
        else if (dblLastParentTime >= dblEndParentTime ||
                 dblNextParentTime < dblBeginParentTime)
        {
            // Handle the case where the last tick was on the end
            // boundary point
            if (dblLastParentTime == dblEndParentTime)
            {
                // First handle the 0 active duration
                if (dblEndParentTime == dblBeginParentTime)
                {
                    if (bFirstTick || tn.IsActive())
                    {
                        bNeedBegin = bFirstTick;
                        bNeedEnd = true;

                        dblNextParentTime = dblEndParentTime;
                    }
                    else
                    {
                        bRet = false;
                    }
                }
                // Now handle where we started at the end point
                else if (bFirstTick &&
                         dblNextParentTime == dblEndParentTime)
                {
                    bNeedBegin = true;
                    bNeedEnd = true;
                }
                // In case we reached the end point during a recalc
                // (like seek)  Let's make sure we always fire the end.
                else if (tn.IsActive())
                {
                    bNeedEnd = true;
                    dblNextParentTime = dblEndParentTime;
                }
                else
                {
                    bRet = false;
                }
            }
            else
            {
                bRet = false;
            }
        }
        else
        {
            // Need to make sure we set the out params correctly
            if (dblLastParentTime < dblBeginParentTime)
            {
                dblLastParentTime = dblBeginParentTime;
                bNeedBegin = true;
            }

            if (dblNextParentTime >= dblEndParentTime)
            {
                dblNextParentTime = dblEndParentTime;
                bNeedEnd = true;
            }
        }
    }
    else
    {
        if (bDeferredActive &&
            bFirstTick &&
            dblNextParentTime == dblEndParentTime)
        {
            bRet = false;
            goto done;
        }
        else if (dblLastParentTime <= dblBeginParentTime ||
                 dblNextParentTime > dblEndParentTime)
        {
            if (dblLastParentTime == dblBeginParentTime)
            {
                // First handle the 0 active duration
                if (dblEndParentTime == dblBeginParentTime)
                {
                    if (bFirstTick || tn.IsActive())
                    {
                        bNeedBegin = bFirstTick;
                        bNeedEnd = true;

                        dblNextParentTime = dblBeginParentTime;
                    }
                    else
                    {
                        bRet = false;
                    }
                }
                // Now handle where we started at the end point
                else if (bFirstTick &&
                         dblNextParentTime == dblBeginParentTime)
                {
                    bNeedBegin = true;
                    bNeedEnd = true;
                }
                // In case we reached the end point during a recalc
                // (like seek)  Let's make sure we always fire the end.
                else if (tn.IsActive())
                {
                    bNeedEnd = true;
                    dblNextParentTime = dblBeginParentTime;
                }
                else
                {
                    bRet = false;
                }
            }
            else
            {
                bRet = false;
            }
        }
        else
        {
            // Need to make sure we set the out params correctly
            if (dblLastParentTime > dblEndParentTime)
            {
                dblLastParentTime = dblEndParentTime;
                bNeedBegin = true;
            }

            if (dblNextParentTime <= dblBeginParentTime)
            {
                dblNextParentTime = dblBeginParentTime;
                bNeedEnd = true;
            }
        }
    }

    if (bFirstTick)
    {
        bNeedBegin = true;
    }
    
  done:
    return bRet;
}

double
CalcNewTickActiveTime(CTIMENode & tn,
                      double dblLastParentTime,
                      double dblNewParentTime)
{
    TraceTag((tagTick,
              "CalcNewTickActiveTime(%ls,%p,%g,%g)",
              tn.GetID(),
              &tn,
              dblLastParentTime,
              dblNewParentTime));

    Assert(dblLastParentTime >= tn.GetBeginParentTime() &&
           dblLastParentTime <= tn.GetEndParentTime());
    Assert(dblNewParentTime >= tn.GetBeginParentTime() &&
           dblNewParentTime <= tn.GetEndParentTime());

    double dblDelta = dblNewParentTime - dblLastParentTime;

    // How figure out if we need to reverse it and change the sign
    if (tn.GetDirection() == TED_Backward)
    {
        dblDelta *= -1;
    }

    // Check to make sure we are moving in the correct direction
    Assert((tn.CalcActiveDirection() == TED_Forward) ||
           (dblDelta <= 0.0));
    Assert((tn.CalcActiveDirection() == TED_Backward) ||
           (dblDelta >= 0.0));
    
    double dblNewActiveTime;

    // Now get the elapsed local time
    dblNewActiveTime = tn.CalcElapsedLocalTime();
    
    // Add the delta
    dblNewActiveTime += dblDelta;

    // Now transform it back
    dblNewActiveTime = tn.ApplyActiveTimeTransform(dblNewActiveTime);

    // Now clamp it
    dblNewActiveTime = Clamp(0.0,
                             dblNewActiveTime,
                             tn.CalcEffectiveActiveDur());
    
    return dblNewActiveTime;
}

void
CTIMENode::UpdateNextTickBounds(CEventList * l,
                                double dblBeginTime,
                                double dblParentTime)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::UpdateTickBounds(%p, %g, %g)",
              this,
              l,
              dblBeginTime,
              dblParentTime));

    bool bPrevPaused = CalcIsPaused();

    // Update before we calcruntimestate
    m_bIsPaused = false;

    // See if we were paused but no longer are paused (we do not have
    // to worry about the other case since we can never transition to
    // paused when we are reset
    Assert(bPrevPaused || !CalcIsPaused());
    
    if (bPrevPaused && !CalcIsPaused())
    {
        TickEvent(l, TE_EVENT_RESUME, 0);
    }

    if (IsActive() && !m_bFirstTick)
    {
        TickEvent(l, TE_EVENT_END, 0);
    }
                
    // Before updating and propagating the begin point we need to
    // reset the end points to point to infinity.  This is done for
    // the case where an element begins and ends with us and so sees
    // the previous end and can cause trouble.  Infinity is as good an
    // indeterminate as we can get
    
    // Do not propagate the ends but just update them
    UpdateEndTime(l, TIME_INFINITE, false);
    UpdateEndSyncTime(TIME_INFINITE);
    UpdateLastEndSyncTime(l, TIME_INFINITE, false);

    // Now update the begin and propagate the change
    UpdateBeginTime(l, dblBeginTime, true);

    // Update before we calc the end
    
    m_bFirstTick = true;

    // We need to reset the end times so that the implicit duration
    // calcbacks do not look at the end times inclusively
    // This happens during the reset call and we used to use first
    // tick in the end calc but this messes up if we have a deferred
    // active tick and an endElement call comes in
    m_saEndList.Reset();

    double dblEnd;
    double dblEndSync;
        
    CalcEndTime(dblBeginTime,
                false,
                dblBeginTime,
                0.0,
                0,
                0.0,
                dblEnd,
                dblEndSync);
        
    UpdateEndTime(l, dblEnd, true);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, true);

    CalcRuntimeState(l, dblParentTime, 0.0);

    // Now go through our children
    ResetChildren(l, true);
}

void
CTIMENode::Tick(CEventList * l,
                double dblNewParentTime,
                bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::Tick(lt:%g, ct:%g, dir:%s, ft:%d, nb:%d)",
              this,
              GetID(),
              m_dblCurrParentTime,
              dblNewParentTime,
              DirectionString(GetDirection()),
              m_bFirstTick,
              bNeedBegin));

    bool bNeedDefer = (IsSyncCueing() ||
                       GetContainer().ContainerIsDeferredActive());
    
    Assert(!IsDeferredActive() || IsFirstTick());
    
    if (m_bDeferredActive != bNeedDefer)
    {
        // If we have already fired a begin event do not attempt to
        // change to deferred
        if (!bNeedDefer || IsFirstTick())
        {
            PropNotify(l,
                       (TE_PROPERTY_TIME |
                        TE_PROPERTY_REPEATCOUNT |
                        TE_PROPERTY_PROGRESS |
                        TE_PROPERTY_ISACTIVE |
                        TE_PROPERTY_ISON |
                        TE_PROPERTY_STATEFLAGS));
            
            // Update the deferred cueing mechanism
            m_bDeferredActive = bNeedDefer;
        }
    }
    
    m_bInTick = true;
    
    while (true) //lint !e716
    {
        // The reason it is done like this (rather than a pure
        // if/then/else) is that TickInactive does not set the active
        // flag so the next time through the loop will not go to the
        // correct branch.  Since the only time we do not complete is
        // when we become active the fall through case works.
        //
        // With the TickActivePeriod, the active flag is set to
        // inactive during the call so we can simply loop w/o a
        // problem.  We could clean this up a bit more but the
        // solution would be too inefficient.
        
        if (!IsActive())
        {
            if (!TickInactivePeriod(l, dblNewParentTime))
            {
                break;
            }

            // We need to force a begin
            bNeedBegin = true;
        }

        if (!TickInstance(l,
                          dblNewParentTime,
                          bNeedBegin))
        {
            break;
        }

        // Make sure to reset the sync times
        ResetSyncTimes();
    }
    
    IGNORE_HR(m_nbList.DispatchTick());

    // Ensure we are completely updated
    m_dblCurrParentTime = dblNewParentTime;

  done:
    // Always reset these values
    
    ResetSyncTimes();
    if (!IsDeferredActive())
    {
        m_bFirstTick = false;
    }
    
    m_bInTick = false;
    
    return;
}

bool
CTIMENode::TickInactivePeriod(CEventList * l,
                              double dblNewParentTime)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickInactivePeriod(%p, %g)",
              this,
              GetID(),
              l,
              dblNewParentTime));

    bool bRet;

    Assert(!IsActive());
    
    TEDirection dir = CalcActiveDirection();
    double dblNextBoundaryTime = GetNextBoundaryParentTime();
    
    if (dblNextBoundaryTime == TIME_INFINITE ||
        (dir == TED_Forward && dblNewParentTime < dblNextBoundaryTime) ||
        (dir == TED_Backward && dblNewParentTime > dblNextBoundaryTime))
    {
        // Indicate we should not continue ticking and update the
        // current parent time to the new parent time
        bRet = false;
        m_dblCurrParentTime = dblNewParentTime;
        goto done;
    }

    // When we are going forward we need to update the boundaries to
    // the next period
    if (dir == TED_Forward)
    {
        double dblBegin;
        CalcNextBeginTime(dblNextBoundaryTime,
                          true,
                          dblBegin);
        
        // Something went wrong and we cannot move backwards
        Assert(dblBegin >= dblNextBoundaryTime);
            
        UpdateNextTickBounds(l,
                             dblBegin,
                             dblNextBoundaryTime);
        UpdateNextBoundaryTime(dblBegin);

        if (dblBegin > dblNextBoundaryTime)
        {
            dblNextBoundaryTime = min(dblBegin, dblNewParentTime);
        }
    }
    else
    {
        // The boundaries in this case have already been updated so we
        // do not need to do anything

        // Indicate we need a first tick
        m_bFirstTick = true;
    }
    
    // Update the current time to the boundary time
    m_dblCurrParentTime = dblNextBoundaryTime;
    
    // Indicate there is more to do
    bRet = true;
  done:
    return bRet;
}

bool
CTIMENode::TickInstance(CEventList * l,
                        double dblNewParentTime,
                        bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickInstance(%p, %g, %d)",
              this,
              GetID(),
              l,
              dblNewParentTime,
              bNeedBegin));

    bool bRet;
    
    double dblLastParentTime = GetCurrParentTime();
    TEDirection dir = CalcActiveDirection();
    bool bNeedShiftUpdate = false;
    
    // This is the time the clock source expects to be at
    double dblAdjustedParentTime;
    
    // Figure out the next parent time to use
    if (TIME_INFINITE != GetSyncNewParentTime())
    {
        dblAdjustedParentTime = GetSyncNewParentTime();

        // Do not reset the sync time yet.  We need to do this in
        // tickactive since we need to get the sync active time 
    }
    else if (GetIsPaused() || GetIsDisabled())
    {
        // Only check if we are paused explicitly.  If our parent has
        // been paused we expect them to handle all adjustments.  It
        // also may be the case that they still provide sync to the
        // clock source when paused so we need to handle all updates

        dblAdjustedParentTime = dblLastParentTime;

        RecalcEndTime(l,
                      dblLastParentTime,
                      dblNewParentTime,
                      true);
    }
    else
    {
        dblAdjustedParentTime = dblNewParentTime;
    }
    
    if (dblAdjustedParentTime != dblNewParentTime)
    {
        bNeedShiftUpdate = true;
    }
    
    if (!TickSingleInstance(l,
                            dblLastParentTime,
                            dblNewParentTime,
                            dblAdjustedParentTime,
                            bNeedBegin))
    {
        bRet = false;
        goto done;
    }
        
    Assert(!IsActive());
        
    // We should be at the end time of the instance
    Assert(GetCurrParentTime() == CalcActiveEndPoint());

    double dblBegin;

    if (GetRestart() != TE_RESTART_NEVER)
    {
        // Now see if there is another begin time to use
        CalcNextBeginTime(GetCurrParentTime(),
                          false,
                          dblBegin);
    }
    else
    {
        dblBegin = TIME_INFINITE;
    }
    
    if (dblBegin == TIME_INFINITE)
    {
        // Indicate that we are finished with all periods
        UpdateNextBoundaryTime(TIME_INFINITE);
        
        m_dblCurrParentTime = dblNewParentTime;
        
        bRet = false;
        goto done;
    }

    Assert((GetParentDirection() == TED_Forward && dblBegin >= GetCurrParentTime()) ||
           (GetParentDirection() == TED_Backward && dblBegin < GetCurrParentTime()));

    if (dir == TED_Forward)
    {
        // Indicate that the next boundary is the begin time
        UpdateNextBoundaryTime(dblBegin);
    }
    else
    {
        // Indicate a shift is not needed since we are causing the
        // update by changing the boundaries
        
        bNeedShiftUpdate = false;
        
        // Update the tick bounds passing the new begin time and the
        // current parent time
        UpdateNextTickBounds(l,
                             dblBegin,
                             GetCurrParentTime());

        // Indicate that the next tick bounds is the end time
        UpdateNextBoundaryTime(GetEndParentTime());
    }

    bRet = true;
  done:

    if (bNeedShiftUpdate)
    {
        // Fire a parent time shift event
        TickEventChildren(l, TE_EVENT_PARENT_TIMESHIFT, 0);
    }
    
    return bRet;
}

bool
CTIMENode::TickSingleInstance(CEventList * l,
                              double dblLastParentTime,
                              double dblNewParentTime,
                              double dblAdjustedParentTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSingleInstance(%p, %g, %g, %g, %d)",
              this,
              GetID(),
              l,
              dblLastParentTime,
              dblNewParentTime,
              dblAdjustedParentTime,
              bNeedBegin));

    bool bRet = false;
    
    bool bTickNeedBegin;
    bool bTickNeedEnd;
    
    // This will check the bounds and ensure the bounds and flags are
    // set correctly
    // This takes the new parent time since the bounds are calculated
    // according to the true time
    if (!::CheckTickBounds(*this,
                           dblLastParentTime,
                           dblNewParentTime,
                           bTickNeedBegin,
                           bTickNeedEnd))
    {
        goto done;
    }

    Assert(dblLastParentTime >= GetBeginParentTime() &&
           dblLastParentTime <= GetEndParentTime());
    Assert(dblNewParentTime >= GetBeginParentTime() &&
           dblNewParentTime <= GetEndParentTime());

    // We need to clamp this since it may be outside our range and we
    // only clamped the new time in the CheckTickBounds call.
    
    dblAdjustedParentTime = Clamp(GetBeginParentTime(),
                                  dblAdjustedParentTime,
                                  GetEndParentTime());
                              
    // We need to calc the new active time
    // Start with the elapsed local time
    double dblNewActiveTime;

    if (TIME_INFINITE != GetSyncActiveTime())
    {
        Assert(TIME_INFINITE != GetSyncNewParentTime());
        
        dblNewActiveTime = GetSyncActiveTime();
    }
    else
    {
        // Need to use the next parent time so we calc the active time for
        // a clock source
        dblNewActiveTime = ::CalcNewTickActiveTime(*this,
                                                   dblLastParentTime,
                                                   dblAdjustedParentTime);
    }
    
    if (TickActive(l,
                   dblNewActiveTime,
                   bNeedBegin || bTickNeedBegin,
                   bTickNeedEnd))
    {
        bRet = true;
    }

    // Update to the new parent time
    m_dblCurrParentTime = dblNewParentTime;
    
    if (m_bNeedSegmentRecalc)
    {
        RecalcSegmentDurChange(l, false, true);

        Assert(!m_bNeedSegmentRecalc);
    }
    else if (bRet &&
             CalcActiveDirection() == TED_Forward &&
             dblNewParentTime != GetEndParentTime())
    {
        UpdateEndTime(l, dblNewParentTime, true);
        UpdateEndSyncTime(dblNewParentTime);

        double dblLastEndSyncTime;
        dblLastEndSyncTime = CalcLastEndSyncTime();
    
        UpdateLastEndSyncTime(l, dblLastEndSyncTime, true);
    }
    
  done:
    return bRet;
}

bool
CTIMENode::TickActive(CEventList * l,
                      double dblNewActiveTime,
                      bool bNeedBegin,
                      bool bNeedEnd)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActive(lt:%g, nt%g, nb:%d, ne:%d, dir%s)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin,
              bNeedEnd,
              DirectionString(CalcActiveDirection())));

    if (bNeedBegin)
    {
        // This means that we just entered

        EventNotify(l,
                    CalcElapsedActiveTime(),
                    TE_EVENT_BEGIN);
    }
        
    PropNotify(l, TE_PROPERTY_TIME | TE_PROPERTY_PROGRESS);

    if (CalcActiveDirection() == TED_Forward)
    {
        if (TickActiveForward(l, dblNewActiveTime, bNeedBegin))
        {
            bNeedEnd = true;
        }
    }
    else
    {
        if (TickActiveBackward(l, dblNewActiveTime, bNeedBegin))
        {
            bNeedEnd = true;
        }
    }

    if (bNeedEnd)
    {
        TickEvent(l,
                  TE_EVENT_END,
                  0);
    }
        
  done:
    return bNeedEnd;
}
    
bool
CTIMENode::TickActiveForward(CEventList * l,
                             double dblNewActiveTime,
                             bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActiveForward(lt:%g, nt%g, nb:%d)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin));
    
    bool bRet = false;

    double dblSegmentBeginTime = GetElapsedActiveRepeatTime();
    double dblActiveDur = CalcEffectiveActiveDur();
    double dblSyncSegmentTime = TIME_INFINITE;

    if (GetSyncSegmentTime() != TIME_INFINITE &&
        GetSyncRepeatCount() == GetCurrRepeatCount() &&
        GetSyncSegmentTime() >= GetCurrSegmentTime())
    {
        dblSyncSegmentTime = GetSyncSegmentTime();
    }
    
    // Now reset the times
    ResetSyncTimes();

    for(;;)
    {
        double dblNewSegmentTime;

        if (dblSyncSegmentTime != TIME_INFINITE)
        {
            dblNewSegmentTime = dblSyncSegmentTime;
            dblSyncSegmentTime = TIME_INFINITE;
        }
        else
        {
            dblNewSegmentTime = dblNewActiveTime - dblSegmentBeginTime;
        }
        
        bool bSegmentEnded;
        
        // This needs to update segment time
        bSegmentEnded = TickSegmentForward(l,
                                           dblSegmentBeginTime,
                                           GetCurrSegmentTime(),
                                           dblNewSegmentTime,
                                           bNeedBegin);

        // Update to the next segment begin time
        dblSegmentBeginTime += GetCurrSegmentTime();
        
        // If the segment did not end or we are at the end of the
        // active duration then break
        
        if (!bSegmentEnded)
        {
            break;
        }
        
        if (dblSegmentBeginTime >= dblActiveDur ||
            m_lCurrRepeatCount + 1 >= CalcRepeatCount())
        {
            bRet = true;
            break;
        }
        
        // Fire the stop event on our children

        TickEventChildren(l,
                          TE_EVENT_END,
                          0);

        m_lCurrRepeatCount++;
        m_dblElapsedActiveRepeatTime = dblSegmentBeginTime;
        m_dblCurrSegmentTime = 0.0;
        
        Assert(m_lCurrRepeatCount < CalcRepeatCount());
            
        PropNotify(l, TE_PROPERTY_REPEATCOUNT);
        
        // Indicate we have just repeated
        EventNotify(l, dblSegmentBeginTime, TE_EVENT_REPEAT, m_lCurrRepeatCount);

        ResetChildren(l, true);
    }
    
  done:
    return bRet;
}

bool
CTIMENode::TickActiveBackward(CEventList * l,
                              double dblNewActiveTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActiveBackward(lt:%g, nt%g, nb:%d)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin));
    
    bool bRet = false;
    
    Assert(dblNewActiveTime >= 0.0);
    
    double dblSegmentBeginTime = GetElapsedActiveRepeatTime();
    double dblSyncSegmentTime = TIME_INFINITE;

    if (GetSyncSegmentTime() != TIME_INFINITE &&
        GetSyncRepeatCount() == GetCurrRepeatCount() &&
        GetSyncSegmentTime() <= GetCurrSegmentTime())
    {
        dblSyncSegmentTime = GetSyncSegmentTime();
    }
    
    // Now reset the times
    ResetSyncTimes();

    for(;;)
    {
        double dblNewSegmentTime;

        if (dblSyncSegmentTime != TIME_INFINITE)
        {
            dblNewSegmentTime = dblSyncSegmentTime;
            dblSyncSegmentTime = TIME_INFINITE;
        }
        else
        {
            dblNewSegmentTime = dblNewActiveTime - dblSegmentBeginTime;
        }
        
        bool bSegmentEnded;
        
        // This needs to update elapsed time and segment time
        bSegmentEnded = TickSegmentBackward(l,
                                            dblSegmentBeginTime,
                                            GetCurrSegmentTime(),
                                            dblNewSegmentTime,
                                            bNeedBegin);
        if (!bSegmentEnded ||
            dblSegmentBeginTime == 0.0)
        {
            break;
        }
        
        // We have reach the end of our current period so all
        // children must be stopped.
        
        // First fire the end event so they can pass it on
        // to the parent
        
        TickEventChildren(l,
                          TE_EVENT_END,
                          0);

        double dblSegmentDur;
        dblSegmentDur = CalcCurrSegmentDur();
        
        if (dblSegmentDur == TIME_INFINITE)
        {
            dblSegmentDur = dblSegmentBeginTime;
        }
        
        m_dblElapsedActiveRepeatTime = dblSegmentBeginTime - dblSegmentDur;

        if (m_dblElapsedActiveRepeatTime < 0.0)
        {
            m_dblElapsedActiveRepeatTime = 0.0;
        }

        m_lCurrRepeatCount--;
        m_dblCurrSegmentTime = dblSegmentDur;
        
        Assert(m_lCurrRepeatCount >= 0);
            
        PropNotify(l, TE_PROPERTY_REPEATCOUNT);

        // Indicate we have just repeated
        EventNotify(l, dblSegmentBeginTime, TE_EVENT_REPEAT, m_lCurrRepeatCount);

        ResetChildren(l, true);

        // We do this late so we can use the correct time in the
        // EventNotify all above
        dblSegmentBeginTime = m_dblElapsedActiveRepeatTime;
    }

  done:
    return bRet;
}

//+-----------------------------------------------------------------------
//
//  Function:  TickSegmentForward
//
//  Overview:  This will tick the segment forward.  It must update
//  segment time
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------


bool
CTIMENode::TickSegmentForward(CEventList * l,
                              double dblActiveSegmentBound,
                              double dblLastSegmentTime,
                              double dblNewSegmentTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSegmentForward(tsb:%g, lt:%g, ct:%g, np:%d)",
              this,
              GetID(),
              dblActiveSegmentBound,
              dblLastSegmentTime,
              dblNewSegmentTime,
              bNeedBegin));

    bool bRet = false;

    Assert(CalcActiveDirection() == TED_Forward);
    Assert(dblLastSegmentTime >= 0.0);
    Assert(dblLastSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime >= 0.0);
    Assert(dblNewSegmentTime >= dblLastSegmentTime);

    // Make sure the new time is less than the segment duration so our
    // calculations become easier
    
    if (dblNewSegmentTime > GetSegmentDur())
    {
        dblNewSegmentTime = GetSegmentDur();
    }
    
    if (dblLastSegmentTime < GetSimpleDur())
    {
        double dblNewSimpleTime = min(dblNewSegmentTime,
                                      GetSimpleDur()); //lint !e666
        
        TickChildren(l,
                     dblNewSimpleTime,
                     bNeedBegin);

        // We need to update the segment time so that the direction
        // flag is queried by our children correctly
        m_dblCurrSegmentTime = dblNewSimpleTime;
    }

    if (GetAutoReverse() &&
        dblNewSegmentTime >= GetSimpleDur())
    {
        Assert(GetSimpleDur() != TIME_INFINITE);
        Assert(GetSegmentDur() != TIME_INFINITE);
        Assert(GetCurrSegmentTime() >= GetSimpleDur());
        
        // True is we either passed the boundary point this time or if
        // we were on the boundary and had a needplay
        bool bOnBoundary = ((dblLastSegmentTime < GetSimpleDur()) ||
                            ((dblLastSegmentTime == GetSimpleDur()) &&
                             bNeedBegin));
        
        // If we did not pass the segment time last time then this
        // time we need to fire an autoreverse event
        if (bOnBoundary)
        {
            // Tell our children to stop
            TickEventChildren(l,
                              TE_EVENT_END,
                              0);

            // Indicate we have just repeated
            EventNotify(l,
                        dblActiveSegmentBound + GetSimpleDur(),
                        TE_EVENT_AUTOREVERSE);

            ResetChildren(l, true);
        }

        TickChildren(l,
                     GetSegmentDur() - dblNewSegmentTime,
                     bNeedBegin || bOnBoundary);
    }

    // Do this after the child tick so endsync will work correctly

    {
        double dblSegmentDur = CalcCurrSegmentDur();
        
        // Make sure the new time is less than the segment duration so our
        // calculations become easier
    
        if (dblNewSegmentTime >= dblSegmentDur)
        {
            dblNewSegmentTime = dblSegmentDur;
            bRet = true;
        }
    }
    
    // Update our segment time
    m_dblCurrSegmentTime = dblNewSegmentTime;

  done:
    return bRet;
}

//+-----------------------------------------------------------------------
//
//  Function:  TickSegmentBackward
//
//  Overview:  This will tick the segment backwards.  It must update
//  segment time
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------

bool
CTIMENode::TickSegmentBackward(CEventList * l,
                               double dblActiveSegmentBound,
                               double dblLastSegmentTime,
                               double dblNewSegmentTime,
                               bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSegmentBackward(tsb:%g, lt:%g, ct:%g, np:%d)",
              this,
              GetID(),
              dblActiveSegmentBound,
              dblLastSegmentTime,
              dblNewSegmentTime,
              bNeedBegin));

    bool bRet = false;
    
    Assert(CalcActiveDirection() == TED_Backward);
    Assert(dblLastSegmentTime >= 0.0);
    Assert(dblLastSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime <= dblLastSegmentTime);

    // Make sure the new time is greater than 0 so our calculations
    // become easier
    
    if (dblNewSegmentTime <= 0.0)
    {
        dblNewSegmentTime = 0.0;
        bRet = true;
    }
    
    if (GetAutoReverse() &&
        dblLastSegmentTime > GetSimpleDur())
    {
        Assert(GetSimpleDur() != TIME_INFINITE);
        Assert(GetSegmentDur() != TIME_INFINITE);
        
        double dblNewMaxSegmentTime = max(dblNewSegmentTime, GetSimpleDur()); //lint !e666
        
        TickChildren(l,
                     GetSegmentDur() - dblNewMaxSegmentTime,
                     bNeedBegin);

        // We need to update the segment time so that the direction
        // flag is queried by our children correctly
        m_dblCurrSegmentTime = dblNewMaxSegmentTime;
        
        if (dblNewSegmentTime <= GetSimpleDur())
        {
            // Tell our children to stop
            TickEventChildren(l,
                              TE_EVENT_END,
                              0);

            // Indicate we have just repeated
            EventNotify(l,
                        dblActiveSegmentBound + GetSimpleDur(),
                        TE_EVENT_AUTOREVERSE);

            ResetChildren(l, true);
        }
    }
                
    if (dblNewSegmentTime <= GetSimpleDur())
    {
        // This should have been updated
        Assert(GetCurrSegmentTime() <= GetSimpleDur());
        Assert(dblNewSegmentTime <= GetCurrSegmentTime());

        TickChildren(l,
                     dblNewSegmentTime,
                     bNeedBegin);
    }

    // Update our segment time
    m_dblCurrSegmentTime = dblNewSegmentTime;

  done:
    return bRet;
}

void
CTIMENode::TickChildren(CEventList * l,
                        double dblNewSegmentTime,
                        bool bNeedPlay)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\tickevent.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tickevent.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTickEvent, "TIME: Engine", "Tick Event")

void
CTIMENode::TickEvent(CEventList * l,
                     TE_EVENT_TYPE et,
                     DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMENode(%lx,%ls)::TickEvent(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    ResetSyncTimes();

    if (!TickEventPre(l, et, dwFlags))
    {
        goto done;
    }
    
    TickEventChildren(l, et, dwFlags);
    
    if (!TickEventPost(l, et, dwFlags))
    {
        goto done;
    }

  done:
    return;
}

// This is in our local time space
bool
CTIMENode::TickEventPre(CEventList * l,
                        TE_EVENT_TYPE et,
                        DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMENode(%lx,%ls)::TickEventPre(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    bool bRet;
    bool bFireEvent = false;
    
    switch(et)
    {
      case TE_EVENT_BEGIN:
        if (IsActive() && m_bFirstTick)
        {
            // If we are on the begin boundary delay until we are no
            // longer sync cueing
            // TODO: Consider adding a fudge factor to the ==
            // comparison since we may be a little off and still want
            // to hold as if we were on the begin boundary
            if ((IsSyncCueing() || IsDeferredActive()) &&
                GetCurrParentTime() == CalcActiveBeginPoint())
            {
                bRet = false;
                goto done;
            }
        
            Assert(GetCurrParentTime() != -TIME_INFINITE);
            bFireEvent = true;
        }
        
        break;
      case TE_EVENT_END:
        // If we are active and it is the first tick then we never
        // fired the begin so fire it now
        if (IsActive() && IsFirstTick())
        {
            // If we are not going to fire the begin then we should
            // not fire the end
            // Use the same logic we use for the begin above
            if ((IsSyncCueing() || IsDeferredActive()) &&
                GetCurrParentTime() == CalcActiveBeginPoint())
            {
                bRet = false;
                goto done;
            }
            
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
        }
        
        break;
      case TE_EVENT_PAUSE:
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        if (GetIsPaused())
        {
            bRet = false;
            goto done;
        }
        
        PropNotify(l, TE_PROPERTY_ISCURRPAUSED);

        bFireEvent = true;

        break;
      case TE_EVENT_RESUME:
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        if (GetIsPaused())
        {
            bRet = false;
            goto done;
        }

        PropNotify(l, TE_PROPERTY_ISCURRPAUSED);

        break;
      case TE_EVENT_DISABLE:
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        if (GetIsDisabled())
        {
            bRet = false;
            goto done;
        }
        
        PropNotify(l, TE_PROPERTY_ISCURRDISABLED);

        bFireEvent = true;

        break;
      case TE_EVENT_ENABLE:
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        if (GetIsDisabled())
        {
            bRet = false;
            goto done;
        }

        PropNotify(l, TE_PROPERTY_ISCURRDISABLED);

        break;
      case TE_EVENT_SEEK:
        HandleSeekUpdate(l);
        bFireEvent = true;
        break;
      case TE_EVENT_PARENT_TIMESHIFT:
        HandleTimeShift(l);
        bFireEvent = true;
        break;
      default:
        break;
    }
    
    if (bFireEvent)
    {
        EventNotify(l, CalcElapsedActiveTime(), et);
    }

    bRet = true;
  done:
    return bRet;
}

// This is in our local time space
bool
CTIMENode::TickEventPost(CEventList * l,
                         TE_EVENT_TYPE et,
                         DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx,%ls)::TickEventPost(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    bool bRet;
    bool bFireEvent = false;
    
    switch(et)
    {
      case TE_EVENT_BEGIN:

        m_bFirstTick = false;

        break;
      case TE_EVENT_END:
        if (IsActive())
        {
            Assert(GetCurrParentTime() != -TIME_INFINITE);
            Assert(!IsFirstTick());
        
            if ((dwFlags & TE_EVENT_INCHILD) != 0)
            {
                m_bEndedByParent = true;
            }
            
            bFireEvent = true;
        }

        // This is dependent on our parent and so if our parent ends
        // then we need to reevaluate
        PropNotify(l, TE_PROPERTY_ISON);
        
        m_bFirstTick = false;
        
        break;
      case TE_EVENT_RESUME:
        bFireEvent = true;

        break;
      case TE_EVENT_ENABLE:
        bFireEvent = true;

        break;
      default:
        break;
    }
    
    if (bFireEvent)
    {
        EventNotify(l, CalcElapsedActiveTime(), et);
    }

    bRet = true;
  done:
    return bRet;
}

void
CTIMEContainer::TickEventChildren(CEventList * l,
                                  TE_EVENT_TYPE et,
                                  DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMEContainer(%lx,%ls)::TickEventChildren(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));
    
    for (TIMENodeList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        (*i)->TickEvent(l,
                        et,
                        dwFlags | TE_EVENT_INCHILD);
    }
        
  done:
    return;
}

void
CTIMENode::TickEventChildren(CEventList * l,
                             TE_EVENT_TYPE et,
                             DWORD dwFlags)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\sync.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: sync.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"
#include "container.h"

DeclareTag(tagClockSync, "TIME: Engine", "CTIMENode Sync");
DeclareTag(tagWatchClockSync, "TIME: Engine", "Watch Sync");

//
// This is different from CalcParentTimeFromGlobalTime because it
// takes into account when a parent has reach its end point
// inclusively and returns TIME_INFINITE to indicate that a parent is
// ending
//

double
CalcSyncParentTimeFromGlobalTime(CTIMENode & tn,
                                 double dblGlobalTime)
{
    TraceTag((tagClockSync,
              "CalcParentTimeFromGlobalTime(%p, %ls, %g)",
              &tn,
              tn.GetID(),
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (tn.GetParent() != NULL)
    {
        dblRet = CalcSyncParentTimeFromGlobalTime(*tn.GetParent(),
                                                  dblRet);
        if (dblRet >= tn.GetParent()->GetEndParentTime())
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        dblRet = tn.GetParent()->CalcActiveTimeFromParentTime(dblRet);
        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = tn.GetParent()->CalcSegmentTimeFromActiveTime(dblRet,
                                                               true);
        dblRet = tn.GetParent()->SegmentTimeToSimpleTime(dblRet);
    }
    
  done:
    return dblRet;
}

HRESULT
CTIMENode::OnBvrCB(CEventList * l,
                   double dblNextGlobalTime)
{
    TraceTag((tagClockSync,
              "CTIMENode(%p, %ls)::OnBvrCB(%#l, %g)",
              this,
              GetID(),
              l,
              dblNextGlobalTime));

    HRESULT hr;

    double dblNewSegmentTime;
    long lNewRepeatCount;
    bool bCueing;

    Assert(IsSyncMaster());

    if (CalcIsDisabled())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(DispatchGetSyncTime(dblNewSegmentTime,
                                 lNewRepeatCount,
                                 bCueing));
    if (S_OK != hr)
    {
        goto done;
    }

    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::OnBvrCB(%g):DispatchSync: last(%g, %d) new(%g, %d)",
              this,
              GetID(),
              dblNextGlobalTime,
              m_dblCurrSegmentTime,
              m_lCurrRepeatCount,
              dblNewSegmentTime,
              lNewRepeatCount));
    
    if (!IsActive())
    {
        double dblNextParentTime = CalcSyncParentTimeFromGlobalTime(*this,
                                                                    dblNextGlobalTime);
        double dblLastParentTime = GetCurrParentTime();
        
        bool bTurningOn = false;
        
        // Need to detect if we are transitioning to being active this
        // tick
        // If not then do not respect the sync call
        if (TIME_INFINITE == dblNextParentTime)
        {
            bTurningOn = false;
        }
        else if (CalcActiveDirection() == TED_Forward)
        {
            bTurningOn = (dblNextParentTime >= GetBeginParentTime() &&
                          dblLastParentTime < GetBeginParentTime());
        }
        else
        {
            bTurningOn = (dblNextParentTime <= GetEndParentTime() &&
                          dblLastParentTime > GetEndParentTime());
        }

        if (!bTurningOn)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = THR(SyncNode(l,
                      dblNextGlobalTime,
                      dblNewSegmentTime,
                      lNewRepeatCount,
                      bCueing));
    if (S_OK != hr)
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
} // OnBvrCB

HRESULT
CTIMENode::SyncNode(CEventList * l,
                    double dblNextGlobalTime,
                    double dblNewSegmentTime,
                    LONG lNewRepeatCount,
                    bool bCueing)
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::SyncNode(%p, %g, %g, %ld, %d)",
              this,
              GetID(),
              l,
              dblNextGlobalTime,
              dblNewSegmentTime,
              lNewRepeatCount,
              bCueing));

    HRESULT hr;
    
    // Now we need to check the sync times for validity
    hr = THR(CheckSyncTimes(dblNewSegmentTime, lNewRepeatCount));
    if (S_OK != hr)
    {
        goto done;
    }
    
    Assert(dblNewSegmentTime != TIME_INFINITE);

    double dblNewActiveTime;
    dblNewActiveTime = CalcNewActiveTime(dblNewSegmentTime,
                                         lNewRepeatCount);
    
    double dblNewParentTime;
    dblNewParentTime = CalcParentTimeFromActiveTime(dblNewActiveTime);

    Assert(dblNewParentTime != TIME_INFINITE);

    // HACK HACK - This is to work around major precision problems
    // when walking up the time tree.  This will add a little fudge to
    // it to avoid truncation problems.
    
    {
        double dblTruncatedActiveTime = CalcActiveTimeFromParentTime(dblNewParentTime);
        if (dblTruncatedActiveTime < dblNewActiveTime)
        {
            dblNewParentTime += 1e-15;

            // This means we got here twice and we should add a little more
            if (dblNewParentTime == m_dblCurrParentTime)
            {
                dblNewParentTime += 1e-15;
            }
        }
    }
    
    double dblNextParentTime;

    if (IsLocked())
    {
        if (GetParent())
        {
            double dblParentSegmentTime;
            dblParentSegmentTime = GetParent()->SimpleTimeToSegmentTime(dblNewParentTime);

            hr = THR(GetParent()->SyncNode(l,
                                           dblNextGlobalTime,
                                           dblParentSegmentTime,
                                           TE_UNDEFINED_VALUE,
                                           bCueing));

            if (S_OK != hr)
            {
                goto done;
            }

            dblNextParentTime = dblNewParentTime;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        dblNextParentTime = CalcSyncParentTimeFromGlobalTime(*this,
                                                             dblNextGlobalTime);
    }
    
    // If this is infinite then we are going to pass a repeat or
    // reverse boundary and no matter what we do it will not matter
    if (dblNextParentTime == TIME_INFINITE)
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = THR(SetSyncTimes(dblNewSegmentTime,
                          lNewRepeatCount,
                          dblNewActiveTime,
                          dblNewParentTime,
                          dblNextParentTime,
                          bCueing));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // We actually need to force a update to our children's time
    // sync since the global relationship changed
    RecalcCurrEndTime(l, true);
    
    hr = S_OK;
  done:
    RRETURN2(hr, S_FALSE, E_FAIL);
}

HRESULT
CTIMENode::CheckSyncTimes(double & dblNewSegmentTime,
                          LONG & lNewRepeatCount) const
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::CTIMENode(%g,%d)",
              this,
              GetID(),
              dblNewSegmentTime,
              lNewRepeatCount));

    HRESULT hr;
    double dblSegmentDur = CalcCurrSegmentDur();

    if (dblNewSegmentTime == TIME_INFINITE ||
        dblNewSegmentTime == TE_UNDEFINED_VALUE)
    {
        // This means that we should have ended.  Ignore this and
        // assume that we will be told to stop using the end method
        
        // This also could have meant that the current repeat segment
        // ended and the repeat count is unknown - so again just
        // ignore this call
        
        hr = S_FALSE;
        goto done;
    }

    // Now update the repeat count - making sure to validate
    // everything
    
    if (lNewRepeatCount == TE_UNDEFINED_VALUE)
    {
        lNewRepeatCount = GetCurrRepeatCount();
    }
    else if (lNewRepeatCount != GetCurrRepeatCount())
    {
        if (CalcActiveDirection() == TED_Forward)
        {
            if (lNewRepeatCount < GetCurrRepeatCount())
            {
                lNewRepeatCount = GetCurrRepeatCount();
            }
            else if (lNewRepeatCount > long(CalcRepeatCount()))
            {
                lNewRepeatCount = long(CalcRepeatCount());
            }
        }
        else
        {
            if (lNewRepeatCount > GetCurrRepeatCount())
            {
                lNewRepeatCount = GetCurrRepeatCount();
            }
            else if (lNewRepeatCount < 0)
            {
                lNewRepeatCount = 0;
            }
        }
    }

    if (dblNewSegmentTime != GetCurrSegmentTime())
    {
        bool bNewRepeat = (lNewRepeatCount != GetCurrRepeatCount());

        if (bNewRepeat)
        {
            if (dblNewSegmentTime < 0.0)
            {
                dblNewSegmentTime = 0.0;
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                dblNewSegmentTime = dblSegmentDur;
            }
        }
        else if (CalcActiveDirection() == TED_Forward)
        {
            if (dblNewSegmentTime < GetCurrSegmentTime())
            {
                dblNewSegmentTime = GetCurrSegmentTime();
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                dblNewSegmentTime = dblSegmentDur;
            }
        }
        else
        {
            if (dblNewSegmentTime > GetCurrSegmentTime())
            {
                dblNewSegmentTime = GetCurrSegmentTime();
            }
            else if (dblNewSegmentTime < 0.0)
            {
                dblNewSegmentTime = 0.0;
            }
        }
    }
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMENode::SetSyncTimes(double dblNewSegmentTime,
                        LONG lNewRepeatCount,
                        double dblNewActiveTime,
                        double dblNewParentTime,
                        double dblNextParentTime,
                        bool bCueing)
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::SetSyncTimes(%g,%d,%g, %g,%g,%d)",
              this,
              GetID(),
              dblNewSegmentTime,
              lNewRepeatCount,
              dblNewActiveTime,
              dblNewParentTime,
              dblNextParentTime,
              bCueing));

    // Init to S_OK and if we find anything invalid return S_FALSE
    
    HRESULT hr = S_OK;
    double dblSegmentDur = CalcCurrSegmentDur();
    TEDirection ted = CalcActiveDirection();
    double dblActiveDur = CalcEffectiveActiveDur();
    
    m_bSyncCueing = bCueing;
    
    Assert(dblNewSegmentTime != TIME_INFINITE);
    Assert(dblNewSegmentTime != TE_UNDEFINED_VALUE);
    
    m_dblSyncParentTime = dblNextParentTime;
    m_dblSyncNewParentTime = dblNewParentTime;

    // Now update the repeat count - making sure to validate
    // everything
    
    // Init to current repeat count in case there is an invalidate
    // repeat count
    m_lSyncRepeatCount = GetCurrRepeatCount();

    if (lNewRepeatCount != TE_UNDEFINED_VALUE &&
        lNewRepeatCount != GetCurrRepeatCount())
    {
        if (ted == TED_Forward)
        {
            if (lNewRepeatCount < GetCurrRepeatCount())
            {
                hr = S_FALSE;
                Assert(m_lSyncRepeatCount == GetCurrRepeatCount());
            }
            else if (lNewRepeatCount > long(CalcRepeatCount()))
            {
                hr = S_FALSE;
                m_lSyncRepeatCount = long(CalcRepeatCount());
            }
            else
            {
                m_lSyncRepeatCount = lNewRepeatCount;
            }
        }
        else
        {
            if (lNewRepeatCount > GetCurrRepeatCount())
            {
                hr = S_FALSE;
                Assert(m_lSyncRepeatCount == GetCurrRepeatCount());
            }
            else if (lNewRepeatCount < 0)
            {
                hr = S_FALSE;
                m_lSyncRepeatCount = 0;
            }
            else
            {
                m_lSyncRepeatCount = lNewRepeatCount;
            }
        }
    }

    // Init to current segment time in case the new segment time is
    // invalid
    m_dblSyncSegmentTime = GetCurrSegmentTime();

    if (dblNewSegmentTime != GetCurrSegmentTime())
    {
        bool bNewRepeat = GetSyncRepeatCount() != GetCurrRepeatCount();

        if (bNewRepeat)
        {
            if (dblNewSegmentTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = 0.0;
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = dblSegmentDur;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
        else if (ted == TED_Forward)
        {
            if (dblNewSegmentTime < GetCurrSegmentTime())
            {
                hr = S_FALSE;
                Assert(m_dblSyncSegmentTime == GetCurrSegmentTime());
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = dblSegmentDur;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
        else
        {
            if (dblNewSegmentTime > GetCurrSegmentTime())
            {
                hr = S_FALSE;
                Assert(m_dblSyncSegmentTime == GetCurrSegmentTime());
            }
            else if (dblNewSegmentTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = 0.0;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
    }
    
    // Init to current active time in case the new active time is
    // invalid
    m_dblSyncActiveTime = CalcElapsedActiveTime();

    if (dblNewActiveTime != m_dblSyncActiveTime)
    {
        if (ted == TED_Forward)
        {
            if (dblNewActiveTime < m_dblSyncActiveTime)
            {
                hr = S_FALSE;
                Assert(m_dblSyncActiveTime == CalcElapsedActiveTime());
            }
            else if (dblNewActiveTime > dblActiveDur)
            {
                hr = S_FALSE;
                m_dblSyncActiveTime = dblActiveDur;
            }
            else
            {
                m_dblSyncActiveTime = dblNewActiveTime;
            }
        }
        else
        {
            if (dblNewActiveTime > m_dblSyncActiveTime)
            {
                hr = S_FALSE;
                Assert(m_dblSyncActiveTime == CalcElapsedActiveTime());
            }
            else if (dblNewActiveTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncActiveTime = 0.0;
            }
            else
            {
                m_dblSyncActiveTime = dblNewActiveTime;
            }
        }
    }
    
  done:
    RRETURN1(hr, S_FALSE);
}

void
CTIMENode::ResetSyncTimes()
{
    TraceTag((tagClockSync,
              "CTIMENode(%p, %ls)::ResetSyncTimes()",
              this,
              GetID()));

    m_dblSyncSegmentTime = TIME_INFINITE;
    m_lSyncRepeatCount = TE_UNDEFINED_VALUE;
    m_dblSyncActiveTime = TIME_INFINITE;
    m_dblSyncParentTime = TIME_INFINITE;
    m_dblSyncNewParentTime = TIME_INFINITE;
    m_bSyncCueing = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>


//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TimeScale.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCALEPLAYER                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\timebase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timebase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEBASE_H
#define _TIMEBASE_H

#pragma once

typedef std::set<double> DoubleSet;

class CEventList;

#define TS_TIMESHIFT 0x00000001

interface ITimeSink
{
    virtual void Update(CEventList * l, DWORD dwFlags) = 0;
};

class TimeSinkList
{
  public:
    TimeSinkList();
    ~TimeSinkList();

    HRESULT Add(ITimeSink *);
    void Remove(ITimeSink *);

    void Update(CEventList * l, DWORD dwFlags);
  protected:
    typedef std::list<ITimeSink *> ITimeSinkList;
    
    ITimeSinkList m_sinkList;
};

class ISyncArc
{
  public:
    virtual ~ISyncArc() {}
        
    virtual HRESULT Attach() = 0;
    virtual void Detach() = 0;

    virtual double GetCurrTimeBase() const = 0;
    virtual bool IsLongSyncArc() const = 0;
};

class CTIMENode;

typedef std::map<long, ISyncArc *> SyncArcList;

class CSyncArcList
{
  public:
    CSyncArcList(CTIMENode & tn, bool bBeginSink);
    ~CSyncArcList();

    HRESULT Add(ISyncArc & tb, bool bOneShot, long * plCookie);
    // Returns whether the cookie was found
    // If bDelete is set then the object is deleted and not just
    // removed
    bool Remove(long lCookie, bool bDelete);
    ISyncArc * Find(long lCookie);

    // This will reset all the one shot timers
    // Returns true if anything was cleared
    bool Reset();
    
    // Returns true if anything was cleared
    bool Clear();

    HRESULT Attach();
    void Detach();

    void Update(CEventList * l,
                ISyncArc & ptb);

    CTIMENode & GetNode() const { return m_tn; }

    double LowerBound(double dblTime,
                      bool bInclusive,
                      bool bStrict,
                      bool bIncludeOneShot,
                      bool bOneShotInclusive) const;
    double UpperBound(double dblTime,
                      bool bInclusive,
                      bool bStrict,
                      bool bIncludeOneShot,
                      bool bOneShotInclusive) const;
    void GetBounds(double dblTime,
                   bool bInclusive,
                   bool bStrict,
                   bool bIncludeOneShot,
                   bool bOneShotInclusive,
                   double * pdblLower,
                   double * pdblUpper) const;

    void GetSortedSet(DoubleSet & ds,
                      bool bIncludeOneShot);

    // Returns true if any were updated
    bool UpdateFromLongSyncArcs(CEventList * l);
  protected:
    CSyncArcList();
    
    CTIMENode &  m_tn;
    bool         m_bBeginSink;
    SyncArcList  m_tbList;
    SyncArcList  m_tbOneShotList;
    long         m_lLastCookie;
    bool         m_bAttached;
};

class CSyncArcOffset
    : public ISyncArc
{
  public:
    CSyncArcOffset(double dblOffset) : m_dblOffset(dblOffset) {}
    
    // ISyncArc
    
    HRESULT Attach() { return S_OK; }
    void Detach() {}
    double GetCurrTimeBase() const { return m_dblOffset; }
    bool IsLongSyncArc() const { return false; }

    double GetOffset() const { return m_dblOffset; }
  protected:
    CSyncArcOffset();
    double m_dblOffset;
};

class CSyncArcTimeBase
    : public ITimeSink,
      public ISyncArc
{
  public:
    CSyncArcTimeBase(CSyncArcList & tbl,
                     CTIMENode & ptnBase,
                     TE_TIMEPOINT tetpBase,
                     double dblOffset);
    ~CSyncArcTimeBase();
        
    // ITIMESink 
    void Update(CEventList * l, DWORD dwFlags);

    // ISyncArc
    HRESULT Attach();
    void Detach();
    double GetCurrTimeBase() const;
    bool IsLongSyncArc() const;

  protected:
    CSyncArcTimeBase();
    CSyncArcList &       m_tbl;
    DAComPtr<CTIMENode>  m_ptnBase;
    TE_TIMEPOINT         m_tetpBase;
    double               m_dblOffset;

#if DBG
    bool                 m_bAttached;
#endif
};

inline double
CSyncArcList::LowerBound(double dblTime,
                         bool bInclusive,
                         bool bStrict,
                         bool bIncludeOneShot,
                         bool bOneShotInclusive) const
{
    double dblLower;

    GetBounds(dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive,
              &dblLower,
              NULL);

    return dblLower;
}

inline double
CSyncArcList::UpperBound(double dblTime,
                         bool bInclusive,
                         bool bStrict,
                         bool bIncludeOneShot,
                         bool bOneShotInclusive) const
{
    double dblUpper;

    GetBounds(dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive,
              NULL,
              &dblUpper);

    return dblUpper;
}

#endif /* _TIMEBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\timebase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timebase.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMESink, "TIME: Engine", "TIMESink methods");

TimeSinkList::TimeSinkList()
{
}

TimeSinkList::~TimeSinkList()
{
    // The add does not do a addref so we do not need to clean up
    // anything

    Assert(m_sinkList.size() == 0);
}

HRESULT
TimeSinkList::Add(ITimeSink * sink)
{
    Assert(sink != NULL);
    // TODO: Handle out of memory
    m_sinkList.push_back(sink);
    return S_OK;
}

void
TimeSinkList::Remove(ITimeSink * sink)
{
    Assert(sink != NULL);
    m_sinkList.remove(sink);
}

void
TimeSinkList::Update(CEventList * l, DWORD dwFlags)
{
    for (ITimeSinkList::iterator i = m_sinkList.begin(); 
         i != m_sinkList.end(); 
         i++)
    {
        (*i)->Update(l, dwFlags);
    }
    
  done:
    return;
}

// =======================
// CTimeBase
// =======================

DeclareTag(tagTimeBase, "TIME: Engine", "CTimeBase methods");

CSyncArcTimeBase::CSyncArcTimeBase(CSyncArcList & tbl,
                                   CTIMENode & ptnBase,
                                   TE_TIMEPOINT tetpBase,
                                   double dblOffset)
: m_tbl(tbl),
  m_ptnBase(&ptnBase),
  m_tetpBase(tetpBase),
  m_dblOffset(dblOffset)
{
#if DBG
    m_bAttached = false;
#endif

    Assert(tetpBase == TE_TIMEPOINT_BEGIN ||
           tetpBase == TE_TIMEPOINT_END);
}
    
CSyncArcTimeBase::~CSyncArcTimeBase()
{
#if DBG
    Assert(!m_bAttached);
#endif
}

HRESULT
CSyncArcTimeBase::Attach()
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Attach()",
              this));
    
    HRESULT hr;
    
    Assert(!m_bAttached);

    switch(m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        hr = m_ptnBase->AddBeginTimeSink(this);
        if (FAILED(hr))
        {
            goto done;
        }

        break;
      case TE_TIMEPOINT_END:
        hr = m_ptnBase->AddEndTimeSink(this);
        if (FAILED(hr))
        {
            goto done;
        }

        break;
      default:
        AssertSz(false, "Invalid time point specified");
        break;
    }

#if DBG
    m_bAttached = true;
#endif
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
}

void
CSyncArcTimeBase::Detach()
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Detach()",
              this));
    
    Assert(!m_bAttached || m_tbl.GetNode().IsReady());
    
    switch (m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        m_ptnBase->RemoveBeginTimeSink(this);

        break;
      case TE_TIMEPOINT_END:
        m_ptnBase->RemoveEndTimeSink(this);

        break;
      default:
        AssertSz(false, "Invalid begin time point specified");
        break;
    }

#if DBG
    m_bAttached = false;
#endif

  done:
    return;
}

void
CSyncArcTimeBase::Update(CEventList * l, DWORD dwFlags)
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Update(%p, %x)",
              this,
              l,
              dwFlags));
    
    // We better have been attached or we are in trouble
    Assert(m_bAttached);

    // We should not have been attached if the node is not ready
    Assert(m_tbl.GetNode().IsReady());
    
    // If this is a timeshift and we are not a long sync arc then
    // ignore the update
    if ((dwFlags & TS_TIMESHIFT) != 0 &&
        !IsLongSyncArc())
    {
        goto done;
    }
    
    m_tbl.Update(l, *this);
    
  done:
    return;
}

double
ConvertLongSyncArc(double dblTime,
                   CTIMENode & ptnFrom,
                   CTIMENode & ptnTo)
{
    TraceTag((tagTimeBase,
              "ConvertLongSyncArc(%g, %p, %p)",
              dblTime,
              &ptnFrom,
              &ptnTo));

    double dblRet = dblTime;

    dblRet = ptnFrom.CalcGlobalTimeFromParentTime(dblRet);

    if (dblRet == TIME_INFINITE)
    {
        goto done;
    }
    
    dblRet = ptnTo.CalcParentTimeFromGlobalTimeForSyncArc(dblRet);
    
  done:
    return dblRet;
}

double
CSyncArcTimeBase::GetCurrTimeBase() const
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::GetCurrTimeBase()",
              this));
    
    double dblTime = TIME_INFINITE;
    
    if (!m_tbl.GetNode().IsReady())
    {
        goto done;
    }
    
    switch (m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        dblTime = m_ptnBase->GetBeginParentTime();

        break;
      case TE_TIMEPOINT_END:
        dblTime = m_ptnBase->GetEndParentTime();

        break;
      case TE_TIMEPOINT_NONE:
      default:
        AssertSz(false, "Invalid begin time point specified");
        break;
    }

    if (IsLongSyncArc())
    {
        dblTime = ConvertLongSyncArc(dblTime, *m_ptnBase, m_tbl.GetNode());
    }
    
    // Make sure we add the offset after the conversion since it is in
    // our local time space and not the syncarc's.
    
    dblTime += m_dblOffset;
    
  done:
    return dblTime;
}

bool
CSyncArcTimeBase::IsLongSyncArc() const
{
    Assert(m_tbl.GetNode().IsReady());
    Assert(m_ptnBase);
    
    return (m_ptnBase->GetParent() != m_tbl.GetNode().GetParent());
}



CSyncArcList::CSyncArcList(CTIMENode & tn,
                                     bool bBeginSink)
: m_tn(tn),
  m_bBeginSink(bBeginSink),
  m_lLastCookie(0),
  m_bAttached(false)
{
}
    
CSyncArcList::~CSyncArcList()
{
    Assert(!m_bAttached);

    Clear();
}

HRESULT
CSyncArcList::Attach()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Attach()",
              this));
    
    HRESULT hr;
    
    Assert(!m_bAttached);
    
    // If we are not ready then we need to delay doing this
    Assert(m_tn.IsReady());
    
    SyncArcList::iterator i;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        hr = THR((*i).second->Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        hr = THR((*i).second->Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_bAttached = true;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
}

void
CSyncArcList::Detach()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Detach()",
              this));
    
    SyncArcList::iterator i;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        (*i).second->Detach();
    }
    
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
    }
    
    m_bAttached = false;

  done:
    return;
}

HRESULT
CSyncArcList::Add(ISyncArc & tb,
                  bool bOneShot,
                  long * plCookie)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Add(%p, %d)",
              this,
              &tb,
              bOneShot));

    HRESULT hr;
    bool bAdded;
    SyncArcList & salList = bOneShot?m_tbOneShotList:m_tbList;

    if (plCookie != NULL)
    {
        *plCookie = 0;
    }

    if (m_bAttached)
    {
        hr = THR(tb.Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    // Pre-increment
    ++m_lLastCookie;
    
    // @@ ISSUE : Memory failure not detected

    bAdded = salList.insert(SyncArcList::value_type(m_lLastCookie, &tb)).second;

    if (!bAdded)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (plCookie != NULL)
    {
        *plCookie = m_lLastCookie;
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        tb.Detach();
    }
    
    RRETURN1(hr, E_FAIL);
}

bool
CSyncArcList::Remove(long lCookie, bool bDelete)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Remove(%#x, %d)",
              this,
              lCookie,
              bDelete));

    bool bRet = false;
    
    SyncArcList::iterator i;

    i = m_tbList.find(lCookie);

    if (i != m_tbList.end())
    {
        bRet = true;
        
        (*i).second->Detach();
        
        if (bDelete)
        {
            delete (*i).second;
        }

        m_tbList.erase(i);
    }
    else
    {
        i = m_tbOneShotList.find(lCookie);
        
        if (i != m_tbOneShotList.end())
        {
            bRet = true;
            
            (*i).second->Detach();
            
            if (bDelete)
            {
                delete (*i).second;
            }
            
            m_tbOneShotList.erase(i);
        }
    }

  done:
    return bRet;
}

ISyncArc *
CSyncArcList::Find(long lCookie)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Find(%#x)",
              this,
              lCookie));

    ISyncArc * ret = NULL;
    
    SyncArcList::iterator i;

    i = m_tbList.find(lCookie);

    if (i != m_tbList.end())
    {
        ret = (*i).second;
    }
    else
    {
        i = m_tbOneShotList.find(lCookie);

        if (i != m_tbOneShotList.end())
        {
            ret = (*i).second;
        }
    }

  done:
    return ret;
}

bool
CSyncArcList::Clear()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Clear()",
              this));

    SyncArcList::iterator i;
    
    if (m_tbList.size() == 0 && m_tbOneShotList.size() == 0)
    {
        return false;
    }
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbList.clear();

    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbOneShotList.clear();

    return true;
}

bool
CSyncArcList::Reset()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Reset()",
              this));

    SyncArcList::iterator i;
    bool bRet = (m_tbOneShotList.size() > 0);

    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbOneShotList.clear();

    return bRet;
}

void
CSyncArcList::Update(CEventList * l,
                     ISyncArc & tb)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Update(%p, %p)",
              this,
              l,
              &tb));
    
    // We better have been attached or we are in trouble
    Assert(m_bAttached);

    // We should not have been attached if the node is not ready
    Assert(m_tn.IsReady());
    
    m_tn.SyncArcUpdate(l,
                       m_bBeginSink,
                       tb);
    
  done:
    return;
}

void
CSyncArcList::GetBounds(double dblTime,
                        bool bInclusive,
                        bool bStrict,
                        bool bIncludeOneShot,
                        bool bOneShotInclusive,
                        double * pdblLower,
                        double * pdblUpper) const
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::GetBounds(%g, %d, %d, %d, %d)",
              this,
              dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive));

    double l;
    double u;
    
    SyncArcList::iterator i;

    if (m_tbList.size() == 0 && (
        m_tbOneShotList.size() == 0 ||
        !bIncludeOneShot))
    {
        l = TIME_INFINITE;
        u = TIME_INFINITE;

        goto done;
    }

    l = TIME_INFINITE;
    u = -TIME_INFINITE;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        double t = (*i).second->GetCurrTimeBase();

        if (bInclusive && t == dblTime)
        {
            l = t;
            u = t;
            goto done;
        }
        
        if (l < dblTime)
        {
            if (t > l && t < dblTime)
            {
                l = t;
            }
        }
        else
        {
            if (t < l)
            {
                l = t;
            }
        }

        if (u > dblTime)
        {
            if (t < u && t > dblTime)
            {
                u = t;
            }
        }
        else
        {
            if (t > u)
            {
                u = t;
            }
        }
    }

    if (bIncludeOneShot)
    {
        for (i = m_tbOneShotList.begin();
             i != m_tbOneShotList.end();
             i++)
        {
            double t = (*i).second->GetCurrTimeBase();

            if (bOneShotInclusive && t == dblTime)
            {
                l = t;
                u = t;
                goto done;
            }
        
            if (l < dblTime)
            {
                if (t > l && t < dblTime)
                {
                    l = t;
                }
            }
            else
            {
                if (t < l)
                {
                    l = t;
                }
            }

            if (u > dblTime)
            {
                if (t < u && t > dblTime)
                {
                    u = t;
                }
            }
            else
            {
                if (t > u)
                {
                    u = t;
                }
            }
        }
    }
    
    if (bStrict)
    {
        if (l > dblTime || (l == dblTime && !bInclusive))
        {
            l = TIME_INFINITE;
        }

        if (u < dblTime || (u == dblTime && !bInclusive))
        {
            u = TIME_INFINITE;
        }
    }

    Assert(u != -TIME_INFINITE);
    
  done:
    if (NULL != pdblLower)
    {
        *pdblLower = l;
    }

    if (NULL != pdblUpper)
    {
        *pdblUpper = u;
    }
}

void
CSyncArcList::GetSortedSet(DoubleSet & ds,
                           bool bIncludeOneShot)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::GetSortedSet(%p, %d)",
              this,
              &ds,
              bIncludeOneShot));

    SyncArcList::iterator i;

    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        double t = (*i).second->GetCurrTimeBase();

        ds.insert(t);
    }
    
    if (bIncludeOneShot)
    {
        for (i = m_tbOneShotList.begin();
             i != m_tbOneShotList.end();
             i++)
        {
            double t = (*i).second->GetCurrTimeBase();
            
            ds.insert(t);
        }
    }
}

bool
CSyncArcList::UpdateFromLongSyncArcs(CEventList * l)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::UpdateFromLongSyncArcs(%p)",
              this,
              l));

    bool bRet = false;
    
    SyncArcList::iterator i;

    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        if ((*i).second->IsLongSyncArc())
        {
            bRet = true;
            Update(l, *(*i).second);
        }
    }
    
    // TODO: Currently these cannot be sync arcs so we could just not
    // make the call
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        if ((*i).second->IsLongSyncArc())
        {
            bRet = true;
            Update(l, *(*i).second);
        }
    }

  done:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\timeconv.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timeconv.cpp
//
//  Contents: implementation of CTIMENode time conversions
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "container.h"

DeclareTag(tagTIMENodeConv, "TIME: Engine", "CTIMENode time conversion methods");

double
CTIMENode::CalcNewActiveTime(double dblNewSegmentTime,
                             LONG lNewRepeatCount)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcNewActiveTime(%g, %ld)",
              this,
              dblNewSegmentTime,
              lNewRepeatCount));

    double dblRet = GetElapsedActiveRepeatTime();
    double dblSegmentDur = CalcCurrSegmentDur();
    long lRepeatDiff = lNewRepeatCount - GetCurrRepeatCount();
    
    Assert(dblNewSegmentTime <= dblSegmentDur);
    Assert(dblNewSegmentTime >= 0.0);
    Assert(lNewRepeatCount < CalcRepeatCount());
    Assert(lNewRepeatCount >= 0);
    
    // If we do not have a known duration then we cannot update
    // elapsed time
    if (dblSegmentDur != TIME_INFINITE)
    {
        dblRet += lRepeatDiff * dblSegmentDur;
    }

    dblRet += dblNewSegmentTime;

    dblRet = Clamp(0.0, dblRet, CalcEffectiveActiveDur());
    
    return dblRet;
}

void
CTIMENode::CalcActiveComponents(double dblActiveTime,
                                double & dblSegmentTime,
                                long & lRepeatCount)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveComponents(%g)",
              this,
              dblActiveTime));
    
    double dblSegmentDur = CalcCurrSegmentDur();
    
    dblActiveTime = Clamp(0.0,
                          dblActiveTime,
                          CalcCurrActiveDur());
                         
    if (dblSegmentDur == TIME_INFINITE)
    {
        lRepeatCount = 0;
        dblSegmentTime = dblActiveTime;
    }
    else
    {
        // First calc how many times we have repeated
        lRepeatCount = long(dblActiveTime / dblSegmentDur);
            
        if (lRepeatCount >= CalcRepeatCount())
        {
            lRepeatCount = ceil(CalcRepeatCount()) - 1;
        }
        
        dblSegmentTime = dblActiveTime - (lRepeatCount * dblSegmentDur);

        dblSegmentTime = Clamp(0.0,
                               dblSegmentTime,
                               dblSegmentDur);
    }
}

double
CTIMENode::CalcActiveTimeFromParentTimeNoBounds(double dblParentTime) const
{
    double dblCurrParentTime, dblRet;
    dblCurrParentTime = Clamp(GetBeginParentTime(),
                              GetCurrParentTime(),
                              GetEndParentTime());
    
    double dblDelta;
    dblDelta = dblParentTime - dblCurrParentTime;

    // How figure out if we need to reverse it and change the sign
    if (GetDirection() == TED_Backward)
    {
        dblDelta *= -1.0;
    }

    double dblNewActiveTime;

    // Now get the elapsed local time
    dblNewActiveTime = CalcElapsedLocalTime();
    
    // Add the delta
    dblNewActiveTime += dblDelta;

    // Now transform it back
    dblNewActiveTime = ApplyActiveTimeTransform(dblNewActiveTime);

    dblNewActiveTime = Clamp(0.0,
                             dblNewActiveTime,
                             CalcEffectiveActiveDur());
    
    dblRet = dblNewActiveTime;
  done:
    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromParentTime(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = TIME_INFINITE;
    
    if (dblParentTime < GetBeginParentTime() ||
        dblParentTime > GetEndParentTime() ||
        GetCurrParentTime() == -TIME_INFINITE)
    {
        goto done;
    }

    dblRet = CalcActiveTimeFromParentTimeNoBounds(dblParentTime);
done:
    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromParentTimeForSyncArc(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = TIME_INFINITE;
    
    if ((dblParentTime < GetBeginParentTime()) || (dblParentTime > GetEndParentTime()))
    {
        dblRet = dblParentTime - GetBeginParentTime();
        goto done;
    }
    
    dblRet = CalcActiveTimeFromParentTimeNoBounds(dblParentTime);
done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromActiveTime(double dblActiveTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromActiveTime(%g)",
              this,
              dblActiveTime));

    double dblRet = TIME_INFINITE;
    
    if (GetBeginParentTime() == TIME_INFINITE ||
        GetCurrParentTime() == -TIME_INFINITE)
    {
        goto done;
    }
    
    double dblDelta;
    dblDelta = Clamp(0.0,
                     dblActiveTime,
                     CalcEffectiveActiveDur());

    dblDelta = ReverseActiveTimeTransform(dblDelta);
    
    dblDelta -= CalcElapsedLocalTime();

    // How figure out if we need to reverse it and change the sign
    if (GetDirection() == TED_Backward)
    {
        dblDelta *= -1.0;
    }

    double dblNewParentTime;
    dblNewParentTime = Clamp(GetBeginParentTime(),
                             GetCurrParentTime(),
                             GetEndParentTime());
    
    // Add the delta
    dblNewParentTime += dblDelta;

    dblRet = dblNewParentTime;
  done:
    return dblRet;
}

double
CTIMENode::ActiveTimeToLocalTime(double dblActiveTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::ActiveTimeToLocalTime(%g)",
              this,
              dblActiveTime));

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());

    // First reverse the time transform
    dblRet = ReverseActiveTimeTransform(dblRet);
    
    // Now we need to deal with the direction
    // If we are moving backwards then we need to treat parent
    // movements the opposite way
    if (TEIsBackward(GetDirection()))
    {
        double dblLocalDur = CalcLocalDur();

        // For now just assume 0
        if (dblLocalDur == TIME_INFINITE)
        {
            dblRet = 0;
        }
        else
        {
            dblRet = dblLocalDur - dblRet;
        }
    }
    
    Assert(dblRet >= 0.0);
    Assert(dblRet <= CalcLocalDur());
    
    return dblRet;
}

double
CTIMENode::LocalTimeToActiveTime(double dblLocalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::LocalTimeToActiveTime(%g)",
              this,
              dblLocalTime));

    double dblLocalDur = CalcLocalDur();
    double dblRet = Clamp(0.0,
                          dblLocalTime,
                          dblLocalDur);

    // Now we need to deal with the direction
    // If we are moving backwards then we need to treat parent
    // movements the opposite way
    if (TEIsBackward(GetDirection()))
    {
        // For now just assume 0
        if (dblLocalDur == TIME_INFINITE)
        {
            dblRet = 0;
        }
        else
        {
            dblRet = dblLocalDur - dblRet;
        }
    }
    
    // Now we need to apply the time transform
    dblRet = ApplyActiveTimeTransform(dblRet);
    
    dblRet = Clamp(0.0,
                   dblRet,
                   CalcEffectiveActiveDur());

    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromSegmentTime(double dblSegmentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromSegmentTime(%g)",
              this,
              dblSegmentTime));

    double dblRet = Clamp(0.0,
                          dblSegmentTime,
                          CalcCurrSegmentDur());

    dblRet += GetElapsedActiveRepeatTime();

    dblRet = Clamp(0.0,
                   dblRet,
                   CalcEffectiveActiveDur());

    return dblRet;
}

double
CTIMENode::CalcSegmentTimeFromActiveTime(double dblActiveTime, bool bTruncate) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcSegmentTimeFromActiveTime(%g, %d)",
              this,
              dblActiveTime,
              bTruncate));

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());
    double dblSegmentDur = CalcCurrSegmentDur();
    
    if (dblSegmentDur == TIME_INFINITE)
    {
        if (dblRet >= GetElapsedActiveRepeatTime())
        {
            dblRet -= GetElapsedActiveRepeatTime();
        }
    }
    else
    {
        dblRet -= GetElapsedActiveRepeatTime();
        if (bTruncate)
        {
            dblRet = Clamp(0.0,
                           dblRet,
                           dblSegmentDur);
        }
        else
        {
            double dblTemp = dblRet;
            dblRet = dblRet - (long(dblRet / dblSegmentDur) * dblSegmentDur);

            if (dblRet < 0 || (dblRet == 0 && dblTemp == dblSegmentDur))
            {
                dblRet += dblSegmentDur;
            }
        }
    }
    
    Assert(dblRet <= CalcCurrSegmentDur());
    Assert(dblRet >= 0.0);
    
    dblRet = Clamp(0.0,
                   dblRet,
                   dblSegmentDur);
    
    return dblRet;
}

double
CTIMENode::SegmentTimeToSimpleTime(double segmentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::SegmentTimeToSimpleTime(%g)",
              this,
              segmentTime));

    double dblRet = segmentTime;
    
    Assert(dblRet <= CalcCurrSegmentDur());
    Assert(dblRet >= 0.0);
    
    if (IsAutoReversing(dblRet))
    {
        Assert(dblRet <= GetSegmentDur());
        dblRet = GetSegmentDur() - dblRet;
    }

    // if the speed is negative and the segment contains an 
    // autoreverse, then this transformation needs to be shifted
    // but the SimpleDuration to give the correct value.  
    if (GetSpeed() < 0.0 && GetAutoReverse())   
    {                                           
        dblRet = fabs(dblRet - GetSimpleDur()); 
    }                                           

    dblRet = ApplySimpleTimeTransform(dblRet);

    return dblRet;
}

double
CTIMENode::SimpleTimeToSegmentTime(double simpleTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::SimpleTimeToSegmentTime(%g)",
              this,
              simpleTime));

    double dblRet = simpleTime;

    dblRet = ReverseSimpleTimeTransform(dblRet);
    
    // See if the current segment was reversing and make sure we
    // adjust the simple time appropriately
    if (IsAutoReversing(GetCurrSegmentTime()))
    {
        dblRet = GetSegmentDur() - dblRet;
    }
    
    return dblRet;
}

double
CTIMENode::CalcGlobalTimeFromParentTime(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcGlobalTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = Clamp(GetBeginParentTime(),
                          dblParentTime,
                          GetEndParentTime());

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->SimpleTimeToSegmentTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromSegmentTime(dblRet);
        dblRet = GetParent()->CalcParentTimeFromActiveTime(dblRet);

        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = GetParent()->CalcGlobalTimeFromParentTime(dblRet);
    }
    
  done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromGlobalTime(double dblGlobalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromGlobalTime(%g)",
              this,
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->CalcParentTimeFromGlobalTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromParentTime(dblRet);
        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = GetParent()->CalcSegmentTimeFromActiveTime(dblRet, false);
        dblRet = GetParent()->SegmentTimeToSimpleTime(dblRet);
    }
    
  done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromGlobalTimeForSyncArc(double dblGlobalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromGlobalTime(%g)",
              this,
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->CalcParentTimeFromGlobalTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromParentTimeForSyncArc(dblRet);

    }
    
  done:
    return dblRet;
}

// ---------------------------------------
// COM Methods
// ---------------------------------------

STDMETHODIMP
CTIMENode::parentTimeToActiveTime(double dblParentTime,
                                  double * pdblActiveTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::parentTimeToActiveTime(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    double dblRet = dblParentTime;

    CHECK_RETURN_NULL(pdblActiveTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcActiveTimeFromParentTime(dblRet);
    
    *pdblActiveTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::activeTimeToParentTime(double dblActiveTime,
                                  double * pdblParentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::activeTimeToParentTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    double dblRet = dblActiveTime;
    
    CHECK_RETURN_NULL(pdblParentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcParentTimeFromActiveTime(dblRet);
    
    *pdblParentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::parentTimeToDocumentTime(double dblParentTime,
                                  double * pdblDocumentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::parentTimeToDocumentTime(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    double dblRet = dblParentTime;

    CHECK_RETURN_NULL(pdblDocumentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcGlobalTimeFromParentTime(dblRet);
    
    *pdblDocumentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::documentTimeToParentTime(double dblDocumentTime,
                                  double * pdblParentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::documentTimeToParentTime(%g)",
              this,
              dblDocumentTime));

    HRESULT hr;
    double dblRet = dblDocumentTime;
    
    CHECK_RETURN_NULL(pdblParentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcParentTimeFromGlobalTime(dblRet);
    
    *pdblParentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::activeTimeToSegmentTime(double dblActiveTime,
                                   double * pdblSegmentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::activeTimeToSegmentTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());
    
    CHECK_RETURN_NULL(pdblSegmentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcSegmentTimeFromActiveTime(dblRet, false);
    
    *pdblSegmentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::segmentTimeToActiveTime(double dblSegmentTime,
                                   double * pdblActiveTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::segmentTimeToActiveTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;

    double dblRet = Clamp(0.0,
                          dblSegmentTime,
                          CalcCurrSegmentDur());
    
    CHECK_RETURN_NULL(pdblActiveTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcActiveTimeFromSegmentTime(dblRet);
    
    *pdblActiveTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::simpleTimeToSegmentTime(double dblSimpleTime,
                                   double * pdblSegmentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::simpleTimeToSegmentTime(%g)",
              this,
              dblSimpleTime));

    HRESULT hr;
    double dblRet = dblSimpleTime;

    CHECK_RETURN_NULL(pdblSegmentTime);
    
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = SimpleTimeToSegmentTime(dblRet);
    
    *pdblSegmentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::segmentTimeToSimpleTime(double dblSegmentTime,
                                   double * pdblSimpleTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::segmentTimeToSimpleTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    double dblRet = dblSegmentTime;

    CHECK_RETURN_NULL(pdblSimpleTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = SegmentTimeToSimpleTime(dblRet);
    
    *pdblSimpleTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\scaleplayer.h ===
#pragma once
#include "shlwrap.h"

#include "resource.h"       // main symbols
#include <mstime.h>


/////////////////////////////////////////////////////////////////////////////
// CScalePlayer
class ATL_NO_VTABLE CScalePlayer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CScalePlayer, &CLSID_ScalePlayer>,
    public CComControl<CScalePlayer>,
	public IDispatchImpl<ITIMEScalePlayer, &IID_ITIMEScalePlayer, &LIBID_TIMESCALELib>,
    public IOleObjectImpl<CScalePlayer>,
    public IOleInPlaceObjectWindowlessImpl<CScalePlayer>,
    public IViewObjectExImpl<CScalePlayer>,
    public IConnectionPointContainerImpl<CScalePlayer>,
    public IPropertyNotifySinkCP<CScalePlayer>,
    public IPropertyNotifySink,
    public IRunnableObject,
    public ITIMEMediaPlayerControl,
    public ITIMEMediaPlayer
{
protected:
    DWORD m_dwLastRefTime;
    double m_dblTime;
    double m_dblNaturalDur;
    DWORD m_dwLastDLRefTime;
    double m_dblDLTime;
    double m_dblDLDur;
    bool m_fDoneDL;
    double m_dblScaleFactor;
    bool m_fSuspended;
    bool m_fMediaReady;
    bool m_fRunning;
    double m_dblMediaDur;
    CComBSTR m_bstrSrc;
    HWND m_pwndMsgWindow;

    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;
    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    RECT m_rectSize;
    COLORREF m_clrKey;
    bool m_fInPlaceActivated;
    DWORD m_dwPropCookie;
    
public:
	CScalePlayer();

    //
    // ITIMEMediaPlayer
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;


    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_customObject)(IDispatch ** disp);

    STDMETHOD(tick)(void);


    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(get_src)(BSTR* pbstrURL);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);

    STDMETHOD(getControl)(IUnknown ** control);

    //
    // ITIMEScalePlayer
    //
    STDMETHOD(get_scaleFactor)(double* pdblScaleFactor);
    STDMETHOD(put_scaleFactor)(double dblScaleFactor);
    STDMETHOD(get_playerTime)(double* pdblTime);
    STDMETHOD(pausePlayer)();
    STDMETHOD(resumePlayer)();
    STDMETHOD(invalidate)();
    STDMETHOD(get_playDuration)(double* pdblDuration);
    STDMETHOD(put_playDuration)(double dblDuration);
    STDMETHOD(get_downLoadDuration)(double* pdblDuration);
    STDMETHOD(put_downLoadDuration)(double dblDuration);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    // IRunnableObject
    STDMETHOD(GetRunningClass)(LPCLSID lpClsid);
    STDMETHOD(Run)(LPBC lpbc);
    STDMETHOD_(BOOL, IsRunning)();
    STDMETHOD(LockRunning)(BOOL fLock, BOOL fLastUnlockCloses);
    STDMETHOD(SetContainedObject)(BOOL fContained);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
 
    HRESULT STDMETHODCALLTYPE Draw( 
            DWORD dwDrawAspect,
            LONG lindex,
            void *pvAspect,
            DVTARGETDEVICE *ptd,
            HDC hdcTargetDev,
            HDC hdcDraw,
            LPCRECTL lprcBounds,
            LPCRECTL lprcWBounds,
            BOOL ( * pfnContinue)(DWORD dwContinue),
            DWORD dwContinue);
 

DECLARE_REGISTRY_RESOURCEID(IDR_SCALEPLAYER)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CScalePlayer)
	COM_INTERFACE_ENTRY(ITIMEScalePlayer)
	COM_INTERFACE_ENTRY(IDispatch)
	//COM_INTERFACE_ENTRY(IViewObject2)
	//COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY2(IViewObject2, IViewObjectExImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY2(IViewObject, IViewObjectExImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY2(IOleInPlaceObject, IOleInPlaceObjectWindowlessImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
	COM_INTERFACE_ENTRY(IRunnableObject)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CScalePlayer)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

BEGIN_MSG_MAP(CScalePlayer)
END_MSG_MAP()

private:

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    void DeinitPropSink();
    HRESULT CreateMessageWindow();
    void computeTime(double* pdblCurrentTime);
    void initDownloadTime();
    void updateDownloadTime();
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// IScalePlayer
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timeeng\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LCID_SCRIPTING,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) MemAlloc(Mt(Mem), size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    CComPtr<IOleContainer> pRoot;
    CComPtr<IHTMLDocument> pHTMLDoc;
    CComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    CComPtr<IDABehavior> event;
    CComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LCID_SCRIPTING,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LCID_SCRIPTING, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\scaleplayer.cpp ===
// ScalePlayer.cpp : Implementation of CScalePlayer
#include "stdafx.h"
#include "TimeScale.h"
#include "ScalePlayer.h"
#include <math.h>
#include <shlwapi.h>

#define ID_TIMER 1
#define TIMER_INT 100

WCHAR gPauseStateString[] = L"State: Paused";
WCHAR gRunnigStateString[] = L"State: Running";
WCHAR gInactiveStateString[] = L"State: Not active";


/////////////////////////////////////////////////////////////////////////////
// CScalePlayer

CScalePlayer::CScalePlayer() :
    m_dwLastRefTime(0),
    m_dblTime(0.0),
    m_dblNaturalDur(5.0),
    m_fDoneDL(false),
    m_dblScaleFactor(1.0),
    m_fSuspended(false),
    m_fMediaReady(false),
    m_fRunning(false),
    m_bstrSrc(),
    m_fInPlaceActivated(false),
    m_pwndMsgWindow(NULL),
    m_dblMediaDur(HUGE_VAL),
    m_dwLastDLRefTime(0),
    m_dblDLTime(0.0),
    m_dblDLDur(2.0)

{
    double pdblCurrentTime;
    m_clrKey = RGB(0xff, 0x00, 0x00);
    m_rectSize.top = m_rectSize.left = 0;
    m_rectSize.bottom = m_rectSize.right= 400;
    m_fSuspended    = false;
    m_fRunning = true;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;
}

//
// ITIMEMediaPlayer
//
STDMETHODIMP CScalePlayer::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;

    if(m_pwndMsgWindow == NULL)
    {
        hr = CreateMessageWindow();
    }

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }
    InitPropSink();

done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::Detach(void)
{
    ::KillTimer(m_pwndMsgWindow, ID_TIMER);
    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    DeinitPropSink();

    return S_OK;
}

STDMETHODIMP CScalePlayer::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::begin(void)
{
    OutputDebugString(L"CScalePlayer::begin\n");
    float flTeSpeed = 0.0;
    HRESULT hr;

    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }
    if(flTeSpeed < 0)
    {
        goto done;
    }

    m_fSuspended    = false;
    m_fRunning = true;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;
    m_clrKey = RGB(0xff, 0x00, 0x00);

done:
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}

STDMETHODIMP CScalePlayer::end(void)
{
    OutputDebugString(L"CScalePlayer::end\n");
    m_fSuspended = true;
    m_fRunning = false;
    m_dblTime    = -HUGE_VAL;
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}

STDMETHODIMP CScalePlayer::resume(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();

    m_clrKey = RGB(0xff, 0x00, 0x00);
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}

STDMETHODIMP CScalePlayer::pause(void)
{
    m_fSuspended = true;

    m_clrKey = RGB(0x00, 0x00, 0xff);
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}


STDMETHODIMP CScalePlayer::resumePlayer(void)
{
    return resume();
}

STDMETHODIMP CScalePlayer::pausePlayer(void)
{
    return pause();
}

STDMETHODIMP CScalePlayer::invalidate(void)
{
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}

STDMETHODIMP CScalePlayer::reset(void)
{
    OutputDebugString(L"CScalePlayer::reset\n");
    HRESULT hr = S_OK;
    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;

    if(!m_fInPlaceActivated)
    {
        goto done;
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (flTeSpeed <= 0.0)
    {
        hr = S_OK;
        pause();
        goto done;
    }
    if (m_dblScaleFactor != flTeSpeed)
    {
        put_scaleFactor((double)flTeSpeed);
    }


    if( !m_fRunning)
    {
        begin(); // add a seek after this

        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        pause();
    }
    else
    {
        resume();
    }
done:
    return hr;
}

STDMETHODIMP CScalePlayer::repeat(void)
{
    OutputDebugString(L"CScalePlayer::repeat\n");
    return begin();
}


STDMETHODIMP CScalePlayer::seek(double dblSeekTime)
{
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = dblSeekTime;
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}


STDMETHODIMP CScalePlayer::tick(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::put_CurrentTime(double   dblCurrentTime)
{
    m_dblTime = dblCurrentTime;
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    if(!m_fRunning)
    {
        *pdblCurrentTime = -HUGE_VAL;
        hr = S_FALSE;
        goto done;
    }

    computeTime(pdblCurrentTime);

    if(*pdblCurrentTime == m_dblNaturalDur)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

void
CScalePlayer::computeTime(double* pdblCurrentTime)
{
    updateDownloadTime();


    if(m_dblDLTime < m_dblDLDur)
    {
        m_dwLastRefTime = timeGetTime();
        m_dblTime = 0.0;
        goto done;
    }

    if (!m_fSuspended)
    {
        DWORD   dwNow;
        long    lDiff;

        dwNow   = timeGetTime();
        lDiff   = dwNow - m_dwLastRefTime;
        m_dwLastRefTime = dwNow;

        if (lDiff < 0)
        {
            lDiff = -lDiff;
        }

        m_dblTime += (lDiff / 1000.0) * m_dblScaleFactor;
        if(m_dblTime > m_dblNaturalDur)
        {
            m_dblTime = m_dblNaturalDur;
        }
    }
done:
    *pdblCurrentTime = m_dblTime;
}

void
CScalePlayer::initDownloadTime()
{
    m_dwLastDLRefTime = timeGetTime();
    m_dblDLTime = 0.0;
}

void
CScalePlayer::updateDownloadTime()
{
    DWORD dwCurrDLTime = timeGetTime();
    double dblNewDLTime;

    dblNewDLTime = (dwCurrDLTime - m_dwLastDLRefTime) / 1000.0;

    if( m_dblDLTime + dblNewDLTime > m_dblDLDur)
    {
        if(!m_fDoneDL)
        {
            m_fDoneDL = true;
            if(m_spOleInPlaceSite)
            {
                m_spOleInPlaceSite->OnPosRectChange(&m_rectSize);
            }
            NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
            m_dblDLTime = m_dblDLDur;
        }
        goto done;
    }

    m_dwLastDLRefTime = dwCurrDLTime;
    m_dblDLTime += dblNewDLTime;
done:
    return;
}

STDMETHODIMP CScalePlayer::put_src(BSTR   bstrURL)
{
    m_bstrSrc = bstrURL;
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_src(BSTR* pbstrURL)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pbstrURL, sizeof(BSTR)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pbstrURL = m_bstrSrc.Copy();
    if (NULL == *pbstrURL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_repeat(long   lTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_repeat(long* plTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(plTime, sizeof(long*)))
    {
        hr = E_POINTER;
        goto done;
    }

    *plTime = 1;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::cue(void)
{
    return E_NOTIMPL;
}


//
// ITIMEScalePlayer
//
STDMETHODIMP CScalePlayer::get_scaleFactor(double* pdblScaleFactor)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblScaleFactor, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblScaleFactor = m_dblScaleFactor;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_scaleFactor(double dblScaleFactor)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblScaleFactor <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    computeTime(&dblTime);
    m_dblScaleFactor = dblScaleFactor;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_playDuration(double* pdblDuration)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblDuration, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblDuration = m_dblNaturalDur;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_playDuration(double dblDuration)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblDuration <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    //NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    m_dblNaturalDur = dblDuration;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_downLoadDuration(double* pdblDuration)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblDuration, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblDuration = m_dblDLDur;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_downLoadDuration(double dblDuration)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblDuration <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    //NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    m_dblDLDur = dblDuration;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_playerTime(double* pdblTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    if(!m_fRunning)
    {
        *pdblTime = -HUGE_VAL;
        hr = S_FALSE;
        goto done;
    }

    computeTime(pdblTime);

    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP CScalePlayer::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if(pdbl == NULL)
    {
        goto done;
    }

    *pdbl = m_dblNaturalDur;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if(pdbl == NULL)
    {
        goto done;
    }

    *pdbl = m_dblNaturalDur;

done:
    return hr;
}


STDMETHODIMP CScalePlayer::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }
    *pl = m_rectSize.bottom - m_rectSize.top;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }

    *pl = m_rectSize.right - m_rectSize.left;
done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;
    if(ppdisp == NULL)
    {
        goto done;
    }

    hr = this->QueryInterface(IID_IDispatch, (void **)ppdisp);

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    if(state == NULL)
    {
        goto done;
    }

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    if(plist == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = QueryInterface(IID_IUnknown, (void **)control);

    return hr;
}

STDMETHODIMP CScalePlayer::GetRunningClass(LPCLSID lpClsid)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}

STDMETHODIMP CScalePlayer::Run(LPBC lpbc)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP_(BOOL)
CScalePlayer::IsRunning(void)
{
    return TRUE;
} // AddRef


STDMETHODIMP CScalePlayer::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}


STDMETHODIMP CScalePlayer::SetContainedObject(BOOL fContained)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}


// If the client site is changed then an init call must ne made.
STDMETHODIMP CScalePlayer::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto done;
    }
    
done:
    return hr;
}

STDMETHODIMP CScalePlayer::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    HRESULT hr = S_OK;

    m_rectSize.bottom = lprcPosRect->bottom;
    m_rectSize.top = lprcPosRect->top;
    m_rectSize.left = lprcPosRect->left;
    m_rectSize.right = lprcPosRect->right;

    return hr;
}

STDMETHODIMP CScalePlayer::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT hr = S_OK;
    BOOL fNoRedraw;

    if(iVerb != OLEIVERB_INPLACEACTIVATE)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    if(m_spOleInPlaceSite != NULL)
    {
        if(!m_fInPlaceActivated)
        {
            if(m_spOleInPlaceSiteWindowless)
            {
                m_spOleInPlaceSiteWindowless->OnInPlaceActivateEx(&fNoRedraw, ACTIVATE_WINDOWLESS);
            }
            else
            {
                m_spOleInPlaceSite->OnInPlaceActivate();
            }
        }

        initDownloadTime();
    }
    m_fInPlaceActivated = true;


done:
    return hr;
}

HRESULT
CScalePlayer::Draw( 
            DWORD dwDrawAspect,
            LONG lindex,
            void *pvAspect,
            DVTARGETDEVICE *ptd,
            HDC hdcTargetDev,
            HDC hdcDraw,
            LPCRECTL lprcBounds,
            LPCRECTL lprcWBounds,
            BOOL ( * pfnContinue)(DWORD dwContinue),
            DWORD dwContinue)

{
    HRESULT hr = S_OK;
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);
    RECT rect;
    WCHAR buffer[50];
    int dec;
    unsigned short frac;
    double pdblCurrentTime;
    VARIANT var;
    SIZE txtSize;
    WCHAR *pStateString;

    VariantInit(&var);

    if(!m_fDoneDL)
    {
        goto done;
    }

    if(lprcBounds == NULL)
    {
        rect.bottom = m_rectSize.bottom;
        rect.top = m_rectSize.top;
        rect.left = m_rectSize.left;
        rect.right = m_rectSize.right;
    }
    else
    {
        rect.bottom = lprcBounds->bottom;
        rect.top = lprcBounds->top;
        rect.left = lprcBounds->left;
        rect.right = lprcBounds->right;
    }

    if (hbr)
    {

        ::FillRect(hdcDraw, &rect, hbr);
        ::DeleteObject(hbr);
    }

    var.vt = VT_R8;
    var.dblVal = m_dblTime;

    hr = VariantChangeType(&var, &var, 0, VT_BSTR);
    if(!GetTextExtentPoint32W( hdcDraw, var.bstrVal, wcslen(var.bstrVal), &txtSize))
    {
        goto done;
    }

    if( (txtSize.cx + 10 <= rect.right - rect.left) &&
        (txtSize.cy + 10 <= rect.bottom - rect.top))
    {
        TextOutW(hdcDraw, rect.left + 10, rect.top + 10, var.bstrVal, wcslen(var.bstrVal));
    }


    if(m_fRunning && !m_fSuspended)
    {
        pStateString = gRunnigStateString;
    }
    else if(m_fRunning && m_fSuspended)
    {
        pStateString = gPauseStateString;
    }
    else
    {
        pStateString = gInactiveStateString;
    }

    if(!GetTextExtentPoint32W( hdcDraw, pStateString, wcslen(pStateString), &txtSize))
    {
        goto done;
    }

    if( (txtSize.cx + 10 <= rect.right - rect.left) &&
        (txtSize.cy + 25 <= rect.bottom - rect.top))
    {
        TextOutW(hdcDraw, rect.left + 10, rect.top + 25, pStateString, wcslen(pStateString));
    }

done:

    VariantClear(&var);
    return hr;
}

HRESULT
CScalePlayer::CreateMessageWindow()
{
    static const TCHAR szClassName[] = TEXT("ScalePlayerWindow");
    HRESULT hr = S_OK;

    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);

    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpszClassName = szClassName;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = _Module.GetModuleInstance();

    (void)::RegisterClassEx(&wc);

    m_pwndMsgWindow = CreateWindow(
    szClassName,
    _T("VRCtlWindow"),
    0, 0, 0, 0, 0,
    (HWND)NULL, (HMENU)NULL,
    _Module.GetModuleInstance(),
    this);
    if ( m_pwndMsgWindow == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    ::SetTimer(m_pwndMsgWindow, ID_TIMER, TIMER_INT, NULL);
done:
    return hr;
}

LRESULT CALLBACK
CScalePlayer::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CScalePlayer *lpThis;
    double pdblCurrentTime;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);

            //lpThis = (CScalePlayer *)lpcs->lpCreateParams;
            return 0;
        }
    case WM_TIMER:
        {
            //check GetWindowLongPtr for 64 bit comp.
            lpThis = (CScalePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis != NULL)
            {
                if(!(lpThis->m_fInPlaceActivated))
                {
                    return 0;
                }
                if(lpThis->m_spOleInPlaceSiteWindowless && !(lpThis->m_fSuspended) && (lpThis->m_fRunning))
                {
                    lpThis->computeTime(&pdblCurrentTime);
                    lpThis->m_spOleInPlaceSiteWindowless->InvalidateRect(&(lpThis->m_rectSize),TRUE);
                }
            }
            return 0;
        }
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

HRESULT 
CScalePlayer::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


HRESULT
CScalePlayer::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

STDMETHODIMP
CScalePlayer::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CScalePlayer::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause();
                break;
            }
            if (m_dblScaleFactor != flTeSpeed)
            {
                put_scaleFactor((double)flTeSpeed);
            }
            break;
        default:
            break;
    }
done:
    return S_OK;
}

HRESULT
CScalePlayer::InitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void
CScalePlayer::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED_)
#define AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "shlwrap.h"

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\timescal\timescale.cpp ===
// TimeScale.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TimeScaleps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TimeScale.h"

#include "TimeScale_i.c"
#include "ScalePlayer.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ScalePlayer, CScalePlayer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transmap.h ===
#ifndef _TRANSMAP_H__
#define _TRANSMAP_H__

#pragma once

HRESULT MapTypesToDXT(LPWSTR pszType, LPWSTR pszSubType, LPWSTR * ppszOut);


#endif // _TRANSMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transout.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transout.cpp
//
//  Abstract:   Implementation of CTIMETransOut
//
//  2000/09/15  mcalkins    Add explicit support for transitioning out.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "trans.h"
#include "transsink.h"

DeclareTag(tagTransitionOut, "TIME: Behavior", "CTIMETransOut methods")




class
ATL_NO_VTABLE
__declspec(uuid("6b2b104a-b13d-4b15-90be-1e8f6f7471da"))
CTIMETransOut :
    public CTIMETransSink
{
public:

    CTIMETransOut();

protected:

    // CTIMETransBase overrides.

    STDMETHOD(OnDirectionChanged)();

    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();

    // CTIMETransSink overrides.

    STDMETHOD(PopulateNode)(ITIMENode * pNode);
    STDMETHOD_(void, PreApply)();
    STDMETHOD_(void, PostApply)();
};


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::CTIMETransOut
//
//------------------------------------------------------------------------------
CTIMETransOut::CTIMETransOut()
{
    // Base class member initialization. (CTIMETransSink)

    m_eDXTQuickApplyType = DXTQAT_TransitionOut;
}
//  Method: CTIMETransOut::CTIMETransOut


//+-----------------------------------------------------------------------
//
//  Function:  CreateTransOut
//
//  Overview:  Create a CTIMETransOut, and return a ITransitionElement pointer to it
//
//  Arguments: ppTransElement - where to stuff the pointer
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CreateTransOut(ITransitionElement ** ppTransElement)
{
    HRESULT hr;
    CComObject<CTIMETransOut> * sptransOut;

    hr = THR(CComObject<CTIMETransOut>::CreateInstance(&sptransOut));
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppTransElement)
    {
        *ppTransElement = sptransOut;
        (*ppTransElement)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::OnDirectionChanged, CTIMETransBase
//
//  Overview:
//      Although a "transout" always gives the visual impression of
//      transitioning the element from a visible state to a non-visible state,
//      when the direction is reversed we actually do a reverse "transin" to
//      give the impression that the direction has reversed.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransOut::OnDirectionChanged()
{
    if (m_fDirectionForward)
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionOut;
    }
    else
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionIn;
    }

    return S_OK;
}
//  Method: CTIMETransOut::OnDirectionChanged


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::PopulateNode, CTIMETransSink
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransOut::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr      = S_OK;
    LONG    lCookie = 0;

    hr = THR(CTIMETransSink::PopulateNode(pNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->addBeginSyncArc(GetMediaTimeNode(),
                                    TE_TIMEPOINT_END,
                                    -1.0 * GetDurationAttr() * GetRepeatCountAttr(),
                                    &lCookie));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransOut::PopulateNode, CTIMETransSink


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::PreApply
//
//  Overview:  Event handler for before apply is called on the transition
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransOut::PreApply()
{
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::PostApply
//
//  Overview:  Event handler for after apply is called on the transition
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransOut::PostApply()
{
    // TODO (mcalkins)  Move this to set the visibility of the element to
    //                  false _after_ the transition is complete.  Some
    //                  sort of similar adjustment needs to be made for
    //                  transin as well.

    // ::SetVisibility(m_spHTMLElement, false);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::OnBegin
//
//+-----------------------------------------------------------------------
void
CTIMETransOut::OnBegin (void)
{
    CTIMETransSink::OnBegin();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONOUTBEGIN));
} // CTIMETransOut::OnBegin


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::OnEnd
//
//+-----------------------------------------------------------------------
void
CTIMETransOut::OnEnd (void)
{
    CTIMETransSink::OnEnd();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONOUTEND));
} // CTIMETransOut::OnEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transbase.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transbase.cpp
//
//  Abstract:   Implemntation of CTIMETransBase.
//
//  2000/10/02  mcalkins    Changed startPercent to startProgress.
//                          Changed endPercent to endProgress.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transbase.h"
#include "tokens.h"
#include "timeparser.h"

const LPWSTR    DEFAULT_M_TYPE          = NULL;
const LPWSTR    DEFAULT_M_SUBTYPE       = NULL;
const double    DEFAULT_M_DURATION      = 1.0;
const double    DEFAULT_M_STARTPROGRESS = 0.0;
const double    DEFAULT_M_ENDPROGRESS   = 1.0;
const LPWSTR    DEFAULT_M_DIRECTION     = NULL;
const double    DEFAULT_M_REPEAT        = 1.0;
const LPWSTR    DEFAULT_M_BEGIN         = NULL;
const LPWSTR    DEFAULT_M_END           = NULL;

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define CTB CTIMETransBase

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(CTB_Type,         CTB,    GetTypeAttr,         put_type,         get_type,            VARIANT);
TIME_PERSIST_FN(CTB_SubType,      CTB,    GetSubTypeAttr,      put_subType,      get_subType,         VARIANT);
TIME_PERSIST_FN(CTB_Duration,     CTB,    GetDurationAttr,     put_dur,          get_dur,             VARIANT);
TIME_PERSIST_FN(CTB_StartProgress,CTB,    GetStartProgressAttr,put_startProgress,get_startProgress,   VARIANT);
TIME_PERSIST_FN(CTB_EndProgress,  CTB,    GetEndProgressAttr,  put_endProgress,  get_endProgress,     VARIANT);
TIME_PERSIST_FN(CTB_Direction,    CTB,    GetDirectionAttr,    put_direction,    get_direction,       VARIANT);
TIME_PERSIST_FN(CTB_RepeatCount,  CTB,    GetRepeatCountAttr,  put_repeatCount,  get_repeatCount,     VARIANT);
TIME_PERSIST_FN(CTB_Begin,        CTB,    GetBeginAttr,        put_begin,        get_begin,           VARIANT);
TIME_PERSIST_FN(CTB_End,          CTB,    GetEndAttr,          put_end,          get_end,             VARIANT);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMETransBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             CTB_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          CTB_SubType )
    PERSISTENCE_MAP_ENTRY( WZ_DUR,              CTB_Duration )
    PERSISTENCE_MAP_ENTRY( WZ_STARTPROGRESS,    CTB_StartProgress )
    PERSISTENCE_MAP_ENTRY( WZ_ENDPROGRESS,      CTB_EndProgress )
    PERSISTENCE_MAP_ENTRY( WZ_DIRECTION,        CTB_Direction )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATCOUNT,      CTB_RepeatCount )
    PERSISTENCE_MAP_ENTRY( WZ_BEGIN,            CTB_Begin )
    PERSISTENCE_MAP_ENTRY( WZ_END,              CTB_End )

END_TIME_PERSISTENCE_MAP()


//+-----------------------------------------------------------------------
//
//  Member: CTIMETransBase::CTIMETransBase
//
//------------------------------------------------------------------------
CTIMETransBase::CTIMETransBase() :
    m_SAType(DEFAULT_M_TYPE),
    m_SASubType(DEFAULT_M_SUBTYPE),
    m_DADuration(DEFAULT_M_DURATION),
    m_DAStartProgress(DEFAULT_M_STARTPROGRESS),
    m_DAEndProgress(DEFAULT_M_ENDPROGRESS),
    m_SADirection(DEFAULT_M_DIRECTION),
    m_DARepeatCount(DEFAULT_M_REPEAT),
    m_SABegin(DEFAULT_M_BEGIN),
    m_SAEnd(DEFAULT_M_END),
    m_fHavePopulated(false),
    m_fInLoad(false),
    m_fDirectionForward(true)
{
}
//  Member: CTIMETransBase::CTIMETransBase


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::~CTIMETransBase
//
//------------------------------------------------------------------------------
CTIMETransBase::~CTIMETransBase()
{
}
//  Member: CTIMETransBase::~CTIMETransBase


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::_ReadyToInit
//
//------------------------------------------------------------------------------
bool
CTIMETransBase::_ReadyToInit()
{
    bool bRet = false;

    if (m_spHTMLElement == NULL) 
    {
        goto done;
    }

    if (m_spHTMLElement2 == NULL)
    {
        goto done;
    }

    if (m_spHTMLTemplate == NULL)
    {
        goto done;
    }

    if (!m_fHavePopulated)
    {
        goto done;
    }

    bRet = true;

done:

    return bRet;
}
//  Member: CTIMETransBase::_ReadyToInit


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::Init
//
//  Overview:   Initializes protected m_spTransWorker with an ITransitionWorker.
//              Must be called during OnLoad.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::Init()
{
    HRESULT hr = S_OK;

    if (!_ReadyToInit())
    {
        hr = THR(E_FAIL);

        goto done;
    }

    hr = THR(_GetMediaSiteFromHTML());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::CreateTransitionWorker(&m_spTransWorker));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransWorker->put_transSite(this));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransWorker->InitFromTemplate());

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::Init


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::Detach
//
//  Overview:  Detaches from ITransitionWorker, and releases all interfaces held
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::Detach()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        m_spTransWorker->Detach();
    }

    m_spTransWorker.Release();
    m_spHTMLElement.Release();
    m_spHTMLElement2.Release();
    m_spHTMLTemplate.Release();

    m_spTransitionSite.Release();

done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::PopulateFromTemplateElement
//
//  Overview:  Persistence in from the template
//
//  Arguments: void
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransBase::PopulateFromTemplateElement()
{
    HRESULT hr = S_OK;

    Assert(m_spHTMLTemplate != NULL);
    Assert(!m_fHavePopulated);

    if (!::IsElementTransition(m_spHTMLTemplate))
    {
        hr = THR(E_FAIL);
        goto done;
    }

    m_fInLoad = true;

    hr = THR(::TimeElementLoad(this, CTIMETransBase::PersistenceMap, m_spHTMLTemplate));
    
    m_fInLoad = false;

    if (FAILED(hr))
    {
        goto done;
    }

    m_fHavePopulated = true;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::PopulateFromPropertyBag
//
//  Overview:  
//      Persistence in from property bag.
//
//  Arguments: 
//      pPropBag    property bag to read from.
//      pErrorLog   Where to write errors out to.
//             
//------------------------------------------------------------------------------
HRESULT
CTIMETransBase::PopulateFromPropertyBag(IPropertyBag2 * pPropBag, IErrorLog * pErrorLog)
{
    HRESULT hr = S_OK;

    Assert(!m_fHavePopulated);
    Assert(pPropBag);

    m_fInLoad = true;

    hr = THR(::TimeLoad(this, CTIMETransBase::PersistenceMap, pPropBag, pErrorLog));
    
    m_fInLoad = false;

    if (FAILED(hr))
    {
        goto done;
    }

    m_fHavePopulated = true;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransBase::PopulateFromPropertyBag


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::_GetMediaSiteFromHTML
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::_GetMediaSiteFromHTML()
{
    HRESULT hr = S_OK;
    
    CComPtr<ITIMEElement> spTimeElem;
    hr = THR(::FindTIMEInterface(m_spHTMLElement, &spTimeElem));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTimeElem->QueryInterface(IID_TO_PPV(ITIMETransitionSite, 
                                                   &m_spTransitionSite)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::_GetMediaSiteFromHTML


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_htmlElement
//
//  Overview:  
//      Returns an addrefed pointer to the html element to apply the transition
//      to.
//
//  Arguments: 
//      ppHTMLElement   Where to store the pointer.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_htmlElement(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(ppHTMLElement);
    Assert(!*ppHTMLElement);

    if (NULL == ppHTMLElement)
    {
        hr = E_POINTER;

        goto done;
    }

    if (NULL != *ppHTMLElement)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (m_spHTMLElement)
    {
        *ppHTMLElement = m_spHTMLElement;

        (*ppHTMLElement)->AddRef();
    }
    else
    {
        hr = E_FAIL;

        goto done;
    }

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_htmlElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_template
//
//  Overview:  
//      Returns an addrefed pointer to the html element to read properties from.
//
//  Arguments: 
//      ppHTMLElement   Where to store the pointer.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_template(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(ppHTMLElement);
    Assert(!*ppHTMLElement);

    if (NULL == ppHTMLElement)
    {
        hr = E_POINTER;

        goto done;
    }

    if (NULL != *ppHTMLElement)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (m_spHTMLTemplate)
    {
        *ppHTMLElement = m_spHTMLTemplate;

        (*ppHTMLElement)->AddRef();
    }
    else
    {
        hr = E_FAIL;

        goto done;
    }
    
done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_template


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_type
//
//  Overview:  returns the type attribute set on the Transition
//
//  Arguments: type - where to store the type string
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_type(VARIANT * type)
{
    HRESULT hr = S_OK;

    if (NULL == type)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(type));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(type)      = VT_BSTR;
    V_BSTR(type)    = m_SAType.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_type, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_type, ITIMETransitionElement
//
//  Overview:  
//      Modifies the type attribute set on the transition.
//
//  Arguments: 
//      type    New type.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_type(VARIANT type)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &type, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAType.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_type, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_subType, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_subType(VARIANT * subtype)
{
    HRESULT hr = S_OK;

    Assert(subtype);

    if (NULL == subtype)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(subtype));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(subtype)   = VT_BSTR;
    V_BSTR(subtype) = m_SASubType.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_subType, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_subType, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_subType(VARIANT subtype)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &subtype, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SASubType.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_subType, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_dur, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_dur(VARIANT * dur)
{
    HRESULT hr = S_OK;

    if (NULL == dur)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(dur));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(dur) = VT_R8;
    V_R8(dur) = m_DADuration;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_dur, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_dur, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_dur(VARIANT dur)
{
    HRESULT     hr      = S_OK;
    double      dblTemp = DEFAULT_M_DURATION;

    CTIMEParser Parser(&dur);

    hr = THR(Parser.ParseDur(dblTemp));

    if (FAILED(hr))
    {
        goto done;
    }

    if (dblTemp < 0.0)
    {
        hr = E_INVALIDARG;

        goto done;
    }

        
    m_DADuration.SetValue(dblTemp);

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_dur, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_startProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_startProgress(VARIANT * startProgress)
{
    HRESULT hr = S_OK;

    if (NULL == startProgress)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(startProgress));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(startProgress) = VT_R8;
    V_R8(startProgress) = m_DAStartProgress;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_startProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_startProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_startProgress(VARIANT startProgress)
{
    HRESULT hr = S_OK;

    {
        CComVariant varStartProg;

        hr = THR(VariantChangeTypeEx(&varStartProg, &startProgress, LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DAStartProgress.SetValue(V_R8(&varStartProg));
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_startProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_endProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_endProgress(VARIANT * endProgress)
{
    HRESULT hr = S_OK;

    if (NULL == endProgress)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(endProgress));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(endProgress) = VT_R8;
    V_R8(endProgress) = m_DAEndProgress;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_endProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_endProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_endProgress(VARIANT endProgress)
{
    HRESULT hr = S_OK;

    {
        CComVariant varEndProg;

        hr = THR(VariantChangeTypeEx(&varEndProg, &endProgress, LCID_SCRIPTING, 
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DAEndProgress.SetValue(V_R8(&varEndProg));
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_endProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_direction, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_direction(VARIANT * direction)
{
    HRESULT hr = S_OK;

    if (NULL == direction)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(direction));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(direction)     = VT_BSTR;
    V_BSTR(direction)   = m_SADirection.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_direction, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_direction, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_direction(VARIANT direction)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    // ##ISSUE - do we need to check for forward/reverse here?
    //           that is, is it ok to persist an invalid value back out?

    hr = THR(VariantChangeTypeEx(&var, &direction, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SADirection.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    if (0 == StrCmpIW(var.bstrVal, WZ_REVERSE))
    {
        m_fDirectionForward = false;
    }
    else if (0 == StrCmpIW(var.bstrVal, WZ_FORWARD))
    {
        m_fDirectionForward = true;
    }

    // Ask derived class if they would like to react to a change in direction.

    hr = THR(OnDirectionChanged());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_direction, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_repeatCount, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_repeatCount(VARIANT * repeatCount)
{
    HRESULT hr = S_OK;

    if (NULL == repeatCount)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(repeatCount));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(repeatCount) = VT_R8;
    V_R8(repeatCount) = m_DARepeatCount;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_repeatCount


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_repeatCount, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_repeatCount(VARIANT repeatCount)
{
    HRESULT hr = S_OK;

    {
        CComVariant varRepCount;

        hr = THR(VariantChangeTypeEx(&varRepCount, &repeatCount, LCID_SCRIPTING, 
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DARepeatCount.SetValue(V_R8(&varRepCount));
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_repeatCount, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_begin, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_begin(VARIANT *begin)
{
    HRESULT hr = S_OK;

    if (NULL == begin)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(begin));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(begin)     = VT_BSTR;
    V_BSTR(begin)   = m_SABegin.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_begin, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_begin, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_begin(VARIANT begin)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &begin, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SABegin.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_begin, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_end, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_end(VARIANT * end)
{
    HRESULT hr = S_OK;

    if (NULL == end)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(end));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(end)   = VT_BSTR;
    V_BSTR(end) = m_SAEnd.GetValue();

    hr = S_OK;  

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_end, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_end, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_end(VARIANT end)
{
    HRESULT hr = S_OK;

    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &end, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAEnd.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_end, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::OnBegin
//
//------------------------------------------------------------------------------
void
CTIMETransBase::OnBegin()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        double dblProgress = 0.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgress = m_DAStartProgress;
        }

        IGNORE_HR(m_spTransWorker->OnBeginTransition());
        IGNORE_HR(m_spTransWorker->put_progress(dblProgress));
    }

    hr = S_OK;

done:

    return;
}
//  Member: CTIMETransBase::OnBegin


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::OnEnd
//
//------------------------------------------------------------------------------
void
CTIMETransBase::OnEnd()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        double dblProgress = 1.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgress = m_DAEndProgress;
        }

        IGNORE_HR(m_spTransWorker->put_progress(dblProgress));
        IGNORE_HR(m_spTransWorker->OnEndTransition());
    }

    hr = S_OK;

done:

    return;
}
//  Member: CTIMETransBase::OnEnd


void
CTIMETransBase::OnRepeat()
{
    HRESULT hr = S_OK;

    hr = THR(FireEvent(TE_ONTRANSITIONREPEAT));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return;
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransBase::FireEvent
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransBase::FireEvent(TIME_EVENT event)
{
    HRESULT hr = S_OK;

    if (m_spTransitionSite)
    {
        hr = THR(m_spTransitionSite->FireTransitionEvent(event));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransBase::FireEvent


// the timing engine will not calculate progress without an explicit duration set on a timing node.
double
CTIMETransBase::CalcProgress(ITIMENode * pNode)
{
    double dblRet = 1.0;

    double dblActiveTime;
    double dblActiveEnd;
    double dblActiveBegin;

    if (NULL == pNode)
        goto done;
    
    IGNORE_HR(pNode->get_currActiveTime(&dblActiveTime));
    IGNORE_HR(pNode->get_endParentTime(&dblActiveEnd));
    IGNORE_HR(pNode->get_beginParentTime(&dblActiveBegin));

    // if dblActiveEnd is INFINITE, dblRet should be 0
    dblRet = dblActiveTime / (dblActiveEnd - dblActiveBegin);

done:
    return dblRet;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::OnProgressChanged
//
//  Overview:  Event handler for progress changes
//
//  Arguments: dblProgress - new progress
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
void
CTIMETransBase::OnProgressChanged(double dblProgress)
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        hr = THR(m_spTransWorker->put_progress(dblProgress));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transbase.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transbase.h
//
//  Abstract:   Declaration of CTIMETransBase.
//
//  2000/10/02  mcalkins    Changed startPercent to startProgress.
//                          Changed endPercent to endProgress.
//
//------------------------------------------------------------------------------

#ifndef _TRANSBASE_H__
#define _TRANSBASE_H__

#pragma once

#include "trans.h"
#include "transworker.h"
#include "transsite.h"
#include "attr.h"
#include "eventmgr.h"

class 
ATL_NO_VTABLE
__declspec(uuid("3b2716d3-0cfb-4f2f-8ff1-9bc7cb2a3a66"))
CTIMETransBase :
    public ITransitionSite
{
    //
    // Flags.
    //

protected:

    unsigned                    m_fHavePopulated    : 1;
    unsigned                    m_fInLoad           : 1;
    unsigned                    m_fDirectionForward : 1;

    //
    // Member variables.
    //

protected:

    // Attributes.

    CAttrString     m_SAType;
    CAttrString     m_SASubType;
    CAttr<double>   m_DAStartProgress;
    CAttr<double>   m_DAEndProgress;
    CAttrString     m_SADirection;
    CAttr<double>   m_DADuration;
    CAttr<double>   m_DARepeatCount;
    CAttrString     m_SABegin;
    CAttrString     m_SAEnd;

    CComPtr<ITransitionWorker>  m_spTransWorker;
    CComPtr<IHTMLElement>       m_spHTMLElement;
    CComPtr<IHTMLElement2>      m_spHTMLElement2;
    CComPtr<IHTMLElement>       m_spHTMLTemplate;
    CComPtr<ITIMETransitionSite>    m_spTransitionSite;

    //
    // Methods.
    //

private:

    STDMETHOD(_GetMediaSiteFromHTML)();

    bool    _ReadyToInit();

protected:

    // Event handlers.

    STDMETHOD_(void, OnProgressChanged)(double dblProgress);
    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();
    STDMETHOD_(void, OnRepeat)();

    STDMETHOD(OnDirectionChanged)() PURE;

    STDMETHOD(FireEvent)(TIME_EVENT event);

    STDMETHOD(PopulateFromTemplateElement)();
    STDMETHOD(PopulateFromPropertyBag)(IPropertyBag2 *  pPropBag, 
                                       IErrorLog *      pErrorLog);

    static TIME_PERSISTENCE_MAP PersistenceMap[];

    double CalcProgress(ITIMENode * pNode);

public:

    CTIMETransBase();
    virtual ~CTIMETransBase();

    STDMETHOD(Init)();
    STDMETHOD(Detach)();

    // ITransitionSite methods.

    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement);
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement);

    // ITIMETransitionElement properties.

    STDMETHOD(get_type)(VARIANT *type);        
    STDMETHOD(put_type)(VARIANT type);        
    STDMETHOD(get_subType)(VARIANT *subtype);        
    STDMETHOD(put_subType)(VARIANT subtype);        
    STDMETHOD(get_startProgress)(VARIANT * startProgress);
    STDMETHOD(put_startProgress)(VARIANT startProgress);
    STDMETHOD(get_endProgress)(VARIANT * endProgress);
    STDMETHOD(put_endProgress)(VARIANT endProgress);
    STDMETHOD(get_direction)(VARIANT *direction);
    STDMETHOD(put_direction)(VARIANT direction);
    STDMETHOD(get_begin)(VARIANT *begin);
    STDMETHOD(put_begin)(VARIANT begin);
    STDMETHOD(get_end)(VARIANT * end);
    STDMETHOD(put_end)(VARIANT end);
    STDMETHOD(get_repeatCount)(VARIANT * repeatCount);
    STDMETHOD(put_repeatCount)(VARIANT repeatCount);
    STDMETHOD(get_dur)(VARIANT * dur);
    STDMETHOD(put_dur)(VARIANT dur); 

    // Persistance value accessors

    CAttrString   & GetTypeAttr()           { return m_SAType; }
    CAttrString   & GetSubTypeAttr()        { return m_SASubType; }
    CAttr<double> & GetDurationAttr()       { return m_DADuration; }
    CAttr<double> & GetStartProgressAttr()  { return m_DAStartProgress; }
    CAttr<double> & GetEndProgressAttr()    { return m_DAEndProgress; }
    CAttrString   & GetDirectionAttr()      { return m_SADirection; }
    CAttr<double> & GetRepeatCountAttr()    { return m_DARepeatCount; }
    CAttrString   & GetBeginAttr()          { return m_SABegin; }
    CAttrString   & GetEndAttr()            { return m_SAEnd; }
};

#endif //_TRANSBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transin.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transin.cpp
//
//  Abstract:   Implementation of CTIMETransIn
//
//  2000/09/15  mcalkins    Add explicit support for transitioning in.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "trans.h"
#include "transsink.h"

DeclareTag(tagTransitionIn, "TIME: Behavior", "CTIMETransIn methods")




class
ATL_NO_VTABLE
__declspec(uuid("ec3c8873-3bfc-473a-80c6-edc879d477cc"))
CTIMETransIn :
    public CTIMETransSink
{
public:

    CTIMETransIn();

protected:

    // CTIMETransBase overrides.

    STDMETHOD(OnDirectionChanged)();

    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();

    // CTIMETransSink overrides.

    STDMETHOD(PopulateNode)(ITIMENode * pNode);

    STDMETHOD_(void, PreApply)();
    STDMETHOD_(void, PostApply)();
};


//+-----------------------------------------------------------------------------
//
// Method:  CTIMETransIn::CTIMETransIn
//
//+-----------------------------------------------------------------------------
CTIMETransIn::CTIMETransIn()
{
    // Base class member initialization. (CTIMETransSink)

    m_eDXTQuickApplyType = DXTQAT_TransitionIn;
}
// Method:  CTIMETransIn::CTIMETransIn


//+-----------------------------------------------------------------------
//
//  Function:  CreateTransIn
//
//  Overview:  Create a CTIMETransIn, and pass back an ITransitionElement pointer
//
//  Arguments: ppTransElement - where to place the pointer
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CreateTransIn(ITransitionElement ** ppTransElement)
{
    HRESULT hr;
    CComObject<CTIMETransIn> * sptransIn;

    hr = THR(CComObject<CTIMETransIn>::CreateInstance(&sptransIn));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (ppTransElement)
    {
        *ppTransElement = sptransIn;
        (*ppTransElement)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransIn::OnDirectionChanged, CTIMETransBase
//
//  Overview:
//      Although a "transin" always gives the visual impression of
//      transitioning the element from a non-visible state to a visible state,
//      when the direction is reversed we actually do a reverse "transout" to 
//      give the impression that the direction has reversed.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransIn::OnDirectionChanged()
{
    if (m_fDirectionForward)
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionIn;
    }
    else
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionOut;
    }

    return S_OK;
}
//  Method: CTIMETransIn::OnDirectionChanged


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransIn::PopulateNode
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransIn::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr      = S_OK;
    LONG    lCookie = 0;

    hr = THR(CTIMETransSink::PopulateNode(pNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->addBeginSyncArc(GetMediaTimeNode(), 
                                    TE_TIMEPOINT_BEGIN, 
                                    0, 
                                    &lCookie));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransIn::PopulateNode


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransIn::PreApply
//
//  Overview:  
//      Event handler for before apply is called on the transition.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransIn::PreApply()
{
    // ##ISSUE: (mcalkins) We should verify that we'll never get here under
    //          any conditions unless this pointer is availble.

    Assert(!!m_spTransitionSite);

    if (m_spTransitionSite)
    {
        m_spTransitionSite->SetDrawFlag(VARIANT_FALSE);
    }
}
//  Member: CTIMETransIn::PreApply


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::PostApply
//
//  Overview:  Event handler for after apply is called on the transition
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransIn::PostApply()
{
    // ##ISSUE: (mcalkins) We should verify that we'll never get here under
    //          any conditions unless this pointer is availble.

    Assert(!!m_spTransitionSite);

    if (m_spTransitionSite)
    {
        m_spTransitionSite->SetDrawFlag(VARIANT_TRUE);
    }   
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::OnBegin
//
//+-----------------------------------------------------------------------
void
CTIMETransIn::OnBegin (void)
{
    CTIMETransSink::OnBegin();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONINBEGIN));
} // CTIMETransIn::OnBegin


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::OnEnd
//
//+-----------------------------------------------------------------------
void
CTIMETransIn::OnEnd (void)
{
    CTIMETransSink::OnEnd();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONINEND));
} // CTIMETransIn::OnEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transsink.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transsink.h
//
//  Abstract:   Declaration of CTIMETransSink.
//
//  2000/09/15  mcalkins    Added m_eDXTQuickApplyType member variable.
//
//------------------------------------------------------------------------------

#ifndef _TRANSSINK_H__
#define _TRANSSINK_H__

#pragma once

#include "transbase.h"
#include "transsite.h"
#include "attr.h"




class
ATL_NO_VTABLE
__declspec(uuid("84f7bcfa-4bcf-4e70-9ecc-d97086e5cb9c"))
CTIMETransSink :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTIMETransSink, &__uuidof(CTIMETransSink)>,
    public CTIMETransBase,
    public ITransitionElement,
    public ITIMENodeBehavior
{
public:

    CTIMETransSink();

    // ITransitionElement methods.

    STDMETHOD(Init)();
    STDMETHOD(Detach)();
    STDMETHOD(put_template)(LPWSTR pwzTemplate);
    STDMETHOD(put_htmlElement)(IHTMLElement * pHTMLElement);
    STDMETHOD(put_timeElement)(ITIMEElement * pTIMEElement);

    // ITIMENodeBehavior methods.

    STDMETHOD(tick)();
    STDMETHOD(eventNotify)(double dblEventTime,
                           TE_EVENT_TYPE teEventType,
                           long lNewRepeatCount);
    STDMETHOD(getSyncTime)(double * dblNewSegmentTime,
                           LONG * lNewRepeatCount,
                           VARIANT_BOOL * bCueing);        
    STDMETHOD(propNotify)(DWORD tePropTypes);

    // QI implementation.

    BEGIN_COM_MAP(CTIMETransSink)
        COM_INTERFACE_ENTRY(ITIMENodeBehavior)
    END_COM_MAP();

protected:

    // Are we a transition in or a transition out?  This should be set
    // appropriately by a class that derives from this class.

    DXT_QUICK_APPLY_TYPE    m_eDXTQuickApplyType;

    // event handlers

    STDMETHOD_(void, OnBegin) (void);
    STDMETHOD_(void, OnEnd) (void);
    STDMETHOD_(void, OnProgressChanged)(double dblProgress);

    // setup

    STDMETHOD(PopulateNode)(ITIMENode * pNode);

    // subclasses must implement

    STDMETHOD_(void, PreApply)() PURE;
    STDMETHOD_(void, PostApply)() PURE;

    // accessors

    ITIMENode * GetParentTimeNode() { return m_spTimeParent; }
    ITIMENode * GetMediaTimeNode() { return m_spMediaNode; }
    ITIMENode * GetTimeNode() { return m_spTimeNode; }

private:

    // initialization

    HRESULT FindTemplateElement();

    // private methods

    HRESULT ApplyIfNeeded();
    bool    ReadyToInit();
    HRESULT CreateTimeBehavior();

    // private data

    CComPtr<ITIMEElement>       m_spTIMEElement;

    CComPtr<ITIMENode>          m_spTimeNode;
    CComPtr<ITIMENode>          m_spTimeParent;
    CComPtr<ITIMENode>          m_spMediaNode;
    CComPtr<ITIMEContainer>     m_spParentContainer;

    CAttrString                 m_SATemplate;

#ifdef DBG
    bool                        m_fHaveCalledInit;
#endif
    bool                        m_fHaveCalledApply;
    bool                        m_fInReset;
    bool                        m_fPreventDueToFill;
};

#endif // _TRANSSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transmap.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transmap.cpp
//
//  Abstract:   Tables and functions that map types and sub types to actual 
//              DXTransforms.
//
//  2000/09/15  mcalkins    Changed to optimized DXTransform progids.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transmap.h"




// An individual TRANSITION_MAP is used to map from type/subtype combinations to 
// dxtransform filter types
//
// the TRANSITION_MAP arrays defined here are structured in the following way:
//
// element 0 = type name, and prefix for output
// elements 1->n-1 = subtype name, and postfix for output
// element n-1 = double NULL for terminator flag

struct TRANSITION_MAP
{
    LPWSTR pszAttribute;    // subtype attribute from html
    LPWSTR pszTranslation;  // attribute for style
};


// Bar wipe translation.

static TRANSITION_MAP g_aBarWipeMap[] = {
    {L"barWipe",                L"progid:DXImageTransform.Microsoft.GradientWipe(GradientSize=0.00, "},

    {L"leftToRight",            L"wipeStyle=0)"},
    {L"topToBottom",            L"wipeStyle=1)"},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBoxWipeMap[] = {
    {L"boxWipe",                NULL},

    {L"topLeft",                NULL},
    {L"topRight",               NULL},
    {L"bottomRight",            NULL},
    {L"bottomLeft",             NULL},
    {L"topCenter",              NULL},
    {L"rightCenter",            NULL},
    {L"bottomCenter",           NULL},
    {L"leftCenter",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aFourBoxWipeMap[] = {
    {L"fourBoxWipe",            NULL},

    {L"cornersIn",              NULL},
    {L"cornersOut",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnDoorWipeMap[] = {
    {L"barnDoorWipe",           L"progid:DXImageTransform.Microsoft.Barn("},

    {L"vertical",               L"orientation='vertical')"},
    {L"horizontal",             L"orientation='horizontal')"},
    {L"diagonalBottomLeft",     NULL},
    {L"diagonalTopLeft",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDiagonalWipeMap[] = {
    {L"diagonalWipe",           NULL},

    {L"topLeft",                NULL},
    {L"topRight",               NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBowTieWipeMap[] = {
    {L"bowTieWipe",             NULL},

    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aMiscDiagonalWipeMap[] = {
    {L"miscDiagonalWipe",       NULL},

    {L"doubleBarnDoor",         NULL},
    {L"doubleDiamond",          NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aVeeWipeMap[] = {
    {L"veeWipe",                NULL},

    {L"down",                   NULL},
    {L"left",                   NULL},
    {L"up",                     NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnVeeWipeMap[] = {
    {L"barnVeeWipe",            NULL},

    {L"down",                   NULL},
    {L"left",                   NULL},
    {L"up",                     NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aZigZagWipeMap[] = {
    {L"zigZagWipe",             NULL},

    {L"leftToRight",            NULL},
    {L"topToBottom",            NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnZigZagWipeMap[] = {
    {L"barnZigZagWipe",         NULL},

    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};


// Iris wipe translation.

static TRANSITION_MAP g_aIrisWipeMap[] = {
    {L"irisWipe",       L"progid:DXImageTransform.Microsoft.Iris("},

    {L"rectangle",      L"irisStyle=SQUARE)"},
    {L"diamond",        L"irisStyle=DIAMOND)"},
    {NULL, NULL}
};

static TRANSITION_MAP g_aTriangleWipeMap[] = {
    {L"triangleWipe",   NULL},

    {L"up",             NULL},
    {L"right",          NULL},
    {L"down",           NULL},
    {L"left",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aArrowHeadWipeMap[] = {
    {L"arrowHeadWipe",  NULL},

    {L"up",             NULL},
    {L"right",          NULL},
    {L"down",           NULL},
    {L"left",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aPentagonWipeMap[] = {
    {L"pentagonWipe",   NULL},

    {L"up",             NULL},
    {L"down",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aHexagonWipeMap[] = {
    {L"hexagonWipe",    NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aEllipseWipeMap[] = {
    {L"ellipseWipe",    L"progid:DXImageTransform.Microsoft.Iris("},

    {L"circle",         L"irisStyle=CIRCLE)"},
    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aEyeWipeMap[] = {
    {L"eyeWipe",        NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aRoundRectWipeMap[] = {
    {L"roundRectWipe",  NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aStarWipeMap[] = {
    {L"starWipe",       L"progid:DXImageTransform.Microsoft.Iris("},

    {L"fourPoint",      NULL},
    {L"fivePoint",      L"irisStyle='star')"},
    {L"sixPoint",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aMiscShapeWipeMap[] = {
    {L"miscShapeWipe",  NULL},

    {L"heart",          NULL},
    {L"keyhole",        NULL},
    {NULL, NULL}
};



// Clock wipe translation.

static TRANSITION_MAP g_aClockWipeMap[] = {
    {L"clockWipe",             L"progid:DXImageTransform.Microsoft.RadialWipe("},

    {L"clockwiseTwelve",        L"wipeStyle=CLOCK)"},
    {L"clockwiseThree",         NULL},
    {L"clockwiseSix",           NULL},
    {L"clockwiseNine",          NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aPinWheelWipeMap[] = {
    {L"pinWheelWipe",           NULL},

    {L"towBladeVertical",       NULL},
    {L"twoBladeHorizontal",     NULL},
    {L"fourBlade",              NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSingleSweepWipeMap[] = {
    {L"singleSweepWipe",            NULL},

    {L"clockwiseTop",               NULL},
    {L"clockwiseRight",             NULL},
    {L"clockwiseBottom",            NULL},
    {L"clockwiseLeft",              NULL},
    {L"clockwiseTopLeft",           NULL},
    {L"counterClockwiseBottomLeft", NULL},
    {L"clockwiseBottomRight",       NULL},
    {L"counterClockwiseTopRight",   NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aFanWipeMap[] = {
    {L"fanWipe",                L"progid:DXImageTransform.Microsoft.RadialWipe("},

    {L"centerTop",              L"wipeStyle=WEDGE)"},
    {L"centerRight",            NULL},
    {L"top",                    NULL},
    {L"right",                  NULL},
    {L"bottom",                 NULL},
    {L"left",                   NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDoubleFanWipeMap[] = {
    {L"doubleFanWipe",          NULL},

    {L"fanOutVertical",         NULL},
    {L"fanOutHorizontal",       NULL},
    {L"fanInVertical",          NULL},
    {L"fanInHorizontal",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDoubleSweepWipeMap[] = {
    {L"doubleSweepWipe",            NULL},

    {L"parallelVertical",           NULL},
    {L"parallelDiagonal",           NULL},
    {L"oppositeVertical",           NULL},
    {L"oppositeHorizontal",         NULL},
    {L"parallelDiagonalTopLeft",    NULL},
    {L"parallelDiagonalBottomLeft", NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSaloonDoorWipeMap[] = {
    {L"saloonDoorWipe",         NULL},

    {L"top",                    NULL},
    {L"left",                   NULL},
    {L"bottom",                 NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aWindshieldWipeMap[] = {
    {L"windshieldWipe",         NULL},

    {L"right",                  NULL},
    {L"up",                     NULL},
    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};


// Snake wipe translation.

static TRANSITION_MAP g_aSnakeWipeMap[] = {
    {L"snakeWipe",                      L"progid:DXImageTransform.Microsoft.ZigZag(GidSizeX=16,GridSizeY=8"},

    {L"topLeftHorizontal",              L")"},
    {L"topLeftVertical",                NULL},
    {L"topLeftDiagonal",                NULL},
    {L"topRightDiagonal",               NULL},
    {L"bottomRightDiagonal",            NULL},
    {L"bottomLeftDiagonal",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSpiralWipeMap[] = {
    {L"spiralWipe",                     L"progid:DXImageTransform.Microsoft.Spiral(GidSizeX=16,GridSizeY=8"},

    {L"topLeftClockwise",               L")"},
    {L"topRightClockwise",              NULL},
    {L"bottomRightClockwise",           NULL},
    {L"bottomLeftClockwise",            NULL},
    {L"topLeftCounterClockwise",        NULL},
    {L"topRightCounterClockwise",       NULL},
    {L"bottomRightCounterClockwise",    NULL},
    {L"bottomLeftCounterClockwise",     NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aParallelSnakesWipeMap[] = {
    {L"parallelSnakesWipe",             NULL},

    {L"verticalTopSame",                NULL},
    {L"verticalBottomSame",             NULL},
    {L"verticalTopLeftOpposite",        NULL},
    {L"verticalBottomLeftOpposite",     NULL},
    {L"horizontalLeftSame",             NULL},
    {L"horizontalRightSame",            NULL},
    {L"horizontalTopLeftOpposite",      NULL},
    {L"horizontalTopRightOpposite",     NULL},
    {L"diagonalBottomLeftOpposite",     NULL},
    {L"diagonalTopLeftOpposite",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBoxSnakesWipeMap[] = {
    {L"boxSnakesWipe",                  NULL},

    {L"twoBoxTop",                      NULL},
    {L"twoBoxBottom",                   NULL},
    {L"twoBoxLeft",                     NULL},
    {L"twoBoxRight",                    NULL},
    {L"fourBoxVertical",                NULL},
    {L"fourBoxHorizontal",              NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aWaterfallWipeMap[] = {
    {L"waterfallWipe",                  NULL},

    {L"verticalLeft",                   NULL},
    {L"verticalRight",                  NULL},
    {L"horizontalLeft",                 NULL},
    {L"horizontalRight",                NULL},
    {NULL, NULL}
};


// Push wipe translation.

static TRANSITION_MAP g_aPushWipeMap[] = {
    {L"pushWipe",    L"progid:DXImageTransform.Microsoft.Slide(slideStyle=PUSH,bands=1"},

    {L"fromLeft",    L")"},
    {L"fromTop",     NULL},
    {L"fromRight",   NULL},
    {L"fromBottom",  NULL},
    {NULL, NULL}
};


// Slide wipe translation.

static TRANSITION_MAP g_aSlideWipeMap[] = {
    {L"slideWipe",   L"progid:DXImageTransform.Microsoft.Slide(slideStyle=HIDE"},

    {L"fromLeft",    L")"},
    {L"fromTop",     NULL},
    {L"fromRight",   NULL},
    {L"fromBottom",  NULL},
    {NULL, NULL}
};


// Fade translation.

static TRANSITION_MAP g_aFadeMap[] = {
    {L"fade", L"progid:DXImageTransform.Microsoft.Fade(Overlap=1.00"},

    {L"crossfade",      L")"},
    {L"fadeToColor",    NULL},
    {L"fadeFromColor",  NULL},
    {NULL, NULL}
};


// This array of transition maps used to find the correct subtype map for a
// type.
 
static TRANSITION_MAP * g_aTypeMap[] = {
    g_aBarWipeMap,
    g_aBoxWipeMap,
    g_aFourBoxWipeMap,
    g_aBarnDoorWipeMap,
    g_aDiagonalWipeMap,
    g_aBowTieWipeMap,
    g_aMiscDiagonalWipeMap,
    g_aVeeWipeMap,
    g_aBarnVeeWipeMap,
    g_aZigZagWipeMap,
    g_aBarnZigZagWipeMap,
    g_aIrisWipeMap,
    g_aTriangleWipeMap,
    g_aArrowHeadWipeMap,
    g_aPentagonWipeMap,
    g_aHexagonWipeMap,
    g_aEllipseWipeMap,
    g_aEyeWipeMap,
    g_aRoundRectWipeMap,
    g_aStarWipeMap,
    g_aMiscShapeWipeMap,

    g_aClockWipeMap,
    g_aPinWheelWipeMap,
    g_aSingleSweepWipeMap,
    g_aFanWipeMap,
    g_aDoubleFanWipeMap,
    g_aSaloonDoorWipeMap,
    g_aWindshieldWipeMap,
    g_aSnakeWipeMap,
    g_aSpiralWipeMap,
    g_aParallelSnakesWipeMap,
    g_aBoxSnakesWipeMap,
    g_aWaterfallWipeMap,

    g_aSnakeWipeMap, 
    g_aSpiralWipeMap,
    g_aParallelSnakesWipeMap,
    g_aBoxSnakesWipeMap,
    g_aWaterfallWipeMap,

    g_aPushWipeMap, 
    g_aSlideWipeMap, 
    g_aFadeMap,
    NULL
};


//+-----------------------------------------------------------------------------
//
//  Function: GetTransitionMap
//
//------------------------------------------------------------------------------
HRESULT
GetTransitionMap(LPWSTR pszType, TRANSITION_MAP** ppTransMap)
{
    HRESULT hr = S_OK;

    Assert(pszType && ppTransMap);

    *ppTransMap = NULL;

    for (int i = 0; g_aTypeMap[i]; i++)
    {
        if (0 == StrCmpIW(g_aTypeMap[i]->pszAttribute, pszType))
        {
            *ppTransMap = g_aTypeMap[i];

            goto done;
        }
    }

    // Could not find the type in the typeMap.

    hr = E_FAIL;

done:

    RRETURN(hr);
}
//  Function: GetTransitionMap


//+-----------------------------------------------------------------------------
//
//  Function: GetSubType
//
//  Parameters:
//
//      pstrSubType         The subtype attibute of the <transition> or 
//                          <transitionFilter> element.
//
//      pTransMap           The map for this specific type of transition.
//
//      ppstrParameters     ppstrParameters be set to point to a string
//                          containing any additional parameters to set this
//                          transition up correctly.
//
//                          If this specific subtype is implemented, it will be
//                          set to the string for this specific subtype.
//
//                          If the default subtype is implemented but this
//                          specific subtype is not, it will be set to point to
//                          the default subtype's string.
//
//                          If the default subtype is not implemented and
//                          neither is this specific subtype, it will be set 
//                          to NULL.
//------------------------------------------------------------------------------
HRESULT
GetSubType(const WCHAR *            pstrSubType, 
           const TRANSITION_MAP *   pTransMap, 
           const WCHAR ** const     ppstrParameters)
{
    Assert(pTransMap);
    Assert(ppstrParameters);

    // The default entry will be the next map entry.

    HRESULT                 hr          = S_OK;
    const TRANSITION_MAP *  pMapEntry   = &pTransMap[1];

    // Set ppstrParameters to point to the default parameters string (which may
    // be NULL.)

    *ppstrParameters = pMapEntry->pszTranslation;

    // If no subtype was provided, we're done.

    if (NULL == pstrSubType)
    {
        goto done;
    }

    while (pMapEntry->pszAttribute)
    {
        if (0 == StrCmpIW(pstrSubType, pMapEntry->pszAttribute))
        {
            // If we have found the subtype, and it has a parameter string
            // associated with it then have ppstrParameters point to that
            // string.  Otherwise, leave it pointing to the default string
            // (which may be NULL if the default case isn't implemented.)

            if (pMapEntry->pszTranslation)
            {
                *ppstrParameters = pMapEntry->pszTranslation;
            }

            goto done;
        }

        // Go to the next map entry.

        pMapEntry = &pMapEntry[1];
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Function: GetSubType


//+-----------------------------------------------------------------------------
//
//  Function: MapTypesToDXT
//
//  #ISSUE: 2000/10/10 (mcalkins) Since everything we do with strings generally
//          uses BSTRs we should make the last parameter a BSTR instead.
//
//------------------------------------------------------------------------------
HRESULT
MapTypesToDXT(LPWSTR pszType, LPWSTR pszSubType, LPWSTR * ppszOut)
{
    HRESULT             hr          = S_OK;
    
    // do not deallocate these - they are only pointers - not allocated
    const WCHAR *       pszFirst    = NULL;
    const WCHAR *       pszSecond   = NULL;
    TRANSITION_MAP *    pTransMap   = NULL;   

    if (NULL == pszType || NULL == ppszOut) // subtype can be null
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *ppszOut = NULL;

    hr = THR(GetTransitionMap(pszType, &pTransMap));

    if (FAILED(hr))
    {
        // type is unknown - assume it is a fully formed transition by itself

        hr          = S_OK;
        *ppszOut    = ::CopyString(pszType);

        if (NULL == *ppszOut)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        goto done;
    }

    // If pTransMap->pszTranslation is NULL it means we haven't written 
    // DXTransforms yet to implement this category of transitions. 

    if (NULL == pTransMap->pszTranslation)
    {
        hr = E_FAIL;

        goto done;
    }

    Assert(pTransMap);
    Assert(0 == StrCmpIW(pszType, pTransMap->pszAttribute));

    pszFirst = pTransMap->pszTranslation;

    hr = THR(GetSubType(pszSubType, pTransMap, &pszSecond));

    if (FAILED(hr))
    {
        goto done;
    }

    // If pszSecond wasn't set, neither the default subtype nor this specific
    // subtype for this transition is implemented and we return failure.

    if (NULL == pszSecond)
    {
        hr = E_FAIL;

        goto done;
    }

    {
        Assert(pszFirst && pszSecond);

        LPWSTR  pszOut  = NULL;
        int     len     = lstrlenW(pszFirst) + lstrlenW(pszSecond) + 1;

        pszOut = new WCHAR[len];

        if (NULL == pszOut)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        StrCpy(pszOut, pszFirst);
        StrCatBuff(pszOut, pszSecond, len);

        Assert((len - 1) == lstrlenW(pszOut));

        *ppszOut = pszOut;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Function: MapTypesToDXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transsink.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transsink.cpp
//
//  Abstract:   Implementation of CTIMETransSink
//
//  2000/09/15  mcalkins    Add explicit support for transitioning in or out.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transsink.h"

DeclareTag(tagTransSink, "SMIL Transitions", "Transition sink methods");
DeclareTag(tagTransSinkEvents, "SMIL Transitions", "Transition sink events");

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::CTIMETransSink
//
//------------------------------------------------------------------------------
CTIMETransSink::CTIMETransSink() :
#ifdef DBG
    m_fHaveCalledInit(false),
#endif
    m_SATemplate(NULL),
    m_fHaveCalledApply(false),
    m_fInReset(false),
    m_fPreventDueToFill(false),
    m_eDXTQuickApplyType(DXTQAT_TransitionIn)
{
}
//  Member: CTIMETransSink::CTIMETransSink

    
//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::ReadyToInit
//
//------------------------------------------------------------------------------
bool
CTIMETransSink::ReadyToInit()
{
    bool bRet = false;

    if (m_spTIMEElement == NULL)
    {
        goto done;
    }

    bRet = true;

done:

    return bRet;
}
//  Member: CTIMETransSink::ReadyToInit


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::Init
//
//  Overview:  
//      Initialize connection to media element, populate template data.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::Init()
{
    HRESULT hr = S_OK;

    if (!ReadyToInit())
    {
        hr = THR(E_FAIL);
        goto done;
    }

    hr = THR(FindTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CTIMETransBase::PopulateFromTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CTIMETransBase::Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateTimeBehavior());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::Detach
//
//  Overview:  Detaches from media element, releases all pointers
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::Detach()
{
    CTIMETransBase::Detach();

    m_spTIMEElement.Release();

    // release timing nodes - remove node from parent - remove any begins and ends
    if (m_spParentContainer)
    {
        IGNORE_HR(m_spParentContainer->removeNode(m_spTimeNode));
    }
    
    if (m_spTimeNode)
    {
        IGNORE_HR(m_spTimeNode->removeBehavior(this));
        IGNORE_HR(m_spTimeNode->removeBegin(0));
        IGNORE_HR(m_spTimeNode->removeEnd(0));
    }

    m_spParentContainer.Release();
    m_spTimeParent.Release();
    m_spMediaNode.Release();
    m_spTimeNode.Release();

    RRETURN(S_OK);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::FindTemplateElement
//
//  Overview:  Populates m_spHTMLTemplate
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransSink::FindTemplateElement()
{
    HRESULT hr = S_OK;
    CComBSTR bstrTemplate;

    bstrTemplate = m_SATemplate.GetValue();
    if (bstrTemplate == NULL)
    {
        hr = THR(E_OUTOFMEMORY);
        goto done;
    }

    hr = THR(::FindHTMLElement(bstrTemplate, m_spHTMLElement, &m_spHTMLTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spHTMLTemplate != NULL);

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_template
//
//  Overview:  Stores the id for the template element to read Transition attributes from
//             call this exactly once before calling init
//
//  Arguments: pwzTemplate - template id
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_template(LPWSTR pwzTemplate)
{
    HRESULT hr = S_OK;

    Assert(pwzTemplate != NULL);
#ifdef DBG
    {
        CComBSTR bstr = m_SATemplate.GetValue();
        
        Assert(bstr == NULL);
    }
#endif //DBG

    // ##TODO - use the atom table for this - don't make extra copies
    hr = THR(m_SATemplate.SetValue(pwzTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_htmlElement
//
//  Overview:  stores the html element associated with this Transition
//             queries for an htmlelement2 pointer
//             call this exactly once before calling init
//
//  Arguments: pHTMLElement - html element to attach to
//             
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_htmlElement(IHTMLElement * pHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(m_spHTMLElement == NULL);
    Assert(m_spHTMLElement2 == NULL);

    m_spHTMLElement = pHTMLElement;

    if (m_spHTMLElement)
    {
        hr = THR(m_spHTMLElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &m_spHTMLElement2)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_timeElement
//
//  Overview:  stores the html+time element associated with this Transition
//             queries for an CTIMEElementBase pointer
//             call this exactly once before calling init
//
//  Arguments: pTIMEElement - time element to attach to
//             
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_timeElement(ITIMEElement * pTIMEElement)
{
    HRESULT hr = S_OK;

    Assert(NULL != pTIMEElement);
    Assert(m_spTIMEElement == NULL);

    m_spTIMEElement = pTIMEElement;

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::ApplyIfNeeded
//
//  Overview:  call apply on Transition worker if this is the first time in transition active
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransSink::ApplyIfNeeded()
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vb = VARIANT_FALSE;

    if (m_fHaveCalledApply || m_fInReset)
    {
        hr = S_OK;
        goto done;
    }

    if (!GetTimeNode())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(GetTimeNode()->get_isActive(&vb));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_spTransWorker && VARIANT_TRUE == vb)
    {
        PreApply();       
        hr = m_spTransWorker->Apply(m_eDXTQuickApplyType);
        PostApply();
        
        if (FAILED(hr))
        {
            goto done;
        }
        m_fHaveCalledApply = true;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransSink::CreateTimeBehavior
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransSink::CreateTimeBehavior()
{
    HRESULT hr = S_OK;

    hr = THR(::TECreateBehavior(L"TransSink", &m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTimeNode->addBehavior(this));

    if (FAILED(hr))
    {
        goto done;
    }

    // ##ISSUE: (mcalkins) This assert is fine, but we should make sure that we
    //          disable the object from inside once we realize we haven't
    //          populated our media site so that this assert will never fire
    //          under any conditions.

    Assert(!!m_spTransitionSite);

    hr = THR(m_spTransitionSite->get_timeParentNode(&m_spTimeParent));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionSite->get_node(&m_spMediaNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTimeParent->QueryInterface(IID_TO_PPV(ITIMEContainer, &m_spParentContainer)));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_spParentContainer->addNode(m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    // virtual call - children handle this.

    hr = THR(PopulateNode(m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInReset = true;

    hr = THR(m_spTimeNode->reset());

    m_fInReset = false;

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransSink::CreateTimeBehavior


HRESULT
CTIMETransSink::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr = S_OK;

    hr = THR(pNode->put_repeatCount(GetRepeatCountAttr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_dur(GetDurationAttr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_fill(TE_FILL_FREEZE));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_restart(TE_RESTART_WHEN_NOT_ACTIVE));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

void
CTIMETransSink::OnProgressChanged(double dblProgress)
{
    if (false == m_fPreventDueToFill)
    {
        IGNORE_HR(ApplyIfNeeded());
        CTIMETransBase::OnProgressChanged(dblProgress);
    }

    return;
}

STDMETHODIMP
CTIMETransSink::propNotify(DWORD tePropTypes)
{
    if (tePropTypes & TE_PROPERTY_PROGRESS)
    {
        double  dblProgressStart    = 0.0;
        double  dblProgressEnd      = 1.0;
        double  dblProgress         = 0.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgressStart    = m_DAStartProgress;
            dblProgressEnd      = m_DAEndProgress;
        }

        if (m_spTimeNode)
        {
            IGNORE_HR(m_spTimeNode->get_currProgress(&dblProgress));
        }

        dblProgress = ::InterpolateValues(dblProgressStart, 
                                          dblProgressEnd,
                                          dblProgress);

        if (!m_fDirectionForward)
        {
            dblProgress = 1.0 - dblProgress;
        }

        OnProgressChanged(dblProgress);
    }

    return S_OK;
}

STDMETHODIMP
CTIMETransSink::tick()
{
    return S_OK;
}

void
CTIMETransSink::OnBegin (void)
{
    HRESULT hr = S_OK;
    TE_FILL_FLAGS te_fill = TE_FILL_REMOVE;
    
    m_fPreventDueToFill = false;
    hr = m_spMediaNode->get_fill(&te_fill);
    if (FAILED(hr))
    {
        goto done;
    }

    if (TE_FILL_REMOVE == te_fill)
    {
        CTIMETransBase::OnBegin();
    }
    else
    {
        m_fPreventDueToFill = true;
    }

done :
    return;
} // CTIMETransSink::OnBegin

void
CTIMETransSink::OnEnd (void)
{
    if (false == m_fPreventDueToFill)
    {
        CTIMETransBase::OnEnd();
    }
    m_fPreventDueToFill = false;
} // CTIMETransSink::OnEnd

STDMETHODIMP
CTIMETransSink::eventNotify(double dblEventTime,
                            TE_EVENT_TYPE teEventType,
                            long lNewRepeatCount)
{
#ifdef DBG
    double dblParentTime, dblCurrTime;
    m_spTimeNode->get_currSimpleTime(&dblCurrTime);
    m_spTimeNode->activeTimeToParentTime(dblCurrTime, &dblParentTime);
#endif

    switch(teEventType)
    {
    case TE_EVENT_BEGIN:
        OnBegin();
        TraceTag((tagTransSinkEvents, 
                  "OnBegin parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    case TE_EVENT_END:
        OnEnd();
        TraceTag((tagTransSinkEvents,
                  "OnEnd parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    case TE_EVENT_REPEAT:
        OnRepeat();
        TraceTag((tagTransSinkEvents, 
                  "OnRepeat parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    default:
        break;
    }

    return S_OK;
}

STDMETHODIMP
CTIMETransSink::getSyncTime(double * dblNewSegmentTime,
                            LONG * lNewRepeatCount,
                            VARIANT_BOOL * bCueing)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include "headers.h"

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND); //lint !e666 !e522
                if (pTemp == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to realloc memory"));
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::Grow - EnsureSize() failed"));
        return hr;
    }

    // ISSUE - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    // bug #14220, ie6 
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::AppendIndirect - EnsureSize() failed!"));
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::InsertIndirect - EnsureSize() failed!"));
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - invalid param"));
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - EnsureSize() failed"));
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        TraceTag((tagError, "CBaseEnum::Init - invalid param"));
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = NEW CImplAry;
        if (rgCopy == NULL)
        {
            TraceTag((tagError, "CBaseEnum::Init - unable to alloc memory for new array class"));
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CBaseEnum::Init - Copy() failed"));
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{ //lint !e1538
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
    m_piid = NULL;
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
    CEnumGeneric();
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = NEW CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Create - unable to alloc memory for CEnumGeneric"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumGeneric::Next - invalid params"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumGeneric::Clone - EnumElements() failed"));
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);
    CEnumVARIANT();

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = NEW CEnumVARIANT(cb, vt, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Create - unable to alloc mem for CEnumVARIANT"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Create - Init() failed"));
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumVARIANT::Next - invalid param"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - EnumVARIANT() failed"));
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\transitions\transworker.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transworker.cpp
//
//  Classes:    CTIMETransitionWorker
//
//  History:
//  2000/07/??  jeffwall    Created.
//  2000/09/07  mcalkins    Use IDXTFilterController interface instead of
//                          IDXTFilter.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transworker.h"
#include "dxtransp.h"
#include "attr.h"
#include "tokens.h"
#include "transmap.h"
#include "..\timebvr\timeelmbase.h"
#include "..\timebvr\transdepend.h"

DeclareTag(tagTransitionWorkerTransformControl, "SMIL Transitions", "CTransitionWorker transform control")
DeclareTag(tagTransitionWorkerProgress, "SMIL Transitions", "CTransitionWorker progress")
DeclareTag(tagTransitionWorkerEvents, "SMIL Transitions", "CTransitionWorker events")

const LPWSTR    DEFAULT_M_TYPE          = NULL;
const LPWSTR    DEFAULT_M_SUBTYPE       = NULL;

class CTransitionDependencyManager;

class
ATL_NO_VTABLE
__declspec(uuid("aee68256-bd58-4fc5-a314-c43b40edb5fc"))
CTIMETransitionWorker :
  public CComObjectRootEx<CComSingleThreadModel>,
  public ITransitionWorker
{
public:

    CTIMETransitionWorker();
  
    // ITransitionWorker methods.

    STDMETHOD(InitFromTemplate)();
    STDMETHOD(InitStandalone)(VARIANT varType, VARIANT varSubtype);
    STDMETHOD(Detach)();
    STDMETHOD(put_transSite)(ITransitionSite * pTransElement);
    STDMETHOD(Apply)(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType);
    STDMETHOD(put_progress)(double dblProgress);
    STDMETHOD(get_progress)(double * pdblProgress);
    STDMETHOD(OnBeginTransition) (void);
    STDMETHOD(OnEndTransition) (void);

    // For Persisitence.

    CAttr<LPWSTR> & GetTypeAttr()           { return m_SAType; }
    CAttr<LPWSTR> & GetSubTypeAttr()        { return m_SASubType; }
    STDMETHOD(get_type)(VARIANT *type);        
    STDMETHOD(put_type)(VARIANT type);        
    STDMETHOD(get_subType)(VARIANT *subtype);        
    STDMETHOD(put_subType)(VARIANT subtype);        

    // QI Implementation.

    BEGIN_COM_MAP(CTIMETransitionWorker)
    END_COM_MAP();

protected:

    // Setup / teardown methods.

    bool    ReadyToInit();

    HRESULT PopulateFromTemplateElement();

    HRESULT AttachFilter();
    HRESULT DetachFilter();

    HRESULT ResolveDependents (void);

private:

    CComPtr<IDXTFilterCollection>   m_spDXTFilterCollection;
    CComPtr<IDXTFilterController>   m_spDXTFilterController;
    CComPtr<ITransitionSite>        m_spTransSite;
    
    HFILTER                         m_hFilter;
    DWORD                           m_dwFilterType;
    double                          m_dblLastFilterProgress;
    CTransitionDependencyManager    m_cDependents;

    static const WCHAR * const      s_astrInvalidTags[];
    static const unsigned int       s_cInvalidTags;

    unsigned                        m_fHaveCalledApply  : 1;

#ifdef DBG
    unsigned                        m_fHaveCalledInit   : 1;
    unsigned                        m_fInLoad           : 1;
#endif // DBG

    // attributes

    CAttr<LPWSTR>   m_SAType;
    CAttr<LPWSTR>   m_SASubType;

    static TIME_PERSISTENCE_MAP PersistenceMap[];
};


//+-----------------------------------------------------------------------------
//
// Static member variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * const CTIMETransitionWorker::s_astrInvalidTags[] = { 
    // Note: keep alphabetical order.
    L"applet",
    L"embed",
    L"object",
    L"option",
    L"select",
    L"tbody",
    L"tfoot",
    L"thead",
    L"tr"
};

const unsigned int CTIMETransitionWorker::s_cInvalidTags 
                = sizeof(s_astrInvalidTags) / sizeof(s_astrInvalidTags[0]);

//+-----------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------

#define TTE CTIMETransitionWorker

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TTE_Type,         TTE,    GetTypeAttr,         put_type,         get_type,            VARIANT);
TIME_PERSIST_FN(TTE_SubType,      TTE,    GetSubTypeAttr,      put_subType,      get_subType,         VARIANT);


//+-----------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMETransitionWorker)
                           // Attr Name     // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             TTE_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          TTE_SubType )

END_TIME_PERSISTENCE_MAP()


//+-----------------------------------------------------------------------------
//
//  Function: CreateTransitionWorker
//
//  Overview:  
//      Creates a CTIMETransitionWorker and returns a ITransitionWorker pointer
//
//  Arguments: 
//      ppTransWorker   where to put the pointer
//             
//------------------------------------------------------------------------------
HRESULT
CreateTransitionWorker(ITransitionWorker ** ppTransWorker)
{
    HRESULT hr;
    CComObject<CTIMETransitionWorker> * sptransWorker;

    hr = THR(CComObject<CTIMETransitionWorker>::CreateInstance(&sptransWorker));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (ppTransWorker)
    {
        *ppTransWorker = sptransWorker;
        (*ppTransWorker)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Function: CreateTransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::CTIMETransitionWorker
//
//  Overview:  
//      Initializes member variables
//
//------------------------------------------------------------------------------
CTIMETransitionWorker::CTIMETransitionWorker() :
    m_hFilter(NULL),
    m_dwFilterType(0),
    m_dblLastFilterProgress(0.0),
    m_fHaveCalledApply(false),
#ifdef DBG
    m_fHaveCalledInit(false),
    m_fInLoad(false),
#endif // DBG
    m_SAType(DEFAULT_M_TYPE),
    m_SASubType(DEFAULT_M_SUBTYPE)
{

}
//  Member: CTIMETransitionWorker::CTIMETransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_transSite
//
//  Arguments: 
//      pTransSite  TransitionSite Element to get data from
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_transSite(ITransitionSite * pTransSite)
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);
    Assert(m_spTransSite == NULL);

    m_spTransSite = pTransSite;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_transSite


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::ReadyToInit
//
//  Overview:  
//      Determines wether or not init can be done now.
//
//  Returns:   
//      bool    true if ok to init, false otherwise
//
//------------------------------------------------------------------------------
bool
CTIMETransitionWorker::ReadyToInit()
{
    bool bReady = false;

    if (m_spTransSite == NULL)
        goto done;

    bReady = true;
done:
    return bReady;
}
//  Member: CTIMETransitionWorker::ReadyToInit

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::InitStandalone
//
//  Overview:  
//      Initializes and sets up CTIMETransitionWorker - call once all of 
//      the properties have been set on ITransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::InitStandalone(VARIANT varType, VARIANT varSubtype)
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);

    if (!ReadyToInit())
    {
        hr = E_FAIL;
        goto done;
    }

    // Hook up type/subtype attributes.
    hr = THR(put_type(varType));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(put_subType(varSubtype));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(AttachFilter());
    if (FAILED(hr))
    {
        goto done;
    }

#ifdef DBG
    m_fHaveCalledInit = true;
#endif // DBG

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::InitStandalone

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::InitFromTemplate
//
//  Overview:  
//      Initializes and sets up CTIMETransitionWorker - call once all of 
//      the properties have been set on ITransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::InitFromTemplate()
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);

    if (!ReadyToInit())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(PopulateFromTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }
        
    hr = THR(AttachFilter());
    if (FAILED(hr))
    {
        goto done;
    }

#ifdef DBG
    m_fHaveCalledInit = true;
#endif // DBG

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::InitFromTemplate


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::Detach
//
//  Overview:  
//      Deinitializes CTIMETransitionWorker and detachs from extra interfaces
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::Detach()
{ 
    m_cDependents.ReleaseAllDependents();

    DetachFilter();

    m_spTransSite.Release();

    return S_OK;
}
//  Member: CTIMETransitionWorker::Detach


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::ResolveDependents
//
//  Overview:  
//      Retrieve the global list of pending transition dependents.  Evaluate 
//      each and determine whether they belong in our dependents list.  No item
//      will reside in both lists - either we assume responsibility 
//      for it, or we will leave it in the global list.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMETransitionWorker::ResolveDependents()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spHTMLElement;
    CComPtr<IHTMLElement> spHTMLBodyElement;
    CComPtr<ITIMEElement> spTIMEElement;
    CComPtr<ITIMETransitionDependencyMgr> spTIMETransitionDependencyMgr;

    Assert(true == m_fHaveCalledInit);

    if (m_spTransSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    // Get the target element

    hr = THR(m_spTransSite->get_htmlElement(&spHTMLElement));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::GetBodyElement(spHTMLElement, __uuidof(IHTMLElement), 
                          (void **)&spHTMLBodyElement);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::FindTIMEInterface(spHTMLBodyElement, &spTIMEElement);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spTIMEElement->QueryInterface(__uuidof(ITIMETransitionDependencyMgr), 
                                       (void **)&spTIMETransitionDependencyMgr);

    if (FAILED(hr))
    {
        goto done;
    }

    // Gather any new dependents from the global list.

    hr = spTIMETransitionDependencyMgr->EvaluateTransitionTarget(
                                        spHTMLElement,
                                        (void *)&m_cDependents);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
} 
//  Member: CTIMETransitionWorker::ResolveDependents


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::OnBeginTransition
//
//  Overview:  
//      Called when the transition owner believes the transition has 'begun'
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::OnBeginTransition(void)
{ 
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerEvents, 
              "CTIMETransitionWorker(%p)::OnBeginTransition()",
              this));

    IGNORE_HR(ResolveDependents());

    hr = THR(m_spDXTFilterController->SetEnabled(TRUE));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::OnBeginTransition


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::OnEndTransition
//
//  Overview:  
//      Called when the transition owner believes the transition has 'ended'
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::OnEndTransition(void)
{ 
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerEvents, 
              "CTIMETransitionWorker(%p)::OnEndTransition()",
              this));

    m_cDependents.NotifyAndReleaseDependents();

    hr = DetachFilter();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::OnEndTransition


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::PopulateFromTemplateElement
//
//  Overview:  
//      Persistence in from the template
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::PopulateFromTemplateElement()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spTemplate;

    hr = THR(m_spTransSite->get_template(&spTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(spTemplate != NULL);

#ifdef DBG
    m_fInLoad = true;
#endif // DBG

    hr = THR(::TimeElementLoad(this, CTIMETransitionWorker::PersistenceMap, spTemplate));

#ifdef DBG
    m_fInLoad = false;
#endif // DBG

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::PopulateFromTemplateElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::AttachFilter
//
//  Overview:  
//      Add the filter to the style of the html element and get back a pointer 
//      to the filter
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::AttachFilter()
{
    HRESULT         hr              = S_OK;
    HFILTER         hFilter         = NULL;
    BSTR            bstrType        = NULL;
    BSTR            bstrSubType     = NULL;
    BSTR            bstrFilter      = NULL;
    BSTR            bstrTagName     = NULL;
    WCHAR *         strFilter       = NULL;
    unsigned int    i               = 0;

    CComPtr<IHTMLElement>           spHTMLElement;
    CComPtr<IHTMLFiltersCollection> spFiltersCollection;   

    Assert(!m_spDXTFilterCollection);

    hr = THR(m_spTransSite->get_htmlElement(&spHTMLElement));

    if (FAILED(hr))
    {
        goto done;
    }

    // When filters are instantiated via CSS, the CSS code knows that certain
    // elements are not allowed to have filters on them.  Since we don't share
    // that code path with them we have to take on the same responsibility.
    // We ask for the tagname of the element so that we can refrain from
    // filtering element types that can't take filters.
    //
    // NOTE: (mcalkins) This is bad architecture, a new filters architecture
    // will have a central place for this info (or hopefully will just allow 
    // everything to be filtered), but for now be aware that this list may need
    // to be updated periodically.

    hr = THR(spHTMLElement->get_tagName(&bstrTagName));

    if (FAILED(hr))
    {
        goto done;
    }

    // Run through array of invalid tags to make sure we can instantiate this
    // behavior.
    
    for (i = 0; i < s_cInvalidTags; i++)
    {
        int n = StrCmpIW(s_astrInvalidTags[i], bstrTagName);

        if (0 == n)
        {
            // Our tag matches an invalid tag, don't instantiate behavior.

            hr = E_FAIL;

            goto done;
        }
        else if (n > 0)
        {
            // The invalid tag tested was higher than our tag so we've done
            // enough testing.

            break;
        }
    }
    
    hr = THR(spHTMLElement->get_filters(&spFiltersCollection));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(spFiltersCollection->QueryInterface(IID_TO_PPV(IDXTFilterCollection, 
                                                            &m_spDXTFilterCollection)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAType.GetString(&bstrType));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_SASubType.GetString(&bstrSubType));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::MapTypesToDXT(bstrType, bstrSubType, &strFilter));

    if (FAILED(hr))
    {
        goto done;
    }

    bstrFilter = SysAllocString(strFilter);

    if (NULL == bstrFilter)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    hr = THR(m_spDXTFilterCollection->AddFilter(bstrFilter, DXTFTF_PRIVATE, 
                                                &m_dwFilterType, &m_hFilter));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spDXTFilterCollection->GetFilterController(
                                                    m_hFilter,
                                                    &m_spDXTFilterController));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spDXTFilterController->SetEnabled(FALSE));

    if (FAILED(hr))
    {
        goto done;
    }

    // Since we're not using the classic Apply/Play behavior, we don't want the
    // filter to attempt to control the visibility of the element in any way.

    hr = THR(m_spDXTFilterController->SetFilterControlsVisibility(FALSE));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    if (FAILED(hr))
    {
        DetachFilter();
    }

    delete [] strFilter;

    ::SysFreeString(bstrFilter);
    ::SysFreeString(bstrTagName);
    SysFreeString(bstrType);
    SysFreeString(bstrSubType);
    
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::AttachFilter


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::DetachFilter
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::DetachFilter()
{
    HRESULT hr = S_OK;

    if (m_hFilter)
    {
        Assert(!!m_spDXTFilterCollection);

        hr = m_spDXTFilterCollection->RemoveFilter(m_hFilter);
    
        if (FAILED(hr))
        {
            goto done;
        }

        m_hFilter = 0;
    }

    hr = S_OK;

done:

    m_spDXTFilterController.Release();
    m_spDXTFilterCollection.Release();

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::DetachFilter


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::Apply, ITransitionWorker
//
//  Parameters:
//      eDXTQuickApplyType  Is this a transition in or a transition out?
//
//  Overview:  
//      Setup the Transition by taking a snapshot and adjusting visibility
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::Apply(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType)
{
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerTransformControl, "CTIMETransitionWorker::Apply()"));

    Assert(!!m_spDXTFilterController);
    Assert(!m_fHaveCalledApply);

    if (m_fHaveCalledApply)
    {
        goto done;
    }

    hr = THR(m_spDXTFilterController->QuickApply(eDXTQuickApplyType, 
                                                 NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fHaveCalledApply  = true;
    hr                  = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::Apply, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_progress, ITransitionWorker
//
//  Overview:  
//      Handle progress changes by calculating filter progress and passing onto 
//      the dxfilter if needed.
//
//  Arguments: 
//      dblProgress = [0,1]
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_progress(double dblProgress)
{
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerProgress, 
              "CTIMETransitionWorker::put_progress(%g)", dblProgress));

    // If the transition has ended, we will have released the filter controller
    // and can safely ignore this progress notification.

    if (!m_spDXTFilterController)
    {
        goto done;
    }

    if (   m_fHaveCalledApply
        && (m_dblLastFilterProgress != dblProgress))
    {
        hr = m_spDXTFilterController->SetProgress(
                                            static_cast<float>(dblProgress));

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_progress, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_progress, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_progress(double * pdblProgress)
{
    HRESULT hr = S_OK;

    if (NULL == pdblProgress)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    TraceTag((tagTransitionWorkerProgress, 
              "CTIMETransitionWorker::get_progress(%g)", m_dblLastFilterProgress));

    *pdblProgress = m_dblLastFilterProgress;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::get_progress, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_type, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_type(VARIANT *type)
{
    return E_NOTIMPL;
}
//  Member: CTIMETransitionWorker::get_type, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_type, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_type(VARIANT type)
{
    HRESULT hr = S_OK;

    Assert(VT_BSTR == type.vt);

    hr = THR(m_SAType.SetString(type.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_type, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_subType, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_subType(VARIANT *subtype)
{
    return E_NOTIMPL;
}
//  Member: CTIMETransitionWorker::get_subType, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_subType, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_subType(VARIANT subtype)
{
    HRESULT hr = S_OK;

    Assert(VT_BSTR == subtype.vt);

    hr = THR(m_SASubType.SetString(subtype.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_subType, ITransitionWorker
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\comutil.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: comutil.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "comutil.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEComTypeInfoHolder

void CTIMEComTypeInfoHolder::AddRef()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        m_dwRef++;
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CTIMEComTypeInfoHolder::Release()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (--m_dwRef == 0)
        {
                if (m_pInfo != NULL)
                        m_pInfo->Release();
                m_pInfo = NULL;
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CTIMEComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    _ASSERTE(m_pguid != NULL);
    _ASSERTE(ppInfo != NULL);
    USES_CONVERSION; //lint !e522
    *ppInfo = NULL;

    HRESULT hRes = E_FAIL;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (m_pInfo == NULL)
    {
        TCHAR szModule[MAX_PATH];

        GetModuleFileName(_Module.m_hInstTypeLib, szModule, MAX_PATH);

        if (m_ptszIndex != NULL)
        {
            PathAppend(szModule, m_ptszIndex);
        }
            
        ITypeLib* pTypeLib;
        LPOLESTR lpszModule = T2OLE(szModule);
        hRes = LoadTypeLib(lpszModule, &pTypeLib);

        if (SUCCEEDED(hRes))
        {
            ITypeInfo* pTypeInfo;
            hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
            if (SUCCEEDED(hRes))
            {
                m_pInfo = pTypeInfo;
            }
            pTypeLib->Release();
        }
    }
    *ppInfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hRes = S_OK;
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
} //lint !e550

HRESULT CTIMEComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
        ITypeInfo** pptinfo)
{
        HRESULT hRes = E_POINTER;
        if (pptinfo != NULL)
                hRes = GetTI(lcid, pptinfo);
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
        UINT cNames, LCID lcid, DISPID* rgdispid)
{
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                pInfo->Release();
        }
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        SetErrorInfo(0, NULL);
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                pInfo->Release();
        }
        return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\basebvr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\basebvr.cpp
//
//  Contents: DHTML Behavior base class
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "basebvr.h"

DeclareTag(tagBaseBvr, "TIME: Behavior", "CBaseBvr methods")

CBaseBvr::CBaseBvr() :
    m_clsid(GUID_NULL),
    m_fPropertiesDirty(true),
    m_fIsIE4(false)
{

    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::CBaseBvr()",
              this));
}

CBaseBvr::~CBaseBvr()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::~CBaseBvr()",
              this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehavior
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CBaseBvr::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr = S_OK; 
    CComPtr<IDispatch> pIDispatch;

    if (pBehaviorSite == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    hr = THR(pBehaviorSite->GetElement(&m_pHTMLEle));
    if (FAILED(hr))
    {
        goto done;
    }

    // First thing we do is see if this behavior was already added

    if (IsBehaviorAttached())
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    m_pBvrSite = pBehaviorSite;

    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &m_pBvrSiteOM);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterUrn((LPWSTR) GetBehaviorURN());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterName((LPWSTR) GetBehaviorName());
    if (FAILED(hr))
    {
        goto done;
    }

    {
        CComPtr<IHTMLElement2> spElement2;
        hr = THR(m_pHTMLEle->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
        if (FAILED(hr))
        {
            // IE4 path
            m_fIsIE4 = true;
        }
    }
  
    hr = THR(m_pBvrSite->QueryInterface(IID_IServiceProvider, (void **)&m_pSp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pHTMLEle->get_document(&pIDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pIDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&m_pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // Do not set the init flag since it will be set by the first
    // notify which we want to skip
    
  done:
    if (S_OK != hr)
    {
        // release all
        m_pBvrSite.Release();
        m_pBvrSiteOM.Release();
        m_pHTMLEle.Release();
        m_pHTMLDoc.Release();
        m_pSp.Release();
    }
    
    return hr;
} // Init
   
STDMETHODIMP
CBaseBvr::Notify(LONG, VARIANT *)
{
    return S_OK;
}

STDMETHODIMP
CBaseBvr::Detach()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Detach()",
              this));

    m_pBvrSite.Release();
    m_pBvrSiteOM.Release();
    m_pHTMLEle.Release();
    m_pHTMLDoc.Release();
    m_pSp.Release();
    
    return S_OK;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::GetClassID, IPersistPropertyBag2
//
//  Synopsis:   Returns the CLSID of the object
//
//  Arguments:  pclsid      output variable
//
//  Returns:    S_OK        if pclsid is valid
//              E_POINTER   if pclsid is not valid
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::GetClassID(CLSID* pclsid)
{
    if (NULL == pclsid)
    {
        return E_POINTER;
    }
    *pclsid = m_clsid;
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::InitNew, IPersistPropertyBag2
//
//  Synopsis:   See Docs for IPersistPropertyBag2
//
//  Arguments:  None
//
//  Returns:    S_OK        Always
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::InitNew(void)
{
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::IsDirty, IPersistPropertyBag2
//
//  Synopsis:   See Docs for IPersistPropertyBag2
//
//  Arguments:  None
//
//  Returns:    S_OK        Always
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::IsDirty(void)
{
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::Load, IPersistPropertyBag2
//
//  Synopsis:   Loads the behavior specific attributes from Trident
//
//  Arguments:  See Docs for IPersistPropertyBag2
//
//  Returns:    Failure     when a fatal error error has occured (i.e. behavior cannot run)
//              S_OK        All other cases
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    // allow derived class to do something after we have successfully loaded
    IGNORE_HR(OnPropertiesLoaded());
    return S_OK;
} // Load

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::Save, IPersistPropertyBag2
//
//  Synopsis:   Saves the behavior specific attributes to Trident
//
//  Arguments:  See Docs for IPersistPropertyBag2
//
//  Returns:    Failure     when a fatal error (behavior cannot run) has occured
//              S_OK        All other cases
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }
    return S_OK;
} // Save


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Notification Helpers
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    void
//
//------------------------------------------------------------------------------------

void
CBaseBvr::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IEnumConnections> pEnum;

    {
        CComPtr<IConnectionPoint> pICP;

        m_fPropertiesDirty = true;
        hr = THR(GetConnectionPoint(IID_IPropertyNotifySink, &pICP));
        if (FAILED(hr) || !pICP)
        {
            goto done;
        }
        
        hr = THR(pICP->EnumConnections(&pEnum));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    CONNECTDATA cdata;
    hr = THR(pEnum->Next(1, &cdata, NULL));
    while (hr == S_OK)
    {
        // check cdata for the object we need
        CComPtr<IPropertyNotifySink> pNotify;
        hr = THR(cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify)));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pNotify->OnChanged(dispid));
        if (FAILED(hr))
        {
            goto done;
        }

        // and get the next enumeration
        hr = THR(pEnum->Next(1, &cdata, NULL));
    }

  done:
    return;
} // NotifyPropertyChanged

//
// IServiceProvider interfaces
//
STDMETHODIMP
CBaseBvr::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        CComPtr<IHTMLWindow2> wnd;

        if (SUCCEEDED(THR(m_pHTMLDoc->get_parentWindow(&wnd))))
        {
            if (wnd)
            {
                if (SUCCEEDED(wnd->QueryInterface(riid, ppv)))
                {
                    return S_OK;
                }
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\atomtable.cpp ===
//************************************************************
//
// FileName:        atomtbl.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Implementation of CAtomTable.
//************************************************************

#include "headers.h"
#include "atomtable.h"


// CAtomTable is used as a static object by CTIMEElementBase and needs to be 
// thread safe since we can have multiple trident threads in the same process
static CritSect g_AtomTableCriticalSection;

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        constructor
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CAtomTable::CAtomTable() :
    m_rgNames(NULL),
    m_lRefCount(0)
{
} // CAtomTable

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        destructor
//************************************************************

CAtomTable::~CAtomTable()
{
    if (m_rgNames)
    {
        // loop thru and release memory
        long lSize = m_rgNames->Size();
        for(long lIndex = 0; lIndex < lSize; lIndex++)
        {
            SysFreeString((*m_rgNames)[lIndex]);
        }

        delete m_rgNames;
        m_rgNames = NULL;
    }
} // ~CAtomTable

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    
//************************************************************

HRESULT
CAtomTable::AddNameToAtomTable(const WCHAR *pwszName, 
                               long        *plOffset)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Invalid param"));
        return E_INVALIDARG;
    }
    
    *plOffset = 0;
    
    // check to see if array is initialized
    if (m_rgNames == NULL)
    {
        m_rgNames = NEW CPtrAry<BSTR>;
        if (m_rgNames == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    g_AtomTableCriticalSection.Release();
    HRESULT hr = GetAtomFromName(pwszName, plOffset);
    g_AtomTableCriticalSection.Grab();

    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        BSTR bstrName = SysAllocString(pwszName);
        if (bstrName == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for string"));
            return E_OUTOFMEMORY;
        }

        // add to table
        hr = m_rgNames->Append(bstrName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - unable to add string to table"));
            SysFreeString(bstrName);
            return hr;
        }

        // calc offset
        *plOffset = m_rgNames->Size() - 1;
    }

    // otherwise return the results of FindAtom
    return hr;
} // AddNameToAtomTable


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given a name, return the index
//************************************************************

HRESULT
CAtomTable::GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    // validate out param
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::GetAtomFromName - Invalid param"));
        return E_INVALIDARG;
    }

    // init param
    *plOffset = 0;

    // loop thru table looking for a match
    long   lSize  = m_rgNames->Size();
    BSTR  *ppItem = *m_rgNames;

    for (long lIndex = 0; lIndex < lSize; lIndex++, ppItem++)
    {
        Assert(*ppItem);

        if (StrCmpW(pwszName, (*ppItem)) == 0)
        {
            *plOffset = lIndex;
            return S_OK;
        }
    }

    // not found
    return DISP_E_MEMBERNOTFOUND;
} // GetAtomFromName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, return the contents
//************************************************************

HRESULT 
CAtomTable::GetNameFromAtom(long lOffset, const WCHAR **ppwszName)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    // validate out param
    if (ppwszName == NULL)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid param"));
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    // check for empty table
    if (m_rgNames->Size() == 0)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - table is empty"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // check to make sure we are in range
    if ((lOffset < 0) || 
        (lOffset >= m_rgNames->Size()))
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid index"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // set IDispatch
    *ppwszName = (*m_rgNames)[lOffset];
    return S_OK;
} // GetNameFromAtom

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\attr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: attr.cpp
//
//  Contents: persistable attribute classes and utilities
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "attr.h"


//+-------------------------------------------------------------------------------------
//
// CAttrBase
//
//--------------------------------------------------------------------------------------

CAttrBase::CAttrBase() :
    m_pstrAttr(NULL),
    m_fSet(false)
{
    // do nothing
}

void 
CAttrBase::ClearString()
{
    delete [] m_pstrAttr;
    m_pstrAttr = NULL;
}

CAttrBase::~CAttrBase()
{
    ClearString();
} //lint !e1740

    
// This is for setting the persisted string
HRESULT
CAttrBase::SetString(BSTR bstrAttr)
{
    if (NULL == bstrAttr)
    {
        ClearString();
    }
    else
    {
        LPWSTR pstrTemp = CopyString(bstrAttr);
        if (NULL == pstrTemp)
        {
            return E_OUTOFMEMORY;
        }
        delete [] m_pstrAttr;
        m_pstrAttr = pstrTemp;
    }

    return S_OK;
}

// This is for getting the persisted string
// returns null if string not available
HRESULT
CAttrBase::GetString(BSTR * pbstrAttr)
{
    if (NULL == pbstrAttr)
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pstrAttr)
    {
        *pbstrAttr = NULL;
    }
    else
    {
        *pbstrAttr = SysAllocString(m_pstrAttr);
        if (NULL == *pbstrAttr)
        {
            return E_OUTOFMEMORY;
        }
    }
    
    return S_OK;
}

// This is for use of persistence macros only! Uses the storage passed in (does not allocate).
void 
CAttrBase::SetStringFromPersistenceMacro(LPWSTR pstrAttr)
{
    delete [] m_pstrAttr;
    m_pstrAttr = pstrAttr;
}

CAttrString::CAttrString(LPWSTR val) : 
  m_pszVal(NULL)
{
    IGNORE_HR(SetValue(val));
}

CAttrString::~CAttrString()
{
    delete [] m_pszVal;
    m_pszVal = NULL;
}

HRESULT
CAttrString::SetValue(LPWSTR val)
{
    delete [] m_pszVal;
    m_pszVal = NULL;

    if (val)
    {
        m_pszVal = ::CopyString(val);
        if (NULL == m_pszVal)
        {
            TraceTag((tagError, "Out of memory!"));
            return E_OUTOFMEMORY;
        }
        MarkAsSet();
    }
    return S_OK;
}

BSTR
CAttrString::GetValue()
{
    if (m_pszVal)
    {
        return ::SysAllocString(m_pszVal);
    }
    return NULL;
}

void
CAttrString::MarkAsSet()
{
    ClearString();
    SetFlag(true);
}


//+-------------------------------------------------------------------------------------
//
// Persistence helpers
//
//--------------------------------------------------------------------------------------


HRESULT
TimeLoad(void *                 pvObj, 
         TIME_PERSISTENCE_MAP   PersistenceMap[], 
         IPropertyBag2 *        pPropBag,
         IErrorLog *            pErrorLog)
{
    HRESULT hr;
    HRESULT hrres = S_OK;
    int i;
    PROPBAG2 propbag;
    VARIANT var;

    CHECK_RETURN_NULL(pPropBag);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);
    propbag.vt = VT_BSTR;

    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        VariantInit(&var);
        // read one attr at a time
        propbag.pstrName = PersistenceMap[i].pstrName;
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // ensure it is a BSTR
            hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                // use the global persistence funtion to set the attribute on the OM
                hr = (PersistenceMap[i].pfnPersist)(pvObj, &var, true);
                //
                // dilipk: do we need to log errors here?
                //
            }
            VariantClear(&var);
        }
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
TimeSave(void *                 pvObj, 
         TIME_PERSISTENCE_MAP   PersistenceMap[], 
         IPropertyBag2 *        pPropBag, 
         BOOL                   fClearDirty, 
         BOOL                   fSaveAllProperties)
{
    HRESULT hr;
    PROPBAG2 propbag;
    CComVariant var;
    int i;

    CHECK_RETURN_NULL(pPropBag);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);

    //
    // dilipk: Need to support fClearDirty. Currently, IsDirty() always returns S_OK.
    //

    propbag.vt = VT_BSTR;
    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        // Get the string value
        hr = THR((PersistenceMap[i].pfnPersist)(pvObj, &var, false));
        if (SUCCEEDED(hr) && (VT_NULL != V_VT(&var)))
        {
            // Write the attribute
            propbag.pstrName = PersistenceMap[i].pstrName;
            hr = THR(pPropBag->Write(1, &propbag, &var));
        }
        var.Clear();
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
TimeElementLoad(void *                 pvObj, 
                TIME_PERSISTENCE_MAP   PersistenceMap[], 
                IHTMLElement *         pElement)
{
    HRESULT hr;
    int i;
    VARIANT var;

    CHECK_RETURN_NULL(pElement);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);

    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        VariantInit(&var);
        CComBSTR bstrName(PersistenceMap[i].pstrName);

        hr = pElement->getAttribute(bstrName, 0, &var);

        if (SUCCEEDED(hr) && VT_NULL != var.vt)
        {
            // ensure it is a BSTR
            hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                // use the global persistence funtion to set the attribute on the OM
                hr = (PersistenceMap[i].pfnPersist)(pvObj, &var, true);
            }
            VariantClear(&var);
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\dlldatax.c ===
// wrapper for dlldata.c

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400     //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY      //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "mstimepdlldata.c"
#include "mstimep_p.c"

#undef DllMain
#undef DllRegisterServer
#undef DllUnRegisterServer
#undef DllGetClassObject
#undef DllCanUnloadNow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\clock.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "clock.h"

static LPCTSTR s_rgtchStarvationWindowClassName = _T("StarveTimer");
static LPCTSTR s_rgtchStarvationWindowName = _T("");

static const ULONG s_ulStarveCallbackInterval = 100;
static const ULONG s_ulStarvationThreshold = 150;
static const ULONG s_ulOptimalThreshold = 90;
static const ULONG s_ulStarvationBackoffConstant = 2;
static const ULONG s_ulStarvationIncreaseConstant = 1;


DeclareTag(tagClock, "TIME: Clock", "Clock methods")
DeclareTag(tagClockStarvation, "TIME: Clock", "Clock starvation")

Clock::Clock()
: m_ulRefs(1),
  m_cookie(0),
  m_lastTime(0.0),
  m_curTime(0.0),
  m_ulLastStarvationCallback(0),
  m_uStarveTimerID(0),
  m_hWndStarveTimer(NULL),
  m_lConsectiveStarvedTicks(0),
  m_fAllowOnTimer(true),
  m_fAllowStarvationCallback(true),
  m_state(CS_STOPPED),
  m_pClockSink(NULL),
  m_interval(0)
{
    TraceTag((tagClock,
              "Clock(%lx)::Clock()",
              this));
}

Clock::~Clock()
{
    TraceTag((tagClock,
              "Clock(%lx)::~Clock()",
              this));

    Stop();

    if (NULL != m_hWndStarveTimer)
    {
        ::DestroyWindow(m_hWndStarveTimer);
    }

    m_pClockSink = NULL;
    m_hWndStarveTimer = NULL;
}

STDMETHODIMP
Clock::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_POINTER;

    if (ppv != NULL)
    {
        hr = E_NOINTERFACE;
        
        if (::IsEqualIID(riid, IID_ITimerSink) ||
            ::IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = (ITimerSink *)this;
            AddRef();
            hr  = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG)
Clock::AddRef(void)
{
    return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
Clock::Release(void)
{
    if (--m_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return m_ulRefs;
}

ULONG
Clock::GetNextInterval (void)
{
    ULONG ulInterval = m_interval;

    // If this is our first time through, 
    // we'll use the interval without question
    if (0 != m_ulLastStarvationCallback)
    {
        // How long since our last starvation callback?
        Assert(m_timer != NULL);

        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));

            if (SUCCEEDED(hr))
            {
                // Have we hit the starvation threshold?  Also allow for the unlikely clock rollover.
                ULONG ulTimeSinceLastStarvationCallback = V_UI4(&v) - m_ulLastStarvationCallback;

                if ((m_ulLastStarvationCallback > V_UI4(&v)) ||
                    (ulTimeSinceLastStarvationCallback > s_ulStarvationThreshold))
                {
                    if (m_lConsectiveStarvedTicks < 0)
                    {
                        m_lConsectiveStarvedTicks = 0;
                    }
                    m_lConsectiveStarvedTicks++;
                    if (m_lConsectiveStarvedTicks > 5)
                    {
                        ulInterval = min(100, ulInterval + s_ulStarvationBackoffConstant);
                        m_lConsectiveStarvedTicks = 0;
                        TraceTag((tagClockStarvation,
                                  "Clock(%p)::Clock(starvation detected, increased interval = %ul)",
                                  this, ulInterval));
                    }
                }
                // Make sure to clear the starved tick count.
                else if ((ulTimeSinceLastStarvationCallback < s_ulOptimalThreshold))
                {
                    if (m_lConsectiveStarvedTicks > 0)
                    {
                        m_lConsectiveStarvedTicks = 0;
                    }
                    m_lConsectiveStarvedTicks--;
                    if (m_lConsectiveStarvedTicks < -5)
                    {
                        ulInterval = max (10, ulInterval - s_ulStarvationIncreaseConstant);
                        m_lConsectiveStarvedTicks = 0;
                        TraceTag((tagClockStarvation,
                                  "Clock(%p)::Clock(no starvation, decreased interval = %ul)",
                                  this, ulInterval));
                    }
                }
                else
                {
                    m_lConsectiveStarvedTicks = 0;
                }
            }
        }
    }

    m_interval = ulInterval;
    return ulInterval;
} // GetNextInterval

STDMETHODIMP
Clock::OnTimer(VARIANT timeAdvise)
{
    HRESULT hr = S_OK;

    // default to 5 milliseconds for next interval
    ULONG ulNextInterval = 5;

    // We have to protect ourselves against 
    // advise sink reentrancy.
    if (m_fAllowOnTimer)
    {
        m_fAllowOnTimer = false;
        // The 'cookie' expires as soon as this
        // callback occurs.
        m_cookie = 0;
        ProcessCB(GetITimerTime());
        // Adjust the new interval based on 
        // current load.
        ulNextInterval = GetNextInterval();
        m_fAllowOnTimer = true;
    }

    hr = THR(SetNextTimerInterval(ulNextInterval));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
Clock::SetITimer(IServiceProvider * serviceProvider, ULONG interval)
{
    HRESULT hr;

    CComPtr<ITimerService> pTimerService;

    if (m_timer)
    {
        m_timer.Release();
    }

    m_interval = interval;
    
    if (!serviceProvider)
    {
        return E_FAIL;
    }
    
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

double
Clock::GetITimerTime()
{
    Assert(m_timer != NULL);

    CComVariant v;
    
    HRESULT hr = S_OK;
    
    if (m_timer)
    {
        hr = THR(m_timer->GetTime(&v));
    }
    else
    {
        return 0.0;
    }

    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return 0.0;
    }

    hr = THR(v.ChangeType(VT_R8));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return 0.0;
    }

    return (V_R8(&v) / 1000.0);
}

void
Clock::CreateStarveTimerWindow (void)
{
    Assert(NULL == m_hWndStarveTimer);
    if (NULL == m_hWndStarveTimer)
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = Clock::StarveWndProc;
        wndclass.hInstance     = _Module.GetModuleInstance();
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;
        wndclass.lpszClassName = s_rgtchStarvationWindowClassName;
        ::RegisterClass(&wndclass);
        
        m_hWndStarveTimer = ::CreateWindowEx(
            WS_EX_TOOLWINDOW,
            s_rgtchStarvationWindowClassName,
            s_rgtchStarvationWindowName,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            wndclass.hInstance,
            (LPVOID)NULL);
        if (NULL != m_hWndStarveTimer)
        {
            ::SetWindowLongPtr(m_hWndStarveTimer, GWLP_USERDATA, (LONG_PTR)this);
        }
    }
} // CreateStarveTimerWindow

void
Clock::SetStarveTimer (void)
{
    // Create the window on demand.
    if (NULL == m_hWndStarveTimer)
    {
        CreateStarveTimerWindow();
    }

    Assert(NULL != m_hWndStarveTimer);
    if (NULL != m_hWndStarveTimer)
    {
        // Make sure to roll past zero.
        if (0 == (++m_uStarveTimerID))
        {
            ++m_uStarveTimerID;
        }
        UINT uRes = ::SetTimer(m_hWndStarveTimer, m_uStarveTimerID, s_ulStarveCallbackInterval, NULL);
        Assert(0 != uRes);
    } //lint !e529
} // SetStarveTimer

HRESULT
Clock::StartITimer()
{
    // This initializes starvation timer as well 
    // as the last-callback-time data, giving us a baseline 
    // from which to judge starvation at startup.
    StarvationCallback();

    return SetNextTimerInterval(m_interval);
} // StartITimer

HRESULT
Clock::SetNextTimerInterval (ULONG ulNextInterval)
{
    HRESULT hr = S_OK;
    
    // Next, get the current time and with the interval set
    // the timer to advise us again.
    VARIANT vtimeMin, vtimeMax, vtimeInt;

    VariantInit( &vtimeMin );
    VariantInit( &vtimeMax );
    VariantInit( &vtimeInt );
    V_VT(&vtimeMin) = VT_UI4;
    V_VT(&vtimeMax) = VT_UI4;
    V_VT(&vtimeInt) = VT_UI4;
    V_UI4(&vtimeMax) = 0;
    V_UI4(&vtimeInt) = 0;

    if (m_timer)
    {
        hr = THR(m_timer->GetTime(&vtimeMin));
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (FAILED(hr))
    {
        goto done;
    }

    V_UI4(&vtimeMin) += ulNextInterval;

    if (m_timer)
    {
        hr = THR(m_timer->Advise(vtimeMin,
                                 vtimeMax,
                                 vtimeInt,
                                 0,
                                 this,
                                 &m_cookie));
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_cookie)
    {
        TraceTag((tagError,
                  "Clock::ITimer::Advise failed with bad cookie"));
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
    
  done:
    return hr;
} // SetNextTimerInterval

HRESULT
Clock::StopITimer()
{
    HRESULT hr = S_OK;
    
    if (m_timer && m_cookie)
    {
        hr = THR(m_timer->Unadvise(m_cookie));

        m_cookie = 0;
    }

    // Stop the starvation timer and 
    // reset the last starvation callback time.
    if (0 != m_uStarveTimerID)
    {
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        m_uStarveTimerID = 0;
    }
    m_ulLastStarvationCallback = 0;

    return hr;
}

HRESULT
Clock::Start()
{
    HRESULT hr;
    
    Stop();

    if (!m_timer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }

    m_curTime = 0.0;
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
Clock::Pause()
{
    HRESULT hr;

    if (m_state == CS_PAUSED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STARTED)
    {
        hr = THR(StopITimer());

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_state = CS_PAUSED;
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Resume()
{
    HRESULT hr;

    if (m_state == CS_STARTED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STOPPED)
    {
        hr = THR(Start());
        goto done;
    }
    
    Assert(m_state == CS_PAUSED);

    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }
    
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Stop()
{
    THR(StopITimer());
    m_state = CS_STOPPED;
    return S_OK;
}

void
Clock::ProcessCB(double time)
{
    if (m_state == CS_STARTED)
    {
        if (time > m_lastTime)
        {
            m_curTime += (time - m_lastTime);
            m_lastTime = time;

            if (m_pClockSink)
            {
                m_pClockSink->OnTimer(m_curTime);
            }
        }
    }
}

void WINAPI
Clock::StarvationCallback (void)
{
    if (m_fAllowStarvationCallback)
    {
        m_fAllowStarvationCallback = false;
        Assert(m_timer != NULL);

        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));
            if (SUCCEEDED(hr))
            {
                m_ulLastStarvationCallback = V_UI4(&v);
            }
        }
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        SetStarveTimer();
        m_fAllowStarvationCallback = true;
    }
} // StarvationCallback 

LRESULT __stdcall 
Clock::StarveWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        Clock *pThis = reinterpret_cast<Clock *>(::GetWindowLongPtr(hWnd, GWLP_USERDATA));

        if (NULL != pThis)
        {
            pThis->StarvationCallback();
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
} // StarveWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\importman.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\importman.cpp
//
//  Contents: implementation of CImportManager and CImportManagerList
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "importman.h"

DeclareTag(tagSyncDownload, "TIME: Import", "Use synchronous imports");
DeclareTag(tagTIMEImportManager, "TIME: ImportManager", "Import manager messages");

//
// Initialization
//

static CImportManager* g_pImportManager = NULL;
static CAtomTable * g_pAtomTable = NULL;

static const TCHAR pchHandleName[] = _T("CImportManager Thread Started OK event");


// thread startup function
unsigned long static _stdcall ThreadStartFunc(void * pvoidList); //lint !e10

//+-----------------------------------------------------------------------
//
//  Function:  InitializeModule_ImportManager
//
//  Overview:  Creates and initializes import manager class.  
//              Expected to be called exactly once per COM instantion
//
//  Arguments: void
//             
//  Returns:   true if created, otherwise false
//
//------------------------------------------------------------------------
bool
InitializeModule_ImportManager(void)
{
    HRESULT hr = S_OK;

    Assert(NULL == g_pImportManager);

    g_pAtomTable = new CAtomTable;
    if (NULL == g_pAtomTable)
    {
        return false;
    }
    g_pAtomTable->AddRef();

    g_pImportManager = new CImportManager;
    if (NULL == g_pImportManager)
    {
        return false;
    }
    
    hr = THR(g_pImportManager->Init());
    if (FAILED(hr))
    {
        IGNORE_HR(g_pImportManager->Detach());
        delete g_pImportManager;
        g_pImportManager = NULL;
        return false;
    }

    return true;
}

//+-----------------------------------------------------------------------
//
//  Function:  DeInitializeModule_ImportManager
//
//  Overview:  Deinializes and destroys import manager
//
//  Arguments: bShutdown    whether or not this is a shutdown, not used
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
DeinitializeModule_ImportManager(bool bShutdown)
{
    if (NULL != g_pImportManager)
    {
        IGNORE_HR(g_pImportManager->Detach());
    }

    if (NULL != g_pAtomTable)
    {
        g_pAtomTable->Release();
        g_pAtomTable = NULL;
    }

    delete g_pImportManager;
    g_pImportManager = NULL;
}


//+-----------------------------------------------------------------------
//
//  Function:  GetImportManager
//
//  Overview:  Controlled method for accessing global import manager
//
//  Arguments: void
//             
//
//  Returns:   pointer to import manager
//
//------------------------------------------------------------------------
CImportManager* GetImportManager(void)
{
    Assert(NULL != g_pImportManager);
    return g_pImportManager;
}

//+-----------------------------------------------------------------------
//
//  Member:    CImportManager::CImportManager
//
//  Overview:  Constructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImportManager::CImportManager() :   
    m_pList(NULL),
    m_lThreadsStarted(0)
{
    memset(m_handleThread, NULL, sizeof(m_handleThread));
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImportManager
//
//  Overview:  Destructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImportManager::~CImportManager()
{
    ReleaseInterface(m_pList);
}

//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Overview:  Creates and initializes threadsafelist class
//
//  Arguments: void
//             
//
//  Returns:   S_OK is ok, otherwise E_OUTOFMEMORY, or error from init
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Init()
{
    HRESULT hr = S_OK;

    m_pList = new CImportManagerList;
    if (NULL == m_pList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pList->AddRef();

    hr = THR(m_pList->Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  CreateOneThread
//
//  Overview:  Creates exactly one thread and returns the handle to it.
//
//  Arguments: pHandle, where to store thread handle
//             pList, pointer to list to pass to thread
//
//  Returns:   S_OK if thread is created
//
//------------------------------------------------------------------------
HRESULT
CreateOneThread(HANDLE * pHandle, CImportManagerList * pList)
{
    Assert(NULL != pHandle);
    Assert(NULL != pList);
    
    HRESULT hr = S_OK;
    DWORD dwThreadID = 0;
    HANDLE handleThreadStartedEvent = NULL;
    HANDLE handleThread = NULL;

    *pHandle = NULL;
    
    handleThreadStartedEvent = CreateEvent(NULL, FALSE, FALSE, pchHandleName);
    if (NULL == handleThreadStartedEvent)
    {
        hr = E_FAIL;
        goto done;
    }

    handleThread = CreateThread(NULL, 0, ThreadStartFunc, reinterpret_cast<void*>(pList), 0, &dwThreadID); //lint !e40
    if (NULL == handleThread)
    {
        hr = E_FAIL;
        goto done; // is this correct?  need to clean up threads / or (destuctor / detach) handles it?
    }
    
    {            
        HANDLE handleArray[] = { handleThread, handleThreadStartedEvent};
        DWORD dwSignaledObject = NULL;

        // don't msgwaitformultiple here -- this code is not reentrant.
        dwSignaledObject = WaitForMultipleObjectsEx(ARRAY_SIZE(handleArray), handleArray, FALSE, TIMEOUT, FALSE);

        if (-1 == dwSignaledObject)
        {
            hr = E_FAIL;
            goto done;
        }
            
        if (WAIT_TIMEOUT == dwSignaledObject)
        {
            // 30 seconds timed out waiting for a thread to start!
            hr = E_FAIL;
            Assert(false);
            goto done;
        }                

        dwSignaledObject -= WAIT_OBJECT_0;
        if (0 == dwSignaledObject)
        {
            // the thread died before the event was signalled.
            hr = E_FAIL;
            goto done;
        }
    }
    
    *pHandle = handleThread;

    hr = S_OK;
done:
    CloseHandle(handleThreadStartedEvent);

    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    StartThreads
//
//  Overview:  Starts threads for import manager.  If no threads are needed
//              for the current download load, none are created.
//
//  Arguments: void
//
//  Returns:   S_OK if ok, otherwise an appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::StartThreads()
{
    HRESULT hr = S_OK;

    Assert(m_lThreadsStarted < NUMBER_THREADS_TO_SPAWN);

    LONG lWaiting = m_pList->GetThreadsWaiting();

    // if no threads are currently waiting, then another thread is needed for a download
    if (0 == lWaiting)
    {
        hr = CreateOneThread(&(m_handleThread[m_lThreadsStarted]), m_pList);
        if (FAILED(hr))
        {
            goto done;
        }

        m_lThreadsStarted++;
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Detach
//
//  Overview:  Deinitialization of object
//
//  Arguments: void
//             
//
//  Returns:   S_OK, or error code from list->Detach
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Detach()
{
    HRESULT hr = S_OK;
    int i = 0;

    for(i = 0; i < NUMBER_THREADS_TO_SPAWN; i++)
    {
        if (NULL != m_handleThread[i])
        {
            CloseHandle(m_handleThread[i]);
            m_handleThread[i] = NULL;
        }
    }
    
    if (NULL != m_pList)
    {
        hr = THR(m_pList->Detach());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    ReleaseInterface(m_pList);

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Add an ITIMEImportMedia to the scheduler
//
//  Arguments: pImportMedia, media to be scheduled
//             
//
//  Returns:   S_OK if ok, otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Add(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr;

#if DBG
    if (IsTagEnabled(tagSyncDownload))
    {
        TraceTag((tagSyncDownload,
                  "CImportManager::Add: Using synchronous call"));
        CComPtr<ITIMEMediaDownloader> spMediaDownloader;

        hr = THR(pImportMedia->GetMediaDownloader(&spMediaDownloader));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(spMediaDownloader->CueMedia());
        if (FAILED(hr))
        {
            goto done;
        }
        hr = S_OK;
        goto done;
    }
#endif
    
    if (m_lThreadsStarted < NUMBER_THREADS_TO_SPAWN)
    {
        hr = THR(StartThreads());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_pList->Add(pImportMedia));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Remove
//
//  Overview:  Remove ITIMEImportMedia from scheduler list
//              calls CThreadSafeList::Remove 
//
//  Arguments: pImportMedia, element to be removed from scheduler
//             
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Remove(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = m_pList->Remove(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;

}

//+-----------------------------------------------------------------------
//
//  Member:    DataAvailable
//
//  Overview:  Signals any waiting threads that data is now available
//              calls CThreadSafeList::DataAvailable
//
//  Arguments: void
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::DataAvailable()
{
    HRESULT hr = S_OK;

    hr = m_pList->DataAvailable();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    RePrioritize
//
//  Overview:  RePrioritize ITIMEImportMedia in scheduler list
//              calls CThreadSafeList::RePrioritize
//
//  Arguments: pImportMedia, element to be reprioritized in scheduler
//             
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::RePrioritize(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = m_pList->RePrioritize(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:    ThreadStartFunc
//
//  Overview:  Thread function, used for downloading
//              Takes a reference on this library, to prevent unloading until completion finishes
//              Calls list->GetNextElementToDownload, until NULL is returned, then exits thread
//              For each element returned, calls CueMedia on unmarshalled interface
//
//  Arguments: pvoidList, pointer to threadsafelist
//             
//
//  Returns:   0
//
//------------------------------------------------------------------------
unsigned long 
ThreadStartFunc(void *pvoidList) 
{ 
    HRESULT hr = S_OK;
    CImportManagerList * pList = NULL;
    BOOL bSucceeded;
    ITIMEImportMedia * pImportMedia = NULL;
    TCHAR szModuleName[_MAX_PATH];
    DWORD dwCharCopied;
    HINSTANCE hInst = NULL;
    HANDLE handleThreadStartedEvent;

    pList = reinterpret_cast<CImportManagerList*>(pvoidList);
    if (NULL == pList)
    {
        goto done;
    }
    
    pList->AddRef();

    dwCharCopied = GetModuleFileName(g_hInst, szModuleName, _MAX_PATH);
    if (0 == dwCharCopied)
    {
        // need to be able to get the file name!
        goto done;
    }

    hInst = LoadLibrary(szModuleName);
    if (NULL == hInst)
    {
        // need to be able to take a reference on this library
        goto done;
    }

    handleThreadStartedEvent = CreateEvent(NULL, FALSE, FALSE, pchHandleName);
    if (NULL == handleThreadStartedEvent)
    {
        // need to create the event to signal
        goto done;
    }
    
    bSucceeded = SetEvent(handleThreadStartedEvent);
    CloseHandle(handleThreadStartedEvent);
    if (FALSE == bSucceeded)
    {
        // calling thread won't unblock unless we exit now!
        hr = THR(E_FAIL);
        goto done;
    }

    // this must be apartment threaded.
    hr = THR(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED ));
    if (FAILED(hr))
    {
        // no recovery available
        goto done;
    }

    hr = THR(pList->GetNextElement(&pImportMedia));
    if (FAILED(hr))
    {
        goto done;
    }

    while(pImportMedia != NULL)
    {
        hr = THR(pImportMedia->CueMedia());
        if (FAILED(hr))
        {
            // what to do?  just keep on Processing
        }    
        

        hr = THR(pList->ReturnElement(pImportMedia));
        pImportMedia->Release();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pList->GetNextElement(&pImportMedia));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    TraceTag((tagTIMEImportManager, "TIME: ImportManager, thread shutting down"));

    hr = S_OK;
done:
    CoUninitialize();

    ReleaseInterface(pList);
    
    FreeLibraryAndExitThread(hInst, 0);
    return 0;
}


CImportManagerList::CImportManagerList()
{
    ;
}

CImportManagerList::~CImportManagerList()
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Tries to match given media to media downloader already in list.
//              if successful, reprioritizes downloader
//              otherwise, if media downloader, adds media downloader to list
//              otherwise, adds importmedia directly to list, by calling up inheritance chain
//             
//  Arguments: pImportMedia, pointer to media to add
//             
//  Returns:   S_OK if added, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::Add(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    bool fExisted = false;
    
    CComPtr<ITIMEMediaDownloader> spMediaDownloader;

    hr = THR(FindMediaDownloader(pImportMedia, &spMediaDownloader, &fExisted));
    if (FAILED(hr))
    {
        goto done;
    }

    if (fExisted)
    {
        double dblNewPriority = INFINITE;
        double dblOldPriority = INFINITE;

        hr = pImportMedia->GetPriority(&dblNewPriority);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMediaDownloader->GetPriority(&dblOldPriority);
        if (FAILED(hr))
        {
            goto done;
        }

        if ( dblNewPriority < dblOldPriority )
        {
            hr = RePrioritize(spMediaDownloader);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        if (spMediaDownloader)
        {
            hr = CThreadSafeList::Add(spMediaDownloader);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = CThreadSafeList::Add(pImportMedia);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetNode
//
//  Overview:  Walks list looking for UniqueID equal to given ID, 
//              if found, QI's for downloader into outgoing interface
//             
//  Arguments: listToCheck - list to check
//             lID - AtomTable ID to find in list
//             pfExisted - [out] if mediadownloader existed or not
//             ppMediaDownloader - [out] pointer to outgoing matched downloader
//             
//  Returns:   S_OK if no error, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::GetNode(std::list<CThreadSafeListNode*> &listToCheck, const long lID, bool * pfExisted, ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;
    
    std::list<CThreadSafeListNode * >::iterator iter;

    *pfExisted = false;
    *ppMediaDownloader = NULL;
    
    CComPtr<ITIMEImportMedia> spImportMedia;

    iter = listToCheck.begin();
    while (iter != listToCheck.end())
    {
        long lNodeID;
        
        hr = (*iter)->GetElement()->GetUniqueID(&lNodeID);
        if (FAILED(hr))
        {
            goto done;
        }

        if (ATOM_TABLE_VALUE_UNITIALIZED != lID)
        {
            if (lID == lNodeID)
            {
                spImportMedia = (*iter)->GetElement();
                break;
            }
        }

        iter++;
    }

    if (spImportMedia != NULL)
    {
        hr = spImportMedia->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
        if (SUCCEEDED(hr))
        {
            *pfExisted = true;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    FindMediaDownloader
//
//  Overview:  checks CThreadSafeList lists against GetNode looking for downloader.
//             
//  Arguments: pImportMedia, pointer to media to add
//             [out] ppMediaDownloader, where to store downloader interface
//             [out] pfExisted, whether or not downloader was found
//             
//  Returns:   S_OK if no error, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::FindMediaDownloader(ITIMEImportMedia * pImportMedia, ITIMEMediaDownloader ** ppMediaDownloader, bool * pfExisted)
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    CComPtr<ITIMEMediaDownloader> spMediaDownloader;

    long lID = ATOM_TABLE_VALUE_UNITIALIZED;

    if (NULL == pfExisted || NULL == ppMediaDownloader)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppMediaDownloader = NULL;
    *pfExisted = false;
    
    hr = pImportMedia->GetUniqueID(&lID);
    if (FAILED(hr))
    {
        goto done;
    }

    // is the id in any lists?
    hr = GetNode(m_listToDoDownload, lID, pfExisted, &spMediaDownloader);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!(*pfExisted))
    {
        hr = GetNode(m_listCurrentDownload, lID, pfExisted, &spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    if (!(*pfExisted))
    {
        hr = GetNode(m_listDoneDownload, lID, pfExisted, &spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if ((*pfExisted))
    {
        hr = pImportMedia->PutMediaDownloader(spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMediaDownloader->AddImportMedia(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = pImportMedia->GetMediaDownloader(&spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (spMediaDownloader)
    {
        hr = spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1999 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//    Manages all event interaction between TIME behaviors
//    and the Trident object model.
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include <string.h>
#include "EventMgr.h"
#include "mshtmdid.h"
#include "dispex.h"
#include "tokens.h"

static struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_FiredEvents[] =
{
    { TE_ONTIMEERROR,        L"ontimeerror"        },
    { TE_ONBEGIN,            L"onbegin"            },
    { TE_ONPAUSE,            L"onpause"            },
    { TE_ONRESUME,           L"onresume"           },
    { TE_ONEND,              L"onend"              },
    { TE_ONRESYNC,           L"onresync"           },
    { TE_ONREPEAT,           L"onrepeat"           },
    { TE_ONREVERSE,          L"onreverse"          },
    { TE_ONMEDIACOMPLETE,    L"onmediacomplete"    },
    { TE_ONOUTOFSYNC,        L"onoutofsync"        },
    { TE_ONSYNCRESTORED,     L"onsyncrestored"     },
    { TE_ONMEDIAERROR,       L"onmediaerror"       },
    { TE_ONRESET,            L"onreset"            },
    { TE_ONSCRIPTCOMMAND,    L"onscriptcommand"    },
    { TE_ONMEDIABARTARGET,   L"onmediabartarget"   },
    { TE_ONURLFLIP,          L"onurlflip"          },
    { TE_ONTRACKCHANGE,      L"ontrackchange"      },
    { TE_GENERIC,            NULL                  },
    { TE_ONSEEK,             L"onseek"             },
    { TE_ONMEDIAINSERTED,    L"onmediainserted"    },
    { TE_ONMEDIAREMOVED,     L"onmediaremoved"     },
    { TE_ONTRANSITIONINBEGIN,L"ontransitioninbegin"  },
    { TE_ONTRANSITIONINEND,  L"ontransitioninend"    },
    { TE_ONTRANSITIONOUTBEGIN, L"ontransitionoutbegin"  },
    { TE_ONTRANSITIONOUTEND, L"ontransitionoutend"    },
    { TE_ONTRANSITIONREPEAT, L"ontransitionrepeat" },
    { TE_ONUPDATE,           NULL                  },
    { TE_ONCODECERROR,       L"oncodecerror"       },
    { TE_MAX,                NULL                  },
};


static struct {
    TIME_EVENT_NOTIFY event;
    wchar_t * wsz_name;
} g_NotifiedEvents[] =
{
    { TEN_LOAD,             NULL                }, // this is null because there is no event to attach to,
    { TEN_UNLOAD,           NULL                }, // these are events that are automatically hooked up 
    { TEN_STOP,             NULL                }, // when attaching to the document's event
    { TEN_READYSTATECHANGE, NULL                }, // through the connection point interfaces.
    { TEN_MOUSE_DOWN,       L"onmousedown"      },
    { TEN_MOUSE_UP,         L"onmouseup"        },
    { TEN_MOUSE_CLICK,      L"onclick"          },
    { TEN_MOUSE_DBLCLICK,   L"ondblclick"       },
    { TEN_MOUSE_OVER,       L"onmouseover"      },
    { TEN_MOUSE_OUT,        L"onmouseout"       },
    { TEN_MOUSE_MOVE,       L"onmousemove"      },
    { TEN_KEY_DOWN,         L"onkeydown"        },
    { TEN_KEY_UP,           L"onkeyup"          },
    { TEN_FOCUS,            L"onfocus"          },
    { TEN_RESIZE,           L"onresize"         },
    { TEN_BLUR,             L"onblur"           },
};

static OLECHAR *g_szSysTime = L"time";
#define GENERIC_PARAM 0                //this is used to get the name from the parameter list of a dynamic event

DeclareTag(tagEventMgr, "TIME: Events", "Event Manager methods")

CEventMgr::CEventMgr()
:   m_dwWindowEventConPtCookie(0),
    m_dwDocumentEventConPtCookie(0),
    m_pEventSite(NULL),
    m_bInited(false),
    m_fLastEventTime(0),
    m_pBvrSiteOM(NULL),
    m_bAttached(false),
    m_bUnLoaded(false),
    m_pElement(NULL),
    m_pEndEvents(NULL),
    m_pBeginEvents(NULL),
    m_lRefs(0),
    m_bDeInited(false),
    m_bReady(false),
    m_bEndAttached(false),
    m_lEventRecursionCount(0)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMgr",
              this));

    memset(m_bRegisterEvents, 0, sizeof(bool) * TE_MAX);
    memset(m_bNotifyEvents, 0, sizeof(bool) * TEN_MAX);
    memset(m_cookies, 0, sizeof(bool) * TE_MAX);
};


    
CEventMgr::~CEventMgr()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::~EventMgr",
              this));

    
    delete [] m_pBeginEvents;
    m_pBeginEvents = NULL;
    delete [] m_pEndEvents;
    m_pEndEvents = NULL;
    
    if (m_pEventSite)
    {
        CTIMEEventSite *pEventSite = m_pEventSite;
        m_pEventSite = NULL;
        pEventSite->Release();
    }

    if (m_pBvrSiteOM)
    {
        m_pBvrSiteOM->Release();
        m_pBvrSiteOM = NULL;
    }
};


///////////////////////////////////////////////////////////////////////////
// _InitEventMgrNotify
//
// Summary:
//     This needs to be called during initialization to set the
//     CTIMEEventSite class.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_InitEventMgrNotify(CTIMEEventSite *pEventSite)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_InitEventMgrNotify(%lx)",
              this, pEventSite));
   
    HRESULT hr = S_OK;
    Assert(pEventSite);
    if (!pEventSite)
    {
        hr = E_FAIL;
    }
    else
    {
        m_pEventSite = pEventSite;
        m_pEventSite->AddRef();
    }
    return hr;
};

///////////////////////////////////////////////////////////////////////////
// _RegisterEventNotification
//
// Summary:
//     Sets a flag that tells the event manager to notify the CTIMEEventSite
//     class that a specific event has occured. This may only be called before
//     the onLoad event is fired.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_RegisterEventNotification(TIME_EVENT_NOTIFY event_id)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_RegisterEventNotification(%l)",
              this, event_id));

    HRESULT hr = S_OK;
    Assert(event_id >= 0 && event_id < TEN_MAX);

    if(m_bInited == true)
    {
        hr = E_FAIL;
    }
    else
    {
        m_bNotifyEvents[event_id] = true;
    }
    return hr;

};

///////////////////////////////////////////////////////////////////////////
// _RegisterEvent
//
// Summary:
//     Sets a flag that tells the event manager to register a specific event 
//     that the time class can fire.  This can only be called before the 
//     onLoad event is fired.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_RegisterEvent(TIME_EVENT event_id)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_RegisterEvent(%l)",
              this, event_id));

    HRESULT hr = S_OK;
    Assert(event_id >= 0 && event_id < TE_MAX);

    if(m_bInited == true)
    {
        hr = E_FAIL;
    }
    else
    {
        m_bRegisterEvents[event_id] = true;
    }
    return hr;
};

///////////////////////////////////////////////////////////////
//  Name: _SetTimeEvent
// 
//  Abstract: New Syntax
///////////////////////////////////////////////////////////////
HRESULT 
CEventMgr::_SetTimeEvent(int type, TimeValueList & tvList)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_SetTimeEvent()",
              this));
    
    HRESULT hr = S_OK;

    IGNORE_HR(DetachEvents());
    
    //delete the old list of events
    if (type == TEM_BEGINEVENT)
    {
        hr = THR(SetNewEventStruct(tvList, &m_pBeginEvents));
    }
    else if (type == TEM_ENDEVENT)
    {
        hr = THR(SetNewEventStruct(tvList, &m_pEndEvents));
    }
    
    if (SUCCEEDED(hr))
    {
        hr = AttachEvents();  //attach to all events in all lists.
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: _SetTimeEvent
// 
//  Abstract:  This is to support old syntax and is string based
///////////////////////////////////////////////////////////////
HRESULT 
CEventMgr::_SetTimeEvent(int type, LPOLESTR lpstrEvents)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_SetTimeEvent(%ls)",
              this, lpstrEvents));
    
    HRESULT hr = S_OK;

    IGNORE_HR(DetachEvents());
    
    //delete the old list of events
    if (type == TEM_BEGINEVENT)
    {
        hr = THR(SetNewEventList(lpstrEvents, &m_pBeginEvents));
    }
    else if (type == TEM_ENDEVENT)
    {
        hr = THR(SetNewEventList(lpstrEvents, &m_pEndEvents));
    }
    
    if (SUCCEEDED(hr))
    {
        hr = AttachEvents();  //attach to all events in all lists.
    }

    return hr;
};



HRESULT CEventMgr::_Init(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite)
{
    TraceTag((tagEventMgr,
          "EventMgr(%lx)::_Init(%lx)",
          this, pEle));
    
    HRESULT hr = S_OK;

    if (!pEle)
    {
        hr = E_FAIL;
        goto done;
    }
    else
    {
        m_pElement = pEle;
    }

    if (!pEleBehaviorSite)
    {   
        hr = E_FAIL;
        goto done;
    }
    else
    {
        hr = THR(pEleBehaviorSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **)&m_pBvrSiteOM));
        if (FAILED(hr))
        {
            goto done;
        }
        Assert(m_pBvrSiteOM);
    }

    hr = THR(ConnectToContainerConnectionPoint());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(RegisterEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    // We need to do this here since dynamically added objects do not
    // always fire the readystatechange event
    UpdateReadyState();
  done:
    if (FAILED(hr))
    {
        if (m_pBvrSiteOM != NULL)
        {
            m_pBvrSiteOM->Release();
            m_pBvrSiteOM = NULL;
        }
    }
    return hr;
};

HRESULT CEventMgr::_Deinit()
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::_Deinit()",
      this));
    

    //clean up the event lists.
    IGNORE_HR(SetNewEventList(NULL, &m_pBeginEvents));
    IGNORE_HR(SetNewEventList(NULL, &m_pEndEvents));

    //release the document and window connection points
    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
        m_dwWindowEventConPtCookie = 0;
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
        m_dwDocumentEventConPtCookie = 0;
    }

    //release the behavior site
    if (m_pBvrSiteOM != NULL)
    {
        m_pBvrSiteOM->Release();
        m_pBvrSiteOM = NULL;
    }

    //cleanup memory
    if (m_lRefs == 0 && m_pEventSite)
    {        
        CTIMEEventSite *pEventSite = m_pEventSite;
        m_pEventSite = NULL;
        pEventSite->Release();
    }
    m_bDeInited = true;
    return S_OK;
};


///////////////////////////////////////////////////////////////
//  Name: _FireEvent
// 
//  Abstract:
//    This is invoked by the FIRE_EVENT macro to allow
//    the controlling class to fire standard TIME events.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::_FireEvent(TIME_EVENT TimeEvent, 
                               long lCount, 
                               LPWSTR szParamNames[], 
                               VARIANT varParams[], 
                               float fTime)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_FireEvent()",
              this));
    
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    CComPtr <IHTMLEventObj2> pEventObj2;
    int i = 0;
    VARIANT vEventTime;
    
    m_lEventRecursionCount++;
    if (m_lEventRecursionCount >= 100)
    {
        goto done;
    }

    if (m_pEventSite == NULL || m_pEventSite->IsThumbnail() == true)
    {
        goto done;
    }

    if (!m_pBvrSiteOM)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_bUnLoaded)
    {
        goto done;
    }

    if (TimeEvent < 0 || TimeEvent >= TE_MAX)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_bRegisterEvents[TimeEvent] == false)
    {
        //this event is not registered, fail
        hr = E_FAIL;
        goto done;
    }

    //create the event object
    hr = THR(m_pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    if (pEventObj != NULL)
    {
        hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
        if (FAILED(hr))
        {
            goto done;
        }

        IGNORE_HR(pEventObj2->put_type(g_FiredEvents[TimeEvent].wsz_name + 2));

        //set the event time on the event object
        VariantInit(&vEventTime);
        V_VT(&vEventTime) = VT_R8;
        V_R8(&vEventTime) = fTime;
        
        {
            hr = THR(pEventObj2->setAttribute(g_szSysTime, vEventTime, VARIANT_FALSE)); 
            if (FAILED(hr))
            {
                goto done;
            }
        }
        
        VariantClear(&vEventTime);
        
        //unpack the parameter list and add it to the event object
        for (i = 0; i < lCount; i++)
        {
            hr = THR(pEventObj2->setAttribute(szParamNames[i], varParams[i], VARIANT_FALSE));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    //fire the event
    hr = THR(m_pBvrSiteOM->FireEvent(m_cookies[TimeEvent], pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    //if a dynamic event needs to be fired, call FireDynanicEvent
    if (TE_ONSCRIPTCOMMAND == TimeEvent)
    {
        hr = THR(FireDynamicEvent(TE_GENERIC, lCount, szParamNames, varParams, fTime));
    }

  done:

    m_lEventRecursionCount--;
    return hr;

};

///////////////////////////////////////////////////////////////
//  Name: FireDynamicEvent
// 
//  Abstract:
//    Handles the registration and firing of dynamic events
//    that come across on media streams.  This should only
//    be called from _FireEvent in the case of OnScriptCommand 
//    events.  
//
//    NOTE: This code is very similar to _FireEvent.  It is 
//          currently here to keep the implementation cleaner
//          At some point this could possible be compressed into
//          a single FireEvent routine.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::FireDynamicEvent(TIME_EVENT TimeEvent, 
                                     long lCount, 
                                     LPWSTR szParamNames[], 
                                     VARIANT varParams[],
                                     float fTime)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::FireDynamicEvent()",
              this));

    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    CComPtr <IHTMLEventObj2> pEventObj2;
    WCHAR *pwszGenericName = NULL;
    long lCookie = 0;
    BSTR bstrType = NULL;
    int i = 0;
    VARIANT vEventTime;

    Assert (TimeEvent == TE_GENERIC); //This current only handles TE_GENERIC events.

    //register the event.
    if (varParams[GENERIC_PARAM].bstrVal == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // build string name - "on" + Param + NULL
    pwszGenericName = NEW WCHAR[lstrlenW(varParams[GENERIC_PARAM].bstrVal)+(2*sizeof(WCHAR))+sizeof(WCHAR)];
    if (pwszGenericName == NULL)
    {
        TraceTag((tagError, "CEventMgr::FireDynamicEvent - unable to alloc mem for string"));
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ocscpy(pwszGenericName, L"on");
    lstrcatW(pwszGenericName, varParams[GENERIC_PARAM].bstrVal);

    hr = THR(m_pBvrSiteOM->GetEventCookie(pwszGenericName, &lCookie));
    if (FAILED(hr))
    {
        hr = THR(m_pBvrSiteOM->RegisterEvent(pwszGenericName, 0, &lCookie));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //create the event object
    hr = THR(m_pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //set event object type parameter
    bstrType = SysAllocString(pwszGenericName);
    if (bstrType != NULL)
    {
        IGNORE_HR(pEventObj2->put_type(bstrType));
        SysFreeString(bstrType);
        bstrType = NULL;
    }
    else 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    //unpack the parameter list and add it to the event object
    for (i = 0; i < lCount; i++)
    {
        BSTR bstrParamName = SysAllocString(szParamNames[i]);
        if (bstrParamName != NULL)
        {
            hr = THR(pEventObj2->setAttribute(bstrParamName, varParams[i], VARIANT_FALSE));
            SysFreeString (bstrParamName);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    //set the event time on the event object
    VariantInit(&vEventTime);
    V_VT(&vEventTime) = VT_R8;
    V_R8(&vEventTime) = fTime;
    {
        BSTR bstrEventTime = SysAllocString(g_szSysTime);
        if (bstrEventTime != NULL)
        {
            hr = THR(pEventObj2->setAttribute(bstrEventTime, vEventTime, VARIANT_FALSE)); 
            SysFreeString(bstrEventTime);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    VariantClear(&vEventTime);
    
    //fire the event
    hr = THR(m_pBvrSiteOM->FireEvent(lCookie, pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    if (pwszGenericName)
    {
        delete [] pwszGenericName;
        pwszGenericName = NULL;
    }

    return hr;

}

HRESULT CEventMgr::_RegisterDynamicEvents(LPOLESTR lpstrEvents)  //unsure how this will be handled or used.
{

    //TODO
    
    return S_OK;
};



///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::AddRef()",
              this));

    long i = 0;
    m_lRefs++;
    if (m_pEventSite)
    {
        i = m_pEventSite->AddRef();
    }
    return i;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::Release()",
              this));
    long i = 0;
    m_lRefs--;
    if (m_pEventSite)
    {
        i = m_pEventSite->Release();
    }
    if (m_lRefs == 0 && m_bDeInited == true)
    {
        // release the controlling behavior
        if (m_pEventSite)
        {
            CTIMEEventSite *pEventSite = m_pEventSite;
            m_pEventSite = NULL;
            pEventSite->Release();
            
        }
    }
    return i;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    HRESULT hr = S_OK;
    int i = 0;
    bool bEndZeroOffset = false;
    bool bBeginZeroOffset = false;
    
    float fTime = valueNotSet;

    // Bail if we are deinited
    if (m_bDeInited)
    {
        goto done;
    }

    if (dispIdMember != 0)  //no need to check dispid's if this is an attached event.
    {
        if (m_pBeginEvents != NULL)
        {
            for (i = 0; i < m_pBeginEvents->lEventCount; i++)
            {
                if (dispIdMember == m_pBeginEvents->pEventDispids[i])
                {
                    if (m_pBeginEvents->pEventList[i].offset != 0.0f)
                    {
                        m_pEventSite->onBeginEndEvent(true, fTime, m_pBeginEvents->pEventList[i].offset, false, 0.0f, 0.0f);
                    }
                    else
                    {
                        bBeginZeroOffset = true;
                    }
                }
            }
        }   
        if (m_pEndEvents != NULL)
        {     
            for (i = 0; i < m_pEndEvents->lEventCount; i++)
            {
                if (dispIdMember == m_pEndEvents->pEventDispids[i])
                {
                    if (m_pEndEvents->pEventList[i].offset != 0.0f)
                    {
                        if (m_bEndAttached == true)
                        {
                            m_pEventSite->onBeginEndEvent(false, 0.0f, 0.0f, true, fTime, m_pEndEvents->pEventList[i].offset);
                        }
                    }
                    else
                    {
                        bEndZeroOffset = true;
                    }
                }
            }
        }
    }
    
    switch (dispIdMember)
    {
      case 0: //this is the case for events that have been hooked using attachEvent
        {
            BSTR bstrEvent;
            CComPtr <IHTMLEventObj> pEventObj;
            CComPtr <IHTMLEventObj2> pEventObj2;
                
            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                Assert(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&bstrEvent));
            //track if this is a click event so the following document.onclick may be ignored.

            hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
            if (SUCCEEDED(hr))
            {
                VARIANT vTime;
                VariantInit(&vTime);
                hr = THR(pEventObj2->getAttribute(g_szSysTime, 0, &vTime));
                if (FAILED(hr))
                {
                    fTime = valueNotSet;
                }
                else
                {
                    hr = VariantChangeTypeEx(&vTime, &vTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
                    if (FAILED(hr))
                    {
                        fTime = valueNotSet;
                    }
                    else
                    {
                        fTime = (float)V_R8(&vTime);
                    }
                }

                VariantClear(&vTime);
            }

            EventMatch(pEventObj, m_pBeginEvents, bstrEvent, TETYPE_BEGIN, fTime, &bBeginZeroOffset);
            if (m_bEndAttached == true)
            {
                EventMatch(pEventObj, m_pEndEvents, bstrEvent, TETYPE_END, fTime, &bEndZeroOffset);
            }

            SysFreeString(bstrEvent);
            bstrEvent = NULL;
            EventNotifyMatch(pEventObj);
        }
        break;
        
      case DISPID_EVPROP_ONPROPERTYCHANGE:
      case DISPID_EVMETH_ONPROPERTYCHANGE:
        break;

      case DISPID_EVPROP_ONLOAD:
      case DISPID_EVMETH_ONLOAD:
        if (m_bNotifyEvents[TEN_LOAD] == true)
        {
            m_pEventSite->onLoadEvent();
        }
          
        break;

      case DISPID_EVPROP_ONUNLOAD:
      case DISPID_EVMETH_ONUNLOAD:
        //detach from all events
        IGNORE_HR(DetachEvents());
        DetachNotifyEvents();

        if (m_bNotifyEvents[TEN_UNLOAD] == true)
        {            
            m_pEventSite->onUnloadEvent();
        }
        m_bUnLoaded = true;
        break;

      case DISPID_EVPROP_ONSTOP:
      case DISPID_EVMETH_ONSTOP:
        if (m_bNotifyEvents[TEN_STOP] == true)
        {
            float fStopTime = m_pEventSite->GetGlobalTime();
            m_pEventSite->onStopEvent(fStopTime);
        }
        break;

      case DISPID_EVPROP_ONREADYSTATECHANGE:
      case DISPID_EVMETH_ONREADYSTATECHANGE:
        if (!m_bUnLoaded)
        {
            UpdateReadyState();
        }
        break;
      default:
        {
            //for lint compatibility
        }
         
    }

    if (bBeginZeroOffset || bEndZeroOffset)
    {
        m_pEventSite->onBeginEndEvent(bBeginZeroOffset, fTime, 0.0f, bEndZeroOffset, fTime, 0.0f);
    }

  done:
    return S_OK;
};


HRESULT CEventMgr::RegisterEvents()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::RegisterEvents",
              this));
    int i = 0;

    HRESULT hr = S_OK;

    Assert(m_pBvrSiteOM);
    
    if (m_pBvrSiteOM == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    for (i = 0; i < TE_MAX; i++)
    {
        if (g_FiredEvents[i].wsz_name != NULL && m_bRegisterEvents[i] == true)
        {
            hr = THR(m_pBvrSiteOM->RegisterEvent(g_FiredEvents[i].wsz_name, 0, (long *) &m_cookies[i]));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Abstract:
//      Attaches to the events in a single event list.
//
///////////////////////////////////////////////////////////////

HRESULT CEventMgr::Attach(Event *pEvent)
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::Attach()",
      this));

    int i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess = FALSE;

    if (pEvent == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvent->lEventCount; i++)
    {
        CComPtr <IHTMLElement> pEle;
        CComPtr <IHTMLElement2> pSrcEle;
        CComPtr <IHTMLDocument2> pDoc2;
        CComPtr <IHTMLElementCollection> pEleCol;
        CComPtr <IDispatch> pSrcDisp;
        CComPtr <IDispatch> pDocDisp;
        CComPtr <IDispatchEx> pDispEx;

        pEvent->pEventDispids[i] = INVALID_DISPID; //invalid dispid

        //get the document
        hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pEle->get_document(&pDocDisp));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
        if (FAILED(hr))
        {
            continue;
        }
        if (StrCmpIW(pEvent->pEventList[i].pElementName, L"document") == 0)
        {

            DISPID dispid;
            CComPtr <ITypeLib> pTypeLib;
            CComPtr <ITypeInfo> pTypeInfo;
            CComPtr <ITypeInfo> pTypeInfoEvents;
            CComPtr <IDispatch> pDispatch;
            BSTR bstrEvent;
            unsigned int index = 0;

            //This code loads the typelib for the IHTMLDocument2 interface,
            //and gets the ID for the event from the type info for the
            //HTMLDocumentEvents dispinterface.
            hr = THR(pDoc2->QueryInterface(IID_IDispatch, (void**)&pDispatch));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pDispatch->GetTypeInfo(0, LCID_SCRIPTING, &pTypeInfo));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pTypeInfo->GetContainingTypeLib(&pTypeLib, &index));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pTypeLib->GetTypeInfoOfGuid(DIID_HTMLDocumentEvents, &pTypeInfoEvents));
            if (FAILED(hr))
            {
                continue;
            }

            bstrEvent = SysAllocString(pEvent->pEventList[i].pEventName);
            if (bstrEvent != NULL)
            {
                hr = THR(pTypeInfoEvents->GetIDsOfNames(&bstrEvent, 1, &dispid));
                SysFreeString(bstrEvent);
                bstrEvent = NULL;
                if (FAILED(hr))
                {
                    continue;
                }
                pEvent->pEventDispids[i] = dispid;
            }
            else
            {
                continue;
            }

            continue; 
        }

        {
            VARIANT vName;
            VARIANT vIndex;

            //get all elements in the document
            hr = THR(pDoc2->get_all(&pEleCol));
            if (FAILED(hr))
            {
                continue;
            }

            //find the element with the correct name
            VariantInit(&vName);
            vName.vt = VT_BSTR;
            vName.bstrVal = SysAllocString(pEvent->pEventList[i].pElementName);

            VariantInit(&vIndex);
            vIndex.vt = VT_I2;
            vIndex.iVal = 0;

            hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
            
            VariantClear(&vName);
            VariantClear(&vIndex);
            if (FAILED(hr))
            {
                continue;
            }
            if (!pSrcDisp) //will be NULL if the vName is invalid element.
            {
                pEvent->pEventElements[i] = NULL;
                continue;
            }

            hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
            if (FAILED(hr))
            {
                continue;
            }

            //cache the IHTMLElement2 pointer for use on detach
            pEvent->pEventElements[i] = pSrcEle;
            pEvent->pEventElements[i]->AddRef();

            hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
            if (SUCCEEDED(hr))
            {
                //determine if this is a valid event
                BSTR bstrEventName;
                DISPID tempDispID;

                bstrEventName = SysAllocString(pEvent->pEventList[i].pEventName);
                if (bstrEventName != NULL)
                {
                    //check for the case insensitive name
                    hr = THR(pDispEx->GetDispID(bstrEventName, fdexNameCaseInsensitive, &tempDispID));
                    if (pEvent->pbDynamicEvents[i] == false && SUCCEEDED(pDispEx->GetDispID(bstrEventName, fdexNameCaseInsensitive, &tempDispID)))
                    {
                        int iIndex = isTimeEvent(bstrEventName);
                        //need to get the correct case sensitive name
                        SysFreeString (bstrEventName);
                        bstrEventName = NULL;
                        if (iIndex == -1)
                        {
                            hr = THR(pDispEx->GetMemberName(tempDispID, &bstrEventName));
                        }
                        else
                        {
                            //need to convert the event to all lowercase.
                            bstrEventName = SysAllocString(g_FiredEvents[iIndex].wsz_name);
                            if (!bstrEventName)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            pEvent->pbDynamicEvents[i] = false;
                            if (pEvent->pEventList[i].bAttach == true)  //only want to attach if this is not a duplicate event.
                            {
                                hr = THR(pSrcEle->attachEvent(bstrEventName, (IDispatch *)this, &bSuccess));
                            }
                        }
                    }
                    else //this is not currently a valid event, but it could be a custom event.
                    {    //so TIME needs to attach to the onScriptCommand event to be able to catch custom events.
                        pEvent->pbDynamicEvents[i] = true;
                        BSTR ScriptEvent = SysAllocString(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name);
                        if (ScriptEvent != NULL)
                        {
                            if (pEvent->pEventList[i].bAttach == true)  //only want to attach if this is not a duplicate event.
                            {
                                IGNORE_HR(pSrcEle->attachEvent(ScriptEvent, (IDispatch *)this, &bSuccess));
                            }
                        }
                        SysFreeString (ScriptEvent);
                        ScriptEvent = NULL;
                    }
                }
                SysFreeString(bstrEventName);
                bstrEventName = NULL;
            }
        }
    }

  done:
    return S_OK;
};

///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::ConnectToContainerConnectionPoint()",
      this));

    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> pWndCPC;
    CComPtr<IConnectionPointContainer> pDocCPC; 
    CComPtr<IHTMLDocument> pDoc; 
    CComPtr<IDispatch> pDocDispatch;
    CComPtr<IDispatch> pScriptDispatch;
    CComPtr<IHTMLElement> pEle;

    HRESULT hr;

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pEle->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        if (m_pDocConPt)
        {
            if (m_dwDocumentEventConPtCookie != 0)
            {
                IGNORE_HR(m_pDocConPt->Unadvise(m_dwDocumentEventConPtCookie));
            }
            m_pDocConPt.Release();
        }
        if (m_pWndConPt)
        {
            if (m_dwWindowEventConPtCookie != 0)
            {
                IGNORE_HR(m_pWndConPt->Unadvise(m_dwWindowEventConPtCookie));
            }
            m_pWndConPt.Release();
        }
        m_dwWindowEventConPtCookie = 0;
        m_dwDocumentEventConPtCookie = 0;
    }
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
//
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(LPOLESTR lpstrEvents)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::GetEventCount(%ls)",
              this, lpstrEvents));

    long curCount = 0;
    OLECHAR *curChar = NULL;
    OLECHAR *szEvent = NULL;
    OLECHAR *szCurEvent = NULL;
    int iCurLoc = 0;
    UINT strLen = 0;

    if (lpstrEvents == NULL)
    {
        curCount = 0;
        goto done;
    }
    strLen = wcslen(lpstrEvents);
    szEvent = NEW OLECHAR [strLen + 1];
    if (szEvent == NULL)
    {
        curCount = 0;
        goto done;
    }

    szCurEvent = NEW OLECHAR [strLen + 1];
    if (szCurEvent == NULL)
    {
        curCount = 0;
        goto done;
    }

    curChar = lpstrEvents;

    //strip out ' '
    while (*curChar != '\0' && curCount < (int)strLen)
    {
        if (*curChar != ' ')
        {
            szEvent[curCount] = *curChar;
            curCount++;
        }
        curChar++;
    }
    szEvent[curCount] = '\0';

    curCount = 0;
    curChar = szEvent;
    iCurLoc = -1;
    while (*curChar != '\0')
    {
        iCurLoc++;
        szCurEvent[iCurLoc] = *curChar;
        if (*curChar == '.')  //reset after a '.'
        {
            iCurLoc = -1;
            ZeroMemory(szCurEvent, sizeof(OLECHAR) * lstrlenW(szCurEvent));
        }
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            iCurLoc = -1;
            if (lstrlenW(szCurEvent) > 2 && StrCmpNIW(szCurEvent, L"on", 2) != 0)
            {
               curCount++; //add an extra event for each that does not start with "on" 
            }
            ZeroMemory(szCurEvent, sizeof(OLECHAR) * lstrlenW(szCurEvent));
            curCount++;
        }
        
    }
    delete [] szCurEvent;
    szCurEvent = NULL;
    //determine if the end character was a ';'.
    if (*(curChar - 1) == ';')
    {
        curCount--;
    }   

  done:
    delete [] szEvent;
    return curCount;
}

///////////////////////////////////////////////////////////////
//  Name: EventMatch
// 
//  Abstract:
//    Determines if the event described by the event object
//    matches one of the events in the event list.  Returns 
//    true if a match exists.
//
//    if bCustom is true then the event notification is sent
//    directly to the m_pEventSite interface, otherwise a true
//    or false is returned.
///////////////////////////////////////////////////////////////
void CEventMgr::EventMatch(IHTMLEventObj *pEventObj, Event *pEvent, BSTR bstrEvent, TIME_EVENT_TYPE evType, float fTime, bool *bZeroOffsetMatch)
{
        
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMatch",
              this));

    BSTR bstrElement = NULL;
    CComPtr<IHTMLEventObj2> pEventObj2;
    IHTMLElement *pSrcEle = NULL;
    HRESULT hr = S_OK;
    int i = 0;
    
    if (pEvent == NULL || m_bDeInited)
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //get the element name
    hr = THR(pEventObj->get_srcElement(&pSrcEle));
    if (FAILED(hr))
    {
        goto done;
    }    

    //Loop until the src element and all of it's container elements have been checked.
    while ((pSrcEle != NULL))
    {
        IHTMLElement *pParentEle = NULL;

        hr = THR(pSrcEle->get_id(&bstrElement));
        if (FAILED(hr))
        {
            goto done;
        }    

        for (i = 0; i < pEvent->lEventCount; i++)
        {
            BSTR bstrDynamicName = NULL;
            CComPtr <IHTMLElement> pEle;

            if (pEvent->pEventElements[i] == NULL)
            {
                continue;
            }   

            hr = THR(pEvent->pEventElements[i]->QueryInterface(IID_IHTMLElement, (void**)&pEle)) ;
            
            if (ValidateEvent(bstrEvent, pEventObj2, pEle) == false)
            {
                //this is not a valid event at this time.
                goto done;
            }

            if ((StrCmpIW(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name + 2, bstrEvent) == 0) && 
                (pEvent->pbDynamicEvents[i] == true))
            {
                //if this is a script command event and the script command event is attached by default
                //then reset the event name to match the value of the "Param" parameter.
                VARIANT vTemp;
                VariantInit(&vTemp);
                pEventObj2->getAttribute(L"Param", 0, &vTemp);
                bstrDynamicName  = SysAllocString(vTemp.bstrVal);
                VariantClear(&vTemp);            
            }
            else
            {
                bstrDynamicName = SysAllocString(bstrEvent);
            }

            //is this a match? Need to check m_bDeInited again here (104003)
            if (pEvent == NULL || pEvent->pEventList == NULL || m_bDeInited)
            {
                goto done;
            }
            if ((bstrDynamicName && 
                ((StrCmpIW(pEvent->pEventList[i].pEventName + 2, bstrDynamicName) == 0) ||
                (StrCmpIW(pEvent->pEventList[i].pEventName, bstrDynamicName) == 0))) &&
                (StrCmpIW(pEvent->pEventList[i].pElementName, bstrElement) == 0))
            {
                //this is a match, exit.
                if (evType == TETYPE_BEGIN || evType == TETYPE_END)  //this is either beginEvent or an endEvent
                {
                    SysFreeString(bstrDynamicName);
                    bstrDynamicName = NULL;
                    

                    if (evType == TETYPE_BEGIN)
                    {
                        if (pEvent->pEventList[i].offset != 0.0f)
                        {
                            m_pEventSite->onBeginEndEvent(true, fTime, pEvent->pEventList[i].offset, false, 0.0f, 0.0f);    
                        }
                        else
                        {
                            if (bZeroOffsetMatch)
                            {
                                *bZeroOffsetMatch = true;
                            }
                        }
                    }
                    else
                    {
                        
                        if (pEvent->pEventList[i].offset != 0.0f)
                        {
                            m_pEventSite->onBeginEndEvent(false, 0.0f, 0.0f, true, fTime, pEvent->pEventList[i].offset);    
                        }
                        else
                        {
                            if (bZeroOffsetMatch)
                            {
                                *bZeroOffsetMatch = true;
                            }
                        }
                    }

                    hr = S_OK;
                    goto done;
                }
            }
            SysFreeString(bstrDynamicName);
            bstrDynamicName = NULL;
        }

        //if no match, check the parent element name to handle event bubbling.
        hr = THR(pSrcEle->get_parentElement(&pParentEle));
        if (FAILED(hr))
        {
            goto done;
        }

        if (bstrElement)
        {
            SysFreeString(bstrElement);
            bstrElement = NULL;
        }
        pSrcEle->Release();
        pSrcEle = pParentEle;
        pParentEle = NULL;
    }
    //else check for event bubbling
    //if match, return true

  done:
    if (bstrElement)
    {
        SysFreeString(bstrElement);
        bstrElement = NULL;
    }
    if (pSrcEle != NULL)
    {
        pSrcEle->Release();
        pSrcEle = NULL;
    }

    return;
};

///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Handles the attaching to all events in all event lists.
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::AttachEvents()
{

    TraceTag((tagEventMgr,
              "EventMgr(%lx)::AttachEvents",
              this));
    HRESULT hr = S_OK;

    if (m_bUnLoaded || m_bAttached || !m_bReady) //if this is already unloaded, already attached, or not ready, don't attach
    {
        hr = E_FAIL;
        goto done;
    }
    //Readystate must be "complete" attach to the events.
    m_bAttached = true;
    
    FindDuplicateEvents();  // Determines which events are duplicates so that events are only attached to once.

    IGNORE_HR(Attach(m_pBeginEvents));
    
  done:
    return hr;
};

///////////////////////////////////////////////////////////////
//  Name: FindDuplicateEvents
// 
//  Abstract:
//    Searches the lists of events to determine if there are
//    any duplicates in the lists.  This step is needed to 
//    prevent attaching to the same event more than once.  This
//    would cause multiple notifications of the same event.
//
///////////////////////////////////////////////////////////////
void CEventMgr::FindDuplicateEvents()
{

    //Check each list against itself for duplicates
    MarkSelfDups(m_pBeginEvents);
    MarkSelfDups(m_pEndEvents);

    //Check the lists against each other for duplicates
    MarkDups(m_pBeginEvents, m_pEndEvents);

    return;
}



///////////////////////////////////////////////////////////////
//  Name: MarkSelfDups
// 
//  Abstract:
//    Searches a list and flags any duplicate events within
//    the list.
//
///////////////////////////////////////////////////////////////
void CEventMgr::MarkSelfDups(Event *pEvents)
{
    int i = 0, j = 0;

    if (pEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvents->lEventCount; i++)
    {
        for (j = i+1; j < pEvents->lEventCount; j++)
        {
            if ((StrCmpIW(pEvents->pEventList[i].pEventName, pEvents->pEventList[j].pEventName) == 0) &&
                (StrCmpIW(pEvents->pEventList[i].pElementName, pEvents->pEventList[j].pElementName) == 0))
            {
                pEvents->pEventList[j].bAttach = false;
            }

        }

    }
  done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: MarkDups
// 
//  Abstract:
//    Searches 2 lists and flags any duplicate events that occur
//    in the second list.
//
///////////////////////////////////////////////////////////////
void CEventMgr::MarkDups(Event *pSrcEvents, Event *pDestEvents)
{
    int i = 0, j = 0;

    if (pSrcEvents == NULL || pDestEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pSrcEvents->lEventCount; i++)
    {
        for (j = 0; j < pDestEvents->lEventCount; j++)
        {
           if ((StrCmpIW(pSrcEvents->pEventList[i].pEventName, pDestEvents->pEventList[j].pEventName) == 0) &&
                (StrCmpIW(pSrcEvents->pEventList[i].pElementName, pDestEvents->pEventList[j].pElementName) == 0))
            {
            
                pDestEvents->pEventList[j].bAttach = false;
            }
        }

    }
  done:
    return;
}


///////////////////////////////////////////////////////////////
//  Name: Detach
// 
//  Abstract:
//    Handles the detaching from events in a single event list
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Detach(Event *pEvents)
{
    HRESULT hr = S_OK;
    int i = 0;

    if (pEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvents->lEventCount; i++)
    {
        if (pEvents->pEventElements[i] && pEvents->pEventList[i].bAttach == true)
        {
            CComPtr <IDispatchEx> pDispEx;

            hr = THR(pEvents->pEventElements[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
            if (SUCCEEDED(hr))
            {
                //determine if this is a valid event
                DISPID temp;
                if (pEvents->pbDynamicEvents[i] == true)
                {
                    BSTR ScriptEvent = SysAllocString(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name);
                    IGNORE_HR(pEvents->pEventElements[i]->detachEvent(ScriptEvent, (IDispatch *)this));
                    SysFreeString(ScriptEvent);
                    ScriptEvent = NULL;
                }
                else
                {
                    BSTR bstrEventName;
                    bstrEventName = SysAllocString(pEvents->pEventList[i].pEventName);
                    hr = THR(pDispEx->GetDispID(bstrEventName, fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pEvents->pEventElements[i]->detachEvent(bstrEventName, (IDispatch *)this));
                    }
                    SysFreeString(bstrEventName);
                    bstrEventName = NULL;
                }
            }
            pEvents->pEventElements[i]->Release();
            pEvents->pEventElements[i] = NULL;
        }
        pEvents->pEventDispids[i] = INVALID_DISPID;
    }
  done:
    return S_OK;
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Handles the detaching from all events in all event lists.
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::DetachEvents()
{
    if (m_bAttached == true)
    {
        IGNORE_HR(Detach(m_pBeginEvents));
        if (m_bEndAttached == true)
        {
            IGNORE_HR(Detach(m_pEndEvents));
        }
        m_bAttached = false;
    }

    return S_OK;
};


///////////////////////////////////////////////////////////////////////////
// SetNewEventList
//
// Summary:
//     This manages the cleanup of the old event list and the construction 
//     of the new event list.  Passing NULL into bstrEvents causing an 
//     clears the old list and creates an empty new list.  This function
//     should return an empty list on failure.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::SetNewEventStruct(TimeValueList & tvList, Event **ppEvents)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    int i = 0;
    long lCurElement = 0;
    TimeValueSTLList & l = tvList.GetList();
    
    //clean up the old list
    if (*ppEvents != NULL)
    {
        for (i = 0; i < (*ppEvents)->lEventCount; i++)
        {
            if ((*ppEvents)->pEventElements[i] != NULL)
            {
                (*ppEvents)->pEventElements[i] ->Release();
                (*ppEvents)->pEventElements[i]  = NULL;
            }
            if ((*ppEvents)->pEventList[i].pEventName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pEventName;
            }
            if ((*ppEvents)->pEventList[i].pElementName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pElementName;
            }
        }
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;        
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;
                    
        delete [] *ppEvents;
        *ppEvents = NULL;
    }
    //Create a new Event object
    *ppEvents = NEW Event;
    if (*ppEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    lCount = GetEventCount(tvList);
    if (lCount == 0)
    {
        ZeroMemory(*ppEvents, sizeof(Event));
        goto done;
    }
    
    //allocate the new event list
    (*ppEvents)->pEventList = NEW EventItem[lCount];
    if (NULL == (*ppEvents)->pEventList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
    (*ppEvents)->pEventDispids = NEW DISPID[lCount];
    (*ppEvents)->pEventElements = NEW IHTMLElement2* [lCount];
    (*ppEvents)->pbDynamicEvents = NEW bool[lCount];
    (*ppEvents)->lEventCount = lCount;

    if ((*ppEvents)->pEventList == NULL ||
        (*ppEvents)->pEventDispids == NULL ||
        (*ppEvents)->pEventElements == NULL ||
        (*ppEvents)->pbDynamicEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;
        goto done;
    }

    ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
    ZeroMemory((*ppEvents)->pEventDispids, sizeof(DISPID) * lCount);
    ZeroMemory((*ppEvents)->pEventElements, sizeof(IHTMLElement2 *) * lCount);
    ZeroMemory((*ppEvents)->pbDynamicEvents, sizeof(bool) * lCount);

    lCurElement = 0;

    {
        for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
        {
            TimeValue *p = (*iter);
            
            if (p->GetEvent() != NULL &&
                StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) != 0 && //remove all non events from the count
                StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) != 0 &&
                StrCmpIW(p->GetEvent(), WZ_INDEFINITE) != 0 )
            {
                (*ppEvents)->pEventList[lCurElement].pEventName = CopyString(p->GetEvent());
                if (p->GetElement() == NULL)
                {
                    (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(L"this");
                }
                else
                {
                    (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(p->GetElement());
                }
                (*ppEvents)->pEventList[lCurElement].offset = (float)p->GetOffset();
                (*ppEvents)->pEventList[lCurElement].bAttach = true;

                if ((*ppEvents)->pEventList[lCurElement].pElementName == NULL ||
                    (*ppEvents)->pEventList[lCurElement].pEventName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
                lCurElement += 1;

                if (lstrlenW(p->GetEvent()) > 2 && StrCmpNIW(p->GetEvent(), L"on", 2) != 0)
                {
                    CComBSTR bstrEvent = L"on";
                    bstrEvent.Append(p->GetEvent());
                    (*ppEvents)->pEventList[lCurElement].pEventName = CopyString(bstrEvent);
                    if (p->GetElement() == NULL)
                    {
                        (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(L"this");
                    }
                    else
                    {
                        (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(p->GetElement());
                    }
                    (*ppEvents)->pEventList[lCurElement].offset = (float)p->GetOffset();
                    (*ppEvents)->pEventList[lCurElement].bAttach = true;

                    if ((*ppEvents)->pEventList[lCurElement].pElementName == NULL ||
                        (*ppEvents)->pEventList[lCurElement].pEventName == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }

                    lCurElement += 1;
                }
            }

        }
    }

    (*ppEvents)->lEventCount = lCurElement;

    hr = S_OK;
    
  done:
    
    if (FAILED(hr) &&
        *ppEvents != NULL)  //need to clean up the event list.
    {
        if ((*ppEvents)->pEventList != NULL)
        {
            for (i = 0; i < (*ppEvents)->lEventCount; i++)
            {
                if ((*ppEvents)->pEventList[i].pEventName != NULL)
                {
                    delete [] (*ppEvents)->pEventList[i].pEventName;
                }
                if ((*ppEvents)->pEventList[i].pElementName != NULL)
                {
                    delete [] (*ppEvents)->pEventList[i].pElementName;
                }
            }
            delete [] (*ppEvents)->pbDynamicEvents;
            delete [] (*ppEvents)->pEventDispids;
            delete [] (*ppEvents)->pEventElements;
            delete [] (*ppEvents)->pEventList;
            
            (*ppEvents)->pbDynamicEvents = NULL;
            (*ppEvents)->pEventDispids = NULL;
            (*ppEvents)->pEventElements = NULL;
            (*ppEvents)->pEventList = NULL;
            (*ppEvents)->lEventCount = 0;
        }
        delete [] *ppEvents;
        *ppEvents = NULL;
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////
// SetNewEventList
//
// Summary:
//     This manages the cleanup of the old event list and the construction 
//     of the new event list.  Passing NULL into bstrEvents causing an 
//     clears the old list and creates an empty new list.  This function
//     should return an empty list on failure.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::SetNewEventList(LPOLESTR lpstrEvents, Event **ppEvents)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    int i = 0;

    if (*ppEvents != NULL)
    {
        for (i = 0; i < (*ppEvents)->lEventCount; i++)
        {
            if ((*ppEvents)->pEventElements[i] != NULL)
            {
                (*ppEvents)->pEventElements[i]->Release();
                (*ppEvents)->pEventElements[i]  = NULL;
            }
            if ((*ppEvents)->pEventList[i].pEventName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pEventName;
            }
            if ((*ppEvents)->pEventList[i].pElementName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pElementName;
            }
        }
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;        
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;

        delete [] *ppEvents;
        *ppEvents = NULL;
    }
    
    //count the new number of events
    if (lpstrEvents != NULL)
    {
        lCount = GetEventCount(lpstrEvents);

        //Create a new Event object
        *ppEvents = NEW Event;    
        if (*ppEvents == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        //allocate the new event list
        (*ppEvents)->pEventList = NEW EventItem[lCount];
        if (NULL == (*ppEvents)->pEventList)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
        (*ppEvents)->pEventDispids = NEW DISPID[lCount];
        (*ppEvents)->pEventElements = NEW IHTMLElement2* [lCount];
        (*ppEvents)->pbDynamicEvents = NEW bool[lCount];
        (*ppEvents)->lEventCount = lCount;

        if ((*ppEvents)->pEventList == NULL ||
            (*ppEvents)->pEventDispids == NULL ||
            (*ppEvents)->pEventElements == NULL ||
            (*ppEvents)->pbDynamicEvents == NULL)
        {
            hr = E_OUTOFMEMORY;
            delete [] (*ppEvents)->pbDynamicEvents;
            delete [] (*ppEvents)->pEventDispids;
            delete [] (*ppEvents)->pEventElements;
            delete [] (*ppEvents)->pEventList;
            (*ppEvents)->lEventCount = 0;
            (*ppEvents)->pbDynamicEvents = NULL;
            (*ppEvents)->pEventDispids = NULL;
            (*ppEvents)->pEventElements = NULL;
            (*ppEvents)->pEventList = NULL;
            goto done;
        }

        ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
        ZeroMemory((*ppEvents)->pEventDispids, sizeof(DISPID) * lCount);
        ZeroMemory((*ppEvents)->pEventElements, sizeof(IHTMLElement2 *) * lCount);
        ZeroMemory((*ppEvents)->pbDynamicEvents, sizeof(bool) * lCount);

        //initialize the bAttach variable to true
        for (i = 0; i < lCount; i++)
        {
            (*ppEvents)->pEventList[i].bAttach = true;
            (*ppEvents)->pEventList[i].offset = 0;
        }
    
        //put the new events into the event list
        hr = THR(GetEvents(lpstrEvents, (*ppEvents)->pEventList, (*ppEvents)->lEventCount));
        if (FAILED(hr))  //need to clean up the event list.
        {
            if ((*ppEvents)->pEventList != NULL)
            {
                for (i = 0; i < (*ppEvents)->lEventCount; i++)
                {
                    if ((*ppEvents)->pEventList[i].pEventName != NULL)
                    {
                        delete [] (*ppEvents)->pEventList[i].pEventName;
                    }
                    if ((*ppEvents)->pEventList[i].pElementName != NULL)
                    {
                        delete [] (*ppEvents)->pEventList[i].pElementName;
                    }
                }
                delete [] (*ppEvents)->pbDynamicEvents;
                delete [] (*ppEvents)->pEventDispids;
                delete [] (*ppEvents)->pEventElements;
                delete [] (*ppEvents)->pEventList;
                
                (*ppEvents)->pbDynamicEvents = NULL;
                (*ppEvents)->pEventDispids = NULL;
                (*ppEvents)->pEventElements = NULL;
                (*ppEvents)->pEventList = NULL;
                (*ppEvents)->lEventCount = 0;
            }
            goto done;
        }
    }

    hr = S_OK;
    
  done:
    if (FAILED(hr) &&
        *ppEvents != NULL)  //need to clean up the event list.
    {
        delete [] *ppEvents;
        *ppEvents = NULL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////
// GetEvents
//
// Summary:
//     Parses the event string and puts the data into the event list.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEvents(LPOLESTR bstrEvents, EventItem *pEvents, long lEventCount)
{
    HRESULT hr = S_OK;
    
    UINT iLen = 0;
    UINT iCurLen = 0;
    OLECHAR *curChar;
    int i = 0, j = 0;
    OLECHAR *sTemp = NULL;
    
    iLen = lstrlenW(bstrEvents);
    
    if (iLen == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    sTemp = NEW OLECHAR [iLen + 1];
    if (sTemp == NULL)
    {
        hr = E_FAIL;
        goto done;
    }


    curChar = bstrEvents;
    for (j = 0; j < lEventCount; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * iLen);
        
        i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < (int)(iLen - 1) && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
                i++;
            }
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
        

        //check to see if the name is "this".
        if (StrCmpIW(sTemp, L"this") == 0)
        {
            //if it is, chang it to the name of the current element.
            CComPtr <IHTMLElement> pEle;
            BSTR bstrElement;

            hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
            if (FAILED(hr))
             {
                goto done;
            }
            
            hr = THR(pEle->get_id(&bstrElement));

            if (FAILED(hr))
            {
                goto done;
            }
            iCurLen = SysStringLen(bstrElement);
            pEvents[j].pElementName = NEW OLECHAR [iCurLen + 1];
            if (pEvents[j].pElementName == NULL)
            {
                SysFreeString(bstrElement);
                bstrElement = NULL;
                hr = E_OUTOFMEMORY;
                goto done;
            }

            ZeroMemory(pEvents[j].pElementName, sizeof(OLECHAR) * (iCurLen + 1));
            ocscpy(pEvents[j].pElementName, bstrElement);
        }
        else
        {        
            //else copy it into the event list.
            iCurLen = ocslen(sTemp);
            pEvents[j].pElementName = NEW OLECHAR [iCurLen + 1];
            if (pEvents[j].pElementName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            ZeroMemory(pEvents[j].pElementName, sizeof(OLECHAR) * (iCurLen + 1));
            ocscpy(pEvents[j].pElementName, sTemp);
        }

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * iLen);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < (int)(iLen - 1) && *curChar != ';' && *curChar != '\0')
        {
            sTemp[i] = *curChar;
            i++;
            curChar++;
        }
        
        //strip out trailing spaces
        i--;
        while (sTemp[i] == ' ' && i > 0)
        {
            sTemp[i] = '\0';
            i--;
        }

        //set the event name in the event list
        iCurLen = ocslen(sTemp);
        pEvents[j].pEventName = NEW OLECHAR [iCurLen + 1];
        if (pEvents[j].pEventName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        else
        {
            ocscpy(pEvents[j].pEventName, sTemp);
        }

        if (lstrlenW(pEvents[j].pEventName) > 2 && StrCmpNIW(pEvents[j].pEventName, L"on", 2) != 0)
        {
            j++;
            if (pEvents[j-1].pElementName)
            {
                pEvents[j].pElementName = CopyString(pEvents[j-1].pElementName);
            }
            if (pEvents[j-1].pEventName)
            {
                CComBSTR bstrEvent = L"on";
                bstrEvent.Append(pEvents[j-1].pEventName);
                pEvents[j].pEventName = CopyString(bstrEvent);
            }
        }
        //advance curChar to the next element or the end of the string
        if (j < lEventCount - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

done:

    if (sTemp != NULL)
    {
        delete [] sTemp;
    }
    return hr;

}

///////////////////////////////////////////////////////////////
//  Name: EventNotifyMatch
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void CEventMgr::EventNotifyMatch(IHTMLEventObj *pEventObj)
{
    BSTR bstrEleName = NULL, bstrSrcEleName = NULL, bstrEvent = NULL;
    CComPtr<IHTMLElement> pSrcEle;
    CComPtr<IHTMLElement> pAttachedEle;
    CComPtr<IHTMLEventObj2> pEventObj2;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //get the element name
    hr = THR(pEventObj->get_srcElement(&pSrcEle));
    if (FAILED(hr) || pSrcEle == NULL)
    {
        goto done;
    }    

    //get this attached elements name
    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pAttachedEle));
    if (FAILED(hr))
    {
        goto done;
    }   

    hr = THR(pAttachedEle->get_id(&bstrEleName));
    if (FAILED(hr))
    {
        goto done;
    }   

    //get the name of the event source
    hr = THR(pSrcEle->get_id(&bstrSrcEleName));
    if (FAILED(hr))
    {
        goto done;
    }    

    if (StrCmpIW(bstrEleName, bstrSrcEleName) == 0)
    {
        //get the event name
        hr = THR(pEventObj->get_type(&bstrEvent));
        if (FAILED(hr))
        {
            goto done;
        }   

        if (ValidateEvent(bstrEvent, pEventObj2, m_pElement) == false)
        {
            //this is not a valid event at this time.
            goto done;
        }

        for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
        {
            if (StrCmpIW(bstrEvent, g_NotifiedEvents[i].wsz_name) == 0)
            {
                m_pEventSite->EventNotify(g_NotifiedEvents[i].event);
            }
        }
    }

  done:
    if (bstrEleName)
    {
        SysFreeString(bstrEleName);
        bstrEleName = NULL;
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
        bstrEvent = NULL;
    }
    if (bstrSrcEleName)
    {
        SysFreeString(bstrSrcEleName);
        bstrSrcEleName = NULL;
    }
    return;
}

///////////////////////////////////////////////////////////////
//  Name: AttachNotifyEvents
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void
CEventMgr::AttachNotifyEvents()
{
    HRESULT hr;
    VARIANT_BOOL bSuccess = FALSE;

    CComPtr<IHTMLElement2> spElement2;
    hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        return;
    }

    for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
    {
        if (m_bNotifyEvents[i] == true)
        {
            BSTR bstrEventName = SysAllocString(g_NotifiedEvents[i].wsz_name);
            IGNORE_HR(spElement2->attachEvent(bstrEventName, (IDispatch *)this, &bSuccess));
            SysFreeString(bstrEventName);
            bstrEventName = NULL;
        }
    }

  done:

    return;
}

///////////////////////////////////////////////////////////////
//  Name: DetachNotifyEvents
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void
CEventMgr::DetachNotifyEvents()
{
    HRESULT hr;
    CComPtr<IHTMLElement2> spElement2;
    hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        return;
    }

    for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
    {
        if (m_bNotifyEvents[i] == true)
        {
            BSTR bstrEventName = SysAllocString(g_NotifiedEvents[i].wsz_name);
            IGNORE_HR(spElement2->detachEvent(bstrEventName, (IDispatch *)this));
            SysFreeString(bstrEventName);
            bstrEventName = NULL;
        }
    }

  done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: ValidateEvent
// 
//  Parameters:
//    BSTR bstrEventName        The cached event name (e.g. "mouseover")
//    IHTMLEventObj *pEventObj  A pointer to the event object
//    IHTMLElement  *pElement   The element on which the event is occurring
//
//  Abstract:
//    Determines if the event is valid - used to filter out mouseover and mouseout events
//    happening on child elements, if the appropriate flag is set.
///////////////////////////////////////////////////////////////

bool CEventMgr::ValidateEvent(LPOLESTR lpszEventName, IHTMLEventObj2 *pEventObj, IHTMLElement *pElement)
{
    HRESULT hr;
    bool bReturn = false;
    VARIANT vValidate;
    CComBSTR bstrFilter = WZ_FILTER_MOUSE_EVENTS;
    VariantInit(&vValidate);
    if (pElement == NULL)
    {
        bReturn = true;
        goto done;
    }

    hr = pElement->getAttribute(bstrFilter, 0, &vValidate);
    if (FAILED(hr) || vValidate.vt == VT_EMPTY)
    {
        bReturn = true;
        goto done;
    }
    
    if (vValidate.vt != VT_BOOL)
    {
        hr = VariantChangeTypeEx(&vValidate, &vValidate, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL);
        if (FAILED(hr))
        {
            bReturn = true;
            goto done;
        }
    }

    if (vValidate.boolVal == VARIANT_FALSE)
    {
        bReturn = false;
        goto done;
    }

    if (StrCmpIW(lpszEventName, L"mouseout") == 0)
    {
        // Check that event.toElement is NOT contained in pElement
        CComPtr <IHTMLElement> pToElement;
        
        hr = pEventObj->get_toElement(&pToElement);

        if (SUCCEEDED(hr) && pToElement)
        {
            VARIANT_BOOL varContained;
            hr = pElement->contains(pToElement, &varContained);

            if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
            {
                bReturn = false;
                goto done;
            }
        }
    }
    else if (StrCmpIW(lpszEventName, L"mouseover") == 0)
    {
        // Check that event.fromElement is NOT contained in pElement
        CComPtr <IHTMLElement> pFromElement;
        hr = pEventObj->get_fromElement(&pFromElement);
        if (SUCCEEDED(hr) && pFromElement)
        {
            VARIANT_BOOL varContained;
            hr = pElement->contains(pFromElement, &varContained);

            if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
            {
                bReturn = false;
                goto done;
            }
        }
    }

    bReturn = true;

  done:
    VariantClear(&vValidate);
    return bReturn;
}

//returns -1 if this is not a time event or the index of the time event if it is.
int 
CEventMgr::isTimeEvent(LPOLESTR lpszEventName)
{
    int i = 0;
    int iReturn = -1;
    if (lpszEventName == NULL)
    {
        goto done;
    }
    for (i = 0; i < TE_MAX; i++)
    {
        if (g_FiredEvents[i].wsz_name == NULL)
        {
            continue;
        }
        if (StrCmpIW(g_FiredEvents[i].wsz_name, lpszEventName) == 0)
        {
            iReturn = i;
            goto done;
        }
    }
  done:

    return iReturn;
}

long 
CEventMgr::GetEventCount(TimeValueList & tvList)
{
    long lCount = 0;
    TimeValueSTLList & l = tvList.GetList();

    for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
    {
        TimeValue *p = (*iter);
        lCount++;
        LPOLESTR szEvent = p->GetEvent();
        if (szEvent == NULL)
        {
            continue;
        }

        if (lstrlenW(szEvent) > 2)
        {
            if (StrCmpNIW(szEvent, L"on", 2) != 0)
            {  //if this event starts with "on" add an extra event so the same event can be attached to with the "on"
                lCount++;
            }   
        }
    }

    return lCount;
}

void
CEventMgr::UpdateReadyState()
{
    HRESULT hr;
    BSTR bstrReadyState = NULL;
       
    hr = THR(::GetReadyState(m_pElement,
                             &bstrReadyState));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_bNotifyEvents[TEN_READYSTATECHANGE] == true)
    {   
        m_pEventSite->onReadyStateChangeEvent(bstrReadyState);
    }
                
    if (bstrReadyState != NULL &&
        StrCmpIW(L"complete",bstrReadyState) == 0)
    {
        if (!m_bReady)
        {
            m_bReady = true;
            AttachNotifyEvents();
            IGNORE_HR(AttachEvents());
        }
    }

  done:
    SysFreeString(bstrReadyState);
    return;
}


HRESULT 
CEventMgr::_ToggleEndEvent(bool bOn)
{
    HRESULT hr = S_OK;

    if (bOn == m_bEndAttached)
    {
        goto done;
    }

    if (bOn == true)
    {
        m_bEndAttached = true;
        if (m_pEndEvents)
        {
            IGNORE_HR(Attach(m_pEndEvents));
        }
    }
    else 
    {
        m_bEndAttached = false;
        if (m_pEndEvents)
        {
            IGNORE_HR(Detach(m_pEndEvents));
        }
    }
    hr = S_OK;
  done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\threadsafelist.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\threadsafelist.cpp
//
//  Contents: definitions for CThreadSafeList, and CThreadSafeListNode
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "threadsafelist.h"


//+-----------------------------------------------------------------------
//
//  Function:  PumpMessagesWhileWaiting
//
//  Overview:  Calls WaitForMultipleObjects, and pumps windows message while it is waiting
//
//  Arguments: pHandleArray array of handle to pass to WaitForMultipleObjects
//             iHandleCount count of objects in array
//             dwTimeOut    timeout time
//
//  Returns:   DWORD, object that was signalled
//
//------------------------------------------------------------------------
DWORD 
PumpMessagesWhileWaiting(HANDLE * pHandleArray, UINT iHandleCount, DWORD dwTimeOut)
{
    DWORD dwSignaledObject = 0;

    do
    {
        dwSignaledObject = MsgWaitForMultipleObjects(iHandleCount, pHandleArray, FALSE, dwTimeOut, QS_ALLINPUT);
        
        if (WAIT_OBJECT_0 + iHandleCount == dwSignaledObject)
        {
            MSG msg;
            BOOL bMessageAvailable;
            bMessageAvailable = PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE);
            if (bMessageAvailable)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            
        }
    } while (WAIT_OBJECT_0 + iHandleCount == dwSignaledObject);
    
    return dwSignaledObject;
}

//+-----------------------------------------------------------------------
//
//  Member:    CThreadSafeList
//
//  Overview:  Constructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CThreadSafeList::CThreadSafeList() :
    m_lThreadsWaiting(0),
    m_hDataAvailable(NULL),
    m_hDataRecieved(NULL),
    m_hShutdown(NULL),
    m_lRefCount(0)
{ 
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CThreadSafeList
//
//  Overview:  destructor, closes handles and destroys critical section
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
CThreadSafeList::~CThreadSafeList()
{
    CloseHandle(m_hDataAvailable);
    m_hDataAvailable = NULL;
    CloseHandle(m_hDataRecieved);
    m_hDataRecieved = NULL;
    CloseHandle(m_hShutdown);
    m_hShutdown = NULL;

    Assert(m_listCurrentDownload.empty());
    Assert(m_listToDoDownload.empty());
    Assert(m_listDoneDownload.empty());
}

//+---------------------------------------------------------------------------
//
//  Member:     QueryInterface, IUnknown
//
//  Synopsis:   COM casting method
//
//  Arguments:  riid, requested interface
//
//  Returns:    S_OK if interface is known, otherwise, NOINTERFACE, or POINTER error
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CThreadSafeList::QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
    {
        return E_POINTER;
    }

    *ppvObject = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppvObject = this;
    }

    if ( NULL != *ppvObject )
    {
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}
        
//+---------------------------------------------------------------------------
//
//  Member:     AddRef, IUnknown
//
//  Synopsis:   Increment reference count of this object
//
//  Arguments:  void
//
//  Returns:    new reference count
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CThreadSafeList::AddRef( void)
{
    return InterlockedIncrement(&m_lRefCount);
}
//+---------------------------------------------------------------------------
//
//  Member:     Release, IUnknown
//
//  Synopsis:   Decrement reference count, delete this when at zero
//
//  Arguments:  void
//
//  Returns:    new reference count
//
//----------------------------------------------------------------------------        
STDMETHODIMP_(ULONG)
CThreadSafeList::Release( void)
{
    ULONG l = InterlockedDecrement(&m_lRefCount);
    if (l == 0)
        delete this;
    return l;
}

//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Overview:  Initialize object, create events, destroy events if previously exist
//
//  Arguments: void
//             
//
//  Returns:   S_OK if events all created, otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Init()
{
    HRESULT hr = S_OK;

    if (m_hDataAvailable)
    {
        CloseHandle(m_hDataAvailable);
    }
    m_hDataAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hDataAvailable)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    if (m_hDataRecieved)
    {
        CloseHandle(m_hDataRecieved);
    }
    m_hDataRecieved = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hDataRecieved)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    if (m_hShutdown)
    {
        CloseHandle(m_hShutdown);
    }
    m_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdown)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Detach
//
//  Overview:  Deinitialize object, don't destroy events
//
//  Arguments: void
//             
//
//  Returns:   S_OK if ok, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CThreadSafeList::Detach()
{
    HRESULT hr = S_OK;
    BOOL bSucceeded = TRUE;

    CritSectGrabber cs(m_CriticalSection);

    IGNORE_HR(ClearList(m_listToDoDownload));
    IGNORE_HR(ClearList(m_listDoneDownload));
    
    if (m_hShutdown)
    {
        bSucceeded = SetEvent(m_hShutdown);
        if (FALSE == bSucceeded)
        {
            // #14221, ie 6
            // jeffwall 8/30/99 we could add 2 null media events into the list here
            // we're dead.  The threads won't get stopped.
            hr = THR(E_FAIL);
            Assert(false);
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CThreadSafeList::ClearList(std::list<CThreadSafeListNode*> &listToClear)
{
    HRESULT hr = S_OK;
    
    // empty out the list
    std::list<CThreadSafeListNode * >::iterator iter = listToClear.begin();
    while (iter != listToClear.end())
    {
        delete (*iter);
        std::list<CThreadSafeListNode * >::iterator olditer = iter;
        iter++;
        listToClear.erase(olditer);
    }
    listToClear.clear();

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetThreadsWaiting
//
//  Overview:  returns instantaneous number of threads waiting
//
//  Arguments: 
//
//  Returns:   number of threads waiting
//
//------------------------------------------------------------------------
LONG
CThreadSafeList::GetThreadsWaiting()
{
    CritSectGrabber cs(m_CriticalSection);

    return m_lThreadsWaiting;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Create a new list element, add to todo list
//
//  Arguments: pImportMedia,    unmarshalled interface
//             lPriority,       where to place in list
//
//  Returns:   S_OK, or appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Add(ITIMEImportMedia* pImportMedia)
{
    HRESULT hr = S_OK;
    
    CThreadSafeListNode * pNode = NULL;
    
    bool fInserted = false;
    
    std::list<CThreadSafeListNode * >::iterator iter;
    
    CritSectGrabber cs(m_CriticalSection);
    
    double dblPriority = 0.0;

    hr = pImportMedia->GetPriority(&dblPriority);
    if (FAILED(hr))
    {
        goto done;
    }
    
    pNode = new CThreadSafeListNode(pImportMedia);
    if (NULL == pNode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // sort the classes based on priority -- make this a binary search eventually
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {                
        double dblIterPriority = 0.0;
        hr = (*iter)->GetElement()->GetPriority(&dblIterPriority);
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblPriority < dblIterPriority)
        {
            // insert before
            m_listToDoDownload.insert(iter, pNode);
            fInserted = true;
            break;
        }
        iter++;
    }
    
    if (!fInserted)
    {
        // place at end
        m_listToDoDownload.insert(iter, pNode);
    }    

    m_CriticalSection.Release();

    hr = DataAvailable();
    m_CriticalSection.Grab();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr; //lint !e429 // the newed element is stored in the list
} 

//+-----------------------------------------------------------------------
//
//  Member:    DataAvailable()
//
//  Overview  If threads are waiting for insertion, signal DataAvailable object,
//            then wait for DataRecieved event
//
//  Arguments: void
//
//  Returns:   S_OK, or appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::DataAvailable()
{
    HRESULT hr = S_OK;
    
    CritSectGrabber cs(m_CriticalSection);
    
    if (0 != m_lThreadsWaiting)
    {
        BOOL bSucceeded = FALSE;
        DWORD dwWaitReturn = 0;
        
        bSucceeded = SetEvent(m_hDataAvailable);
        if (FALSE == bSucceeded)
        {
            hr = THR(E_FAIL);
            goto done;
        }
        
        {
            m_CriticalSection.Release();
            
            // wait for a thread to pick this up
            dwWaitReturn = WaitForSingleObjectEx(m_hDataRecieved, TIMEOUT, FALSE);
            
            m_CriticalSection.Grab();
        }
        
        if (WAIT_TIMEOUT == dwWaitReturn)
        {
            // either no thread was waiting (error)
            Assert(m_lThreadsWaiting > 0);
            // or there is a problem with the system
            hr = THR(E_FAIL);
            goto done;
        }
        if (-1 == dwWaitReturn)
        {
            hr = THR(E_FAIL);
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Remove
//
//  Overview:  Remove element from lists, check current list, then todo list
//              if element is in the current download list, wait until it is returned.
//
//             Only a TIME thread can be in this method, 
//              therefore only 1 thread at a time can be in this method.
//              therefore the remove event does not need back notification that it has been recieved
//
//             If more than one thread is ever in this method, there will be bugs aplenty.  
//              Because there is no back notification, the wrong thread could be notified 
//              of the remove, and all download processing would stop.  
//
//  Arguments: pImportMedia, element to remove
//             
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Remove(ITIMEImportMedia* pImportMedia)
{
    HRESULT hr = S_OK;

    std::list<CThreadSafeListNode *>::iterator iter;

    CritSectGrabber cs(m_CriticalSection);

    // look for element in todo list
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listToDoDownload.erase(iter);

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    iter = m_listDoneDownload.begin();
    while (iter != m_listDoneDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listDoneDownload.erase(iter);

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    iter = m_listCurrentDownload.begin();
    while (iter != m_listCurrentDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            (*iter)->RemoveWhenDone();

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ReturnElement
//
//  Overview:  Move returned media to done list, 
//              unless shutting down, or media has been removed, delete then.
//
//  Arguments: pOldMedia, previous media thread was using
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::ReturnElement(ITIMEImportMedia * pOldMedia)
{
    HRESULT hr = S_OK;
    
    std::list<CThreadSafeListNode *>::iterator iter;

    CritSectGrabber cs(m_CriticalSection);

    // remove old media from "out" list
    iter = m_listCurrentDownload.begin();
    while (iter != m_listCurrentDownload.end())
    {
        if ( MatchElements((*iter)->GetElement(), pOldMedia) )
        {
            if ((*iter)->GetRemoveWhenDone() || WAIT_OBJECT_0 == WaitForSingleObjectEx(m_hShutdown, 0, FALSE))
            {
                delete (*iter);
                m_listCurrentDownload.erase(iter);
            }
            else
            {
                m_listDoneDownload.push_back(*iter);
                m_listCurrentDownload.erase(iter);
            }

            break;
        }
        iter++;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetNextElement
//
//  Overview:  
//              wait for data to come available, if needed, wait for dataavailable event, then fire datarecieved
//              then pop front of list into current download list, and set pNewMedia to media element
//
//  Arguments: pOldMedia, previous media thread was using
//             pNewMedia, [out] pointer to new Media
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::GetNextElement(ITIMEImportMedia** pNewMedia, bool fBlockThread /* = true */)
{
    HRESULT hr = S_OK;
    
    BOOL bSucceeded = TRUE;
    
    DWORD dwSignaledObject = 0;

    std::list<CThreadSafeListNode *>::iterator iter;

    CThreadSafeListNode * pNextCueNode = NULL;
    
    CritSectGrabber cs(m_CriticalSection);

    if (NULL == pNewMedia)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    *pNewMedia = NULL;

    // make sure that it isn't time to shutdown
    dwSignaledObject = WaitForSingleObjectEx(m_hShutdown, 0, FALSE);
    if (-1 == dwSignaledObject)
    {
        // failure
        hr = THR(E_FAIL);
        Assert(false && _T("WaitForSingleObjectEx failed!"));
        goto done;
    }
    if (WAIT_OBJECT_0 == dwSignaledObject)
    {
        // time to shutdown
        *pNewMedia = NULL;
        hr = S_OK;
        goto done;
    }

    pNextCueNode = GetNextMediaToCue();
    
    if (fBlockThread)
    {
        // make sure there is something to download
        while (NULL == pNextCueNode)
        {
            HANDLE handleArray[] = { m_hShutdown, m_hDataAvailable };
            
            {
                m_lThreadsWaiting++;
                m_CriticalSection.Release();
                
                dwSignaledObject = PumpMessagesWhileWaiting(handleArray, ARRAY_SIZE(handleArray), INFINITE);
                
                m_CriticalSection.Grab();
                m_lThreadsWaiting--;        
            }
            
            if (-1 == dwSignaledObject)
            {
                // failure
                hr = THR(E_FAIL);
                goto done;
            }
            
            dwSignaledObject -= WAIT_OBJECT_0;
            if (0 == dwSignaledObject)
            {
                // the exit event was set.
                *pNewMedia = NULL;
                hr = S_OK;
                goto done;
            }

            if (WAIT_TIMEOUT != dwSignaledObject)
            {
                // we really got a dataAvailable Event
                bSucceeded = SetEvent(m_hDataRecieved);
                if (FALSE == bSucceeded)
                {
                    hr = THR(E_FAIL);
                    goto done;
                }
            }

            pNextCueNode = GetNextMediaToCue();
        } // while
    }
    else if (NULL == pNextCueNode)
    {
        hr = S_FALSE;
        goto done;
    }

    Assert(NULL != pNextCueNode); 

    // copy structure to "out" list
    m_listCurrentDownload.push_back(pNextCueNode); 

    // return media in new pointer
    *pNewMedia = pNextCueNode->GetElement();
    
    // always addref an outgoing interface
    if (NULL != (*pNewMedia))
    {
        (*pNewMedia)->AddRef();
    }
    else
    {
        Assert(false && "Got a NULL Media pointer from the list");
    }
    
    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    GetNextMediaToCue
//
//  Overview:  Check the ToDo list to see is any media returns true 
//             from CanBeCued. If any media can be cued, it is removed 
//             from the ToDo list and returned to the caller.
//
//  Arguments: void
//
//  Returns:   NULL if nothing can be cued now, or
//             iterator to the first element that can be cued now.
//
//------------------------------------------------------------------------
CThreadSafeListNode*
CThreadSafeList::GetNextMediaToCue()
{
    std::list<CThreadSafeListNode *>::iterator iter;
    
    iter = m_listToDoDownload.begin();
    while ( iter != m_listToDoDownload.end() )
    {
        ITIMEImportMedia * pImportMedia = (*iter)->GetElement();
        
        if (NULL != pImportMedia)
        {
            VARIANT_BOOL vb;
            
            IGNORE_HR(pImportMedia->CanBeCued(&vb));
            if (VARIANT_FALSE != vb)
            {
                CThreadSafeListNode * pRet = (*iter);
                m_listToDoDownload.erase(iter);
                return pRet;
            }
        }
        iter++;
    }
    
    return NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    RePrioritize
//
//  Overview:  caller believes that priority has changed, therefore
//              if media has yet to be downloaded (is in todo list)
//              remove from todo list, call add to reinsert.
//
//  Arguments: pImportMedia - media to reprioritize
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::RePrioritize(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    std::list<CThreadSafeListNode *>::iterator iter;

    bool bFound = false;

    // look for element in todo list
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listToDoDownload.erase(iter);
            
            bFound = true;

            break;
        }
        iter++;
    }

    if (bFound)
    {
        hr = CThreadSafeList::Add(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\loader.cpp ===
// loader.cpp 
//
// (c) 1999 Microsoft Corporation.
//
#include "headers.h"
#include <objbase.h>
#include <initguid.h>
#include "loader.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "wininet.h"

// Need this #define because global headers use some of the deprecated functions. Without this
// #define, we can't build unless we touch code everywhere.
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#undef STRSAFE_NO_DEPRECATE

extern CComPtr<IBindStatusCallback> g_spLoaderBindStatusCallback;

//  NEED_GM_SET causes the default GM set to be loaded by the CLoader.Init() call.
DeclareTag(tagDMLoader, "TIME: DMLoader", "DMLoader methods");

#define NEED_GM_SET

#define AUDIOVBSCRIPT_TEXT L"AudioVBScript"
#define AUDIOVBSCRIPT_LEN (sizeof(AUDIOVBSCRIPT_TEXT)/sizeof(wchar_t))

bool IsAudioVBScriptFile( IStream *pStream )
{
    bool fResult = false;

    // Validate pStream
    if (pStream == NULL)
    {
        return false;
    }

    // Clone pStream
    IStream *pStreamClone = NULL;
    if (SUCCEEDED( pStream->Clone( &pStreamClone ) ) && pStreamClone)
    {
        // Read in the RIFF header to verify that this is a script file and to get the length of the main RIFF chunk
        ULONG lScriptLength = 0;
        DWORD dwHeader[3];
        DWORD dwRead = 0;
        if (SUCCEEDED( pStreamClone->Read( dwHeader, sizeof(DWORD) * 3, &dwRead ) )
        &&  (dwRead == sizeof(DWORD) * 3)
        &&  (dwHeader[0] == FOURCC_RIFF) // RIFF header
        &&  (dwHeader[1] >= sizeof(DWORD)) // Size is valid
        &&  (dwHeader[2] == DMUS_FOURCC_SCRIPT_FORM)) // Script form
        {
            // Store the script chunk's length
            // Need to subtract off the DMUS_FOURCC_SCRIPT_FORM data, since it's considered part of the RIFF chunk
            lScriptLength = dwHeader[1] - sizeof(DWORD);
            WCHAR wcstr[AUDIOVBSCRIPT_LEN];
    
            // Now, search for the DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK chunk

            // Continue while there is enough data in the chunk to read another chunk header
            while (lScriptLength > sizeof(DWORD) * 2)
            {
                DWORD dwHeader[2];
                DWORD dwRead = 0;
                if (FAILED( pStreamClone->Read( dwHeader, sizeof(DWORD) * 2, &dwRead ) )
                ||  (dwRead != sizeof(DWORD) * 2)
                ||  ((lScriptLength - sizeof(DWORD) * 2) < dwHeader[1]))
                {
                    break;
                }
                else
                {
                    // Subtract off the size of this chunk
                    lScriptLength -= sizeof(DWORD) * 2 + dwHeader[1];

                    // Check if this is the language chunk
                    if (dwHeader[0] == DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK)
                    {
                        // Chunk must be exactly the length of "AudioVBScript" plus a NULL
                        if (dwHeader[1] != sizeof(WCHAR) * AUDIOVBSCRIPT_LEN)
                        {
                            break;
                        }
                        else
                        {
                            // Read the string
                            if (FAILED( pStreamClone->Read( wcstr, sizeof(WCHAR) * AUDIOVBSCRIPT_LEN, &dwRead ) )
                            ||  (dwRead != dwHeader[1]))
                            {
                                break;
                            }
                            else
                            {
                                // Compare the strings
                                if (memcmp( wcstr, AUDIOVBSCRIPT_TEXT, sizeof(WCHAR) * AUDIOVBSCRIPT_LEN ) != 0)
                                {
                                    // Not Audio VBScript - fail
                                    break;
                                }
                                else
                                {
                                    // Is Audio VBScript - succeed
                                    fResult = true;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Not the language chunk - skip it
                        LARGE_INTEGER li;
                        li.QuadPart = dwHeader[1];
                        if (FAILED( pStreamClone->Seek( li, STREAM_SEEK_CUR, NULL ) ))
                        {
                            break;
                        }
                    }
                }
            }
        }

        pStreamClone->Release();
    }

    return fResult;
}

CFileStream::CFileStream( CLoader *pLoader)

{
    m_cRef = 1;         // Start with one reference for caller.
    m_pFile = INVALID_HANDLE_VALUE;       // No file yet.
    m_pLoader = pLoader; // Link to loader, so loader can be found from stream.
    if (pLoader)
    {
        pLoader->AddRefP(); // Addref the private counter to avoid cyclic references.
    }
}

CFileStream::~CFileStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
        m_pLoader = NULL;
    }
    Close();
}

HRESULT CFileStream::Open(WCHAR * lpFileName,DWORD dwDesiredAccess)

{
    Close();

    // Store the filename
    HRESULT hr = StringCbCopy(m_wszFileName, sizeof(m_wszFileName), lpFileName);

    // Don't open the file if we had to truncate the name, or we will open a different
    // file than the one we were asked to open. In that case, m_pFile doesn't need
    // to be cleared because the call to Close() above takes care of that
    if(SUCCEEDED(hr))
    {
        if( dwDesiredAccess == GENERIC_READ )
        {
            m_pFile = CreateFileW(lpFileName, 
                                    GENERIC_READ, 
                                    FILE_SHARE_READ, 
                                    NULL, 
                                    OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);
        }
        else if( dwDesiredAccess == GENERIC_WRITE )
        {
            m_pFile = CreateFileW(lpFileName, 
                                    GENERIC_WRITE, 
                                    0, 
                                    NULL, 
                                    CREATE_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);
        }
    }

    if (m_pFile == INVALID_HANDLE_VALUE)
    {
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
} //lint !e550

HRESULT CFileStream::Close()

{
    if (m_pFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_pFile);
        m_pFile = INVALID_HANDLE_VALUE;
    }
    return S_OK;
}

STDMETHODIMP CFileStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/*  The GetLoader interface is used to find the loader from the IStream.
    When an object is loading data from the IStream via the object's
    IPersistStream interface, it may come across a reference chunk that
    references another object that also needs to be loaded. It QI's the
    IStream for the IDirectMusicGetLoader interface. It then uses this
    interface to call GetLoader and get the actual loader. Then, it can
    call GetObject on the loader to load the referenced object.
*/

STDMETHODIMP CFileStream::GetLoader(
    IDirectMusicLoader ** ppLoader) // Returns an AddRef'd pointer to the loader.

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    DWORD dw;
    BOOL bRead = false;
    HRESULT hr = E_FAIL;

    bRead = ReadFile(m_pFile, pv, cb, &dw, NULL);
    //dw = fread( pv, sizeof(char), cb, m_pFile );
    //if ( cb == dw )
    if (bRead)
    {
        if( pcbRead != NULL )
        {
            *pcbRead = dw;
        }
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr ;
}

STDMETHODIMP CFileStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    DWORD dw = 0;
    BOOL bWrite = false;
    HRESULT hr = STG_E_MEDIUMFULL;

    //if( cb == fwrite( pv, sizeof(char), cb, m_pFile ))
    bWrite = WriteFile (m_pFile, pv, cb, &dw, NULL);
    if (bWrite && cb == dw) 
    {
        if( pcbWritten != NULL )
        {
            *pcbWritten = cb;
        }
        hr = S_OK;
    }
    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CFileStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // fseek can't handle a LARGE_INTEGER seek...
    DWORD dwReturn = 0;
    DWORD dwMoveMethod = 0;
    HRESULT hr = E_FAIL;

    //convert the incoming parameter to the correct value
    if (dwOrigin == SEEK_SET)
    {
        dwMoveMethod = FILE_BEGIN;
    }
    else if (dwOrigin == SEEK_CUR)
    {
        dwMoveMethod = FILE_CURRENT;
    }
    else if (dwOrigin == SEEK_END)
    {
        dwMoveMethod = FILE_END;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    //int i = fseek( m_pFile, lOffset, dwOrigin );
    //if( i ) 
    //{
    //  return E_FAIL;
    //}

    dwReturn = SetFilePointer(m_pFile, dlibMove.LowPart, &dlibMove.HighPart, dwMoveMethod);
    if (dwReturn == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
    {
        hr = E_FAIL;
        goto done;
    }

    if( plibNewPosition != NULL )
    {
        plibNewPosition->LowPart = dwReturn;
        plibNewPosition->HighPart = dlibMove.HighPart;
    }

    hr = S_OK;

    done:
    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CFileStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Clone( IStream** ppstm )
{ 
    // Create a new CFileStream
    HRESULT hr = E_OUTOFMEMORY;
    CFileStream *pNewStream = new CFileStream( m_pLoader );
    if (pNewStream)
    {
        // Try and open the file again
        hr = pNewStream->Open(m_wszFileName,GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            // Get our current position 
            LARGE_INTEGER   dlibMove;
            dlibMove.QuadPart = 0;
            ULARGE_INTEGER  libNewPosition;
            hr = Seek( dlibMove, STREAM_SEEK_CUR, &libNewPosition );
            if (SUCCEEDED(hr))
            {
                // Seek to the same position in the new pNewStream
                dlibMove.QuadPart = libNewPosition.QuadPart;
                hr = pNewStream->Seek(dlibMove,STREAM_SEEK_SET,NULL);
                if (SUCCEEDED(hr))
                {
                    // Finally, assign the new file stream to ppstm
                    *ppstm = pNewStream;
                }
            }
        }

        if( FAILED(hr) )
        {
            pNewStream->Release();
            pNewStream = NULL; //lint !e423  This is no leak because the Release handles the delete
        }
    }
	return hr; 
}


CMemStream::CMemStream( CLoader *pLoader)

{
    m_cRef = 1;
    m_pbData = NULL;
    m_llLength = 0;
    m_llPosition = 0;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CMemStream::~CMemStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    m_pbData = NULL;
    m_pLoader = NULL;
        
    Close();
}

HRESULT CMemStream::Open(BYTE *pbData, LONGLONG llLength)

{
    Close();
    m_pbData = pbData;
    m_llLength = llLength;
    m_llPosition = 0;
    if ((pbData == NULL) || (llLength == 0))
    {
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    if (IsBadReadPtr(pbData, (DWORD) llLength))
    {
        m_pbData = NULL;
        m_llLength = 0;
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
}

HRESULT CMemStream::Close()

{
    m_pbData = NULL;
    m_llLength = 0;
    return S_OK;
}

STDMETHODIMP CMemStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP CMemStream::GetLoader(
    IDirectMusicLoader ** ppLoader) 

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CMemStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    if ((cb + m_llPosition) <= m_llLength)
    {
        memcpy(pv,&m_pbData[m_llPosition],cb);
        m_llPosition += cb;
        if( pcbRead != NULL )
        {
            *pcbRead = cb;
        }
        return S_OK;
    }
    return E_FAIL ;
}

STDMETHODIMP CMemStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // Since we only parse RIFF data, we can't have a file over 
    // DWORD in length, so disregard high part of LARGE_INTEGER.

    LONGLONG llOffset;

    llOffset = dlibMove.QuadPart;
    if (dwOrigin == STREAM_SEEK_CUR)
    {
        llOffset += m_llPosition;
    } 
    else if (dwOrigin == STREAM_SEEK_END)
    {
        llOffset += m_llLength;
    }
    if ((llOffset >= 0) && (llOffset <= m_llLength))
    {
        m_llPosition = llOffset;
    }
    else return E_FAIL;

    if( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = m_llPosition;
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Clone( IStream** ppstm )
{ 
    // Create a new CMemStream
    HRESULT hr = E_OUTOFMEMORY;
    CMemStream *pMemStream = new CMemStream( m_pLoader );
    if (pMemStream)
    {
        // Open the same memory location
        hr = pMemStream->Open( m_pbData, m_llLength );
        if (SUCCEEDED(hr))
        {
            // Set the new stream to the same position
            pMemStream->m_llPosition = m_llPosition;
            *ppstm = pMemStream;
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            pMemStream->Release();
            pMemStream = NULL; //lint !e423  This is no leak because the Release handles the delete
        }
    }
    return hr; 
}


CLoader::CLoader()

{
    InitializeCriticalSection(&m_CriticalSection);
    m_cRef = 1;
    m_cPRef = 0;
    m_pObjectList = NULL;
    m_bstrSrc = NULL;
}

CLoader::~CLoader()

{
    CLoader::ClearCache(GUID_DirectMusicAllTypes);
    if (m_bstrSrc)
    {
        SysFreeString(m_bstrSrc);
        m_bstrSrc = NULL;
    }
    
    DeleteCriticalSection(&m_CriticalSection);
    m_pObjectList = NULL;
}


HRESULT CLoader::Init()

{
    HRESULT hr = S_OK;

    // If support for the GM set is desired, create a direct music loader
    // and get the GM dls collection from it, then release that loader.
#ifdef NEED_GM_SET
    IDirectMusicLoader *pLoader;
    hr = CoCreateInstance(            
        CLSID_DirectMusicLoader,
        NULL,            
        CLSCTX_INPROC,             
        IID_IDirectMusicLoader,
        (void**)&pLoader); 
    if (SUCCEEDED(hr))
    {
        DMUS_OBJECTDESC ObjDesc;     
        IDirectMusicObject* pGMSet = NULL; 
        ObjDesc.guidClass = CLSID_DirectMusicCollection;
        ObjDesc.guidObject = GUID_DefaultGMCollection;
        ObjDesc.dwSize = sizeof(DMUS_OBJECTDESC);
        ObjDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT;
        hr = pLoader->GetObject( &ObjDesc,
                IID_IDirectMusicObject, (void**) &pGMSet );
        if (SUCCEEDED(hr))
        {
            CObjectRef *pRef = new CObjectRef();
            if (pRef)
            {
                pRef->m_guidObject = GUID_DefaultGMCollection;
                pRef->m_pNext = m_pObjectList;
                m_pObjectList = pRef;
                pRef->m_pObject = pGMSet;
                pGMSet->AddRef();
            }
            pGMSet->Release();
        }
        pLoader->Release();
    }
#endif
    return hr;
}

HRESULT
CLoader::GetSegment(BSTR bstrSrc, IDirectMusicSegment **ppSeg)
{
    if (m_bstrSrc)
    {
        SysFreeString(m_bstrSrc);
        m_bstrSrc = NULL;
    }
    m_bstrSrc = SysAllocString(bstrSrc);
    if (!m_bstrSrc)
    {
        return E_OUTOFMEMORY;
    }

    DMUS_OBJECTDESC ObjDesc;
    ObjDesc.guidClass = CLSID_DirectMusicSegment;
    ObjDesc.dwSize = sizeof(DMUS_OBJECTDESC);
    ObjDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;

    // find the filename
    const WCHAR *pwszSlash = NULL;
    for (const WCHAR *pwsz = m_bstrSrc; *pwsz; ++pwsz)
    {
        if (*pwsz == L'\\' || *pwsz == L'/')
        {
            pwszSlash = pwsz;
        }
    }

    if (!pwszSlash || wcslen(pwszSlash + 1) >= DMUS_MAX_NAME)
    {
        return E_INVALIDARG;
    }
    StringCbCopy(ObjDesc.wszFileName, sizeof(ObjDesc.wszFileName), pwszSlash + 1);

    return GetObject(&ObjDesc, IID_IDirectMusicSegment, reinterpret_cast<void**>(ppSeg));
}

// CLoader::QueryInterface
//
STDMETHODIMP
CLoader::QueryInterface(const IID &iid,
                                   void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicLoader) 
    {
        *ppv = static_cast<IDirectMusicLoader*>(this);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CLoader::AddRef
//
STDMETHODIMP_(ULONG)
CLoader::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CLoader::AddRefP()
{
    return InterlockedIncrement(&m_cPRef);
}

// CLoader::Release
//
STDMETHODIMP_(ULONG)
CLoader::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        InterlockedIncrement(&m_cRef);      // Keep streams from deleting loader.
        ClearCache(GUID_DirectMusicAllTypes);
        if (!InterlockedDecrement(&m_cRef))
        {
            if (!m_cPRef)
            {
                delete this;
                return 0;
            }
        }
    }
    return m_cRef;
}

ULONG CLoader::ReleaseP()
{
    if (!InterlockedDecrement(&m_cPRef)) 
    {
        if (!m_cRef)
        {
            delete this;
            return 0;
        }
    }
    return m_cPRef;
}

STDMETHODIMP CLoader::GetObject(
    LPDMUS_OBJECTDESC pDESC,    // Description of the requested object in <t DMUS_OBJECTDESC> structure.
    REFIID riid,                // The interface type to return in <p ppv>
    LPVOID FAR *ppv)            // Receives the interface on success.

{
    HRESULT hr = E_NOTIMPL;

    EnterCriticalSection(&m_CriticalSection);
    IDirectMusicObject * pIObject = NULL;

    // At this point, the loader should check with all the objects it already
    // has loaded. It should look for file name, object guid, and name.
    // In this case, we are being cheap and looking for only the object's
    // guid and its filename.  The GUID is guaranteed to be unique when
    // the file was created with DirectMusic Producer.  However, the same file
    // could be referenced on a web page multiple times by only its filename.
    // (Nobody would manually type a GUID into their HTML.)  Also there is a
    // problem with DirectX 6.1 and 7.0 that causes DLS collections not to
    // report their GUIDs.  So we also look for an object with matching filename.

    // If it sees that the object is already loaded, it should
    // return a pointer to that one and increment the reference.
    // It is very important to keep the previously loaded objects
    // "cached" in this way. Otherwise, objects, like DLS collections, will get loaded
    // multiple times with a very great expense in memory and efficiency!
    // This is primarily an issue when object reference each other. For
    // example, segments reference style and collection objects.

    CObjectRef * pObject = NULL;
    for (pObject = m_pObjectList;pObject;pObject = pObject->m_pNext)
    {
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT && pObject->m_guidObject != GUID_NULL)
        {
            // We have the GUIDs of both objects so compare by GUID, which is most precise.
            // (If different objects have the same filename then GUIDs will be used to tell them apart.)
            if (pDESC->guidObject == pObject->m_guidObject)
                break;
        }
        else
        {
            // Compare the filenames.
            if ((pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH) && 0 == _wcsicmp(pDESC->wszFileName, pObject->m_wszFileName))
                break;
        }
    }

    // If we found an object, and it has been loaded
    if (pObject && pObject->m_pObject)
    {
        // QI the object for the requested interface
        hr = pObject->m_pObject->QueryInterface( riid, ppv );
        LeaveCriticalSection(&m_CriticalSection);
        return hr;
    }

    // If we found an object, and it has not been loaded, it must have a valid IStream pointer in it
    // or have a valid filename
    if( pObject && (pObject->m_pStream == NULL) )
    {
        // Not supposed to happen
        LeaveCriticalSection(&m_CriticalSection);
        return E_FAIL;
    }

    // Try and create the requested object
    hr = CoCreateInstance(pDESC->guidClass,
    NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
    (void **) &pIObject);
    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CriticalSection);
        return hr;
    }

    // By default, flag that we created pObject
    bool fCreatedpObject = true;

    if( pObject )
    {
        // If we already found the object, just keep a pointer to the object
        pObject->m_pObject = pIObject;
        pIObject->AddRef();

        // Flag that we didn't create pObject
        fCreatedpObject = false;
    }
    else
    {
        // Create a new object to store in the list
        pObject = new CObjectRef;
        if (pObject)
        {
            // Get the filename from the descriptor that was used to load the object.  This assures that
            // the file can be found in the cache with just a filename.  For example, a second player that
            // requests the same segment won't have its GUID so must find it by filename.
            if (pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH)
                StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), pDESC->wszFileName);

            // Now, add the object to our list
            pObject->m_pNext = m_pObjectList;
            m_pObjectList = pObject;

            // If we succeeded in creating the DirectMusic object,
            // keep a pointer to it and addref it
            pObject->m_pObject = pIObject;
            pIObject->AddRef();
        }
        else
        {
            // Couldn't create list item - release the object and return
            pIObject->Release();
            LeaveCriticalSection(&m_CriticalSection);
            return E_OUTOFMEMORY;
        }
    }

    // If we found an object (i.e., didn't create one), try and load it from its IStream pointer
    // or filename
    // This only happens if fCreatedpObject is false (meaning 
    if( !fCreatedpObject )
    {
        if( pObject->m_pStream )
        {
            // If the object has a stream pointer, load from the stream
            // This is the case if the object is embedded within a container
            hr = LoadFromStream(pObject->m_guidClass, pObject->m_pStream, pIObject);
        }
        else
        {
            hr = DMUS_E_LOADER_NOFILENAME;
        }
    }
    // Otherwise, load the object from whatever is valid
    else if (pDESC->dwValidData & DMUS_OBJ_FILENAME)
    {
        hr = LoadFromFile(pDESC,pIObject);
    }
    else if (pDESC->dwValidData & DMUS_OBJ_MEMORY)
    {
        hr = LoadFromMemory(pDESC,pIObject);
    }
    else if( pDESC->dwValidData & DMUS_OBJ_STREAM)
    {
        hr = LoadFromStream(pDESC->guidClass, pDESC->pStream, pIObject);
    }
    else
    {
        hr = DMUS_E_LOADER_NOFILENAME;
    }

    // If load succeeded
    if (SUCCEEDED(hr))
    {
        // Keep the guid and filename for finding it next time.

        // Get the object descriptor
        DMUS_OBJECTDESC DESC;
        memset((void *)&DESC,0,sizeof(DESC));
        DESC.dwSize = sizeof (DMUS_OBJECTDESC); 
        hr = pIObject->GetDescriptor(&DESC);
        if( SUCCEEDED( hr ) )
        {
            // Save the GUID from the object.
            if (DESC.dwValidData & DMUS_OBJ_OBJECT)
                pObject->m_guidObject = DESC.guidObject;

            // If filename for this object is not set, but DESC has it,
            // then copy the filename into our list item
            if (pObject->m_wszFileName[0] == 0 && (DESC.dwValidData & DMUS_OBJ_FILENAME || DESC.dwValidData & DMUS_OBJ_FULLPATH))
                StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), DESC.wszFileName);


        }

        // Finally, QI for the interface requested by the calling method
        hr = pIObject->QueryInterface( riid, ppv );
    }
    else
    {
        // Remove pObject's pointer to the DirectMusic object
        pObject->m_pObject->Release();
        pObject->m_pObject = NULL;

        // If we created pObject
        if( fCreatedpObject )
        {
            // Remove object from list

            // If object is at head of list
            if( m_pObjectList == pObject )
            {
                m_pObjectList = m_pObjectList->m_pNext;
            }
            else
            {
                // Object not at the head of the list - probably tried to load
                // a container, which then loaded other objects

                // Find object
                CObjectRef *pPrevRef = m_pObjectList;
                CObjectRef *pTmpRef = pPrevRef->m_pNext;
                while( pTmpRef && pTmpRef != pObject )
                {
                    pPrevRef = pTmpRef;
                    pTmpRef = pTmpRef->m_pNext;
                }

                // If we found the object (we should have)
                if( pTmpRef == pObject )
                {
                    // Make the list skip the object
                    pPrevRef->m_pNext = pObject->m_pNext;
                }
            }

            // Clear the list object's next pointer
            pObject->m_pNext = NULL;

            // Delete pObject
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
                pObject->m_pStream = NULL;
            }
            delete pObject;
            pObject = NULL;
        }
    }
    // In all cases, release pIObject
    pIObject->Release();

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CLoader::LoadFromFile(LPDMUS_OBJECTDESC pDesc,IDirectMusicObject * pIObject)

{
    HRESULT hr = S_OK;

    if ((pDesc->dwValidData & DMUS_OBJ_FULLPATH) || !(pDesc->dwValidData & DMUS_OBJ_FILENAME))
    {
        return E_INVALIDARG; // only accept relative paths
    }

    // Resolve relative to m_bstrSrc
    WCHAR wszURL[MAX_PATH + 1] = L"";
    DWORD dwLength = MAX_PATH;
    if (!InternetCombineUrlW(m_bstrSrc, pDesc->wszFileName, wszURL, &dwLength, 0))
    {
        return E_INVALIDARG;
    }

    TraceTag((tagDMLoader, "CLoader::LoadFromFile downloading  %S", wszURL));

    // Download the URL
    WCHAR wszFilename[MAX_PATH + 1] = L"";
    hr = URLDownloadToCacheFileW(NULL, wszURL, wszFilename, MAX_PATH, 0, g_spLoaderBindStatusCallback);
    if (FAILED(hr))
    {
        return hr;
    }

    pDesc->dwValidData &= ~DMUS_OBJ_FILENAME;
    pDesc->dwValidData |= DMUS_OBJ_FULLPATH;

    CFileStream *pStream = new CFileStream ( this );
    if (pStream)
    {
        if (!(pDesc->dwValidData & DMUS_OBJ_FULLPATH))
        {
            pStream->Release();
            pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
            return E_INVALIDARG;
        }

        TraceTag((tagDMLoader, "CLoader::LoadFromFile loading object from %S", wszFilename));

        hr = pStream->Open(wszFilename, GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == pDesc->guidClass) 
            {
                if (!IsAudioVBScriptFile( pStream ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS = NULL;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStream );
                    pIPS->Release();
                }
            }
        }
        pStream->Release();
        pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CLoader::LoadFromMemory(LPDMUS_OBJECTDESC pDesc,IDirectMusicObject * pIObject)

{
    HRESULT hr;
    CMemStream *pStream = new CMemStream ( this );
    if (pStream)
    {
        hr = pStream->Open(pDesc->pbMemData,pDesc->llMemLength);
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == pDesc->guidClass) 
            {
                if (!IsAudioVBScriptFile( pStream ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStream );
                    pIPS->Release();
                }
            }
        }
        pStream->Release(); 
        pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CLoader::LoadFromStream(REFGUID rguidClass, IStream *pStream,IDirectMusicObject * pIObject)

{
    HRESULT hr;
    if (pStream)
    {
        // Need to load from a clone of the given IStream, so we don't move its position
        IStream *pStreamClone;
        hr = pStream->Clone( &pStreamClone );
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == rguidClass) 
            {
                if (!IsAudioVBScriptFile( pStreamClone ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStreamClone );
                    pIPS->Release();
                }
            }

            pStreamClone->Release(); 
       }
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}


STDMETHODIMP CLoader::SetObject(
    LPDMUS_OBJECTDESC pDESC)

{
    HRESULT hr = E_FAIL;
    EnterCriticalSection(&m_CriticalSection);

    // Search for the given object descriptor
    CObjectRef * pObject = NULL;
    for (pObject = m_pObjectList;pObject;pObject = pObject->m_pNext)
    {
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT && pObject->m_guidObject != GUID_NULL)
        {
            // We have the GUIDs of both objects so compare by GUID, which is most precise.
            // (If different objects have the same filename then GUIDs will be used to tell them apart.)
            if (pDESC->guidObject == pObject->m_guidObject)
                break;
        }
        else
        {
            // Comare the filenames.
            if ((pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH) && 0 == _wcsicmp(pDESC->wszFileName, pObject->m_wszFileName))
                break;
        }
    }

    if (pObject)
    {
        // Don't support merging data with existing objects
        LeaveCriticalSection(&m_CriticalSection);
        return E_INVALIDARG;
    }

    // Ensure that the object's stream and class is set
    if( !(pDESC->dwValidData & DMUS_OBJ_STREAM) || !(pDESC->dwValidData & DMUS_OBJ_CLASS) )
    {
        // Don't support merging data with existing objects
        LeaveCriticalSection(&m_CriticalSection);
        return E_INVALIDARG;
    }

    // Otherwise, create a new object
    pObject = new CObjectRef();
    if (pObject)
    {
        hr = S_OK;

        // Set the object's fields
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT)
        {
            pObject->m_guidObject = pDESC->guidObject;
        }
        if (pDESC->dwValidData & DMUS_OBJ_FILENAME)
        {
            hr = StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), pDESC->wszFileName);
        }

        if (SUCCEEDED(hr))
        {
            // Copy the object's class
            pObject->m_guidClass = pDESC->guidClass;

            // Clone and parse the object's stream
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
                pObject->m_pStream = NULL;
            }
            if( pDESC->pStream )
            {
                hr = pDESC->pStream->Clone( &pObject->m_pStream );

                // If Clone succeeded and we don't have the object's GUID,
                // parse the object from the stream
                if( SUCCEEDED( hr )
                &&  !(pObject->m_guidObject != GUID_NULL) )
                {
                    // Make another clone of the stream
                    IStream *pStreamClone;
                    if( SUCCEEDED( pObject->m_pStream->Clone( &pStreamClone ) ) )
                    {
                        // Create the object, and ask for the IDirectMusicObject interface
                        IDirectMusicObject *pIObject;
                        hr = CoCreateInstance(pDESC->guidClass,
                            NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
                            (void **) &pIObject);
                        if (SUCCEEDED(hr))
                        {
                            // Initialize the object descriptor
                            DMUS_OBJECTDESC tmpObjDesc;
                            memset((void *)&tmpObjDesc,0,sizeof(tmpObjDesc));
                            tmpObjDesc.dwSize = sizeof (DMUS_OBJECTDESC);

                            // Fill in the descriptor
                            hr = pIObject->ParseDescriptor(pStreamClone,&tmpObjDesc);
                            if (SUCCEEDED(hr))
                            {
                                // Finally, fill in the object's GUID and filename
                                if( tmpObjDesc.dwValidData & DMUS_OBJ_OBJECT )
                                {
                                    pObject->m_guidObject = tmpObjDesc.guidObject;
                                }
                                if (tmpObjDesc.dwValidData & DMUS_OBJ_FILENAME)
                                {
                                    StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), tmpObjDesc.wszFileName);
                                }
                            }
                            pIObject->Release();
                        }

                        pStreamClone->Release();
                    }
                }
            }
        }

        // Add the object to the list, if we succeeded and found a valid GUID for the object
        if( SUCCEEDED(hr)
        &&  (pObject->m_guidObject != GUID_NULL) )
        {
            pObject->m_pNext = m_pObjectList;
            m_pObjectList = pObject;
        }
        else
        {
            // Otherwise, clean up and delete the object
            if (pObject->m_pObject)
            {
                pObject->m_pObject->Release();
            }
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
            }
            delete pObject;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CLoader::SetSearchDirectory(
    REFCLSID rguidClass,    // Class id identifies which clas of objects this pertains to.
                            // Optionally, GUID_DirectMusicAllTypes specifies all classes. 
    WCHAR *pwzPath,         // File path for directory. Must be a valid directory and
                            // must be less than MAX_PATH in length.
    BOOL fClear)            // If TRUE, clears all information about objects
                            // prior to setting directory. 
                            // This helps avoid accessing objects from the
                            // previous directory that may have the same name.
                            // However, this will not remove cached objects.
                                        
{
    // This loader doesn't use search directories.  You can only load by URL via GetSegment.
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::ScanDirectory(
    REFCLSID rguidClass,    // Class id identifies which class of objects this pertains to.
    WCHAR *pszFileExtension,// File extension for type of file to look for. 
                            // For example, L"sty" for style files. L"*" will look in all
                            // files. L"" or NULL will look for files without an
                            // extension.
    WCHAR *pszCacheFileName // Optional storage file to store and retrieve
                            // cached file information. This file is created by 
                            // the first call to <om IDirectMusicLoader::ScanDirectory>
                            // and used by subsequant calls. NULL if cache file
                            // not desired.
)

{
    return E_NOTIMPL;
}


STDMETHODIMP CLoader::CacheObject(
    IDirectMusicObject * pObject)   // Object to cache.

{
    return E_NOTIMPL;
}


STDMETHODIMP CLoader::ReleaseObject(
    IDirectMusicObject * pObject)   // Object to release.

{
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::ClearCache(
    REFCLSID rguidClass)    // Class id identifies which class of objects to clear.
                            // Optionally, GUID_DirectMusicAllTypes specifies all types. 

{
    if (rguidClass != GUID_DirectMusicAllTypes)
        return E_NOTIMPL;

    while (m_pObjectList)
    {
        CObjectRef * pObject = m_pObjectList;
        m_pObjectList = pObject->m_pNext;
        if (pObject->m_pObject)
        {
            pObject->m_pObject->Release();
        }
        if( pObject->m_pStream )
        {
            pObject->m_pStream->Release();
        }
        delete pObject;
    }
    return S_OK;
}

STDMETHODIMP CLoader::EnableCache(
    REFCLSID rguidClass,    // Class id identifies which class of objects to cache.
                            // Optionally, GUID_DirectMusicAllTypes specifies all types. 
    BOOL fEnable)           // TRUE to enable caching, FALSE to clear and disable.
{
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::EnumObject(
    REFCLSID rguidClass,    // Class ID for class of objects to view. 
    DWORD dwIndex,          // Index into list. Typically, starts with 0 and increments.
    LPDMUS_OBJECTDESC pDESC)// DMUS_OBJECTDESC structure to be filled with data about object.
                                       
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\timeparser.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timeparser.cpp
 *
 * Abstract:  Each parse function in this class assumes that the tokenizer's
 *            current token is first token that should be analyzed.
 *
 *******************************************************************************/
#include "headers.h"
#include "timeparser.h"
#include "playlist.h"

#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour
#define CLSIDLENGTH   38

static const ParentList
g_parentTable[] = 
{
    {MOREINFO_TOKEN, 4, {ASX_TOKEN, ENTRY_TOKEN, BANNER_TOKEN, INVALID_TOKEN}},
    {ENTRYREF_TOKEN, 4, {ASX_TOKEN, EVENT_TOKEN, REPEAT_TOKEN, INVALID_TOKEN}},
    {REF_TOKEN, 2, {ENTRY_TOKEN, INVALID_TOKEN}},
    {BASE_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {LOGO_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {PARAM_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {PREVIEWDURATION_TOKEN, 4, {ASX_TOKEN, ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {STARTTIME_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {ENDTIME_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {STARTMARKER_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {ENDMARKER_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {DURATION_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {BANNER_TOKEN, 3, {ENTRY_TOKEN, ASX_TOKEN, INVALID_TOKEN}},
    {NULL, 0, {0}},
};

static const TOKEN
g_AsxTags[] =
{
    TITLE_TOKEN, AUTHOR_TOKEN, REF_TOKEN, COPYRIGHT_TOKEN,
    ABSTRACT_TOKEN, ENTRYREF_TOKEN, MOREINFO_TOKEN, ENTRY_TOKEN,
    BASE_TOKEN, LOGO_TOKEN, PARAM_TOKEN, PREVIEWDURATION_TOKEN,
    STARTTIME_TOKEN, STARTMARKER_TOKEN, ENDTIME_TOKEN, ENDMARKER_TOKEN,
    DURATION_TOKEN, BANNER_TOKEN, REPEAT_TOKEN, NULL
};

DeclareTag(tagTimeParser, "API", "CTIMEPlayerNative methods");

void
CTIMEParser::CreateParser(CTIMETokenizer *tokenizer, bool bSingleChar)
{
    m_Tokenizer = tokenizer;
    m_fDeleteTokenizer = false;
    //initializes the tokenizer to point to the first token in the stream
    if (m_Tokenizer)
    {
        if (bSingleChar)
        {
            m_Tokenizer->SetSingleCharMode(bSingleChar);
        }
        m_Tokenizer->NextToken();
        m_hrLoadError = S_OK;
    }
    else
    {
        m_hrLoadError = E_POINTER;
    }
}

void
CTIMEParser::CreateParser(LPOLESTR tokenStream, bool bSingleChar)
{
    HRESULT hr = S_OK;

    m_fDeleteTokenizer = true;
    m_Tokenizer = NULL;

    if (tokenStream == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    m_Tokenizer = NEW CTIMETokenizer();//lint !e1733 !e1732
    if (m_Tokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = m_Tokenizer->Init(tokenStream, wcslen(tokenStream));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (bSingleChar)
    {
        m_Tokenizer->SetSingleCharMode(bSingleChar);
    }
    m_Tokenizer->NextToken();

  done:

    //store any errors here.
    m_hrLoadError = hr;

}//lint !e1541

void 
CTIMEParser::CreateParser(VARIANT *tokenStream, bool bSingleChar)
{
    CComVariant vTemp;
    HRESULT hr = S_OK;

    m_fDeleteTokenizer = true;
    m_Tokenizer = NULL; //lint !e672

    if (tokenStream == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit (&vTemp);
    hr = VariantChangeTypeEx(&vTemp, tokenStream, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
    if (FAILED(hr))
    {
        goto done;
    }

    m_Tokenizer = NEW CTIMETokenizer();
    if (m_Tokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = m_Tokenizer->Init(vTemp.bstrVal, SysStringLen(vTemp.bstrVal));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (bSingleChar)
    {
        m_Tokenizer->SetSingleCharMode(bSingleChar);
    }
    m_Tokenizer->NextToken();

  done:

    //store any errors here.
    m_hrLoadError = hr;

}//lint !e1541

CTIMEParser::~CTIMEParser()
{
    if (m_fDeleteTokenizer)
    {
        if (m_Tokenizer)
        {
            delete m_Tokenizer;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value of the percent found in the string.
//  Returns E_FAIL and 0 if the next token is not a percent value.
//
//  percentVal =        '+' unsignedPercent || '-' unsignedPercent
//  unsignedPercent =   number || number '%' || number ';' || number '%' ';'
//  number =            double
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePercent(double & percentVal)
{
    HRESULT hr = E_FAIL;

    TIME_TOKEN_TYPE curToken = TT_Unknown;
    bool bPositive = true;
    double curVal = 0.0;
    bool bOldSyntax = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntax = m_Tokenizer->GetTightChecking();
    curToken = m_Tokenizer->TokenType();
    m_Tokenizer->SetTightChecking(true);

    //handle +,- 
    if (curToken == TT_Plus)
    { 
        curToken = m_Tokenizer->NextToken();
    }
    else if (curToken == TT_Minus)
    {
        bPositive = false;
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_Number)
    {
        goto done;
    }
    curVal = m_Tokenizer->GetTokenNumber();
    curToken = m_Tokenizer->NextToken();
    
    //step over the percent sign.
    if (curToken == TT_Percent || curToken == TT_Semi)
    {
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_EOF)
    {
        curVal = 0;
        goto done;
    }
      
    hr = S_OK;

  done:

    percentVal = curVal * ((bPositive)? 1 : -1);

    if (m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetTightChecking(bOldSyntax);
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a bool value if the next token is a bool
//  Returns E_FAIL and false if the next token is not a bool value.
//
//  boolVal =   "true" || "false"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseBoolean(bool & boolVal)
{
    HRESULT hr = E_FAIL;
    bool bTemp = false;
    LPOLESTR pszToken = NULL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }
    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Identifier)
    {
        goto done;
    }

    pszToken = m_Tokenizer->GetTokenValue();
    if (pszToken == NULL)
    {
        goto done;
    }
    if (StrCmpIW(pszToken, WZ_TRUE) == 0) //if it is true
    {
        bTemp = true;
    }
    else if (StrCmpIW(pszToken, WZ_FALSE) != 0) //else if it is not false
    {
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    if (curToken != TT_EOF)
    {
        goto done;
    }

    hr = S_OK;

  done:
    if (pszToken)
    {
        delete [] pszToken;
    }
    boolVal = bTemp;
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value of the total number of seconds
//  Returns E_FAIL and false if the next token is not a clockvalue value.
//
//  clockVal =      '+' clock || '-' clock || "indefinite"
//  clock    =      HH ':' MM ':' SS || MM ':' SS || DD || DD 's' || DD 'm' || DD 'h'
//  HH       =      integer ( > 0 )
//  MM       =      integer (0 to 60)
//  SS       =      double (0 to 60)
//  DD       =      double
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseClockValue(double & time)
{
    HRESULT hr = E_FAIL;
    double fltTemp = 0.0;
    double fltHour = 0.0, fltMinute = 0.0, fltSecond = 0.0;
    LPOLESTR pszToken = NULL;
    long lColonCount = 0;
    bool bPositive = true, bFirstLoop = true;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    bool bOldSyntaxFlag = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntaxFlag = m_Tokenizer->GetTightChecking();

    m_Tokenizer->SetTightChecking(true);
    curToken = m_Tokenizer->TokenType();
    
    //if this is a '+' or a '-' determine which and goto next token.
    if (curToken == TT_Minus || curToken == TT_Plus)
    {
        bPositive = (curToken != TT_Minus); 
        curToken = m_Tokenizer->NextToken();
    }
    
    if (curToken == TT_Identifier)
    {
        pszToken = m_Tokenizer->GetTokenValue();
        if (NULL == pszToken)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        if (IsIndefinite(pszToken))
        {
            hr = S_OK;
            fltTemp = INDEFINITE;
        }

        if (IsWallClock(pszToken))
        {
            m_Tokenizer->NextToken();
            hr = ParseWallClock(fltTemp);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        goto done;
    }
    else if (curToken == TT_Number)
    {
        fltSecond = m_Tokenizer->GetTokenNumber();
        curToken = m_Tokenizer->NextToken();
    }
    
    while (curToken != TT_EOF && curToken != TT_Semi)
    {
        //next can be either a ":", an identifier, or eof.
        switch (curToken)
        {
            case TT_Identifier:
            {
                //this is only valid the first time through the loop
                if (bFirstLoop)
                {
                    double fltMultiplier = 0.0;
                    if (pszToken)
                    {
                        delete [] pszToken;
                        pszToken = NULL;
                    }
                    pszToken = m_Tokenizer->GetTokenValue();
                    fltMultiplier = GetModifier(pszToken);
                    if (fltMultiplier == -1)
                    {
                        goto done;
                    }
                    else
                    {
                        fltTemp = fltSecond * fltMultiplier;
                    }
                }
                else 
                {
                    goto done;
                }
                hr = S_OK;
                m_Tokenizer->NextToken();
                goto done;

            }
            case TT_Colon:
            {   
                lColonCount++;
                if (lColonCount > 2)
                {
                    goto done;
                }

                //next case must be a number
                curToken = m_Tokenizer->NextToken();
                if (curToken != TT_Number)
                {
                    goto done;
                }
                fltHour = fltMinute;
                fltMinute = fltSecond;
                fltSecond = m_Tokenizer->GetTokenNumber();
                break;
            }
            default:
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }
        curToken = m_Tokenizer->NextToken();
        bFirstLoop = false;
    } 

    if ((fltHour < 0.0) || 
        (fltMinute < 0.0 || fltMinute > 60.0) ||
        ((fltHour != 0 || fltMinute != 0) && fltSecond > 60))
    {
        goto done;
    }
    else
    {
        fltTemp = (fltHour * SECPERHOUR) + (fltMinute * SECPERMINUTE) + fltSecond; 
    }
  

    hr = S_OK;

  done:
  
    if (FAILED(hr))
    {
        time = 0.0;
    }
    else
    {
        time = fltTemp;
        if (!bPositive)
        {
            time *= -1;
        }
    }

    delete [] pszToken;

    if (m_hrLoadError == S_OK)
    {
        //restore the old syntax checking state
        m_Tokenizer->SetTightChecking(bOldSyntaxFlag);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Returns S_OK and a double value of the total number of seconds
//  Returns S_FALSE if string is empty
//  Returns E_FAIL if the string is not a clockvalue value or has more than one value.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseRepeatDur(double & time)
{
    HRESULT hr;
    double dblRet;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    // If this is an empty string, error out 
    if (IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(ParseClockValue(dblRet));
    if (FAILED(hr))
    {
        goto done;
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (!IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    time = dblRet;
    
    hr = S_OK;

  done:

    return hr;
} // ParseRepeatDur


///////////////////////////////////////////////////////////////////////////////
//
//  Returns S_OK and a double value of the total number of seconds
//  Returns S_FALSE if string is empty
//  Returns E_FAIL if the string is not a clockvalue value or has more than one value.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseDur(double & time)
{
    HRESULT hr;
    double dblRet;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    // If this is an empty string, error out 
    if (IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(ParseClockValue(dblRet));
    if (FAILED(hr))
    {
        goto done;
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (!IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    time = dblRet;
    
    hr = S_OK;

  done:

    return hr;
} // ParseDur


///////////////////////////////////////////////////////////////////////////////
//
// Check if there are only spaces including and after the current token. 
//
///////////////////////////////////////////////////////////////////////////////
bool 
CTIMEParser::IsEmpty()
{
    if (m_hrLoadError != S_OK)
    {
        return true;
    }

    TIME_TOKEN_TYPE curToken = m_Tokenizer->TokenType();

    while (TT_Space == curToken)
    {
        curToken = m_Tokenizer->NextToken();
    }

    // Check the current token for EOF or space
    if (TT_EOF == curToken)
    {
        return true;
    }
    else
    {
        return false;
    }

} // IsEmpty


long 
CTIMEParser::CountPath()
{
    HRESULT hr = E_FAIL;
    LPOLESTR tokenStream = NULL;
    CTIMETokenizer *pTokenizer = NULL;
    long lCurCount = 0;
    long lPointCount = 0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    LPOLESTR pszTemp = NULL;
    PathType lastPathType = PathNotSet;
    bool bUseParen = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    //setup a new tokenizer
    pTokenizer = NEW CTIMETokenizer();
    if (pTokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    tokenStream = m_Tokenizer->GetRawString(0, m_Tokenizer->GetStreamLength());

    if (tokenStream == NULL)
    {
        lCurCount = 0;
        goto done;
    }

    hr = pTokenizer->Init(tokenStream, wcslen(tokenStream));
    if (FAILED(hr))
    {
        goto done;
    }

    pTokenizer->SetSingleCharMode(true);
    pTokenizer->NextToken(); 

    //parse the path without saving anything.
    while (curToken != TT_EOF)
    {
        long lCurPoint = 0;
        if (pszTemp)
        {
            delete pszTemp;
            pszTemp = NULL;
        }
        if (   (lCurCount > 0)
            && (    (curToken == TT_Number)
                ||  (curToken == TT_Minus)
                ||  (curToken == TT_Plus)))
        {
            if (lastPathType == PathNotSet)
            {
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        else
        {
            pszTemp = pTokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                goto done;
            }
            if (lstrlenW(pszTemp) != 1 && lastPathType != PathNotSet)  
            {
                hr = E_INVALIDARG;
                goto done;
            }
            switch (pszTemp[0])
            {
              case 'M': case 'm': 
                lPointCount = 1;
                lastPathType = PathMoveTo;
                break;
              case 'L': case 'l': 
                lPointCount = 1;
                lastPathType = PathLineTo;
                break;
              case 'H': case 'h': 
                lPointCount = 1;
                lastPathType = PathHorizontalLineTo;
                break;
              case 'V': case 'v': 
                lastPathType = PathVerticalLineTo;
                lPointCount = 1;
                break;
              case 'Z': case 'z': 
                lPointCount = 0;
                lastPathType = PathClosePath;
                break;
              case 'C': case 'c': 
                lPointCount = 3;
                lastPathType = PathBezier;
                break;
              default:
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        
        //check the hr falling out of the switch.
        if (FAILED(hr))
        {
            goto done;
        }

        //get the number of points specified.
        if (    (curToken != TT_Number)
            &&  (curToken != TT_Minus)
            &&  (curToken != TT_Plus))
        {
            curToken = pTokenizer->NextToken();
        }
        
        bUseParen = false;
        if (curToken == TT_LParen)
        {
            bUseParen = true;
            curToken = pTokenizer->NextToken();
        }

        while (lCurPoint < lPointCount &&  curToken != TT_EOF)
        {
            if (curToken != TT_Number)
            {
                if (    (curToken == TT_Minus)
                    ||  (curToken == TT_Plus))
                {
                    curToken = pTokenizer->NextToken();
                    if (curToken != TT_Number)
                    {
                        hr = E_INVALIDARG;
                        goto done;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                    goto done;
                }
            }
            if (lastPathType != PathVerticalLineTo && 
                lastPathType != PathHorizontalLineTo)
            {
                curToken = pTokenizer->NextToken();                
                if (curToken != TT_Number)
                {
                    if (    (curToken == TT_Minus)
                        ||  (curToken == TT_Plus))
                    {
                        curToken = pTokenizer->NextToken();
                        if (curToken != TT_Number)
                        {
                            hr = E_INVALIDARG;
                            goto done;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        goto done;
                    }
                }

            }
            lCurPoint++;
            
            curToken = pTokenizer->NextToken();
        }

        if (bUseParen)
        {
            if (curToken == TT_RParen)
            {
                curToken = pTokenizer->NextToken();
            }
            else
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }

        if (lCurPoint != lPointCount)
        {
            hr = E_INVALIDARG;
            goto done;
        }
        lCurCount++;
    }

    hr = S_OK;

  done:

    if (pszTemp)
    {
        delete pszTemp;
        pszTemp = NULL;
    }

    if (pTokenizer)
    {
        delete pTokenizer;
        pTokenizer = NULL;
    }

    if (tokenStream)
    {
        delete [] tokenStream;
        tokenStream = NULL;
    }

    if (FAILED(hr))
    {
        lCurCount = 0;
    }
    return lCurCount;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns an array of path constructs
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePath(long & count, long & moveCount, CTIMEPath ***pppPath)
{
    HRESULT hr = E_FAIL;
    long lPathCount = 0;
    long lCurCount = 0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    long lPointCount = 0;
    LPOLESTR pszTemp = NULL;
    PathType lastPathType = PathNotSet;
    CTIMEPath **pTempPathArray = NULL;
    bool bUseParen = false;
    POINTF ptPrev = {0.0, 0.0};
    bool fLastAbsolute = true;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    moveCount= 0;

    if (pppPath == NULL)
    {
        goto done;
    }

    lPathCount = CountPath();

    if (lPathCount == 0)
    {
        goto done;
    }

    //should be initialized to true now
    //m_Tokenizer->SetSingleCharMode(true);
    
    pTempPathArray = NEW CTIMEPath* [lPathCount];
    if (pTempPathArray == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    //loop through each and parse the current pathitem.
    while (curToken != TT_EOF && lCurCount < lPathCount)
    {
        long lCurPoint = 0;

        pTempPathArray[lCurCount] = NEW CTIMEPath;

        if (pszTemp)
        {
            delete pszTemp;
            pszTemp = NULL;
        }

        if (   (lCurCount > 0)
            && (    (curToken == TT_Number)
                ||  (curToken == TT_Minus)
                ||  (curToken == TT_Plus)))
        {
            if (lastPathType != PathNotSet)
            {
                if (lastPathType == PathMoveTo)
                {
                    // "If a moveto is followed by multiple pairs of coordinates, the subsequent 
                    // pairs are treated as implicit lineto commands."
                    hr = THR(pTempPathArray[lCurCount]->SetType(PathLineTo));
                }
                else
                {
                    hr = THR(pTempPathArray[lCurCount]->SetType(lastPathType));
                }
                //set the mode to the same as the last mode
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(fLastAbsolute));
                //lPointCount should be preserved from the last time around.
            }
            else
            {
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        else
        {
            pszTemp = m_Tokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                goto done;
            }

            if (lstrlenW(pszTemp) != 1 && lastPathType != PathNotSet)  //Can only take one character here.
            {
                hr = E_INVALIDARG;
                goto done;
            }

            switch (pszTemp[0])
            {
              case 'M': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true)); 
              case 'm':  //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathMoveTo));
                lastPathType = PathMoveTo;
                lPointCount = 1;
                moveCount++;
                break;
          
              case 'L': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'l': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathLineTo));
                lastPathType = PathLineTo;
                lPointCount = 1;
                break;
          
              case 'H': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'h': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathHorizontalLineTo));
                lastPathType = PathHorizontalLineTo;
                lPointCount = 1;
                break;
          
              case 'V': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'v': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathVerticalLineTo));
                lastPathType = PathVerticalLineTo;
                lPointCount = 1;
                break;
          
              case 'Z': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'z': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathClosePath));
                lastPathType = PathClosePath;
                lPointCount = 0;
                break;
          
              case 'C': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'c': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathBezier));
                lastPathType = PathBezier;
                lPointCount = 3;
                break;

              default:
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        
        //check the hr falling out of the switch.
        if (FAILED(hr))
        {
            goto done;
        }

        //get the number of points specified.
        if (    (curToken != TT_Number)
            &&  (curToken != TT_Minus)
            &&  (curToken != TT_Plus))
        {
            curToken = m_Tokenizer->NextToken();
        }

        bUseParen = false;
        if (curToken == TT_LParen)
        {
            bUseParen = true;
            curToken = m_Tokenizer->NextToken();
        }

        {
            //
            // in this scope we parse the points and convert them to absolute values
            //

            POINTF tempPoint = {0.0, 0.0};

            while (lCurPoint < lPointCount &&  curToken != TT_EOF)
            {
                double fCurNum1 = 0.0, fCurNum2 = 0.0;
                bool fAbsolute;
                
                tempPoint.x = tempPoint.y = 0.0;
                fAbsolute = pTempPathArray[lCurCount]->GetAbsolute();

                hr = ParseNumber(fCurNum1, false);
                if (FAILED(hr))
                {
                    goto done;
                }

                if (lastPathType == PathVerticalLineTo)
                {
                    if (fAbsolute)
                    {
                        tempPoint.y = (float)fCurNum1;
                    }
                    else
                    {
                        tempPoint.y = (float)(fCurNum1 + ptPrev.y);
                    }
                    tempPoint.x = ptPrev.x;
                }
                else if (lastPathType == PathHorizontalLineTo)
                {
                    if (fAbsolute)
                    {
                        tempPoint.x = (float)fCurNum1;
                    }
                    else
                    {
                        tempPoint.x = (float)(fCurNum1 + ptPrev.x);
                    }
                    tempPoint.y = ptPrev.y;
                }
                else
                {  
                    hr = ParseNumber(fCurNum2, false);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
               
                    if (fAbsolute)
                    {
                        tempPoint.x = (float)fCurNum1;
                        tempPoint.y = (float)fCurNum2;
                    }
                    else
                    {
                        tempPoint.x = (float)(fCurNum1 + ptPrev.x);
                        tempPoint.y = (float)(fCurNum2 + ptPrev.y);
                    }
                }

                hr = THR(pTempPathArray[lCurCount]->SetPoints(lCurPoint, tempPoint));
                if (FAILED(hr))
                {
                    goto done;
                }

                lCurPoint++;

                curToken = m_Tokenizer->TokenType();
            }

            // after conversion, mark point as absolute
            fLastAbsolute = pTempPathArray[lCurCount]->GetAbsolute();
            pTempPathArray[lCurCount]->SetAbsolute(true);

            // cache the last absolute point
            ptPrev = tempPoint;     
        }

        if (bUseParen)
        {
            if (curToken == TT_RParen)
            {
                curToken = m_Tokenizer->NextToken();
            }
            else
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }

        if (lCurPoint != lPointCount)
        {
            goto done;
        }
        
        lCurCount++;
    }

    count = lCurCount ;

    hr = S_OK;

  done:

    if (m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetSingleCharMode(false);
    }

    delete pszTemp;
    pszTemp = NULL;

    if (SUCCEEDED(hr) && pppPath)
    {
        // Bail if move-to is not the first command
        bool fInvalidPath = ((lCurCount > 0) && (PathMoveTo != pTempPathArray[0]->GetType()));

        if (fInvalidPath)
        {
            hr = E_FAIL;
        }
        else
        {
            // copy the path into the out param
            *pppPath = NEW CTIMEPath* [lCurCount];
            if (*pppPath == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                // copy the points
                memcpy(*pppPath, pTempPathArray, sizeof(CTIMEPath *) * lCurCount);  //lint !e668
            }
        }
    }

    if (FAILED(hr))
    {
        count = 0;
        moveCount = 0;
        if (pTempPathArray != NULL)
        {
            for (int i = 0; i < lPathCount; i++)
            {
                delete pTempPathArray[i];
            }
        } 
        if (pppPath)
        {
            *pppPath = NULL;
        }
    }
    delete [] pTempPathArray;
  
    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value if the next token is a valid number
//  Returns E_FAIL and false if the next token is not a number.
//
//  Number      = '+' doubleVal || '-' doubleVal || "indefinite"
//  doubleVal    =  double || '.' integer
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseNumber(double & doubleVal, bool bValidate /* = true */)
{
    HRESULT hr = E_FAIL;
    bool bPositive = true;
    double fltTemp = 0.0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    LPOLESTR pszTemp = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    //if this is a '+' or a '-' determine which and goto next token.
    if (curToken == TT_Minus || curToken == TT_Plus)
    {
        bPositive = (curToken != TT_Minus); 
        curToken = m_Tokenizer->NextToken();
    }
    
    switch (curToken)
    {
      case TT_Number:
        {
            fltTemp = m_Tokenizer->GetTokenNumber();
            break;
        }
      case TT_Identifier:
        {
            pszTemp = m_Tokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            if (!IsIndefinite(pszTemp))
            {
                hr = E_INVALIDARG;
                goto done;
            }

            fltTemp = INDEFINITE;

            break;
        }
      default:
        {   //failure case
            hr = E_INVALIDARG;
            goto done;
        }
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (bValidate)
    {
        // only spaces allowed after this
        if (!IsEmpty())
        {
            fltTemp = 0.0;
            hr = E_INVALIDARG;
            goto done;
        }
    }
    hr = S_OK;

  done:

    doubleVal = fltTemp * ((bPositive)? 1 : -1);

    delete [] pszTemp;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  syncbase =  (id)("." "begin" || "." "end")("+" clockvalue)?
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseSyncBase(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    LPOLESTR pszElement = NULL, pszEvent = NULL;
    double clockTime = 0.0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }
    //get the element id
    pszElement = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Dot)
    {
        goto done;
    }

    //get the event name
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Identifier)
    {
        goto done;
    }
    
    pszEvent = m_Tokenizer->GetTokenValue();
    curToken = m_Tokenizer->NextToken();

    if (curToken == TT_Plus || curToken == TT_Minus) //get the clock value for this
    {
        hr = ParseClockValue(clockTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (curToken == TT_Semi)
    {
        curToken = m_Tokenizer->NextToken();
        goto done;
    }

    if (curToken != TT_EOF)
    {
        goto done;
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        if (pszElement)
        {
            delete [] pszElement;
            pszElement = NULL;
        }
        if (pszEvent)
        {
            delete [] pszEvent;
            pszEvent = NULL;
        }
        clockTime = 0.0;
    }

    ElementID = pszElement;
    syncEvent = pszEvent;
    time = clockTime;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  
//  Begin       =   clockvalue || syncBase || eventvalue || "indefinite"
//  clockValue  =   clockValue //call parseClockValue
//  EventValue  =   EventList  //call parseEvent  //NOT CURRENTLY HANDLED
//  syncBase    =   SyncBase   //call parseSyncBase
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeValueList(TimeValueList & tvList, bool * bWallClock, SYSTEMTIME * sysTime)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    double curOffsetTime = 0.0;
    LPOLESTR pszElement = NULL;
    LPOLESTR pszEvent = NULL;
    bool bOldSyntaxFlag = false;
    bool bNeg = false;

    if (bWallClock)
    {
        *bWallClock = false;
    }

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntaxFlag = m_Tokenizer->GetTightChecking();
    tvList.Clear();
    
    curToken = m_Tokenizer->TokenType();

    m_Tokenizer->SetTightChecking(true);
        
    while (curToken != TT_EOF)  //loop until eof
    {
        Assert(curOffsetTime == 0.0);
        Assert(pszElement == NULL);
        Assert(pszEvent == NULL);

        switch (curToken)
        {
            case (TT_Plus):
            case (TT_Minus):
            case (TT_Number): //handle the case of a clock value
            {
                hr = THR(ParseClockValue(curOffsetTime));
                if (FAILED(hr))
                {
                    goto done;
                }
                curToken = m_Tokenizer->TokenType();
                break;
            }
            case (TT_Identifier): //handle the case of an event value
            {  // (element .)? event (+ offset)?
                pszEvent = m_Tokenizer->GetTokenValue();
                if (pszEvent == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                if (IsIndefinite(pszEvent))
                {
                    delete [] pszEvent;
                    pszEvent = NULL;
                    curOffsetTime = (double)TIME_INFINITE;
                    curToken = m_Tokenizer->NextToken();
                    break;
                }

                if (IsWallClock(pszEvent))
                {
                    m_Tokenizer->NextToken();
                    if (bWallClock)
                    {
                        *bWallClock = true;
                    }
                    hr = ParseWallClock(curOffsetTime, sysTime);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    delete [] pszEvent;
                    pszEvent = NULL;
                    break;
                }

                curToken = m_Tokenizer->NextToken();
                switch (curToken)
                {
                    case TT_Dot:
                    {
                        pszElement = pszEvent; //move the event in the element holder
                        pszEvent = NULL;
                        curToken = m_Tokenizer->NextToken();
                        if (curToken == TT_Identifier)
                        {
                            pszEvent = m_Tokenizer->GetTokenValue();
                            if (pszEvent == NULL)
                            {
                                hr = E_INVALIDARG;
                                goto done;
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                            goto done;
                        }
                        
                        do  //white space is valid here.
                        {
                            curToken = m_Tokenizer->NextToken();
                        } while (curToken == TT_Space);
                        
                        if (curToken == TT_Minus)
                        {
                            bNeg = true;
                        }

                        if (curToken == TT_Plus || curToken == TT_Minus)
                        {
                            do  //white space is valid here.
                            {
                                curToken = m_Tokenizer->NextToken();
                            } while (curToken == TT_Space);
                            if (curToken == TT_EOF || curToken == TT_Semi)
                            {
                                hr = E_FAIL;
                                goto done;
                            }
                            hr = THR(ParseClockValue(curOffsetTime));
                            if (FAILED(hr))
                            {
                                goto done;
                            }
                            if (bNeg == true)
                            {
                                bNeg = false;
                                curOffsetTime *= -1;
                            }
                            curToken = m_Tokenizer->TokenType();
                        }
                        else if (curToken == TT_Semi)
                        {
                            curToken = m_Tokenizer->NextToken();
                        }
                        else if (curToken != TT_EOF)
                        { //handle all cases other than EOF
                            hr = E_INVALIDARG;
                            goto done;
                        }
                        break;
                    }
                    case TT_Plus:
                    case TT_Minus:
                    {
                        hr = THR(ParseClockValue(curOffsetTime));
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                        curToken = m_Tokenizer->NextToken();
                        break;
                    }
                    case TT_Semi:
                    case TT_EOF:
                    {
                        curOffsetTime = 0.0;
                        break;
                    }
                    default:
                    {   
                        hr = E_INVALIDARG;
                        goto done;
                    }

                }
                break; 
            }
            default:
            {
                //this is an error case
                hr = E_INVALIDARG;
                goto done;
            }
        }

        while (curToken == TT_Semi || curToken == TT_Space) //skip past all ';'s
        {
            curToken = m_Tokenizer->NextToken();
        }
        
        TimeValue *tv;

        tv = new TimeValue(pszElement,
                           pszEvent,
                           curOffsetTime);

        if (tv == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        // @@ ISSUE : Need to detect memory failure
        tvList.GetList().push_back(tv);

        curOffsetTime = 0.0;
        pszElement = NULL;
        pszEvent = NULL;
    }  //lint !e429

    Assert(curToken == TT_EOF);

    hr = S_OK;
  done:

    delete [] pszElement;
    delete [] pszEvent;
    
    if (FAILED(hr))
    {
        tvList.Clear();
    }

    if (m_hrLoadError == S_OK)
    {
        //restore the old syntax checking state
        m_Tokenizer->SetTightChecking(bOldSyntaxFlag);
    }

    return hr;
}

bool
CTIMEParser::IsWallClock(OLECHAR *szWallclock)
{
    bool bResult = FALSE;
    
    if (StrCmpIW(szWallclock, L"wallclock") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

HRESULT 
CTIMEParser::ParseWallClock(double & curOffsetTime, SYSTEMTIME * sysTime)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    bool bOldSyntax = false;
    int nDay = 0, nMonth = 0, nYear = 0;
    double fHours = 0.0, fMinutes = 0.0, fSec = 0.0;
    SYSTEMTIME curTime, wallTime;
    LPOLESTR pszTemp = NULL;
    bool bUseDate = false;
    bool bUseLocalTime = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    //initialize the time variables.
    ZeroMemory(&wallTime, sizeof(wallTime));
    ZeroMemory(&curTime, sizeof(curTime));

    m_Tokenizer->SetSingleCharMode(true);

    curToken = m_Tokenizer->TokenType();
    bOldSyntax = m_Tokenizer->GetTightChecking();
    m_Tokenizer->SetTightChecking(true);

    if (curToken != TT_LParen)
    {
        goto done;
    }
    curToken = m_Tokenizer->NextToken();

    //white space is valid here.
    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    }
    
    if (curToken != TT_Number)
    {
        goto done;
    }

    if (m_Tokenizer->PeekNextNonSpaceChar() == '-')
    {
        bool bNeedEnd = false;
        bUseDate = true;
        hr = ParseDate(nYear, nMonth, nDay);
        if (FAILED(hr))
        {
            goto done;
        }
        wallTime.wYear = (WORD)nYear;
        wallTime.wMonth = (WORD)nMonth;
        wallTime.wDay = (WORD)nDay;
        curToken = m_Tokenizer->TokenType();
        if (curToken == TT_Space)
        {
            bNeedEnd = true;
            while (curToken == TT_Space)
            {
                curToken = m_Tokenizer->NextToken();
            }
        }
        if (curToken == TT_RParen)
        {
            bUseLocalTime = true;
        }
        else if (bNeedEnd == true)
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else if (m_Tokenizer->PeekNextNonSpaceChar() == ':')
    {
        //init the walltime structure to be today.
        wallTime.wYear = 0;
        wallTime.wMonth = 0;
        wallTime.wDay = 0;

        hr = ParseOffset(fHours, fMinutes, fSec, bUseLocalTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    curToken = m_Tokenizer->TokenType();
    if (curToken == TT_Identifier)
    {
        pszTemp = m_Tokenizer->GetTokenValue();
        if (StrCmpW(pszTemp, L"Z") == 0)
        {
            m_Tokenizer->NextToken();
        }
        else if (StrCmpW(pszTemp, L"T") == 0)
        {
            curToken = m_Tokenizer->NextToken();        
    
            hr = ParseOffset(fHours, fMinutes, fSec, bUseLocalTime);
            if (FAILED(hr))
            {
                goto done;
            }   
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    curToken = m_Tokenizer->TokenType();
    //white space is valid here.
    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    } 
    
    if (curToken != TT_RParen)
    {
        hr = E_FAIL;
        goto done;
    }

    if (bUseLocalTime == true)
    {
        if (sysTime == NULL)
        {
            GetLocalTime(&curTime);
        }
        else
        {
            curTime = *sysTime;
        }
    }
    else
    {
        TIME_ZONE_INFORMATION tzInfo;
        DWORD dwRet = GetTimeZoneInformation(&tzInfo);
        GetSystemTime(&curTime);
        if (dwRet & TIME_ZONE_ID_DAYLIGHT && tzInfo.DaylightBias == -60)
        {
            curTime.wHour += 1;
        }
    }

    if (wallTime.wYear == 0 && wallTime.wDay == 0 && wallTime.wMonth == 0)
    {
        wallTime.wYear = curTime.wYear;
        wallTime.wMonth = curTime.wMonth;
        wallTime.wDay = curTime.wDay;
    }
    wallTime.wHour = (WORD)fHours;
    wallTime.wMinute = (WORD)fMinutes;
    wallTime.wSecond = (WORD)fSec;

    
    //need to figure out the time difference here.
    hr = ComputeTime(&curTime, &wallTime, curOffsetTime, bUseDate);
    if (FAILED(hr))
    {   
        goto done;
    }
    hr = S_OK;

  done:

    if(m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetSingleCharMode(false);
        m_Tokenizer->SetTightChecking(bOldSyntax);
    }

    if (FAILED(hr))
    {
        curOffsetTime = 0.0;
    }

    if (pszTemp)
    {
        delete pszTemp;
        pszTemp = NULL;
    }

    return hr;
}

void 
CTIMEParser::CheckTime(SYSTEMTIME *wallTime, bool bUseDate)
{
    int DayPerMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31 };    

    while (wallTime->wSecond >= 60)
    {
        wallTime->wMinute++;
        wallTime->wSecond -= 60;
    }
    while (wallTime->wMinute >= 60)
    {
        wallTime->wHour++;
        wallTime->wMinute -= 60;
    }
    while (wallTime->wHour >= 24)
    {
        if (bUseDate == true)
        {
            wallTime->wDay++;
        }
        wallTime->wHour -= 24;
    }
    while (wallTime->wDay > DayPerMonth[wallTime->wMonth - 1])
    {
        wallTime->wDay = (WORD)(wallTime->wDay - DayPerMonth[wallTime->wMonth - 1]);
        wallTime->wMonth++;
        if (wallTime->wMonth > 12)
        {
            wallTime->wMonth = 1;
            wallTime->wYear++;
        }
    }

    return;
}

HRESULT 
CTIMEParser::ComputeTime(SYSTEMTIME *curTime, SYSTEMTIME *wallTime, double & curOffsetTime, bool bUseDate)
{
    HRESULT hr = E_FAIL;
    FILETIME fileCurTime, fileWallTime;
    LARGE_INTEGER lnCurTime, lnWallTime;
    BOOL bError = FALSE;
    hr = S_OK;

    CheckTime(curTime, bUseDate);
    bError = SystemTimeToFileTime(curTime, &fileCurTime);
    if (!bError)
    {
        goto done;
    }   

    CheckTime(wallTime, bUseDate);
    bError = SystemTimeToFileTime(wallTime, &fileWallTime);
    if (!bError)
    {
        goto done;
    }   

    memcpy (&lnCurTime, &fileCurTime, sizeof(lnCurTime));
    memcpy (&lnWallTime, &fileWallTime, sizeof(lnWallTime));

    lnWallTime.QuadPart -= lnCurTime.QuadPart;
    //number is to convert from 100 nanosecond intervals to seconds 
    curOffsetTime = lnWallTime.QuadPart / 10000000;  //lint !e653

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        curOffsetTime = 0.0;
    }

    return hr;
}


HRESULT 
CTIMEParser::ParseSystemLanguages(long & lLangCount, LPWSTR **ppszLang)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    long lCount = 0;
    LPWSTR *pszLangArray = NULL;
    LPWSTR pszLang = NULL;
    bool bDone = false;
    
    lLangCount = 0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    lCount = m_Tokenizer->GetAlphaCount(',');
    lCount += 1; 
    pszLangArray = NEW LPWSTR [lCount];
    if (pszLangArray == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    while (!bDone && lLangCount <= lCount)
    {
        CComBSTR bstrLang;
        switch (curToken)
        {
        case TT_Identifier:
            pszLang = m_Tokenizer->GetTokenValue();
            bstrLang.Append(pszLang);
            delete [] pszLang;
            pszLang = NULL;
            curToken = m_Tokenizer->NextToken();
            if (curToken == TT_Minus)
            {
                bstrLang.Append(L"-");
            
                curToken = m_Tokenizer->NextToken();
                if (curToken == TT_Identifier)
                {
                    pszLang = m_Tokenizer->GetTokenValue();
                    bstrLang.Append(pszLang);
                    delete [] pszLang;
                    pszLang = NULL;
                }
                else
                {
                    hr = E_INVALIDARG; 
                    goto done;
                }
                curToken = m_Tokenizer->NextToken();
            }

            if (curToken == TT_Comma)
            {
                curToken = m_Tokenizer->NextToken();
            }

            pszLang = CopyString(bstrLang);
            pszLangArray[lLangCount] = pszLang;
            pszLang = NULL;
            lLangCount++;
            break;
        case TT_EOF:
            bDone = true;
            break;
        default:
            hr = E_INVALIDARG;
            goto done;
        }
    }

    hr = S_OK;

  done:
    if (SUCCEEDED(hr))
    {
        *ppszLang = NEW LPWSTR[lLangCount];
        if ((*ppszLang) == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if (pszLangArray != NULL)
            {
                memcpy(*ppszLang, pszLangArray, sizeof(LPWSTR*) * lLangCount);
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszLangArray)
        {
            for (int i = 0; i < lLangCount; i++)
            {
                delete [] pszLangArray[i];
            }
        }
        lLangCount = 0;
        ppszLang = NULL;
    }

    if (pszLangArray != NULL)
    {
        delete [] pszLangArray;
    }  
    
    return hr;
}

HRESULT 
CTIMEParser::ParseDate(int & nYear, int & nMonth, int & nDay)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    double fTemp = 0.0;
    int DayPerMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31 };    

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    // get the year value
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp < 0.0 || fTemp != floor(fTemp))
    {
        goto done;
    }
    nYear = (int)fTemp;

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Minus)
    {
        goto done;
    }

    //get the month value
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp < 0.0 || fTemp > 12.0 || fTemp != floor(fTemp))
    {
        goto done;
    }
    nMonth = (int)fTemp;

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Minus)
    {
        goto done;
    }


    //get the day value
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp != floor(fTemp))
    {
        goto done;
    }
    nDay = (int)fTemp;

    
    if (nDay < 0 || nDay > DayPerMonth[nMonth - 1])
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if ((nMonth == 2) && (nDay == 29) &&
        !((nYear%4 == 0 ) && ((nYear%100 != 0) || (nYear%400 == 0))))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        nYear = 0;
        nMonth = 0;
        nDay = 0;
    }

    return hr;
}

HRESULT 
CTIMEParser::ParseOffset(double & fHours, double & fMinutes, double & fSec, bool &bUseLocalTime)
{
    HRESULT hr = E_FAIL;

    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    double fltSecond = 0.0, fltMinute = 0.0, fltHour = 0.0, fltTotalTime = 0.0;
    long lColonCount = 0;
    bool bNeg = false;
    hr = S_OK;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bUseLocalTime = false;
    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Number)
    {
        goto done;
    }

    fltHour = m_Tokenizer->GetTokenNumber();
    curToken = m_Tokenizer->NextToken();
    
    while (curToken != TT_EOF && 
           curToken != TT_Identifier && 
           curToken != TT_RParen &&
           curToken != TT_Plus &&
           curToken != TT_Minus)
    {
        switch (curToken)
        {
          case TT_Colon:
            {   
                lColonCount++;
                if (lColonCount > 2)
                {
                    goto done;
                }

                //next case must be a number
                curToken = m_Tokenizer->NextToken();
                if (curToken != TT_Number)
                {
                    goto done;
                }
                if (lColonCount == 1)
                {
                    fltMinute = m_Tokenizer->GetTokenNumber();
                }
                else
                {
                    fltSecond = m_Tokenizer->GetTokenNumber();
                }
                break;
            }
          default:
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }
        curToken = m_Tokenizer->NextToken();
    } 

    if (lColonCount == 0)
    {
        goto done;
    }

    if ((fltHour < 0.0) ||  fltHour > 24.0 ||
        (fltMinute < 0.0 || fltMinute > 60.0) ||
        ((fltHour != 0 || fltMinute != 0) && fltSecond > 60) ||
        ((floor(fltHour) != fltHour) ||
         (floor(fltMinute) != fltMinute)))
    {
        hr = E_FAIL;
        goto done;
    }

    if (curToken == TT_Plus)
    {
        bNeg = true;
    }

    fHours = fltHour;
    fMinutes = fltMinute;
    fSec = fltSecond;
    
    if (curToken == TT_Plus || curToken == TT_Minus)
    {
        bool bIgnoreThis;
        m_Tokenizer->NextToken();
        hr = ParseOffset(fltHour, fltMinute, fltSecond, bIgnoreThis);
        if (FAILED(hr))
        {
            goto done;
        }

        fltTotalTime = ((((fltHour * 60) + fltMinute) * 60) + fltSecond);
        if (bNeg)
        {
            fltTotalTime *= -1;
        }

        fltTotalTime = ((((fHours * 60) + fMinutes) * 60) + fSec) + fltTotalTime;
        fHours = floor(fltTotalTime / 3600);
        fltTotalTime -= fHours * 3600;
        fMinutes = floor(fltTotalTime / 60);
        fltTotalTime -= fMinutes * 60;
        fSec = fltTotalTime;

        curToken = m_Tokenizer->TokenType();
    }
    else if (curToken == TT_Identifier)
    {
        LPOLESTR pszTemp = NULL;
        pszTemp = m_Tokenizer->GetTokenValue();
        if (StrCmpW(pszTemp, L"Z") == 0)
        {
            delete pszTemp;
            pszTemp = NULL;
        }
        else
        {
            hr = E_FAIL;            
            delete pszTemp;
            pszTemp = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
    }
    else
    {
        bUseLocalTime = true;
    }

    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_RParen)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;

  done:


    if (FAILED(hr))
    {
        fHours = 0;
        fMinutes = 0;
        fSec = 0;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a token value if the next token is a valid fill value
//  Returns E_FAIL and false if the next token is not a valid fill value.
//
//  fill    =   'remove' || 'freeze' || 'hold' || 'transition'
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseFill(TOKEN &FillTok)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != REMOVE_TOKEN && 
        tempToken != FREEZE_TOKEN && 
        tempToken != HOLD_TOKEN &&
        tempToken != TRANSITION_TOKEN
       ) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
  
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    FillTok = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid RestartParam
//  Returns E_FAIL and NULL if the next token is not a valid Restart Val.
//
//  Restart     =   "always" || "never" || "whenNotActive"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseRestart(TOKEN & TokRestart)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != ALWAYS_TOKEN && 
        tempToken != NEVER_TOKEN && 
        tempToken != WHENNOTACTIVE_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }


    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    TokRestart = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid Sync paramenter
//  Returns E_FAIL and NULL if the next token is not a valid Sync value.
//
//  SyncVal     =   "canSlip" || "locked"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseSyncBehavior(TOKEN & SyncVal)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != CANSLIP_TOKEN && 
        tempToken != LOCKED_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    SyncVal = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid TimeAction
//  Returns E_FAIL and NULL if the next token is not a valid TimeAction
//
//  TimeAction     =    "class"     ||
//                      "display"   ||
//                      "none"      ||
//                      "onOff"     ||
//                      "style"     ||
//                      "visibility" 
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeAction(TOKEN & timeAction)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != CLASS_TOKEN && 
        tempToken != DISPLAY_TOKEN &&
        tempToken != NONE_TOKEN &&
        tempToken != ONOFF_PROPERTY_TOKEN &&
        tempToken != STYLE_TOKEN &&
        tempToken != VISIBILITY_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    timeAction = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid timeline
//  Returns E_FAIL and NULL if the next token is not a valid timeline
//
//  TimeLine    =   "par"   ||
//                  "seq"   ||
//                  "excl"  ||
//                  "none" 
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeLine(TimelineType & timeline)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != SEQ_TOKEN && 
        tempToken != PAR_TOKEN &&
        tempToken != NONE_TOKEN &&
        tempToken != EXCL_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    if (tempToken == SEQ_TOKEN)
    {
        timeline = ttSeq;
    }
    else if (tempToken == EXCL_TOKEN)
    {
        timeline = ttExcl;
    }
    else if (tempToken == PAR_TOKEN)
    {
        timeline = ttPar;
    }
    else
    {
        timeline = ttNone;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        timeline = ttNone;
        goto done;
    }

    hr = S_OK;

  done:

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid update value
//  Returns E_FAIL and NULL if the next token is not a valid update value
//
//  Update    =   "auto"     ||
//                "manual"   ||
//                "reset"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseUpdateMode(TOKEN & update)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();


    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != AUTO_TOKEN && 
        tempToken != MANUAL_TOKEN &&
        tempToken != RESET_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    update = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and either a token representing the player device or a clsid.
//      In the case of a valid classid, the token returned will be NULL.
//  Returns E_FAIL and if the next token is not a valid Player.
//
//  Player =    "dshow"         ||
//              "dvd"           ||
//              CLSID
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePlayer(TOKEN & player, CLSID & clsid)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken == TT_Identifier)
    {
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            goto done;
        }
        if (tempToken != DVD_TOKEN &&
#if DBG // 94850
            tempToken != DSHOW_TOKEN &&
#endif
            tempToken != DMUSIC_TOKEN &&
            tempToken != CD_TOKEN) //validates that this is the correct token.
        {
            tempToken = NULL;
            hr = E_FAIL;
            goto done;
        }
    }
    else if (curToken == TT_LCurly)
    {
        hr = ParseCLSID(clsid);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (curToken == TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    player = tempToken;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a CLSID value if the next token is a valid CLSID
//  Returns E_FAIL and if the next token is not a valid CLSID.
//
//  CLSID = '{' GUID '}' 
//  GUID = id '-' id '-' id '-' id
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseCLSID(CLSID & clsid)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    CComBSTR bstrCLSID;
    LPOLESTR pszTemp = NULL;
    long curLoc = 0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_LCurly)
    {
        goto done;
    }
    
    curLoc = m_Tokenizer->CurrTokenOffset();
    pszTemp = m_Tokenizer->GetRawString(curLoc, curLoc + CLSIDLENGTH);
    if (NULL == pszTemp)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    bstrCLSID.Append (L"{");   
    bstrCLSID.Append (pszTemp);   

    //advance to the end of the clsid
    while (curToken != TT_RCurly && curToken != TT_EOF)
    {
        curToken = m_Tokenizer->NextToken();
    }
    //move to the next token
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:

    if (pszTemp)
    {
        delete [] pszTemp;
        pszTemp = NULL;
    }

    //if this is successful then create a clsid from the bstr.
    if (SUCCEEDED(hr))
    {
        hr = THR(CLSIDFromString(bstrCLSID, &clsid));
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid calcMode
//  Returns E_FAIL and NULL if the next token is not a valid calcMode
//
//  CalcMode    =   "discrete"  ||
//                  "linear"    ||
//                  "paced"     
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseCalcMode(TOKEN & calcMode)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != DISCRETE_TOKEN && 
        tempToken != LINEAR_TOKEN &&
        tempToken != PACED_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    calcMode = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a string identifier from the next token
//  Returns E_FAIL and false if the next token is not a string.
//
//  ID = string
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseIdentifier(LPOLESTR & id)
{   
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    LPOLESTR pszTemp = NULL;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }
    
    pszTemp = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        delete pszTemp;
        pszTemp = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    id = pszTemp;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid priorityClass attribute
//  Returns E_FAIL and NULL if the next token is not a valid priorityClass
//
//  priorityClass    =   "stop" || "pause" || "defer" || "never"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePriorityClass(TOKEN & priorityClass)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    if (IsEmpty())
    {
        hr = E_FAIL;
        goto done;
    }
    
    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != STOP_TOKEN &&
        tempToken != PAUSE_TOKEN &&
        tempToken != DEFER_TOKEN &&
        tempToken != NEVER_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (!IsEmpty())    
    {
        tempToken = NULL;
        goto done;
    }
    hr = S_OK;

  done:
    priorityClass = tempToken;
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and either a TOKEN value or and identifier if the next token is a valid EndSync
//      In the case of a valid token, the ID param will be NULL, in the case of a valid ID, then
//      token will be NULL;
//  Returns E_FAIL and NULL in both params if the next token is invalid.
//
//  EndSync    =   "first"  ||
//                 "last"   ||
//                 "none"   ||
//                 Identifier
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseEndSync(TOKEN & endSync, LPOLESTR & ID)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();


    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (SUCCEEDED(hr))
    {
        if (tempToken == FIRST_TOKEN ||
            tempToken == LAST_TOKEN ||
            tempToken == NONE_TOKEN) //validates that this is the correct token.
        {
            endSync = tempToken;
            hr = S_OK;
            goto done;
        }
        else
        {
            tempToken = NULL;
        }
    }
    pszTemp = m_Tokenizer->GetTokenValue();
    if (pszTemp == NULL)
    {
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        delete pszTemp;
        pszTemp = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    ID = pszTemp;
    endSync = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK if the current token is EOF, returns E_FAIL otherwise.
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseEOF()
{
    HRESULT hr = S_OK;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    if (m_Tokenizer->TokenType() != TT_EOF)
    {
        hr = E_FAIL;   
    }

  done:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Converts a number to a decimal value i.e. 5.24 to 0.524.
//  This is used to convert '.' number values from the tokenizer
//  because the it does not recognize 'dot' 5 as .5, but 
//  as two separate tokens, a dot token and a number token.
///////////////////////////////////////////////////////////////////////////////
double 
CTIMEParser::DoubleToDecimal(double val, long lCount)
{
    for (int i = 0; i < lCount; i++)
    {
        val /= 10.0;
    }

    return val;
}

/////////////////////////////////////////////////////////////////////////////////
// Creates a TOKEN out of the current TIME_TOKEN value.  There is no type checking
// done here.  The type coming in must bu TT_Identifier and that must be validated
// by the caller.
/////////////////////////////////////////////////////////////////////////////////
HRESULT
CTIMEParser::ParseToken(TOKEN *pToken)
{
    HRESULT hr = E_FAIL;
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    
    *pToken = NULL;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();
    if (NULL == pszTemp)
    {
        goto done;
    }

    tempToken = StringToToken(pszTemp);  

    *pToken = tempToken;
    hr = S_OK;

done:
    
    if (pszTemp)
    {
        delete [] pszTemp;
    }
    return hr;

}

//determines the time multiple to apply based on the string type passed in.
// returns:     -1 if invalid
//              
double 
CTIMEParser::GetModifier(OLECHAR *szToken)
{

    if (StrCmpIW(szToken, L"s") == 0)
    {
        return 1;
    }
    else if (StrCmpIW(szToken, L"m") == 0)
    {
        return SECPERMINUTE;
    }
    else if (StrCmpIW(szToken, L"h") == 0)
    {
        return SECPERHOUR;
    }
    else if (StrCmpIW(szToken, L"ms") == 0)
    {
        return (double)0.001; // seconds/millisecond
    }
    
    return -1; //invalid value
}


////////////////////////////////////////////////////////////////////////
//  Path Struct
////////////////////////////////////////////////////////////////////////
CTIMEPath::CTIMEPath() :
    m_pPoints(NULL),
    m_pathType(PathNotSet),
    m_bAbsoluteMode(false),
    m_lPointCount(0)
{
    //do nothing
}

CTIMEPath::~CTIMEPath()
{
    delete [] m_pPoints;
}

HRESULT  
CTIMEPath::SetType(PathType type)
{
    HRESULT hr = E_FAIL;
    m_pathType = type;

    if (m_pathType == PathMoveTo || 
        m_pathType == PathLineTo || 
        m_pathType == PathHorizontalLineTo || 
        m_pathType == PathVerticalLineTo)
    {
        m_lPointCount = 1;
    }
    else if (m_pathType == PathClosePath)
    {
        m_lPointCount = 0;
    }
    else if (m_pathType == PathBezier)
    {
        m_lPointCount = 3;
    }
    else
    {
        hr = E_INVALIDARG;
        m_lPointCount = 0;
        goto done;
    }

    if (m_pPoints)
    {   
        delete m_pPoints;
        m_pPoints = NULL;
    }   

    if (m_lPointCount > 0)
    {
        m_pPoints = NEW POINTF [m_lPointCount];

        if (m_pPoints == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory(m_pPoints, sizeof(POINTF) * m_lPointCount);
    }
    
    hr = S_OK;

  done:

    return hr;
}

HRESULT   
CTIMEPath::SetAbsolute(bool bMode)
{
    m_bAbsoluteMode = bMode;
    return S_OK;
}

HRESULT   
CTIMEPath::SetPoints (long index, POINTF point)
{
    HRESULT hr = E_FAIL;

    if (index < 0 || 
        index > m_lPointCount - 1)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_pPoints == NULL)
    {
        goto done;
    }

    m_pPoints[index].x = point.x;
    m_pPoints[index].y = point.y;
    
    hr = S_OK;

  done:

    return hr;
}

POINTF *
CTIMEPath::GetPoints()
{
    POINTF *pTemp = NULL;
  
    if (m_lPointCount == 0)
    {
        goto done;
    }

    pTemp = NEW POINTF [m_lPointCount];
    
    if (pTemp == NULL)
    {
        goto done;
    }

    if (m_pPoints != NULL)
    {
        memcpy(pTemp, m_pPoints, sizeof(POINTF) * m_lPointCount);
    }

  done:
    return pTemp;
}

HRESULT 
CTIMEParser::ParsePlayList(CPlayList *pPlayList, bool fOnlyHeader, std::list<LPOLESTR> *asxList)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL, curTag = NULL;
    LPOLESTR pszTemp = NULL, pTagStr = NULL;
    bool fHeader = true;
    bool fEntry = false;
    bool fGetTagString = false;
    bool fTokenFound;
    TokenList tokenList;
    CComPtr<CPlayItem> pPlayItem;
    bool fCanSkip = true;

    TokenList vtokenList;
    StringList valueList;
    bool fClosed = false;

    if (pPlayList)
    {
        pPlayList->AddRef();
    }
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    while( curToken == TT_Space) //Get rid off leading spaces
    {
        m_Tokenizer->NextToken();
        curToken = m_Tokenizer->TokenType();
    }

    if (curToken != TT_Less)
    {
        hr = E_FAIL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }

    if (tempToken != ASX_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    while(((curToken = m_Tokenizer->NextToken()) != TT_EOF) && curToken != TT_Greater);
    if(curToken == EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    if(curToken != TT_Greater)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    if(fOnlyHeader)
    {
        goto done;
    }

    tokenList.push_front(tempToken);

    for(;;)
    {
        FreeStrings(valueList);
        valueList.clear();
        vtokenList.clear();

        if(!fGetTagString)
        {
            curToken = m_Tokenizer->NextToken();
        }
        else
        {
            //if(!m_Tokenizer->FetchStringToChar(_T('<')))
            if(!m_Tokenizer->FetchStringToString(L"</"))
            {
                hr = E_FAIL;
                tempToken = NULL;
                goto done;
            }
            if(pTagStr)
            {
                delete [] pTagStr;
                pTagStr = NULL;
            }

            pTagStr = m_Tokenizer->GetTokenValue();

            fGetTagString = false;
            continue;
        }
        if(curToken == TT_EOF)
        {
            if(tokenList.empty())
            {
                hr = S_OK;
                goto done;
            }
            hr = E_FAIL;
            goto done;
        }

        if(curToken == TT_Less)
        {
            //open tag
            curToken = m_Tokenizer->NextToken();

            if(curToken == TT_ForwardSlash)
            {
                //close tag
                curToken = m_Tokenizer->NextToken();
                if(curToken != TT_Identifier)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }

                hr = ParseToken(&tempToken);
                if (FAILED(hr))
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }

                if(tokenList.empty() || (tempToken != tokenList.front()))
                {
                    hr = E_FAIL;
                    tempToken = tokenList.front();
                    goto done;
                }

                tokenList.pop_front();

                curToken = m_Tokenizer->NextToken();
                if(curToken != TT_Greater)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
                TraceTag((tagTimeParser, "Closing <%S>", (TCHAR *)tempToken));

                if(tempToken == ENTRY_TOKEN)
                {
                    fEntry = false;
                    pPlayItem.Release();
                }
                else
                {
                    if(fEntry)
                    {
                        ProcessTag(tempToken, pTagStr, pPlayItem);
                    }
                    if(pTagStr != NULL)
                    {
                        delete [] pTagStr;
                        pTagStr = NULL;
                    }
                }

                //Process the tag.
                continue;
            }

            if(curToken != TT_Bang)
            {
                if(curToken != TT_Identifier)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
    
                hr = ParseToken(&tempToken);
                if (FAILED(hr))
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
            }
            else
            {
                hr = IgnoreValueTag();
                if(FAILED(hr))
                {
                    hr = E_FAIL;
                    goto done;
                }
                continue;
            }

            curTag = tempToken;
            TraceTag((tagTimeParser, "Opening <%S>", (TCHAR *)curTag));

            hr = ProcessValueTag(tempToken, pPlayItem, tokenList.front(), fTokenFound, asxList, &tokenList);
            if(FAILED(hr))
            {
                goto done;
            }
            if(fTokenFound)
            {
                continue;
            }

            IGNORE_HR(GetTagParams(&vtokenList, &valueList, fClosed));

            if(curTag == ENTRY_TOKEN)
            {
                pTagStr = FindTokenValue(CLIENTSKIP_TOKEN, vtokenList, valueList);
                if(pTagStr != NULL)
                {
                    if(StrCmpIW(pTagStr, L"No") == 0)
                    {
                        fCanSkip = false;
                    }
                }

                //create new play item
                if(fEntry) // do not allow nested entries.
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
                tokenList.push_front(curTag);
                fEntry = true;
                hr = THR(pPlayList->CreatePlayItem(&pPlayItem));
                if (FAILED(hr))
                {
                    goto done; //can't create playitems.
                }
                IGNORE_HR(pPlayList->Add(pPlayItem, -1));
                pPlayItem->PutCanSkip(fCanSkip);
                fCanSkip = true;
                continue;
            }

            if(curTag == REPEAT_TOKEN)
            {
                tokenList.push_front(curTag);
                continue;
            }

            if((curTag == AUTHOR_TOKEN) ||
               (curTag == TITLE_TOKEN) ||
               (curTag == ABSTRACT_TOKEN) ||
               (curTag == COPYRIGHT_TOKEN) ||
               (curTag == BANNER_TOKEN) ||
               (curTag == TITLE_TOKEN) ||
               (curTag == INVALID_TOKEN))
            {
                //create new play item
                tokenList.push_front(curTag);
                if(curTag != INVALID_TOKEN)
                {
                    fGetTagString = true;
                }
                continue;
            }

        }

        if(curToken == TT_Identifier || curToken == TT_String)
        {
                pszTemp = m_Tokenizer->GetTokenValue();

                delete [] pszTemp;
        }

        if(curToken == TT_Number)
        {
                pszTemp = m_Tokenizer->GetNumberTokenValue();

                delete [] pszTemp;
        }
    }

done:
    if (pPlayList)
    {
        pPlayList->Release();
    }

    return hr;
}

HRESULT
CTIMEParser::GetTagParams(TokenList *tokenList, StringList *valueList, bool &fClosed)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    unsigned char  iPos = 1;
    bool fdone = false;
    bool fKeepString = false;
    LPOLESTR pTagStr = NULL;
    
    while(!fdone)
    {
        curToken = m_Tokenizer->NextToken();
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            goto done;
        }

        if(iPos == 4)
        {
            if(curToken == TT_Identifier)
            {
                iPos = 1;
            }
        }
        switch(iPos)
        {
            case 1:
            {
                // State 1 checks for the identifiier
                if(curToken == TT_ForwardSlash)
                {
                    iPos = 5;
                    break;
                }
                if(curToken == TT_Greater)
                {
                    goto done;
                }

                if(curToken == TT_Identifier)
                {
                    if(tempToken != INVALID_TOKEN)
                    {
                        tokenList->push_back(tempToken);
                        fKeepString = true;
                    }
                    iPos++;
                    break;
                }

                hr = E_FAIL;
                fdone = true;
                break;
            }
            case 2:
            {
                // After identifier we have either another identifier or an equal
                if(curToken == TT_Identifier)
                {
                    if(fKeepString)
                    {
                        valueList->push_back(NULL);
                        fKeepString = false;
                    }
                    if(tempToken != INVALID_TOKEN)
                    {
                        tokenList->push_back(tempToken);
                        fKeepString = true;
                    }
                    iPos = 2;
                    break;
                }

                if(curToken != TT_Equal)
                {
                    hr = E_FAIL;
                    fdone = true; 
                    break;
                }
                iPos++;
                break;
            }
            case 3:
            {
                // After an equal we should find a string
                if(curToken != TT_String)
                {
                    hr = E_FAIL;
                    fdone = true;
                    break;
                }

                if(fKeepString)
                {
                    pTagStr = m_Tokenizer->GetTokenValue();
                    valueList->push_back(pTagStr);
                    fKeepString = false;
                }

                iPos++;
                break;
            }
            case 4:
            {
                // Check for correct prameter list termination
                if(curToken == TT_Greater)
                {
                    hr = S_OK;
                    fdone = true;
                    fClosed = false;
                    break;
                }
                else if(curToken == TT_ForwardSlash)
                {
                    iPos++;
                    break;
                }

                hr = E_FAIL;
                fdone = true;
            }
            case 5:
            {
                if(curToken == TT_Greater)
                {
                    hr = S_OK;
                    fClosed = true;
                }
                else
                {
                    hr = E_FAIL;
                }
                fdone = true;
            }
        }
    }
done:
    return hr;
}

HRESULT 
CTIMEParser::ProcessTag(TOKEN tempToken, LPOLESTR pszTemp, CPlayItem *pPlayItem)
{
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        goto done;
    }

    if(pszTemp == NULL)
    {
        goto done;
    }

    if(tempToken == AUTHOR_TOKEN)
    {
        TraceTag((tagTimeParser, "  Author:<%S>", pszTemp));
        pPlayItem->PutAuthor(pszTemp);
        goto done;
    }

    if(tempToken == TITLE_TOKEN)
    {
        TraceTag((tagTimeParser, "  Title:<%S>", pszTemp));
        pPlayItem->PutTitle(pszTemp);
        goto done;
    }
    
    if(tempToken == ABSTRACT_TOKEN)
    {
        TraceTag((tagTimeParser, "  Abstract:<%S>", pszTemp));
        pPlayItem->PutAbstract(pszTemp);
        goto done;
    }
    
    if(tempToken == COPYRIGHT_TOKEN)
    {
        TraceTag((tagTimeParser, "  Copyright:<%S>", pszTemp));
        pPlayItem->PutCopyright(pszTemp);
        goto done;
    }

    if(tempToken == HREF_TOKEN)
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEParser::IgnoreValueTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 

    while(((curToken = m_Tokenizer->NextToken()) != TT_EOF) && curToken != TT_Greater);
    if(curToken == EOF)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEParser::TestForValueTag(TOKEN token, TOKEN parentToken, bool &ffound, bool &fparentOk)
{
    int i, j;
    ffound = false;
    fparentOk = false;

    for( i = 0; (g_parentTable[ i].tagToken != NULL) && !fparentOk; i++)
    {
        if(token != g_parentTable[ i].tagToken)
        {
            continue;
        }
        ffound = true;

        for( j = 0; (j < g_parentTable[ i].listLen) && !fparentOk; j++)
        {
            if(g_parentTable[ i].allowedParents[ j] == parentToken)
            {
                fparentOk = true;
            }
        }
    }

}

bool
CTIMEParser::IsAsxTagToken(TOKEN token)
{
    bool fIsAsxTag = false;
    int i = 0;

    for(i = 0; (g_AsxTags[i] != NULL) && !fIsAsxTag; i++)
    {
        if(g_AsxTags[i] == token)
        {
            fIsAsxTag = true;
        }
    }

    return fIsAsxTag;
}

HRESULT
CTIMEParser::ProcessValueTag(TOKEN token, CPlayItem *pPlayItem, TOKEN parentToken, bool &ffound, std::list<LPOLESTR> *asxList, TokenList *ptokenList)
{
    HRESULT hr = S_OK;
    bool fparentOk = false;
    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;
    bool fIsAsx = true;

    TestForValueTag(token, parentToken, ffound, fparentOk);
    if(!ffound)
    {
        fIsAsx = IsAsxTagToken(token);
        if(!fIsAsx)
        {
            hr = GetTagParams(&tokenList, &valueList, fClosed);
            FreeStrings(valueList);
            if(FAILED(hr))
            {
                goto done;
            }

            if(!fClosed)
            {
                ptokenList->push_front(token);
            }
            ffound = true;
        }
        goto done;
    }

    if(!fparentOk)
    {
        hr = E_FAIL;
        goto done;
    }

    if(token == REF_TOKEN)
    {
        hr = ProcessRefTag(pPlayItem);
    }
    else if(token == ENTRYREF_TOKEN)
    {
        hr = ProcessEntryRefTag(asxList);
    }
    else if(token == BANNER_TOKEN)
    {
        hr = ProcessBannerTag(pPlayItem);
    }
    else if(token == MOREINFO_TOKEN)
    {
        hr = GetTagParams(&tokenList, &valueList, fClosed);
        if(FAILED(hr))
        {
            goto done;
        }
        FreeStrings(valueList);
        if(!fClosed)
        {
            hr = IgnoreValueTag();
        }
    }
    else if(token == BASE_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == LOGO_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == PARAM_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == PREVIEWDURATION_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == STARTTIME_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == STARTMARKER_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == ENDTIME_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == ENDMARKER_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == DURATION_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEParser::ProcessRefTag(CPlayItem *pPlayItem)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL, curTag = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;

    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;

    hr = GetTagParams(&tokenList, &valueList, fClosed);

    pszTemp = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszTemp == NULL)
    {
        goto done;
    }

    TraceTag((tagTimeParser, "  HREF:<%S>", pszTemp));
    pPlayItem->PutSrc(pszTemp);

done:
    delete [] pszTemp;

    return hr;
}

HRESULT
CTIMEParser::ProcessBannerTag(CPlayItem *pPlayItem)
{
    bool bClosed = false;
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;    
    LPOLESTR pszBanner = NULL;
    LPOLESTR pszAbstract = NULL;
    LPOLESTR pszMoreInfo = NULL;
    LPOLESTR pszModified = NULL;
    TokenList tokenList;
    StringList valueList;

    hr = GetTagParams(&tokenList, &valueList, bClosed);
    if(FAILED(hr))
    {
        goto done;
    }

    pszBanner = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszBanner == NULL)
    {
        goto done;
    }

    //handle other tags inside banner.
    while (!bClosed)
    {
        curToken = m_Tokenizer->NextToken();
        if (curToken != TT_Less)
        {
            hr = E_FAIL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();

        if (curToken == TT_ForwardSlash)
        {
            curToken = m_Tokenizer->NextToken();
            if (curToken != TT_Identifier)
            {
                hr = E_FAIL;
                goto done;
            }
            hr = ParseToken(&tempToken);
            if (tempToken != BANNER_TOKEN)
            {
                hr = E_FAIL;
                goto done;
            }
            curToken = m_Tokenizer->NextToken();
            if (curToken != TT_Greater)
            {
                hr = E_FAIL;
                goto done;
            }
            bClosed = true;
        }
        else
        {
            hr = ParseToken(&tempToken);
            if (FAILED(hr))
            {
                goto done;
            }

            if (tempToken == MOREINFO_TOKEN)
            {
                pszMoreInfo = ProcessMoreInfoTag();
            }
            else if (tempToken == ABSTRACT_TOKEN)
            {
                pszAbstract = ProcessAbstractTag();    
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
        }
    }

    TraceTag((tagTimeParser, "  Banner:<%S>", pszBanner));
    if (bClosed && (pPlayItem != NULL))
    {
        hr = S_OK;
        pPlayItem->PutBanner(pszBanner, pszAbstract, pszMoreInfo);
        goto done;
    }

done:

    delete [] pszBanner;
    delete [] pszAbstract;
    delete [] pszMoreInfo;
    pszBanner = NULL;
    pszAbstract = NULL;
    pszMoreInfo = NULL;

    return hr;
}

LPOLESTR 
CTIMEParser::ProcessMoreInfoTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;
    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;

    hr = GetTagParams(&tokenList, &valueList, fClosed);

    pszTemp = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszTemp == NULL)
    {
        goto done;
    }

done:

    return pszTemp;
}

LPOLESTR
CTIMEParser::FindTokenValue(TOKEN token, TokenList &tokenList, StringList &valueList)
{
    TokenList::iterator iToken;
    StringList::iterator iString;
    LPOLESTR pRetStr = NULL;

    if(tokenList.size() != valueList.size())
    {
        return NULL;
    }
    for(iToken = tokenList.begin(), iString = valueList.begin();
        iToken != tokenList.end(); iToken++, iString++)
        {
            if((*iToken) == token)
            {
                pRetStr = new TCHAR[lstrlen((*iString)) + 1];
                StrCpyW(pRetStr, (*iString));
                break;
            }
        }

    return pRetStr;
}

void
CTIMEParser::FreeStrings(StringList &valueList)
{
    StringList::iterator iString;

    for(iString = valueList.begin(); iString != valueList.end(); iString++)
    {
        if((*iString) != NULL)
        {
            delete [] (*iString);
            (*iString) = NULL;
        }
    }
}

HRESULT
CTIMEParser::ProcessHREF(LPOLESTR *pszTemp)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;

    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Identifier)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }
    if(tempToken != HREF_TOKEN)
    {
        hr = E_FAIL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Equal)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_String)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    *pszTemp = m_Tokenizer->GetTokenValue();

  done:

    return hr;

}

LPOLESTR 
CTIMEParser::ProcessAbstractTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    LPOLESTR pszModified = NULL;

    curToken = m_Tokenizer->NextToken();

    if (curToken != TT_Greater)
    {
        hr = E_FAIL;
        goto done;
    }

    if(!m_Tokenizer->FetchStringToString(L"</"))
    {
        hr = E_FAIL;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Less)
    {
        hr = E_FAIL;
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_ForwardSlash)
    {
        hr = E_FAIL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Identifier)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    if(tempToken != ABSTRACT_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Greater)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        delete [] pszTemp;
        pszTemp = NULL;
    }
    return pszTemp;
}

HRESULT
CTIMEParser::ProcessEntryRefTag(std::list<LPOLESTR> *asxList)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;
    bool fBind = false;
    LPOLESTR pTagStr = NULL;

    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Identifier)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    if(tempToken != HREF_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Equal)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_String)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();
    // This is the play item source

    curToken = m_Tokenizer->NextToken();

    if(curToken == TT_Identifier)
    {
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        if(tempToken != CLIENTBIND_TOKEN)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
        if(curToken != TT_Equal)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
        if(curToken != TT_String)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }
        pTagStr = m_Tokenizer->GetTokenValue();

        if(StrCmpIW(pTagStr, L"Yes") == 0)
        {
            fBind = true;
        }
        else if(StrCmpIW(pTagStr, L"No") == 0)
        {
            fBind = false;
        }
        else
        {
            delete [] pTagStr;
            pTagStr = NULL;
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        delete [] pTagStr;
        pTagStr = NULL;

        curToken = m_Tokenizer->NextToken();
    }


    if(curToken != TT_ForwardSlash)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Greater)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    TraceTag((tagTimeParser, "  HREF:<%S>", pszTemp));
    if(asxList != NULL)
    {
        asxList->push_front(pszTemp);
    }

done:

    return hr;
}


HRESULT 
CTIMEParser::ParseTransitionTypeAndSubtype (VARIANT *pvarType, VARIANT *pvarSubtype)
{
    HRESULT hr = S_OK;

    if ((NULL == pvarType) || (NULL == pvarSubtype))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        // Expected format is "typename:subtypename"
        LPOLESTR wzValue = m_Tokenizer->GetTokenValue();
        TIME_TOKEN_TYPE curToken = m_Tokenizer->NextToken();

        ::VariantClear(pvarType);
        ::VariantClear(pvarSubtype);

        if (NULL != wzValue)
        {
            V_VT(pvarType) = VT_BSTR;
            V_BSTR(pvarType) = ::SysAllocString(wzValue);
            delete [] wzValue;
            wzValue = NULL;
        }

        Assert(TT_Colon == curToken);
        curToken = m_Tokenizer->NextToken();

        if (TT_EOF != curToken)
        {
            wzValue = m_Tokenizer->GetTokenValue();
            if (NULL != wzValue)
            {
                V_VT(pvarSubtype) = VT_BSTR;
                V_BSTR(pvarSubtype) = ::SysAllocString(wzValue);
                delete [] wzValue;
                wzValue = NULL;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // ParseTransitionTypeAndSubtype
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\timetoken.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timetoken.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timetoken.h"

CTIMETokenizer::CTIMETokenizer () :
    _pCharacterStream(NULL),
    _cCharacterStream(0),
    _currChar ('\0'),
    _currToken (TT_Unknown),
    _currTokOffset(0),
    _nextTokOffset(0),
    _pStartOffset(0),
    _pEndOffset(0),
    _pStartTokenValueOffset(0),
    _pEndTokenValueOffset(0),
    _bTightSyntaxCheck(false),
    _bSingleCharMode(false)
{
}

CTIMETokenizer::~CTIMETokenizer()
{
    if (_pCharacterStream)
    {
        delete [] _pCharacterStream;
        _pCharacterStream = NULL;
    }
    _pStartOffset = NULL;
    _pEndOffset = NULL;
    _pStartTokenValueOffset = NULL;
    _pEndTokenValueOffset = NULL;
}
    
ULONG 
CTIMETokenizer::GetCharCount (OLECHAR token)
{
    ULONG count = 0;
    OLECHAR *curChar = _pCharacterStream;

    if (!_pCharacterStream)
    {
        goto done;
    }

    while (*curChar != '\0')
    {
        if (*curChar == token)
        {
            count++;
        }        
        curChar++;
    }
  done:
    
    return count;
}


ULONG 
CTIMETokenizer::GetAlphaCount(char cCount)
{
    ULONG count = 0;
    OLECHAR *curChar = _pCharacterStream;

    if (!_pCharacterStream)
    {
        goto done;
    }

    while (*curChar != '\0')
    {
        if (*curChar == cCount)
        {
            count++;
        }        
        curChar++;
    }
  done:
    
    return count;
}

void 
CTIMETokenizer::SetSingleCharMode(bool bSingle)
{ 
    _bSingleCharMode = bSingle; 
}

TIME_TOKEN_TYPE
CTIMETokenizer::NextToken()
{
    TIME_TOKEN_TYPE tt = TT_Unknown;

    if (CurrentChar())
    {
        if (_bSingleCharMode && _nextTokOffset == 1 && _pStartOffset != 0)
        {
            _pStartOffset = _pCharacterStream + _nextTokOffset;
        }
        else
        {
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;
        }
        
        if (CurrentChar() == CHAR_BACKSLASH)
        {
            tt = TT_Backslash;
        }
        // Identifier?
        else if ((CurrentChar() >= 'a' && CurrentChar() <= 'z') ||
                 (CurrentChar() >= 'A' && CurrentChar() <= 'Z') ||
                 (CurrentChar() == CHAR_ESCAPE))
        {
            // Fetch the rest of the identifier.
            tt = FetchIdentifier();
            goto Done;
        }

        else if ((CurrentChar() >= '0' && CurrentChar() <= '9') ||
                 (CurrentChar() == CHAR_DOT && PeekNextChar(0) >= '0' && PeekNextChar(0) <= '9' ))
        {
            tt = FetchNumber();
            goto Done;
        }

        else
        {
            switch (CurrentChar())
            {
            case CHAR_HASH : 
                tt = TT_Hash;
                NextChar();
                break;

            case CHAR_AT : 
                tt = TT_At;
                NextChar();
                break;

            case CHAR_SINGLE : 
            case CHAR_DOUBLE : 
                {
                    // TODO: Need to handle escaped character as first character.
                    // Probably best to do in CurrentChar
                    OLECHAR chStrDelim = CurrentChar();

                    NextChar();

                    // Don't include the beginning quote in string value.
                    _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

                    FetchString(chStrDelim);
                    NextChar();
                    tt = TT_String;
                    break;
                }

            case CHAR_EQUAL : 
                tt = TT_Equal;
                NextChar();
                break;
            
            case CHAR_COLON : 
                tt = TT_Colon;
                NextChar();
                break;

            case CHAR_FORWARDSLASH : 
                tt = TT_ForwardSlash;
                NextChar();
                break;

            case CHAR_LEFT_CURLY : 
                tt = TT_LCurly;
                NextChar();
                break;

            case CHAR_RIGHT_CURLY : 
                tt = TT_RCurly;
                NextChar();
                break;

            case CHAR_SEMI : 
                tt = TT_Semi;
                NextChar();
                break;

            case CHAR_DOT : 
                tt = TT_Dot;
                NextChar();
                break;

            case CHAR_COMMA : 
                tt = TT_Comma;
                NextChar();
                break;

            case CHAR_ASTERISK : 
                tt = TT_Asterisk;
                NextChar();
                break;

            case CHAR_LEFT_PAREN : 
                tt = TT_LParen;
                NextChar();
                break;

            case CHAR_RIGHT_PAREN : 
                tt = TT_RParen;
                NextChar();
                break;

            case CHAR_BANG : 
                tt = TT_Bang;
                NextChar();
                break;
            case CHAR_PERCENT :
                tt = TT_Percent;
                NextChar();
                break;
            case CHAR_PLUS :
                tt = TT_Plus;
                NextChar();
                break;
            case CHAR_MINUS :
                tt = TT_Minus;
                NextChar();
                break;
            case CHAR_SPACE:
                tt = TT_Space;
                if (!_bTightSyntaxCheck)
                {
                    while (CurrentChar() != 0 && isspace(CurrentChar()))
                    {
                        NextChar();
                    }
                    tt = NextToken();
                }
                else
                {
                    NextChar();
                }
                break;
            case CHAR_LESS:
                tt = TT_Less;
                NextChar();
                break;
            case CHAR_GREATER:
                tt = TT_Greater;
                NextChar();
                break;
            default: 
                // <!-- ?
                if (CDOToken())
                {
                    // find and return comment token.
                    tt = TT_Comment;
                }
                else
                    tt = TT_Unknown;
                NextChar();
                break;
            }
        }
    }
    else    // Done parsing EOF hit.
    {
        tt = TT_EOF;
    }

    _currTokOffset = _nextTokOffset - 1;

Done:
    NextNonSpaceChar();
    _currToken = tt;

    return tt;
}


TIME_TOKEN_TYPE
CTIMETokenizer::FetchIdentifier()
{
    if (!_bSingleCharMode)
    {
        while ((CurrentChar() >= 'a' && CurrentChar() <= 'z') ||
               (CurrentChar() >= 'A' && CurrentChar() <= 'Z') ||
               (CurrentChar() >= '0' && CurrentChar() <= '9') ||
               (CurrentChar() == CHAR_UNDERLINE || CurrentChar() == CHAR_ESCAPE)) 
        {
            if (CurrentChar() == CHAR_ESCAPE)
                break;

            NextChar();
        }
    }
    else
    {
        NextChar(); //only fetch a single character.
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Identifier;
}

BOOL
CTIMETokenizer::FetchStringToChar(OLECHAR chStrDelim)
{
    _pStartOffset++;

    return FetchString(chStrDelim);
}

BOOL
CTIMETokenizer::FetchStringToString(LPOLESTR pstrDelim)
{
    _pStartOffset++;

    return FetchString(pstrDelim);
}


TIME_TOKEN_TYPE
CTIMETokenizer::FetchNumber()
{
    // digit = 0..9
    // number = digit* | [digit + '.' [+ digit*]]

    while (CurrentChar() >= '0' && CurrentChar() <= '9') 
    {
        NextChar();
    }

    if (CurrentChar() == CHAR_DOT)
    {
        NextChar();
        if (CurrentChar() >= '0' && CurrentChar() <= '9')
        {
            while (CurrentChar() >= '0' && CurrentChar() <= '9')
                NextChar();
        }
        else
        {
            return TT_Unknown;
        }
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;
    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Number;
}


// Looking for /* and 
BOOL
CTIMETokenizer::CDOToken()
{
    if (CurrentChar() == CHAR_FORWARDSLASH &&
        PeekNextChar(0) == CHAR_ASTERISK)
    {
        // skip the /*
        NextChar();
        NextChar();

        while (CurrentChar() &&
               (CurrentChar() != CHAR_ASTERISK ||
                PeekNextChar(0) != CHAR_FORWARDSLASH))
        {
            NextChar();
        }

        // skip the */
        if (CurrentChar())
        {
            // Only advance one char here as there will be one more in NextToken(), after this.
            NextChar();
        }

        _pEndOffset = _pCharacterStream + _nextTokOffset;

        return TRUE;
    }

    return FALSE;
}


BOOL
CTIMETokenizer::FetchString(OLECHAR chDelim)
{
    BOOL   fResult;

    while (CurrentChar() && CurrentChar() != chDelim)
    {
        NextChar();
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    // Was end string delimiter found ' or " depending on how the string started?
    fResult = !!CurrentChar();

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return fResult;
}

BOOL
CTIMETokenizer::FetchString(LPOLESTR strDelim)
{
    BOOL fResult = FALSE;
    int i = 0, iLen, j, iOffsetLen;
    LPOLESTR pcmpStr = NULL;

    if(strDelim == NULL)
    {
        goto done;
    }

    iLen = lstrlenW(strDelim);

    iOffsetLen = lstrlenW(_pStartOffset);
    if(iOffsetLen < iLen)
    {
        fResult = FALSE;
        goto done;
    }

    pcmpStr = new TCHAR[lstrlenW(strDelim) + 1];

    while (((iOffsetLen - i) > iLen) && (fResult != TRUE))
    {
        for(j = 0; j < iLen; j++)
        {
            //pcmpStr[j] = *(_pStartOffset + i + j);
            pcmpStr[j] = *(_pCharacterStream + _nextTokOffset + j - 1);
        }
        pcmpStr[iLen] = 0;

        if(StrCmpIW(pcmpStr, strDelim) == 0)
        {
            fResult = TRUE;
            break;
        }
        NextChar();
        i++;
    }
    delete [] pcmpStr;

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

done:
    return fResult;
}

HRESULT CTIMETokenizer::Init (OLECHAR *pData, ULONG ulLen)
{
    HRESULT hr = S_OK;

    if (_pCharacterStream)
    {
        delete [] _pCharacterStream;
        _pCharacterStream = NULL;
    }
    _pCharacterStream = CopyString(pData);
    if (NULL == _pCharacterStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    _cCharacterStream = ulLen;
    //need to reset all of the values

    _currChar = '\0';
    _currToken = TT_Unknown;
    _currTokOffset = 0;
    _nextTokOffset = 0;
    _pStartOffset = 0;
    _pEndOffset = 0;
    _pStartTokenValueOffset = 0;
    _pEndTokenValueOffset = 0;

    NextChar();             // Prime the tokenizer.
    NextNonSpaceChar();     // Find first real character to be tokenized.

    hr = S_OK;
done:
    RRETURN(hr);
}

OLECHAR CTIMETokenizer::NextChar()
{
    if (_nextTokOffset < _cCharacterStream)
        _currChar = *(_pCharacterStream + _nextTokOffset++);
    else if (_currChar)
    {
        _nextTokOffset = _cCharacterStream + 1;
        _currChar = _T('\0');
    }

    return _currChar;
}


OLECHAR CTIMETokenizer::NextNonSpaceChar()
{
    if (!_bTightSyntaxCheck)
    {
        while (CurrentChar() != 0 && isspace(CurrentChar()))
            NextChar();
    }

    return CurrentChar();    // if 0 return then EOF hit.
}

BOOL CTIMETokenizer::isIdentifier (OLECHAR *szMatch)
{
    if (_currToken == TT_Identifier)
    {
        return StrCmpIW(szMatch, GetTokenValue()) == 0;
    }

    return FALSE;
}

double CTIMETokenizer::GetTokenNumber()
{
    ULONG len = 0;
    double dblTokenValue = 0.0;
    OLECHAR *szTokenValue = NULL;
 
    if (_currToken != TT_Number)
    {
        goto done;        
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        HRESULT hr = S_OK;
        VARIANT vNum;
        
        len = GetTokenLength();
        szTokenValue = NEW OLECHAR [len + 1];
        
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');

        //convert the token to a number
        VariantInit(&vNum);
        vNum.vt = VT_BSTR;
        vNum.bstrVal = SysAllocString(szTokenValue);

        hr = THR(VariantChangeTypeEx(&vNum, &vNum, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8));
        if (SUCCEEDED(hr))
        {
            dblTokenValue = V_R8(&vNum);
        }

        delete [] szTokenValue;
        szTokenValue = NULL;

        VariantClear(&vNum);
    }
    

  done:
    return dblTokenValue;
}

OLECHAR *CTIMETokenizer::GetTokenValue ()
{
    ULONG len = 0;
    OLECHAR *szTokenValue = NULL;

    if (_currToken == TT_Number)
    {
        goto done;        
    }

    len = GetTokenLength();
    if (_bSingleCharMode && len > 1)
    {
        _pEndTokenValueOffset = _pStartTokenValueOffset + 1;
        _nextTokOffset = _pEndTokenValueOffset - _pStartTokenValueOffset;
        len = GetTokenLength();
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        szTokenValue = NEW OLECHAR [len + 1];
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');
    }

  done:
    return szTokenValue;
}


OLECHAR *CTIMETokenizer::GetNumberTokenValue ()
{
    ULONG len = 0;
    OLECHAR *szTokenValue = NULL;

    len = GetTokenLength();
    if (_bSingleCharMode && len > 1)
    {
        _pEndTokenValueOffset = _pStartTokenValueOffset + 1;
        _nextTokOffset = _pEndTokenValueOffset - _pStartTokenValueOffset;
        len = GetTokenLength();
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        szTokenValue = NEW OLECHAR [len + 1];
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');
    }

  done:
    return szTokenValue;
}

OLECHAR *CTIMETokenizer::GetRawString (ULONG uStartOffset, ULONG uEndOffset)
{
    int i = 0;
    OLECHAR *szTokenValue = NULL;

    if (uEndOffset && uEndOffset > uStartOffset)
    {

        szTokenValue = NEW OLECHAR [(uEndOffset-uStartOffset) + 1];

        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, (_pCharacterStream + uStartOffset), sizeof(OLECHAR)*(uEndOffset-uStartOffset));
        szTokenValue[uEndOffset-uStartOffset] = '\0';
        //trim off trailing spaces
        i = uEndOffset-uStartOffset;
        while (szTokenValue[i] == ' ' && i >= 0)
        {
            szTokenValue[i] = _T('\0');
            i--;
        }
    }

  done:
    return szTokenValue;
}

// Look ahead to next non-space character w/o messing with current tokenizing state.
OLECHAR CTIMETokenizer::PeekNextNonSpaceChar()
{
    ULONG   peekTokOfset = _nextTokOffset;
    OLECHAR   peekCurrentChar = _currChar;

    while (peekCurrentChar != 0 && isspace(peekCurrentChar))
        peekCurrentChar = (peekTokOfset < _cCharacterStream) ? *(_pCharacterStream + peekTokOfset++) : '\0';

    return peekCurrentChar;    // if 0 return then EOF hit.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\tokens.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: token.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tokens.h"

// timeAction values
TOKEN NONE_TOKEN                    = L"none";
TOKEN STYLE_TOKEN                   = L"style";
TOKEN VISIBILITY_TOKEN              = L"visibility";
TOKEN DISPLAY_TOKEN                 = L"display";
TOKEN INVALID_TOKEN                 = L"";

// If this should change, nCLASS_TOKEN_LENGTH should be changed as well
TOKEN     CLASS_TOKEN               = L"class";
const int nCLASS_TOKEN_LENGTH       = 5;
// If this should change, nSEPARATOR_LENGTH should be changed as well
TOKEN     SEPARATOR_TOKEN           = L":";
const int nSEPARATOR_TOKEN_LENGTH   = 1;

TOKEN ONOFF_PROPERTY_TOKEN         = L"on";

TOKEN TRUE_TOKEN   = L"true";
TOKEN FALSE_TOKEN  = L"false";
TOKEN HIDDEN_TOKEN  = L"hidden";

TOKEN READYSTATE_COMPLETE_TOKEN = L"complete";

TOKEN CANSLIP_TOKEN  = L"canSlip";
TOKEN LOCKED_TOKEN   = L"locked";

TOKEN STOP_TOKEN = L"stop";
TOKEN PAUSE_TOKEN = L"pause";
TOKEN DEFER_TOKEN = L"defer";
TOKEN NEVER_TOKEN = L"never";

TOKEN REMOVE_TOKEN = L"remove";
TOKEN FREEZE_TOKEN = L"freeze";
TOKEN HOLD_TOKEN = L"hold";
TOKEN TRANSITION_TOKEN = L"transition";

TOKEN ALWAYS_TOKEN = L"always";
TOKEN WHENNOTACTIVE_TOKEN = L"whenNotActive";

TOKEN SEQ_TOKEN = L"seq";
TOKEN PAR_TOKEN = L"par";
TOKEN EXCL_TOKEN = L"excl";

TOKEN AUTO_TOKEN = L"auto"; 
TOKEN MANUAL_TOKEN = L"manual";
TOKEN RESET_TOKEN = L"reset";

#if DBG // 94850
TOKEN DSHOW_TOKEN = L"dshow";
#endif
TOKEN DVD_TOKEN = L"dvd";
TOKEN DMUSIC_TOKEN = L"dmusic";
TOKEN CD_TOKEN = L"cd";

TOKEN DISCRETE_TOKEN = L"discrete";
TOKEN LINEAR_TOKEN = L"linear";
TOKEN PACED_TOKEN = L"paced";

TOKEN CLOCKWISE_TOKEN = L"clockwise";
TOKEN COUNTERCLOCKWISE_TOKEN = L"counterclockwise";

//ASX TOKENS
TOKEN ENTRY_TOKEN = L"entry";
TOKEN TITLE_TOKEN = L"title";
TOKEN COPYRIGHT_TOKEN = L"copyright";
TOKEN AUTHOR_TOKEN = L"author";
TOKEN ABSTRACT_TOKEN = L"abstract";
TOKEN REF_TOKEN = L"ref";
TOKEN ENTRYREF_TOKEN = L"entryref";
TOKEN ASX_TOKEN = L"asx";
TOKEN HREF_TOKEN = L"href";
TOKEN REPEAT_TOKEN = L"repeat";
TOKEN EVENT_TOKEN = L"event";
TOKEN MOREINFO_TOKEN = L"moreinfo";
TOKEN BASE_TOKEN = L"base";
TOKEN LOGO_TOKEN = L"logo";
TOKEN PARAM_TOKEN = L"param";
TOKEN PREVIEWDURATION_TOKEN = L"previewduration";
TOKEN STARTTIME_TOKEN = L"starttime";
TOKEN STARTMARKER_TOKEN = L"startmarker";
TOKEN ENDTIME_TOKEN = L"endtime";
TOKEN ENDMARKER_TOKEN = L"endmarker";
TOKEN DURATION_TOKEN = L"duration";
TOKEN BANNER_TOKEN = L"banner";
TOKEN CLIENTSKIP_TOKEN = L"clientskip";
TOKEN CLIENTBIND_TOKEN = L"clientbind";
TOKEN COUNT_TOKEN = L"count";


//END ASX TOKENS

TOKEN FIRST_TOKEN = L"first";
TOKEN LAST_TOKEN = L"last";

TOKEN INDEFINITE_TOKEN = L"indefinite";

// TODO: Need to make this much faster

// This array should never contain INVALID_TOKEN
static TOKEN tokenArray[] =
{
    NONE_TOKEN,
    STYLE_TOKEN,
    VISIBILITY_TOKEN,
    DISPLAY_TOKEN,
    CLASS_TOKEN,
    READYSTATE_COMPLETE_TOKEN,
    CANSLIP_TOKEN,
    LOCKED_TOKEN,
    STOP_TOKEN,
    PAUSE_TOKEN,
    DEFER_TOKEN,
    NEVER_TOKEN,
    REMOVE_TOKEN,
    FREEZE_TOKEN,
    HOLD_TOKEN,
    TRANSITION_TOKEN,
    ALWAYS_TOKEN,
//    NEVER_TOKEN, // also above
    WHENNOTACTIVE_TOKEN,  
    SEQ_TOKEN,
    PAR_TOKEN,
    EXCL_TOKEN,
    AUTO_TOKEN, 
    MANUAL_TOKEN,
    RESET_TOKEN,
#if DBG // 94850
    DSHOW_TOKEN,
#endif
    DVD_TOKEN,
    CD_TOKEN,
    DISCRETE_TOKEN,
    LINEAR_TOKEN,
    PACED_TOKEN,
    CLOCKWISE_TOKEN,
    COUNTERCLOCKWISE_TOKEN,
    FIRST_TOKEN,
    LAST_TOKEN,
    INDEFINITE_TOKEN,
    DMUSIC_TOKEN,
    ENTRY_TOKEN,
    TITLE_TOKEN,
    COPYRIGHT_TOKEN,
    REF_TOKEN,
    ASX_TOKEN,
    ABSTRACT_TOKEN,
    AUTHOR_TOKEN,
    HREF_TOKEN,
    ENTRYREF_TOKEN,
    REPEAT_TOKEN,
    EVENT_TOKEN,
    MOREINFO_TOKEN,
    BASE_TOKEN,
    LOGO_TOKEN,
    PARAM_TOKEN,
    PREVIEWDURATION_TOKEN,
    STARTTIME_TOKEN,
    STARTMARKER_TOKEN,
    ENDTIME_TOKEN,
    ENDMARKER_TOKEN,
    DURATION_TOKEN,
    BANNER_TOKEN,
    CLIENTSKIP_TOKEN,
    CLIENTBIND_TOKEN,
    COUNT_TOKEN,
    NULL
};

TOKEN
StringToToken(wchar_t * str)
{
    for (unsigned int i = 0; i < ARRAY_SIZE(tokenArray); i++)
    {
        if (StrCmpIW(str, (wchar_t *) tokenArray[i]) == 0)
            return tokenArray[i];
    }

    return INVALID_TOKEN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\timevalue.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timevalue.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------



#include "headers.h"
#include "timevalue.h"

DeclareTag(tagTimeValue, "TIME: Time Value", "TimeValue methods");

TimeValue::TimeValue(LPWSTR Element,
                     LPWSTR Event,
                     double Offset)
: m_pwszElm(Element),
  m_pwszEv(Event),
  m_dblOffset(Offset)
{
}

TimeValue::TimeValue()
: m_pwszElm(NULL),
  m_pwszEv(NULL),
  m_dblOffset(0.0)
{
}

TimeValue::TimeValue(const TimeValue & tv)
: m_pwszElm(NULL),
  m_pwszEv(NULL),
  m_dblOffset(0.0)
{
    Copy(tv);
}
    
TimeValue::~TimeValue()
{
    Clear();
}

void
TimeValue::Clear()
{
    delete [] m_pwszElm;
    m_pwszElm = NULL;
    
    delete [] m_pwszEv;
    m_pwszEv = NULL;

    m_dblOffset = 0.0;
}
    
HRESULT
TimeValue::Copy(const TimeValue & tv)
{
    return Set(tv.GetElement(),
               tv.GetEvent(),
               tv.GetOffset());
}

HRESULT
TimeValue::Set(LPWSTR Element,
               LPWSTR Event,
               double Offset)
{
    Clear();

    m_pwszElm = Element?CopyString(Element):NULL;
    m_pwszEv = Event?CopyString(Event):Event;
    m_dblOffset = Offset;

    return S_OK;
}

TimeValueList::TimeValueList()
{
}

TimeValueList::~TimeValueList()
{
    Clear();
}

void
TimeValueList::Clear()
{
    for (TimeValueSTLList::iterator i = m_tvlList.begin();
         i != m_tvlList.end();
         i++)
    {
        delete (*i);
    }

    m_tvlList.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\base.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// BASE.CPP - Base class methods
//


#include "pch.h"

// Constructors / Destructors
CBase::CBase( 
        LPECB lpEcb, 
        LPSTR *lppszOut,
        LPSTR *lppszDebug, 
        LPDUMPTABLE lpDT )
{

    this->lpEcb     = lpEcb;

    this->lpszOut   = NULL;
    this->lpszDebug = NULL;
    this->lpDT      = lpDT;

    if ( lppszOut )
    {
        *lppszOut = (LPSTR) GlobalAlloc( GMEM_FIXED, 65336 );
        if ( *lppszOut )
        {
            this->lpszOut      = *lppszOut;
            this->lpszOut[ 0 ] = 0; // start empty;
        }
    }

    if ( lppszDebug )
    {
        *lppszDebug = (LPSTR) GlobalAlloc( GMEM_FIXED, 8196 );
        if ( *lppszDebug )
        {
            this->lpszDebug      = *lppszDebug;
            this->lpszDebug[ 0 ] = 0; // start empty;
        }
    }

} // CBase( )

CBase::~CBase( )
{
    GlobalFree( lpszDebug );
    GlobalFree( lpszOut );
} // ~CBase( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\base.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// BASE.H - 
//


#ifndef _BASE_H_
#define _BASE_H_


class CBase
{

public:
    LPECB   lpEcb;
    LPSTR   lpszOut;                    // HTML output
    LPSTR   lpszDebug;                  // Debug output

    LPDUMPTABLE lpDT;                   // Parser commented hex dump table

    CBase( LPECB lpEcb, LPSTR *lpszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    virtual ~CBase( );

private:

}; // CBase


#endif // _BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\util\util.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: util.cpp
//
//  Contents: commonly used utility functions, etc.
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "util.h"
#define INITGUID
#include <initguid.h>  // needed for precomp headers...
#include <ddrawex.h>
#include "tokens.h"
#include <ras.h>
#include <dispex.h>
#include <shlguid.h>
#include <shlwapip.h>
#include "timevalue.h"

// Need this #define because global headers use some of the deprecated functions. Without this
// #define, we can't build unless we touch code everywhere.
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#undef STRSAFE_NO_DEPRECATE

//defined for VariantToTime conversion function
#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour

static IDirectDraw * g_directdraw = NULL;
static CritSect * g_ddCS = NULL;
static CritSect * g_STLCS = NULL;
static long g_lConnectSpeed = -1;
static HRESULT g_hrConnectResult = S_OK;

DISPID GetDispidAndParameter(IDispatch *pidisp, LPCWSTR wzAtributeNameIn, long *lParam);

#define MAX_REG_VALUE_LENGTH   50

#if DBG == 1

//+------------------------------------------------------------------------
//
//  Implement THR and IGNORE_HR for TIME code
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs. Trident's THR
//  and IGNORE_HR output is too polluted to allow TIME failures to be easily detected.
//
//-------------------------------------------------------------------------
DeclareTag(tagTimeTHR, "TIME", "Trace THR and IGNORE_HR");

//+-----------------------------------------------------------------------------------
//
//  Member:     ::THRTimeImpl
//
//  Synopsis:   Implements the THR macro for TIME. This function should never be used directly.
//
//  Arguments:
//
//  Returns:    HRESULT passed in
//
//------------------------------------------------------------------------------------
HRESULT
THRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine)
{
    if (FAILED(hr))
    {
        TraceTag((tagTimeTHR, "THR: FAILURE of \"%s\" at %s:%d <hr = 0x%x>", pchExpression, pchFile, nLine, hr));
    }
    return hr;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     ::IGNORE_HRTimeImpl
//
//  Synopsis:   Implements the IGNORE_HR macro for TIME. This function should never be used directly.
//
//  Arguments:
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
void
IGNORE_HRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine)
{
    if (FAILED(hr))
    {
        TraceTag((tagTimeTHR, "IGNORE_HR: FAILURE of \"%s\" at %s:%d <hr = 0x%x>", pchExpression, pchFile, nLine, hr));
    }
}

#endif // if DBG == 1



IDirectDraw *
GetDirectDraw()
{
    HRESULT hr;

    {
        CritSectGrabber _csg(*g_ddCS);

        if (g_directdraw == NULL)
        {
            CComPtr<IDirectDrawFactory> lpDDF;

            hr = CoCreateInstance(CLSID_DirectDrawFactory,
                                  NULL, CLSCTX_INPROC_SERVER,
                                  IID_IDirectDrawFactory,
                                  (void **) & lpDDF);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDrawFactory object");
                return NULL;
            }

            hr = lpDDF->CreateDirectDraw(NULL, NULL, DDSCL_NORMAL, 0, NULL, &g_directdraw); //lint !e620

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDraw object");
                return NULL;
            }

            hr = g_directdraw->SetCooperativeLevel(NULL,
                                                   DDSCL_NORMAL); //lint !e620

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not set DirectDraw properties");
                g_directdraw->Release();
                g_directdraw = NULL;
                return NULL;
            }

        }
    }

    return g_directdraw;
}

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT * pf,
                       bool vidmem,
                       LONG width, LONG height)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH; //lint !e620
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;

    if (pf)
    {
        // KEVIN: if you want the pixelformat of the surface tomatach the
        // screen, comment out this line.
        ddsd.dwFlags |= DDSD_PIXELFORMAT; //lint !e620

        ddsd.ddpfPixelFormat = *pf;
    }

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        (DDSCAPS_3DDEVICE |                                                         //lint !e620
         DDSCAPS_OFFSCREENPLAIN |                                                   //lint !e620
         (vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC));    //lint !e620

    IDirectDraw * dd = ddraw;

    if (!dd)
    {
        dd = GetDirectDraw();

        if (!dd)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    hr = dd->CreateSurface( &ddsd, surfPtrPtr, NULL );

    if (FAILED(hr))
    {
        *surfPtrPtr = NULL;
    }

  done:
    return hr;
}

inline LONG Width(LPRECT r) { return r->right - r->left; }
inline LONG Height(LPRECT r) { return r->bottom - r->top; }

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect)
{
    HRESULT hr;

    HDC destDC;
    hr = DDSurf->GetDC(&destDC);

    if (SUCCEEDED(hr))
    {
        HRGN hrgn;

        hrgn = CreateRectRgn(0,0,1,1);

        if (hrgn == NULL)
        {
            hr = GetLastError();
        }
        else
        {
            if (GetClipRgn(srcDC, hrgn) == ERROR)
            {
                hr = GetLastError();
            }
            else
            {
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - prcDestRect(%d, %d, %d, %d)",
                          prcDestRect->left,prcDestRect->top,prcDestRect->right,prcDestRect->bottom));

                RECT targetRect;
                RECT rgnRect;

                GetRgnBox(hrgn, &rgnRect);

                TraceTag((tagError,
                          "CopyDCToDdrawSurface - rgn box(%d, %d, %d, %d)",
                          rgnRect.left,rgnRect.top,rgnRect.right,rgnRect.bottom));

                if (IntersectRect(&targetRect, &rgnRect, prcDestRect))
                {
                    TraceTag((tagError,
                              "CopyDCToDdrawSurface - targetrect(%d, %d, %d, %d)",
                              targetRect.left,targetRect.top,targetRect.right,targetRect.bottom));

                    {
                        BitBlt(destDC,
                               prcDestRect->left,
                               prcDestRect->top,
                               Width(prcDestRect),
                               Height(prcDestRect),

                               srcDC,
                               prcSrcRect->left,
                               prcSrcRect->top,
                               SRCCOPY);

                        //SelectClipRgn(destDC, NULL);
                    }
                }
            }

            DeleteObject(hrgn);
        }

        DDSurf->ReleaseDC(destDC);
    }

    return hr;
}

//////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

//// Misc ///

//const wchar_t * TIMEAttrPrefix = L"t:";

BSTR
CreateTIMEAttrName(LPCWSTR str)
{
    ////////////////////////////////////////////////////////////
    // REMOVE DEPENDENCY ON t:
    // This code is left in in case we ever need to modify the attribute names
    // again.
    ////////////////////////////////////////////////////////////
    //BSTR bstr = NULL;
    //
    //LPWSTR newstr = (LPWSTR) _alloca(sizeof(wchar_t) *
    //                                 (lstrlenW(str) +
    //                                  lstrlenW(TIMEAttrPrefix) +
    //                                  1));
    //
    //if (newstr == NULL)
    //{
    //    goto done;
    //}
    //
    //StrCpyW(newstr, TIMEAttrPrefix);
    //StrCatW(newstr, str);
    //
    //bstr = SysAllocString(newstr);
    ////////////////////////////////////////////////////////////

  done:
    return SysAllocString(str);
}

HRESULT
GetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 LONG lFlags,
                 VARIANT * value)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(elm->getAttribute(bstr,lFlags,value));

    SysFreeString(bstr);

  done:
    return hr;
}

HRESULT
SetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 VARIANT value,
                 LONG lFlags)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(elm->setAttribute(bstr,value,lFlags));

    SysFreeString(bstr);

  done:
    return hr;
}

//
// Initialization
//

/*lint ++flb */

bool
InitializeModule_Util()
{
    g_ddCS = new CritSect;
    g_STLCS = new CritSect;

    if (NULL == g_ddCS || NULL == g_STLCS)
    {
        return false;
    }

    return true;
}

void
DeinitializeModule_Util(bool bShutdown)
{
    delete g_ddCS;
    g_ddCS = NULL;

    delete g_STLCS;
    g_STLCS = NULL;
}

/*lint --flb */

///////////////////////////////////////////////////////////
// Name: VariantToBool
//
// Parameters:   VARIANT var      - a variant to convert to a
//                                  BOOL value.
//
// Abstract:
//    This function coverts any VARIANT to a boolean value using
//    TRUE = 1 and FALSE = 0.  (COM uses TRUE = -1 and FALSE = 0).
//    Any VARIANT that can be coerced to a BOOL is and the coerced
//    value is returned.  If the VARIANT cannot be coerced, FALSE
//    is returned.
///////////////////////////////////////////////////////////
bool VariantToBool(VARIANT var)
{
    //if the value is already a bool return it.
    if (var.vt == VT_BOOL)
    {
        return var.boolVal == FALSE ? false : true;
    }
    else  //otherwise convert it to VT_BOOL
    {
        VARIANT vTemp;
        HRESULT hr;

        VariantInit(&vTemp);
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL);
        if (SUCCEEDED(hr)) //if it can be converted return it
        {
            return vTemp.boolVal == FALSE ? false : true;
        }
        else //if it can't be converted return false
        {
            return false;
        }
    }

}


///////////////////////////////////////////////////////////
// Name: VariantToFloat
//
// Parameters:   VARIANT var      - a variant to convert to a
//                                  float value.  This can contain
//                                  the special cases 'FOREVER' and
//                                  'INDEFINITE'.
//
// Abstract:
//
///////////////////////////////////////////////////////////
float VariantToFloat(VARIANT var, bool bAllowIndefinite, bool bAllowForever)
{
    float fResult = INVALID;

    if (var.vt == VT_R4)
    {
        fResult = var.fltVal;
        goto done;
    }

    VARIANT vTemp;
    HRESULT hr;

    VariantInit(&vTemp);
    hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr))
    {
        fResult = vTemp.fltVal;
        goto done;
    }

    //Check to see if it is 'FOREVER' and 'INDEFINITE
    //Should these be case sensitive?
    if (bAllowForever)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, L"FOREVER") == 0)
            {
                fResult = FOREVER;
                goto done;
            }
        }
    }
    if (bAllowIndefinite)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, WZ_INDEFINITE) == 0)
            {
                fResult = INDEFINITE;
                goto done;
            }
        }
    }

  done:
    return fResult;

}

///////////////////////////////////////////////////////////
// Name: VariantToTime
//
// Parameters:   VARIANT var      - a VARIANT to convert to a
//                                  from a time value to seconds.
//                                    this can take the form of
//                                    HH:MM:SS.DD
//                                    MM:SS.DD
//                                    SS.DD
//                                    DD.DDs
//                                    DD.DDm
//                                    DD.DDh
//                                    and may be preceeded by a + or -
//
//
//
// Abstract:
//    Converts the incoming variant to a BSTR and parses for valid
//    clock values.  It passes the value back in retVal and returns
//    S_OK or E_INVALIDARG in the case of incorrect input. If the
//    return value is E_INVALIDARG, *retVal is passed back as
//    INDEFINITE.
///////////////////////////////////////////////////////////
HRESULT VariantToTime(VARIANT var, float *retVal, long *lframe, bool *fisFrame)
{

    HRESULT hr = S_OK;
    OLECHAR *szTime;
    OLECHAR *szTimeBase = NULL;
    bool bPositive = TRUE;
    int nHour = 0;
    int nMin = 0;
    int nSec = 0;
    float fFSec = 0;
    VARIANT vTemp;

    if(fisFrame)
    {
        *fisFrame = false;
    }

    //convert the parameter to a BSTR
    VariantInit(&vTemp);
    if (var.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }
    else
    {
        hr = VariantCopy(&vTemp, &var);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }

    hr = S_OK;

    //convert to a char array. If not possible, return error.
    szTimeBase = TrimCopyString(vTemp.bstrVal);

    if (szTimeBase == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szTime = szTimeBase;

    if (IsIndefinite(szTime))
    {
        *retVal = INDEFINITE;
        goto done;
    }

    //check for +/- if none, assume +
    if (*szTime == '-')
    {
        bPositive = false;
        szTime++;
    }
    else if (*szTime == '+')
    {
        szTime++;
    }

    //check for invalid and err out
    if (*szTime == '\0')
    {
        *retVal = INVALID;
        goto done;
    }

    //get first set of numbers
    while (*szTime >= '0' && *szTime <= '9')
    {
        nSec = nSec * 10 + (*szTime - '0');
        szTime++;
    }
    if (*szTime == '\0')    //if none use time as seconds
    {
        *retVal = bPositive ? nSec : -nSec; //this is the end so return;
        goto done;
    }
    else if (*szTime == '.')  //if it is a '.' treat this as the fractional part
    {
        float nDiv = 10.0;
        szTime++;
        while (*szTime >= '0' && *szTime <= '9')
        {
            fFSec = fFSec + (*szTime - '0') / nDiv;
            szTime++;
            nDiv *= 10;
        }
        if (*szTime == '\0')
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
            goto done;
        }
    }

    if (*szTime == 'h') //if "h" use time as hours
    {
        nHour = nSec;
        nSec = 0;
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nHour + fFSec) * SECPERHOUR) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 'i' && *(szTime + 2) == 'n') //if "min" use time as minutes
    {
        nMin = nSec;
        nSec = 0;
        szTime += 3;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nMin + fFSec) * SECPERMINUTE)* (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 's') //if "s" use time as seconds
    {
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 's') //if "ms" use time as milliseconds
    {
        fFSec = (fFSec + nSec) / 1000.0;
        szTime += 2;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = fFSec * (bPositive? 1 : -1); //convert minutes to seconds
        }
        goto done;
    }
    else if (*szTime == 'f') //if "s" use time as seconds
    {
        if((fisFrame == NULL) || (lframe == NULL))
        {
            hr = E_FAIL;
            goto done;
        }
        szTime++;
        if (*szTime != '\0')
        {
            *lframe = INVALID;
        }
        else
        {
            *lframe = (nSec) * (bPositive? 1 : -1);
            *fisFrame = true;
        }
        goto done;
    }
    else if (*szTime == ':' && fFSec == 0)
    {
        //handle the HH:MM:SS format here
        nMin = nSec;
        nSec = 0;

        //next part must be 2 digits
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = *szTime - '0';
        }
        else
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = nSec * 10 + (*szTime - '0');
        }
        else
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime == ':')
        {
            nHour = nMin;
            nMin = nSec;
            nSec = 0;
            //next part must be 2 digits
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = *szTime - '0';
            }
            else
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = nSec * 10 + (*szTime - '0');
            }
            else
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
        }

        if (*szTime == '.')
        {
            //handle fractional part
            float nDiv = 10.0;
            szTime++;
            while ((*szTime >= '0') && (*szTime <= '9'))
            {
                fFSec = fFSec + ((*szTime - '0') / nDiv);
                szTime++;
                nDiv *= 10;
            }
        }

        //check to be sure the string terminated
        if (*szTime != '\0')
        {
            *retVal = INVALID;
            goto done;
        }

        if (nSec < 00 || nSec > 59 || nMin < 00 || nMin > 59)
        {
            *retVal = INVALID;
            goto done;
        }
        *retVal = (((float)(nHour * SECPERHOUR + nMin * SECPERMINUTE + nSec) + fFSec)) * (bPositive? 1 : -1); //lint !e790
    }
    else
    {
        *retVal = INVALID;
    }
  done:

    if (szTimeBase != NULL)
    {
        delete [] szTimeBase;
    }

    if (vTemp.vt == VT_BSTR)
    {
        VariantClear(&vTemp);
    }

    if (*retVal == INVALID) //lint !e777
    {
        *retVal = INDEFINITE;
        hr = E_INVALIDARG;
    }

    return hr;

}

///////////////////////////////////////
// Name: IsIndefinite
//
// Abstract:
//   Determines in a case-insensitive manner
//   if the string szTime is 'INDEFINITE'.
///////////////////////////////////////
BOOL IsIndefinite(OLECHAR *szTime)
{
    BOOL bResult = FALSE;

    if (StrCmpIW(szTime, L"INDEFINITE") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

//+-----------------------------------------------------------------------
//
//  Member:    EnsureComposerSite
//
//  Overview:  Ensure that there is a composer site behavior present on an
//             element
//
//  Arguments: The target element
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
EnsureComposerSite (IHTMLElement2 *pielemTarget, IDispatch **ppidispSite)
{
    HRESULT hr;
    CComPtr<IAnimationComposerSite> spComposerSite;

    Assert(NULL != ppidispSite);

    hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                               pielemTarget,
                               IID_IAnimationComposerSite,
                               reinterpret_cast<void **>(&spComposerSite));

    if (S_OK != hr)
    {
        CComPtr<IAnimationComposerSiteFactory> spSiteFactory;

        hr = THR(CoCreateInstance(CLSID_AnimationComposerSiteFactory,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IAnimationComposerSiteFactory,
                                  reinterpret_cast<void**>(&spSiteFactory)));
        if (FAILED(hr))
        {
            goto done;
        }

        {
            CComVariant varComposerSiteFactory(static_cast<IUnknown *>(spSiteFactory));
            long nCookie;

            hr = THR(pielemTarget->addBehavior(WZ_SMILANIM_STYLE_PREFIX,
                                               &varComposerSiteFactory,
                                               &nCookie));
            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                                   pielemTarget,
                                   IID_IAnimationComposerSite,
                                   reinterpret_cast<void **>(&spComposerSite));
    }

    Assert(spComposerSite != NULL);
    if (FAILED(hr) || (spComposerSite == NULL))
    {
        goto done;
    }

    hr = THR(spComposerSite->QueryInterface(IID_TO_PPV(IDispatch, ppidispSite)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // EnsureComposerSite


HRESULT
AddBodyBehavior(IHTMLElement* pBaseElement)
{
    CComPtr<IHTMLElement2>      spBodyElement2;
    CComPtr<ITIMEFactory>       spTimeFactory;
    CComPtr<ITIMEBodyElement>   spBodyElem;

    HRESULT hr;

    hr = THR(GetBodyElement(pBaseElement,
                            IID_IHTMLElement2,
                            (void **) &spBodyElement2));
    if (FAILED(hr))
    {
        // If the QI failed then simply return assuming we are using IE4
        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }

        goto done;
    }

    // here if we need to parent to some other page body i.e. pBodyElement != NULL
    // we no longer create a new body. We initialize variables needed for this parenting.

    if (IsTIMEBehaviorAttached(spBodyElement2))
    {
        // someone's already put a TIMEBody behavior on the time body.  bail out.
        hr = S_OK;
        goto done;
    }

    // This is really ugly but I guess necessary
    hr = THR(CoCreateInstance(CLSID_TIMEFactory,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITIMEFactory,
                              (void**)&spTimeFactory));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        CComVariant varTIMEFactory((IUnknown *) spTimeFactory);
        long nCookie;

        hr = THR(spBodyElement2->addBehavior(WZ_TIME_STYLE_PREFIX,
                                             &varTIMEFactory,
                                             &nCookie));
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
GetBodyElement(IHTMLElement* pElem, REFIID riid, void** ppBE)
{
    HRESULT hr = S_OK;

    CComPtr<IDispatch>         pBodyDispatch;
    CComPtr<IHTMLDocument2>    pDocument2;
    CComPtr<IHTMLElement>      pBodyElement;

    Assert(NULL != pElem);

    hr = THR(pElem->get_document(&pBodyDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBodyDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocument2->get_body(&pBodyElement));

    // We need to check the point aswell as the hr since we get lied to by Trident sometimes.
    if (FAILED(hr) || !pBodyElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pBodyElement->QueryInterface(riid, ppBE));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}

// ------------------------------------------------------------------------------

HRESULT
FindBehaviorInterface(LPCWSTR pwszName,
                      IDispatch *pHTMLElem,
                      REFIID riid,
                      void **ppRet)
{
    CComVariant varResult;
    HRESULT hr;

    Assert(pHTMLElem != NULL);
    Assert(ppRet != NULL);

    // Don't use THR as this is expected to fail several times.
    hr = GetProperty(pHTMLElem, pwszName, &varResult);

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = THR(varResult.ChangeType(VT_DISPATCH));
    if (FAILED(hr))
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    if (V_DISPATCH(&varResult) == NULL)
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = V_DISPATCH(&varResult)->QueryInterface(riid, ppRet);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_NOINTERFACE);
}

HRESULT
FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem)
{
    HRESULT hr;
    CComPtr<IDispatch> spDispatch;

    if (NULL == pHTMLElem || NULL == ppTIMEElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, &spDispatch)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                                  spDispatch,
                                  IID_ITIMEElement,
                                  reinterpret_cast<void**>(ppTIMEElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

// ------------------------------------------------------------------------------

// @@ Need to share code between the time class and here
// @@ that sniffs an element for a behavior.
bool
IsTIMEBehaviorAttached (IDispatch *pidispElem)
{
    HRESULT hr;
    CComPtr<ITIMEElement> spTIMEElm;

    hr = FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                               pidispElem,
                               IID_ITIMEElement,
                               reinterpret_cast<void **>(&spTIMEElm));

    return (S_OK == hr);
} // IsTIMEBehaviorAttached

// ------------------------------------------------------------------------------

// @@ Need to share code between the time class and here
// @@ that sniffs an element for a behavior.
bool
IsComposerSiteBehaviorAttached (IDispatch *pidispElem)
{
    HRESULT hr;
    CComPtr<IAnimationComposerSite> spComposerSite;

    hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                               pidispElem,
                               IID_IAnimationComposerSite,
                               reinterpret_cast<void **>(&spComposerSite));

    return (S_OK == hr);
} // IsComposerSiteBehaviorAttached

// ------------------------------------------------------------------------------

LPWSTR
TIMEGetLastErrorString()
{
    HRESULT hr = S_OK;
    CComPtr<IErrorInfo> pErrorInfo;
    CComBSTR bstrDesc;
    LPWSTR pDesc = NULL;

    hr = GetErrorInfo(0, &pErrorInfo);
    if (FAILED(hr))
    {
        goto done;
    }

    if (pErrorInfo == NULL)
    {
        goto done;
    }

    hr = pErrorInfo->GetDescription(&bstrDesc);
    if (FAILED(hr))
    {
        goto done;
    }

    pDesc = NEW WCHAR [bstrDesc.Length() + 1];
    if (pDesc == NULL)
    {
        goto done;
    }

    ZeroMemory(pDesc, (bstrDesc.Length() + 1) * sizeof(WCHAR));
    memcpy(pDesc, bstrDesc, bstrDesc.Length() * sizeof(WCHAR));

  done:
    return pDesc;
}

HRESULT
TIMEGetLastError()
{
    DWORD dwHRes = 0;
    HRESULT hr = S_OK;

    CComPtr<IErrorInfo> pErrorInfo;

    hr = GetErrorInfo(0, &pErrorInfo);

    if (FAILED(hr))
    {
        return hr;
    }

    if (pErrorInfo != NULL)
    {
        hr = pErrorInfo->GetHelpContext(&dwHRes);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return (HRESULT)dwHRes;
}

HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg)
{
    USES_CONVERSION; //lint !e522
    HINSTANCE hInst = 0;
    TCHAR szDesc[1024];
    szDesc[0] = NULL;
    // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
    if (ULONG_PTR( msg ) < 0x10000) // id
    {
        UINT nID = LOWORD((ULONG_PTR)msg);
        _ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
        if (LoadString(hInst, nID, szDesc, 1024) == 0)
        {
            _ASSERTE(FALSE);
            lstrcpy(szDesc, _T("Unknown Error"));
        }
        //this is a lint problem with the macro expansion.
        msg = T2OLE(szDesc); //lint !e506
        if (hr == 0)
        {
            //another lint problem with the macro expansion
            hr = MAKE_HRESULT(3, FACILITY_ITF, nID); //lint !e648
        }
    }
    CComPtr<ICreateErrorInfo> pICEI;
    if (SUCCEEDED(CreateErrorInfo(&pICEI)))
    {
        CComPtr<IErrorInfo> pErrorInfo;
        pICEI->SetGUID(GUID_NULL);
        LPOLESTR lpsz;
        ProgIDFromCLSID(CLSID_TIME, &lpsz);
        if (lpsz != NULL)
        {
            pICEI->SetSource(lpsz);
        }

        pICEI->SetHelpContext(hr);

        CoTaskMemFree(lpsz);
        pICEI->SetDescription((LPOLESTR)msg);
        if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
        {
            SetErrorInfo(0, pErrorInfo);
        }
    }

    return (hr == 0) ? DISP_E_EXCEPTION : hr;
} //lint !e550


//////////////////////////////////////////////////////////////////////////////////////////////////
// String Parsing utilities
//////////////////////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------------------
//
//  Function:   ::StringToTokens
//
//  Synopsis:   Parses a string into tokens
//
//  Arguments:  [pstrString]        String to be parsed
//              [pstrSeparators]    String of separators
//              [paryTokens]        Array of tokens returned
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Assumes separators are single characters
//              3. Implicitly uses NULL as a separator
//              4. Memory: If function returns success, caller should free memory in paryTokens
//              5. Perf hint: arrange separators in decreasing frequency-of-occurrance order.
//
//------------------------------------------------------------------------------------

HRESULT
StringToTokens(/*in*/ LPWSTR                   pstrString,
               /*in*/ LPWSTR                   pstrSeparators,
               /*out*/CPtrAry<STRING_TOKEN*> * paryTokens )
{
    HRESULT         hr = E_FAIL;
    UINT            uStringLength = 0;
    UINT            uSeparatorsLength = 0;
    UINT            uStringIndex;
    UINT            uSeparatorsIndex;
    WCHAR           chCurrChar;
    bool            fTokenBegun;
    bool            fIsSeparator;
    STRING_TOKEN *  pStringToken;

    CHECK_RETURN_NULL(pstrString);
    CHECK_RETURN_NULL(pstrSeparators);
    CHECK_RETURN_NULL(paryTokens);

    uStringLength = wcslen(pstrString);
    uSeparatorsLength = wcslen(pstrSeparators);

    // done if string is empty
    if (0 == uStringLength)
    {
        hr = S_OK;
        goto done;
    }

    // We make one pass through pstrString, going left to right, processing
    // one character per iteration.
    //
    // A simple state machine (3 states) is used:
    //
    // Initial state:       Token not begun and Token not ended (state 1)
    // Intermediate state:  Token begun and Token not ended     (state 2)
    // Final state:         Token begun and Token ended         (state 3)
    //
    // State transitions depend on whether the current character is a separator:
    //
    // State 1 --- separator -------> State 1
    // State 1 --- non-separator ---> State 2
    // State 2 --- non-separator ---> State 2
    // State 2 --- separator -------> State 3
    // State 3 ---------------------> State 1 (Done with current token, move on to next token)
    //

    // initialize to state 1
    fTokenBegun = false;
    pStringToken = NULL;

    // Loop through all characters of pstrString including terminating null, from left to right
    for (uStringIndex = 0;
         uStringIndex < uStringLength + 1;
         uStringIndex ++)
    {
        //
        // Determine if current char is a separator
        //

        chCurrChar = pstrString[uStringIndex];
        for (fIsSeparator = false,
             uSeparatorsIndex = 0;
             uSeparatorsIndex < uSeparatorsLength + 1;
             uSeparatorsIndex ++)
        {
            // break if current character is a separator
            if (chCurrChar == pstrSeparators[uSeparatorsIndex])
            {
                fIsSeparator = true;
                break;
            }
        }

        //
        // Token parsing logic
        //

        if (!fTokenBegun)
        {
            // We are in State 1
            if (fIsSeparator)
            {
                // remain in State 1
                continue;
            }
            else
            {
                // go to state 2
                fTokenBegun = true;

                // Since this is nulled out when we go from state 3 to 1, if this fails it means
                // we made an illegal state transition (2 -> 1) -- Bad!!!
                Assert(NULL == pStringToken);

                // create token struct
                pStringToken = new STRING_TOKEN;
                if (NULL == pStringToken)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                // store the index of the first char of the token
                (*pStringToken).uIndex = uStringIndex;
            }
        }
        else
        {
            // We are in State 2
            if (false == fIsSeparator)
            {
                // remain in state 2
                continue;
            }
            else
            {
                // We are in State 3 now

                // This should not be null because we *should* have come here from state 2.
                Assert(NULL != pStringToken);

                // Store length of token
                (*pStringToken).uLength = uStringIndex - (*pStringToken).uIndex;

                // append token to array
                hr = (*paryTokens).Append(pStringToken);
                if (FAILED(hr))
                {
                    delete pStringToken;
                    goto done;
                }

                // Null out the reference to indicate we're done with this token
                pStringToken = NULL;

                // go to state 1 (move on to next token)
                fTokenBegun = false;
            }
        }
    } // for

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        IGNORE_HR(FreeStringTokenArray(paryTokens));
    }
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::TokensToString
//
//  Synopsis:   Creates a string from an array of tokens
//
//  Arguments:  [paryTokens]        Iput array of tokens
//              [pstrString]        Input string
//              [ppstrOutString]    Output string
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Memory: If function returns success, caller should free memory in ppstrOutString
//
//------------------------------------------------------------------------------------


HRESULT TokensToString(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens,
                       /*in*/  LPWSTR                   pstrString,
                       /*out*/ LPWSTR *                 ppstrOutString)
{
    HRESULT hr = E_FAIL;
    LPWSTR pstrTemp = NULL;
    UINT i1;
    UINT ichTemp;
    UINT uSize;
    UINT uStringLength;
    UINT uTokenLength;
    STRING_TOKEN ** ppToken;
    LPWSTR pstrToken;

    CHECK_RETURN_NULL(paryTokens);
    CHECK_RETURN_NULL(pstrString);
    CHECK_RETURN_SET_NULL(ppstrOutString);

    // If this fires, it means we will leak pstrString
    Assert(pstrString != *ppstrOutString);

    uSize = (*paryTokens).Size();
    uStringLength = wcslen(pstrString);

    // done if ary or string is empty
    if (0 == uSize || 0 == uStringLength)
    {
        hr = S_OK;
        goto done;
    }

    // allocate memory for string (cannot be larger than pstrString)
    pstrTemp = new WCHAR[sizeof(WCHAR) * (uStringLength + 1)];
    if (NULL == pstrTemp)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    // store index at which to append
    ichTemp = 0;

    // loop over tokens in String 1
    for (i1 = 0, ppToken = (*paryTokens);
         i1 < uSize;
         i1++, ppToken++)
    {
        Assert(*ppToken);

        // alias ugly variables
        pstrToken = &(pstrString[(**ppToken).uIndex]);
        uTokenLength = (**ppToken).uLength;

        // append to difference string
        memcpy(&(pstrTemp[ichTemp]),
               pstrToken,
               sizeof(WCHAR) * uTokenLength);

        // update index of writable sub-string
        ichTemp += uTokenLength;

        // append blank space if this is not the last Token
        if (i1 < uSize - 1)
        {
            pstrTemp[ichTemp] = L' ';
            ichTemp ++;
        }
    }

    // null terminate pstrTemp
    if (ichTemp <= uStringLength)
    {
        pstrTemp[ichTemp] = NULL;
    }
    else
    {
        // Bad! no space to put NULL
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    // TODO: dilipk 8/31/99: reallocate string of correct size
    *ppstrOutString = pstrTemp;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (NULL != pstrTemp)
        {
            delete [] pstrTemp;
            pstrTemp = NULL;
        }
    }
    return hr;
}



//+-----------------------------------------------------------------------------------
//
//  Function:   ::TokenSetDifference
//
//  Synopsis:   Computes set difference of two arrays of tokens. Set Difference of A & B
//              (A - B) is the set of elements in A that are not in B.
//
//  Arguments:  [paryTokens1]           Input array 1
//              [pstr1]                 Input string 1
//              [paryTokens2]           Input array 2
//              [pstr2]                 Input string 2
//              [paryTokens1Minus2]     Output array
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Memory: If function returns success, caller should free memory in paryTokens1Minus2
//              3. Token comparisons are case insensitive
//
//------------------------------------------------------------------------------------


HRESULT TokenSetDifference(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens1,
                           /*in*/  LPWSTR                   pstr1,
                           /*in*/  CPtrAry<STRING_TOKEN*> * paryTokens2,
                           /*in*/  LPWSTR                   pstr2,
                           /*out*/ CPtrAry<STRING_TOKEN*> * paryTokens1Minus2)
{
    HRESULT hr = E_FAIL;
    UINT i1;
    UINT i2;
    UINT Size1;
    UINT Size2;
    STRING_TOKEN ** ppToken1;
    STRING_TOKEN ** ppToken2;
    LPWSTR pstrToken1;
    LPWSTR pstrToken2;
    UINT uToken1Length;
    UINT uToken2Length;
    STRING_TOKEN * pNewToken;
    bool fIsUnique;

    CHECK_RETURN_NULL(paryTokens1);
    CHECK_RETURN_NULL(paryTokens2);
    CHECK_RETURN_NULL(paryTokens1Minus2);
    CHECK_RETURN_NULL(pstr1);
    CHECK_RETURN_NULL(pstr2);

    // Protect against weirdness
    if (paryTokens1 == paryTokens1Minus2 ||
        paryTokens2 == paryTokens1Minus2)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    Size1 = (*paryTokens1).Size();
    Size2 = (*paryTokens2).Size();

    // done if either Token array is empty
    if (0 == Size1 || 0 == Size2)
    {
        hr = S_OK;
        goto done;
    }

    // loop over tokens in String 1
    for (i1 = 0, ppToken1 = (*paryTokens1);
         i1 < Size1;
         i1++, ppToken1++)
    {
        Assert(*ppToken1);

        // look for match in String 2
        fIsUnique = true;
        for (i2 = 0, ppToken2 = (*paryTokens2);
             i2 < Size2;
             i2++, ppToken2++)
        {
            Assert(*ppToken2);

            // alias ugly variables
            pstrToken1 = &(pstr1[(**ppToken1).uIndex]);
            pstrToken2 = &(pstr2[(**ppToken2).uIndex]);
            uToken1Length = (**ppToken1).uLength;
            uToken2Length = (**ppToken2).uLength;

            // compare lengths
            if (uToken1Length != uToken2Length)
            {
                continue;
            }

            // compare tokens (lengths are equal)
            if (0 == StrCmpNIW(pstrToken1, pstrToken2, uToken1Length))
            {
                fIsUnique = false;
                break;
            }
        } // for

        if (fIsUnique)
        {
            // Create copy of token
            pNewToken = new STRING_TOKEN;
            if (NULL == pNewToken)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            (*pNewToken).uIndex = (**ppToken1).uIndex;
            (*pNewToken).uLength = (**ppToken1).uLength;

            // Append new token to paryTokens1Minus2
            hr = THR((*paryTokens1Minus2).Append(pNewToken));
            if (FAILED(hr))
            {
                delete pNewToken;
                goto done;
            }
        }
    } // for


    hr = S_OK;
done:
    if (FAILED(hr))
    {
        IGNORE_HR(FreeStringTokenArray(paryTokens1Minus2));
    }
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::FreeStringTokenArray
//
//  Synopsis:   Frees memory allocated to tokens and empties the array
//
//  Arguments:  [paryTokens]           Input array
//
//  Returns:    [S_OK]      If function completes successfully
//              [E_POINTER] Bad arg pointer
//
//------------------------------------------------------------------------------------


HRESULT
FreeStringTokenArray(/*in*/CPtrAry<STRING_TOKEN*> * paryTokens)
{
    HRESULT hr = E_FAIL;
    UINT i;
    STRING_TOKEN ** ppStringToken;

    CHECK_RETURN_NULL(paryTokens);

    for (i = (*paryTokens).Size(), ppStringToken = *paryTokens;
         i > 0;
         i--, ppStringToken++)
    {
        Assert(*ppStringToken);
        delete *ppStringToken;
    }

    (*paryTokens).DeleteAll();

    hr = S_OK;
done:
    return hr;
}



#ifdef DBG

static const UINT s_cMAX_TOKEN_LENGTH = 1000;

//+-----------------------------------------------------------------------------------
//
//  Function:   ::PrintStringTokenArray
//
//  Synopsis:   Debugging utility to print tokens using TraceTag((tagError,...))
//
//  Arguments:  [pstrString]    Input string
//              [paryTokens]    Input array
//
//  Returns:    [void]
//
//  Notes:      1. Assumes null terminated strings
//
//------------------------------------------------------------------------------------

void
PrintStringTokenArray(/*in*/ LPWSTR                   pstrString,
                      /*in*/ CPtrAry<STRING_TOKEN*> * paryTokens)
{
    int i;
    STRING_TOKEN ** ppStringToken;
    char achOutputString[s_cMAX_TOKEN_LENGTH];
    WCHAR wchTemp;

    if (NULL == paryTokens || NULL == pstrString)
    {
        return;
    }

    WideCharToMultiByte(CP_ACP, NULL,
                        pstrString,
                        -1,
                        achOutputString,
                        s_cMAX_TOKEN_LENGTH, NULL, NULL);
    TraceTag((tagError, "*********Parsed String: <%s>\nTokens:\n", achOutputString));

    for (i = (*paryTokens).Size(), ppStringToken = *paryTokens;
         i > 0;
         i--, ppStringToken++)
    {
        Assert(*ppStringToken);

        wchTemp = pstrString[(**ppStringToken).uIndex + (**ppStringToken).uLength];
        *(pstrString + (**ppStringToken).uIndex + (**ppStringToken).uLength) = *(L"");
        WideCharToMultiByte(CP_ACP, NULL,
                            pstrString + (**ppStringToken).uIndex,
                            (**ppStringToken).uLength + 1,
                            achOutputString,
                            s_cMAX_TOKEN_LENGTH, NULL, NULL);
        pstrString[(**ppStringToken).uIndex + (**ppStringToken).uLength] = wchTemp;

        TraceTag((tagError, "<%s> index = %d, length = %d\n", achOutputString,
            (**ppStringToken).uIndex, (**ppStringToken).uLength));
    }
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::PrintWStr
//
//  Synopsis:   Debugging utility to print a LPWSTR using TraceTag((tagError,...))
//
//  Arguments:  [pstr]    Input string
//
//  Returns:    [void]
//
//  Notes:      1. Assumes null terminated strings
//
//------------------------------------------------------------------------------------

void
PrintWStr(LPWSTR pstr)
{
    char achOutputString[s_cMAX_TOKEN_LENGTH];

    WideCharToMultiByte(CP_ACP, NULL,
                        pstr,
                        -1,
                        achOutputString,
                        s_cMAX_TOKEN_LENGTH, NULL, NULL);
    TraceTag((tagError, "<%s>", achOutputString));
}

#endif /* DBG */


WCHAR * TrimCopyString(const WCHAR *str)
{
    int i = 0;
    int len = str?lstrlenW(str)+1:1;
    int j = len - 1;
    WCHAR *newstr = NULL;

    if (str != NULL)
    {
        while (str[i] == ' ' && i < len)
        {
            i++;
        }
        while (str[j-1] == ' ' && j > 0)
        {
            j--;
        }


        newstr = new WCHAR [(i<j)?(j - i + 1):1] ;
        if (newstr)
        {
            if (i < j)
            {
                memcpy(newstr,str+i?str+i:L"",(j - i) * sizeof(WCHAR)) ;
                newstr[j-i] = 0;
            }
            else
            {
                memcpy(newstr, L"", sizeof(WCHAR)) ;
            }
        }
    }
    else
    {
        newstr = new WCHAR;
        if (newstr != NULL)
        {
            newstr[0] = 0;
        }
    }
    return newstr ;

}

// This used to convert URL's to a netshow extension.

WCHAR *
BeckifyURL(WCHAR *url)
{
    WCHAR *newVal = NULL;
    LPCWSTR lpFileName = PathFindFileName(url);
    LPCWSTR lpwExt = PathFindExtensionW(lpFileName);

    if(url == NULL)
    {
        newVal = NULL;
        goto done;
    }

    if(lstrlenW(url) < 5)
    {
        newVal = NULL;
        goto done;
    }

    if(lpwExt != lpFileName + lstrlenW(lpFileName))
    {
        newVal = NULL;
        goto done;
    }

    if((TIMEGetUrlScheme(url) != URL_SCHEME_HTTP) && (TIMEGetUrlScheme(url) != URL_SCHEME_HTTPS))
    {
        newVal = NULL;
        goto done;
    }

    newVal = NEW OLECHAR [lstrlenW(url) + 6];
    if(newVal == NULL)
    {
        goto done;
    }

    StrCpyW(newVal, url);
    StrCatW(newVal, L".beck");

done:
    return newVal;
}

bool
IsASXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    bool bRet = false;

    if (src != NULL)
    {
        LPCWSTR lpwExt = PathFindExtensionW(src);

        // Detect .asf files and skip them
        if (StrCmpIW(lpwExt, ASFSRC) == 0)
        {
            goto done;
        }
        else if (StrCmpIW(lpwExt, ASXSRC) == 0)
        {
            bRet = true;
            goto done;
        }
    }

    if (srcType != NULL &&
        StrStrIW(srcType, ASXMIME2) != NULL)
    {
        bRet = true;
        goto done;
    }
    else if (userMimeType != NULL &&
        StrStrIW(userMimeType, ASXMIME) != NULL)
    {
        bRet = true;
        goto done;
    }
    else if (userMimeType != NULL &&
        StrStrIW(userMimeType, ASXMIME2) != NULL)
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

static bool
TestFileExtension(LPCWSTR wzFile, LPCWSTR wzExtension)
{
    bool bRet = false;

    if (NULL != wzFile)
    {
        LPCWSTR lpwExt = PathFindExtensionW(wzFile);

        // Detect .asf files and skip them
        if (StrCmpIW(lpwExt, wzExtension) == 0)
        {
            bRet = true;
            goto done;
        }
    }

  done:
    return bRet;
} // TestFileExtension

bool
IsM3USrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, M3USRC);
} // IsM3USrc

bool
IsLSXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, LSXSRC);
} // IsLSXSrc

bool
IsWMXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WMXSRC);
} // IsLSXSrc

bool
IsWAXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WAXSRC);
} // IsWAXSrc

bool
IsWVXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WVXSRC);
} // IsWVXSrc

bool
IsWMFSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WMFSRC);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
bool IsHTMLSrc(const WCHAR * src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    bool bFlag = false;

    if (src != NULL)
    {
        len = lstrlenW(src);
        if (len >= HTMLSTREAMSRCLEN)
        {
            memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));

            if ((StrCmpIW(stream, HTMLSTREAMSRC) == 0) || (StrCmpIW(stream, SAMISTREAMSRC) == 0))
            {
                bFlag = true;
            }

        }
    }
    return bFlag;
}

bool
StringEndsIn(const LPWSTR pszString, const LPWSTR pszSearch)
{
    if (NULL == pszString || NULL == pszSearch)
    {
        return false;
    }

    size_t iStringLength = wcslen(pszString);
    size_t iSearchLength = wcslen(pszSearch);

    if (iSearchLength > iStringLength)
    {
        return false;
    }

    if (0 == StrCmpNIW(pszString+(iStringLength - iSearchLength), pszSearch, iSearchLength))
    {
        return true;
    }
    return false;
}

//+-----------------------------------------------------------------------
//
//  Member:    MatchElements
//
//  Overview:  Find out whether two interfaces point to the same object
//
//  Arguments: the dispatch of the objects
//
//  Returns:   bool
//
//------------------------------------------------------------------------
bool
MatchElements (IUnknown *piInOne, IUnknown *piInTwo)
{
    bool bRet = false;

    if (piInOne == piInTwo)
    {
        bRet = true;
    }
    else if (NULL == piInOne || NULL == piInTwo)
    {
        bRet = false;
    }
    else
    {
        CComPtr<IUnknown> piunk1;
        CComPtr<IUnknown> piunk2;

        if (FAILED(THR(piInOne->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piunk1)))))
        {
            goto done;
        }
        if (FAILED(THR(piInTwo->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piunk2)))))
        {
            goto done;
        }

        bRet = ((piunk1.p) == (piunk2.p));
    }

done :
    return bRet;
} // MatchElements

//+-----------------------------------------------------------------------
//
//  Member:    GetProperty
//
//  Overview:  Get the value of the given property
//
//  Arguments: The dispatch, property name and the out param for the new value
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
GetProperty (IDispatch *pidisp, LPCWSTR wzPropNameIn, VARIANTARG *pvar)
{
    HRESULT             hr;
    DISPID              dispid = NULL;
    LPWSTR              wzPropName = const_cast<LPWSTR>(wzPropNameIn);
    DISPPARAMS          params = {NULL, NULL, 0, 0};

    Assert(NULL != pidisp);
    Assert(NULL != wzPropName);
    Assert(NULL != pvar);

    // Don't use THR as this can fail several times
    hr = pidisp->GetIDsOfNames(IID_NULL, &wzPropName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        // need to handle the (n) case....
        long lExtraParam;
        dispid = GetDispidAndParameter(pidisp, wzPropName, &lExtraParam);
        if (NULL == dispid)
        {
            goto done;
        }
        // Now get the data....
        params.rgvarg = NEW VARIANTARG[1];
        if (NULL == params.rgvarg)
        {
            goto done;
        }

        ZeroMemory(params.rgvarg, sizeof(VARIANTARG));
        params.rgvarg[0].vt   = VT_I4;
        params.rgvarg[0].lVal = lExtraParam;
        params.cArgs          = 1;

    }

    hr = THR(pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                            &params, pvar, NULL, NULL));


    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (params.rgvarg != NULL)
    {
        delete [] params.rgvarg;
    }
    return hr;
} // GetProperty

//+-----------------------------------------------------------------------
//
//  Member:    PutProperty
//
//  Overview:  Set the value of the given property
//
//  Arguments: The dispatch, property name and the new value
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
PutProperty (IDispatch *pidisp, LPCWSTR wzPropNameIn, VARIANTARG *pvar)
{
    HRESULT     hr;
    DISPID      dispid      = NULL;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    LPWSTR      wzPropName  = const_cast<LPWSTR>(wzPropNameIn);
    DISPPARAMS  params      = {pvar, &dispidPut, 1, 1};
    long        lExtraParam = -1;
    Assert(NULL != pidisp);
    Assert(NULL != wzPropName);
    Assert(NULL != pvar);

    hr = THR(pidisp->GetIDsOfNames(IID_NULL, &wzPropName,
                                   1, LCID_SCRIPTING, &dispid));
    if (FAILED(hr))
    {
        // need to handle the (n) case....
        dispid = GetDispidAndParameter(pidisp, wzPropName, &lExtraParam);
        if (NULL == dispid)
        {
            goto done;
        }
        // Now get the data....
        params.rgvarg = new VARIANTARG[2];
        if (NULL == params.rgvarg)
        {
            goto done;
        }
        ZeroMemory(params.rgvarg, sizeof(VARIANTARG) * 2);
        params.rgvarg[1].vt   = VT_I4;
        params.rgvarg[1].lVal = lExtraParam;
        VariantCopy(&params.rgvarg[0],pvar);
        params.cArgs  = 2;
    }

    // dilipk: removed THR since this fails many times
    hr = pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                            &params, NULL, NULL, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (lExtraParam != -1)
    {
        delete [] params.rgvarg;
    }
    return hr;
} // PutProperty

//+-----------------------------------------------------------------------
//
//  Member:    CallMethod
//
//  Overview:  Call the method on the given dispatch
//
//  Arguments: The method name, the return value, arguments
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
CallMethod(IDispatch *pidisp, LPCWSTR wzMethodNameIn, VARIANT *pvarResult, VARIANT *pvarArgument1)
{
    HRESULT     hr;
    DISPID      dispid          = NULL;
    LPWSTR      wzMethodName    = const_cast<LPWSTR>(wzMethodNameIn);
    DISPPARAMS  params          = {pvarArgument1, NULL, 0, 0};

    Assert(NULL != pidisp);
    Assert(NULL != wzMethodName);

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    hr = pidisp->GetIDsOfNames(IID_NULL, &wzMethodName,
                               1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD,
                        &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
} // CallMethod

//+-----------------------------------------------------------------------
//
//  Member:    GetDispidAndParameter
//
//  Overview:  Return the dispid and the paramater if the is one..
//
//  Arguments:
//
//  Returns:   lParam and the dispid if it can..
//
//------------------------------------------------------------------------
DISPID
GetDispidAndParameter(IDispatch *pidisp, LPCWSTR wzAtributeNameIn, long *lParam)
{
    USES_CONVERSION; //lint !e522
    HRESULT  hr;
    DISPID   dispid = NULL;
    int      i;
    LPWSTR   wzTemp;

    wzTemp = new WCHAR[INTERNET_MAX_URL_LENGTH];
    if (NULL == wzTemp)
    {
        goto done;
    }

    ZeroMemory(wzTemp, sizeof(WCHAR) * INTERNET_MAX_URL_LENGTH);

    i = StrCSpnIW(wzAtributeNameIn,L"(");
    if (i == wcslen(wzAtributeNameIn))
    {
        goto done;
    }

    if (i+1 >= INTERNET_MAX_URL_LENGTH)
    {
        // Prevent buffer overrun
        goto done;
    }

    StrCpyNW(wzTemp, wzAtributeNameIn, i+1);

    hr = pidisp->GetIDsOfNames(IID_NULL, &wzTemp, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        dispid = NULL;
        goto done;
    }

    hr = StringCchCopy(wzTemp, INTERNET_MAX_URL_LENGTH, wzAtributeNameIn+i+1);
    if(FAILED(hr))
    {
        dispid = NULL;
        goto done;
    }
    *lParam = (long) _ttoi(OLE2T(wzTemp));

done:
    if (wzTemp)
    {
        delete [] wzTemp;
    }
    return dispid;
} //lint !e550

//+-----------------------------------------------------------------------
//
//  Function:  IsPalettizedDisplay
//
//  Overview:  Determines if primary display is 8 bits per pixel or less
//
//  Arguments: void
//
//  Returns:   true if display is <= 8bpp
//             false if display is > 8bpp
//
//------------------------------------------------------------------------
bool IsPalettizedDisplay()
{
    HDC hdcPrimary = NULL;
    int iBppPrimary = 0;

    hdcPrimary = GetDC(NULL);
    Assert(NULL != hdcPrimary);
    if (hdcPrimary)
    {
        iBppPrimary = GetDeviceCaps(hdcPrimary, BITSPIXEL);
        ReleaseDC(NULL, hdcPrimary);

        if (8 >= iBppPrimary)
        {
            return true;
        }
    }
    return false;
}


////////////////////////////////////////////////////////////////////////////////
//Determines if captions need to be shown
////////////////////////////////////////////////////////////////////////////////
bool GetSystemCaption()
{
    BOOL bUseCaptions = false;

    //GetSystemMetrics(SM_SHOWSOUNDS);  This call is unreliable.
    SystemParametersInfo(SPI_GETSHOWSOUNDS, 0, (void*)(&bUseCaptions), 0);

    return ((bUseCaptions == 0) ? false : true);
}

//if system caption is set don't use overdub, use subtitle
bool GetSystemOverDub()
{
    bool bOverdub = false;

    bOverdub = !GetSystemCaption();

    return bOverdub;
}

//if system caption is set don't use overdub, use subtitle
LPWSTR GetSystemConnectionType()
{
    LPWSTR szConnect = NULL;
    BOOL bReturn = FALSE;
    DWORD dwFlags = 0;

    bReturn = InternetGetConnectedStateEx(&dwFlags, NULL, 0, 0);
    if (!bReturn || dwFlags & INTERNET_CONNECTION_OFFLINE)
    {
        szConnect = CopyString(WZ_NONE);
    }
    else if (dwFlags & INTERNET_CONNECTION_MODEM)
    {
        szConnect = CopyString(WZ_MODEM);
    }
    else if (dwFlags & INTERNET_CONNECTION_LAN)
    {
        szConnect = CopyString(WZ_LAN);
    }

    return szConnect;
}

////////////////////////////////////////////////////////////////////////////////
//gets the language code for the system that is currently running.
////////////////////////////////////////////////////////////////////////////////
LPWSTR GetSystemLanguage(IHTMLElement *pEle)
{
    HRESULT hr = E_FAIL;
    CComPtr <IDispatch> pDocDisp;
    CComPtr <IHTMLDocument2> pDoc2;
    CComPtr <IHTMLWindow2> pWindow2;
    CComPtr <IOmNavigator> pNav;
    BSTR bstrUserLanguage = NULL;
    LPWSTR lpszUserLanguage = NULL;

    //get the system language.
    hr = pEle->get_document(&pDocDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDoc2->get_parentWindow(&pWindow2);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pWindow2->get_clientInformation(&pNav);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pNav->get_userLanguage(&bstrUserLanguage);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:

    if (SUCCEEDED(hr))
    {
        lpszUserLanguage = CopyString(bstrUserLanguage);
    }
    if (bstrUserLanguage)
    {
        SysFreeString(bstrUserLanguage);
    }

    return lpszUserLanguage;

}

bool
IsElementNameThis(IHTMLElement * pElement, LPWSTR pszName)
{
    HRESULT hr = S_OK;

    CComBSTR sBSTR;
    bool bRet = false;

    if (NULL == pElement || NULL == pszName)
    {
        goto done;
    }

    hr = pElement->get_tagName(&sBSTR);
    if (FAILED(hr))
    {
        goto done;
    }

    if (sBSTR != NULL &&
        0 == StrCmpIW(sBSTR, pszName))
    {
        bRet = true;
    }

done:
    return bRet;
}

bool
IsElementPriorityClass(IHTMLElement * pElement)
{
    return IsElementNameThis(pElement, WZ_PRIORITYCLASS_NAME);
}
bool
IsElementTransition(IHTMLElement * pElement)
{
    return IsElementNameThis(pElement, WZ_TRANSITION_NAME);
}

bool IsVMLObject(IDispatch *pidisp)
{
    CComVariant pVar;
    HRESULT hr;

    hr = GetProperty (pidisp, L"tagurn", &pVar);
    if (FAILED(hr))
    {
        return false;
    }

    if (pVar.vt == VT_BSTR &&
        pVar.bstrVal != NULL)
    {
        if (0 == StrCmpIW(WZ_VML_URN, pVar.bstrVal))
        {
            return true;
        }
    }
    return false;
}


//+-----------------------------------------------------------------------
//
//  Multi-thread lock for STL
//
//------------------------------------------------------------------------


std::_Lockit::_Lockit()
{
    if (g_STLCS)
    {
        g_STLCS->Grab();
    }
}


std::_Lockit::~_Lockit()
{
    if (g_STLCS)
    {
        g_STLCS->Release();
    }
}

HRESULT
GetReadyState(IHTMLElement * pElm,
              BSTR * pbstrReadyState)
{
    HRESULT hr;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IDispatch> pDocDisp;

    Assert(pbstrReadyState);
    Assert(pElm);

    *pbstrReadyState = NULL;

    hr = THR(pElm->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_readyState(pbstrReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

typedef HRESULT (WINAPI *FAULTINIEFEATUREPROC)( HWND hWnd,
                                                uCLSSPEC *pClassSpec,
                                                QUERYCONTEXT *pQuery,
                                                DWORD dwFlags);
static const TCHAR URLMON_DLL[] = _T("URLMON.DLL");
static const char FAULTINIEFEATURE[] = "FaultInIEFeature";

HRESULT
CreateObject(REFCLSID clsid,
             REFIID iid,
             void ** ppObj)
{
    HRESULT hr;
    HINSTANCE hinstURLMON = NULL;

    hinstURLMON = LoadLibrary(URLMON_DLL);
    if (NULL != hinstURLMON)
    {
        FAULTINIEFEATUREPROC            faultInIEFeature;
        faultInIEFeature = (FAULTINIEFEATUREPROC) ::GetProcAddress(hinstURLMON, FAULTINIEFEATURE);

        if (NULL != faultInIEFeature)
        {
            uCLSSPEC classpec;

            // setup the classpec
            classpec.tyspec = TYSPEC_CLSID;
            classpec.tagged_union.clsid = clsid;

            IGNORE_HR((*faultInIEFeature)(NULL, &classpec, NULL, NULL)); //lint !e522
        }

        FreeLibrary(hinstURLMON);
        hinstURLMON = NULL;
    }

    // Create given a clsid
    hr = THR(CoCreateInstance(clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              iid,
                              ppObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HWND
GetDocumentHwnd(IHTMLDocument2 * pDoc)
{
    HRESULT hr;
    HWND hwnd = NULL;
    CComPtr<IOleWindow> spOleWindow;

    if (pDoc == NULL)
    {
        goto done;
    }

    hr = THR(pDoc->QueryInterface(IID_TO_PPV(IOleWindow, &spOleWindow)));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spOleWindow->GetWindow(&hwnd));
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hwnd;
}


HRESULT GetHTMLAttribute(IHTMLElement * pElement, const WCHAR * cpwchAttribute, VARIANT * pVar)
{
    HRESULT hr = S_OK;

    BSTR bstrAttribute = NULL;

    if (NULL == pVar || NULL == pElement || NULL == cpwchAttribute)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bstrAttribute = SysAllocString(cpwchAttribute);
    if (bstrAttribute == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = pElement->getAttribute(bstrAttribute, 0, pVar);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    SysFreeString(bstrAttribute);
    RRETURN( hr );
}

// get document.all.pwzID
HRESULT
FindHTMLElement(LPWSTR pwzID, IHTMLElement * pAnyElement, IHTMLElement ** ppElement)
{
    HRESULT hr = S_OK;

    Assert(pwzID);
    Assert(ppElement);

    CComPtr<IDispatch> spDocDispatch;
    CComPtr<IHTMLDocument2> spDocument2;
    CComPtr<IHTMLElementCollection> spCollection;
    CComPtr<IDispatch> spElementDispatch;

    CComVariant varName(pwzID);
    CComVariant varIndex(0);

    if (NULL == pAnyElement)
    {
        hr = THR(E_INVALIDARG);
        goto done;
    }

    hr = THR(pAnyElement->get_document(&spDocDispatch));
    if (FAILED(hr) || spDocDispatch == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = THR(spDocDispatch->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDocument2)));
    if (FAILED(hr) || spDocument2 == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spDocument2->get_all(&spCollection));
    if (FAILED(hr) || spCollection == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spCollection->item(varName, varIndex, &spElementDispatch));
    if (FAILED(hr) || spElementDispatch == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spElementDispatch->QueryInterface(IID_TO_PPV(IHTMLElement, ppElement)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Function:  SetVisibility
//
//  Overview:  set the visibility on the html element to bVis
//
//  Arguments: bVis - wheter or not to set visibility on / off
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
SetVisibility(IHTMLElement * pElement, bool bVis)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> spElement2;
    CComPtr<IHTMLStyle> spRuntimeStyle;
    CComBSTR bstrVis;

    if (NULL == pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spElement2->get_runtimeStyle(&spRuntimeStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (bVis)
    {
        bstrVis = WZ_VISIBLE;
    }
    else
    {
        bstrVis = WZ_HIDDEN;
    }

    hr = THR(spRuntimeStyle->put_visibility(bstrVis));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


HRESULT WalkUpTree(IHTMLElement *pFirst,
    long &lscrollOffsetyc, long &lscrollOffsetxc,
    long &lPixelPosTopc, long &lPixelPosLeftc)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement> pElemp;
    long lscrollOffsetx, lscrollOffsety, lPixelPosTop, lPixelPosLeft;
    long lclientx = 0, lclienty = 0;

    for( pElemp = pFirst;
        SUCCEEDED(hr) && (pElemp != NULL);
        hr = pElem->get_offsetParent(&pElemp))
    {
        pElem.Release();
        pElem = pElemp;
        hr = THR(pElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (FAILED(hr))
        {
            break;
        }
        hr = pElem2->get_scrollTop(&lscrollOffsety);
        if (FAILED(hr))
        {
            break;
        }
        lscrollOffsetyc += lscrollOffsety;

        hr = pElem2->get_scrollLeft(&lscrollOffsetx);
        if (FAILED(hr))
        {
            break;
        }
        lscrollOffsetxc += lscrollOffsetx;

        hr = pElem->get_offsetTop(&lPixelPosTop);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosTopc += lPixelPosTop;

        hr = pElem->get_offsetLeft(&lPixelPosLeft);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosLeftc += lPixelPosLeft;

        hr = pElem2->get_clientLeft(&lclientx);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosLeftc += lclientx;

        hr = pElem2->get_clientTop(&lclienty);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosTopc += lclienty;

        pElem2.Release();
        pElemp.Release();
    }
    return hr;
}

void GetRelativeVideoClipBox(RECT &localRect, RECT &elementSize, RECT &videoRect, long lscaleFactor)
{
    LONG lscreenWidth = GetSystemMetrics(SM_CXSCREEN);
    LONG lscreenHeight = GetSystemMetrics(SM_CYSCREEN);

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = lscaleFactor;
    videoRect.bottom = lscaleFactor;

    if(localRect.left < 0)
    {
        videoRect.left = ( -localRect.left / (double )elementSize.right) * lscaleFactor; //lint !e524
        localRect.left = 0;
    }
    if(localRect.right > lscreenWidth)
    {
        videoRect.right = lscaleFactor - ( (localRect.right - lscreenWidth) / (double )elementSize.right) * lscaleFactor; //lint !e524
        localRect.right = lscreenWidth;
    }
    if(localRect.top < 0)
    {
        videoRect.top = ( -localRect.top / (double )elementSize.bottom) * lscaleFactor; //lint !e524
        localRect.top = 0;
    }
    if(localRect.bottom > lscreenHeight)
    {
        videoRect.bottom = lscaleFactor - ( (localRect.bottom - lscreenHeight) / (double )elementSize.bottom) * lscaleFactor; //lint !e524
        localRect.bottom = lscreenHeight;
    }
}

//
// Returns true if this is Win95 or 98
//

bool TIMEIsWin9x(void)
{
    return (0 != (GetVersion() & 0x80000000));
}

//
// Returns true if this is Win95
//
bool TIMEIsWin95(void)
{
    static bool bHasOSVersion = false;
    static bool bIsWin95 = false;

    if (bHasOSVersion)
    {
        return bIsWin95;
    }

    OSVERSIONINFOA osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOA));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA(&osvi);

    bIsWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId) &&
               (4 == osvi.dwMajorVersion) &&
               (0 == osvi.dwMinorVersion);

    bHasOSVersion = true;

    return bIsWin95;
}

//
// Property change notification helper
//

HRESULT
NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid)
{
    HRESULT hr = E_FAIL;
    CComPtr<IEnumConnections> pEnum;

    CHECK_RETURN_NULL(pICP);

    // #14222, ie6
    // dilipk: there are too many copies of this code lying around.
    //                 all objects should use this helper function.
    //

    hr = pICP->EnumConnections(&pEnum);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
        goto done;
    }

    CONNECTDATA cdata;

    hr = pEnum->Next(1, &cdata, NULL);
    while (hr == S_OK)
    {
        // check cdata for the object we need
        IPropertyNotifySink *pNotify;

        hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
            TIMESetLastError(hr);
            goto done;
        }

        hr = pNotify->OnChanged(dispid);
        ReleaseInterface(pNotify);
        if (FAILED(hr))
        {
            TIMESetLastError(hr);
            goto done;
        }

        // and get the next enumeration
        hr = pEnum->Next(1, &cdata, NULL);
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


double
Round(double inValue)
{
    double cV,fV;

    cV = ceil(inValue);
    fV = floor(inValue);

    if (fabs(inValue - cV) <  fabs(inValue - fV))
    {
        return cV;
    }

    return fV;
}

double
InterpolateValues(double dblNum1,
                double dblNum2,
                double dblProgress)
{
    return (dblNum1 + ((dblNum2 - dblNum1) * dblProgress));
}


HRESULT
GetSystemBitrate(long *lpBitrate)
{
    RASCONN RasCon;
    RAS_STATS Statistics;
    DWORD dwConCount = 0;
    DWORD lSize = sizeof(RASCONN);
    long lRet = 0;
    HRESULT hr = S_OK;
    LPWSTR lpszConnectType = NULL;

    HINSTANCE histRASAPI32 = NULL;
    RASGETCONNECTIONSTATISTICSPROC RasGetConnectStatsProc = NULL;
    RASENUMCONNECTIONSPROC RasEnumConnectionsProc = NULL;
    const TCHAR RASAPI32_DLL[] = _T("RASAPI32.DLL");
    const char RASGETCONNECTIONSTATISTICS[] = "RasGetConnectionStatistics";
    const char RASENUMCONNECTIONS[] = "RasEnumConnectionsW";

    if (lpBitrate == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(g_hrConnectResult))
    {
        hr = g_hrConnectResult;
        goto done;
    }

    if (g_lConnectSpeed != -1)
    {
        hr = S_OK;
        goto done;
    }


    //Check for systemBitrate in Win9x
    lpszConnectType = GetSystemConnectionType();
    if (lpszConnectType && StrCmpIW(lpszConnectType, WZ_MODEM) == 0)
    {
        long lTemp = 0;
        //need to check that this is a modem before checking the registry
        hr = CheckRegistryBitrate(&lTemp);
        if (SUCCEEDED(hr))
        {
            g_lConnectSpeed = lTemp;
            goto done;
        }
    }

    hr = S_OK;
    //check for system bitrate on Win2k
    histRASAPI32 = LoadLibrary(RASAPI32_DLL);
    if (NULL == histRASAPI32)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    RasGetConnectStatsProc = (RASGETCONNECTIONSTATISTICSPROC)GetProcAddress(histRASAPI32, RASGETCONNECTIONSTATISTICS);
    RasEnumConnectionsProc = (RASENUMCONNECTIONSPROC)GetProcAddress(histRASAPI32, RASENUMCONNECTIONS);

    if (RasGetConnectStatsProc == NULL || RasEnumConnectionsProc == NULL)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    RasCon.dwSize = lSize;
    Statistics.dwSize = sizeof(RAS_STATS);

    lRet = RasEnumConnectionsProc(&RasCon, &lSize, &dwConCount);

    if (dwConCount == 0)
    {
        hr = S_OK;
        g_lConnectSpeed = 0;
        goto done;
    }
    if (lRet != 0)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    lRet = RasGetConnectStatsProc(RasCon.hrasconn, &Statistics);
    if (lRet != 0)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    g_lConnectSpeed = Statistics.dwBps;
    hr = S_OK;

  done:

    if (histRASAPI32 != NULL)
    {
        FreeLibrary(histRASAPI32);
        histRASAPI32 = NULL;
    }
    if (SUCCEEDED(hr))
    {
        *lpBitrate = g_lConnectSpeed;
    }

    g_hrConnectResult = hr;

    return hr;
}

HRESULT CheckRegistryBitrate(long *pBitrate)
{
    LONG lRet = 0;
    HKEY hKeyRoot = NULL;
    HRESULT hr = S_OK;
    DWORD dwSize = MAX_REG_VALUE_LENGTH;
    DWORD dwType = 0;
    BYTE bDataBuf[MAX_REG_VALUE_LENGTH];

    if (pBitrate == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    lRet = RegOpenKeyEx(HKEY_DYN_DATA, _T("PerfStats\\StatData"), 0, KEY_READ, &hKeyRoot);
    if (ERROR_SUCCESS != lRet)
    {
        hr = E_FAIL;
        goto done;
    }

    Assert(NULL != hKeyRoot);

    lRet = RegQueryValueEx(hKeyRoot, _T("Dial-up Adapter\\ConnectSpeed"), 0, &dwType, bDataBuf, &dwSize);
    if (ERROR_SUCCESS != lRet)
    {
        hr = E_FAIL;
        goto done;
    }

    if (REG_BINARY == dwType)
	{
		*pBitrate = (long)(*(DWORD*)bDataBuf);
	}
    else if (REG_DWORD == dwType)
    {
        *pBitrate = (long)(*(DWORD*)bDataBuf);
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

done:

    RegCloseKey(hKeyRoot);
    return hr;
}


HRESULT
SinkHTMLEvents(IUnknown * pSink,
               IHTMLElement * pEle,
               IConnectionPoint ** ppDocConPt,
               DWORD * pdwDocumentEventConPtCookie,
               IConnectionPoint ** ppWndConPt,
               DWORD * pdwWindowEventConPtCookie)
{
    CComPtr<IConnectionPointContainer> spWndCPC;
    CComPtr<IConnectionPointContainer> spDocCPC;
    CComPtr<IHTMLDocument> spDoc;
    CComPtr<IDispatch> spDocDispatch;
    CComPtr<IDispatch> spScriptDispatch;
    CComPtr<IConnectionPoint> spDocConPt;
    CComPtr<IConnectionPoint> spWndConPt;
    DWORD dwDocumentEventConPtCookie = 0;
    DWORD dwWindowEventConPtCookie = 0;

    HRESULT hr;

    if (NULL == pSink || NULL == pEle ||
        NULL == ppDocConPt || NULL == pdwDocumentEventConPtCookie ||
        NULL == ppWndConPt || NULL == pdwWindowEventConPtCookie)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(pEle->get_document(&spDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(spDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&spDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(spDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &spDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }


    hr = THR(spDocConPt->Advise(pSink, &dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(spDoc->get_Script (&spScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&spWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &spWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spWndConPt->Advise(pSink, &dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (spDocConPt)
        {
            if (dwDocumentEventConPtCookie != 0)
            {
                IGNORE_HR(spDocConPt->Unadvise(dwDocumentEventConPtCookie));
            }
            spDocConPt.Release();
        }
        if (spWndConPt)
        {
            if (dwWindowEventConPtCookie != 0)
            {
                IGNORE_HR(spWndConPt->Unadvise(dwWindowEventConPtCookie));
            }
            spWndConPt.Release();
        }
        dwWindowEventConPtCookie = 0;
        dwDocumentEventConPtCookie = 0;
    }
    else
    {
        *ppDocConPt = spDocConPt;
        (*ppDocConPt)->AddRef();
        *pdwDocumentEventConPtCookie = dwDocumentEventConPtCookie;

        *ppWndConPt = spWndConPt;
        (*ppWndConPt)->AddRef();
        *pdwWindowEventConPtCookie = dwWindowEventConPtCookie;
    }

    RRETURN(hr);
}


bool
IsValidtvList(TimeValueList *tvlist)
{
    TimeValueSTLList & l = tvlist->GetList();
    bool bIsValid = false;
    for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
    {
        TimeValue *p = (*iter);
        if ((p->GetEvent() != NULL)                            ||
            (p->GetEvent() == NULL && p->GetElement() == NULL) ||
            (StrCmpIW(p->GetEvent(), WZ_INDEFINITE) == 0))
        {
            bIsValid = true;
        }
    }

    return bIsValid;

}

static const IID SID_SMediaBarSync = { 0x2efc8085, 0x066b, 0x4823, { 0x9d, 0xb4, 0xd1, 0xe7, 0x69, 0x16, 0xda, 0xa0 } };

HRESULT GetSyncBaseBody(IHTMLElement * pHTMLElem, ITIMEBodyElement ** ppBodyElem)
{
    HRESULT hr = S_OK;
    CComPtr<IDispatch> spDispDoc;
    CComPtr<IServiceProvider> spServiceProvider;
    CComPtr<IServiceProvider> spServiceProviderOC;
    CComPtr<IOleCommandTarget> spOCT;
    CComVariant svarBodyElem;


    if (!pHTMLElem || !ppBodyElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = pHTMLElem->get_document(&spDispDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDispDoc->QueryInterface(IID_TO_PPV(IServiceProvider, &spServiceProvider));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SWebBrowserApp, IID_TO_PPV(IServiceProvider, &spServiceProviderOC));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProviderOC->QueryService(SID_SMediaBarSync, IID_TO_PPV(IOleCommandTarget, &spOCT));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spOCT->Exec(0, 0, 0, &svarBodyElem, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = svarBodyElem.ChangeType(VT_UNKNOWN);
    if (FAILED(hr))
    {
        goto done;
    }
    if (svarBodyElem.punkVal && ppBodyElem)
    {
        hr = (svarBodyElem.punkVal)->QueryInterface(IID_TO_PPV(ITIMEBodyElement, ppBodyElem));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
ConvertToPixelsHELPER(LPOLESTR szString, LPOLESTR szKey, double dFactor, float fPixelFactor, double *outVal)
{
    HRESULT hr = S_OK;
    bool bReturn = false;
    LPOLESTR szTemp = NULL;
    OLECHAR  szTemp2[INTERNET_MAX_URL_LENGTH];
   
    // do init
    ZeroMemory(szTemp2,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);

    // do the compare
    szTemp = StrStr(szString,szKey);
    if (NULL != szTemp)
    {
        if (INTERNET_MAX_URL_LENGTH > (lstrlenW(szString) + 2))
        {
            CComVariant varTemp;
            StrCpyNW(szTemp2,szString,wcslen(szString) - wcslen(szTemp)+1);
            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString(szTemp2);
            hr = ::VariantChangeTypeEx(&varTemp,&varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
            if (SUCCEEDED(hr))
            {
                *outVal = V_R8(&varTemp); 
                *outVal /= dFactor;    // convert to inches.
                *outVal *= fPixelFactor;
                bReturn = true;
            }
            varTemp.Clear();
        }
        else
        {
            bReturn = false;
        }
    }

    szTemp = NULL;
    
done :
    return bReturn;
}

UINT
TIMEGetUrlScheme(const TCHAR * pchUrlIn)
{
    PARSEDURL      puw = {0};

    if (!pchUrlIn)
        return (UINT)URL_SCHEME_INVALID;

    puw.cbSize = sizeof(PARSEDURL);

    return (SUCCEEDED(ParseURL(pchUrlIn, &puw))) ?
                puw.nScheme : URL_SCHEME_INVALID;
}


HRESULT
TIMECombineURL(LPCTSTR base, LPCTSTR src, LPOLESTR * ppOut)
{
    Assert(ppOut);

    OLECHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD len = INTERNET_MAX_URL_LENGTH;
    LPOLESTR szPath = NULL;
    HRESULT hr = S_OK;

    *ppOut = NULL;

    if (NULL == src)
    {
        goto done;
    }

    if ((NULL != base) && (TIMEGetUrlScheme(base) != URL_SCHEME_FILE)
        && !PathFileExists(src) && (TIMEGetUrlScheme(src) != URL_SCHEME_FILE) && (0 != StrCmpNIW(L"\\\\", base, 2)))
    {
        hr = ::CoInternetCombineUrl(base,
                                    src,
                                    URL_DONT_ESCAPE_EXTRA_INFO | URL_ESCAPE_SPACES_ONLY,
                                    szUrl,
                                    INTERNET_MAX_URL_LENGTH,
                                    &len,
                                    0);
        if (FAILED(hr))
        {
            // could have failed for any reason - just default to copying source
            szPath = ::CopyString(src);
        }
        szPath = ::CopyString(szUrl);
    }
    else if (TRUE == InternetCombineUrlW (base, src, szUrl, &len, ICU_NO_ENCODE | ICU_DECODE))
    {
        szPath = ::CopyString(szUrl);
    }
    else
    {
        // InternetCombineUrlW failed - just copy the source
        szPath = ::CopyString(src);
    }

    if (NULL == szPath)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppOut = szPath;
    szPath = NULL;

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
TIMEFindMimeFromData(LPBC pBC,
                     LPCWSTR pwzUrl,
                     LPVOID pBuffer,
                     DWORD cbSize,
                     LPCWSTR pwzMimeProposed,
                     DWORD dwMimeFlags,
                     LPWSTR *ppwzMimeOut,
                     DWORD dwReserved)
{
    int cBytes;  // num CHARS plus NULL char times two for UNICODE

    if (NULL != pwzUrl)
    {
        if (IsASXSrc(pwzUrl, NULL, NULL) ||
            IsLSXSrc(pwzUrl, NULL, NULL) ||
            IsWMXSrc(pwzUrl, NULL, NULL))
        {
            if (ppwzMimeOut)
            {
                cBytes = 2 * (lstrlenW(ASXMIME) + 1);  // num CHARS plus NULL char times two for UNICODE
                *ppwzMimeOut = (LPWSTR)::CoTaskMemAlloc(cBytes);
                if (NULL == *ppwzMimeOut)
                {
                    return E_OUTOFMEMORY;
                }

                memcpy(*ppwzMimeOut, ASXMIME, cBytes);
                return S_OK;
            }
        }
        else if (IsWMFSrc(pwzUrl, NULL, NULL))
        {
            cBytes = 2 * (lstrlenW(L"image/wmf") + 1);  // num CHARS plus NULL char times two for UNICODE
            *ppwzMimeOut = (LPWSTR)::CoTaskMemAlloc(cBytes);
            if (NULL == *ppwzMimeOut)
            {
                return E_OUTOFMEMORY;
            }

            memcpy(*ppwzMimeOut, L"image/wmf", cBytes);
            return S_OK;
        }
    }

    return FindMimeFromData(pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\debug.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DEBUG.H - Debugging header
//

#ifndef _DEBUG_H_
#define _DEBUG_H_

// structures
typedef struct {
    LPBYTE lpAddr;      // Address
    DWORD  dwColor;     // Color to use
    LPSTR  lpszComment; // Comment to show
} DUMPTABLE, *LPDUMPTABLE;

#pragma warning(disable:4200)
typedef struct {
    DWORD dwCount;
    struct {
        DWORD dwCode;
        LPSTR lpDesc;
    } ids[];
} CODETOSTR, *LPCODETOSTR;
#pragma warning(default:4200)

// globals
extern const char g_szTrue[];
extern const char g_szFalse[];
extern CODETOSTR HRtoStr;
extern CODETOSTR HSEtoStr;
extern CODETOSTR ErrtoStr;

// macros
#define BOOLTOSTRING( _f ) ( _f ? g_szTrue : g_szFalse )

// constants
// Maximum number of dump table entries
#define MAX_DT  400

// debug flags
#define TF_ALWAYS   0xFFFFffff
#define TF_FUNC     0x80000000  // Trace with function calls
#define TF_DLL      0x00000001  // DLL entry points
#define TF_RESPONSE 0x00000002  // Responses
#define TF_READDATA 0x00000004  // Data reading functions
#define TF_PARSE    0x00000008  // Parsing
#define TF_SERVER   0x00000010  // Call to server callbacks
#define TF_LEX      0x00000020  // Lex 

#ifdef DEBUG

// Globals
extern DWORD g_dwTraceFlag;

// macros
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg;
#define Assert(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && AssertMsg(0, szFile, __LINE__, TEXT(#f) )) \
            DEBUG_BREAK;       \
    }

// functions
BOOL CDECL AssertMsg(
    BOOL fShouldBeTrue,
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszStatement );

void CDECL TraceMsg( 
    DWORD mask, 
    LPCSTR pszMsg, 
    ... );
void CDECL TraceMsgResult( 
    DWORD mask, 
    LPCODETOSTR lpCodeToStr,
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );


#else // DEBUG

#define DEBUG_BREAK
#define AssertMsg           1 ? (void)0 : (void)
#define TraceMsg            1 ? (void)0 : (void)
#define TraceMsgResult      1 ? (void)0 : (void)

#endif // DEBUG

// HTML output debugging messages
void CDECL DebugMsg( 
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... );
void CDECL DebugMsgResult( 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr,
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );
//
// These are for users of BOTH RETAIL and DEBUG. They only echo to the
// logfile and to the debug output (if process attached to IIS).
//
void CDECL LogMsgResult( 
    LPSTR lpszLog, 
    LPSTR lpStr,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );
void CDECL LogMsg( 
    LPSTR lpszLog,
    LPSTR lpStr, 
    LPCSTR pszMsg, 
    ... );

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\pch.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// PCH.H - Precompile header
//

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>
#include <windowsx.h>
#include <httpext.h>
#include <shlwapi.h>
#include <wininet.h>
#include "debug.h"
#include "reflectr.h"
#include "base.h"
#include "response.h"
#include "readdata.h"
#include "multpars.h"
#include "textpars.h"

#define FILEUPLD_VERSION_MAJOR  1
#define FILEUPLD_VERSION_MINOR  0
#define FILEUPLD_DESCRIPTION    "Form Submission Reflecter"
#define FILEUPLD_FILTER_FLAGS   SF_NOTIFY_READ_RAW_DATA | SF_NOTIFY_ORDER_DEFAULT

// Macros
#define ARRAYOF( _a )  ( sizeof( _a ) / sizeof( _a[0] ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\debug.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DEBUG.CPP - Debugging code
//

#include "pch.h"

// local globals
static const char s_szNewline[] = "\n";

// globals
const char g_szTrue[]  = "True";
const char g_szFalse[] = "False";

// local structures
CODETOSTR HRtoStr = {
    2,
    {
        { S_OK,                 "S_OK or NOERROR"               },
        { S_FALSE,              "S_FALSE"                       }
    }
};

CODETOSTR HSEtoStr = {
    5,
    {
        { HSE_STATUS_SUCCESS,           "HSE_STATUS_SUCCESS" },
        { ERROR_INVALID_INDEX,          "ERROR_INVALID_INDEX" },
        { ERROR_INSUFFICIENT_BUFFER,    "ERROR_INSUFFICIENT_BUFFER" },
        { ERROR_MORE_DATA,              "ERROR_MORE_DATA" },
        { ERROR_NO_DATA,                "ERROR_NO_DATA" }
    }
};

CODETOSTR ErrtoStr = {
    4,
    {
        { ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER" },
        { HSE_STATUS_SUCCESS_AND_KEEP_CONN, "HSE_STATUS_SUCCESS_AND_KEEP_CONN" },
        { HSE_STATUS_PENDING, "HSE_STATUS_PENDING" },
        { HSE_STATUS_ERROR,   "HSE_STATUS_ERROR" }
    }
};


// local functions
const char *FindResult( 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult );



#ifdef DEBUG    /***********************************************************/

// globals
DWORD   g_dwTraceFlag = // flag used to turn on/off certain debug msgs.
    // 0x00000000;
    TF_PARSE | TF_FUNC;
    // TF_ALWAYS;


//
// What:    IsTraceFlagSet
//
// Desc:    Tests to see is any of the flags in dwFlag
//          are set in g_dwTraceFlag.
// 
// In:      dwFlag are the flags to be tested.
//
// Return:  TRUE if flag is set or if dwFlags == TF_ALWAYS.
//          Otherwise, we return FALSE.
//
BOOL CDECL IsTraceFlagSet( DWORD dwFlag )
{
    return ( 
        ( (dwFlag & g_dwTraceFlag) == dwFlag ) ? 
        TRUE : 
        ( ( dwFlag == TF_ALWAYS ) ? 
            TRUE : 
            FALSE )
    );
}

//
// What:    AssertMsg
//
// Desc:    Debugging output with stop condition.
//
BOOL CDECL AssertMsg(
    BOOL fShouldBeTrue,
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszStatement )
{
    if ( !fShouldBeTrue )
    {
        CHAR ach[ 1024 + 40 ];    // Largest path plus extra
        
        wsprintf( ach, "Assert: %s (%u): %s",
            pszFile, dwLine, pszStatement );
        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }
    return !fShouldBeTrue;

} // AssertMsg( )

//
// What:    TraceMsg
//
// Desc:    Debugging output with conditional flags (see 
//          DEBUG.H for flags).
//
void CDECL TraceMsg( 
    DWORD dwFlag, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;

    if ( IsTraceFlagSet( dwFlag ) )
    {
        int cch;

        StrCpy( ach, "Trace: " );

        cch = lstrlen( ach );
        va_start( vArgs, pszMsg );
        wvsprintf( &ach[ cch ], pszMsg, vArgs );
        va_end( vArgs );

        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }

} // TraceMsg( )



// 
// What:    TraceMsgResult
//
// Desc:    Debugging output with conditional flags and
//          it displays the HRESULT in "English".
//
void CDECL TraceMsgResult( 
    DWORD dwFlag, 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;

    if ( IsTraceFlagSet( dwFlag ) )
    {
        int cch;

        StrCpy( ach, "Trace: " );

        cch = lstrlen( ach );
        va_start( vArgs, pszMsg );
        wvsprintf( &ach[ cch ], pszMsg, vArgs );
        va_end( vArgs );

        cch = lstrlen( ach );
        wsprintf( &ach[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }
} // TraceMsgResult( )



#endif // DEBUG     /********************************************************/



/*********************************************************

    These are for debugging the GET/POST as well as 
    debugging the parser.

*********************************************************/


//
// What:    DebugMsg
//
// Desc:    Debugging output
//
void CDECL DebugMsg( 
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;
    int cch;

    va_start( vArgs, pszMsg );
    wvsprintf( ach, pszMsg, vArgs );
    va_end( vArgs );

#ifdef DEBUG
    OutputDebugString( ach );
    OutputDebugString( s_szNewline );
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, ach );
    }

} // DebugMsg( )



// 
// What:    DebugMsgResult
//
// Desc:    Debugging output displaying the dwResult in "English".
//
void CDECL DebugMsgResult( 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;
    int cch;

    va_start( vArgs, pszMsg );
    wvsprintf( ach, pszMsg, vArgs );
    va_end( vArgs );

    cch = lstrlen( ach );
    wsprintf( &ach[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

#ifdef DEBUG
    OutputDebugString( ach );
    OutputDebugString( s_szNewline );
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, ach );
    }

} // DebugMsgResult( )


//
// What:    LogMsg
//
// Desc:    Append text to be written to server log.
//
void CDECL LogMsg( 
    LPSTR lpszLog,
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... )
{
    va_list vArgs;

    char szBuffer[ 1024 + 40 ];

    va_start( vArgs, pszMsg );
    wvsprintf( szBuffer, pszMsg, vArgs );
    va_end( vArgs );

#ifdef DEBUG
    if ( lstrlen( szBuffer ) >= HSE_LOG_BUFFER_LEN )
    {
        OutputDebugString( "Log overflow=" );
        OutputDebugString( szBuffer );
        OutputDebugString( s_szNewline );
    } 
    else 
    {
        StrCpy( lpszLog, szBuffer );
        OutputDebugString( "Log Message= " );
        OutputDebugString( lpszLog );
        OutputDebugString( s_szNewline );
    }
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, szBuffer );
        StrCat( lpszOut, s_szNewline );
    }

} // LogMsg( )

// 
// What:    LogMsgResult
//
// Desc:    Append text to be written to server log and appends an english
//              translation to the dwResult code.
//
void CDECL LogMsgResult( 
    LPSTR lpszLog, 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    va_list vArgs;

    int cch;
    char szBuffer[ 1024 + 40 ];

    va_start( vArgs, pszMsg );
    wvsprintf( szBuffer, pszMsg, vArgs );
    va_end( vArgs );

    cch = lstrlen( szBuffer );
    wsprintf( &szBuffer[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

#ifdef DEBUG
    if ( lstrlen( szBuffer ) >= HSE_LOG_BUFFER_LEN )
    {
        OutputDebugString( "Log overflow=" );
        OutputDebugString( szBuffer );
        OutputDebugString( s_szNewline );
    } 
    else 
    {
        StrCpy( lpszLog, szBuffer );
        OutputDebugString( "Log Message= " );
        OutputDebugString( lpszLog );
        OutputDebugString( s_szNewline );
    }
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, szBuffer );
        StrCat( lpszOut, s_szNewline );
    }
} // LogMsgResult( )

//
// What:    FindHResult
//
// Desc:    Searches for a string for a HRESULT. If not found
//          it will display the HEX value.
//
const char *FindResult( 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult )
{
    static char szResult[ 11 ];  // just enough for "0x00000000" + NULL

    for( DWORD i = 0 ; i < lpCodeToStr->dwCount ; i++ )
    {
        if ( lpCodeToStr->ids[ i ].dwCode == dwResult )
        {
            return lpCodeToStr->ids[ i ].lpDesc;
        }
    } // for i

    wsprintf( szResult, "%x", dwResult );

    return szResult;

} // FindHResult( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\dllmain.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DLLMAIN.CPP - DLL entry points
//

#include "pch.h"

// Globals
HANDLE g_hInst;

//
// What:    DllMain
//
// Desc:    Dll initialization entry point.
//
BOOL WINAPI DllMain (
    HANDLE hInst, 
    ULONG ulReason,
    LPVOID lpReserved )
{
    TraceMsg( TF_FUNC | TF_DLL, "DllMain( )" );

#if 0
    DebugBreak( );  // stop so we can get a chance to enable break points
#endif

    switch( ulReason ) 
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInst;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
    
} // DllMain( )

//
// What:    DllRegisterServer
//
// Desc:    Register our ISAPI with IIS
//
STDAPI DllRegisterServer( void )
{
    HRESULT hr = S_OK;

    TraceMsg( TF_FUNC | TF_DLL, "DllRegisterServer( )" );

    TraceMsgResult( TF_DLL, &HRtoStr, hr, "DllRegisterServer( ) Exit" );
    return hr;

} // DllRegisterServer( )

//
// What:    GetExtensionVersion
//
// Desc:    ISAPI entry point
//
BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO  *pVer )
{
    TraceMsg( TF_FUNC | TF_DLL, "GetExtensionVersion( pVer )" );

    pVer->dwExtensionVersion = MAKELONG( FILEUPLD_VERSION_MINOR,
                                         FILEUPLD_VERSION_MAJOR );
    StrCpyN( pVer->lpszExtensionDesc,
              FILEUPLD_DESCRIPTION,
              HSE_MAX_EXT_DLL_NAME_LEN );

    TraceMsg( TF_FUNC | TF_DLL, "GetExtensionVersion( pVer ) Exit BOOL=TRUE" );
    return TRUE;
} // GetExtensionVersion( )

//
// What:    HttpExtensionProc
//
// Desc:    ISAPI entry point
//
DWORD  HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK  lpEcb )
{
    DWORD  dwResult  = HSE_STATUS_SUCCESS;  // return status
    BOOL   fReturn;                         // status flag
    BOOL   fMultipart;                      // multipart/form-data submit?
    BOOL   fTextPlain;                      // text/plain submit?
    BOOL   fDebug;                          // show debug spew?
    LPSTR  lpszOut   = NULL;                // server log output
    LPSTR  lpszDebug = NULL;                // debug output
    LPBYTE lpbData;                         // pointer to body data
    DWORD  dwParsed;                        // number of bytes parsed

    DUMPTABLE   DT[ MAX_DT ];               // Hex Dump table info.
    QUERYMETHOD eMethod = METHOD_UNKNOWN;   // method of query

    CMultipartParse *lpMPParser = NULL;
    CTextPlainParse *lpTPParser = NULL;

    TraceMsg( TF_FUNC | TF_DLL, "HttpExtensionProc( lpEcb )" );

#if 0
    fReturn = SendEcho( lpEcb );
#endif

    // Make sure that we have all the data
    fReturn = CompleteDownload( lpEcb, &lpbData );

    // Check content-type for multipart
    if ( fReturn )
    {
        fReturn = CheckForMultiPartFormSubmit( lpEcb, &fMultipart );
    }

    if ( fReturn )
    {
        fReturn = CheckForTextPlainSubmit( lpEcb, &fTextPlain );
    }

    if ( fReturn )
    {
        fReturn = CheckForDebug( lpEcb, &fDebug );
    }

    // Parse
    if ( fReturn )
    {
        if ( fMultipart )
        {
            if ( fDebug )
            {
                lpMPParser = new CMultipartParse( lpEcb, &lpszOut, &lpszDebug, DT );
            }
            else
            {
                lpMPParser  = new CMultipartParse( lpEcb, &lpszOut, NULL, DT );
                lpszDebug = NULL;
            }

            fReturn = lpMPParser->PreParse( lpbData, &dwParsed );
            eMethod= METHOD_POSTMULTIPART;

        } 
        else if ( fTextPlain )
        {
            if ( ! fDebug )
            {
                lpTPParser = new CTextPlainParse( lpEcb, &lpszOut, &lpszDebug, DT );
            }
            else
            {
                lpTPParser  = new CTextPlainParse( lpEcb, &lpszOut, NULL, DT );
                lpszDebug = NULL;
            }

            fReturn = lpTPParser->Parse( lpbData, &dwParsed );
            eMethod= METHOD_POSTTEXTPLAIN;

        }
        else 
        {

            if ( !StrCmpI( lpEcb->lpszMethod, "POST" ) )
            {
                eMethod= METHOD_POST;
            }
            else if ( !StrCmpI( lpEcb->lpszMethod, "GET" ) )
            {
                eMethod= METHOD_GET;
            }
        }              
    }

    // Display results
    if ( fReturn )
    {
        fReturn = SendSuccess( eMethod, lpEcb, lpszOut, lpszDebug, lpbData, dwParsed, DT );
    }
    else
    {
        fReturn = SendFailure( eMethod, lpEcb, lpszOut, lpszDebug, lpbData, dwParsed, DT );
    }

    // Check to see if everything went OK
    if ( !fReturn )
    {
        dwResult = HSE_STATUS_ERROR;
    }

    // Free if we created the buffer
    if ( lpEcb->lpbData != lpbData ) 
    {
        GlobalFree( lpbData );
    }

    delete lpMPParser;
    delete lpTPParser;
    
    TraceMsgResult( TF_FUNC | TF_DLL, &HSEtoStr, dwResult, "HttpExtensionProc( lpEcb ) " );
    lpEcb->dwHttpStatusCode = dwResult;
    return dwResult;
} // HttpExtensionProc( )


//
// Support functions
//
void *  __cdecl operator new( unsigned int nSize )
{
    return ((LPVOID) LocalAlloc( LMEM_FIXED, nSize ));

}

void  __cdecl operator delete( void *pv )
{
    LocalFree( pv );
}

extern "C" int __cdecl _purecall( void ) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\readdata.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// readdata.H - Reading data helping utilities
//

#ifndef _READDATA_H_
#define _READDATA_H_

// Methods
BOOL ReadData( LPECB lpEcb, LPVOID lpMoreData, DWORD dwSize );
BOOL CompleteDownload( LPECB lpEcb, LPBYTE *lpbData );
BOOL GetServerVarString( LPECB lpEcb, LPSTR lpVarName, LPSTR *lppszBuffer, LPDWORD lpdwSize );
BOOL CheckForMultiPartFormSubmit( LPECB lpEcb, BOOL *lpfMultipart );
BOOL CheckForDebug( LPECB lpEcb, BOOL *lpfDebug );
BOOL CheckForTextPlainSubmit( LPECB lpEcb, BOOL *lpfTextPlain );

#endif // _READDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\multpars.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// MULTPARS.CPP - Parses incoming stream for files
//

#include "pch.h"

// Local globals
const char g_cszBoundaryKeyword[]    = "boundary=";             // don't include space
const DWORD g_cbBoundaryKeyword      = sizeof( g_cszBoundaryKeyword ) - 1;
const char g_cszCheck[]              = "check=";                // don't include space
const DWORD g_cbCheck                = sizeof( g_cszCheck ) - 1;
const char g_cszBoundaryIndicator[]  = "\r\n--";
const DWORD g_cbBoundaryIndicator    = sizeof( g_cszBoundaryIndicator ) - 1;

const char g_cszExtraBytes[]         = "Extra bytes";
const char g_cszBodyData[]           = "Body Data";

// 
// Parsing table
//
PARSETABLE g_LexTable[ ] = {
    // Parser search string,         Lexicon           ,Length, Color , Comment
    { (LPSTR)g_cszBoundaryIndicator, LEX_BOUNDARY        , 0, 0xFFFFFF, "Boundary String"   },
    { (LPSTR)g_cszBoundaryIndicator, LEX_EOT             , 0, 0xFFFFFF, "Ending Boundary"   },
    { (LPSTR)g_cszBoundaryIndicator +2, LEX_STARTBOUNDARY, 0, 0xFFFFFF, "Starting Boundary" },
    // must be after LEX_BOUNDARY
    { "\r\n",                        LEX_CRLF            , 0, 0x7F7F7F, NULL                },
    { "content-disposition:",        LEX_CONTENTDISP     , 0, 0x0000FF, "Header Field"      },
    { "content-type:",               LEX_CONTENTTYPE     , 0, 0x0000FF, "Header Field"      },
    { "name=",                       LEX_NAMEFIELD       , 0, 0x0000FF, "Field Param"       },
    { "filename=",                   LEX_FILENAMEFIELD   , 0, 0x0000FF, "Field Param"       },
    // MIME types
    { "multipart",                   LEX_MULTIPART       , 0, 0x003FFF, "MIME Type"         },
    { "text",                        LEX_TEXT            , 0, 0x003FFF, "MIME Type"         },
    { "application",                 LEX_APPLICATION     , 0, 0x003FFF, "MIME Type"         },
    { "audio",                       LEX_AUDIO           , 0, 0x003FFF, "MIME Type"         },
    { "image",                       LEX_IMAGE           , 0, 0x003FFF, "MIME Type"         },
    { "message",                     LEX_MESSAGE         , 0, 0x003FFF, "MIME Type"         },
    { "video",                       LEX_VIDEO           , 0, 0x003FFF, "MIME Type"         },
    { "x-",                          LEX_MIMEEXTENSION   , 0, 0x003FFF, "MIME Extension"    },
    { "iana-",                       LEX_MIMEEXTENSION   , 0, 0x003FFF, "MIME Extension"    },
    // MIME subtypes
    { "form-data",                   LEX_FORMDATA        , 0, 0x003FFF, "MIME Subtype"      },
    { "attachment",                  LEX_ATTACHMENT      , 0, 0x003FFF, "MIME Subtype"      },
    { "mixed",                       LEX_MIXED           , 0, 0x003FFF, "MIME Subtype"      },
    { "plain",                       LEX_PLAIN           , 0, 0x003FFF, "MIME Subtype"      },
    { "x-msdownload",                LEX_XMSDOWNLOAD     , 0, 0x003FFF, "MIME Subtype"      },
    { "octet-stream",                LEX_OCTETSTREAM     , 0, 0x003FFF, "MIME Subtype"      },
    { "binary",                      LEX_BINARY          , 0, 0x003FFF, "MIME Subtype"      },
    // special chacacters
    { " ",                           LEX_SPACE           , 0, 0x7F7F7F, NULL                },
    // tabs are treated as spaces
    { "\t",                          LEX_SPACE           , 0, 0x7F7F7F, NULL                },
    { "/",                           LEX_SLASH           , 0, 0x003FFF, NULL                },
    { "\"",                          LEX_QUOTE           , 0, 0x000000, NULL                },
    { ";",                           LEX_SEMICOLON       , 0, 0x7F7F7F, NULL                },
    { "(",                           LEX_BEGIN_COMMENT   , 0, 0x7F7F7F, "Comment"           },
    { ")",                           LEX_END_COMMENT     , 0, 0x7F7F7F, NULL                },
    // end of table
    { NULL,                          LEX_UNKNOWN         , 0, 0x7F7F7F, NULL                }
    // NOTE: Length should always be zero. We will calculate this the first
    //       time we encounter the string as save it here to be used on
    //       future passes.
};

//
// Constructor / Destructor
//
CMultipartParse::CMultipartParse( 
                    LPECB lpEcb, 
                    LPSTR *lppszOut, 
                    LPSTR *lpszDebug,
                    LPDUMPTABLE lpDT )
    :CBase( lpEcb, lppszOut, lpszDebug, lpDT )
{
    DebugMsg( lpszOut, g_cszTableHeader, "\
(NOTE: To turn on detailed debugging information, add '?debug' to the end of action URL in the orginating HTML file.)\
<br>\
<H2>Multipart Form Data (METHOD=POST, ENCTYPE=MULTIPART/FORM-DATA)</H2>\
",
        "TBLMULTIFORM" );

    _cbDT = 0;  // empty DUMPTABLE

} // CMultipartParse( )

CMultipartParse::~CMultipartParse( )
{
    if ( _lpszBoundary )
    {
        GlobalFree( _lpszBoundary );
    }

} // ~CMultipartParse( )

//
// METHODS
//

//
// What:    PreParse
//
// Desc:    Parses incoming form from the root header. It is assumed that by
//          this point that we are parsing a MUTLIPART / FORM-DATA POST.
//
BOOL CMultipartParse::PreParse( LPBYTE lpbData, LPDWORD lpdwParsed )
{
    BOOL   fReturn;
    LPSTR  lpszHeader;

    TraceMsg( TF_FUNC | TF_PARSE, "PreParse( )" );

    _lpbLastParse = _lpbParse = _lpbData = lpbData;

    // Grab content_type from server header
    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszHeader, NULL );
    if ( !fReturn )
        goto Cleanup;

    // Create the boundary string that we will be searching for
    fReturn = GetBoundaryString( (LPBYTE) lpszHeader );
    GlobalFree( lpszHeader );
    if ( !fReturn )
        goto Cleanup;

    // Parse body headers
    fReturn = ParseBody( );

Cleanup:
    // End table output
    StrCat( lpszOut, g_cszTableEnd );

    // End the DUMPTABLE
    lpDT[ _cbDT ].lpAddr = NULL; // indicates EOTable

    *lpdwParsed = ( _lpbParse - _lpbData );

    TraceMsg( TF_FUNC | TF_PARSE, "PreParse( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // PreParse( )

//
// What:    ParseBody
//
// Desc:    Body header parsing state entered. We start by finding the 
//          next boundary string which indicates the beginning of a
//          body header.
//
BOOL CMultipartParse::ParseBody( )
{
    BOOL   fReturn      = TRUE; // assume success;
    DWORD  eLex;
    BOOL   fStartBoundaryOk = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "ParseBody( )" );

    // Bypass possible crap
    eLex = Lex( );
    while (( eLex != LEX_BOUNDARY ) && ( eLex !=LEX_EOT ) && ( eLex != LEX_STARTBOUNDARY ))
        eLex = Lex( );

    while (( fReturn) && ((DWORD) ( _lpbParse - _lpbData ) != lpEcb->cbTotalBytes ))
    {
        switch ( eLex )
        {
        case LEX_STARTBOUNDARY:
            if ( !fStartBoundaryOk )
            {
                DebugMsg( lpszDebug, "Found a mulformed boundary string. Missing preceeding CRLF at %u (0x%x) bytes.\n",
                    ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
                fReturn = FALSE;
                break;
            }
            // fall thru
        case LEX_BOUNDARY:
            DebugMsg( lpszDebug, "Found boundary. Content starts at %u (0x%x) bytes.\n", 
                ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = BodyHeader( );
            break;

        case LEX_EOT:
            {
                DWORD cbParsed = _lpbParse - _lpbData;
                fReturn = ( cbParsed == lpEcb->cbTotalBytes );
                DebugMsg( lpszDebug, "EOT found.\n" );
                DebugMsg( lpszDebug, "TotalBytesReceived == BytesParsed? %s \n",
                    BOOLTOSTRING( fReturn ) );
                if ( !fReturn )
                {
                    DebugMsg( lpszDebug, "Header 'Content-length': %u bytes. Parsed: %u bytes\n",
                        lpEcb->cbTotalBytes, ( _lpbParse - _lpbData ) );
                    DebugMsg( lpszDebug, "( Note: If bytes parsed greater than 'content-length', it \
                        is possible that the server read the entire packet in its first pass and \
                        that the actual packet size is larger than indicated by the content-length \
                        header field entry. )\n");
                }
            }
            goto Cleanup;

        default:
            DebugMsg( lpszDebug, "Did not find a boundary string after %u (0x%x) bytes.\n", 
                _lpbParse - _lpbData, _lpbParse - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        fStartBoundaryOk = FALSE;
        eLex = Lex( );

    } // while ( _lpbParse - _lpbData )

    DebugMsg( lpszDebug, "Parsed %u (0x%x) bytes.\n", ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ParseBody( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // ParseBody( )

// 
// What:    BodyHeader
//
// Desc:    State has entered the bodyheader.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::BodyHeader( )
{
    BOOL           fReturn = TRUE;
    BODYHEADERINFO sBHI;
    LEXICON        eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "BodyHeader()" );

    // defaults
    sBHI.eContentDisposition = LEX_FORMDATA;
    sBHI.lpszNameField       = NULL;
    sBHI.lpszFilenameField   = NULL;
    sBHI.lpszBodyContents    = NULL;
    sBHI.dwContentType       = LEX_TEXT;
    sBHI.dwContentSubtype    = LEX_PLAIN;

    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // expected
        case LEX_CONTENTDISP:
            fReturn = ContentDisposition( &sBHI );
            break;

        case LEX_CONTENTTYPE:
            fReturn = ContentType( &sBHI );
            break;

        case LEX_CRLF:  // indicate end of header
            goto EndofHeader;

            // ignored
        case LEX_SPACE:
            break;
        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        default:
            DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                FindTokenName( eLex ), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = FALSE;
            break;
        }  
    }

EndofHeader:
    // now retrieve the content...
    if ( fReturn )
    {
        fReturn = BodyContent( &sBHI );
    }

    // add results to output table
    if ( sBHI.lpszNameField )
    {
        DebugMsg( lpszOut, "<TR ID=TR%s><TD ID=TD%s>%s</TD><TD ID=%s>",
            sBHI.lpszNameField, sBHI.lpszNameField, 
            sBHI.lpszNameField, sBHI.lpszNameField );
    }
    else
    {
        DebugMsg( lpszOut, "<TR><TD> 'not given' </TD><TD>" );
    }

    if ( sBHI.lpszFilenameField )
    {
        DebugMsg( lpszOut, "%s", sBHI.lpszFilenameField );
    }
    else if ( sBHI.lpszBodyContents )
    {
        DebugMsg( lpszOut, "%s", sBHI.lpszBodyContents );
    }
    else
    {
        DebugMsg( lpszOut, "'unknown'" );
    }

    DebugMsg( lpszOut, "</TD></TR>" );

    // Free alloced memory
    if ( sBHI.lpszFilenameField )
    {
        GlobalFree( sBHI.lpszFilenameField );
    }

    if ( sBHI.lpszNameField )
    {
        GlobalFree( sBHI.lpszNameField );
    }

    if ( sBHI.lpszBodyContents )
    {
        GlobalFree( sBHI.lpszBodyContents );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BodyHeader() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // BodyHeader( )


//
// What:    ContentDisposition
//
// Desc:    Content-Disposition state reached. Parse header entry.
//
// In/Out:  lpBHI is a pointer to the body header information structure
//              that will be filled in as arguments are parsed.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::ContentDisposition( LPBODYHEADERINFO lpBHI )
{
    BOOL  fReturn = TRUE;
    LEXICON eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "ContentDisposition( lpBHI=0x%x )",
        lpBHI );

    // What forms do we support?
    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // supported
        case LEX_FORMDATA:
            lpBHI->eContentDisposition = eLex;
            break; // LEX_FORMDATA

            // unsupported
        case LEX_ATTACHMENT:
            DebugMsg( lpszDebug, "'%s' (Multiple files) not supported (yet). Aborting...\n",
                FindTokenName( LEX_ATTACHMENT ) );
            fReturn = FALSE;
            break; // LEX_ATTACHMENT

            // possible optional fields
        case LEX_NAMEFIELD:
            fReturn = GetQuotedString( &lpBHI->lpszNameField );
            DebugMsg( lpszDebug, "Name Field='%s'\n", lpBHI->lpszNameField );
            break;

        case LEX_FILENAMEFIELD:
            fReturn = GetQuotedString( &lpBHI->lpszFilenameField );
            DebugMsg( lpszDebug, "Filename Field='%s'\n", lpBHI->lpszFilenameField );
            break;

            // ignored
        case LEX_SPACE:
        case LEX_SEMICOLON:
            break;

        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        case LEX_CRLF:
            eLex = Lex( );
            if ( eLex != LEX_SPACE )
            {
                fReturn = BackupLex( eLex );
                goto Cleanup;    // end of field
            }
            // otherwise we ignore the CRLF and keep going
            break;

            // unexpected things
        default:
            DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                FindTokenName( eLex), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = FALSE;
        }
    } // while eLex

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ContentDisposition() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ContentDisposition( )

//
// What:    ContentType
//
// Desc:    Content-Type state reached. Parse header entry.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::ContentType( LPBODYHEADERINFO lpBHI )
{
    BOOL  fReturn = TRUE;
    BOOL  fAfterSlash = FALSE;
    LEXICON eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "ContentType( lpBHI=0x%x )",
        lpBHI );

    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // MIME types
        case LEX_MULTIPART:
        case LEX_TEXT:
        case LEX_APPLICATION:
        case LEX_AUDIO:
        case LEX_IMAGE:
        case LEX_MESSAGE:
        case LEX_VIDEO:
            lpBHI->dwContentType = eLex;
            break;

            // separator
        case LEX_SLASH:
            fAfterSlash = TRUE;
            break;

            // MIME subtypes
        case LEX_FORMDATA:
        case LEX_ATTACHMENT:
        case LEX_MIXED:
        case LEX_PLAIN:
        case LEX_XMSDOWNLOAD:
        case LEX_OCTETSTREAM:
        case LEX_BINARY:
            lpBHI->dwContentSubtype = eLex;
            break;

            // these are prefixes (like "x-") so we ignore the rest of the 
            // token name.
        case LEX_MIMEEXTENSION:     
            fReturn = GetToken( );  // ignore
            if ( !fAfterSlash )
            {
                lpBHI->dwContentType = eLex;
            }
            else
            {
                lpBHI->dwContentSubtype = eLex;
            }
            break;

          // ignored
        case LEX_SPACE:
        case LEX_SEMICOLON:
            break;

        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        case LEX_CRLF:
            eLex = Lex( );
            if ( eLex != LEX_SPACE )
            {
                fReturn = BackupLex( eLex );
                goto Cleanup;    // end of field
            }
            // otherwise we ignore the CRLF and keep going
            break;

        default:
            if ( !fAfterSlash )
            {
                DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                    FindTokenName( eLex ), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
                fReturn = FALSE;
            }
            else
            {
                fReturn = GetToken( );
            }

        } // switch eLex

    } // while fReturn

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ContentType() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ContentType( )

//
// What:    GetBoundaryString
//
// Desc:    Searches CONTENT_TYPE for boundary string and copies into 
//          buffer (GlobalAlloced).
//
// Return:  TRUE is boundary found and copied, otherwise FALSE.
//
BOOL CMultipartParse::GetBoundaryString( LPBYTE lpbData )
{
    BOOL fReturn;
    LPSTR lpstr;

    TraceMsg( TF_FUNC | TF_PARSE, "GetBoundaryString( )" );

    // assume failure
    _lpszBoundary = NULL;
    _cbBoundary   = 0;
    fReturn       = FALSE;

    // find the boundary keyword
    lpstr = StrStrI( (LPSTR) lpbData, g_cszBoundaryKeyword );
    if ( !lpstr )
        goto Cleanup;    

    // move forward of keyword 
    lpstr += g_cbBoundaryKeyword;

    // point to boundary string
    _lpszBoundary = StrDup( lpstr );
    _cbBoundary = lstrlen( _lpszBoundary );

    DebugMsg( lpszDebug, "Boundary String : 'CRLF--%sCRLF' %u (0x%x) bytes\n",
        _lpszBoundary, _cbBoundary + 6, _cbBoundary + 6 );
    DebugMsg( lpszDebug, "EndOfContent Str: 'CRLF--%s--CRLF' %u (0x%x) bytes\n",
        _lpszBoundary, _cbBoundary + 8, _cbBoundary + 8 );

    fReturn = TRUE;

Cleanup:
    // _lpszBoundary will be cleaned up on the destruction of the
    // class.

    TraceMsg( TF_FUNC | TF_PARSE, "GetBoundaryString( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // GetBoundaryString( )



//
// What:    HandleComments
//
// Desc:    pull down comments and discard them. 
//          ISSUE: Doesn't handle embedded comments.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::HandleComments( )
{
    BOOL fReturn = TRUE;
    TraceMsg( TF_FUNC | TF_PARSE, "HandleComments( )" );

    LEXICON eLex = LEX_UNKNOWN;
    while( eLex != LEX_END_COMMENT )
        eLex = Lex( ); // parse away...

    TraceMsg( TF_FUNC | TF_PARSE, "HandleComments( ) Exit" );
    return fReturn;
} // HandleComments( )


//
// What:    BodyContent
//
// Desc:    Handles the content part of the body.
//
// In:      lpBHI is the body header information structure that
//              contains arguments found in the body header.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::BodyContent( LPBODYHEADERINFO lpBHI )
{
    BOOL    fReturn           = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "BodyContent( lpBHI=0x%x )",
        lpBHI );

    // Is it a file?
    if (( lpBHI->lpszFilenameField ) 
       && ( lpBHI->lpszFilenameField[ 0 ] != 0 ))
    {   // file content....
        fReturn = HandleFile( lpBHI->lpszFilenameField );
        if ( fReturn )
            DebugMsg( lpszDebug, "Body Data= FILE CONTENTS\n" );
    }
    else
    {   // TODO: we need to handle different "Content-Types".
        //         For now we will assume that it is text/plain.
        LEXICON eLex = LEX_UNKNOWN;

        LPBYTE lpbStart = _lpbParse;
        DWORD dwSize;
        fReturn = FindNextBoundary( &dwSize );

        // neaten up to be displayed and copied
        CHAR cTemp = *_lpbParse; // save
        *_lpbParse = 0;     // null to display
        DebugMsg( lpszDebug, "Body Data='%s'\n", lpbStart );
        lpBHI->lpszBodyContents = StrDup( (LPSTR) lpbStart );
        *_lpbParse = cTemp; // restore
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BodyContent( _lpbParse=0x%x ) Exit = %s",
        _lpbParse, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // BodyContent( )

//
// What:    GetQuotedString
//
// Desc:    Retrieves a quoted string from data.
//
// In/Out:  lppszBuf is a passed in buffer pointer which will be assigned to
//              to the field name.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::GetQuotedString( LPSTR *lppszBuf )
{
    BOOL   fReturn = TRUE;
    LPBYTE lpbStart;

    TraceMsg( TF_FUNC | TF_PARSE, "GetQuotedString( )" );

    LEXICON eLex = Lex( );
    fReturn = ( eLex == LEX_QUOTE );
    if ( !fReturn )
    {
        DebugMsg( lpszDebug, "Excepted the beginning of a quoted string at %u (0x%x) bytes.\n",
            ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
        goto Cleanup;
    }

    lpbStart = _lpbParse;
    while (( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes ) 
        && ( *_lpbParse != '\"' ))           
        _lpbParse++;

    if ( _lpbParse == (LPBYTE) lpEcb->cbTotalBytes )
    {
        fReturn = FALSE;
        *lppszBuf = StrDup( "Error!" );
    }
    else
    {
        CHAR cTmp = *_lpbParse;
        *_lpbParse = 0;             // save
        *lppszBuf = StrDup( (LPSTR) lpbStart );
        *_lpbParse = cTmp;          // restore
        _lpbParse++;        // get past the quote
    }

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "GetQuoteString( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetQuotedString( )

//
// What:    GetToken
//
// Desc:    Scans past unknow content and validates that the characters
//          used are acceptable ( see RFC 1521, page 9 ). If an invalid
//          character is found, it will exit (no error).
//
// Return:  FALSE if we run past the end of the data buffer, otherwise TRUE.
//
BOOL CMultipartParse::GetToken( )
{
    BOOL fReturn = TRUE;

    static const char szInvalidChars[] = "()<>@,;:\\\"/[]?=";
    // plus SPACE and CTLs (in if statement)

    TraceMsg( TF_FUNC | TF_PARSE, "GetToken()" );

    while ( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes )
    {
        if (( *_lpbParse <= 32 ) 
           || ( StrChr( szInvalidChars, *_lpbParse ) ))
            break;

        _lpbParse++;
    }

    if ( (DWORD) ( _lpbParse - _lpbData ) == lpEcb->cbTotalBytes )
    {
        DebugMsg( lpszDebug, "Could not find the end of the token.\n" );
        fReturn = FALSE;
    }

    TraceMsg( TF_FUNC | TF_PARSE, "GetToken() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetToken( )

//
// What:    HandleFile
//
// Desc:    Retrieves "file" part of the body.
//
// In:      lpszFilename is the name of the file from the form submission.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::HandleFile( LPSTR lpszFilename )
{
    BOOL   fReturn = TRUE;
    DWORD  eLex = LEX_UNKNOWN;
    DWORD  dwSize;
    LPBYTE lpbStart;

    TraceMsg( TF_FUNC | TF_PARSE, "HandleFile( \"%s\" )", lpszFilename );

    // find the end of the file
    lpbStart = _lpbParse;
    fReturn = FindNextBoundary( &dwSize );

    // fix filename for server use
    if ( fReturn )
    {
        DebugMsg( lpszDebug, "Filesize= %u (0x%x) bytes\n", dwSize, dwSize );
        fReturn = FixFilename( lpszFilename, &lpszFilename );
    }

    // Check the filename for ""
    if (( fReturn ) && ( StrCmp( lpszFilename, "" ) ))
    {
#ifndef FILE_SAVE
        fReturn  = FileCompare( lpbStart, lpszFilename, dwSize );
#else // FILE_SAVE
        fReturn  = FileSave( lpbStart, lpszFilename, dwSize );
#endif // FILE_SAVE
    }

    if ( !fReturn )
    {
        LogMsg( lpEcb->lpszLogData, NULL, "Error: File possibly corrupt." );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "HandleFile( \"%s\" ) Exit = %s", 
        lpszFilename, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // HandleFile( )


//
// What:    FindNextBoundary
//
// Desc:    Finds the next boundary in body content and the length of
//          the block skipped.
//
// Out:     *lpdwSize will contain the size of the block skipped.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FindNextBoundary( LPDWORD lpdwSize )
{
    BOOL fReturn = FALSE;   // assume failure

    TraceMsg( TF_FUNC | TF_PARSE, "FindNextBoundary()" );

    lpDT[ _cbDT ].lpAddr      = _lpbParse;
    lpDT[ _cbDT ].dwColor     = 0x000000;
    lpDT[ _cbDT ].lpszComment = (LPSTR) g_cszBodyData;
    _cbDT++;
    if ( _cbDT >= MAX_DT )
    {
        DebugMsg( lpszDebug, "*** DEBUG ERROR *** Exceeded Dump Table Limit\n" );
        _cbDT = MAX_DT - 1;
    }

    // find the end of the file
    LPBYTE lpbStart = _lpbParse;
    while ( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes )
    {
        // possible boundary?
        if ( !StrCmpN( (LPSTR) _lpbParse, g_cszBoundaryIndicator, g_cbBoundaryIndicator ) )
        { // yes... check further
            LPBYTE lpb = _lpbParse; // save
            LEXICON eLex = Lex( );
            _lpbParse = lpb;        // restore
            _cbDT--;                // ignore this parse
            if (( eLex == LEX_BOUNDARY ) || ( eLex == LEX_EOT ))
            {
                fReturn = TRUE;
                break;  // exit loop
            }
        }
        _lpbParse++;
    }

    // figure out the size
    *lpdwSize = _lpbParse - lpbStart;

    if ( !fReturn )
    {
        DebugMsg( lpszDebug, "FindNextBoundary( ): Did not find boundary after %u (0x%x) bytes.\n",
            lpbStart - _lpbData, lpbStart - _lpbData );

        _lpbParse--;    // back up one byte
        _cbDT--;        // back up one parse table entry
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FindNextBoundary( *lpdwSize = %u (0x%x) ) Exit = %s",
        *lpdwSize, *lpdwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

}  // FindNextBoundary( )

#ifndef FILE_SAVE
//
// What:    MemoryCompare
//
// Desc:    Compares memory chunks and determines if they match
//
// In:      lpbSrc1 and lpbSrc2 and the memory blocks to compare.
//          dwSize is the length of the blocks.
//
// Return:  TRUE if they match, otherwise FALSE
//
BOOL CMultipartParse::MemoryCompare( LPBYTE lpbSrc1, LPBYTE lpbSrc2, DWORD dwSize )
{
    DWORD cb = 0;
    while (( cb < dwSize ) && ( *lpbSrc1 == *lpbSrc2 ))
    {
        lpbSrc1++;
        lpbSrc2++;
        cb++;
    }

    return ( cb == dwSize );
} // MemoryCompare( )

//
// What:    FileCompare
//
// Desc:    Compares bits in memory with contents of the file lpszFilename.
//
// In:      lpbStart is the starting memory address.
//          lpszFilename is the filename to use.
//          dwSize is the length of valid bits after lpbStart.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FileCompare( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize )
{
#define BIG_FILE_SIZE   4096
    BOOL fReturn = TRUE;
    DWORD dwRead;
    LPBYTE lpBuffer;

    TraceMsg( TF_FUNC | TF_PARSE, "FileCompare( lpbStart=0x%x, lpszFilename='%s', dwSize=%u )",
        lpbStart, lpszFilename, dwSize );

    HANDLE hFile = CreateFile( lpszFilename, GENERIC_READ, 
        FILE_SHARE_READ, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
        NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        DebugMsg( lpszDebug, "CreateFile() failed to open '%s'.\n",
            lpszFilename );
        fReturn = FALSE;
        goto Cleanup;
    }

    dwRead = GetFileSize( hFile, NULL );
    if ( dwSize != dwRead )
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: File sizes don't match: '%s'",
            lpszFilename );
        DebugMsg( lpszDebug, "FileChecking: Client sent=%u (0x%x) bytes and File length=%u (0x%x) bytes.\n",
            lpszFilename, dwSize, dwSize, dwRead, dwRead );
        DebugMsg( lpszDebug, "FileChecking: I will compare the bits I can.\n" );
        fReturn = FALSE;

        // shorten if needed
        dwSize = ( dwSize > dwRead ? dwRead : dwSize );                            
    }

    if ( dwSize > BIG_FILE_SIZE )
    {   // read/compare only the beginning and the end bytes
        DWORD dwShortSize = BIG_FILE_SIZE / 2;

        DebugMsg( lpszDebug, "FileChecking: **** Very large file ( > %u (0x%x) bytes )****\n",
            BIG_FILE_SIZE, BIG_FILE_SIZE );
        DebugMsg( lpszDebug, "FileChecking: Checking only the beginning %u (0x%x) bytes and the last %u (0x%x) bytes.\n",
            dwShortSize, dwShortSize, dwShortSize, dwShortSize);
            
        lpBuffer = (LPBYTE) GlobalAlloc( GMEM_FIXED, dwShortSize );
        if ( !lpBuffer )
        {
            DebugMsg( lpszDebug, "Out of memory(?).\n" );
            fReturn = FALSE;
            goto Cleanup;
        }
        // read beginning bytes
        if ( !ReadFile( hFile, lpBuffer, dwShortSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "begin bytes ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        }
        if ( dwShortSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking(begin bytes): Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwShortSize, dwShortSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        } 

        fReturn = MemoryCompare( lpBuffer, lpbStart, dwShortSize );
        if ( !fReturn )
            goto Cleanup;

        // seek to end bytes
        if ( 0xFFFFffff == SetFilePointer( hFile, dwSize - dwShortSize, NULL, FILE_BEGIN ) )
        {   // error
            DebugMsg( lpszDebug, "SetFilePointer() failed!\n" );
            fReturn = FALSE;
            goto Cleanup;
        }

        // read end bytes
        if ( !ReadFile( hFile, lpBuffer, dwShortSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "end bytes ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 
        if ( dwShortSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking(end bytes): Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwShortSize, dwShortSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        } 

        fReturn = MemoryCompare( lpBuffer, lpbStart + dwSize - dwShortSize, dwShortSize );
    }
    else // if ( dwSize > BIG_FILE_SIZE )
    {   // read/compare entire file
        lpBuffer = (LPBYTE) GlobalAlloc( GMEM_FIXED, dwSize );
        if ( !lpBuffer )
        {
            DebugMsg( lpszDebug, "Out of memory(?).\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 

        if ( !ReadFile( hFile, lpBuffer, dwSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 

        if ( dwSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking: Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwSize, dwSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        }

        fReturn = MemoryCompare( lpBuffer, lpbStart, dwSize );

    } // if ( dwSize > BIG_FILE_SIZE )


Cleanup:
    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle( hFile ); // close file

    GlobalFree( lpBuffer );

    // Output to IIS log
    if ( fReturn )
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: Files matched!" );
    }
    else
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: Files don't match or an error occured." );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FileCompare( lpbStart=0x%x, lpszFilename='%s', dwSize=%u ) Exit = %s",
        lpbStart, lpszFilename, dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // FileCompare( )

#else // FILE_SAVE

//
// What:    FileSave
//
// Desc:    Save bits starting at lpbStart to a file called lpszFilename.
//
// In:      lpbStart is the starting memory address.
//          lpszFilename is the filename to use.
//          dwSize is the length of valid bits after lpbStart.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FileSave( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize )
{
    BOOL fReturn = TRUE;
    
    TraceMsg( TF_FUNC | TF_PARSE, "FileSave( lpbStart=0x%x, lpszFilename='%s', dwSize=%u )",
        lpbStart, lpszFilename, dwSize );

    if ( fReturn )
    {
        HANDLE hFile = CreateFile( lpszFilename, GENERIC_WRITE, 
            FILE_SHARE_READ, NULL, CREATE_NEW, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
            NULL );
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            DWORD dwWrote;
            if ( WriteFile( hFile, lpbStart, dwSize, &dwWrote, NULL ) )
            {
                fReturn = ( dwSize == dwWrote );
                if ( !fReturn ) 
                {
                    LogMsg( lpEcb->lpszLogData, lpszDebug, "Could not write entire file '%s'. Only wrote %u (0x%x) bytes.",
                        lpszFilename, dwWrote, dwWrote );
                }
            }
            else 
            {
                LogMsg( lpEcb->lpszLogData, lpszDebug, "Could not write file '%s'.",
                    lpszFilename );
                fReturn = FALSE;
            }

            CloseHandle( hFile );

        } 
        else 
        {
            LogMsg( lpEcb->lpszLogData, lpszDebug, "CreateFile() failed to create '%s'.",
                lpszFilename );
            fReturn = FALSE;

        } // if hFile

    } // if fReturn

    TraceMsg( TF_FUNC | TF_PARSE, "FileSave( lpbStart=0x%x, lpszFilename='%s', dwSize=%u ) Exit = ",
        lpbStart, lpszFilename, dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // FileSave( )

#endif // FILE_SAVE

//
// What:    FixFilename
//
// Desc:    Adjusts filename to be used on the server. It creates a path
//          to the same directory as the DLL. It then appends the just 
//          the filename ( not the path info ).
//
// In:      lpszFilename is the filename submitted by user.
//
// In/Out:  lppszNameFilename will return a pointer to the newly constructed
//              filename.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FixFilename( LPSTR lpszFilename, LPSTR *lppszNewFilename )
{
    BOOL fReturn = TRUE;
    CHAR szFilename[ MAX_PATH ];    // temp buffer

    TraceMsg( TF_FUNC | TF_PARSE, "FixFilename( lpszFilename='%s', *lppszNewFilename=0x%x )",
        lpszFilename, *lppszNewFilename );

    // Strip c:\ stuff
    LPSTR lpszShortFilename = StrRChr( lpszFilename, lpszFilename + lstrlen( lpszFilename ), '\\' );
    if ( lpszShortFilename )
    {
        lpszShortFilename++;    // move ahead of '\'
    }
    else
    {
        lpszShortFilename = lpszFilename;   // maybe it's already short.
    }

    // retrieve download directory file URL info
    LPSTR lpszPath;
    fReturn = GetServerVarString( lpEcb, "PATH_TRANSLATED", &lpszPath, NULL );
    if ( lpszPath )
    {
        StrCpy( szFilename, lpszPath );
        DWORD cch = lstrlen( szFilename );
        // check for '\' at the end...
        if ( szFilename[ cch - 1 ] != '\\' )
        {   // not there... add it
            szFilename[ cch ] = '\\';
            cch++;
        }
        // append filename
        StrCpy( &szFilename[ cch ], lpszShortFilename );
    } 
    else 
    {
        StrCpy( szFilename, lpszShortFilename );
    }

    *lppszNewFilename = StrDup( szFilename );
    fReturn = ( *lppszNewFilename != NULL );

    TraceMsg( TF_FUNC | TF_PARSE, "FixFilename( lpszFilename='%s', *lppszNewFilename=0x%x ) Exit = %s",
        lpszFilename, *lppszNewFilename, BOOLTOSTRING( fReturn ) );
    return fReturn;
    
} // FixFilename( )

//
// What:    Lex
//
// Desc:    Turns the next bytes into a token
//
// Return:  TRUE unless an error occurs.
//
LEXICON CMultipartParse::Lex( )
{
    TraceMsg( TF_FUNC | TF_PARSE | TF_LEX, "Lex( _lpbParse=0x%x )",
        _lpbParse );

    lpDT[ _cbDT ].lpAddr      = _lpbParse;
    lpDT[ _cbDT ].dwColor     = 0xFFFFFF;
    lpDT[ _cbDT ].lpszComment = (LPSTR) g_cszExtraBytes;

    if ( _lpbParse > _lpbData + lpEcb->cbTotalBytes )
    {
        return LEX_EOT;   // over the limit!
    }

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        // remember str length sizes to speed up on next pass
        if ( !g_LexTable[ i ].cLength )
        {
            g_LexTable[ i ].cLength  = lstrlen( g_LexTable[ i ].lpszName );
        }

        if ( !StrCmpNI( (LPSTR)_lpbParse, g_LexTable[ i ].lpszName, g_LexTable[ i ].cLength ) )
            break;  // found... exit

    } // for i

    // SPECIAL CASE
    LEXICON eLex = g_LexTable[ i ].eLex;
    if ( eLex == LEX_BOUNDARY )
    {   // check for a specific boundary marker
        _lpbParse += g_LexTable[ i ].cLength;
        eLex = LEX_UNKNOWN;

        if ( !StrCmpN( (LPSTR) _lpbParse , _lpszBoundary, _cbBoundary ) )
        { // match
            // check to see if it is an EOT Marker
            if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "--\r\n", 4 ) )
            {
                _lpbParse += _cbBoundary + 4;
                eLex      = LEX_EOT;
            } 
            // else make sure that it ends with a CRLF - rfc1521 Page 30
            else if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "\r\n", 2 ) )
            {
                _lpbParse += _cbBoundary + 2;
                eLex      = LEX_BOUNDARY;
            }
            // else it isn't a boundary
        }   
    }
    else if ( eLex == LEX_STARTBOUNDARY )
    {   // check for a specific boundary marker
        _lpbParse += g_LexTable[ i ].cLength;
        eLex = LEX_UNKNOWN;

        if ( !StrCmpN( (LPSTR) _lpbParse , _lpszBoundary, _cbBoundary ) )
        { // match
            // check to see if it is an EOT Marker
            if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "\r\n", 2 ) )
            {
                _lpbParse += _cbBoundary + 2;
                eLex      = LEX_STARTBOUNDARY;
            }
            // else it isn't a boundary
        }
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        _lpbParse++;
    }
    else    // move past symbol
    {
        _lpbParse += g_LexTable[ i ].cLength;
    }


    lpDT[ _cbDT ].dwColor     = g_LexTable[ i ].dwColor;
    lpDT[ _cbDT ].lpszComment = g_LexTable[ i ].lpszComment;
    _cbDT++;
    if ( _cbDT >= MAX_DT )
    {
        DebugMsg( lpszDebug, "*** DEBUG ERROR *** Exceeded Dump Table Limit\n" );
        _cbDT = MAX_DT - 1;
    }

    TraceMsg( TF_FUNC | TF_PARSE | TF_LEX, "Lex( _lpbParse=0x%x ) Exit = %u ( %u, '%s')",
        _lpbParse, eLex, i,
        ( g_LexTable[ i ].lpszName ? g_LexTable[ i ].lpszName  : "NULL" ) );
    return eLex;
} // Lex( )

//
// What:    Find Token
//
// Desc:    Searches tokens and displays friendly name.
//
// In:      eLex is the Lexicon to find
//
// Return:  TRUE unless an error occurs.
//
LPSTR CMultipartParse::FindTokenName( LEXICON eLex )
{
    TraceMsg( TF_FUNC | TF_PARSE, "FindTokenName( )" );

    LPSTR lpszReturn = "<not found>";  // default

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        if ( g_LexTable[ i ].eLex == eLex )
            break;  // found... exit

    } // for i

    // SPECIAL CASE
    if ( eLex == LEX_BOUNDARY )
    {
        lpszReturn = _lpszBoundary;
    }
    else if ( eLex == LEX_EOT )
    {
        lpszReturn = _lpszBoundary;
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        LPBYTE lpb = _lpbParse - 1;
        while (( *lpb ) && ( *lpb > 32 ))
            lpb++;
        *lpb = 0;
        lpszReturn = (LPSTR) _lpbParse;
    }
    else if ( g_LexTable[ i ].lpszName )
    {
        lpszReturn = g_LexTable[ i ].lpszName;
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FindTokenName( ) Exit" );
    return lpszReturn;

} // FindTokenName( )

//
// What:    BackupLex
//
// Desc:    Backs parser up eLex's byte count.
//
// In:      eLex is the token ID to back up
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::BackupLex( LEXICON eLex )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "BackupLex( eLex=%s )", 
        FindTokenName( eLex ) );

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        if ( g_LexTable[ i ].eLex == eLex )
            break;  // found... exit

    } // for i

    // SPECIAL CASES
    if ( eLex == LEX_BOUNDARY )
    {
        // "CRLF--" + boundary string + "CRLF"
        _lpbParse -= ( g_LexTable[ i ].cLength + _cbBoundary + 2 );
    }
    else if ( eLex == LEX_EOT )
    {
        // "CRLF--" + boundary string + "--CRLF"
        _lpbParse -= ( g_LexTable[ i ].cLength + _cbBoundary + 4 );
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        _lpbParse--;
    }
    else if ( g_LexTable[ i ].lpszName )
    {
        _lpbParse -= g_LexTable[ i ].cLength;
    }

    if ( fReturn )
    {
        _cbDT--;    // remove one
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BackupLex( eLex=%s ) Exit",
        FindTokenName( eLex ) );
    return fReturn;

} // BackupLex( )

/*****************************************************************************
//
// FUNCTION TEMPLATE
//
// ***************************************************************************
//
// What:    
//
// Desc:    
//
// In:
//
// Out:
//
// Return:
//
BOOL CMultipartParse::( )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "()" );


    TraceMsg( TF_FUNC | TF_PARSE, "() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\readdata.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// READDATA.CPP - Reading data helping utilities
//

#include "pch.h"

// Globals
const char g_cszMultiPartFormData[]  = "multipart/form-data";
const char g_cszDebug[]              = "debug";
const char g_cszTextPlain[]          = "text/plain";

//
// What:    ReadData
//
// Desc:    Reads the rest of the stream from the client. There is dwSize
//          bytes left to read and will be stored in lpMoreData.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK.
//          lpMoreData is the buffer where the bits will be stored.
//          dwSize is the amount of bits to be saved.
//
// Return:  FALSE if there is an error during the read, otherwise TRUE.
//
BOOL ReadData( LPECB lpEcb, LPVOID lpMoreData, DWORD dwSize )
{
    BOOL fReturn;
    BOOL fLastRequestFail = FALSE;
    DWORD cb, count;
    LPBYTE lpBytes;
    TraceMsg( TF_FUNC | TF_READDATA, "ReadData( lpEcb, lpMoreData, dwSize=%u )", dwSize );

    lpBytes = (LPBYTE) lpMoreData;
    count = 0;
    while ( count != dwSize )
    {
        cb  = dwSize - count;
        fReturn = ReadClient( lpEcb->ConnID, lpBytes, &cb );
        if ( !fReturn )
            goto Cleanup;

        count += cb;    // increment the number of bytes read
        lpBytes += cb;  // move pointer ahead

        if ( cb == 0 )
        {
            if ( fLastRequestFail )
            {
                DebugMsg( NULL, "Two ReadClient requests resulted in ZERO bytes read. Aborting rest of read." );
                break;
            }

            fLastRequestFail = TRUE;
        }
        else
        {
            fLastRequestFail = FALSE;
        }
    }

    TraceMsg( TF_READDATA, "Count= %u", count );

Cleanup:
    TraceMsg( TF_FUNC | TF_READDATA, "ReadData( lpEcb, lpMoreData, dwSize=%u ) Exit = %s", 
        dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // ReadData( )


//
// What:    CompleteDownload
//
// Desc:    Makes sure that we have everything the client is sending.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK.
//
// Out:     lpbData is the pointer to the return pointer where the entire
//          data bytes are.
//
BOOL CompleteDownload( LPECB lpEcb, LPBYTE *lppbData )
{
    BOOL fReturn = TRUE;    // assume success

    TraceMsg( TF_FUNC | TF_READDATA, "CompleteDownload( )" );

    // Point to what the server has already downloaded
    *lppbData = lpEcb->lpbData;  

    // Do we have the whole thing?
    BOOL fDownloadComplete = (lpEcb->cbTotalBytes == lpEcb->cbAvailable );

    TraceMsg( TF_READDATA, "Does cbTotalBytes(%u) == cbAvailable(%u)? %s",
        lpEcb->cbTotalBytes, lpEcb->cbAvailable, 
        BOOLTOSTRING( fDownloadComplete ) );

    if ( !fDownloadComplete )
    {   // Get the rest of the data...
        *lppbData = (LPBYTE) GlobalAlloc( GPTR, lpEcb->cbTotalBytes );
        CopyMemory( *lppbData , lpEcb->lpbData, lpEcb->cbAvailable );
        DWORD dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        fReturn = ReadData( lpEcb, *lppbData + lpEcb->cbAvailable, dwSize );
        if ( !fReturn ) {
            TraceMsg( TF_ALWAYS, NULL, "CompleteDownload( ): Error recieving submission." );
            goto Cleanup;
        }
    }

Cleanup:
    TraceMsg( TF_FUNC | TF_READDATA, "CompleteDownload( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CompleteDownload( )

//
// What:    GetServerVarString
//
// Desc:    Asks server for a server variable. It also allocs space for the 
//          resulting string.
//
// In:      lpEcb is an EXTENDED_CONTROL_BLOCK.
//          lpVarName is a pointer the string name of the server variable to
//              retrieve.
// In/Out:  lppszBuffer will be assign memory for the result string from the 
//              server.
//          lpdwSize (if passed) will be assigned the size of the buffer.
//
BOOL GetServerVarString( LPECB lpEcb, LPSTR lpszVarName, LPSTR *lppszBuffer, LPDWORD lpdwSize )
{
    CHAR  szVerySmallBuf[ 1 ];   // bogus buffer
    DWORD dwSize;
    BOOL  fReturn;

    TraceMsg( TF_FUNC | TF_READDATA, "GetServerVarString( lpEcb, lpszVarName='%s', *lppszBuffer=%x, lpdwSize=%x )",
        lpszVarName, *lppszBuffer, lpdwSize );

    // Find out how big our buffer needs to be.
    dwSize = 0;
    fReturn = GetServerVariable( lpEcb->ConnID, lpszVarName, szVerySmallBuf, &dwSize );
    DWORD dwErr = GetLastError( );
    if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
    {
        TraceMsgResult( TF_ALWAYS, &ErrtoStr, dwErr, "GetServerVariable( ) returned " );
        goto Cleanup;
    }

    // get some memory
    *lppszBuffer = (LPSTR) GlobalAlloc( GPTR, dwSize );
    if ( !*lppszBuffer )
    {   // not enough memory
        TraceMsg( TF_ALWAYS, "Operation failed. Out of Memory(?). lppszBuffer == NULL" );
        fReturn = FALSE;
        goto Cleanup;    
    }

    // grab it for real this time
    fReturn = GetServerVariable( lpEcb->ConnID, lpszVarName, *lppszBuffer , &dwSize );
    if ( !fReturn )
    {
        DWORD dwErr = GetLastError( );
        TraceMsgResult( TF_ALWAYS, &ErrtoStr, dwErr, "GetServerVariable( ) returned " );
        goto Cleanup;
    }

Cleanup:
    if ( !fReturn )
    {
        dwSize = 0;
        *lppszBuffer = NULL;
    }

    if ( lpdwSize )
        *lpdwSize = dwSize;

    TraceMsg( TF_FUNC | TF_READDATA, "GetServerVarString( lpEcb, lpszVarName='%s', *lppszBuffer=%x, lpdwSize=%x ) Exit = %s",
        lpszVarName, *lppszBuffer, lpdwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetServerVarString( )

//
// What:    CheckForMultiPartFormSubmit
//
// Desc:    Checks "content-type" to see if it is a "multipart/form-data"
//          submission.
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
// Out:     lpfMultipart: TRUE is submission is multipart, otherwise false.
//
// Return:  FALSE is there was an error, otherwise TRUE.
//
BOOL CheckForMultiPartFormSubmit( LPECB lpEcb, BOOL *lpfMultipart )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForMultiPartFormSubmit( )" );

    *lpfMultipart = FALSE;

    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer ) && (StrStr( lpszBuffer, g_cszMultiPartFormData ) ))
        *lpfMultipart = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForMultiPartFormSubmit( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForMultiPartFormSubmit( )


//
// What:    CheckForDebug
//
// Desc:    Checks "query_string" to see if it is "debug".
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
// 
// Out:     lpfDebug is the flag that we set.
//
// Return:  TRUE is the submit is multipart, otherwise FALSE.
//
BOOL CheckForDebug( LPECB lpEcb, BOOL *lpfDebug )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForDebug( )" );

    *lpfDebug = FALSE;

    fReturn = GetServerVarString( lpEcb, "QUERY_STRING", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer) && ( StrStr( lpszBuffer, g_cszDebug ) ))
        *lpfDebug = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForDebug( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForDebug( )


//
// What:    CheckForTextPlanSubmit
//
// Desc:    Checks "content-type" to see if it is "text/plain".
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
// 
// Out:     lpfTextPlain is the flag that we set.
//
// Return:  TRUE is the submit is multipart, otherwise FALSE.
//
BOOL CheckForTextPlainSubmit( LPECB lpEcb, BOOL *lpfTextPlain )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForTextPlainSubmit( )" );

    *lpfTextPlain = FALSE;

    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer) && ( StrStr( lpszBuffer, g_cszTextPlain ) ))
        *lpfTextPlain = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForTextPlainSubmit( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForTextPlainSubmit( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\multpars.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// MULTPARS.H - Multipart parser (CMultipartParse) header
//


// Turn this on to compile a file saving version
// #define FILE_SAVE

#ifndef _MULTPARS_H_
#define _MULTPARS_H_

enum LEXICON {
    LEX_UNKNOWN,
    LEX_SPACE,
    LEX_CRLF,
    LEX_BEGIN_COMMENT,
    LEX_END_COMMENT,
    LEX_QUOTE,
    LEX_SEMICOLON,
    LEX_SLASH,
    // Body keywords
    LEX_CONTENTDISP,
    LEX_CONTENTTYPE,
    // Field IDs
    LEX_NAMEFIELD,
    LEX_FILENAMEFIELD,
    // MIME types
    LEX_MULTIPART,
    LEX_TEXT,
    LEX_APPLICATION,
    LEX_AUDIO,
    LEX_IMAGE,
    LEX_MESSAGE,
    LEX_VIDEO,
    LEX_MIMEEXTENSION,
    // MIME subtypes
    LEX_FORMDATA,
    LEX_ATTACHMENT,
    LEX_MIXED,
    LEX_PLAIN,
    LEX_XMSDOWNLOAD,
    LEX_OCTETSTREAM,
    LEX_BINARY,
    // Boundary
    LEX_BOUNDARY,   // "CR/LF" ended boundary string
    LEX_EOT,        // double-dashed ended boundary string
    LEX_STARTBOUNDARY // boundary string missing first CR/LF
};

typedef struct {
    LPSTR   lpszName;       // token name
    LEXICON eLex;           // token value
    DWORD   cLength;        // length of lpszName, filled in at runtime, 
                            // should be ZERO in table def
    DWORD   dwColor;        // debugging color to be used
    LPSTR   lpszComment;    // debugging comment to be displayed
} PARSETABLE, *LPPARSETABLE;

typedef struct {
    LEXICON eContentDisposition;
    LPSTR   lpszNameField;
    LPSTR   lpszFilenameField;
    LPSTR   lpszBodyContents;
    DWORD   dwContentType;
    DWORD   dwContentSubtype;
} BODYHEADERINFO, *LPBODYHEADERINFO;

#define LPBHI LPBODYHEADERINFO
    

class CMultipartParse : public CBase
{
public:
    CMultipartParse( LPECB lpEcb, LPSTR *lppszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    ~CMultipartParse( );

    // Starts parsing data using infomation from server headers
    BOOL PreParse( LPBYTE lpbData, LPDWORD lpdwParsed );

private:
    LPBYTE  _lpbData;                   // Memory containing send data
    LPBYTE  _lpbParse;                  // Current parse location into _lpbData
    LPBYTE  _lpbLastParse;              // Last location of Lex parsing

    LPSTR   _lpszBoundary;              // Boundary string
    DWORD   _cbBoundary;                // Boundary string length

    // Debugging Data dump
    DWORD       _cbDT;                  // Counter

    // Lex
    LEXICON Lex( );                         // finds next Lex
    BOOL    BackupLex( LEXICON dwLex );     // moves back one Lex
    LPSTR   FindTokenName( LEXICON dwLex ); // finds Lex's name
    BOOL    GetToken( );                    // moves post a token of valid
                                            // header characters

    // states
    BOOL ParseBody( );                  // initial state
    BOOL BodyHeader( );
    BOOL ContentDisposition( LPBODYHEADERINFO lpBHI );
    BOOL ContentType( LPBODYHEADERINFO lpBHI );
    BOOL BodyContent( LPBODYHEADERINFO lpBHI );

    // utilities
    BOOL GetBoundaryString( LPBYTE lpbData );
    BOOL GetQuotedString( LPSTR *lppszBuf );
    BOOL HandleComments( );
#ifndef FILE_SAVE
    BOOL MemoryCompare( LPBYTE lpbSrc1, LPBYTE lpbSrc2, DWORD dwSize );
#endif
    BOOL FindNextBoundary( LPDWORD lpdwSize );

    // files
    BOOL HandleFile( LPSTR lpszFilename );
#ifndef FILE_SAVE
    BOOL FileCompare( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize );
#else // FILE_SAVE
    BOOL FileSave( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize );
#endif // FILE_SAVE
    BOOL FixFilename( LPSTR lpszFilename, LPSTR *lppszNewFilename );

    CMultipartParse( );

}; // CMultipartParse

#endif // _MULTPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\reflectr.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// REFLECTR.H - 
//

#ifndef _REFLECTR_H_
#define _REFLECTR_H_

#define LPECB   LPEXTENSION_CONTROL_BLOCK

#define GetServerVariable( _hconn, _lpstr, _lpvoid, _lpdword )                  \
    (lpEcb->GetServerVariable)( _hconn, _lpstr, _lpvoid, _lpdword );            \
    TraceMsg( TF_SERVER, "GetServerVariable( Connid=0x%x  lpszVarName='%s'  lpBuf=0x%x  lpdwSize=0x%x )",  \
        _hconn, _lpstr, _lpvoid, _lpdword )

#define WriteClient( _hconn, _lpvoid, _lpdword, _dw )                           \
    (lpEcb->WriteClient)( _hconn, _lpvoid, _lpdword, _dw );                     \
    TraceMsg( TF_SERVER, "WriteClient( Connid=0x%x  lpBuf=0x%x  lpdwSize=0x%x  dwResv=0x%x )",  \
        _hconn, _lpvoid, _lpdword, _dw )

#define ReadClient( _hconn, _lpvoid, _lpdword )                                 \
    (lpEcb->ReadClient)( _hconn, _lpvoid, _lpdword );                           \
    TraceMsg( TF_SERVER, "ReadClient( Connid=0x%x  lpBuf=0x%x  lpdwSize=0x%x )",      \
        _hconn, _lpvoid, _lpdword )

#define ServerSupportFunction( _hconn, _dw, _lpvoid, _lpdword, _lpdword2 )                  \
    (lpEcb->ServerSupportFunction)( _hconn, _dw, _lpvoid, _lpdword, _lpdword2 );            \
    TraceMsg( TF_SERVER, "ServerSupportFunction( Connid=%x  dwService=0x%x  lpBuf=0x%x  lpdwSize=0x%x lpdwDataType=0x%x )",  \
        _hconn, _dw, _lpvoid, _lpdword, _lpdword2 )

#endif // _REFLECTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\textpars.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// TEXTPARSE.H - Text/plain parser header file
//

#ifndef _TEXTPARS_H_
#define _TEXTPARS_H_


class CTextPlainParse : public CBase
{
public:
    CTextPlainParse( LPECB lpEcb, LPSTR *lppszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    ~CTextPlainParse( );

    // Starts parsing data using infomation from server headers
    BOOL Parse( LPBYTE lpbData, LPDWORD lpdwParsed );

private:
    LPBYTE  _lpbData;                   // Memory containing send data
    LPBYTE  _lpbParse;                  // Current parse location into _lpbData

    CTextPlainParse( );

}; // CTextPlainParse

#endif // _TEXTPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\response.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// RESPONSE.H - 
//

#ifndef _RESPONSE_H_
#define _RESPONSE_H_

// globals
extern const char g_cszTableHeader[];
extern const char g_cszTableEnd[];

// Defines
#define RESPONSE_BUF_SIZE   4096

// METHODS
enum QUERYMETHOD {
    METHOD_UNKNOWN,
    METHOD_POST,
    METHOD_POSTMULTIPART,
    METHOD_GET,
    METHOD_POSTTEXTPLAIN
};

// Methods
BOOL SendSuccess( 
    QUERYMETHOD  eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwSize,
    LPDUMPTABLE lpDT );

BOOL SendFailure( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwSize,
    LPDUMPTABLE lpDT );

BOOL SendRedirect( LPECB lpEcb, LPSTR lpszURL );
BOOL SendEcho( LPECB lpEcb );
BOOL SendServerHeader( LPECB lpEcb );
BOOL OutputHTMLString( LPECB lpEcb, LPSTR lpszOut );
BOOL HexDump( 
        LPECB       lpEcb, 
        LPBYTE      lpbData, 
        DWORD       dwLength, 
        LPDUMPTABLE lpDT );

#endif // _RESPONSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\textpars.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// TEXTPARS.CPP - Parses text/plain submissions
//

#include "pch.h"

//
// Constructor / Destructor
//
CTextPlainParse::CTextPlainParse( 
                    LPECB lpEcb, 
                    LPSTR *lppszOut, 
                    LPSTR *lpszDebug,
                    LPDUMPTABLE lpDT )
    :CBase( lpEcb, lppszOut, lpszDebug, lpDT )
{
    DebugMsg( lpszOut, g_cszTableHeader, "<BR>\
(NOTE: To turn on detailed debugging information, add '?debug' to the end of action URL in the orginating HTML file.)\
<br>\
<H2>Text/Plain Form Data (METHOD=POST, ENCTYPE=TEXT/PLAIN)</H2>\
",
        "TBLMULTIFORM" );

} // CTextPlainParse( )

CTextPlainParse::~CTextPlainParse( )
{

} // ~CTextPlainParse( )

CTextPlainParse::Parse( LPBYTE lpbData, LPDWORD lpdwParsed )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "Parse()" );

    _lpbParse = _lpbData = lpbData;

    while ( (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes )
    {
        LPSTR lpszName  = NULL; // points to the "name" field
        LPSTR lpszValue = NULL; // points to the "value" field
        LPSTR lpszEqual = NULL; // points to the "=" sign
        CHAR  cTmp;

        lpszName = (LPSTR) _lpbParse;

        while (( *_lpbParse != '='  
              && (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes ))
              _lpbParse++;

        if ( *_lpbParse != '=' )
        {
            DebugMsg( lpszDebug, "Expected to find an '=' after %u (0x%x) bytes.",
                (LPBYTE)lpszName - _lpbData, (LPBYTE)lpszName - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        lpszEqual  = (LPSTR) _lpbParse;
        *lpszEqual = 0;     // terminate (save)

        _lpbParse++;        // move past

        lpszValue = (LPSTR) _lpbParse;

        while (( *_lpbParse != '\r'  
              && *_lpbParse != '\n'
              && (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes ))
              _lpbParse++;

        if (( *_lpbParse != '\r' ) && ( *_lpbParse != '\n' ))
        {
            DebugMsg( lpszDebug, "Expected to find a CR, LF, CRLF or LFCR after %u (0x%x) bytes.",
                (LPBYTE)lpszValue - _lpbData, (LPBYTE)lpszValue - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        cTmp = *_lpbParse;          // save
        *_lpbParse = 0;             // terminate

        DebugMsg( lpszOut, "<TR ID=TR%s><TD ID=TD%s>%s</TD><TD ID=%s>%s</TD></TR>",
            lpszName, lpszName, lpszName, lpszName, lpszValue );

        *_lpbParse = cTmp;         // restore
        *lpszEqual = '=';          // restore

        _lpbParse++;    // move past

        // A possible combination of CR, LF, CRLF or LFCR are acceptable.
        if (( *_lpbParse = '\r' ) || ( *_lpbParse = '\n' ))
        {
            _lpbParse++;    // move past
        }
    }

    DebugMsg( lpszDebug, "Parsed %u (0x%x) bytes.", ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );

Cleanup:
    // End table output
    StrCat( lpszOut, g_cszTableEnd );

    *lpdwParsed = _lpbParse - _lpbData;

    // indicates EOTable, this will be an empty table for text/plain
    lpDT[ 0 ].lpAddr = NULL;

    TraceMsg( TF_FUNC | TF_PARSE, "Parse() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // Parse()

/*****************************************************************************
//
// FUNCTION TEMPLATE
//
// ***************************************************************************
//
// What:    
//
// Desc:    
//
// In:
//
// Out:
//
// Return:
//
BOOL CTextPlainParse::( )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "()" );


    TraceMsg( TF_FUNC | TF_PARSE, "() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tools\make_altfont.cxx ===
//+-----------------------------------------------------------------------------
//
//  make_altfont.cxx
//
//  cthrash@microsoft.com, June 1998.
//
//
//  Compile and run this file to make the tables for src\intl\intlcore\altfont.cxx
//
//------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#ifndef WCHAR
typedef unsigned short WCHAR;
#endif

#ifndef BOOL
typedef int BOOL;
#endif

inline BOOL InRange( WCHAR chmin, WCHAR ch, WCHAR chmax)
{
    return (unsigned)(ch - chmin) <= (unsigned)(chmax - chmin);
}

int StrCmpIC( const WCHAR * s0, const WCHAR * s1 )
{
    int ch1, ch2;

    do {

        ch1 = *s0++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *s1++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

struct NAMEPAIR
{
    WCHAR * pszAName;
    WCHAR * pszBName;
};

// NB (cthrash) Data comes from chrispr in Office.

struct NAMEPAIR anpTable[] = 
{
    { L"\x0041\x0052\x884C\x6977\x9023\x7DBF\x4F53\x0048", L"Arphic Gyokailenmentai Heavy JIS" },
    { L"\x0041\x0052\x884C\x6977\x9023\x7DBF\x4F53\x004C", L"Arphic Gyokailenmentai Light JIS" },
    { L"\x0041\x0052\x884C\x6977\x66F8\x4F53\x0048", L"Arphic Gyokaisho Heavy JIS" },
    { L"\x0041\x0052\x884C\x6977\x66F8\x4F53\x004C", L"Arphic Gyokaisho Light JIS" },
    { L"\x0041\x0052\x6977\x66F8\x4F53 \x004D", L"Arphic Kaisho Medium JIS" },
    { L"\x0041\x0052\x52D8\x4EAD\x6D41\x0048", L"Arphic Kanteiryu Heavy JIS" },
    { L"\x0041\x0052\x53E4\x5370\x4F53\x0042", L"Arphic Koin-Tai Bold JIS" },
    { L"\x0041\x0052\x9ED2\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic Kuro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x884C\x6977\x66F8\x4F53\x0048", L"Arphic PGyokaisho Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x884C\x6977\x66F8\x4F53\x004C", L"Arphic PGyokaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x6977\x66F8\x4F53\x4F53 \x004D", L"Arphic PKaisho Medium JIS" },
    { L"\x0041\x0052\x0020\x0050\x52D8\x4EAD\x6D41\x0048", L"Arphic PKanteiryu Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x53E4\x5370\x4F53\x0042", L"Arphic PKoin-Tai Bold JIS" },
    { L"\x0041\x0052\x0020\x0050\x9ED2\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic PKuro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x30DA\x30F3\x884C\x6977\x66F8\x4F53 \x004C", L"Arphic PPengyokaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x30DA\x30F3\x6977\x66F8\x4F53\x004C", L"Arphic PPenkaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x96B7\x66F8\x4F53 \x004D", L"Arphic PReisho Medium JIS" },
    { L"\x0041\x0052\x0020\x0050\x767D\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic PSiro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x30DA\x30F3\x884C\x6977\x66F8\x4F53 \x004C", L"Arphic Pengyokaisho Light JIS" },
    { L"\x0041\x0052\x30DA\x30F3\x6977\x66F8\x4F53\x004C", L"Arphic Penkaisho Light JIS" },
    { L"\x0041\x0052\x96B7\x66F8\x4F53 \x004D", L"Arphic Reisho Medium JIS" },
    { L"\x0041\x0052\x767D\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic Siro-Maru-POP Heavy JIS" },
    { L"\xFF24\xFF26\x7279\x592A\x30B4\x30B7\x30C3\x30AF\x4F53", L"DFGothic-EB" },
    { L"\xFF24\xFF26\xFF30\x7279\x592A\x30B4\x30B7\x30C3\x30AF\x4F53", L"DFPGothic-EB" },
    { L"\xFF24\xFF26\x0050\x004F\x0050\x4F53", L"DFPOP-SB" },
    { L"\xFF24\xFF26\xFF30\x0050\x004F\x0050\x4F53", L"DFPPOP-SB" },
    { L"\x0048\x0047\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGGothicE" },
    { L"\x0048\x0047\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGGothicM" },
    { L"\x0048\x0047\x884C\x66F8\x4F53", L"HGGyoshotai" },
    { L"\x0048\x0047\x6559\x79D1\x66F8\x4F53", L"HGKyokashotai" },
    { L"\x0048\x0047\x660E\x671D\x0042", L"HGMinchoB" },
    { L"\x0048\x0047\x660E\x671D\x0045", L"HGMinchoE" },
    { L"\x0048\x0047\x0050\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGPGothicE" },
    { L"\x0048\x0047\x0050\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGPGothicM" },
    { L"\x0048\x0047\x0050\x884C\x66F8\x4F53", L"HGPGyoshotai" },
    { L"\x0048\x0047\x0050\x6559\x79D1\x66F8\x4F53", L"HGPKyokashotai" },
    { L"\x0048\x0047\x0050\x660E\x671D\x0042", L"HGPMinchoB" },
    { L"\x0048\x0047\x0050\x660E\x671D\x0045", L"HGPMinchoE" },
    { L"\x0048\x0047\x0050\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGPSoeiKakugothicUB" },
    { L"\x0048\x0047\x0050\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGPSoeiKakupoptai" },
    { L"\x0048\x0047\x0050\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGPSoeiPresenceEB" },
    { L"\x0048\x0047\x0053\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGSGothicE" },
    { L"\x0048\x0047\x0053\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGSGothicM" },
    { L"\x0048\x0047\x0053\x884C\x66F8\x4F53", L"HGSGyoshotai" },
    { L"\x0048\x0047\x0053\x6559\x79D1\x66F8\x4F53", L"HGSKyokashotai" },
    { L"\x0048\x0047\x0053\x660E\x671D\x0042", L"HGSMinchoB" },
    { L"\x0048\x0047\x0053\x660E\x671D\x0045", L"HGSMinchoE" },
    { L"\x0048\x0047\x0053\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGSSoeiKakugothicUB" },
    { L"\x0048\x0047\x0053\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGSSoeiKakupoptai" },
    { L"\x0048\x0047\x0053\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGSSoeiPresenceEB" },
    { L"\x0048\x0047\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGSoeiKakugothicUB" },
    { L"\x0048\x0047\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGSoeiKakupoptai" },
    { L"\x0048\x0047\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGSoeiPresenceEB" },
    { L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF", L"MS Gothic" },
    { L"\xFF2D\xFF33\x0020\x660E\x671D", L"MS Mincho" },
    { L"\xFF2D\xFF33\x0020\xFF30\x30B4\x30B7\x30C3\x30AF", L"MS PGothic" },
    { L"\xFF2D\xFF33\x0020\xFF30\x660E\x671D", L"MS PMincho" },
    { L"\x4EFF\x5B8B\x005F\x0047\x0042\x0047\x0032\x0033\x0031\x0032", L"FangSong_GB2312" },
    { L"\x6977\x4F53\x005F\x0047\x0042\x0047\x0032\x0033\x0031\x0032", L"KaiTi_GB2312" },
    { L"\x96B6\x4E66", L"LiSu" },
    { L"\x65B0\x5B8B\x4F53", L"NSimSun" },
    { L"\x9ED1\x4F53", L"SimHei" },
    { L"\x5B8B\x4F53", L"SimSun" },
    { L"\x5E7C\x5706", L"YouYuan" },
    { L"\x534e\x6587\x5b8b\x4f53", L"STSong" },
    { L"\x534e\x6587\x4e2d\x5b8b", L"STZhongsong" },
    { L"\x534e\x6587\x6977\x4f53", L"STKaii" },
    { L"\x534e\x6587\x4eff\x5b8b", L"STFangsong" },
    { L"\x534e\x6587\x7ec6\x9ed1", L"STXihei" },
    { L"\x534e\x6587\x96b6\x4e66", L"STLiti" },
    { L"\x534e\x6587\x884c\x6977", L"STXingkai" },
    { L"\x534e\x6587\x65b0\x9b4f", L"STXinwei" },
    { L"\x534e\x6587\x7425\x73c0", L"STHupo" },
    { L"\x534e\x6587\x5f69\x4e91", L"STCaiyun" },
    { L"\x65b9\x6b63\x59da\x4f53\x7b80\x4f53", L"FZYaoTi" },
    { L"\x65b9\x6b63\x8212\x4f53\x7b80\x4f53", L"FZShuTi" },
    { L"\xD734\xBA3C\xC544\xBBF8\xCCB4", L"Ami R" },
    { L"\xBC14\xD0D5", L"Batang" },
    { L"\xBC14\xD0D5\xCCB4", L"BatangChe" },
    { L"\xB3CB\xC6C0", L"Dotum" },
    { L"\xB3CB\xC6C0\xCCB4", L"DotumChe" },
    { L"\xD734\xBA3C\xC5D1\xC2A4\xD3EC", L"Expo M" },
    { L"\xAD74\xB9BC", L"Gulim" },
    { L"\xAD74\xB9BC\xCCB4", L"GulimChe" },
    { L"\xAD81\xC11C", L"Gungsuh" },
    { L"\xAD81\xC11C\xCCB4", L"GungsuhChe" },
    { L"\x0048\x0059\xBAA9\xAC01\xD30C\xC784\x0042", L"HYPMokGak-Bold" },
    { L"\x0048\x0059\xC595\xC740\xC0D8\xBB3C\x004D", L"HYShortSamul-Medium" },
    { L"\x0048\x0059\xC5FD\xC11C\x004D", L"HYPost-Medium" },
    { L"\xD734\xBA3C\xB465\xADFC\xD5E4\xB4DC\xB77C\xC778", L"Headline R" },
    { L"\xD734\xBA3C\xBAA8\xC74C\x0054", L"MoeumT R" },
    { L"\xD734\xBA3C\xD3B8\xC9C0\xCCB4", L"Pyunji R" },
    { L"\x0048\x0059\xACAC\xACE0\xB515", L"HYGothic-Extra" },
    { L"\x0048\x0059\xC2E0\xBB38\xBA85\xC870", L"HYSinMun-MyeongJo" },
    { L"\x0048\x0059\xACAC\xBA85\xC870", L"HYMyeongJo-Extra" },
    { L"\x0048\x0059\xD0C0\xC790\x004D", L"HYTaJa-Medium" },
    { L"\xD734\xBA3C\xAC01\xC9C4\xD5E4\xB4DC\xB77C\xC778", L"Headline Sans R" },
    { L"\xD734\xBA3C\xC61B\xCCB4", L"Yet R" },
    { L"\x6A19\x6977\x9AD4", L"DFKai-SB" },
    { L"\x83EF\x5EB7\x5137\x7C97\x9ED1", L"DFLiHeiBold" },
    { L"\x83EF\x5EB7\x65B0\x5137\x7C97\x9ED1", L"DFLiHeiBold(P)" },
    { L"\x7D30\x660E\x9AD4", L"MingLiU" },
    { L"\x7d30\x660e\x9ad4_HKSCS", L"MingLiU_HKSCS" },
    { L"\x65B0\x7D30\x660E\x9AD4", L"PMingLiU" },
    { L"\xff28\xff27\xff7a\xff9e\xff7c\xff6f\xff78\x0045-PRO", L"\xff28\xff27\x30b4\x30b7\x30c3\x30af\x0045-PRO" } // HACK (cthrash) For Outlook/OE (see IE5 #76530)
};
    
#define NUM sizeof(anpTable) / sizeof(WCHAR *)

void OutString( FILE *f, WCHAR * pch )
{
    int fLastWasHex = 0;
    
    printf("L\"");
    while (*pch)
    {
        WCHAR c = *pch++;

        if (   c < 128
            && (   !fLastWasHex
                || (   !InRange(L'0', c, L'9')
                    && !InRange(L'a', c, L'f')
                    && !InRange(L'A', c, L'F'))))
        {
            fputc(c,f);
            fLastWasHex = 0;
        }
        else
        {
            fprintf(f,"\\x%04x", c);
            fLastWasHex = 1;
        }
    }
    fprintf(f, "\"");
}

struct NAMEINDEX
{
    WCHAR * pchName;
    int nIndex;
};

struct NAMEINDEX *aniTable;

void MakeTable()
{
    int i;
    struct NAMEINDEX * pni;
    
    aniTable = (struct NAMEINDEX *)malloc( NUM * sizeof(struct NAMEINDEX ));

    pni = aniTable;
    
    for (i=0; i<NUM/2; i++)
    {
        pni->pchName = anpTable[i].pszAName;
        pni->nIndex = i;
        pni++;
        pni->pchName = anpTable[i].pszBName;
        pni->nIndex = NUM + i;
        pni++;
    }
}

int __cdecl cmpfunc( const void *v0, const void *v1)
{
    return StrCmpIC( ((struct NAMEINDEX *)v0)->pchName,
                     ((struct NAMEINDEX *)v1)->pchName );
}

void main(void)
{
    const int c = NUM;
    int i;

    MakeTable();
    
    qsort( aniTable, c, sizeof(struct NAMEINDEX), cmpfunc );

    for (i=0; i<c; i++)
    {
        printf("const TCHAR g_pszAltFontName%03d[] = ", i);
        OutString(stdout, aniTable[i].pchName);
        printf(";\n");
    }

    printf("\nconst TCHAR * const pszAltFontNames[] = \n{\n");
    for (i=0; i<c; i++)
    {
        printf("   g_pszAltFontName%03d,\n", i);
    }
    printf("};\n");

    printf("\nconst TCHAR * const pszAltFontNamesAlt[] = \n{\n");
    for (i=0; i<c; i++)
    {
        struct NAMEINDEX ni;
        struct NAMEINDEX *pni;

        ni.pchName = aniTable[i].nIndex >= NUM
                     ? anpTable[aniTable[i].nIndex-NUM].pszAName
                     : anpTable[aniTable[i].nIndex].pszBName;

        pni = (struct NAMEINDEX *)bsearch( &ni,
                                           aniTable,
                                           c,
                                           sizeof(struct NAMEINDEX),
                                           cmpfunc);

        printf("   g_pszAltFontName%03d,\n", pni - aniTable);
    }
    printf("};\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\test\reflectr\response.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// RESPONSE.CPP - Contains possible responses
//

#include "pch.h"


// Globals
const char g_cszTableHeader[] = "%s \
<TABLE ID=%s BORDER=1> \
<TR> \
  <TH WIDTH=40%%>Variable Name</TH> \
  <TH WIDTH=60%%>Value</TH> \
</TR>";

const char g_cszTableEnd[] = "</TABLE>";

// List of known server variables
LPSTR g_lpServerVars[] = {
        "AUTH_TYPE",
        "CONTENT_LENGTH",
        "CONTENT_TYPE",
        "GATEWAY_INTERFACE",
        "LOGON_USER",
        "PATH_INFO",
        "PATH_TRANSLATED",
        "QUERY_STRING",
        "REMOTE_ADDR",
        "REMOTE_HOST",
        "REQUEST_METHOD",
        "SCRIPT_MAP",
        "SCRIPT_NAME",
        "SERVER_NAME",
        "SERVER_PORT",
        "SERVER_PORT_SECURE",
        "SERVER_SOFTWARE",
        "URL" 
    };

#define FROMHEX( _v ) \
    ( ( _v >= 48 ) && ( _v <= 57 ) ? _v - 48 : \
    ( ( _v >= 65 ) && ( _v <= 70 ) ? _v + 10 - 65 : 0 ) )

//
// What:    UnCanonicalize
//
// Desc:    Un-escapes strings
//
BOOL UnCanonicalize( LPSTR lpszStart, LPSTR lpszUnURL , LPDWORD lpdwSize )
{
    LPSTR lps = lpszStart;
    DWORD cb  = 0;

    while (( *lps ) && ( cb < *lpdwSize ))
    {
        if ( *lps == '%' )
        {
            lps++;
            lpszUnURL[ cb ]  = 16 * FROMHEX( *lps);
            lps++;
            lpszUnURL[ cb ] += FROMHEX( *lps);
        } 
        else if ( *lps == '+' )
        {
            lpszUnURL[ cb ] = 32;
        }
        else 
        {
            lpszUnURL[ cb ] = *lps;
        }
        cb++;
        lps++;
    }

    lpszUnURL[ cb ] = 0;  // paranoid
    *lpdwSize = cb;

    return TRUE;

} // UnCanonicalize( )


//
// What:    DumpFormDataFromPost
//
// Desc:    Dumps the fields and values in a form from a POST.
//
BOOL DumpFormDataFromPost( LPECB lpEcb )
{
    BOOL  fReturn = TRUE;
    DWORD dwSize;

    static char szUnparsed[] = "The unparsed Form submit string is: <FONT FACE=\"Courier New\">";
    static char szUnFont[] = "</FONT>";

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpFormDataFromPost()" );

    if ( fReturn )
    {   // header and the beginning of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>Form Data (METHOD=POST)</H2>", "TBLPOST" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        int i = 0;
        LPSTR lpszStart = (LPSTR) lpEcb->lpbData;
        while (( fReturn ) && ( lpszStart ))
        {
            CHAR  cTmpEnd;
            LPSTR lpszEquals = StrChr( lpszStart, '=' );
            if ( !lpszEquals )
                break;  // no more data

            LPSTR lpszEnd    = StrChr( lpszEquals, '&' );

            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd;     // save
                *lpszEnd = 0;
            }

            CHAR cTmp = *lpszEquals;    // save
            *lpszEquals = 0;

            CHAR szBuffer[ 4096 ];
            CHAR szUnURL[ 2048 ];
            dwSize = sizeof( szUnURL );
            fReturn = UnCanonicalize( lpszEquals + 1, szUnURL, &dwSize );
            if ( fReturn )
            {
                dwSize = wsprintf( szBuffer, 
                    "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                    i, i, lpszStart, lpszStart, szUnURL );
                fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
            }

            *lpszEquals = cTmp;         // restore

            if ( lpszEnd )
            {
                *lpszEnd = cTmpEnd;     // restore
                lpszEnd++;
            }

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end of the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // display unparsed information
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnparsed );
        fReturn = WriteClient( lpEcb->ConnID, szUnparsed, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        dwSize = 1 + lstrlen( (LPSTR) lpEcb->lpbData );
        fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpbData, &dwSize, HSE_IO_ASYNC );
    }

    // end FONT tag
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnFont );
        fReturn = WriteClient( lpEcb->ConnID, szUnFont, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpFormDataFromPost() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpFormDataFromPost( )

//
// What:    DumpQueryStringDataFromGet
//
// Desc:    Dumps the fields and values in a form from a GET.
//
BOOL DumpQueryStringDataFromGet( LPECB lpEcb )
{
    BOOL fReturn = TRUE;
    LPSTR lpszBuffer;
    DWORD dwSize;

    static char szUnparsed[] = "The unparsed QueryString is: <FONT FACE=\"Courier New\">";
    static char szUnFont[] = "</FONT>";

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpQueryStringDataFromGet()" );

    if ( fReturn )
        fReturn = GetServerVarString( lpEcb, "QUERY_STRING", &lpszBuffer, NULL );

    if ( fReturn )
    {   // header and the beginning of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>QueryString Data(METHOD=GET)</H2>", "TBLGET" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        int i = 0;
        LPSTR lpszStart = lpszBuffer;
        while (( fReturn ) && ( lpszStart ))
        {
            CHAR cTmpEnd;
            LPSTR lpszEquals = StrChr( lpszStart, '=' );
            LPSTR lpszEnd    = StrChr( lpszEquals, '&' );

            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd;     // save
                *lpszEnd = 0;
            }

            CHAR cTmp = *lpszEquals;    // save
            *lpszEquals = 0;

            CHAR szBuffer[ 4096 ];
            CHAR szUnURL[ 2048 ];
            dwSize = sizeof( szUnURL );
            fReturn = UnCanonicalize( lpszEquals + 1, szUnURL, &dwSize );
            if ( fReturn )
            {
                dwSize = wsprintf( szBuffer, 
                    "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                    i, i, lpszStart, lpszStart, szUnURL );
                fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
            }

            *lpszEquals = cTmp;         // restore

            if ( lpszEnd )
            {
                *lpszEnd = cTmpEnd;     // restore
                lpszEnd++;
            }

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // display unparsed information
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnparsed );
        fReturn = WriteClient( lpEcb->ConnID, szUnparsed, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        dwSize = 1 + lstrlen( lpszBuffer );
        fReturn = WriteClient( lpEcb->ConnID, lpszBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // end font tag
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnFont );
        fReturn = WriteClient( lpEcb->ConnID, szUnFont, &dwSize, HSE_IO_ASYNC );
    }

    // clean up
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpQueryStringDataFromGet() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpQueryStringDataFromGet( )

//
// What:    DumpServerVariables
//
// Desc:    Dumps the current server variable settings from the result of
//          a form submission.
//
BOOL DumpServerVariables( LPECB lpEcb )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;
    DWORD dwSize;
    int   i = 0;    // counter

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpServerVariables()" );

    if ( fReturn )
    {   // header and the begging of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>Server Variables</H2>", "TBLSERVERVARS" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // try the known ones
    for( ; ( fReturn ) && ( i < ARRAYOF( g_lpServerVars ) ); i++ )
    {
        GetServerVarString( lpEcb, g_lpServerVars[ i ], &lpszBuffer, NULL );

        if ( lpszBuffer )
        {
            CHAR szBuffer[ 512 ];
            dwSize = wsprintf( szBuffer, 
                "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                i, i, g_lpServerVars[ i ], g_lpServerVars[ i ], lpszBuffer );
            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
        }

        GlobalFree( lpszBuffer );
        lpszBuffer = NULL;
    }

    // try the HTTP_ALL from header that the server ignores
    if ( fReturn )
        fReturn = GetServerVarString( lpEcb, "ALL_HTTP", &lpszBuffer, NULL );

    if (( fReturn ) && ( lpszBuffer ))
    {
        LPSTR lpszStart = lpszBuffer;
        while (( fReturn ) && ( lpszStart ))
        {
            char cTmpEnd;

            LPSTR lpszColon = StrChr( lpszStart, ':' );
            LPSTR lpszEnd   = StrStr( lpszColon, "HTTP_" );
            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd; // save
                *lpszEnd = 0;
            }

            char cTmp = *lpszColon; // save
            *lpszColon = 0;

            CHAR szBuffer[ 4096 ];
            dwSize = wsprintf( szBuffer, 
                "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                i, i, lpszStart, lpszStart, lpszColon + 1 );
            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );

            *lpszColon = cTmp;      // restore

            if ( lpszEnd )
                *lpszEnd = cTmpEnd; // restore

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // clean up
    GlobalFree( lpszBuffer );
    lpszBuffer = NULL;

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpServerVariables() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

//
// What:    DumpOutput
//
// Desc:    Generate reponse body page after headers and the HTML header
//          has been.
//
BOOL DumpOutput( 
        QUERYMETHOD eMethod, 
        LPECB       lpEcb, 
        LPSTR       lpszOut, 
        LPSTR       lpszDebug )
{
    BOOL  fReturn;
    DWORD dwSize;
    char  szBuffer[ RESPONSE_BUF_SIZE ];

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpOutput()" );

    // Display form data
    switch ( eMethod )
    {
    case METHOD_POST:
        fReturn = DumpFormDataFromPost( lpEcb );
        break;

    case METHOD_GET:
        fReturn = DumpQueryStringDataFromGet( lpEcb );
        break;

    case METHOD_POSTTEXTPLAIN:
    case METHOD_POSTMULTIPART:
        if ( lpszOut )
        {
            dwSize = 1 + lstrlen( lpszOut );
            fReturn = WriteClient( lpEcb->ConnID, lpszOut, &dwSize, HSE_IO_ASYNC );
        }
        break;

    default:
        StrCpy( szBuffer, "<H2>???? (METHOD=UNKNOWN)</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // Dump the server variables
    if ( fReturn )
        fReturn = DumpServerVariables( lpEcb );

    // Dump any debugging messages
    if (( fReturn ) && ( lpszDebug ))
    {
        StrCpy( szBuffer, "<H2>Debugging Output</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );

        if ( fReturn )
            fReturn = OutputHTMLString( lpEcb, lpszDebug );
    }

    // Dump any server log entries
    if (( fReturn ) && ( lpEcb->lpszLogData[ 0 ] ))
    {
        StrCpy( szBuffer, "<H2>Server Log Entry</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
        if ( fReturn )
        {
            dwSize = 1 + lstrlen( lpEcb->lpszLogData );
            fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpszLogData, &dwSize, HSE_IO_ASYNC );
        }
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpOutput() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpOutput( )

// 
// What:    SendSuccess
//
// Desc:    Sends client an HTML response for a successful upload. Just a
//          green screen with "SUCCESS!" in a big header.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendSuccess( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwParsed,
    LPDUMPTABLE lpDT ) 
{
    BOOL  fReturn = TRUE;    // assume success
    CHAR  szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    BOOL  fDebug = FALSE;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendSuccess( )" );

    // Generate on the fly so
    // fReturn = SendServerHeader( lpEcb );

    if ( fReturn )
    {
        StrCpy( szBuffer, "\
            <HTML>\
            <HEAD>\
            <TITLE>Form Submission Reflector</TITLE>\
            </HEAD>\
            <BODY bgcolor=#00FF00>\
            <FONT FACE=\"ARIAL,HELVETICA\" SIZE=2>\
            Submission Result <INPUT TYPE=TEXT NAME=RESULT VALUE=\"SUCCESS!\">" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
        fReturn = CheckForDebug( lpEcb, &fDebug );

    if ( fReturn )
    {
        if ( fDebug )
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, lpszDebug );
        else
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, NULL );
    }

    if (( fReturn ) && ( fDebug ))
        fReturn = HexDump( lpEcb, lpbData, dwParsed, lpDT );

    if ( fReturn )
    {
        StrCpy( szBuffer, "</BODY></HTML>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendSuccess( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )

// 
// What:    SendFailure
//
// Desc:    Sends client an HTML response for a failed upload. Just a
//          red screen with "FAILED!" in a big header.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendFailure( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwParsed,
    LPDUMPTABLE lpDT ) 
{
    BOOL  fReturn = TRUE;    // assume success
    CHAR  szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    BOOL  fDebug = FALSE;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendFailure( )" );

    // fReturn = SendServerHeader( lpEcb );

    if ( fReturn )
    {
        StrCpy( szBuffer, "\
            <HTML>\
            <HEAD>\
            <TITLE>Form Submission Reflector</TITLE>\
            </HEAD>\
            <BODY bgcolor=#FF0000>\
            <FONT FACE=\"ARIAL,HELVETICA\" SIZE=2>\
            Submission Result <INPUT TYPE=TEXT NAME=RESULT VALUE=\"FAILED!\">" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
        fReturn = CheckForDebug( lpEcb, &fDebug );

    if ( fReturn )
    {
        if ( fDebug )
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, lpszDebug );
        else
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, NULL );
    }

    if (( fReturn ) && ( fDebug ))
        fReturn = HexDump( lpEcb, lpbData, dwParsed, lpDT );

    if ( fReturn )
    {
        StrCpy( szBuffer, "</BODY></HTML>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendFailure( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )


// 
// What:    SendRedirect
//
// Desc:    Redirects to another URL.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendRedirect( LPECB lpEcb, LPSTR lpszURL ) 
{
    BOOL fReturn = TRUE;    // assume success
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize = 1 + lstrlen( lpszURL );
    DWORD dw;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendRedirect( )" );

    fReturn = ServerSupportFunction( lpEcb->ConnID, HSE_REQ_SEND_URL_REDIRECT_RESP,
        lpszURL, &dwSize, &dw );

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendRedirect( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )


//
// What:    SendEcho
//
// Desc:    Sends client an echo for everything that it sent to us.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
BOOL SendEcho( LPECB lpEcb )
{
    BOOL fReturn = TRUE;    // assume success
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    LPVOID  lpMoreData = NULL;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendEcho( )" );

    BOOL fDownloadComplete = (lpEcb->cbTotalBytes == lpEcb->cbAvailable );

    TraceMsg( TF_RESPONSE, "Does cbTotalBytes(%u) == cbAvailable(%u)? %s",
        lpEcb->cbTotalBytes, lpEcb->cbAvailable, 
        BOOLTOSTRING( fDownloadComplete ) );

    if ( !fDownloadComplete )
    {   // Get the rest of the data
        dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        lpMoreData = (LPVOID) GlobalAlloc( GPTR, dwSize );
        fReturn = ReadData( lpEcb, lpMoreData, dwSize );
        if ( !fReturn )
            goto Cleanup;
    }

    TraceMsg( TF_RESPONSE, "Total Bytes: %u\n%s", 
        lpEcb->cbAvailable, lpEcb->lpbData );

    // Server header info...
    fReturn = SendServerHeader( lpEcb );
    if ( !fReturn )
        goto Cleanup;

    // Create top part of response and send it
    StrCpy( szBuffer, "<HTML><BODY bgcolor=#0000FF><PRE>" );
    dwSize = 1 + lstrlen( szBuffer );
    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

    // and echo it back...
    dwSize = lpEcb->cbAvailable;
    fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpbData, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

    // and anything else that was sent...
    if ( lpMoreData ) 
    {
        dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        fReturn = WriteClient( lpEcb->ConnID, lpMoreData, &dwSize, HSE_IO_ASYNC );
        if ( !fReturn )
            goto Cleanup;
    }

    // Create bottom part of response and send it
    StrCpy( szBuffer, "</PRE></BODY></HTML>" );
    dwSize = 1 + lstrlen( szBuffer );
    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

Cleanup:
    if ( lpMoreData )
        GlobalFree( lpMoreData );

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendEcho( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendEcho( )


//
// What:    SendServerHeader
//
// Desc:    This sends a complete HTTP server response header including the 
//          status, server version, message time, and MIME version. The ISAPI 
//          application should append other HTTP headers such as the content 
//          type and content length, followed by an extra "\r\n". This function 
//          only takes textual data, up to the first '\0' terminator
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
BOOL SendServerHeader( LPECB lpEcb )
{
    BOOL fReturn;
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize, dwParam;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendServerHeader( )" );


    TraceMsg( TF_RESPONSE, "Sending Pre Header: %s", szBuffer );

    dwSize = wsprintf( szBuffer, "200 OK" );
    dwParam = 0;
    fReturn = ServerSupportFunction( lpEcb->ConnID, HSE_REQ_SEND_RESPONSE_HEADER,
        szBuffer, &dwSize, &dwParam );
    if ( !fReturn )
        goto Cleanup;

    TraceMsg( TF_RESPONSE, "Sending Post Header: %s", szBuffer );

    dwSize = wsprintf( szBuffer, "Content-Type: text/html\r\n" );

    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;


Cleanup:
    TraceMsg( TF_FUNC | TF_RESPONSE, "SendServerHeader( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // SendServerHeader( )

//
// What:    OutputHTMLString
//
// Desc:    Outputs HTML to client. Simply changes '\n's to <BR>s.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//          lpszOut string to translate to HTML.
//
BOOL OutputHTMLString( LPECB lpEcb, LPSTR lpszOut )
{
    BOOL  fReturn = TRUE;
    LPSTR lpstr;
    DWORD dwSize;

    TraceMsg( TF_FUNC | TF_RESPONSE, "OutputHTMLString()" );

    if( *lpszOut )
    {
        lpstr = lpszOut;
        while (( *lpstr ) && ( fReturn))
        {
            lpszOut = lpstr;
            lpstr++;

            while (( *lpstr ) && ( *lpstr != '\n' ))
                lpstr++;

            CHAR cTmp = *lpstr;     // save
            *lpstr = 0;

            dwSize = 1 + lstrlen( lpszOut );
            fReturn = WriteClient( lpEcb->ConnID, lpszOut, &dwSize, HSE_IO_ASYNC );

            *lpstr = cTmp;          // restore

            if ( fReturn )
            {
                dwSize  = 4;
                fReturn = WriteClient( lpEcb->ConnID, "<BR>", &dwSize, HSE_IO_ASYNC );
            }
        }
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "OutputHTMLString() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // OutputHTMLString( )

// 
// What:    HexDump
//
// Desc:    Dumps a HEX dump to the client using HTML. (16-byte rows)
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//          lpbData is the data to be dumped
//          dwLength is the length of the dump.
//          lpDT is DUMPTABLE which contains information about what the
//              parser found while parsing. The end of the DT is indicated
//              by a NULL lpAddr.
//
// Return:  Return a pointer to the formatted output buffer.
//
BOOL HexDump( 
        LPECB lpEcb,
        LPBYTE lpbData, 
        DWORD dwLength, 
        LPDUMPTABLE lpDT )
{
    BOOL   fReturn;
    DWORD  cb           = 0;            // number of bytes processed
    DWORD  cbDT         = 0;            // number of DTs processed
    DWORD  cbComment    = 0;            // number of DT comments processed
    LPBYTE lpb          = lpbData;      // current data byte to be processed
    DWORD  dwColor      = 0x000000;     // color to output text in
    LPBYTE lpbStartLine = lpb;          // keeps track of where this line begins
                                        // for the string dump
    BOOL   fKeepGoing   = TRUE;         // exit flag
    CHAR   szBuffer[ 4096 ];            // output buffer
    CHAR   szString[ 512 ];             // "String Dump" output buffer
    DWORD  cbBuf, cbStr;                // helper count bytes for buffers

    // Output Dump Header
    cbBuf = wsprintf( szBuffer, "\
        <H2>Parser Commented Request Dump</H2>\
        <FONT FACE=\"Courier\">\
        <TABLE colpadding=2>\
        <TR><TD>Offset</TD><TD>Hex Dump</TD><TD>String Dump</TD><TD>Comments</TD></TR>" );

    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );

    while (( fReturn ) && ( fKeepGoing ))
    {
        if ( cb == 0 )
        {   // beginning of every row....
            if (( cbDT ) 
               && ( ( lpDT[ cbDT ].lpAddr - lpb ) > 64 ))
            {
                // eliminates "big" body data (like binary files)
                cbBuf = wsprintf( szBuffer, "<TR><TD>Skipping...</TD><TD>.</TD><TD>.</TD><TD>.</TD></TR>" );   

                // jump to one row before the next DT point
                lpb = (LPBYTE) ( ( ( (DWORD) lpDT[ cbDT ].lpAddr / 16 ) - 1 ) * 16 );
            } 
            else 
            {
                cbBuf = 0;
            }

            // Output 0xXXXXXXXX (NNNNNN): and change the color
            cbBuf += wsprintf( &szBuffer[ cbBuf ], 
                "<TR><TD>0x%-8.8x (%-6.6u):</TD><TD><FONT COLOR=%-6.6x>",
                lpb - lpbData, lpb - lpbData, dwColor );

            // starting color on "String Dump"
            cbStr = wsprintf( szString, "<FONT COLOR=%-6.6x>", dwColor );
        }

        if ( lpb < lpbData + dwLength )
        {   // middle of every row...

            // color change if needed
            while (( lpDT[ cbDT ].lpAddr )
               && ( lpb >= lpDT[ cbDT ].lpAddr ))
            {
                dwColor = lpDT[ cbDT ].dwColor;
                cbBuf += wsprintf( &szBuffer[ cbBuf ], "</FONT><FONT COLOR=%-6.6x>", dwColor );

                cbStr += wsprintf( &szString[ cbStr ], "</FONT><FONT COLOR=%-6.6x>", dwColor );

                cbDT++;
            }

            // output hex number
            cbBuf += wsprintf( &szBuffer[ cbBuf ], "%-2.2x ", *lpb );

            // output "String Dump" character
            cbStr += wsprintf( &szString[ cbStr ], "%c", 
                ( ( *lpb < 32 || *lpb == 127 ) ? '.' : ( ( *lpb == 32 ) ? '_' : *lpb ) ) );

            lpb++;

        }

        cb++;   // always count even if there is no more data

        if ( cb == 16 )
        {   // end of every row...

            // terminate FONT tags and append "String Dump"
            cbStr += wsprintf( &szString[ cbStr ], "</FONT>" );
            cbBuf += wsprintf( &szBuffer[ cbBuf ], "</FONT></TD><TD>%s</TD>",
                szString );

            // skip NULL comments
            while (( lpDT[ cbComment ].lpAddr ) 
                  && ( !lpDT[ cbComment ].lpszComment ))
                  cbComment++;  

            // don't allow comments to get ahead of the bits
            if (( lpDT[ cbComment ].lpAddr ) && ( cbComment < cbDT )) 
            {
                cbBuf += wsprintf( &szBuffer[ cbBuf ], 
                    "<TD><FONT COLOR=%-6.6x>%s</FONT></TD></TR>",
                    lpDT[ cbComment ].dwColor, lpDT[ cbComment ].lpszComment );
                cbComment++;
            } 
            else 
            {
                cbBuf += wsprintf( &szBuffer[ cbBuf ], "<TD><BR></TD></TR>" );
            }

            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );

            cb = 0;
            lpbStartLine = lpb;

            if ( lpb >= lpbData + dwLength )
                fKeepGoing = FALSE;
        }
    }

    // end the table
    if ( fReturn )
    {
        cbBuf = wsprintf( szBuffer, "</TABLE></FONT>" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );
    }

    return fReturn;
} // HexDump( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\trixacc.h ===
//	trixacc.h
//	Private interface for ITriEditAccess
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __TRIXACC_PRIVATE_H__
#define __TRIXACC_PRIVATE_H__


typedef interface ITriEditExtendedAccess ITriEditExtendedAccess;


DEFINE_GUID(IID_ITriEditExtendedAccess, 0x5387A2AE,0x0D6A,0x11d3,0x96,0x34,0x00,0xC0,0x4f,0x79,0xef,0xc4);

MIDL_INTERFACE("5387A2AE-0D6A-11d3-9634-00C04F79EFC4")
ITriEditExtendedAccess : public IUnknown
{
	public:
     STDMETHOD(GetCharsetFromStream)( IStream* piStream, BSTR* pbstrCodePage);
    
};

#endif //__TRIXACC_PRIVATE_H__

// End of trixacc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\designer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */


/* File created by MIDL compiler version 3.02.88 */
/* at Fri May 22 18:46:33 1998
 */
/* Compiler settings for d:\devbin\shell\v6\idl\DESIGNER.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none, no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __DESIGNER_h__
#define __DESIGNER_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IActiveDesigner_FWD_DEFINED__
#define __IActiveDesigner_FWD_DEFINED__
typedef interface IActiveDesigner IActiveDesigner;
#endif 	/* __IActiveDesigner_FWD_DEFINED__ */


#ifndef __ICodeNavigate_FWD_DEFINED__
#define __ICodeNavigate_FWD_DEFINED__
typedef interface ICodeNavigate ICodeNavigate;
#endif 	/* __ICodeNavigate_FWD_DEFINED__ */


#ifndef __ISelectionContainer_FWD_DEFINED__
#define __ISelectionContainer_FWD_DEFINED__
typedef interface ISelectionContainer ISelectionContainer;
#endif 	/* __ISelectionContainer_FWD_DEFINED__ */


#ifndef __ITrackSelection_FWD_DEFINED__
#define __ITrackSelection_FWD_DEFINED__
typedef interface ITrackSelection ITrackSelection;
#endif 	/* __ITrackSelection_FWD_DEFINED__ */


#ifndef __IProfferTypeLib_FWD_DEFINED__
#define __IProfferTypeLib_FWD_DEFINED__
typedef interface IProfferTypeLib IProfferTypeLib;
#endif 	/* __IProfferTypeLib_FWD_DEFINED__ */


#ifndef __IProvideDynamicClassInfo_FWD_DEFINED__
#define __IProvideDynamicClassInfo_FWD_DEFINED__
typedef interface IProvideDynamicClassInfo IProvideDynamicClassInfo;
#endif 	/* __IProvideDynamicClassInfo_FWD_DEFINED__ */


#ifndef __IExtendedObject_FWD_DEFINED__
#define __IExtendedObject_FWD_DEFINED__
typedef interface IExtendedObject IExtendedObject;
#endif 	/* __IExtendedObject_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "servprov.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0000
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1997 Microsoft Corporation. All Rights Reserved.
//
//  File: designer.h
//
//--------------------------------------------------------------------------
#ifndef _DESIGNER_H_
#define _DESIGNER_H_
const GUID CATID_Designer =
{0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x00, 0xaa, 0x00, 0x62, 0xbe, 0x57};


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0000_v0_0_s_ifspec;

#ifndef __IActiveDesigner_INTERFACE_DEFINED__
#define __IActiveDesigner_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveDesigner
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IActiveDesigner __RPC_FAR *LPACTIVEDESIGNER;


EXTERN_C const IID IID_IActiveDesigner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51aae3e0-7486-11cf-a0C2-00aa0062be57")
    IActiveDesigner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeClassID( 
            /* [out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeMiscStatusFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPersistenceInterface( 
            /* [in] */ REFIID riidPersist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveRuntimeState( 
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void __RPC_FAR *pObjStgMed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtensibilityObject( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveDesignerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveDesigner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveDesigner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeClassID )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeMiscStatusFlags )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPersistenceInterface )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riidPersist);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveRuntimeState )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void __RPC_FAR *pObjStgMed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtensibilityObject )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut);
        
        END_INTERFACE
    } IActiveDesignerVtbl;

    interface IActiveDesigner
    {
        CONST_VTBL struct IActiveDesignerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveDesigner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveDesigner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveDesigner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveDesigner_GetRuntimeClassID(This,pclsid)	\
    (This)->lpVtbl -> GetRuntimeClassID(This,pclsid)

#define IActiveDesigner_GetRuntimeMiscStatusFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetRuntimeMiscStatusFlags(This,pdwMiscFlags)

#define IActiveDesigner_QueryPersistenceInterface(This,riidPersist)	\
    (This)->lpVtbl -> QueryPersistenceInterface(This,riidPersist)

#define IActiveDesigner_SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed)	\
    (This)->lpVtbl -> SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed)

#define IActiveDesigner_GetExtensibilityObject(This,ppvObjOut)	\
    (This)->lpVtbl -> GetExtensibilityObject(This,ppvObjOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveDesigner_GetRuntimeClassID_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IActiveDesigner_GetRuntimeClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_GetRuntimeMiscStatusFlags_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);


void __RPC_STUB IActiveDesigner_GetRuntimeMiscStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_QueryPersistenceInterface_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [in] */ REFIID riidPersist);


void __RPC_STUB IActiveDesigner_QueryPersistenceInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_SaveRuntimeState_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [in] */ REFIID riidPersist,
    /* [in] */ REFIID riidObjStgMed,
    /* [in] */ void __RPC_FAR *pObjStgMed);


void __RPC_STUB IActiveDesigner_SaveRuntimeState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_GetExtensibilityObject_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut);


void __RPC_STUB IActiveDesigner_GetExtensibilityObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveDesigner_INTERFACE_DEFINED__ */


#ifndef __ICodeNavigate_INTERFACE_DEFINED__
#define __ICodeNavigate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeNavigate
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ICodeNavigate __RPC_FAR *LPCODENAVIGATE;


EXTERN_C const IID IID_ICodeNavigate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c4-7436-11ce-8034-00aa006009fa")
    ICodeNavigate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayDefaultEventHandler( 
            /* [in] */ LPCOLESTR lpstrObjectName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeNavigateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeNavigate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeNavigate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeNavigate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayDefaultEventHandler )( 
            ICodeNavigate __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpstrObjectName);
        
        END_INTERFACE
    } ICodeNavigateVtbl;

    interface ICodeNavigate
    {
        CONST_VTBL struct ICodeNavigateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeNavigate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeNavigate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeNavigate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeNavigate_DisplayDefaultEventHandler(This,lpstrObjectName)	\
    (This)->lpVtbl -> DisplayDefaultEventHandler(This,lpstrObjectName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeNavigate_DisplayDefaultEventHandler_Proxy( 
    ICodeNavigate __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpstrObjectName);


void __RPC_STUB ICodeNavigate_DisplayDefaultEventHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeNavigate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0141
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SCodeNavigate IID_ICodeNavigate
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2
#define SELOBJS_ACTIVATE_WINDOW   1


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0141_v0_0_s_ifspec;

#ifndef __ISelectionContainer_INTERFACE_DEFINED__
#define __ISelectionContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISelectionContainer
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ISelectionContainer __RPC_FAR *LPSELECTIONCONTAINER;


EXTERN_C const IID IID_ISelectionContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c6-7436-11ce-8034-00aa006009fa")
    ISelectionContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CountObjects( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG __RPC_FAR *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectObjects( 
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISelectionContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISelectionContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG __RPC_FAR *pc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ISelectionContainerVtbl;

    interface ISelectionContainer
    {
        CONST_VTBL struct ISelectionContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionContainer_CountObjects(This,dwFlags,pc)	\
    (This)->lpVtbl -> CountObjects(This,dwFlags,pc)

#define ISelectionContainer_GetObjects(This,dwFlags,cObjects,apUnkObjects)	\
    (This)->lpVtbl -> GetObjects(This,dwFlags,cObjects,apUnkObjects)

#define ISelectionContainer_SelectObjects(This,cSelect,apUnkSelect,dwFlags)	\
    (This)->lpVtbl -> SelectObjects(This,cSelect,apUnkSelect,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionContainer_CountObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG __RPC_FAR *pc);


void __RPC_STUB ISelectionContainer_CountObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionContainer_GetObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cObjects,
    /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects);


void __RPC_STUB ISelectionContainer_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionContainer_SelectObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ ULONG cSelect,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ISelectionContainer_SelectObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionContainer_INTERFACE_DEFINED__ */


#ifndef __ITrackSelection_INTERFACE_DEFINED__
#define __ITrackSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITrackSelection
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ITrackSelection __RPC_FAR *LPTRACKSELECTION;


EXTERN_C const IID IID_ITrackSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c5-7436-11ce-8034-00aa006009fa")
    ITrackSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSelectChange( 
            /* [in] */ ISelectionContainer __RPC_FAR *pSC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrackSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITrackSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITrackSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITrackSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSelectChange )( 
            ITrackSelection __RPC_FAR * This,
            /* [in] */ ISelectionContainer __RPC_FAR *pSC);
        
        END_INTERFACE
    } ITrackSelectionVtbl;

    interface ITrackSelection
    {
        CONST_VTBL struct ITrackSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrackSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrackSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrackSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrackSelection_OnSelectChange(This,pSC)	\
    (This)->lpVtbl -> OnSelectChange(This,pSC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrackSelection_OnSelectChange_Proxy( 
    ITrackSelection __RPC_FAR * This,
    /* [in] */ ISelectionContainer __RPC_FAR *pSC);


void __RPC_STUB ITrackSelection_OnSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrackSelection_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0143
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_STrackSelection IID_ITrackSelection
#define CONTROLTYPELIB       (0x00000001)


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0143_v0_0_s_ifspec;

#ifndef __IProfferTypeLib_INTERFACE_DEFINED__
#define __IProfferTypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProfferTypeLib
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IProfferTypeLib __RPC_FAR *LPPROFFERTYPELIB;


EXTERN_C const IID IID_IProfferTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("718cc500-0a76-11cf-8045-00aa006009fa")
    IProfferTypeLib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferTypeLib( 
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferTypeLibVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProfferTypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProfferTypeLib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProfferTypeLib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProfferTypeLib )( 
            IProfferTypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IProfferTypeLibVtbl;

    interface IProfferTypeLib
    {
        CONST_VTBL struct IProfferTypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferTypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProfferTypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProfferTypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProfferTypeLib_ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags)	\
    (This)->lpVtbl -> ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProfferTypeLib_ProfferTypeLib_Proxy( 
    IProfferTypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ UINT uVerMaj,
    /* [in] */ UINT uVerMin,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IProfferTypeLib_ProfferTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProfferTypeLib_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0144
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SProfferTypeLib IID_IProfferTypeLib


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0144_v0_0_s_ifspec;

#ifndef __IProvideDynamicClassInfo_INTERFACE_DEFINED__
#define __IProvideDynamicClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDynamicClassInfo
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IProvideDynamicClassInfo __RPC_FAR *LPPROVIDEDYNAMICCLASSINFO;


EXTERN_C const IID IID_IProvideDynamicClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("468cfb80-b4f9-11cf-80dd-00aa00614895")
    IProvideDynamicClassInfo : public IProvideClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDynamicClassInfo( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreezeShape( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideDynamicClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDynamicClassInfo )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreezeShape )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        END_INTERFACE
    } IProvideDynamicClassInfoVtbl;

    interface IProvideDynamicClassInfo
    {
        CONST_VTBL struct IProvideDynamicClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideDynamicClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDynamicClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDynamicClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDynamicClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideDynamicClassInfo_GetDynamicClassInfo(This,ppTI,pdwCookie)	\
    (This)->lpVtbl -> GetDynamicClassInfo(This,ppTI,pdwCookie)

#define IProvideDynamicClassInfo_FreezeShape(This)	\
    (This)->lpVtbl -> FreezeShape(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideDynamicClassInfo_GetDynamicClassInfo_Proxy( 
    IProvideDynamicClassInfo __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IProvideDynamicClassInfo_GetDynamicClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideDynamicClassInfo_FreezeShape_Proxy( 
    IProvideDynamicClassInfo __RPC_FAR * This);


void __RPC_STUB IProvideDynamicClassInfo_FreezeShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDynamicClassInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0145
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


const GUID SID_SApplicationObject =
{0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8};


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0145_v0_0_s_ifspec;

#ifndef __IExtendedObject_INTERFACE_DEFINED__
#define __IExtendedObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendedObject
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IExtendedObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A575C060-5B17-11d1-AB3E-00A0C9055A90")
    IExtendedObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInnerObject( 
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendedObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendedObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendedObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendedObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInnerObject )( 
            IExtendedObject __RPC_FAR * This,
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IExtendedObjectVtbl;

    interface IExtendedObject
    {
        CONST_VTBL struct IExtendedObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendedObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendedObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendedObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendedObject_GetInnerObject(This,iid,ppvObject)	\
    (This)->lpVtbl -> GetInnerObject(This,iid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IExtendedObject_GetInnerObject_Proxy( 
    IExtendedObject __RPC_FAR * This,
    /* [in] */ REFIID iid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IExtendedObject_GetInnerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendedObject_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0146
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0146_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\triediid.h ===
// GUIDs for TriEdit.dll Active Document
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef _triediid_h_
#define _triediid_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const GUID  GUID_TriEditCommandGroup;
EXTERN_C const IID   IID_ITriEditDocument;
EXTERN_C const IID   LIBID_TRIEDITLib;
EXTERN_C const CLSID CLSID_TriEditDocument;

DEFINE_GUID(GUID_TriEditCommandGroup, 0x2582f1c0, 0x084e, 0x11d1, 0x9a, 0x0e, 0x00, 0x60, 0x97, 0xc9, 0xb3, 0x44);
DEFINE_GUID(IID_ITriEditDocument,     0x438DA5DF, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);
DEFINE_GUID(LIBID_TRIEDITLib,         0x438DA5D1, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);
DEFINE_GUID(CLSID_TriEditDocument,    0x438DA5E0, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);

#ifdef __cplusplus
}
#endif

#endif	// _triediid_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\vidstamp.h ===
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */

#if 	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if 	(rup == 0)

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b "." ruppad #c

#if 	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c) 		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR		VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION			rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version 	*/
/* data structure for all files, and which do not change.		*/
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG					0
#else
#define VER_DEBUG					VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD			0
#else
#define VER_PRIVATEBUILD			VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE				0
#else
#define VER_PRERELEASE				VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK			VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS					VOS__WINDOWS32
#else
#define VER_FILEOS					VOS_DOS_WINDOWS16
#endif

#if defined(_DEBUG)
#define VER_FILEFLAGS				(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#else
#define VER_FILEFLAGS				0
#endif

#define VER_COMPANYNAME_STR 		"Microsoft Corporation"
#define VER_PRODUCTNAME_STR		"Microsoft (R) Visual InterDev"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\version.h ===
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */

#define rmj		6
#define rmm		1
/* It is CRITICAL to bump the version number with each release. */
#define rup		9211
#define szVerName	""
#define szVerUser	"IE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright (c)1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\inc\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\deinstab.cpp ===
// DEInsTab.cpp : Implementation of CDEInsertTableParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DEInsTab.h"

/////////////////////////////////////////////////////////////////////////////
// CDEInsertTableParam

static WCHAR k_wszEmpty[] = L"";


CDEInsertTableParam::CDEInsertTableParam()
{
	m_nNumRows = 3;
	m_nNumCols = 3;
	m_bstrTableAttrs = ::SysAllocString(L"border=1 cellPadding=1 cellSpacing=1 width=75%");
	m_bstrCellAttrs = ::SysAllocString(k_wszEmpty);
	m_bstrCaption = ::SysAllocString(k_wszEmpty);
}

CDEInsertTableParam::~CDEInsertTableParam()
{
	::SysFreeString(m_bstrTableAttrs);
	m_bstrTableAttrs = NULL;
	::SysFreeString(m_bstrCellAttrs);
	m_bstrCellAttrs = NULL;
	::SysFreeString(m_bstrCaption);
	m_bstrCaption = NULL;
}

STDMETHODIMP CDEInsertTableParam::get_NumRows(LONG * pVal)
{
	_ASSERTE(pVal);

	*pVal = m_nNumRows;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_NumRows(LONG newVal)
{
	m_nNumRows = newVal;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_NumCols(LONG * pVal)
{
	_ASSERTE(pVal);

	*pVal = m_nNumCols;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_NumCols(LONG newVal)
{
	m_nNumCols = newVal;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_TableAttrs(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrTableAttrs);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_TableAttrs(BSTR newVal)
{
	::SysFreeString(m_bstrTableAttrs);
	if ( NULL == newVal )
	{
		m_bstrTableAttrs = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrTableAttrs = ::SysAllocString(newVal);
	}
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_CellAttrs(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrCellAttrs);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_CellAttrs(BSTR newVal)
{
	::SysFreeString(m_bstrCellAttrs);
	if ( NULL == newVal )
	{
		m_bstrCellAttrs = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrCellAttrs = ::SysAllocString(newVal);
	}
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_Caption(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrCaption);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_Caption(BSTR newVal)
{
	::SysFreeString(m_bstrCaption);
	if ( NULL == newVal )
	{
		m_bstrCaption = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrCaption = ::SysAllocString(newVal);
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\deinstab.h ===
// DEInsTab.h : Declaration of the CDEInsertTableParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DEINSERTTABLEPARAM_H_
#define __DEINSERTTABLEPARAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDEInsertTableParam
class ATL_NO_VTABLE CDEInsertTableParam : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDEInsertTableParam, &CLSID_DEInsertTableParam>,
	public IDispatchImpl<IDEInsertTableParam, &IID_IDEInsertTableParam, &LIBID_DHTMLEDLib>
{
public:
	CDEInsertTableParam();
	~CDEInsertTableParam();

private:

	ULONG	m_nNumRows;
	ULONG	m_nNumCols;
	BSTR	m_bstrTableAttrs;
	BSTR	m_bstrCellAttrs;
	BSTR	m_bstrCaption;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_DEINSERTTABLEPARAM)

BEGIN_COM_MAP(CDEInsertTableParam)
	COM_INTERFACE_ENTRY(IDEInsertTableParam)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDEInsertTableParam
public:
	STDMETHOD(get_Caption)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Caption)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CellAttrs)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CellAttrs)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_TableAttrs)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TableAttrs)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_NumCols)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_NumCols)(/*[in]*/ LONG newVal);
	STDMETHOD(get_NumRows)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_NumRows)(/*[in]*/ LONG newVal);
};

#endif //__DEINSERTTABLEPARAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\ambients.cpp ===
/*
 * AMBIENTS.CPP
 * Implementation of the ambient properties IDispatch on a
 * control site.
 *
 * Copyright (c)1995-1996 Microsoft Corporation, All Rights Reserved
 */

#include "stdafx.h"
#include <docobj.h>
#include "site.h"
#include "proxyframe.h"
#include "mshtmdid.h"

/*
 * CImpAmbientIDispatch::CImpAmbientIDispatch
 * CImpAmbientIDispatch::~CImpAmbientIDispatch
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpAmbientIDispatch::CImpAmbientIDispatch( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
    return;
}

CImpAmbientIDispatch::~CImpAmbientIDispatch(void)
{
    return;
}

/*
 * CImpAmbientIDispatch::QueryInterface
 * CImpAmbientIDispatch::AddRef
 * CImpAmbientIDispatch::Release
 */

STDMETHODIMP CImpAmbientIDispatch::QueryInterface(REFIID riid, void** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CImpAmbientIDispatch::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpAmbientIDispatch::Release(void)
{
    m_cRef--;
    return m_pUnkOuter->Release();
}


/*
 * CImpAmbientIDispatch::GetTypeInfoCount
 * CImpAmbientIDispatch::GetTypeInfo
 * CImpAmbientIDispatch::GetIDsOfNames
 *
 * Unimplemented members, not needed for ambient properties.
 */

STDMETHODIMP CImpAmbientIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo=0;
    return E_NOTIMPL;
}

STDMETHODIMP CImpAmbientIDispatch::GetTypeInfo(
	UINT		/*itinfo*/,
	LCID		/*lcid*/,
	ITypeInfo**	pptInfo
)
{
    *pptInfo=NULL;
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CImpAmbientIDispatch::GetIDsOfNames(
	REFIID		/*riid*/,
	OLECHAR**	rgszNames,
	UINT		/*cNames*/,
	LCID		/*lcid*/,
	DISPID*		rgDispID)
{
    *rgszNames	= NULL;
    *rgDispID	= NULL;
    return ResultFromScode(E_NOTIMPL);
}


/*
 * CImpAmbientIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispIDMember    DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */


STDMETHODIMP CImpAmbientIDispatch::Invoke(
	DISPID			dispIDMember,
	REFIID			riid,
	LCID			/*lcid*/,
	unsigned short	wFlags,
	DISPPARAMS*		/*pDispParams*/,
	VARIANT*		pVarResult,
	EXCEPINFO*		/*pExcepInfo*/,
	UINT*			/*puArgErr*/
)
{
    HRESULT			hr;
    VARIANT			varResult;
	VARIANT_BOOL	vbBool	= VARIANT_FALSE;


    if (IID_NULL!=riid)
        return ResultFromScode(E_INVALIDARG);

    if(NULL==pVarResult)
      pVarResult=&varResult;

    VariantInit(pVarResult);

    //The most common case is boolean, use as an initial type
    V_VT(pVarResult)=VT_BOOL;

    /*
     * Process the requested ambient property.  Anything but a
     * request for a property is invalid, so we can check that
     * before looking at the specific ID.  We can only get away
     * with this because all properties are read-only.
     */

    if (!(DISPATCH_PROPERTYGET & wFlags))
        return ResultFromScode(DISP_E_MEMBERNOTFOUND);

    hr = NOERROR;
    switch (dispIDMember)
	{
        case DISPID_AMBIENT_USERMODE:
            hr = m_pSite->GetFrame()->GetBrowseMode( &vbBool );
			if ( SUCCEEDED ( hr ) )
			{
				V_BOOL(pVarResult) = vbBool;
			}
            break;

	// BUG 542694: Disalbe the loading of frames.
        case DISPID_AMBIENT_DLCONTROL:
			if ( m_pSite->GetFrame() &&
				 m_pSite->GetFrame()->GetControl() &&
				 m_pSite->GetFrame()->GetControl()->IsSafeForScripting() )
			{
				V_VT(pVarResult)=VT_I4;
				V_I4(pVarResult) =
						DLCTL_DLIMAGES |
						DLCTL_NO_SCRIPTS |
						DLCTL_NO_DLACTIVEXCTLS |
						DLCTL_NO_FRAMEDOWNLOAD |
						DLCTL_NO_CLIENTPULL |
						DLCTL_NOFRAMES;
			}
            break;

        default:
            hr=ResultFromScode(DISP_E_MEMBERNOTFOUND);
            break;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>
#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")

ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);
ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T> class CComControl;
class CComDispatchDriver;

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;

};

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {_ASSERTE(p!=NULL); return *p; }
	IDispatch** operator&() {_ASSERTE(p==NULL); return &p; }
	IDispatch* operator->() {_ASSERTE(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return PutProperty(p, dwDispID, pVar);
	}

	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent
class CFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID);
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID);
};


//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};


typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// CComControl
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE(_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here
	// non-virtuals only please
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	void GetZoomInfo(ATL_DRAWINFO& di);
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	HRESULT SendOnDataChange(DWORD advf = 0);
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	LRESULT OnSetFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(TRUE);
		return 0;
	}

	LRESULT OnKillFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(FALSE);
		return 0;
	}
	LRESULT OnGetDlgCode(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		return 0;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDiaplayName)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
		bstrDiaplayName = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		_ASSERTE((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
		bstrScaleUnits = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
		_ASSERTE(var.vt == VT_INT_PTR || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(var.byref);
		return hRes;
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
		LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
		BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap);
	HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
		ATL_PROPMAP_ENTRY* pMap);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */,
		ATL_PROPMAP_ENTRY* pMap);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */,
		BOOL& /* lResult */);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		long m_nBackStyle;
		long m_nBorderStyle;
		long m_nBorderWidth;
		long m_nDrawMode;
		long m_nDrawStyle;
		long m_nDrawWidth;
		long m_nFillStyle;
		long m_nAppearance;
		long m_nMousePointer;
		long m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels
};

template <class T>
class ATL_NO_VTABLE CComControl :  public CComControlBase, public CWindowImpl<T>
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}
};

// Forward declarations
//
template <class T> class IPersistImpl;
template <class T> class IPersistStreamInitImpl;
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class ISpecifyPropertyPagesImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}
};

#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL} \
		}; \
		return pPropMap; \
	}


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStreamInitImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE(_T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::InitNew\n"));
		pT->SendOnDataChange();
		return S_OK;
	}

};


//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStorageImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStorageImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE(_T("IPersistStorageImpl::InitNew\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE(_T("IPersistStorageImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE(_T("IPersistStorageImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE(_T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}

//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl
{
public:

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistPropertyBagImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::GetClassID