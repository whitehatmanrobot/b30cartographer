/ CMSMQTransactionDispenser::BeginTransaction
//=--------------------------------------------------------------------------=
// Obtains and begins a transaction
//
// Output:
//    pptransaction  [out] where they want the transaction
//
// Notes:
//
HRESULT CMSMQTransactionDispenser::BeginTransaction(
    IMSMQTransaction3 **ppmqtransaction)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    ITransaction *ptransaction = NULL;
    IMSMQTransaction3 *pmqtransaction = NULL;
    CComObject<CMSMQTransaction> * pmqtransactionObj;
    IUnknown *punkDtc = NULL;
    HRESULT hresult = NOERROR;

    if (ppmqtransaction == NULL) {
      return E_INVALIDARG;
    }
    *ppmqtransaction = NULL;                      // pessimism
    IfFailGo(MQBeginTransaction(&ptransaction));
    //
    // We can also get here from old apps that want the old IMSMQTransaction/IMSMQTransaction2 back, but since
    // IMSMQTransaction3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQTransaction>::NewObj(&pmqtransactionObj, &IID_IMSMQTransaction3, (IUnknown **)&pmqtransaction));
    
    // ptransaction ownership transfers...
    //
    // This transaction is implemented by MSMQ, and we know that it doesn't need marshaling
    // between apartments. The culprit is that its implementation doesn't aggragate the FTM,
    // so GIT marshalling would be expensive. Since we can count on that it doesn't need
    // marshaling we allow it not to use GIT marshaling, and just use direct pointers
    //
    IfFailGo(pmqtransactionObj->Init(ptransaction, FALSE /*fUseGIT*/));
    *ppmqtransaction = pmqtransaction;
    ADDREF(*ppmqtransaction);
    // fall through...
      
Error:
    RELEASE(ptransaction);
    RELEASE(pmqtransaction);
    RELEASE(punkDtc);
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransactionDispenser::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] objects's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQTransactionDispenser::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\activex\mqoa\xdispdtc.h ===
//=--------------------------------------------------------------------------=
// xdisper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//  MSMQCoordinatedTransactionDispenser
//
//
#ifndef _MSMQCoordinatedTransactionDispenser_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
//#include "cs.h"

// forwards
class CMSMQCoordinatedTransactionDispenser;
struct ITransactionDispenser;

class ATL_NO_VTABLE CMSMQCoordinatedTransactionDispenser : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQCoordinatedTransactionDispenser, &CLSID_MSMQCoordinatedTransactionDispenser>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQCoordinatedTransactionDispenser3, &IID_IMSMQCoordinatedTransactionDispenser3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQCoordinatedTransactionDispenser()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQCOORDINATEDTRANSACTIONDISPENSER)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQCoordinatedTransactionDispenser)
	COM_INTERFACE_ENTRY(IMSMQCoordinatedTransactionDispenser3)
	// return IMSMQCoordinatedTransactionDispenser3 for IMSMQCoordinatedTransactionDispenser2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQCoordinatedTransactionDispenser2, IMSMQCoordinatedTransactionDispenser3)
	// return IMSMQCoordinatedTransactionDispenser3 for IMSMQCoordinatedTransactionDispenser
	COM_INTERFACE_ENTRY_IID(IID_IMSMQCoordinatedTransactionDispenser, IMSMQCoordinatedTransactionDispenser3)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQCoordinatedTransactionDispenser
public:
    virtual ~CMSMQCoordinatedTransactionDispenser();

    // IMSMQCoordinatedTransactionDispenser methods
    // TODO: copy over the interface methods for IMSMQCoordinatedTransactionDispenser from
    //       mqInterfaces.H here.
    STDMETHOD(BeginTransaction)(THIS_ IMSMQTransaction3 FAR* FAR* ptransaction);
    // IMSMQCoordinatedTransactionDispenser2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    static ITransactionDispenser *m_ptxdispenser;
    // static HINSTANCE m_hLibDtc;
    // static HINSTANCE m_hLibUtil;
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
};

#define _MSMQCoordinatedTransactionDispenser_H_
#endif // _MSMQCoordinatedTransactionDispenser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\activex\mqoa\xact.cpp ===
//=--------------------------------------------------------------------------=
// xact.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQTransaction object
//
//
#include "stdafx.h"
#include "dispids.h"

#include "txdtc.h"             // transaction support.
#include "oautil.h"
#include "xact.h"
#include <limits.h>
#include "mqtempl.h"

// forwards
struct ITransaction;

const MsmqObjType x_ObjectType = eMSMQTransaction;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



//=--------------------------------------------------------------------------=
// CMSMQTransaction::CMSMQTransaction
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//
CMSMQTransaction::CMSMQTransaction() :
	m_csObj(CCriticalSection::xAllocateSpinCount)
{

    // TODO: initialize anything here
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_pptransaction = NULL;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::~CMSMQTransaction
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQTransaction::~CMSMQTransaction ()
{
    // TODO: clean up anything here.
    if (m_pptransaction)
      delete m_pptransaction;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQTransaction::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTransaction3,
		&IID_IMSMQTransaction2,
		&IID_IMSMQTransaction,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::Init
//=--------------------------------------------------------------------------=
//    initializer
//
// Parameters:
//    ptransaction  [in]  ownership transfers
//    fUseGIT       [in]  whether to use GIT marshaling or direct ptrs between apts
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Init(ITransaction *ptransaction, BOOL fUseGIT)
{
    HRESULT hresult;
    P< CBaseGITInterface > pGITInterface;
    //
    // allocate either CGITInterface for real GIT marshaling or CFakeGITInterface
    // for direct ptr (e.g. no marshalling between apts)
    //
    if (fUseGIT)
    {
      pGITInterface = new CGITInterface;
    }
    else
    {
      pGITInterface = new CFakeGITInterface;
    }
    //
    // return if allocation failed
    //
    IfNullRet((CBaseGITInterface *)pGITInterface);
    //
    // register the given interface
    //
    IfFailRet(pGITInterface->Register(ptransaction, &IID_ITransaction));
    //
    // ownership transfer of CBaseGITInterface to m_pptransaction
    //
    ASSERTMSG(m_pptransaction == NULL, "m_pptransaction not empty in Init");
    m_pptransaction = pGITInterface.detach();
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::get_Transaction
//=--------------------------------------------------------------------------=
//    Returns underlying ITransaction* "magic cookie"
//
// Parameters:
//    plTranscation [out]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::get_Transaction(
    long *plTransaction)
{
#ifdef _WIN64
    //
    // WIN64
    // we can't return a transaction ptr as long in win64
    //
    UNREFERENCED_PARAMETER(plTransaction);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);    
#else //!_WIN64
    //
    // WIN32
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    if (m_pptransaction != NULL)
    {
      ITransaction * pTransaction;
      hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction, NULL);
      if (SUCCEEDED(hresult))
      {
        *plTransaction = (long)pTransaction;
        //
        // we didn't addref it previously, so we remove the AddRef from GetWithDefault
        //
        RELEASE(pTransaction);
      }
    }
    else
    {
      *plTransaction = 0;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
#endif //_WIN64
}

//=--------------------------------------------------------------------------=
// CMSMQTransaction::Commit
//=--------------------------------------------------------------------------=
//    Commit a transaction
//
// Parameters:
//    fRetaining    [optional]
//    grfTC         [optional]
//    grfRM         [optional]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Commit(
    VARIANT *pvarFRetaining, 
    VARIANT *pvarGrfTC, 
    VARIANT *pvarGrfRM)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL fRetaining = FALSE;
    long grfTC = 0;
    long grfRM = 0;
    HRESULT hresult = NOERROR;

    if (m_pptransaction == NULL) {
      return E_INVALIDARG;
    }
    R<ITransaction> pTransaction;
    IfFailRet(m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction.ref(), NULL));
    if (pTransaction.get() == NULL)
    {
      return E_INVALIDARG;
    }
    
    //
    // process optional args
    //
    if (V_VT(pvarFRetaining) != VT_ERROR) {
      fRetaining = GetBool(pvarFRetaining);
    }
    if (V_VT(pvarGrfTC) != VT_ERROR) {
      grfTC = GetNumber(pvarGrfTC, UINT_MAX);
    }
    if (V_VT(pvarGrfRM) != VT_ERROR) {
      grfRM = GetNumber(pvarGrfRM, UINT_MAX);
    }
    hresult = pTransaction->Commit(fRetaining, grfTC, grfRM);
    
    // 1790: we don't want to lose the specific DTC error
    //  number.
    //
#if 0
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
#endif // 0
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::Abort
//=--------------------------------------------------------------------------=
//    Commit a transaction
//
// Parameters:
//    fRetaining  [optional]
//    fAsync      [optional]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Abort(
    VARIANT *pvarFRetaining, 
    VARIANT *pvarFAsync)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL fRetaining = FALSE;
    BOOL fAsync = 0;
    HRESULT hresult = NOERROR;

    //
    // process optional args
    //
    if (V_VT(pvarFRetaining) != VT_ERROR) {
      fRetaining = GetBool(pvarFRetaining);
    }
    if (V_VT(pvarFAsync) != VT_ERROR) {
      fAsync = GetBool(pvarFAsync);
    }
    if (m_pptransaction == NULL) {
      return E_INVALIDARG;
    }
    R<ITransaction> pTransaction;
    IfFailRet(m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction.ref(), NULL));
    if (pTransaction.get() == NULL)
    {
      return E_INVALIDARG;
    }

    hresult = pTransaction->Abort(NULL, fRetaining, fAsync);

    // 1790: we don't want to lose the specific DTC error
    //  number.
    //
#if 0
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
#endif // 0
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// HELPER: GetXactFromVar
//=--------------------------------------------------------------------------=
// Get ITransaction * from a variant
//
// Input:
//    varTransaction   [in]  ITransaction variant
//    ppTransaction    [out] Returned ITransaction interface
//
// Notes:
//
static HRESULT GetXactFromVar(
    const VARIANT * pvarTransaction,
    ITransaction ** ppTransaction)
{
    HRESULT hresult = NOERROR;
    ITransaction * pTransaction = NULL;
    //
    // Get ITransaction interface from variant (also validate variant in try-except)
    //
    IUnknown * punkTrans = NULL;
    __try {
      //
      // Get IUnknown interface
      //
      switch(pvarTransaction->vt) {
      case VT_UNKNOWN:
        punkTrans = pvarTransaction->punkVal;
        break;
      case VT_UNKNOWN | VT_BYREF:
        punkTrans = *pvarTransaction->ppunkVal;
        break;
      case VT_DISPATCH:
        punkTrans = pvarTransaction->pdispVal;
        break;
      case VT_DISPATCH | VT_BYREF:
        punkTrans = *pvarTransaction->ppdispVal;
        break;
      case VT_INTPTR:
        punkTrans = (IUnknown *) V_INTPTR(pvarTransaction);
        break;
      case VT_INTPTR | VT_BYREF:
        punkTrans = (IUnknown *) (*(V_INTPTR_REF(pvarTransaction)));
        break;
      default:
        hresult = E_INVALIDARG;
        break;
      }
      //
      // QI for ITransaction
      //
      if (SUCCEEDED(hresult)) {
        hresult = punkTrans->QueryInterface(IID_ITransaction, (void **)&pTransaction);
      }
    } //__try
    __except (EXCEPTION_EXECUTE_HANDLER) {
      hresult = E_INVALIDARG;      
    }
    //
    // return results
    //
    if (SUCCEEDED(hresult)) {
        *ppTransaction = pTransaction;
    }
    else {
        RELEASE(pTransaction);
    }
    return hresult;
}

//=--------------------------------------------------------------------------=
// CMSMQTransaction::InitNew
//=--------------------------------------------------------------------------=
// Attaches to an existing transaction
//
// Input:
//    varTransaction   [in]  ITransaction interface
//
// Notes:
// #3478 RaananH
//
HRESULT CMSMQTransaction::InitNew(
    VARIANT varTransaction)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    ITransaction * pTransaction = NULL;
    HRESULT hresult;

    //
    // we can't attach if this transaction is already inited
    // BUGBUG we might release the old transaction, but then we'd better
    // use put_Transaction (e.g. assigning to the Transaction property)
    // instead of Attach
    // BUGBUG ERRORCODE we may need a better error code here
    //
    if (m_pptransaction != NULL) {
      return CreateErrorHelper(MQ_ERROR_TRANSACTION_USAGE, x_ObjectType);
    }

    //
    // Get ITransaction interface from variant (also validate variant in try-except)
    //
    IfFailGo(GetXactFromVar(&varTransaction, &pTransaction));

    //
    // we have a valid ITransaction, lets init the transaction with it
    //
    // Since we don't know the origin of this transaction interface, we can't guarantee
    // that this transaction interface doesn't need marshaling between apartments,
    // and since we are not marshalled between apartments (FTM) we therefore force it to
    // use GIT marshaling (and not direct pointers)
    //
    IfFailGo(Init(pTransaction, TRUE /*fUseGIT*/));
    hresult = NOERROR;
    // fall through...
      
Error:
    RELEASE(pTransaction);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransaction::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQTransaction::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransaction::get_ITransaction
//=-------------------------------------------------------------------------=
// Gets object's ITransaction interface as a variant (VT_UNKNOWN)
//
// Parameters:
//    pvarITransaction - [out] object's ITransaction interface
//
// Output:
//
// Notes:
// ITransaction replaces the Transaction property - on win64 Transaction doesn't work
// since it is defined as long, but the value returned should be a pointer.
// It is returned as a variant and not IUnknown so VBS could use it as well
//
HRESULT CMSMQTransaction::get_ITransaction(VARIANT *pvarITransaction)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    if (m_pptransaction != NULL)
    {
      ITransaction * pTransaction;
      hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction, NULL);
      if (SUCCEEDED(hresult))
      {
        if (pTransaction)
        {
          //
          // pTransaction is already ADDREF'ed
          //
          pvarITransaction->vt = VT_UNKNOWN;
          pvarITransaction->punkVal = pTransaction;
        }
        else //pTransaction == NULL
        {
          //
          // return empty variant
          //
          pvarITransaction->vt = VT_EMPTY;
        }
      } //SUCCEEDED(hresult)
    }
    else //m_pptransaction == NULL
    {
      //
      // return empty variant
      //
      pvarITransaction->vt = VT_EMPTY;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\activex\mqoa\xdispdtc.cpp ===
//=--------------------------------------------------------------------------=
// xdispdtc.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//  MSMQCoordinatedTransactionDispenser
//
//
#include "stdafx.h"
#include "dispids.h"

#include "txdtc.h"             // transaction support.
#include "oautil.h"
#include "xact.h"
#include "xdispdtc.h"

// forwards
struct ITransactionDispenser;

const MsmqObjType x_ObjectType = eMSMQCoordinatedTransactionDispenser;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



// global: TransactionDispenser Dispenser DTC's interface
ITransactionDispenser *CMSMQCoordinatedTransactionDispenser::m_ptxdispenser = NULL;
// HINSTANCE CMSMQCoordinatedTransactionDispenser::m_hLibDtc = NULL;
// HINSTANCE CMSMQCoordinatedTransactionDispenser::m_hLibUtil = NULL;

//#2619 RaananH Multithread async receive
CCriticalSection g_csGetDtcDispenser(CCriticalSection::xAllocateSpinCount);

//
//  TransactionDispenser stuff
//

// UNDONE: copied from mqutil
//  Really should be able to link with mqutil.lib
//   but need to solve include file wars.
//
// Because we are compiling in UNICODE, here is a problem with DTC...
//#include	<xolehlp.h>
//
extern HRESULT DtcGetTransactionManager(
    LPSTR pszHost,
    LPSTR pszTmName,
    REFIID rid,
    DWORD dwReserved1,
    WORD wcbReserved2,
    void FAR * pvReserved2,
    void** ppvObject);

//
//  TransactionDispenser stuff
//  NOTE: we dynload this from core Falcon
//
// extern HRESULT XactGetDTC(IUnknown **ppunkDtc);


// 
// defer to mqrt
//
EXTERN_C
HRESULT
APIENTRY
RTXactGetDTC(
    IUnknown **ppunkDTC
    );


/*====================================================

GetDtc
    Gets the IUnknown pointer to the MS DTC
Arguments:
    OUT IUnknown *ppunkDtc
Returns:
    HR
=====================================================*/

static HRESULT GetDtc(IUnknown **ppunkDtc)
{
    return RTXactGetDTC(ppunkDtc);
}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::~CMSMQCoordinatedTransactionDispenser
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQCoordinatedTransactionDispenser::~CMSMQCoordinatedTransactionDispenser ()
{
    // TODO: clean up anything here.

}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQCoordinatedTransactionDispenser::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQCoordinatedTransactionDispenser3,
		&IID_IMSMQCoordinatedTransactionDispenser2,
		&IID_IMSMQCoordinatedTransactionDispenser,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::BeginTransaction
//=--------------------------------------------------------------------------=
// Obtains and begins a transaction
//
// Output:
//    pptransaction  [out] where they want the transaction
//
// Notes:
//#2619 RaananH Multithread async receive
//
HRESULT CMSMQCoordinatedTransactionDispenser::BeginTransaction(
    IMSMQTransaction3 **ppmqtransaction)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    ITransaction *ptransaction = NULL;
    IMSMQTransaction3 *pmqtransaction = NULL;
    CComObject<CMSMQTransaction> * pmqtransactionObj;
    IUnknown *punkDtc = NULL;
    HRESULT hresult = NOERROR;

    if (ppmqtransaction == NULL) {
      return E_INVALIDARG;
    }
    *ppmqtransaction = NULL;                      // pessimism
    //
    // no deadlock - no one that locks g_csGetDtcDispenser tries to lock us from inside its lock
    //
    {
		CS lock(g_csGetDtcDispenser); //#2619

		if (m_ptxdispenser == NULL) {
		  IfFailGo(GetDtc(&punkDtc));           // dynload
		  IfFailGo(punkDtc->QueryInterface(
					IID_ITransactionDispenser, 
					(LPVOID *)&m_ptxdispenser));
		}
	}

    ASSERTMSG(m_ptxdispenser, "should have a transaction manager.");
    IfFailGo(m_ptxdispenser->BeginTransaction(
              NULL,                             // punkOuter,
              ISOLATIONLEVEL_ISOLATED,          // ISOLEVEL isoLevel,
              ISOFLAG_RETAIN_DONTCARE,          // ULONG isoFlags,
              NULL,                             // ITransactionOptions *pOptions
              &ptransaction));    
    //
    // We can also get here from old apps that want the old IMSMQTransaction/IMSMQTransaction2 back, but since
    // IMSMQTransaction3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQTransaction>::NewObj(&pmqtransactionObj, &IID_IMSMQTransaction3, (IUnknown **)&pmqtransaction));
    
    // ptransaction ownership transfers...
    //
    // Since we can't guarantee that this transaction interface doesn't need marshaling
    // between apartments, and since we are not marshalled between apartments (FTM)
    // we therefore force it to use GIT marshaling (and not direct pointers)
    //
    IfFailGo(pmqtransactionObj->Init(ptransaction, TRUE /*fUseGIT*/));
    *ppmqtransaction = pmqtransaction;
    ADDREF(*ppmqtransaction);
    // fall through...
      
Error:
    RELEASE(ptransaction);
    RELEASE(pmqtransaction);
    RELEASE(punkDtc);
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] objects's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQCoordinatedTransactionDispenser::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\activex\mqoa\xact.h ===
//=--------------------------------------------------------------------------=
// xact.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQTransaction object.
//
//
#ifndef _MSMQTransaction_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
#include "cs.h"

// forwards
class CMSMQTransaction;
struct ITransaction;

class ATL_NO_VTABLE CMSMQTransaction : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTransaction, &CLSID_MSMQTransaction>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTransaction3, &IID_IMSMQTransaction3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQTransaction();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRANSACTION)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQTransaction)
	COM_INTERFACE_ENTRY(IMSMQTransaction3)
	COM_INTERFACE_ENTRY(IMSMQTransaction2)
	COM_INTERFACE_ENTRY(IMSMQTransaction)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQTransaction
public:
    virtual ~CMSMQTransaction();

    // IMSMQTransaction methods
    // TODO: copy over the interface methods for IMSMQTransaction from
    //       mqInterfaces.H here.
    STDMETHOD(get_Transaction)(THIS_ long FAR* plTransaction);
    STDMETHOD(Commit)(THIS_ VARIANT *fRetaining, VARIANT *grfTC, VARIANT *grfRM);
    STDMETHOD(Abort)(THIS_ VARIANT *fRetaining, VARIANT *fAsync);

    // IMSMQTransaction2 methods (in addition to IMSMQTransaction)
    //
    STDMETHOD(InitNew)(THIS_ VARIANT varTransaction);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    // IMSMQTransaction3 methods (in addition to IMSMQTransaction2)
    //
    STDMETHOD(get_ITransaction)(THIS_ VARIANT FAR* pvarITransaction);

    // introduced methods
    HRESULT Init(ITransaction *ptransaction, BOOL fUseGIT);
    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
    //
    CCriticalSection m_csObj;

protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pptransaction can either be our object (if dispensed by MSMQ) - for which we use the
    // Fake GIT wrapper, or it can be dispensed by DTC, or set by the user using InitNew - in this case
    // we store it in GIT        
    //
    CBaseGITInterface * m_pptransaction;
};


#define _MSMQTransaction_H_
#endif // _MSMQTransaction_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\activex\mqoa\xdisper.h ===
//=--------------------------------------------------------------------------=
// xdisper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// MSMQTransactionDispenser object.
//
//
#ifndef _MSMQTransactionDispenser_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
//#include "cs.h"

// forwards
class CMSMQTransactionDispenser;
class ATL_NO_VTABLE CMSMQTransactionDispenser : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTransactionDispenser, &CLSID_MSMQTransactionDispenser>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTransactionDispenser3, &IID_IMSMQTransactionDispenser3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQTransactionDispenser()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRANSACTIONDISPENSER)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQTransactionDispenser)
	COM_INTERFACE_ENTRY(IMSMQTransactionDispenser3)
	// return IMSMQTransactionDispenser3 for IMSMQTransactionDispenser2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQTransactionDispenser2, IMSMQTransactionDispenser3)
	// return IMSMQTransactionDispenser3 for IMSMQTransactionDispenser
	COM_INTERFACE_ENTRY_IID(IID_IMSMQTransactionDispenser, IMSMQTransactionDispenser3)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQTransactionDispenser
public:
    virtual ~CMSMQTransactionDispenser();

    // IMSMQTransactionDispenser methods
    // TODO: copy over the interface methods for IMSMQTransactionDispenser from
    //       mqInterfaces.H here.
    STDMETHOD(BeginTransaction)(THIS_ IMSMQTransaction3 FAR* FAR* ptransaction);
    // IMSMQTransactionDispenser2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
};


#define _MSMQTransactionDispenser_H_
#endif // _MSMQTransactionDispenser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\admmsg.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   admmsg.cpp

Abstract:

   Implementations of utilities used for Admin messages

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "globals.h"
#include "resource.h"
#include "mqprops.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "mqformat.h"
#include "privque.h"
#include "rt.h"
#include "admcomnd.h"
#include "admmsg.h"
#include "mqcast.h"

#include "admmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_WAIT_FOR_RESPONSE 45        //seconds

//////////////////////////////////////////////////////////////////////////////
/*++

SendMSMQMessage

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT SendMSMQMessage(LPCTSTR pcszTargetQueue,
                        LPCTSTR pcszLabel,
                        LPCTSTR pcszBody,
                        DWORD   dwBodySize,
                        LPCWSTR lpwcsResponseQueue = 0,
                        DWORD   dwTimeOut = MAX_WAIT_FOR_RESPONSE
                        )
{
    HRESULT       hr;
    PROPVARIANT   aPropVar[5];
    PROPID        aPropID[5];
    MQMSGPROPS    msgprops;
    QUEUEHANDLE   hQueue;
    UINT          iNextProperty = 0;

    BOOL fResponseExist = (0 != lpwcsResponseQueue);
    DWORD cProp = fResponseExist ? 5 : 4;

    //
    // Open the target queue with send permission
    //
    hr = MQOpenQueue(pcszTargetQueue, MQ_SEND_ACCESS, 0, &hQueue);

    if (FAILED(hr))
    {
        ATLTRACE(_T("SendMSMQMessage : Can't open queue for sending messages\n"));
        return hr;
    }

    //
    // Set Label Property
    //
    aPropID[iNextProperty] = PROPID_M_LABEL;
    aPropVar[iNextProperty].vt = VT_LPWSTR;
    aPropVar[iNextProperty++].pwszVal = (LPWSTR)pcszLabel;

    //
    // Set Body Property
    //
    aPropID[iNextProperty] = PROPID_M_BODY;
    aPropVar[iNextProperty].vt = VT_UI1|VT_VECTOR;
    aPropVar[iNextProperty].caub.cElems = dwBodySize;
    aPropVar[iNextProperty++].caub.pElems = (UCHAR*)(LPWSTR)pcszBody;

    //
    // Set Arrive time-out
    //
    aPropID[iNextProperty] = PROPID_M_TIME_TO_REACH_QUEUE;
    aPropVar[iNextProperty].vt = VT_UI4;
    aPropVar[iNextProperty++].ulVal = dwTimeOut;

    //
    // Set Receive time-out
    //
    aPropID[iNextProperty] = PROPID_M_TIME_TO_BE_RECEIVED;
    aPropVar[iNextProperty].vt = VT_UI4;
    aPropVar[iNextProperty++].ulVal = dwTimeOut;

    ASSERT(iNextProperty == 4);

    if (fResponseExist)
    {
        //
        // Set Response Queue Property
        //
        aPropID[iNextProperty] = PROPID_M_RESP_QUEUE;
        aPropVar[iNextProperty].vt = VT_LPWSTR;
        aPropVar[iNextProperty++].pwszVal = (LPWSTR)lpwcsResponseQueue;
    }

    //
    // prepare the message properties to send
    //
    msgprops.cProp = cProp;
    msgprops.aPropID = aPropID;
    msgprops.aPropVar = aPropVar;
    msgprops.aStatus  = NULL;


    //
    // Send the message and close the queue
    //
    hr = MQSendMessage(hQueue, &msgprops, NULL);

    MQCloseQueue(hQueue);

    return (hr);

}
//+-----------------------------
//
//   GetDacl()
//   Gets a security descriptor with "premissions to everyone"
//
//+-----------------------------
static HRESULT GetDacl(SECURITY_DESCRIPTOR **ppSecurityDescriptor)
{
    SECURITY_DESCRIPTOR sd;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

	PSID pEveryoneSid = MQSec_GetWorldSid();
	ASSERT((pEveryoneSid != NULL) && IsValidSid(pEveryoneSid));

	PSID pAnonymousSid = MQSec_GetAnonymousSid();
	ASSERT((pAnonymousSid != NULL) && IsValidSid(pAnonymousSid));

    //
    // Calculate the required DACL size and allocate it.
    //
    DWORD dwAclSize = sizeof(ACL) +
						 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						 GetLengthSid(pEveryoneSid) +
						 GetLengthSid(pAnonymousSid);

    P<ACL> pDacl = (PACL) new BYTE[dwAclSize];

    BOOL bRet = InitializeAcl(pDacl, dwAclSize, ACL_REVISION);
    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: InitializeAcl failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet = AddAccessAllowedAce(
				pDacl,
				ACL_REVISION,
				MQSEC_QUEUE_GENERIC_ALL,
				pEveryoneSid
				);

    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: AddAccessAllowedAce failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_WRITE_MESSAGE,
					pAnonymousSid
					);

    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: AddAccessAllowedAce failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet =  SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: SetSecurityDescriptorDacl failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD(&sd, NULL, &dwLen);
    if (!bRet)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            *ppSecurityDescriptor = (SECURITY_DESCRIPTOR*) new BYTE[dwLen];
            bRet = MakeSelfRelativeSD(&sd, *ppSecurityDescriptor, &dwLen);
        }

        if (!bRet)
        {
            DWORD gle = GetLastError();
            TRACE(_T("%s, line %d: MakeSelfRelativeSD failed. Error %d\n"), THIS_FILE, __LINE__, gle);
            return HRESULT_FROM_WIN32(gle);
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CreatePrivateResponseQueue

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT CreatePrivateResponseQueue(LPWSTR pFormatName)
{
    HRESULT hr;
    MQQUEUEPROPS QueueProps;
    PROPVARIANT Var;
    PROPID      Propid = PROPID_Q_PATHNAME;
    CString     strQueueName;
    DWORD dwFormatNameLen = MAX_QUEUE_FORMATNAME;

    //
    // Create a private queue
    //
    strQueueName = L".\\PRIVATE$\\msmqadminresp";
    //strQueueName += lpcwQueueName;

    Var.vt = VT_LPWSTR;
    Var.pwszVal = (LPTSTR)(LPCTSTR)strQueueName;

    QueueProps.cProp = 1;
    QueueProps.aPropID = &Propid;
    QueueProps.aPropVar = &Var;
    QueueProps.aStatus = NULL;

    hr = MQCreateQueue(NULL, &QueueProps, pFormatName, &dwFormatNameLen);

    ASSERT( hr != MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL);

    if (hr == MQ_ERROR_QUEUE_EXISTS)
    {
       hr = MQPathNameToFormatName( strQueueName,
                                    pFormatName,
                                    &dwFormatNameLen ) ;
       if (FAILED(hr))
       {
          ATLTRACE(_T("CreatePrivateResponseQueue Open- Couldn't get FormatName\n"));
       }
       return hr;
    }

    if FAILED(hr)
    {
        return hr;
    }

    //
    // Sets full permission to everyone.
    // This is usefull in case the queue is somehow not deleted,
    // and another user is trying to run the admin (bug 3549, yoela, 12-Nov-98).
	// Set MQSEC_WRITE_MESSAGE for anonymous. otherwise the response messages
	// will be rejected.
    //
    P<SECURITY_DESCRIPTOR> pSecurityDescriptor;
    hr = GetDacl(&pSecurityDescriptor);
    if FAILED(hr)
    {
        MQDeleteQueue(pFormatName);
        ASSERT(0);
        return hr;
    }

    ASSERT(pSecurityDescriptor != 0);
    hr = MQSetQueueSecurity(pFormatName, DACL_SECURITY_INFORMATION,
                            pSecurityDescriptor);

    if FAILED(hr)
    {
        MQDeleteQueue(pFormatName);
        ASSERT(0);
    }
    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

WaitForAdminResponse

  Always allocate memory for the response buffer.
  Must be freed by the caller.

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT WaitForAdminResponse(QUEUEHANDLE hQ, DWORD dwTimeout, UCHAR* *ppBodyBuffer, DWORD* pdwBufSize)
{

    UCHAR*  pBody;
    DWORD   dwNewSize, dwBodySize;
    HRESULT hr = MQ_OK;

    MQMSGPROPS msgprops;
    MSGPROPID amsgpid[2];
    PROPVARIANT apvar[2];

    msgprops.cProp = 2;
    msgprops.aPropID = amsgpid;
    msgprops.aPropVar = apvar;
    msgprops.aStatus = NULL;

    pBody = NULL;
    dwNewSize = 3000;

    do
    {
        delete pBody;

        dwBodySize = dwNewSize;
        pBody = new UCHAR[dwBodySize];

        msgprops.aPropID[0] = PROPID_M_BODY;
        msgprops.aPropVar[0].vt = VT_UI1 | VT_VECTOR;
        msgprops.aPropVar[0].caub.pElems = pBody;
        msgprops.aPropVar[0].caub.cElems = dwBodySize;

        msgprops.aPropID[1] = PROPID_M_BODY_SIZE;
        msgprops.aPropVar[1].vt = VT_UI4;
        msgprops.aPropVar[1].ulVal = VT_UI4;

        hr = MQReceiveMessage(hQ, dwTimeout, MQ_ACTION_RECEIVE, &msgprops,
                              0,NULL,0, NULL);

        dwNewSize = msgprops.aPropVar[1].ulVal;

    } while(MQ_ERROR_BUFFER_OVERFLOW == hr);

    if(FAILED(hr))
    {
        ATLTRACE(_T("admmsg.cpp: Error while reading admin resp message\n"));
        return(hr);
    }

    *pdwBufSize = dwNewSize;
    *ppBodyBuffer = pBody;
    return hr;

}

//////////////////////////////////////////////////////////////////////////////
/*++

GetAdminQueueFormatName

--*/
//////////////////////////////////////////////////////////////////////////////
static void GetAdminQueueFormatName(const GUID& gQMID, CString& strQueueFormatName)
{
    WCHAR wcsTemp[MAX_PATH] = L"" ;

    _snwprintf(
        wcsTemp,
        sizeof(wcsTemp) / sizeof(wcsTemp[0]),
        FN_PRIVATE_TOKEN            // "PRIVATE"
            FN_EQUAL_SIGN           // "="
            GUID_FORMAT             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_PRIVATE_SEPERATOR    // "\\"
            FN_PRIVATE_ID_FORMAT,     // "xxxxxxxx"
        GUID_ELEMENTS((&gQMID)),
        ADMINISTRATION_QUEUE_ID
        );
    wcsTemp[MAX_PATH-1] = L'\0' ;

    strQueueFormatName = wcsTemp;
}


//////////////////////////////////////////////////////////////////////////////
/*++

SendAndReceiveAdminMsg

    Sends an admin message.
    Always allocate the response body buffer. Must be freed by the caller

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT SendAndReceiveAdminMsg(
    const GUID& gMachineID,
    CString& strMsgBody,
    UCHAR** ppBuf,
    DWORD* pdwBufSize
    )
{
    HRESULT hr;
    CString strAdminQ;
    WCHAR wzPrivateFormatName[MAX_QUEUE_FORMATNAME];
    QUEUEHANDLE hQ;

    //
    // Create a private queue for response
    //
    hr = CreatePrivateResponseQueue(wzPrivateFormatName);
    if(FAILED(hr))
        return(hr);

    //
    // Send request message to Target machine
    //
    GetAdminQueueFormatName(gMachineID, strAdminQ);
    hr = SendMSMQMessage( strAdminQ, ADMIN_COMMANDS_TITLE,
                          strMsgBody, ((strMsgBody.GetLength() + 1)*sizeof(TCHAR)),
                          wzPrivateFormatName,MAX_WAIT_FOR_RESPONSE);

    if(FAILED(hr))
        return(hr);

    //
    // Open the private queue
    //
    hr = MQOpenQueue(wzPrivateFormatName, MQ_RECEIVE_ACCESS, 0, &hQ);
    if(FAILED(hr))
    {
        ATLTRACE(_T("SendAndReceiveAdminMsg - Can not open response private queue\n"));
        return(hr);
    }

    //
    // Wait for the response
    //
    hr = WaitForAdminResponse(hQ,MAX_WAIT_FOR_RESPONSE * 1000, ppBuf, pdwBufSize);
    if(FAILED(hr))
        return(hr);

    //
    // Close the private response queue
    //
    MQCloseQueue(hQ);


    //
    // And delete it.
    //
    hr = MQDeleteQueue(wzPrivateFormatName);

    return(MQ_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

RequestPrivateQueues

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT RequestPrivateQueues(const GUID& gMachineID, PUCHAR *ppListofPrivateQ, DWORD *pdwNoofQ)
{
    ASSERT(ppListofPrivateQ != NULL);
    ASSERT(pdwNoofQ != NULL);

    CArray<QMGetPrivateQResponse*, QMGetPrivateQResponse*> aResponse;
    QMGetPrivateQResponse* pResponse;

    PUCHAR  pPrivateQBuffer = 0;

    QMGetPrivateQResponse_POS32 pos = NULL;
    DWORD dwTotalSize = 0;
    HRESULT hr;

    *pdwNoofQ = 0;
    do
    {
        DWORD dwResponseSize = 0;
        CString strMsgBody;
        strMsgBody.Format(TEXT("%s=%d"), ADMIN_GET_PRIVATE_QUEUES, pos);

        PUCHAR pPrivateQueueBuffer;
        hr = SendAndReceiveAdminMsg(gMachineID,
                                  strMsgBody,
                                  &pPrivateQueueBuffer,
                                  &dwResponseSize);
        if (FAILED(hr))
        {
            for (int i = 0; i < aResponse.GetSize(); i++)
            {
                pResponse = aResponse[i];
                delete pResponse;
            }
            return hr;
        }

        pResponse = reinterpret_cast<QMGetPrivateQResponse*>(pPrivateQueueBuffer);

        aResponse.Add(pResponse);
        dwTotalSize += pResponse->dwResponseSize;
        *pdwNoofQ += pResponse->dwNoOfQueues;


        pos = pResponse->pos;

    } while (pResponse->hr == ERROR_MORE_DATA);

    pPrivateQBuffer = new UCHAR[dwTotalSize];
    PUCHAR pCurrentPos = pPrivateQBuffer;

    for (int i = 0; i < aResponse.GetSize(); i++)
    {
        pResponse = aResponse[i];
        memcpy(pCurrentPos, pResponse->uResponseBody, pResponse->dwResponseSize);
        pCurrentPos += pResponse->dwResponseSize;
        delete pResponse;
    }

    *ppListofPrivateQ = pPrivateQBuffer;

    return(S_OK);

}

HRESULT
RequestDependentClient(
    const GUID& gMachineID,
    CList<LPWSTR, LPWSTR&>& DependentMachineList
    )
{
    HRESULT hr;
    CString strMsgBody = ADMIN_GET_DEPENDENTCLIENTS;
    DWORD   dwResponseSize = 0;
    AP<UCHAR> pch = NULL;

    hr = SendAndReceiveAdminMsg(
                gMachineID,
                strMsgBody,
                &pch,
                &dwResponseSize
                );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Remove status byte to make the data aligned.
    //
    ASSERT(dwResponseSize >= 1);
    memmove(pch, pch + 1, dwResponseSize - 1);

    ClientNames* pClients = (ClientNames*)pch.get();
    LPWSTR pw = &pClients->rwName[0];

    for (ULONG i=0; i<pClients->cbClients; ++i)
    {
        DWORD size = numeric_cast<DWORD>(wcslen(pw)+1);
        LPWSTR clientName = new WCHAR[size];
        memcpy(clientName, pw, size*sizeof(WCHAR));
        DependentMachineList.AddTail(clientName);

        pw += size;
    }

    return(MQ_OK);
}
//////////////////////////////////////////////////////////////////////////////
/*++

MQPing

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT MQPingNoUI(const GUID& gMachineID)
{
    //
    // convert guid to string-guid repesentation
    //
    WCHAR strId[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(gMachineID, strId, TABLE_SIZE(strId));
    if (iLen != (STRING_UUID_SIZE + 1))
    {
        ASSERT(0);
        return MQ_ERROR;
    }

    CString strMsgBody;
    strMsgBody.Format(TEXT("%s=%s"), ADMIN_PING, strId);

    P<UCHAR> pBuffer;
    DWORD dwResponseSize;
    HRESULT hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return hr;
    }

    GUID guid;
    //
    // first byte is the status
    //
    if (ADMIN_STAT_OK == pBuffer[0])
    {
        //
        // Body should look like "={<guid>}" - guid begins at second TCHAR
		// The string {<guid>} (starting from the third BYTE) is copied to a newly
		// allocated buffer in order to avoid alignment faults on win64 in
		// IIDFromString(). <nelak, 03/2001>
        //
		P<TCHAR> strGuidAsString = new TCHAR[dwResponseSize / sizeof(TCHAR)];
		memcpy(strGuidAsString, &pBuffer[3], dwResponseSize - 3);

		if (SUCCEEDED(IIDFromString(strGuidAsString, &guid)))
        {
            if (guid == gMachineID)
            {
                return S_OK;
            }
        }
    }

    return(MQ_ERROR);
}

HRESULT MQPing(const GUID& gMachineID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    UINT nIdMessage= IDS_PING_FAILED, nType = MB_ICONEXCLAMATION;
    {
        CWaitCursor wc;

        if (SUCCEEDED(MQPingNoUI(gMachineID)))
        {
            nIdMessage= IDS_PING_SUCCEEDED;
            nType = MB_ICONINFORMATION;
        }
    }

    AfxMessageBox(nIdMessage, nType);
    return S_OK;
}


HRESULT
SendAdminGuidMessage(
    const GUID& gMachineID,
    const GUID& ReportQueueGuid,
    LPCWSTR pwcsCommand
    )
{
    //
    // Get the Target Admin Queue's format name
    //
    CString strAdminQueueFormatName;

    GetAdminQueueFormatName(gMachineID, strAdminQueueFormatName);


    CString strMsgBody;

    //
    // convert guid to string-guid repesentation
    //
    WCHAR wcsTemp[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(ReportQueueGuid, wcsTemp, TABLE_SIZE(wcsTemp));

    if (iLen != (STRING_UUID_SIZE + 1))
    {
        return MQ_ERROR;
    }

    //
    // prepare message body and send it along with the appropriate title of
    // admin commands
    //
    strMsgBody = pwcsCommand;
    strMsgBody += L"=";
    strMsgBody += wcsTemp;

    return (SendMSMQMessage(strAdminQueueFormatName,
                              ADMIN_COMMANDS_TITLE,
                              strMsgBody,
                              (strMsgBody.GetLength() + 1)*sizeof(TCHAR)
                             ));
}



//////////////////////////////////////////////////////////////////////////////
/*++

SendQMTestMessage

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT SendQMTestMessage(GUID &gMachineID, GUID &gQueueId)
{
    return SendAdminGuidMessage(gMachineID, gQueueId, ADMIN_SEND_TESTMSG);
}


/*====================================================

GetQPathnameFromGuid

  Queries the Targeted QM for the report-queue.
  This action is done through falcon-messages to the
  target QM. The action has a timeout limit

Arguments:

Return Value:

=====================================================*/
HRESULT
GetQPathnameFromGuid(
	 const GUID *pguid,
	 CString& strName,
	 const CString& strDomainController
	 )
{
	HRESULT hr;
    PROPID  pid = PROPID_Q_PATHNAME;
    PROPVARIANT pVar;

    pVar.vt = VT_NULL;

    hr = ADGetObjectPropertiesGuid(
                eQUEUE,
                GetDomainController(strDomainController),
				true,	// fServerName
                pguid,
                1,
                &pid,
                &pVar
                );

    if (SUCCEEDED(hr))
    {
        strName = pVar.pwszVal;
        MQFreeMemory(pVar.pwszVal);
    }

    return hr;
}

HRESULT
GetQMReportQueue(
    const GUID& gMachineID,
    CString& strRQPathname,
	const CString& strDomainController
    )
{
    CString strMsgBody = ADMIN_GET_REPORTQUEUE;
    HRESULT hr;

    P<UCHAR> pBuffer;
    DWORD dwResponseSize = 0;

    hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return(hr);
    }

    switch (pBuffer[0] /* status */)
    {
        case ADMIN_STAT_NOVALUE:
            //
            // no report queue found
            //
            strRQPathname.Empty();
            hr = MQ_OK;
            break;

        case ADMIN_STAT_OK:
			//
			// Avoid alignment faults
			//
			GUID machineGuid;
			memcpy(&machineGuid, &pBuffer[1], sizeof(GUID));

            //
            // query the DS for the queue's pathname
            //
            hr = GetQPathnameFromGuid(
					&machineGuid,
					strRQPathname,
					strDomainController
					);
            break;

        default:
            hr = MQ_ERROR;

    }

    return hr;
}

/*====================================================

SetQMReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT
SetQMReportQueue(
    const GUID& gDesMachine,
    const GUID& gReportQueue
    )
{
    return SendAdminGuidMessage(gDesMachine, gReportQueue, ADMIN_SET_REPORTQUEUE);
}




/*====================================================

GetQMReportState

  Queries the Targeted QM for the report-state .
  This action is done through falcon-messages to the
  target QM. The action has a timeout limit

  NOTE : Currently, the report-state is the propagation flag.

Arguments:

Return Value:

=====================================================*/

HRESULT
GetQMReportState(
    const GUID& gMachineID,
    BOOL& fReportState
    )
{
    CString strMsgBody = ADMIN_GET_PROPAGATEFLAG;

    HRESULT hr;
    fReportState = FALSE; // default value

    P<UCHAR> pBuffer;
    DWORD dwResponseSize = 0;

    hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return(hr);
    }

    switch (pBuffer[0] /* Status */)
    {
        case ADMIN_STAT_OK:

            fReportState =
             (pBuffer[1] == PROPAGATE_FLAG_TRUE) ? TRUE : FALSE;

            hr = MQ_OK;
            break;

        default:
            hr = MQ_ERROR;

    }

    return hr;
}


/*====================================================

SetQMReportState

Arguments:

Return Value:

=====================================================*/

HRESULT
SetQMReportState(
    const GUID& gMachineID,
    BOOL fReportState
    )
{
    //
    // Get the Target Admin Queue's format name
    //
    CString strAdminQueueFormatName;

    GetAdminQueueFormatName(gMachineID, strAdminQueueFormatName);

    //
    // prepare message body and send it along with the appropriate title of
    // admin commands
    //
    CString strMsgBody;

    strMsgBody = ADMIN_SET_PROPAGATEFLAG;
    strMsgBody += L"=";
    strMsgBody += (fReportState) ? PROPAGATE_STRING_TRUE : PROPAGATE_STRING_FALSE;

    return (SendMSMQMessage(strAdminQueueFormatName,
                              ADMIN_COMMANDS_TITLE,
                              strMsgBody,
                              (strMsgBody.GetLength() + 1)*sizeof(TCHAR)
                              ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\aliasq.h ===
//aliasq.h : Declaration of the CAliasQObject

#ifndef __ALIASQ_H_
#define __ALIASQ_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CAliasQObject
class CAliasQObject : 
	public CDataObject,
    //public CMsmqDataObject,
	public CComCoClass<CAliasQObject, &CLSID_AliasQObject>,
    public IDsAdminCreateObj

{
public:
    DECLARE_NOT_AGGREGATABLE(CAliasQObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_ALIASQOBJECT)

    BEGIN_COM_MAP(CAliasQObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

public:

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();
    
    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);

    //
    // implementation for pure virtual function of CDataObject
    //
    virtual const DWORD GetObjectType() { return 0;}
    virtual const PROPID *GetPropidArray() {return NULL;}
    virtual const DWORD  GetPropertiesCount() {return 0;}
    
private:

    CString m_strContainerNameDispFormat; 
	CString m_strContainerName;
	
};


#endif //__ALIASQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\aliasq.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aliasq.cpp

Abstract:

    Implementation of CAliasQObject

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "aliasq.h"
#include "aliasgen.h"
#include "globals.h"
#include "newalias.h"

#include "aliasq.tmh"

/////////////////////////////////////////////////////////////////////////////
// CAliasQObject


//
// IShellPropSheetExt
//

HRESULT 
CAliasQObject::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{                
    return ExtractAliasPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}


STDMETHODIMP 
CAliasQObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    HPROPSHEETPAGE hPage = CreateGeneralPage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }       

    //
    // Add the "Member Of" page using the cached interface
    //    
    if (m_spMemberOfPage != 0)
    {
        VERIFY(SUCCEEDED(m_spMemberOfPage->AddPages(lpfnAddPage, lParam)));
    }
   
    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }    

    return S_OK;
}

HPROPSHEETPAGE 
CAliasQObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    

	CMqDsPropertyPage<CAliasGen> *pcpageGeneral = 
        new CMqDsPropertyPage<CAliasGen>(m_pDsNotifier);
    if (FAILED(pcpageGeneral->InitializeProperties(m_strLdapName, m_strMsmqPath)))
    {
        delete pcpageGeneral;

        return 0;
    }

	return CreatePropertySheetPage(&pcpageGeneral->m_psp);  
}

//
// IContextMenu
//
STDMETHODIMP 
CAliasQObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return 0;
}

STDMETHODIMP 
CAliasQObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    ASSERT(0);

    return S_OK;
}


STDMETHODIMP CAliasQObject::Initialize(IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{   
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }
    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));

    //
    // Get the container distinguish name
    //   
    VARIANT var;

    hr = pIADs->Get(const_cast<WCHAR*> (x_wstrDN), &var);
    ASSERT(SUCCEEDED(hr));
        
	if ( !GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerNameDispFormat) )
	{
		m_strContainerNameDispFormat = L"";
	}
	m_strContainerName = var.bstrVal;

    VariantClear(&var);

    return S_OK;
}

HRESULT 
CAliasQObject::CreateModal(HWND hwndParent, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
           
    R<CNewAlias> pNewAlias = new CNewAlias(m_strContainerName, m_strContainerNameDispFormat);       
	CGeneralPropertySheet propertySheet(pNewAlias.get());
	pNewAlias->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pNewAlias data also after DoModal() exitst
	//
	pNewAlias->AddRef();
	INT_PTR iStatus = propertySheet.DoModal();

    if(iStatus == IDCANCEL || FAILED(pNewAlias->GetStatus()))
    {
        //
        // We should return S_FALSE here to instruct the framework to 
        // do nothing. If we return an error code, the framework will 
        // pop up an additional error dialog box.
        //
        return S_FALSE;
    }

    //
    // Check if creation succeeded
    //
    LPCWSTR wcsAliasFullPath = pNewAlias->GetAliasFullPath();
    if (wcsAliasFullPath == NULL)
    {
        return S_FALSE;
    }        

    HRESULT rc = ADsOpenObject( 
		            (LPWSTR)wcsAliasFullPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) ppADsObj
					);

    if(FAILED(rc))
    {   
        if ( ADProviderType() == eMqdscli)
        {
            AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        }
        else
        {
            MessageDSError(rc, IDS_CREATED_BUT_RETRIEVE_FAILED);
        }
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\adsutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adsutil.cpp

Abstract:

    Implementation of CAdsUtil: auxiliary class to use ADSI API

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "adsutil.h"

#include "adsutil.tmh"

CAdsUtil::CAdsUtil(CString strParentName, 
                   CString strObjectName,
                   CString strFormatName)
	:   m_strParentName(strParentName),
        m_strObjectName(strObjectName),
        m_strFormatName(strFormatName),
        m_pIAds (NULL)
{	
}

CAdsUtil::CAdsUtil(CString strLdapPath)
	:   m_strLdapPath(strLdapPath) ,
        m_pIAds (NULL)
{	
}

CAdsUtil::~CAdsUtil()
{    
    if (m_pIAds)
    {
        m_pIAds->Release();
    }
}

HRESULT CAdsUtil::CreateAliasObject(CString *pstrFullPathName)
{
    CString strTemp = x_wstrLdapPrefix;
    strTemp += m_strParentName;

    // First, we must bind to the parent container
    R<IADsContainer>  pContainer  = NULL;
    HRESULT hr = ADsOpenObject( 
					strTemp,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADsContainer,
					(void**)&pContainer
					);

    if (FAILED(hr))
    {       
        return hr;
    }    

    CString strChildFullPathName = x_CnPrefix + m_strObjectName; 

    R<IDispatch> pDisp = NULL;
      
    hr = pContainer->Create(const_cast<WCHAR*> (x_wstrAliasClass),
                            strChildFullPathName.AllocSysString(),
                            (IDispatch **) &pDisp);
    if (FAILED(hr))
    {     
        return hr;
    }    

    R<IADs> pChild  = NULL;

    hr = pDisp->QueryInterface (IID_IADs,(LPVOID *) &pChild);
    if (FAILED(hr))
    {     
        return hr;
    }    
         
    VARIANT vProp;
    vProp.vt = VT_BSTR;
    vProp.bstrVal = SysAllocString(m_strFormatName);

    hr = pChild->Put(const_cast<WCHAR*> (x_wstrAliasFormatName), vProp);        
    if (FAILED(hr))
    {           
        return hr;
    }        
    VariantClear(&vProp);


    // Finalize creation - commit it 
    //
    hr = pChild->SetInfo();
    if (FAILED(hr))
    {
        return hr;
    }    
    
    BSTR bs;
    hr = pChild->get_ADsPath(&bs);
    if (FAILED(hr))
    {       
        return hr;
    }

    *pstrFullPathName = bs;    

    return MQ_OK;
}

HRESULT CAdsUtil::InitIAds ()
{
    ASSERT(!m_strLdapPath.IsEmpty());  

    HRESULT hr = ADsOpenObject( 
					m_strLdapPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &m_pIAds
					);
    return hr;
}

HRESULT CAdsUtil::GetObjectProperty ( 
                        CString strPropName, 
                        CString *pstrPropValue)
{
    ASSERT(!m_strLdapPath.IsEmpty());
    ASSERT (m_pIAds);    

    VARIANT var;

    HRESULT hr = m_pIAds->Get(strPropName.AllocSysString(), &var);

	if ( SUCCEEDED(hr) )
	{
		*pstrPropValue = var.bstrVal;
	}

    VariantClear(&var);
    return hr;
}

HRESULT  CAdsUtil::SetObjectProperty (CString strPropName, 
                                      CString strPropValue)
{
    ASSERT(!m_strLdapPath.IsEmpty()); 
    ASSERT (m_pIAds); 

    VARIANT var;
    VariantInit(&var);
 
    // Setting the format name
    
    V_BSTR(&var) = SysAllocString(strPropValue);
    V_VT(&var) = VT_BSTR;
    HRESULT hr = m_pIAds->Put( strPropName.AllocSysString(), var );
    if (FAILED(hr))
    {
        return hr;
    }    
    VariantClear(&var);
       
    return hr;   
}

HRESULT CAdsUtil::CommitChanges()
{
    HRESULT hr = m_pIAds->SetInfo();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\aliasgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aliasgen.cpp

Abstract:

    Alias Queue General property page implementation

Author:

    Tatiana Shubin (tatianas)

--*/

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "AliasGen.h"
#include "globals.h"
#include "adsutil.h"

#include "aliasgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//#define ALIAS_PROP   2

/////////////////////////////////////////////////////////////////////////////
// CAliasGen property page

IMPLEMENT_DYNCREATE(CAliasGen, CMqPropertyPage)

CAliasGen::CAliasGen() : CMqPropertyPage(CAliasGen::IDD)    
{
	//{{AFX_DATA_INIT(CAliasGen)	
    m_strAliasPathName = _T("");
    m_strAliasFormatName = _T("");
    m_strDescription = _T("");
	//}}AFX_DATA_INIT
}

CAliasGen::~CAliasGen()
{
}

void CAliasGen::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAliasGen)	
    DDX_Text(pDX, IDC_ALIAS_LABEL, m_strAliasPathName);
    DDX_Text(pDX, IDC_ALIAS_FORMATNAME, m_strAliasFormatName);
    DDX_Text(pDX, IDC_ALIAS_DESCRIPTION, m_strDescription);
    DDV_NotEmpty(pDX, m_strAliasFormatName, IDS_MISSING_ALIAS_FORMATNAME);
	DDV_ValidFormatName(pDX, m_strAliasFormatName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAliasGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CAliasGen)
	ON_EN_CHANGE(IDC_ALIAS_FORMATNAME, OnChangeRWField)
    ON_EN_CHANGE(IDC_ALIAS_DESCRIPTION, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAliasGen message handlers

BOOL CAliasGen::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //

    UpdateData( FALSE );
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT
CAliasGen::InitializeProperties(CString strLdapPath, CString strAliasPathName)
{
    //
    // get alias properties using ADSI 
    //
    CAdsUtil AdsUtil(strLdapPath);
    
    HRESULT hr = AdsUtil.InitIAds();
    if (FAILED(hr))
    {     
        return hr;
    }

    hr = AdsUtil.GetObjectProperty(                             
                        x_wstrAliasFormatName, 
                        &m_strAliasFormatName);
    if (FAILED(hr))
    {
        //
        // must be defined
        //
        return hr;
    }

    hr = AdsUtil.GetObjectProperty(                             
                        x_wstrDescription, 
                        &m_strDescription);
    if (FAILED(hr))
    {
        //
        // maybe not set
        //
        m_strDescription.Empty();
    }
      
    m_strAliasPathName = strAliasPathName;    
    m_strInitialAliasFormatName = m_strAliasFormatName;
    m_strInitialDescription = m_strDescription;
    m_strLdapPath = strLdapPath;

    return MQ_OK;
}

HRESULT CAliasGen::SetChanges()
{    
    CAdsUtil AdsUtil(m_strLdapPath);

    HRESULT hr = AdsUtil.InitIAds();
    if (FAILED(hr))
    {       
        return hr;
    }

    //
    // if initial format name was changed so set it using ADSI API
    //
    if (m_strInitialAliasFormatName != m_strAliasFormatName)
    {        
        hr = AdsUtil.SetObjectProperty(
                        x_wstrAliasFormatName, 
                        m_strAliasFormatName);
        if (FAILED(hr))
        {       
            return hr;
        }
    }
    
    //
    // if initial description was changed so set it using ADSI API
    //
    if (m_strInitialDescription != m_strDescription)
    {
        hr = AdsUtil.SetObjectProperty(
                        x_wstrDescription, 
                        m_strDescription);
    }
    
    if (FAILED(hr))
    {       
        return hr;
    }

    hr = AdsUtil.CommitChanges();   

    return hr;
}


BOOL CAliasGen::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    HRESULT hr = SetChanges();
    if (FAILED(hr))
    {       
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strAliasPathName);
        return FALSE;        
    }
   
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\adsutil.h ===
//adsutil.h

class CAdsUtil
{
public:
    CAdsUtil(CString strParentName, 
             CString strObjectName,
             CString strFormatName);
    CAdsUtil(CString strLdapPath);

    ~CAdsUtil ();

    HRESULT CreateAliasObject(CString *pstrFullPathName);
    
    HRESULT InitIAds ();    

    HRESULT GetObjectProperty (                 
                CString strPropName, 
                CString *pstrPropValue);
    HRESULT SetObjectProperty (               
                CString strPropName, 
                CString strPropValue);
    HRESULT CommitChanges();

private:
    CString m_strParentName;
    CString m_strObjectName;
    CString m_strFormatName;
    
    CString m_strLdapPath;

    IADs *m_pIAds;
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\admmsg.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   admmsg.h

Abstract:

   Definition of functions used for Admin messages

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////


HRESULT RequestPrivateQueues(const GUID& gMachineID, PUCHAR *ppListofPrivateQ, DWORD *pdwNoofQ);
HRESULT RequestDependentClient(const GUID& gMachineID, CList<LPWSTR, LPWSTR&>& DependentMachineList);
HRESULT MQPing(const GUID& gMachineID);
HRESULT SendQMTestMessage(GUID &gMachineID, GUID &gQueueId);
HRESULT GetQMReportQueue(const GUID& gMachineID, CString& strRQPathname, const CString& strDomainController);
HRESULT SetQMReportQueue(const GUID& gDesMachine, const GUID& gReportQueue);
HRESULT GetQMReportState(const GUID& gMachineID, BOOL& fReportState);
HRESULT SetQMReportState(const GUID& gMachineID, BOOL fReportState);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\aliasgen.h ===
#if !defined(AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AliasGen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CAliasGen dialog

class CAliasGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CAliasGen)

// Construction
public:
    CAliasGen() ;
	~CAliasGen();
   
    HRESULT InitializeProperties(
                CString strLdapPath, 
                CString strAliasPathName
                );

// Dialog Data
	//{{AFX_DATA(CAliasGen)
	enum { IDD = IDD_ALIAS_GENERAL };	
	CString	m_strAliasPathName;
    CString	m_strAliasFormatName;
    CString	m_strDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAliasGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAliasGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    HRESULT SetChanges();

    CString m_strInitialAliasFormatName;
    CString m_strInitialDescription;

    CString m_strLdapPath;

    
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\alloc.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    alloc.cpp

Abstract:
    Memory Allocation functions module. Mqsnap needs it own memory allocation
	function and cannot use those  implemented in mm.lib because
	it's allocator needs to be  compatibile with crt allocator since
	mfc deletes objects that mqsnap allocates at start up. 

Author:

    Gil Shafriri (gilsh) 04-Jan-2001

--*/
#include "stdafx.h"

#include "alloc.tmh"

using std::nothrow_t;
using std::bad_alloc;

void* MmAllocate(size_t s) throw(bad_alloc)
{
    void* p = malloc(s);

    if(p != 0)
		return p;

	throw bad_alloc();
}


void* MmAllocate(size_t s, const nothrow_t&) throw()
{
    return malloc(s);
}


void* MmAllocate(size_t s, const char* /* fn */, int /* l */) throw(bad_alloc)
{
    void* p = malloc(s);

    if(p != 0)
		return p;

	throw bad_alloc();
}


void* MmAllocate(size_t s, const char* /* fn */, int /* l */, const nothrow_t&) throw()
{

    return malloc(s);
}


void MmDeallocate(void* p) throw()
{
    free(p);
}

PVOID ADAllocateMemory(IN DWORD size)
{
	return MQAllocateMemory(size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\atlmyimpl.cpp ===
#include "stdafx.h"

#pragma warning(disable: 4267)

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

#pragma warning(disable: 4505)
#include <statreg.cpp>

#endif


//#define ATL_NO_NAMESPACE

#include <atlimpl.cpp>
#include <atlwin.cpp>

#pragma warning(default: 4267)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\certgen.cpp ===
// CertGen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqcert.h"
#include "mqPPage.h"
#include "CertGen.h"
#include "mqcertui.h"
#include "rtcert.h"

#include "certgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCertGen property page

IMPLEMENT_DYNCREATE(CCertGen, CMqPropertyPage)

CCertGen::CCertGen() :
    CMqPropertyPage(CCertGen::IDD),
    m_pCertListBox(NULL),
    m_pCertList(NULL),
    m_NumOfCertificate(0)
{
	//{{AFX_DATA_INIT(CCertGen)
	m_Label = _T("");
	//}}AFX_DATA_INIT
}

CCertGen::~CCertGen()
{
    for(DWORD i = 0; i < m_NumOfCertificate; ++i)
    {
        m_pCertList[i]->Release();
    }

    delete [] m_pCertList;
}

void CCertGen::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertGen)
	DDX_Text(pDX, IDC_CERTLABEL, m_Label);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CCertGen)
	ON_BN_CLICKED(IDC_CERT_VIEW, OnCertView)
	ON_BN_CLICKED(IDC_CERT_REMOVE, OnCertRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void
CCertGen::Initialize(
    CMQSigCertificate** ppCertList,
    DWORD NumOfCertificate
    )
{
    m_pCertList = ppCertList;
    m_NumOfCertificate = NumOfCertificate;
}

//
// Function -
//      FillCertsList
//
// Parameters
//      None.
//
// Description -
//      Goes over the entries in p509List, for each entry puts the common name
//      of the X509 cert subject in the list box.
//
void
CCertGen::FillCertsList(
    void
    )
{
    DWORD i;
    CMQSigCertificate* pCert ;

    ASSERT(m_pCertList != NULL);
    ASSERT(m_NumOfCertificate != 0);


    for (i = 0; i < m_NumOfCertificate; ++i)
    {
        HRESULT hr;
        pCert = m_pCertList[i];

        CAutoMQFree<CERT_NAME_INFO> pNameInfo ;

        hr = pCert->GetSubjectInfo(&pNameInfo);
        if (SUCCEEDED(hr))
        {
            CAutoMQFree<WCHAR> wszCommonName = NULL;
            hr = pCert->GetNames(
                            pNameInfo,
                            NULL,
                            NULL,
                            NULL,
                            &wszCommonName
                            );


            if (SUCCEEDED(hr) && (wszCommonName != NULL) )
            {
                int iNewItem;

                VERIFY(CB_ERR != (iNewItem = m_pCertListBox->AddString(wszCommonName)));
                VERIFY(CB_ERR != m_pCertListBox->SetItemData(iNewItem, i));
            }
        }
    }
}

BOOL CCertGen::OnInitDialog()
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Load Label
        //
        m_Label.LoadString(IDS_SHOWCERTINSTR);

        //
        // Initialize pointer to ListBox
        //
        m_pCertListBox = (CListBox *)GetDlgItem(IDC_CERT_LIST);
        FillCertsList();
    }

    UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCertGen::OnCertView()
{
    HRESULT hr;
    BOOL fInternal = FALSE;

    DWORD_PTR Index;
    int iSelected;

    //
    // Get the index of the selected cell on the Certificate array
    //
    iSelected = m_pCertListBox->GetCurSel();
    if (CB_ERR == iSelected)
    {
        return;
    }

    VERIFY(CB_ERR != (Index = m_pCertListBox->GetItemData(iSelected)));

    CMQSigCertificate *pCertSel = m_pCertList[Index];

    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;

    hr =  pCertSel->GetSubjectInfo(&pNameInfo);
    if (SUCCEEDED(hr))
    {
        CAutoMQFree<WCHAR> wszLocality = NULL;
        hr = pCertSel->GetNames(
                            pNameInfo,
                            &wszLocality,
                            NULL,
                            NULL,
                            NULL
                            );

        if (SUCCEEDED(hr) && (wszLocality != NULL) )
        {
            fInternal = (wcscmp(wszLocality, L"MSMQ") == 0);
        }
    }

    ShowCertificate(m_hWnd, pCertSel, fInternal);

}


void CCertGen::OnCertRemove()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr;
    DWORD_PTR Index;
    int iSelected;

    //
    // Get the index of the selected cell on the Certificate array
    //
    iSelected = m_pCertListBox->GetCurSel();
    if (CB_ERR == iSelected)
    {
        return;
    }
    VERIFY(CB_ERR != (Index = m_pCertListBox->GetItemData(iSelected)));

    CMQSigCertificate *pCertSel = m_pCertList[Index];

    hr = RTRemoveUserCert(pCertSel);

    if (FAILED(hr))
    {
        CString  strErrorMessage;

        strErrorMessage.FormatMessage(IDS_DELETE_USER_CERT_ERROR, hr);
        AfxMessageBox(strErrorMessage, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    VERIFY(LB_ERR != m_pCertListBox->DeleteString(iSelected));

    if (m_pCertListBox->GetCount() == 0)
    {
        CWnd* pWin;

        pWin = GetDlgItem(IDC_CERT_VIEW);
        pWin->EnableWindow(FALSE);
        pWin = GetDlgItem(IDC_CERT_REMOVE);
        pWin->EnableWindow(FALSE);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

extern HMODULE	    g_hResourceMod;

template <class T, bool bAutoDelete = TRUE>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = g_hResourceMod;
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC) T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > _thisClass;
	BEGIN_MSG_MAP(_thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CMySimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CMySimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CMySimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};
#endif


class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CMySimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_spConsole);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(_T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole->QueryInterface(IID_IHeaderCtrl, (void**)&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
    
    STDMETHOD(Destroy)(MMC_COOKIE cookie)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE(_T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions);
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T>
HRESULT IComponentImpl<T>::Notify(LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IComponentImpl::Notify\n"));
	ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
	HRESULT hr = E_POINTER;

	if (lpDataObject == NULL)
		ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		// Make sure that the object is derived from CSnapInObjectRoot
		hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
		if (SUCCEEDED(hr))
			hr = pItem->Notify(event, arg, param, NULL, pT, type);
	}
	return hr;
}

template <class T>
HRESULT IComponentImpl<T>::GetResultViewType(MMC_COOKIE cookie,
    LPOLESTR  *ppViewType,
    long  *pViewOptions)
{
	ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

	HRESULT hr = E_FAIL;
	if (cookie == NULL)
	{
		T* pT = static_cast<T*> (this);
		ATLASSERT( pT->m_pComponentData != NULL );
		ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
		hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
	}
	else
	{
		CSnapInItem* pItem = (CSnapInItem*)cookie;
		hr = pItem->GetResultViewType(ppViewType, pViewOptions);
	}
	return hr;
}

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed);
	
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
};

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
	ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
	}
	return hr;
}

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::Command(long lCommandID,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
			hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
	}
	return hr;
}

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject);
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);
};

template<class T>
inline HRESULT IExtendPropertySheetImpl<T>::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
	}

	return hr;
}

template <class T>
inline HRESULT IExtendPropertySheetImpl<T>::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
	

	HRESULT hr = E_POINTER;
	
	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->QueryPagesFor(type);
	}
	return hr;
}

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
};

template <class T>
inline HRESULT IExtendControlbarImpl<T>::ControlbarNotify(MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

	CSnapInItem* pItem = NULL;
	DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
	HRESULT hr = S_OK;
	T* pT = static_cast<T*>(this);

	if (event == MMCN_BTN_CLICK)
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
	else if (event == MMCN_SELECT)
	{
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
		BOOL bSelect = (BOOL) HIWORD (arg);
		BOOL bScope = (BOOL) LOWORD(arg); 
		if (bSelect)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
					pT->m_spControlbar->Detach(pToolbar);
			}
		}
	}

	if (SUCCEEDED(hr))
		hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

	return hr;
}
#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	~CSnapInToolbarInfo()
	{
		CleanUp();
	}

	HRESULT CleanUp()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		return S_OK;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

				
		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(g_hResourceMod, MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(g_hResourceMod, menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(g_hResourceMod, MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(g_hResourceMod, hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}


			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(g_hResourceMod, pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg, 
		LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			if (!bSelect)
				return S_OK;
			BOOL bScope = (BOOL) LOWORD(arg); 

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;

				pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& bHandled,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\client.cpp ===
// ClientPage.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include <rt.h>
#include "_registr.h"
#include "localutl.h"
#include "client.h"
#include "mqcast.h"

#include "client.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientPage property page

IMPLEMENT_DYNCREATE(CClientPage, CMqPropertyPage)

CClientPage::CClientPage() : CMqPropertyPage(CClientPage::IDD)
{
	//{{AFX_DATA_INIT(CClientPage)
	m_szServerName = _T("");
	//}}AFX_DATA_INIT  
    DWORD dwType = REG_SZ ;
    TCHAR szRemoteMSMQServer[ MAX_COMPUTERNAME_LENGTH+1 ];
    DWORD dwSize = sizeof(szRemoteMSMQServer) ;
    HRESULT rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
                                    &dwType,
                                    (PVOID) szRemoteMSMQServer,
                                    &dwSize ) ;
    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }
    m_szServerName = szRemoteMSMQServer;
    m_fModified = FALSE;
}

CClientPage::~CClientPage()
{
}

void CClientPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);

    if(pDX->m_bSaveAndValidate == FALSE)
    {   
        // 
        // On entry save current state
        //
       _tcscpy(m_szOldServer, m_szServerName);
    }

	//{{AFX_DATA_MAP(CClientPage)
	DDX_Text(pDX, IDC_ServerName, m_szServerName);
	//}}AFX_DATA_MAP

    if(pDX->m_bSaveAndValidate)
    {
        //
        // Trim spaces from server name
        //
        m_szServerName.TrimLeft();
        m_szServerName.TrimRight();

        //
        // On exit, check changes
        //
        if(m_szServerName != m_szOldServer)
            m_fModified = TRUE;
    }
}

BOOL CClientPage::OnApply()
{
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    //
    // Set changes in the registry
    //
    //ConvertToWideCharString(pageClient.m_szServerName,wszServer);	
    DWORD dwType = REG_SZ;
    DWORD dwSize = (numeric_cast<DWORD>(_tcslen(m_szServerName) + 1)) * sizeof(TCHAR);
    HRESULT rc = SetFalconKeyValue(RPC_REMOTE_QM_REGNAME,&dwType,m_szServerName,&dwSize);

    m_fNeedReboot = TRUE;
    return CMqPropertyPage::OnApply();
}

BEGIN_MESSAGE_MAP(CClientPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CClientPage)
		// NOTE: the ClassWizard will add message map macros here
        ON_EN_CHANGE(IDC_ServerName, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\certgen.h ===
#if !defined(AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CertGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCertGen dialog

class CCertGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CCertGen)

// Construction
public:
	CCertGen();
	~CCertGen();

    void
    Initialize(
        CMQSigCertificate** pCertList,
        DWORD NumOfCertificate
        );

// Dialog Data
	//{{AFX_DATA(CCertGen)
	enum { IDD = IDD_USER_CERTIFICATE };
	CString	m_Label;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertGen)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertGen)
	virtual BOOL OnInitDialog();
	afx_msg void OnCertView();
	afx_msg void OnCertRemove();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void
    FillCertsList(
        void
        );

    CListBox* m_pCertListBox;

    CMQSigCertificate** m_pCertList;
    DWORD m_NumOfCertificate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\cmpmrout.cpp ===
// CmpMRout.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "frslist.h"
#include "globals.h"
#include "mqPPage.h"
#include "CmpMRout.h"

#include "cmpmrout.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting property page

IMPLEMENT_DYNCREATE(CComputerMsmqRouting, CMqPropertyPage)

CComputerMsmqRouting::CComputerMsmqRouting() : CMqPropertyPage(CComputerMsmqRouting::IDD),
  	m_strMsmqName(_T(""))
{
	//{{AFX_DATA_INIT(CComputerMsmqRouting)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_caclsidOutFrs.cElems = 0;
    m_caclsidOutFrs.pElems = m_OutFrsGuids;

    m_caclsidInFrs.cElems = 0;
    m_caclsidInFrs.pElems = m_InFrsGuids;
}

CMap<GUID, const GUID&, CString, LPCTSTR> CFrsList::m_mapFrsCache;

CComputerMsmqRouting::~CComputerMsmqRouting()
{
}

void CComputerMsmqRouting::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqRouting)
	//}}AFX_DATA_MAP
    BOOL fFirstTime = (m_frscmbInFrs[0].m_hWnd  == NULL);

	DDX_Control(pDX, IDC_INROUTCOMBO_0,  m_frscmbInFrs[0]);
	DDX_Control(pDX, IDC_INROUTCOMBO_1,  m_frscmbInFrs[1]);
	DDX_Control(pDX, IDC_INROUTCOMBO_2,  m_frscmbInFrs[2]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_0, m_frscmbOutFrs[0]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_1, m_frscmbOutFrs[1]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_2, m_frscmbOutFrs[2]);

    //
    // Exchange FRS values
    //
    if (!pDX->m_bSaveAndValidate)
    {
        if (fFirstTime)
        {
	        m_frscmbInFrs[0].InitFrsList(&m_guidSiteID, m_strDomainController);

            m_frscmbOutFrs[2] = m_frscmbOutFrs[1] = m_frscmbOutFrs[0] = 
                m_frscmbInFrs[2] = m_frscmbInFrs[1] = m_frscmbInFrs[0];
        }

        InitiateOutFrsControls();
        InitiateInFrsControls();
    }
    else
    {
        SetOutFrsCauuid();
        SetInFrsCauuid();
    }
}


BEGIN_MESSAGE_MAP(CComputerMsmqRouting, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqRouting)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_0, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_1, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_2, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_0, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_1, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_2, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting message handlers

BOOL CComputerMsmqRouting::OnInitDialog() 
{	
	UpdateData( FALSE );
    m_fModified = FALSE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CComputerMsmqRouting::InitiateFrsControls(CACLSID &cauuid, CFrsList *pfrsListArray)
{
    ASSERT(cauuid.cElems <= x_dwMaxNumOfFrs);

    for (DWORD i = 0; i<min(cauuid.cElems, x_dwMaxNumOfFrs); i++)
    {
        if (FAILED(pfrsListArray[i].SelectGuid(cauuid.pElems[i], m_strDomainController)))
        {
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

BOOL CComputerMsmqRouting::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Write the R/W properties to the DS
        //
	    PROPID paPropid[] = 
            {PROPID_QM_OUTFRS, PROPID_QM_INFRS};

	    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	    PROPVARIANT apVar[x_iPropCount];
    
	    DWORD iProperty = 0;

        //
        // PROPID_QM_OUTFRS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_OUTFRS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;
	    apVar[iProperty++].cauuid = m_caclsidOutFrs;

        //
        // PROPID_QM_INFRS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_INFRS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;
	    apVar[iProperty++].cauuid = m_caclsidInFrs;
    
        HRESULT hr = ADSetObjectProperties(
                eMACHINE,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                m_strMsmqName,
                x_iPropCount, 
                paPropid, 
                apVar
                );

        if (MQ_OK != hr)
        {
            MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
            return FALSE;
        }
    }
	
	return CMqPropertyPage::OnApply();
}


void CComputerMsmqRouting::SetFrsCauuid(CACLSID &cauuid, GUID *aguid, CFrsList *frscmb)
{
    DWORD i,j;
    DWORD dwFrsCount = 0;
    for (i=0; i<x_dwMaxNumOfFrs; i++)
    {
        if (frscmb[i].GetSelectedGuid(aguid[dwFrsCount]))
        {
            dwFrsCount++;
        }
    }

    //
    // Remove duplicates
    //
    for (i=0; i<dwFrsCount; i++)
    {
        for(j=i+1; j<dwFrsCount; j++)
        {
            if (aguid[i] == aguid[j])
            {
                dwFrsCount--;
                aguid[j] = aguid[dwFrsCount];
                j--;
            }
        }
    }

    //
    // Set the CLSID set
    //
    cauuid.cElems = dwFrsCount;
    cauuid.pElems = aguid;
}

void CComputerMsmqRouting::CopyCaclsid(CACLSID &cauuidResult, const CACLSID *pcauuidSource)
{
    ASSERT(pcauuidSource->cElems <= x_dwMaxNumOfFrs);

    DWORD dwCElems = min(pcauuidSource->cElems, x_dwMaxNumOfFrs);

    cauuidResult.cElems = dwCElems;

    if (dwCElems > 0)
    {
        memcpy(cauuidResult.pElems, pcauuidSource->pElems, dwCElems*sizeof(GUID));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\client.h ===
// ClientPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientPage dialog

class CClientPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CClientPage)

// Construction
public:
	CClientPage();
	~CClientPage();

// Dialog Data
	//{{AFX_DATA(CClientPage)
	enum { IDD = IDD_CLIENT };
	CString	m_szServerName;
	//}}AFX_DATA
	TCHAR   m_szOldServer[1000];  

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CClientPage)
    public:
    virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CClientPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\atlapp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLAPP_H__
#define __ATLAPP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlapp.h requires atlbase.h to be included first
#endif

//#ifndef ATL_NO_NAMESPACE
//namespace ATL
//{
//#endif

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMessageFilter;
class CUpdateUIObject;
class CMessageLoop;


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap for ATL 2.0/2.1

#if (_ATL_VER < 0x0300)

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLTRACE2
#define ATLTRACE2(cat, lev, msg)	ATLTRACE(msg)
#endif

#ifndef ATLINLINE
#define ATLINLINE inline
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aT);
			m_aT = NULL;
			m_nSize = 0;
			m_nAllocSize = 0;
		}
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

#endif //(_ATL_VER < 0x0300)

/////////////////////////////////////////////////////////////////////////////
// CMessageFilter - Interface for message filter support

class ATL_NO_VTABLE CMessageFilter
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CUpdateUIObject - Interface for update UI support

class ATL_NO_VTABLE CUpdateUIObject
{
public:
	virtual BOOL DoUpdate() = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CMessageLoop - message loop implementation

class CMessageLoop
{
public:
	CSimpleArray<CMessageFilter*> m_aMsgFilter;
	CSimpleArray<CUpdateUIObject*> m_aUpdateUI;
	MSG m_msg;

// Message filter operations
	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Add(pMessageFilter);
	}
	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Remove(pMessageFilter);
	}
// Update UI operations
	BOOL AddUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Add(pUpdateUI);
	}
	BOOL RemoveUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Remove(pUpdateUI);
	}
// message loop
	int Run()
	{
		BOOL bDoIdle = TRUE;
		int nIdleCount = 0;
		BOOL bRet;

		for(;;)
		{
			while(!::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE) && bDoIdle)
			{
				if(!OnIdle(nIdleCount++))
					bDoIdle = FALSE;
			}

			bRet = ::GetMessage(&m_msg, NULL, 0, 0);

			if(bRet == -1)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("::GetMessage returned -1 (error)\n"));
				continue;	// error, don't process
			}
			else if(!bRet)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("CMessageLoop::Run - exiting\n"));
				break;		// WM_QUIT, exit message loop
			}

			if(!PreTranslateMessage(&m_msg))
			{
				::TranslateMessage(&m_msg);
				::DispatchMessage(&m_msg);
			}

			if(IsIdleMessage(&m_msg))
			{
				bDoIdle = TRUE;
				nIdleCount = 0;
			}
		}

		return (int)m_msg.wParam;
	}

	static BOOL IsIdleMessage(MSG* pMsg)
	{
		// These messages should NOT cause idle processing
		switch(pMsg->message)
		{
		case WM_MOUSEMOVE:
#ifndef UNDER_CE
		case WM_NCMOUSEMOVE:
#endif //!UNDER_CE
		case WM_PAINT:
		case 0x0118:	// WM_SYSTIMER (caret blink)
			return FALSE;
		}

		return TRUE;
	}

// Overrideables
	// Override to change message filtering
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		// loop backwards
		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
		{
			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
				return TRUE;
		}
		return FALSE;	// not translated
	}
	// override to change idle UI updates
	virtual BOOL OnIdle(int /*nIdleCount*/)
	{
		for(int i = 0; i < m_aUpdateUI.GetSize(); i++)
		{
			CUpdateUIObject* pUpdateUI = m_aUpdateUI[i];
			if(pUpdateUI != NULL)
				pUpdateUI->DoUpdate();
		}
		return FALSE;	// don't continue
	}
};


//#ifndef ATL_NO_NAMESPACE
//}; //namespace ATL
//#endif

#endif // __ATLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compdiag.cpp ===
// CompDiag.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "admmsg.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "testmsg.h"
#include "machtrac.h"
#include "CompDiag.h"

#include "compdiag.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag property page

IMPLEMENT_DYNCREATE(CComputerMsmqDiag, CMqPropertyPage)

CComputerMsmqDiag::CComputerMsmqDiag() : CMqPropertyPage(CComputerMsmqDiag::IDD)
{
	//{{AFX_DATA_INIT(CComputerMsmqDiag)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CComputerMsmqDiag::~CComputerMsmqDiag()
{
}

void CComputerMsmqDiag::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqDiag)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CComputerMsmqDiag, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqDiag)
	ON_BN_CLICKED(IDC_DIAG_PING, OnDiagPing)
	ON_BN_CLICKED(IDC_DIAG_SEND_TEST, OnDiagSendTest)
	ON_BN_CLICKED(IDC_DIAG_TRACKING, OnDiagTracking)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag message handlers

void CComputerMsmqDiag::OnDiagPing() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    MQPing(m_guidQM);

}

BOOL CComputerMsmqDiag::OnInitDialog() 
{
	UpdateData( FALSE );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqDiag::OnDiagSendTest() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CTestMsgDlg testMsgDlg(m_guidQM, m_strMsmqName, m_strDomainController, this);	
    testMsgDlg.DoModal();
}

void CComputerMsmqDiag::OnDiagTracking() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CMachineTracking machTracking(m_guidQM, m_strDomainController);
    machTracking.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compdiag.h ===
#if !defined(AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_)
#define AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompDiag.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag dialog

class CComputerMsmqDiag : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqDiag)

// Construction
public:
	CString m_strMsmqName;
	CString	m_strDomainController;
	CComputerMsmqDiag();
	~CComputerMsmqDiag();
	GUID m_guidQM;

// Dialog Data
	//{{AFX_DATA(CComputerMsmqDiag)
	enum { IDD = IDD_COMPUTER_MSMQ_DIAGNOSTICS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqDiag)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqDiag)
	afx_msg void OnDiagPing();
	virtual BOOL OnInitDialog();
	afx_msg void OnDiagSendTest();
	afx_msg void OnDiagTracking();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	compext.h

Abstract:

	Definition for the computer extension snapnin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __COMPEXT_H_
#define __COMPEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"


/****************************************************

        CSnapinComputer Class
    
 ****************************************************/

class CSnapinComputer : public CNodeWithScopeChildrenList<CSnapinComputer, TRUE>
{
public:

	GUID    m_guidId;
	CString m_pwszComputerName;
    CString m_pwszGuid;
    BOOL    m_fDontExpand;
    HRESULT m_hrError;

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinComputer, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinComputer(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CNodeWithScopeChildrenList<CSnapinComputer, TRUE>(pParentNode, pComponentData ),
        m_hrError(MQ_OK)
    {
   		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    }

	~CSnapinComputer()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();


    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);

private:
};





/****************************************************

        CComputerExtData Class
    
 ****************************************************/

class CComputerExtData : public CSnapInItemImpl<CComputerExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *   m_pComponentData;


	BEGIN_SNAPINCOMMAND_MAP(CComputerExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CComputerExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

    CComputerExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CComputerExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);

   void RemoveAllChildrens(void);

   void RemoveChild(CString& strName);


private:

    CMap< CString, LPCWSTR, CSnapinComputer*, CSnapinComputer* > m_mapComputers;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\cmpmrout.h ===
#if !defined(AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_)
#define AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CmpMRout.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting dialog
const DWORD x_dwMaxNumOfFrs = 3;

class CComputerMsmqRouting : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqRouting)

// Construction
public:
	GUID m_guidSiteID;
	CComputerMsmqRouting();
	~CComputerMsmqRouting();

    void InitiateOutFrsValues(const CACLSID *pcauuid);
    void InitiateInFrsValues(const CACLSID *pcauuid);

// Dialog Data
	//{{AFX_DATA(CComputerMsmqRouting)
	enum { IDD = IDD_COMPUTER_MSMQ_ROUTING };
	//}}AFX_DATA
	CString	m_strMsmqName;
	CString	m_strDomainController;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqRouting)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

protected:
   	HRESULT InitiateInFrsControls();
   	HRESULT InitiateOutFrsControls();
   	HRESULT InitiateFrsControls(CACLSID &cauuid, CFrsList *pfrsListArray);
   	void CopyCaclsid(CACLSID &cauuidResult, const CACLSID *pcauuidSource);

    CACLSID m_caclsidOutFrs;
    CACLSID m_caclsidInFrs;
    GUID m_OutFrsGuids[x_dwMaxNumOfFrs];
    GUID m_InFrsGuids[x_dwMaxNumOfFrs];

	CFrsList m_frscmbInFrs[x_dwMaxNumOfFrs];
	CFrsList m_frscmbOutFrs[x_dwMaxNumOfFrs];
    void SetOutFrsCauuid();
    void SetInFrsCauuid();
    void SetFrsCauuid(CACLSID &cauuid, GUID *aguid, CFrsList *frscmb);
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqRouting)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

inline void CComputerMsmqRouting::InitiateOutFrsValues(const CACLSID *pcauuid)
{
    CopyCaclsid(m_caclsidOutFrs, pcauuid);
}

inline void CComputerMsmqRouting::InitiateInFrsValues(const CACLSID *pcauuid)
{
    CopyCaclsid(m_caclsidInFrs, pcauuid);
}

inline HRESULT CComputerMsmqRouting::InitiateInFrsControls()
{
    return InitiateFrsControls(m_caclsidInFrs, m_frscmbInFrs);
}

inline HRESULT CComputerMsmqRouting::InitiateOutFrsControls()
{
    return InitiateFrsControls(m_caclsidOutFrs, m_frscmbOutFrs);
}

inline void CComputerMsmqRouting::SetOutFrsCauuid()
{
    SetFrsCauuid(m_caclsidOutFrs, m_OutFrsGuids, m_frscmbOutFrs);
}

inline void CComputerMsmqRouting::SetInFrsCauuid()
{
    SetFrsCauuid(m_caclsidInFrs, m_InFrsGuids, m_frscmbInFrs);
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compgen.h ===
#if !defined(AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_)
#define AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral dialog

class CComputerMsmqGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqGeneral)

// Construction
public:
	GUID m_guidID;
	DWORD m_dwJournalQuota;
	DWORD m_dwQuota;

    CComputerMsmqGeneral();
	~CComputerMsmqGeneral();

// Dialog Data
	//{{AFX_DATA(CComputerMsmqGeneral)
	enum { IDD = IDD_COMPUTER_MSMQ_GENERAL };
	CString	m_strMsmqName;
	CString	m_strDomainController;
	CString	m_strService;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnComputerMsmqMquotaCheck();
	afx_msg void OnComputerMsmqJquotaCheck();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compsite.cpp ===
// CompSite.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "CompSite.h"

#include "compsite.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites dialog
IMPLEMENT_DYNCREATE(CComputerMsmqSites, CMqPropertyPage)


CComputerMsmqSites::CComputerMsmqSites(BOOL fIsServer)
	: CMqPropertyPage(CComputerMsmqSites::IDD),
    m_fIsServer(fIsServer),
    m_fForeign(FALSE),
    m_nSites(0)
{
	//{{AFX_DATA_INIT(CComputerMsmqSites)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CComputerMsmqSites::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);

    BOOL fFirstTime = (m_clistAllSites.m_hWnd == NULL);

	//{{AFX_DATA_MAP(CComputerMsmqSites)
	DDX_Control(pDX, IDC_CURRENTSITES_LABEL, m_staticCurrentSitesLabel);
	DDX_Control(pDX, IDC_SITES_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_SITES_ADD, m_buttonAdd);
	DDX_Control(pDX, IDC_CURRENTSITES_LIST, m_clistCurrentSites);
	DDX_Control(pDX, IDC_ALLSITES_LIST, m_clistAllSites);
	//}}AFX_DATA_MAP

    if (fFirstTime)
    {
        InitiateSitesList();
    }

    ExchangeSites(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        EnableButtons();
    }
}


BEGIN_MESSAGE_MAP(CComputerMsmqSites, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqSites)
	ON_BN_CLICKED(IDC_SITES_ADD, OnSitesAdd)
	ON_BN_CLICKED(IDC_SITES_REMOVE, OnSitesRemove)
	ON_LBN_SELCHANGE(IDC_CURRENTSITES_LIST, EnableButtons)
	ON_LBN_SELCHANGE(IDC_ALLSITES_LIST, EnableButtons)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites message handlers


HRESULT CComputerMsmqSites::InitiateSitesList()
{
    //
    // Initiate the label of current sites
    //
    ASSERT(m_staticCurrentSitesLabel.m_hWnd != NULL);

    CString strLabelFormat, strLabelFinal;
    
    m_staticCurrentSitesLabel.GetWindowText(strLabelFormat);

    strLabelFinal.FormatMessage(strLabelFormat, m_strMsmqName);

    m_staticCurrentSitesLabel.SetWindowText(strLabelFinal);

    //
    // Prepare list of sites
    //
    ASSERT(m_clistAllSites.m_hWnd != NULL);

    DWORD dwSiteIndex = 0;
    m_clistAllSites.ResetContent();
    
    //
    // Initialize the full sites list
    //
	PROPID aPropId[] = {PROPID_S_SITEID, PROPID_S_PATHNAME};
	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

	PROPVARIANT apResultProps[x_nProps];

	CColumns columns;
	for (DWORD i=0; i<x_nProps; i++)
	{
		columns.Add(aPropId[i]);
	}
       
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS
        if (m_fForeign)
        {
            hr = ADQueryForeignSites(
                        GetDomainController(m_strDomainController),
						true,		// fServerName
                        columns.CastToStruct(),
                        &hEnume
                        );
        }
        else
        {
            hr = ADQueryAllSites(
                        GetDomainController(m_strDomainController),
						true,		// fServerName
                        columns.CastToStruct(),
                        &hEnume
                        );
        }
    }

    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return E_UNEXPECTED;
    }

	DWORD dwPropCount = x_nProps;
	while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
			&& (dwPropCount != 0) )
	{
        DWORD iProperty = 0;

        //
        // PROPID_S_SITEID
        //
        ASSERT(PROPID_S_SITEID == aPropId[iProperty]);
        CAutoMQFree<GUID> pguidSite = apResultProps[iProperty].puuid;
        iProperty++;

        //
        // PROPID_S_PATHNAME
        //
        ASSERT(PROPID_S_PATHNAME == aPropId[iProperty]);
        CAutoMQFree<WCHAR> lpwstrSiteName = apResultProps[iProperty].pwszVal;
        iProperty++;
        
        int nIndex = m_clistAllSites.AddString(lpwstrSiteName);
        if (FAILED(nIndex))
        {
            return E_UNEXPECTED;
        }

        m_aguidAllSites.SetAtGrow(dwSiteIndex, *(GUID *)pguidSite);
        m_clistAllSites.SetItemData(nIndex, dwSiteIndex);
        dwSiteIndex++;

		dwPropCount = x_nProps;
	}
    //
    // Sets the sites change flags array. This array will contain non zero
    // for a site that was changed (deleted from or added to the list) 
    // and zero otherwise.
    //
    if (m_piSitesChanges != 0)
    {
        delete m_piSitesChanges.detach();
    }

    m_nSites = DWORD_PTR_TO_DWORD(m_aguidAllSites.GetSize());
    m_piSitesChanges = new int[m_nSites];
    memset(m_piSitesChanges, 0, m_nSites*sizeof(m_piSitesChanges[0]));

    return S_OK;
}

BOOL CComputerMsmqSites::OnInitDialog() 
{
	UpdateData( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqSites::MoveClistItem(CListBox &clistDest, CListBox &clistSrc, int iIndex /* = -1 */)
{
    if ((-1) == iIndex)
    {
        iIndex = clistSrc.GetCurSel();
        if (LB_ERR == iIndex)
        {
            return;
        }
    }

    CString strItem;
    clistSrc.GetText(iIndex, strItem);

    int iIndexDest = clistDest.AddString(strItem);
    ASSERT(LB_ERR != iIndexDest);

    VERIFY(LB_ERR != clistDest.SetItemData(iIndexDest, clistSrc.GetItemData(iIndex)));

    VERIFY(LB_ERR != clistSrc.DeleteString(iIndex));
}

//
// MarkSitesChanged
// Return value: TRUE if there is net change in the sites since initialization.
// FALSE otherwise.
//
BOOL CComputerMsmqSites::MarkSitesChanged(CListBox* plb, BOOL fAdded)
{
    int nSelItems = plb->GetSelCount();
    BOOL fWasChange = FALSE;
    AP<int> piRgIndex = new int[nSelItems];
    plb->GetSelItems(nSelItems, piRgIndex );
    int i;
    for (i=0; i<nSelItems; i++)
    {
        DWORD_PTR dwSiteIndex = plb->GetItemData(piRgIndex[i]);
        if (fAdded)
        {
            m_piSitesChanges[dwSiteIndex]++;
        }
        else
        {
            m_piSitesChanges[dwSiteIndex]--;
        }


        if (m_piSitesChanges[dwSiteIndex] != 0)
        {
            fWasChange = TRUE;
        }
    }
    //
    // If this change only reverse past changes, go over all the array to see if 
    // there are changes left
    //
    if (!fWasChange)
    {
        for (i=0; i<(int)m_nSites; i++)
        {
            if (m_piSitesChanges[i] != 0)
            {
                fWasChange = TRUE;
                break;
            }
        }
    }

    return fWasChange;
}

void CComputerMsmqSites::OnSitesAdd() 
{
    BOOL fWasChange = MarkSitesChanged(&m_clistAllSites, TRUE);
    MoveSelected(&m_clistAllSites, &m_clistCurrentSites);
    OnChangeRWField(fWasChange);
}

void CComputerMsmqSites::OnSitesRemove() 
{
    BOOL fWasChange = MarkSitesChanged(&m_clistCurrentSites, FALSE);
    MoveSelected(&m_clistCurrentSites, &m_clistAllSites);
    OnChangeRWField(fWasChange);
}

void CComputerMsmqSites::EnableButtons()
{
    m_buttonAdd.EnableWindow(0 != m_clistAllSites.GetSelCount());
    m_buttonRemove.EnableWindow(0 != m_clistCurrentSites.GetSelCount());
}


BOOL CComputerMsmqSites::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Check for server (Bug #3965, YoelA, 14-Feb-1999)
        // Changing sites of an MSMQ server may break the system integrity in
        // mixed NT4/NT5 environment. Issue a warning.
        //
        if (m_fIsServer)
        {
            //
            // Check to see if any non foreign site was added to or removed from
            // this computer
            //
            BOOL fDisplaySitesWarning = FALSE;
            for (DWORD i=0; i<m_nSites; i++)
            {
                if(m_piSitesChanges[i] != 0)
                {
                    //
                    // Check if the site is foreign. Issue a warning if not.
                    //
                    BOOL fForeign = FALSE;
                    //
                    // Note that we do not check errors here. They are reported to the user,
                    // and in case of error (like no DS) we will treat the site as non
                    // foreign
                    //
                    GetSiteForeignFlag(&m_aguidAllSites[i], &fForeign, m_strDomainController);
                    if (FALSE == fForeign)
                    {
                        fDisplaySitesWarning = TRUE;
                        break;
                    }
                }
            }
            if (fDisplaySitesWarning)
            {
                if (IDYES != AfxMessageBox(IDS_SERVER_SITES_WARNING, MB_YESNO))
                {
                    return FALSE;
                }
            }
        }

        CWaitCursor wc;

        //
        // Write the R/W properties to the DS
        //
	    PROPID paPropid[] = {PROPID_QM_SITE_IDS};

	    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	    PROPVARIANT apVar[x_iPropCount];
    
	    DWORD iProperty = 0;

        //
        // PROPID_QM_SITE_IDS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_SITE_IDS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;

        INT_PTR iNumSites = m_aguidSites.GetSize();

        P<GUID> aguidSites = new GUID[iNumSites];

        for (INT_PTR i=0; i<iNumSites; i++)
        {
            aguidSites[i] = m_aguidSites[i];
        }

	    apVar[iProperty].cauuid.pElems = aguidSites;
	    apVar[iProperty].cauuid.cElems = (ULONG) INT_PTR_TO_INT(iNumSites);
    	 
        HRESULT hr = ADSetObjectProperties(
                        eMACHINE,
                        GetDomainController(m_strDomainController),
						true,	// fServerName
                        m_strMsmqName,
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

        if (MQ_OK != hr)
        {
            MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
            return FALSE;
        }
    }

    //
    // Reset change flag and changes array
    //
    OnChangeRWField(FALSE);
    memset(m_piSitesChanges, 0, m_nSites*sizeof(m_piSitesChanges[0]));

	return CMqPropertyPage::OnApply();
}

void CComputerMsmqSites::OnChangeRWField(BOOL bChanged)
{
    EnableButtons();
    CMqPropertyPage::OnChangeRWField(bChanged);
}

void CComputerMsmqSites::ExchangeSites(CDataExchange * pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!pDX->m_bSaveAndValidate)
    {
        CArray<GUID, const GUID&> aguidSites;
        aguidSites.Copy(m_aguidSites);

        int iNumSites = INT_PTR_TO_INT(aguidSites.GetSize());
        int iNumListElems = m_clistAllSites.GetCount();
        if(LB_ERR == iNumListElems)
        {
            ASSERT(0);
            return;
        }

        for(int i=0; i<iNumListElems && 0 < iNumSites; i++)
        {
            for (int j=0; j<iNumSites && i<iNumListElems;)
            {
                if (m_aguidAllSites[m_clistAllSites.GetItemData(i)] == 
                        aguidSites[j])
                {
                    aguidSites.RemoveAt(j);
                    iNumSites--;

                    MoveClistItem(m_clistCurrentSites, m_clistAllSites, i);
                    iNumListElems--;

                    //
                    // Current item was deleted from list - retry all sites 
                    // with the next item, that now have index i
                    //
                    j=0;
                }
                else
                {
                    j++;
                }
            }
        }
    }
    else
    {
        m_aguidSites.RemoveAll();
        int iNumListElems = m_clistCurrentSites.GetCount();
        if (iNumListElems == 0)
        {
            AfxMessageBox(IDS_YOU_MUST_SPECIFY_SITE);
            pDX->Fail();
        }

        for (int i=0; i<iNumListElems; i++)
        {
            m_aguidSites.Add(
                m_aguidAllSites[m_clistCurrentSites.GetItemData(i)]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compgen.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    compgen.cpp

Abstract:

    Computer MSMQ/General property page implementation

Author:

    Yoel Arnon (yoela)

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "CompGen.h"

#include "compgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral property page

IMPLEMENT_DYNCREATE(CComputerMsmqGeneral, CMqPropertyPage)

CComputerMsmqGeneral::CComputerMsmqGeneral() : 
    CMqPropertyPage(CComputerMsmqGeneral::IDD),
	m_dwQuota(0),
	m_dwJournalQuota(0)
{
	//{{AFX_DATA_INIT(CComputerMsmqGeneral)
	m_strMsmqName = _T("");
	m_strService = _T("");
	m_guidID = GUID_NULL;
	//}}AFX_DATA_INIT
}


CComputerMsmqGeneral::~CComputerMsmqGeneral()
{
}

void CComputerMsmqGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqGeneral)
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_NAME, m_strMsmqName);
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_SERVICE, m_strService);
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_ID, m_guidID);
	//}}AFX_DATA_MAP
	DDX_NumberOrInfinite(pDX, IDC_COMPUTER_MSMQ_QUOTA, IDC_COMPUTER_MSMQ_MQUOTA_CHECK, m_dwQuota);
	DDX_NumberOrInfinite(pDX, IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDC_COMPUTER_MSMQ_JQUOTA_CHECK, m_dwJournalQuota);
}


BEGIN_MESSAGE_MAP(CComputerMsmqGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqGeneral)
	ON_BN_CLICKED(IDC_COMPUTER_MSMQ_MQUOTA_CHECK, OnComputerMsmqMquotaCheck)
	ON_BN_CLICKED(IDC_COMPUTER_MSMQ_JQUOTA_CHECK, OnComputerMsmqJquotaCheck)
	ON_EN_CHANGE(IDC_COMPUTER_MSMQ_QUOTA, OnChangeRWField)
	ON_EN_CHANGE(IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral message handlers

BOOL CComputerMsmqGeneral::OnInitDialog() 
{

	UpdateData( FALSE );

    m_fModified = FALSE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqGeneral::OnComputerMsmqMquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_COMPUTER_MSMQ_QUOTA, IDC_COMPUTER_MSMQ_MQUOTA_CHECK);
    OnChangeRWField();
}

void CComputerMsmqGeneral::OnComputerMsmqJquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDC_COMPUTER_MSMQ_JQUOTA_CHECK);
    OnChangeRWField();
}

BOOL CComputerMsmqGeneral::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }
    //
    // Write the R/W properties to the DS
    //
	PROPID paPropid[] = 
        {PROPID_QM_QUOTA, PROPID_QM_JOURNAL_QUOTA};

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_Q_QUOTA
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwQuota ;

    //
    // PROPID_QM_JOURNAL_QUOTA
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwJournalQuota;
    	
	HRESULT hr = ADSetObjectProperties(
                        eMACHINE,
                        GetDomainController(m_strDomainController),
						true,	// fServerName
                        m_strMsmqName,
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

    if (MQ_OK != hr)
    {
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	compext.cpp

Abstract:
    Implementation of the Computer extension snapin

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "rt.h"
#include "dataobj.h"
#include "sysq.h"
#include "compext.h"

#include "compext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************

CSnapinComputer Class
    
 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {3FDC5B21-D4EB-11d1-9B9D-00E02C064C39}
static const GUID CSnapinComputerGUID_NODETYPE = 
{ 0x3fdc5b21, 0xd4eb, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CSnapinComputer::m_NODETYPE = &CSnapinComputerGUID_NODETYPE;
const OLECHAR* CSnapinComputer::m_SZNODETYPE = OLESTR("3FDC5B21-D4EB-11d1-9B9D-00E02C064C39");
const OLECHAR* CSnapinComputer::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinComputer::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputer::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputer::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (m_fDontExpand)
    {
        //
        // We don't need the scode data item if we do not expand the node
        //
       	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
        return m_hrError;
    }

    HRESULT hr = S_OK;
    CString strTitle;
    //
    // Add a system queue folder
    //
    CSystemQueues *pQ; 

    pQ = new CSystemQueues(this, m_pComponentData, m_pwszComputerName);
    strTitle.LoadString(IDS_SYSTEM_QUEUES);
    pQ->m_bstrDisplayName = strTitle;
    pQ->m_pwszGuid = m_pwszGuid;
    memcpy(&pQ->m_guidId, &m_guidId, sizeof(GUID));

   	AddChild(pQ, &pQ->m_scopeDataItem);


    //
    // Add a private queue folder
    //
    CPrivateFolder * pF;

    pF = new CPrivateFolder(this, m_pComponentData, m_pwszComputerName);
    strTitle.LoadString(IDS_PRIVATE_FOLDER);
    pF->m_bstrDisplayName = strTitle;
    pF->m_pwszGuid = m_pwszGuid;
    memcpy(&pF->m_guidId, &m_guidId, sizeof(GUID));

	AddChild(pF, &pF->m_scopeDataItem);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputer::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputer::OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{

    ((CComputerExtData *)m_pParentNode)->RemoveChild(m_pwszComputerName);

	return (S_OK);
}

    
/****************************************************

        CComputerExt Class
    
 ****************************************************/
//
// Extending the DS msmqconfiguration node type
//  taken from object:   GC://CN=MSMQ-Configuration,CN=Schema,CN=Configuration,DC=raphirdom,DC=Com
//             property: schemaIDGUID
//             value:    x44 xc3 x0d x9a x00 xc1 xd1 x11 xbb xc5 x00 x80 xc7 x66 x70 xc01
//

static const GUID CComputerExtDataGUID_NODETYPE = 
//{ 0x3c6e5d82, 0xc4b5, 0x11d1, { 0x9d, 0xb4, 0x9c, 0x71, 0xe8, 0x56, 0x3c, 0x51 } };
  { 0x9a0dc344, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } };

const GUID*  CComputerExtData::m_NODETYPE = &CComputerExtDataGUID_NODETYPE;
//const OLECHAR* CComputerExtData::m_SZNODETYPE = OLESTR("3c6e5d82-c4b5-11d1-9db4-9c71e8563c51");
const OLECHAR* CComputerExtData::m_SZNODETYPE = OLESTR("9a0dc344-c100-11d1-bbc5-0080c76670c0");
const OLECHAR* CComputerExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CComputerExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComputerExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::GetExtNodeObject

  Called with a node that we need to expand. 
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CComputerExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{

    CString             strComputerName;
    CSnapinComputer *   pComp;
    
	LPWSTR              lpwstrLdapName;
    LPDSOBJECTNAMES     pDSObj;

	m_pDataObject = pDataObject;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    //
    // Get the LDAP name of the computer from the DS Snapin
    //
   	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);

    if(FAILED(hr))
    {
        ATLTRACE(_T("CComputerExtData::GetExtNodeObject - Get clipboard format from DS failed\n"));
        return(pDefault);
    }

    pDSObj = (LPDSOBJECTNAMES)stgmedium.hGlobal;
    lpwstrLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);

	//
	// Get Domain Controller name
	//
    CString strDomainController;
	hr = ExtractDCFromLdapPath(strDomainController, lpwstrLdapName);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

	//
    // Translate (and keep) the LDAP name to a computer name
    //
    ExtractComputerMsmqPathNameFromLdapName(strComputerName, lpwstrLdapName);
	GlobalFree(stgmedium.hGlobal);

    //
    // Do we already have this object
    //
    BOOL fComputerExist = m_mapComputers.Lookup(strComputerName, pComp);
    if(fComputerExist == TRUE)
    {
        if (SUCCEEDED(pComp->m_hrError))
        {
            //
            // If there was no error last time, simply return the cashed 
            // result. Otherwise continue.
            //
            return(pComp);
        }
    }
    else
    {
        //
        // Not in the list, so create a queue object
        //
        pComp = new CSnapinComputer(this, m_pComponentData);
    }

    pComp->m_pwszComputerName = strComputerName;
    //
    // Get the GUID & foreign flag of the computer
    //
    PROPVARIANT   aPropVar[2];
    PROPID        aPropId[2];

    aPropVar[0].vt = VT_NULL;
    aPropVar[0].puuid = NULL;
    aPropId[0] = PROPID_QM_MACHINE_ID;

    aPropVar[1].vt = VT_NULL;
    aPropVar[1].bVal = FALSE;
    aPropId[1] = PROPID_QM_FOREIGN;
  

    hr = ADGetObjectProperties(
                eMACHINE,
                GetDomainController(strDomainController),
				true,	// fServerName
                strComputerName,
                ARRAYSIZE(aPropId), 
                aPropId,
                aPropVar
                );

    if(SUCCEEDED(hr))
    {
        ASSERT(PROPID_QM_MACHINE_ID == aPropId[0]);
        //
        // Keep the guid
        //
        memcpy(&(pComp->m_guidId), aPropVar[0].puuid, sizeof(GUID));

        //
        // And a stringize version of the guid
        //
        g_VTCLSID.Display(&aPropVar[0], pComp->m_pwszGuid);

        //
        // Free memory
        // 
        MQFreeMemory(aPropVar[0].puuid);

        ASSERT(PROPID_QM_FOREIGN == aPropId[1]);
        //
        // if Foreign - do not extend (IE do not create system / private queues sub folders)
        //
        if (aPropVar[1].bVal)
        {
            pComp->m_fDontExpand = TRUE;
        }
        else
        {
            pComp->m_fDontExpand = FALSE;
        }

    }
    else
    {
        //
        // Most probably, MSMQ is not running. We do not want to report an
        // error - we simply don't display the system / private queues.
        //
        pComp->m_pwszGuid = L"";
        pComp->m_fDontExpand = TRUE;
    }
    pComp->m_hrError=hr;
   
    //
    // Add the computer to the map if it was not there
    //
    if (FALSE == fComputerExist)
    {
        m_mapComputers.SetAt(strComputerName, pComp);
    }
 
    return(pComp);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::~CComputerExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComputerExtData::~CComputerExtData()
{

    RemoveAllChildrens();
}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::RemoveAllChildrens


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerExtData::RemoveAllChildrens(void)
{

    POSITION pos;
    CString str;
    CSnapinComputer * pComp;

    //
    // Delete all the nodes from the map
    //
    pos = m_mapComputers.GetStartPosition();
    while(pos != NULL)
    {

        m_mapComputers.GetNextAssoc(pos, str, pComp);
        delete pComp;
    }

    //
    // Empty the map
    //
    m_mapComputers.RemoveAll();

}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerExtData::RemoveChild(CString& strName)
{
    BOOL rc;
    CSnapinComputer * pComp;

    rc = m_mapComputers.Lookup(strName, pComp);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapComputers.RemoveKey(strName);
    ASSERT(rc == TRUE);

    delete pComp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\deppage.cpp ===
// deppage.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqPPage.h"
#include "deppage.h"
#include "admmsg.h"

#include "deppage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine property page

IMPLEMENT_DYNCREATE(CDependentMachine, CMqPropertyPage)

CDependentMachine::CDependentMachine() : CMqPropertyPage(CDependentMachine::IDD)
{
	//{{AFX_DATA_INIT(CDependentMachine)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CDependentMachine::~CDependentMachine()
{
}

void CDependentMachine::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDependentMachine)
	DDX_Control(pDX, IDC_DEPENDENT_CLIENTS, m_clistDependentClients);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDependentMachine, CMqPropertyPage)
	//{{AFX_MSG_MAP(CDependentMachine)
	ON_BN_CLICKED(IDC_DEPENDENT_CLIENTS_REFRESH, OnDependentClientsRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine message handlers

void CDependentMachine::OnDependentClientsRefresh() 
{
    m_clistDependentClients.DeleteAllItems();
    
    //
    // Update the dependent clients list control
    //
    UpdateDependentClientList();
}

HRESULT  CDependentMachine::UpdateDependentClientList()
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wc;

    CList<LPWSTR, LPWSTR&> DependentMachineList;
    HRESULT hr;

    hr = RequestDependentClient(m_gMachineId, DependentMachineList);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD iItem = 0;

    POSITION pos = DependentMachineList.GetHeadPosition();
    while (pos != NULL)
    {
        AP<WCHAR> ClientName= DependentMachineList.GetNext(pos);

        m_clistDependentClients.InsertItem(iItem, ClientName);
        ++iItem;
    }

    return(MQ_OK);
}

BOOL CDependentMachine::OnInitDialog() 
{
    UpdateData( FALSE );

    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());

        RECT rectList;
        CString csHeading;
        m_clistDependentClients.GetClientRect(&rectList);

        csHeading.LoadString(IDS_CLIENTS_HEADING);
        m_clistDependentClients.InsertColumn(0, LPCTSTR(csHeading), LVCFMT_LEFT, rectList.right - rectList.left,0 );
    }

    //
    // Update the dependent clients list control
    //
    HRESULT hr = UpdateDependentClientList();
    if FAILED(hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        MessageDSError(hr, IDS_OP_RETRIEVE_DEP_CLIENTS);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void
CDependentMachine::SetMachineId(
    const GUID* pMachineId
    )
{
    m_gMachineId = *pMachineId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\compsite.h ===
#if !defined(AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_)
#define AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites dialog

class CComputerMsmqSites : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqSites)

// Construction
public:
	BOOL m_fForeign;
	CComputerMsmqSites(BOOL fIsServer = FALSE);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CComputerMsmqSites)
	enum { IDD = IDD_COMPUTER_MSMQ_SITES };
	CStatic	m_staticCurrentSitesLabel;
	CButton	m_buttonRemove;
	CButton	m_buttonAdd;
	CListBox	m_clistCurrentSites;
	CListBox	m_clistAllSites;
	//}}AFX_DATA
	CString	m_strMsmqName;
	CString	m_strDomainController;
    CArray<GUID, const GUID&> m_aguidSites;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqSites)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void ExchangeSites(CDataExchange* pDX);
	void EnableButtons();
	void MoveClistItem(CListBox &clistDest, CListBox &clistSrc, int iIndex = -1);
    HRESULT InitiateSitesList();
    CArray<GUID, const GUID&> m_aguidAllSites;
    BOOL m_fIsServer;
    BOOL MarkSitesChanged(CListBox* plb, BOOL fAdded);


	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqSites)
	virtual BOOL OnInitDialog();
	afx_msg void OnSitesAdd();
	afx_msg void OnSitesRemove();
	//}}AFX_MSG
    virtual void OnChangeRWField(BOOL bChanged);
	DECLARE_MESSAGE_MAP()
private:
	DWORD m_nSites;
    AP<int> m_piSitesChanges;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\dataobj.h ===
// dataobj.h : IDataObject Interface to communicate data
//
// This is a part of the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// MMC SDK Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// MMC Library product.
//

#ifndef __DATAOBJ_H_
#define __DATAOBJ_H_

#include <mmc.h>
#include <shlobj.h>
#include "globals.h"	// Added by ClassView

//
// Defines, Types etc...
//

class CDisplaySpecifierNotifier;


/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this. Refer
//               to OLE documentation for a description of clipboard formats and
//               the IdataObject interface.

class CDataObject:
    public IShellExtInit,
    public IShellPropSheetExt,
    public IContextMenu,
   	public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

    CDataObject();
   ~CDataObject();
 
    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) PURE;
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

protected:
	BOOL m_fFromFindWindow;
	virtual HRESULT GetProperties();
	virtual HRESULT GetPropertiesSilent();

	CPropMap m_propMap;
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath) PURE;
    virtual HRESULT HandleMultipleObjects(LPDSOBJECTNAMES pDSObj)
    //
    // Do nothing by default
    //
    {return S_OK;};


   	virtual const DWORD  GetObjectType() PURE;
    virtual const PROPID *GetPropidArray() PURE;
    virtual const DWORD  GetPropertiesCount() PURE;
    
    HRESULT InitAdditionalPages(
        LPCITEMIDLIST pidlFolder, 
        LPDATAOBJECT lpdobj, 
        HKEY hkeyProgID
        );

    CString m_strLdapName;
    CString m_strDomainController;
    CString m_strMsmqPath;
    CDisplaySpecifierNotifier *m_pDsNotifier;

    CComPtr<IShellExtInit> m_spObjectPageInit;
    CComPtr<IShellPropSheetExt> m_spObjectPage;
    CComPtr<IShellExtInit> m_spMemberOfPageInit;
    CComPtr<IShellPropSheetExt> m_spMemberOfPage;

};

//
// IContextMenu
//
inline STDMETHODIMP CDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags)
{
    return S_OK;
}

inline STDMETHODIMP CDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    return S_OK;
}

inline STDMETHODIMP CDataObject::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return S_OK;
}

struct FindColumns
{
    INT fmt;
    INT cx;
    INT uID;
    LPCTSTR pDisplayProperty;
};

class CMsmqDataObject : 
    public CDataObject,
    public IQueryForm
{
public:
    BEGIN_COM_MAP(CMsmqDataObject)
	    COM_INTERFACE_ENTRY(IQueryForm)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

    CMsmqDataObject();
    ~CMsmqDataObject();

    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IQueryForm
    STDMETHOD(Initialize)(THIS_ HKEY hkForm);
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam) PURE;

protected:
    static  FindColumns Columns[];
    static  HRESULT CALLBACK QueryPageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void ClearQueryWindowFields(HWND hwnd) PURE;
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams) PURE;
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable) PURE;
};


class CComputerMsmqDataObject : 
    public CMsmqDataObject,
   	public CComCoClass<CComputerMsmqDataObject,&CLSID_MsmqCompExt>
{
public:

    DECLARE_NOT_AGGREGATABLE(CComputerMsmqDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_MsmqCompExt)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    // IQueryForm
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

    //
    // Constructor
    //
    CComputerMsmqDataObject()
    {
        m_guid = GUID_NULL;
    };

protected:
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateRoutingPage();
    HPROPSHEETPAGE CreateDependentClientPage();
    HPROPSHEETPAGE CreateSitesPage();
    HPROPSHEETPAGE CreateDiagPage();
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable);
	virtual void ClearQueryWindowFields(HWND hwnd);
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);

   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();
    GUID *GetGuid();

    enum _MENU_ENTRY
    {
        mneMqPing = 0
    };

private:
    static const PROPID mx_paPropid[];
    GUID m_guid;
};


inline const DWORD CComputerMsmqDataObject::GetObjectType()
{
    return MQDS_MACHINE;
};

inline const PROPID *CComputerMsmqDataObject::GetPropidArray()
{
    return mx_paPropid;
}


//
// IShellPropSheetExt
//
//+----------------------------------------------------------------------------
//
//  Member: CDataObject::IShellExtInit::ReplacePage
//
//  Notes:  Not used.
//
//-----------------------------------------------------------------------------
inline STDMETHODIMP
CDataObject::ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                             LPARAM lParam)
{
    return E_NOTIMPL;
}


//
// BugBug: The following section is part of propcfg.h
// Included here till propcfg.h becomes part of NT public
//
#define CFSTR_DS_PROPSHEETCONFIG L"DsPropSheetCfgClipFormat"
//
// Issue: The struct below is wrong - it doesn't match the one defined in nt\public\internal\ds\dspropp.h
//  Need to fix post-beta1 (just not to break 32 bit).
//  Need to define WM_DSA_SHEET_CLOSE_NOTIFY as (WM_USER + 5)
//  and use it instead of MsgSheetClose, and change long to LONG_PTR
// RaananH Sep/3/2000
//
typedef struct _PROPSHEETCFG {
    long lNotifyHandle;
    HWND hwndParentSheet;   // invoking parent if launched from another sheet.
    HWND hwndHidden;        // snapin hidden window handle
    UINT MsgSheetClose;     // message to be posted when sheet is closed
    WPARAM wParamSheetClose; // wParam to be used with above message
} PROPSHEETCFG, * PPROPSHEETCFG;
//
// Bugbug - end of section from propcfg.h
//

//
// CDisplaySpecifierNotifier
//
class CDisplaySpecifierNotifier
{
public:
    long AddRef(BOOL fIsPage = TRUE);
    long Release(BOOL fIsPage = TRUE);
    CDisplaySpecifierNotifier(LPDATAOBJECT lpdobj);

private:
    long m_lRefCount;
    long m_lPageRef;
    PROPSHEETCFG m_sheetCfg;
    ~CDisplaySpecifierNotifier()
    {
    };
};
#endif // __DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\dssec.h ===
#ifndef _DSSEC_H_
#define _DSSEC_H_

#include <aclui.h>  // LPSECURITYINFO


//+---------------------------------------------------------------------------
//
//  Function:   PFNREADOBJECTSECURITY
//
//  Synopsis:   Reads the security descriptor of a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to read
//              [OUT PSECURITY_DESCRIPTOR*] --  Return SD here. Caller frees with LocalFree
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
//
//  Function:   PFNWRITEOBJECTSECURITY
//
//  Synopsis:   Writes a security descriptor to a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to write
//              [OUT PSECURITY_DESCRIPTOR]  --  Security descriptor to write
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFNREADOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR*, LPARAM);
typedef HRESULT (WINAPI *PFNWRITEOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, LPARAM);

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObject
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD dwFlags,
                            LPSECURITYINFO *ppSI,
                            PFNREADOBJECTSECURITY pfnReadSD,
                            PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext);

#define DSSI_READ_ONLY          0x00000001
#define DSSI_NO_ACCESS_CHECK    0x00000002
#define DSSI_NO_EDIT_SACL       0x00000004
#define DSSI_NO_EDIT_OWNER      0x00000008
#define DSSI_IS_ROOT            0x00000010

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext);

//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption]       --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               PFNREADOBJECTSECURITY pfnReadSD,
               PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext);


typedef HRESULT (WINAPI *PFNDSCREATEISECINFO)(LPCWSTR,
                                              LPCWSTR,
                                              DWORD,
                                              LPSECURITYINFO*,
                                              PFNREADOBJECTSECURITY,
                                              PFNWRITEOBJECTSECURITY,
                                              LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATESECPAGE)(LPCWSTR,
                                             LPCWSTR,
                                             DWORD,
                                             HPROPSHEETPAGE*,
                                             PFNREADOBJECTSECURITY,
                                             PFNWRITEOBJECTSECURITY,
                                             LPARAM);

typedef HRESULT (WINAPI *PFNDSEDITSECURITY)(HWND,
                                            LPCWSTR,
                                            LPCWSTR,
                                            DWORD,
                                            LPCWSTR,
                                            PFNREADOBJECTSECURITY,
                                            PFNWRITEOBJECTSECURITY,
                                            LPARAM);

#endif  /* _DSSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\deppage.h ===
#if !defined(AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// deppage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine dialog

class CDependentMachine : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CDependentMachine)

// Construction
public:
	CDependentMachine();
	~CDependentMachine();
    
    void
    SetMachineId(
        const GUID* pMachineId
        );

// Dialog Data
	//{{AFX_DATA(CDependentMachine)
	enum { IDD = IDD_COMPUTER_MSMQ_DEPENDENT_CLIENTS };
	CListCtrl	m_clistDependentClients;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDependentMachine)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDependentMachine)
	afx_msg void OnDependentClientsRefresh();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HRESULT  UpdateDependentClientList();

	GUID m_gMachineId;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\dataobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dataobj.cpp

Abstract:

    CDataObject implementation. Originally based on step4 sample from
    mmc SDK.
    In our model, this represents the data related to a specific Queue / MSMQ objetct / Etc.

Author:

    Yoel Arnon (yoela)

--*/

#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "strconv.h"
#include "CompGen.h"
#include "frslist.h"
#include "CmpMRout.h"
#include "compsite.h"
#include "CompDiag.h"
#include "deppage.h"
#include "Qname.h"
#include "admmsg.h"
#include "generrpg.h"

#include "dataobj.tmh"
               
/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this. Refer
//               to OLE documentation for a description of clipboard formats and
//               the IdataObject interface.

//============================================================================
//
// Constructor and Destructor
// 
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CDataObject::CDataObject() :
    m_strMsmqPath(TEXT("")),
    m_strDomainController(TEXT("")),
    m_pDsNotifier(0),
    m_fFromFindWindow(FALSE),
    m_spObjectPageInit(0),
    m_spObjectPage(0),
    m_spMemberOfPageInit(0),
    m_spMemberOfPage(0)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::~CDataObject
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    if (0 != m_pDsNotifier)
    {
        m_pDsNotifier->Release(FALSE);
    }
}

HRESULT CDataObject::InitAdditionalPages(
                        LPCITEMIDLIST pidlFolder, 
                        LPDATAOBJECT lpdobj, 
                        HKEY hkeyProgID)
{
    HRESULT hr;
    if (m_spObjectPageInit != 0 && m_spMemberOfPageInit != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
        return S_OK;
    }

    if (m_spObjectPageInit != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
    }
    else
    {
        //
        // Get the "object" property page handler
        // Note: if we fail, we simply ignore that page.
        //
        hr = CoCreateInstance(x_ObjectPropertyPageClass, 0, CLSCTX_ALL, IID_IShellExtInit, (void**)&m_spObjectPageInit);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spObjectPageInit = 0;
            return S_OK;
        }

        ASSERT(m_spObjectPageInit != 0);
        hr = m_spObjectPageInit->Initialize(pidlFolder, lpdobj, hkeyProgID);
        if FAILED(hr)
        {
            ASSERT(0);
            return S_OK;
        }
        hr = m_spObjectPageInit->QueryInterface(IID_IShellPropSheetExt, (void**)&m_spObjectPage);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spObjectPage = 0;
        }
    }

    if (m_spMemberOfPageInit  != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
    }
    else
    {
        //
        // Get the "memeber of" property page handler
        // Note: if we fail, we simply ignore that page.
        //
        hr = CoCreateInstance(x_MemberOfPropertyPageClass, 0, CLSCTX_ALL, IID_IShellExtInit, (void**)&m_spMemberOfPageInit);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spMemberOfPageInit = 0;
            return S_OK;
        }

        ASSERT(m_spMemberOfPageInit != 0);
        hr = m_spMemberOfPageInit->Initialize(pidlFolder, lpdobj, hkeyProgID);
        if FAILED(hr)
        {
            ASSERT(0);
            return S_OK;
        }
        hr = m_spMemberOfPageInit->QueryInterface(IID_IShellPropSheetExt, (void**)&m_spMemberOfPage);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spMemberOfPage = 0;
        }
    }

    return S_OK;
}
    
//
// IShellExtInit
//
STDMETHODIMP CDataObject::Initialize (
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if (0 == lpdobj || IsBadReadPtr(lpdobj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    //
    // Gets the LDAP path
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

	LPWSTR lpwstrLdapName;
	LPDSOBJECTNAMES pDSObj;
	
	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	hr = lpdobj->GetData(&formatetc, &stgmedium);

    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        pDSObj = (LPDSOBJECTNAMES)(HGLOBAL)gpDSObj;

        //
        // Identify wheather we were called from the "Find" window
        //
        if (pDSObj->clsidNamespace == CLSID_FindWindow)
        {
            m_fFromFindWindow = TRUE;
        }

		lpwstrLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);

		m_strLdapName = lpwstrLdapName;      

		//
		// Get Domain Controller name
		//
		hr = ExtractDCFromLdapPath(m_strDomainController, lpwstrLdapName);
		ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

        hr = ExtractMsmqPathFromLdapPath(lpwstrLdapName);

        if (SUCCEEDED(hr))
        {
            hr = HandleMultipleObjects(pDSObj);
        }
    }

    //
    // Initiate Display Specifiers modifier
    //
    ASSERT(0 == m_pDsNotifier);
    m_pDsNotifier = new CDisplaySpecifierNotifier(lpdobj);

    //
    // if we fail we'll ignore these pages
    //
    HRESULT hr1 = InitAdditionalPages(pidlFolder, lpdobj, hkeyProgID);
    
    return hr;
}


HRESULT CComputerMsmqDataObject::ExtractMsmqPathFromLdapPath(LPWSTR lpwstrLdapPath)
{
    return ExtractComputerMsmqPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}


CMsmqDataObject::CMsmqDataObject()
{
}

CMsmqDataObject::~CMsmqDataObject()
{
}

//
// IShellExtInit
//
STDMETHODIMP CMsmqDataObject::Initialize (
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID)
{
    HRESULT hr = CDataObject::Initialize(
                    pidlFolder,
                    lpdobj,
                    hkeyProgID);
    if FAILED(hr)
    {
        return hr;
    }    

    return hr;
}

    
//
// IShellPropSheetExt
//
STDMETHODIMP CComputerMsmqDataObject::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    //
    // Call GetProperties and capture the errors
    //
    {
        CErrorCapture errstr;
        hr = GetProperties();
        if (FAILED(hr))
        {
            hPage = CGeneralErrorPage::CreateGeneralErrorPage(m_pDsNotifier, errstr);
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        return S_OK;
        }
    }

    //
    // Check if the machine is an MSMQ server - [adsrv] separately per functionality
    //
    PROPVARIANT propVar;
    PROPID pid;
    
    pid = PROPID_QM_SERVICE_DSSERVER;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDs = propVar.bVal;

    pid = PROPID_QM_SERVICE_ROUTING;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fRout= propVar.bVal;

    pid = PROPID_QM_SERVICE_DEPCLIENTS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDepCl= propVar.bVal;

    //
    // Get foreign flag
    //
    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fForeign = (propVar.bVal);

    
    hPage = CreateGeneralPage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    //
    // Routing page should appear only on clients
    //
    if ((!fRout) && (!fForeign))   // [adsrv] fIsServer
    {
        hPage = CreateRoutingPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Dependent client page appear only on servers
    //
    if (fDepCl)       // [adsrv] fIsServer
    {
        hPage = CreateDependentClientPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Sites page is created iff PROPID_QM_SITE_IDS exists in the map.
    // Otherwise, we are in NT4 - multiple sites are not supported, 
    // and we will not display the sites.
    //

    pid = PROPID_QM_SITE_IDS;
    if (m_propMap.Lookup(pid, propVar))
    {

        hPage = CreateSitesPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    if (!fForeign)
    {
        hPage = CreateDiagPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }

    //
    // Security page
    //
    hr = CreateMachineSecurityPage(
			&hPage, 
			m_strMsmqPath, 
			GetDomainController(m_strDomainController), 
			true	// fServerName
			);
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}


HPROPSHEETPAGE CComputerMsmqDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
    CMqDsPropertyPage<CComputerMsmqGeneral> *pcpageGeneral = 
        new CMqDsPropertyPage<CComputerMsmqGeneral> (m_pDsNotifier);

    pcpageGeneral->m_strMsmqName = m_strMsmqPath;
    pcpageGeneral->m_strDomainController = m_strDomainController;

    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_QM_MACHINE_ID
    //
    pid = PROPID_QM_MACHINE_ID;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_guidID = *propVar.puuid;    

    //
    // PROPID_QM_QUOTA
    //
    pid = PROPID_QM_QUOTA;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_dwQuota = propVar.ulVal;

    //
    // PROPID_QM_JOURNAL_QUOTA
    //
    pid = PROPID_QM_JOURNAL_QUOTA;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_dwJournalQuota = propVar.ulVal;

    //
    // PROPID_QM_SERVICE, PROPID_QM_FOREIGN
    //
    pid = PROPID_QM_SERVICE;            
    VERIFY(m_propMap.Lookup(pid, propVar));
    ULONG ulService = propVar.ulVal;

    pid = PROPID_QM_SERVICE_DSSERVER;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDs = propVar.bVal;

    pid = PROPID_QM_SERVICE_ROUTING;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fRout= propVar.bVal;

    pid = PROPID_QM_SERVICE_DEPCLIENTS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDepCl= propVar.bVal;

    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fForeign = propVar.bVal;

    pcpageGeneral->m_strService = MsmqServiceToString(fRout, fDepCl, fForeign);

    return CreatePropertySheetPage(&pcpageGeneral->m_psp);  
}

HPROPSHEETPAGE CComputerMsmqDataObject::CreateRoutingPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid;

    //
    // Note: CComputerMsmqGeneral is auto-delete by default
    //
    CComputerMsmqRouting *pcpageRouting = new CComputerMsmqRouting();
    pcpageRouting->m_strMsmqName = m_strMsmqPath;
    pcpageRouting->m_strDomainController = m_strDomainController;

    //
    // PROPID_QM_SITE_ID
    //
    pid = PROPID_QM_SITE_ID;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->m_guidSiteID = *propVar.puuid;

    //
    // PROPID_QM_OUTFRS
    //
    pid = PROPID_QM_OUTFRS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->InitiateOutFrsValues(&propVar.cauuid);

    //
    // PROPID_QM_INFRS
    //
    pid = PROPID_QM_INFRS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->InitiateInFrsValues(&propVar.cauuid);

    return CreatePropertySheetPage(&pcpageRouting->m_psp);  
}

HPROPSHEETPAGE 
CComputerMsmqDataObject::CreateDependentClientPage(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CDependentMachine* pDependentPage = new CDependentMachine;

    //
    // PROPID_QM_MACHINE_ID
    //
    PROPVARIANT propVar;
    PROPID pid = PROPID_QM_MACHINE_ID;

    VERIFY(m_propMap.Lookup(pid, propVar));
    pDependentPage->SetMachineId(propVar.puuid);

    return CreatePropertySheetPage(&pDependentPage->m_psp);  
}

HPROPSHEETPAGE CComputerMsmqDataObject::CreateDiagPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Note: CComputerMsmqDiag is auto-delete by default
    //
    CComputerMsmqDiag *pcpageDiag = new CComputerMsmqDiag();

    pcpageDiag->m_strMsmqName = m_strMsmqPath;
    pcpageDiag->m_strDomainController = m_strDomainController;


    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_QM_MACHINE_ID
    //
    pid = PROPID_QM_MACHINE_ID;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageDiag->m_guidQM = *propVar.puuid;

    return CreatePropertySheetPage(&pcpageDiag->m_psp);  
}

HPROPSHEETPAGE CComputerMsmqDataObject::CreateSitesPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid;

    //
    // Retrieve the service in order to pass TRUE for server and FALSE 
    // for client to CComputerMsmqSites.
    //
    pid = PROPID_QM_SERVICE;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Note: CComputerMsmqSites is auto-delete by default
    //
    CComputerMsmqSites *pcpageSites = new CComputerMsmqSites(propVar.ulVal != SERVICE_NONE);
    pcpageSites->m_strMsmqName = m_strMsmqPath;
    pcpageSites->m_strDomainController = m_strDomainController;

    //
    // PROPID_QM_SITE_IDS
    //
    pid = PROPID_QM_SITE_IDS;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Sets m_aguidSites from CACLSID
    //
    CACLSID const *pcaclsid = &propVar.cauuid;
    for (DWORD i=0; i<pcaclsid->cElems; i++)
    {
        pcpageSites->m_aguidSites.SetAtGrow(i,((GUID *)pcaclsid->pElems)[i]);
    }

    //
    // PROPID_QM_FOREIGN
    //
    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageSites->m_fForeign = propVar.bVal;

    return CreatePropertySheetPage(&pcpageSites->m_psp);  
}

HRESULT CDataObject::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(GetObjectType(), 
                                               m_strDomainController,
                                               m_strMsmqPath,
                                               GetPropertiesCount(),
                                               GetPropidArray());
    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_strMsmqPath);
        }
    }

    return hr;
}


HRESULT CDataObject::GetPropertiesSilent()
{
    HRESULT hr = m_propMap.GetObjectProperties(GetObjectType(), 
                                               m_strDomainController,
                                               m_strMsmqPath,
                                               GetPropertiesCount(),
                                               GetPropidArray());
    return hr;
}


const PROPID CComputerMsmqDataObject::mx_paPropid[] = 
    {PROPID_QM_MACHINE_ID, 
     PROPID_QM_QUOTA, PROPID_QM_JOURNAL_QUOTA, PROPID_QM_SERVICE, 
     PROPID_QM_SERVICE_DSSERVER,  PROPID_QM_SERVICE_ROUTING, 
     PROPID_QM_SERVICE_DEPCLIENTS, PROPID_QM_FOREIGN, PROPID_QM_OUTFRS, 
     PROPID_QM_INFRS, PROPID_QM_SITE_ID, PROPID_QM_SITE_IDS};


const DWORD  CComputerMsmqDataObject::GetPropertiesCount()
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}
    
//
// IContextMenu
//
STDMETHODIMP CComputerMsmqDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strMqPingMenuEntry;
    strMqPingMenuEntry.LoadString(IDS_MQPING);

    InsertMenu(hmenu,
         indexMenu, 
         MF_BYPOSITION|MF_STRING,
         idCmdFirst + mneMqPing,
         strMqPingMenuEntry);

    return 1;
}

STDMETHODIMP CComputerMsmqDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case mneMqPing:
        {
            GUID *pguid = GetGuid();
            if (pguid)
            {
                MQPing(*pguid);
            }
        }
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------
/ IQueryForm methods
/----------------------------------------------------------------------------*/

STDMETHODIMP CMsmqDataObject::Initialize(THIS_ HKEY hkForm)
{
    // This method is called to initialize the query form object, it is called before
    // any pages are added.  hkForm should be ignored, in the future however it
    // will be a way to persist form state.

    return S_OK;
}

/*---------------------------------------------------------------------------*/
STDMETHODIMP CMsmqDataObject::AddForms(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
    // This method is called to allow the form handler to register its query form(s),
    // each form is identifiered by a CLSID and registered via the pAddFormProc.  Here
    // we are going to register a test form.
    
    // When registering a form which is only applicable to a specific task, eg. Find a Domain
    // object, it is advised that the form be marked as hidden (CQFF_ISNEVERLISTED) which 
    // will cause it not to appear in the form picker control.  Then when the
    // client wants to use this form, they specify the form identifier and ask for the
    // picker control to be hidden. 

    //
    // By default - do nothing
    //
    return S_OK;

}


/*---------------------------------------------------------------------------*/

// The PageProc is used to perform general house keeping and communicate between
// the frame and the page. 
//
// All un-handled, or unknown reasons should result in an E_NOIMPL response
// from the proc.  
//
// In:
//  pPage -> CQPAGE structure (copied from the original passed to pAddPagesProc)
//  hwnd = handle of the dialog for the page
//  uMsg, wParam, lParam = message parameters for this event
//
// Out:
//  HRESULT
//
// uMsg reasons:
// ------------
//  CQPM_INIIIALIZE
//  CQPM_RELEASE
//      These are issued as a result of the page being declared or freed, they 
//      allow the caller to AddRef, Release or perform basic initialization
//      of the form object.
//
// CQPM_ENABLE
//      Enable is when the query form needs to enable or disable the controls
//      on its page.  wParam contains TRUE/FALSE indicating the state that
//      is required.
//
// CQPM_GETPARAMETERS
//      To collect the parameters for the query each page on the active form 
//      receives this event.  lParam is an LPVOID* which is set to point to the
//      parameter block to pass to the handler, if the pointer is non-NULL 
//      on entry the form needs to appened its query information to it.  The
//      parameter block is handler specific. 
//
//      Returning S_FALSE from this event causes the query to be canceled.
//
// CQPM_CLEARFORM
//      When the page window is created for the first time, or the user clicks
//      the clear search the page receives a CQPM_CLEARFORM notification, at 
//      which point it needs to clear out the edit controls it has and
//      return to a default state.
//
// CQPM_PERSIST:
//      When loading of saving a query, each page is called with an IPersistQuery
//      interface which allows them to read or write the configuration information
//      to save or restore their state.  lParam is a pointer to the IPersistQuery object,
//      and wParam is TRUE/FALSE indicating read or write accordingly.

HRESULT CALLBACK CMsmqDataObject::QueryPageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CMsmqDataObject* pMsmqDataObject = (CMsmqDataObject*)pQueryPage->lParam;

    switch ( uMsg )
    {
        // Initialize so AddRef the object we are associated with so that
        // we don't get unloaded.

        case CQPM_INITIALIZE:
            pMsmqDataObject->CComObjectRoot::InternalAddRef();
            break;

        // Release, therefore Release the object we are associated with to
        // ensure correct destruction etc.

        case CQPM_RELEASE:
            pMsmqDataObject->CComObjectRoot::InternalRelease();
            break;

        // Enable so fix the state of our two controls within the window.

        case CQPM_ENABLE:
            pMsmqDataObject->EnableQueryWindowFields(hwnd, DWORD_PTR_TO_DWORD(wParam));
            break;

        // Fill out the parameter structure to return to the caller, this is 
        // handler specific.  In our case we constructure a query of the CN
        // and objectClass properties, and we show a columns displaying both
        // of these.  For further information about the DSQUERYPARAMs structure
        // see dsquery.h

        case CQPM_GETPARAMETERS:
            hr = pMsmqDataObject->GetQueryParams(hwnd, (LPDSQUERYPARAMS*)lParam);
            break;

        // Clear form, therefore set the window text for these two controls
        // to zero.

        case CQPM_CLEARFORM:
            pMsmqDataObject->ClearQueryWindowFields(hwnd);
            break;
            
        // persistance is not currently supported by this form.            
                  
        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            ASSERT(0 != pPersistQuery);

            hr = E_NOTIMPL;             // NYI
            break;
        }

        default:
        {
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------*/

// The DlgProc is a standard Win32 dialog proc associated with the form
// window.  

INT_PTR CALLBACK CMsmqDataObject::FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = FALSE;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        //
        // pQueryPage will be of use later, so hang onto it by storing it
        // in the DWL_USER field of the dialog box instance.
        //

        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);
    }
    else
    {
        //
        // pQueryPage can be retreived from the DWL_USER field of the
        // dialog structure, note however that in some cases this will
        // be NULL as it is set on WM_INITDIALOG.
        //

        pQueryPage = (LPCQPAGE)GetWindowLongPtr(hwnd, DWLP_USER);
    }

    return fResult;
}



HRESULT CComputerMsmqDataObject::EnableQueryWindowFields(HWND hwnd, BOOL fEnable)
{
    return E_NOTIMPL;
}

void CComputerMsmqDataObject::ClearQueryWindowFields(HWND hwnd)
{
}

HRESULT CComputerMsmqDataObject::GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams)
{
    return E_NOTIMPL ;
}

STDMETHODIMP CComputerMsmqDataObject::AddPages(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
    return E_NOTIMPL;
}

//
// CComputerMsmqDataObject::GetGuid
//
GUID *CComputerMsmqDataObject::GetGuid()
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_guid == GUID_NULL)
    {
        //
        // Get the GUID from the DS
        //
        PROPID pid = PROPID_QM_MACHINE_ID;
        PROPVARIANT pvar;
        pvar.vt = VT_NULL;        
        HRESULT hr = ADGetObjectProperties(
                            eMACHINE,
                            GetDomainController(m_strDomainController),
							true,	// fServerName
                            m_strMsmqPath, 
                            1, 
                            &pid, 
                            &pvar
                            );

        if FAILED(hr)
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_strMsmqPath);
            return 0;
        }
        m_guid = *pvar.puuid;
        MQFreeMemory(pvar.puuid);
    }
    return &m_guid;
}

//
// CDisplaySpecifierNotifier
//
long CDisplaySpecifierNotifier::AddRef(BOOL fIsPage /*= TRUE*/)
{
    InterlockedIncrement(&m_lRefCount);
    if (fIsPage)
    {
        InterlockedIncrement(&m_lPageRef);
    }
    return m_lRefCount;
}

long CDisplaySpecifierNotifier::Release(BOOL fIsPage /*= TRUE */)
{
    ASSERT(m_lRefCount > 0);
    InterlockedDecrement(&m_lRefCount);
    if (fIsPage)
    {
        ASSERT(m_lPageRef > 0);
        InterlockedDecrement(&m_lPageRef);
        if (0 == m_lPageRef)
        {
            if (m_sheetCfg.hwndHidden && ::IsWindow(m_sheetCfg.hwndHidden))
            {
               ::PostMessage(m_sheetCfg.hwndHidden, 
                             m_sheetCfg.MsgSheetClose, 
                             (WPARAM)m_sheetCfg.wParamSheetClose, 
                             (LPARAM)0);
            }
        }
    }
    if (0 == m_lRefCount)
    {
        delete this;
    }
    return m_lRefCount;
};

CDisplaySpecifierNotifier::CDisplaySpecifierNotifier(LPDATAOBJECT lpdobj) :
    m_lRefCount(1),
    m_lPageRef(0)
{
    //
    // Get the prop sheet configuration
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG));
	HRESULT hr = lpdobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        m_sheetCfg = *(PPROPSHEETCFG)(HGLOBAL)gpDSObj;
    }
    else
    {
        //
        // We are probably called from "Find" menu
        //
        memset(&m_sheetCfg, 0, sizeof(m_sheetCfg));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\edataobj.cpp ===
// edataobj.cpp : Implementation of CEnterpriseDataObject
#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "edataobj.h"
#include "EnterGen.h"
#include "MsmqLink.h"
#include "ForgSite.h"
#include "ForgComp.h"

#include "edataobj.tmh"

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseDataObject

const PROPID CEnterpriseDataObject::mx_paPropid[] = { PROPID_E_LONG_LIVE };

HRESULT 
CEnterpriseDataObject::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    //
    // NOTE:  the enterprise name is extracted from DS and from LDAP.
    //
    HRESULT rc;

    PROPID      prop;
    PROPVARIANT var;
    prop = PROPID_E_NAME;    
    var.vt = VT_NULL;    

    rc = ADGetObjectProperties(
                eENTERPRISE,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                L"msmq",
                1,
                &prop,
                &var
                );
  
    if (SUCCEEDED(rc))
    {
        m_strMsmqPath = var.pwszVal;
        MQFreeMemory(var.pwszVal);
    }
    
    return rc;
}

//
// IShellPropSheetExt
//


STDMETHODIMP 
CEnterpriseDataObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (SUCCEEDED(GetProperties()))
    {
        HPROPSHEETPAGE hPage = CreateGeneralPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }
    else
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}


HPROPSHEETPAGE 
CEnterpriseDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CEnterpriseGeneral>  *pcpageGeneral = 
        new CMqDsPropertyPage<CEnterpriseGeneral>(m_pDsNotifier, m_strMsmqPath, m_strDomainController);

    PROPVARIANT propVar;
    PROPID pid;

	//
	// PROPID_E_CREATE_TIME
	//
    pid = PROPID_E_LONG_LIVE;
    VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageGeneral->LongLiveIntialize(propVar.ulVal);

    return CreatePropertySheetPage(&pcpageGeneral->m_psp);  
}


const 
DWORD  
CEnterpriseDataObject::GetPropertiesCount(
    void
    )
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}


//
// IContextMenu
//
STDMETHODIMP 
CEnterpriseDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    UINT uiMenu = 0;

    CString strNewMenuEntry;
    strNewMenuEntry.LoadString(IDS_NEW_FOREIGN_SITE);
    
    InsertMenu(
        hmenu,
        indexMenu, 
        MF_BYPOSITION|MF_STRING,
        idCmdFirst + eNewForeignSite,
        strNewMenuEntry
        );
    uiMenu++;   
    
    strNewMenuEntry.LoadString(IDS_NEW_FOREIGN_COMPUTER);
    InsertMenu(
        hmenu,
        indexMenu, 
        MF_BYPOSITION|MF_STRING,
        idCmdFirst + eNewForeignComputer,
        strNewMenuEntry
        );
    uiMenu++;
    
    return uiMenu;
}

STDMETHODIMP 
CEnterpriseDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case eNewForeignSite:
        {
			_bstr_t bstrMsmqPath = m_strMsmqPath;
			CString strPathDisplayFormat;
			GetContainerPathAsDisplayString(bstrMsmqPath, &strPathDisplayFormat);

		    CForeignSite* pForeignSite = new CForeignSite(strPathDisplayFormat);       
			CGeneralPropertySheet propertySheet(pForeignSite);
			pForeignSite->SetParentPropertySheet(&propertySheet);

            propertySheet.DoModal();
            break;
        }

        case eNewForeignComputer:
        {
 		    CForeignComputer* pForeignComputer = new CForeignComputer(m_strDomainController);       
			CGeneralPropertySheet propertySheet(pForeignComputer);
			pForeignComputer->SetParentPropertySheet(&propertySheet);
           
            propertySheet.DoModal();
            break;
        }

        default:
            ASSERT(0);

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\dsext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   DSExt.h

Abstract:

   Extensions to DS functionality (wrapper classes, etc.)

Author:

    Yoel Arnon (yoela)

--*/
//
// DsLookup class
//
class DSLookup
{
public:
    DSLookup ( IN HANDLE   hEnume,
               IN HRESULT  hr
               );

    ~DSLookup ();

    HRESULT Next( IN OUT  DWORD*          pcProps,
                  OUT     PROPVARIANT     aPropVar[]);

    BOOL HasValidHandle();

    HRESULT GetStatusCode();

private:
    HANDLE  m_hEnum;
    HRESULT m_hr;
};

inline DSLookup::DSLookup ( 
    IN HANDLE   hEnume,
    IN HRESULT  hr
    ) :
    m_hEnum(hEnume),
    m_hr(hr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());  
   
    if (FAILED(m_hr))
    {
        MessageDSError(m_hr, IDS_LOOKUP_BEGIN);

        if (0 != m_hEnum)
        {
            VERIFY(SUCCEEDED(ADEndQuery(m_hEnum)));  
            m_hEnum = 0;
        }
    }
}

inline DSLookup::~DSLookup ()
{
    if (0 != m_hEnum)
    {
        VERIFY(SUCCEEDED(ADEndQuery(m_hEnum)));        
        m_hEnum = 0;
    }
}

inline HRESULT DSLookup::Next( 
    IN OUT  DWORD*          pcProps,
    OUT     PROPVARIANT     aPropVar[])
{
    ASSERT(0 != m_hEnum);    
    m_hr = ADQueryResults(
               m_hEnum, 
               pcProps, 
               aPropVar
               );
    return m_hr;
}

inline BOOL DSLookup::HasValidHandle()
{
    return (0 != m_hEnum);
}

inline HRESULT DSLookup::GetStatusCode()
{
    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\entergen.h ===
#if !defined(AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EnterGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral dialog

class CEnterpriseGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CEnterpriseGeneral)

// Construction
public:
	CEnterpriseGeneral(const CString& EnterprisePathName, const CString& strDomainController);
    CEnterpriseGeneral() {};
	~CEnterpriseGeneral();

    void LongLiveIntialize(DWORD dwInitialLongLiveValue);

// Dialog Data
	//{{AFX_DATA(CEnterpriseGeneral)
	enum { IDD = IDD_ENTERPRISE_GENERAL };
	//}}AFX_DATA

    DWORD m_dwLongLiveValue;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CEnterpriseGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CEnterpriseGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnterpriseLongLiveChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    enum LongLiveUnits
    {
        eSeconds,
        eMinutes,
        eHours,
        eDays,
        eLast
    };

    static const int m_conversionTable[eLast];
	DWORD	m_dwInitialLongLiveValue;
    CString m_strDomainController;
	CString m_strMsmqServiceContainer;
};


inline
void
CEnterpriseGeneral::LongLiveIntialize(
    DWORD dwInitialLongLiveValue
    ) 
{
    m_dwInitialLongLiveValue = dwInitialLongLiveValue;
    m_dwLongLiveValue = dwInitialLongLiveValue;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\edataobj.h ===
// edataobj.h : Declaration of the CEnterpriseDataObject

#ifndef __EDATAOBJECT_H_
#define __EDATAOBJECT_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseDataObject
class CEnterpriseDataObject : 
	public CDataObject,
	public CComCoClass<CEnterpriseDataObject, &CLSID_EnterpriseDataObject>
{
public:
    DECLARE_NOT_AGGREGATABLE(CEnterpriseDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_ENTERPRISEDATAOBJECT)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    enum _MENU_ENTRY
    {
        eNewForeignSite = 0,
        eNewForeignComputer
    };

    static const PROPID mx_paPropid[];
};

inline 
const 
DWORD 
CEnterpriseDataObject::GetObjectType(
    void
    )
{
    return MQDS_ENTERPRISE;
};

inline 
const 
PROPID*
CEnterpriseDataObject::GetPropidArray(
    void
    )
{
    return mx_paPropid;
}

#endif //__EDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgcomp.cpp ===
// ForgComp.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqsnap.h"
#include "mqppage.h"
#include "ForgComp.h"

#include "forgcomp.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer dialog

CForeignComputer::CForeignComputer(const CString& strDomainController)
	: CMqPropertyPage(CForeignComputer::IDD),
	  m_strDomainController(strDomainController)
{
	//{{AFX_DATA_INIT(CForeignComputer)
	m_strName = _T("");
	m_iSelectedSite = -1;
	//}}AFX_DATA_INIT
}


void
CForeignComputer::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CForeignComputer::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    BOOL fFirstTime = (m_ccomboSites.m_hWnd == NULL);

	//{{AFX_DATA_MAP(CForeignComputer)
	DDX_Control(pDX, IDC_FOREIGN_COMPUTER_SITE, m_ccomboSites);
	DDX_Text(pDX, IDC_FOREIGN_COMPUTER_NAME, m_strName);
	//}}AFX_DATA_MAP
	DDV_NotEmpty(pDX, m_strName, IDS_PLEASE_ENTER_A_COMPUTER_NAME);
	DDX_CBIndex(pDX, IDC_FOREIGN_COMPUTER_SITE, m_iSelectedSite);

    if (fFirstTime)
    {
        InitiateSitesList();
    }

    if (pDX->m_bSaveAndValidate) 
    {
        if (CB_ERR == m_iSelectedSite)
        {
            AfxMessageBox(IDS_PLEASE_SELECT_A_SITE);
            pDX->Fail();
        }

        DWORD_PTR dwSiteIndex = m_ccomboSites.GetItemData(m_iSelectedSite);
        ASSERT(CB_ERR != dwSiteIndex);

        m_guidSite = m_aguidAllSites[dwSiteIndex];
    }

	DDV_ValidComputerName(pDX, m_strName);
}


BEGIN_MESSAGE_MAP(CForeignComputer, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignComputer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer message handlers
BOOL CForeignComputer::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	CString strDomainName;

	int index = m_strDomainController.Find(L'.');
	if ( index != -1 )
	{
		strDomainName = m_strDomainController.Right(m_strDomainController.GetLength() - index - 1);
	}

	CString strTitle;
	strTitle.FormatMessage(IDS_COMPUTERS, strDomainName);

	SetDlgItemText(IDC_FOREIGN_COMPUTER_CONTAINER, strTitle);

	return TRUE;
}


BOOL CForeignComputer::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


HRESULT CForeignComputer::InitiateSitesList()
{
    //
    // Prepare list of sites
    //
    ASSERT(m_ccomboSites.m_hWnd != NULL);

    DWORD dwSiteIndex = 0;
    m_ccomboSites.ResetContent();
    
    //
    // Initialize the full sites list
    //
	PROPID aPropId[] = {PROPID_S_SITEID, PROPID_S_PATHNAME};
	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

	PROPVARIANT apResultProps[x_nProps];

	CColumns columns;
	for (DWORD i=0; i<x_nProps; i++)
	{
		columns.Add(aPropId[i]);
	}
    
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryForeignSites(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    columns.CastToStruct(),
                    &hEnume
                    );     
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return E_UNEXPECTED;
    }

	DWORD dwPropCount = x_nProps;
	while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
			&& (dwPropCount != 0) )
	{
        DWORD iProperty = 0;

        //
        // PROPID_S_SITEID
        //
        ASSERT(PROPID_S_SITEID == aPropId[iProperty]);
        CAutoMQFree<GUID> pguidSite = apResultProps[iProperty].puuid;
        iProperty++;

        //
        // PROPID_S_PATHNAME
        //
        ASSERT(PROPID_S_PATHNAME == aPropId[iProperty]);
        CAutoMQFree<WCHAR> lpwstrSiteName = apResultProps[iProperty].pwszVal;
        iProperty++;

        int nIndex = m_ccomboSites.AddString(lpwstrSiteName);
        if (FAILED(nIndex))
        {
            return E_UNEXPECTED;
        }

        m_aguidAllSites.SetAtGrow(dwSiteIndex, *(GUID *)pguidSite);
        m_ccomboSites.SetItemData(nIndex, dwSiteIndex);
        dwSiteIndex++;

		dwPropCount = x_nProps;
	}

	//
	// If only one foreign site exists, initialize the combo box with it
	//
	if ( dwSiteIndex == 1 )
	{
		m_ccomboSites.SetCurSel(0);
	}

    return S_OK;
}

BOOL CForeignComputer::OnWizardFinish() 
{
    if (0 == UpdateData())
    {
        //
        // Data was not validated - remain in Window!
        //
        return FALSE;
    }

    //
    //  Create computer object
    //
    // The Netbios name is the first MAX_COM_SAM_ACCOUNT_LENGTH (19) characters
    // of the computer name. This value goes to the samAccountName property of the computer.
    // Two computers cannot have the same 19 characters prefix (6295 - ilanh - 03-Jan-2001)
    //
    CString strAccountName = m_strName.Left(MAX_COM_SAM_ACCOUNT_LENGTH) + L"$";
	PROPID prop = PROPID_COM_SAM_ACCOUNT;
    PROPVARIANT var;
    var.vt = VT_LPWSTR;
    var.pwszVal = (LPWSTR)(LPCWSTR)strAccountName;   

    HRESULT hr = ADCreateObject(
                    eCOMPUTER,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    m_strName,
                    NULL, //pSecurityDescriptor,
                    1,
                    &prop,
                    &var,
                    NULL    
                    );

    if (FAILED(hr) && hr != MQDS_E_COMPUTER_OBJECT_EXISTS)
    {
		if ( (hr & DS_ERROR_MASK) == ERROR_DS_INVALID_DN_SYNTAX ||
			 hr == E_ADS_BAD_PATHNAME )
		{
			DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_INVALID_DN_SYNTAX, m_strName, hr);
			return FALSE;
		}
		else if (	(hr & DS_ERROR_MASK) == ERROR_DS_CONSTRAINT_VIOLATION ||
					(hr & DS_ERROR_MASK) == ERROR_DS_UNWILLING_TO_PERFORM ||
					(hr & DS_ERROR_MASK) == ERROR_GEN_FAILURE )
		{
			DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_MAYBE_INVALID_DN_SYNTAX, m_strName, hr);
			return FALSE;
		}
		
        MessageDSError(hr, IDS_OP_CREATE_COMPUTER, m_strName);

        //
        // On error - do not call the default, and thus do not exit the dialog
        //
        return FALSE;
    }

    PROPID aProp[] = {PROPID_QM_SITE_IDS,                       
                      PROPID_QM_SERVICE_DSSERVER,  
                      PROPID_QM_SERVICE_ROUTING, 
                      PROPID_QM_SERVICE_DEPCLIENTS, 
                      PROPID_QM_FOREIGN, 
                      PROPID_QM_OS};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    UINT uiPropIndex = 0;

    //
    // PROPID_QM_SITE_IDS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SITE_IDS);   
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 1;
    apVar[uiPropIndex].cauuid.pElems = &m_guidSite;

    uiPropIndex++;
    
    //
    // PROPID_QM_SERVICE_DSSERVER
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_DSSERVER);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE_ROUTING
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_ROUTING);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE_DEPCLIENTS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_DEPCLIENTS);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;


    //
    // PROPID_QM_FOREIGN
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_FOREIGN);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = TRUE;

    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_OS);
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = MSMQ_OS_FOREIGN;

    uiPropIndex++;
    
    hr = ADCreateObject(
            eMACHINE,
            GetDomainController(m_strDomainController),
			true,	    // fServerName
            (LPTSTR)((LPCTSTR)m_strName),
            NULL, //pSecurityDescriptor,
            sizeof(aProp) / sizeof(aProp[0]),
            aProp, 
            apVar,
            NULL    
            );

    if FAILED(hr)
    {
        MessageDSError(hr, IDS_OP_CREATE_MSMQ_OBJECT, m_strName);
        return FALSE;
    }


    CString strConfirmation;
    strConfirmation.FormatMessage(IDS_FOREIGN_COMPUTER_CREATED, m_strName);
    AfxMessageBox(strConfirmation, MB_ICONINFORMATION );

	return CMqPropertyPage::OnWizardFinish();
}


void
CForeignComputer::DDV_ValidComputerName(
	CDataExchange* pDX,
	CString& strName
	)
{
	if (!pDX->m_bSaveAndValidate)
		return;

	int indexDot = strName.Find(L'.');
	int indexSpaceStart = strName.Find(L' ');
	int indexSpaceEnd = strName.Find(L' ', strName.GetLength()-1);

	if (indexDot >= 0 || 
		indexSpaceStart == 0 ||
		indexSpaceEnd >= 0)
	{
		DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_INVALID_DN_SYNTAX, strName, 0);
        pDX->Fail();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\entergen.cpp ===
// EnterGen.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "EnterGen.h"
#include "mqdsname.h"

#include "entergen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral property page

IMPLEMENT_DYNCREATE(CEnterpriseGeneral, CMqPropertyPage)

const int CEnterpriseGeneral::m_conversionTable[] = { 1, 60, 60*60, 60*60*24 };

CEnterpriseGeneral::CEnterpriseGeneral(
    const CString& EnterprisePathName,
	const CString& strDomainController
    ) : 
    CMqPropertyPage(CEnterpriseGeneral::IDD),
    m_strDomainController(strDomainController),
	m_dwLongLiveValue(0)
{
	//{{AFX_DATA_INIT(CEnterpriseGeneral)
	//}}AFX_DATA_INIT
	m_strMsmqServiceContainer.Format(
								L"%s"
								TEXT(",")
								L"%s",
								x_MsmqServiceContainerPrefix,
								EnterprisePathName
								);
}

CEnterpriseGeneral::~CEnterpriseGeneral()
{
}

void CEnterpriseGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
   	int	iLongLiveUnits = eSeconds;
	DWORD	dwLongLiveFieldValue = m_dwLongLiveValue;

    if (!pDX->m_bSaveAndValidate)
    {
        //
        // If time is exactly divided by days, hours or seconds use it.
        //
        for (DWORD i = eDays;  i > eSeconds; --i)
        {
            if ((dwLongLiveFieldValue % m_conversionTable[i]) == 0)
            {
                iLongLiveUnits = i;
                dwLongLiveFieldValue = dwLongLiveFieldValue / m_conversionTable[i];
                break;
            }
        }
    }

	DDX_CBIndex(pDX, IDC_ENT_GEN_LONGLIVE_UNITS_COMBO, iLongLiveUnits);
	DDX_Text(pDX, IDC_ENT_GEN_LONGLIVE_EDIT, dwLongLiveFieldValue);

	//{{AFX_DATA_MAP(CEnterpriseGeneral)
	//}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        m_dwLongLiveValue = dwLongLiveFieldValue * m_conversionTable[iLongLiveUnits];
    }
}



BEGIN_MESSAGE_MAP(CEnterpriseGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CEnterpriseGeneral)
	ON_CBN_SELCHANGE(IDC_ENT_GEN_LONGLIVE_UNITS_COMBO, OnEnterpriseLongLiveChange)
	ON_EN_CHANGE(IDC_ENT_GEN_LONGLIVE_EDIT, OnEnterpriseLongLiveChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral message handlers

BOOL CEnterpriseGeneral::OnInitDialog() 
{
    CString strLongLiveUnit;
	
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());

        const int UnitTypes[] = {IDS_SECONDS, IDS_MINUTES, IDS_HOURS, IDS_DAYS};
        //
        // Initialize the units combo box
        //
        CComboBox *ccomboUnits = (CComboBox *)GetDlgItem(IDC_ENT_GEN_LONGLIVE_UNITS_COMBO);

        for (int i = eSeconds; i < eLast; ++i)
        {
            VERIFY(FALSE != strLongLiveUnit.LoadString(UnitTypes[i]));
            VERIFY(CB_ERR != ccomboUnits->AddString(strLongLiveUnit));
        }
    }

    UpdateData( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CEnterpriseGeneral::OnApply() 
{
    if (m_dwLongLiveValue == m_dwInitialLongLiveValue)
    {
        return TRUE;
    }

    PROPID paPropid[] = { PROPID_E_LONG_LIVE };
	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_E_LONG_LIVE
    //
    ASSERT(paPropid[iProperty] == PROPID_E_LONG_LIVE);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwLongLiveValue;
    
    //
    // set the new value
    //	
    HRESULT hr = ADSetObjectProperties(
                        eENTERPRISE,
                        GetDomainController(m_strDomainController),
						true,	// fServerName
                        L"msmq",
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

    if (MQ_OK != hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqServiceContainer);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}

void CEnterpriseGeneral::OnEnterpriseLongLiveChange() 
{
    SetModified();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgcomp.h ===
#ifndef FORGCOMP_NEW
#define FORGCOMP_NEW

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForgComp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer dialog

class CForeignComputer : public CMqPropertyPage
{
// Construction
public:
	CForeignComputer(const CString& strDomainController);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CForeignComputer)
	enum { IDD = IDD_CREATE_FOREIGN_COMPUTER };
	CComboBox	m_ccomboSites;
	CString	m_strName;
	int		m_iSelectedSite;
	//}}AFX_DATA

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CForeignComputer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	GUID m_guidSite;
    HRESULT InitiateSitesList();
    CArray<GUID, const GUID&> m_aguidAllSites;
    CString m_strDomainController;


	// Generated message map functions
	//{{AFX_MSG(CForeignComputer)
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CGeneralPropertySheet* m_pParentSheet;

	void DDV_ValidComputerName(CDataExchange* pDX, CString& strName);

};

#endif // #ifndef FORGCOMP_NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgdata.cpp ===
// ForeignSiteData.cpp : Implementation of CForeignSiteData
#include "stdafx.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "ForgData.h"
#include "ForgPage.h"

#include "forgdata.tmh"

const PROPID CForeignSiteData::mx_paPropid[] = {
    PROPID_S_FOREIGN
    };

HRESULT 
CForeignSiteData::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    return ExtractNameFromLdapName(m_strMsmqPath, lpwstrLdapPath, 1);
}

STDMETHODIMP 
CForeignSiteData::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (FAILED(GetPropertiesSilent()))
    {
        return E_UNEXPECTED;
    }

    //
    // Check that the site is a foreign site.
    //
    PROPVARIANT propVar;
    PROPID pid = PROPID_S_FOREIGN;
    
    VERIFY(m_propMap.Lookup(pid, propVar));
    if (propVar.bVal == FALSE)
    {
        return S_OK;
    }

    HPROPSHEETPAGE hPage = CreateForeignSitePage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}

HPROPSHEETPAGE 
CForeignSiteData::CreateForeignSitePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Note: CForeignPage is auto-delete by default
    //
	CForeignPage *pcpageForeign = new CForeignPage;

	return CreatePropertySheetPage(&pcpageForeign->m_psp);  
}

const 
DWORD  
CForeignSiteData::GetPropertiesCount()
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgdata.h ===
// ForgData.h : Declaration of the CForeignSiteData

#ifndef __FOREIGNSITEDATA_H_
#define __FOREIGNSITEDATA_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CForeignSiteData
class ATL_NO_VTABLE CForeignSiteData : 
	public CDataObject,
	public CComCoClass<CForeignSiteData, &CLSID_ForeignSiteData>
{
    DECLARE_NOT_AGGREGATABLE(CForeignSiteData)
    DECLARE_REGISTRY_RESOURCEID(IDR_FOREIGNSITEDATA)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateForeignSitePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    static const PROPID mx_paPropid[];

};


inline
const 
DWORD 
CForeignSiteData::GetObjectType()
{
    return MQDS_SITE;
}

inline
const 
PROPID*
CForeignSiteData::GetPropidArray()
{
    return mx_paPropid;
}

//
// IContextMenu
//
inline
STDMETHODIMP 
CForeignSiteData::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

inline
STDMETHODIMP 
CForeignSiteData::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}


#endif //__FOREIGNSITEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgpage.cpp ===
// ForgPage.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "ForgPage.h"

#include "forgpage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignPage property page

IMPLEMENT_DYNCREATE(CForeignPage, CMqPropertyPage)

CForeignPage::CForeignPage() : CMqPropertyPage(CForeignPage::IDD)
{
	//{{AFX_DATA_INIT(CForeignPage)
	m_Description = _T("");
	//}}AFX_DATA_INIT
}

CForeignPage::~CForeignPage()
{
}

void CForeignPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CForeignPage)
	DDX_Text(pDX, IDC_FOREIGN_LABEL, m_Description);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CForeignPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CForeignPage message handlers

BOOL CForeignPage::OnInitDialog() 
{
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_Description.LoadString(IDS_FOREIGN_SITE);
    }

    UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgpage.h ===
#if !defined(AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForgPage.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CForeignPage dialog

class CForeignPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CForeignPage)

// Construction
public:
	CForeignPage();
	~CForeignPage();

// Dialog Data
	//{{AFX_DATA(CForeignPage)
	enum { IDD = IDD_FOREIGN_SITE };
	CString	m_Description;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CForeignPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CForeignPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgsite.h ===
#ifndef FORGSITE_NEW
#define FORGSITE_NEW

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForeignSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CForeignSite dialog

class CForeignSite : public CMqPropertyPage
{
// Construction
public:
	CForeignSite(CString strRootDomain);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CForeignSite)
	enum { IDD = IDD_CREATE_FOREIGN_SITE };
	CString	m_Foreign_Site_Name;
	CString	m_strDomainController;
	//}}AFX_DATA

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CForeignSite)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CForeignSite)
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HRESULT
    CreateForeignSite(
        void
        );

	CGeneralPropertySheet* m_pParentSheet;
	CString m_strRootDomain;

};


#endif // FORGSITE_NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\forgsite.cpp ===
// ForgSite.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqppage.h"
#include "ForgSite.h"

#include "forgsite.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignSite dialog


CForeignSite::CForeignSite(CString strRootDomain)
	: CMqPropertyPage(CForeignSite::IDD),
	  m_strRootDomain(strRootDomain)
{
	//{{AFX_DATA_INIT(CForeignSite)
	m_Foreign_Site_Name = _T("");
	//}}AFX_DATA_INIT
}


void
CForeignSite::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CForeignSite::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CForeignSite)
	DDX_Text(pDX, IDC_FOREIGN_SITE_NAME, m_Foreign_Site_Name);
	//}}AFX_DATA_MAP

    if ((pDX->m_bSaveAndValidate) && (m_Foreign_Site_Name.IsEmpty()))
    {
        AfxMessageBox(IDS_MISSING_FOREIGN_SITE_NAME);
        pDX->Fail();
    }
}


BEGIN_MESSAGE_MAP(CForeignSite, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CForeignSite message handlers
BOOL CForeignSite::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	CString strTitle;
	strTitle.FormatMessage(IDS_SITES, m_strRootDomain);

	SetDlgItemText(IDC_FOREIGN_SITE_CONTAINER, strTitle);

	return TRUE;
}


BOOL CForeignSite::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


BOOL CForeignSite::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create Site link in the DS
    //
    HRESULT rc = CreateForeignSite();
    if(FAILED(rc))
    {
		if ( (rc & DS_ERROR_MASK) == ERROR_DS_INVALID_DN_SYNTAX ||
			 (rc & DS_ERROR_MASK) == ERROR_DS_NAMING_VIOLATION ||
			 rc == E_ADS_BAD_PATHNAME )
		{
			DisplayErrorAndReason(IDS_CREATE_SITE_FAILED, IDS_INVALID_DN_SYNTAX, m_Foreign_Site_Name, rc);
			return FALSE;
		}

        MessageDSError(rc, IDS_CREATE_SITE_FAILED, m_Foreign_Site_Name);
        return FALSE;
    }

    CString strConfirmation;
    strConfirmation.FormatMessage(IDS_FOREIGN_SITE_CREATED, m_Foreign_Site_Name);
    AfxMessageBox(strConfirmation, MB_ICONINFORMATION);

    return CMqPropertyPage::OnWizardFinish();
}


HRESULT
CForeignSite::CreateForeignSite(
    void
    )
{
    ASSERT(!m_Foreign_Site_Name.IsEmpty());


    //
    // Prepare the properties for DS call.
    //
    PROPID paPropid[] = { 
                PROPID_S_FOREIGN
                };

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    DWORD iProperty = 0;

	ASSERT(paPropid[iProperty] == PROPID_S_FOREIGN);    //PropId
    apVar[iProperty].vt = VT_UI1;          //Type
    apVar[iProperty].bVal = TRUE;
    ++iProperty;
  
    HRESULT hr = ADCreateObject(
                    eSITE,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    m_Foreign_Site_Name,
                    NULL, //pSecurityDescriptor,
                    iProperty,
                    paPropid,
                    apVar,                                  
                    NULL    
                    );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\frslist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    frslist.h

Abstract:

    FRS list control - definitions.

Author:

    Yoel Arnon (yoela)

--*/
#ifndef _FRSLIST_H_
#define _FRSLIST_H_

class CGuidArray;

class CFrsList : public CComboBox
{
public:
    CFrsList();
    ~CFrsList();
	HRESULT InitFrsList(const GUID *pguidSiteId, const CString& strDomainController);
    CFrsList& operator = (const CFrsList &frslst);
    int SelectGuid(GUID &guid, const CString& strDomainController);
    int AddItem(LPCWSTR strItem, GUID &guidItem);
    BOOL GetLBGuid(int nIndex, GUID &guid);
    BOOL GetSelectedGuid(GUID &guid);

protected:
    static CMap<GUID, const GUID&, CString, LPCTSTR> m_mapFrsCache;
    CGuidArray *m_pGuidArray;
    void Initiate();
};

inline BOOL CFrsList::GetSelectedGuid(GUID &guid)
{
    int nIndex = GetCurSel();

    if (FAILED(nIndex))
    {
        return FALSE;
    }

    return GetLBGuid(nIndex, guid);
}

//
// Note: CGuidArray can only be allocated on the heap!
//
class CGuidArray : public CArray<GUID, const GUID&>
{
public:
    ULONG AddRef();
    ULONG Release();
    CGuidArray();

private:
    ULONG m_ulRefCount;
    ~CGuidArray();
};

inline CGuidArray::CGuidArray() :
    m_ulRefCount(1)    
{
}

inline CGuidArray::~CGuidArray()
{
    ASSERT(0 == m_ulRefCount);
}

inline ULONG CGuidArray::AddRef()
{
    return (++m_ulRefCount);
}

inline ULONG CGuidArray::Release()
{
    ASSERT(m_ulRefCount > 0);
    m_ulRefCount--;
    if (0 == m_ulRefCount)
    {
        delete this;
    }
    return m_ulRefCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\generrpg.cpp ===
// GenErrPg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "GenErrPg.h"

#include "generrpg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage dialog


CGeneralErrorPage::CGeneralErrorPage()
	: CMqPropertyPage(CGeneralErrorPage::IDD)
{
	//{{AFX_DATA_INIT(CGeneralErrorPage)
	m_strError = _T("");
	//}}AFX_DATA_INIT
}

CGeneralErrorPage::CGeneralErrorPage(CString &strError)
	: CMqPropertyPage(CGeneralErrorPage::IDD)
{
    m_strError = strError;
}

void CGeneralErrorPage::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGeneralErrorPage)
	DDX_Text(pDX, IDC_ERROR_LABEL, m_strError);
	//}}AFX_DATA_MAP
}

HPROPSHEETPAGE CGeneralErrorPage::CreateGeneralErrorPage(
    CDisplaySpecifierNotifier *pDsNotifier, CString &strErr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
    CMqDsPropertyPage<CGeneralErrorPage> *pcpageErrorGeneral = 
        new CMqDsPropertyPage<CGeneralErrorPage> (pDsNotifier, strErr);

    return CreatePropertySheetPage(&pcpageErrorGeneral->m_psp);  
}


BEGIN_MESSAGE_MAP(CGeneralErrorPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CGeneralErrorPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage message handlers

BOOL CGeneralErrorPage::OnInitDialog() 
{

    UpdateData( FALSE );

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\frslist.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    frslist.cpp

Abstract:

    FRS list control - source.

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "resource.h"
#include "frslist.h"
#include "globals.h"
#include "dsext.h"

#include "frslist.tmh"

CFrsList::CFrsList() :
    m_pGuidArray(0)
{
}

CFrsList::~CFrsList()
{
    if (m_pGuidArray)
    {
        m_pGuidArray->Release();
    }
}


HRESULT CFrsList::InitFrsList(const GUID *pguidSiteId, const CString& strDomainController)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Initiate();
    if (0 != m_pGuidArray)
    {
        m_pGuidArray->Release();
    }
    m_pGuidArray = new CGuidArray;

    HRESULT hr = S_OK;
    PROPID aPropId[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID};
    const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

    PROPVARIANT apResultProps[x_nProps];

    CColumns columns;
    for (DWORD i=0; i<x_nProps; i++)
    {
        columns.Add(aPropId[i]);
    }

    //
    // This search request will be recognized and specially simulated by DS
    //    
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQuerySiteServers(
                    GetDomainController(strDomainController),
					true,		// fServerName
                    pguidSiteId,
                    eRouter,
                    columns.CastToStruct(),
                    &hEnume
                    );
    }

    DSLookup dslookup (hEnume, hr);
    
    if (!dslookup.HasValidHandle())
    {
        return E_UNEXPECTED;
    }

    DWORD dwPropCount = x_nProps;
    while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
            && (dwPropCount != 0) )
    {
        DWORD iProperty = 0;
        
        //
        // PROPID_QM_PATHNAME
        //
        ASSERT(PROPID_QM_PATHNAME == aPropId[iProperty]);
        CAutoMQFree<WCHAR> lpwstrFrsName = apResultProps[iProperty].pwszVal;

        iProperty++;

        //
        // PROPID_QM_MACHINE_ID
        //
        ASSERT(PROPID_QM_MACHINE_ID == aPropId[iProperty]);
        CAutoMQFree<GUID> pguidFrs = apResultProps[iProperty].puuid;

        int nIndex = AddItem(lpwstrFrsName, *pguidFrs);

        if (FAILED(nIndex))
        {
            return E_UNEXPECTED;
        }

        //
        // Add the FRS to the cache.
        // 
        m_mapFrsCache[*pguidFrs] = lpwstrFrsName;

        dwPropCount = x_nProps;
    }

    return hr;
}

CFrsList& CFrsList::operator = (const CFrsList &frslst)
{
    if (&frslst == this)
    {
        return *this;
    }

    //
    // First, clears the current items in the combo box
    //
    while(CB_ERR != DeleteString(0));
    m_pGuidArray = frslst.m_pGuidArray;
    m_pGuidArray->AddRef();

    for (int i=0; i<frslst.GetCount(); i++)
    {
        CString strCurrentString;
        frslst.GetLBText(i, strCurrentString);
        int iNewIndex = AddString(strCurrentString);
        if (SUCCEEDED(iNewIndex))
        {
            INT_PTR iCurrentIndex = frslst.GetItemData(i);
            SetItemData(iNewIndex, iCurrentIndex);
        }
    }
    return *this;
}

int CFrsList::SelectGuid(GUID &guid, const CString& strDomainController)
{
    CString strItemToSelect;
    HRESULT hr;

    if (0 == m_mapFrsCache.Lookup(guid, strItemToSelect))
    {
        PROPID pid = PROPID_QM_PATHNAME;
        PROPVARIANT var;

        var.vt = VT_NULL;

        hr = ADGetObjectPropertiesGuid(
                eMACHINE,
                GetDomainController(strDomainController),
				true,	// fServerName
                &guid, 
                1, 
                &pid, 
                &var
                );

        if (SUCCEEDED(hr))
        {
            strItemToSelect = var.pwszVal;
            MQFreeMemory(var.pwszVal);
            m_mapFrsCache[guid] = strItemToSelect;
        }
        else
        {
            return CB_ERR;
        }
    }

    int nIndex = FindStringExact( -1, strItemToSelect);

    if (CB_ERR == nIndex)
    {
        //
        // Add the item to the combo box
        //
        nIndex = AddItem(strItemToSelect, guid);
        if (FAILED(nIndex))
        {
            return CB_ERR;
        }
    }

    VERIFY(CB_ERR != SetCurSel(nIndex));

    return nIndex;
}

int CFrsList::AddItem(LPCWSTR strItem, GUID &guidItem)
{
    int nIndex = AddString(strItem);
    if (FAILED(nIndex))
    {
        return CB_ERR;
    }

    if (0 != m_pGuidArray)
    {
        INT_PTR iGuidIndex = m_pGuidArray->Add(guidItem);

        if (FAILED(SetItemData(nIndex, iGuidIndex)))
        {
            return CB_ERR;
        }
    }
    else
    {
        ASSERT(0);
        return CB_ERR;
    }

    return nIndex;
}

BOOL CFrsList::GetLBGuid(int nIndex, GUID &guid)
{
    INT_PTR iGuidIndex = GetItemData(nIndex);

    if (iGuidIndex < 0)
    {
        return FALSE;
    }

    ASSERT(0 != m_pGuidArray && iGuidIndex <= m_pGuidArray->GetUpperBound());

    guid = (*m_pGuidArray)[iGuidIndex];

    return TRUE;
}

static INT_PTR s_initItemData = -1;

void CFrsList::Initiate()
{
    while(CB_ERR != DeleteString(0))
	{
		NULL;
	}

    CString strNone;
    strNone.LoadString(IDS_COMBO_SELECTION_NONE);

    VERIFY(0 == AddString(strNone));
    SetItemData(0, s_initItemData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\generrpg.h ===
#if !defined(AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_)
#define AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GenErrPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage dialog

class CGeneralErrorPage : public CMqPropertyPage
{
// Construction
public:
	CGeneralErrorPage();   // standard constructor
    CGeneralErrorPage(CString &strError);
    static HPROPSHEETPAGE CreateGeneralErrorPage(CDisplaySpecifierNotifier *pDsNotifier, CString &strErr);

// Dialog Data
	//{{AFX_DATA(CGeneralErrorPage)
	enum { IDD = IDD_GENERALERROR };
	CString	m_strError;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGeneralErrorPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGeneralErrorPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\infodlg.cpp ===
// InfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqPPage.h"
#include "InfoDlg.h"

#include "infodlg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInfoDlgDialog dialog

CInfoDlgDialog::CInfoDlgDialog(LPCTSTR szInfoText, CWnd* pParent /*=NULL*/)
	: CMqDialog(CInfoDlgDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInfoDlgDialog)
	m_szInfoText = _T("");
	//}}AFX_DATA_INIT
    m_szInfoText = szInfoText;
	m_pParent = pParent;
	m_nID = CInfoDlgDialog::IDD;
}

BOOL CInfoDlgDialog::Create()
{
    return CDialog::Create(m_nID, m_pParent);
}

CInfoDlgDialog *CInfoDlgDialog::CreateObject(LPCTSTR szInfoText, CWnd* pParent)
{
    CInfoDlgDialog *dlg = new CInfoDlgDialog(szInfoText, pParent);
    if (dlg)
    {
        dlg->Create();
    }

    return dlg;
}

void CInfoDlgDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInfoDlgDialog)
	DDX_Text(pDX, IDC_Moving_Files_LABEL, m_szInfoText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInfoDlgDialog, CMqDialog)
	//{{AFX_MSG_MAP(CInfoDlgDialog)   
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CInfoDlgDialog::PostNcDestroy()
{
	CDialog::PostNcDestroy();
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// CInfoDlg - Wrapper class

CInfoDlg::CInfoDlg(LPCTSTR szInfoText, CWnd* pParent)
{
    m_pinfoDlg = CInfoDlgDialog::CreateObject(szInfoText, pParent);
}

CInfoDlg::~CInfoDlg()
{
    //
    // Note: We do not delete m_pinfoDlg. It deletes itself on PostNcDestroy
    //
    if (m_pinfoDlg)
    {
        m_pinfoDlg->DestroyWindow();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\icons.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	icons.h

Abstract:

	
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __ICONS_H_
#define __ICONS_H_

enum MQICON {

	IMAGE_DEADLETTER_QUEUE,
	IMAGE_JOURNAL_QUEUE,
	IMAGE_PRIVATE_QUEUE,
	IMAGE_PRIVATE_FOLDER_CLOSE,
	IMAGE_PRIVATE_FOLDER_OPEN,
	IMAGE_SYSTEM_FOLDER_CLOSE,
	IMAGE_SYSTEM_FOLDER_OPEN,
	IMAGE_PUBLIC_FOLDER_NODS_CLOSE,
	IMAGE_PUBLIC_FOLDER_NODS_OPEN,
    IMAGE_QUEUE,
    IMAGE_MESSAGE,
    IMAGE_JOURNAL_MESSAGE,
    IMAGE_REPORT_MESSAGE,
    IMAGE_ACK_MESSAGE,
    IMAGE_NACK_MESSAGE,
    IMAGE_TEST_MESSAGE,
    IMAGE_DEAD_LETTER_MESSAGE,
	IMAGE_PRODUCT_ICON,
	IMAGE_PRODUCT_NOTCONNECTED,
	IMAGE_LOCAL_OUTGOING_QUEUE,
	IMAGE_PUBLIC_QUEUE,
	IMAGE_PRIVATE_QUEUE_HOLD,
	IMAGE_QUEUE_HOLD,
	IMAGE_LOCAL_OUTGOING_QUEUE_HOLD,
	IMAGE_PUBLIC_QUEUE_HOLD,
	IMAGE_ERROR,
	IMAGE_TRIGGERS_GENERAL,
	IMAGE_TRIGGERS_DEFINITION,
	IMAGE_RULES_DEFINITION
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\infodlg.h ===
// InfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInfoDlgDialog dialog

class CInfoDlgDialog : public CMqDialog
{
// Construction
public:
    static CInfoDlgDialog *CreateObject(LPCTSTR szInfoText, CWnd* pParent = NULL);

private:
    //
    // Private constructor - this object can only be created
    // using CreateObject
    //
    CInfoDlgDialog(LPCTSTR szInfoText, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CInfoDlgDialog)
	enum { IDD = IDD_INFO_DLG };
    CString m_szInfoText;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CInfoDlgDialog)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:  
    // Generated message map functions
    //{{AFX_MSG(CInfoDlgDialog)       
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL Create();
    CWnd* m_pParent;
	int m_nID;
};

class CInfoDlg
{
public:
    CInfoDlg(LPCTSTR szInfoText, CWnd* pParent = NULL);
    ~CInfoDlg();

private:
    CInfoDlgDialog *m_pinfoDlg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\linkdata.cpp ===
// linkdata.cpp : Implementation of CLinkDataObject
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "linkdata.h"
#include "linkgen.h"
#include "SiteGate.h"
#include "globals.h"
#include "msmqlink.h"

#include "linkdata.tmh"

const PROPID CLinkDataObject::mx_paPropid[] = {
    PROPID_L_NEIGHBOR1,
    PROPID_L_NEIGHBOR2,
    PROPID_L_ACTUAL_COST,
    PROPID_L_GATES_DN,
	PROPID_L_DESCRIPTION
    };


/////////////////////////////////////////////////////////////////////////////
// CLinkDataObject


//
// IShellPropSheetExt
//

HRESULT 
CLinkDataObject::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    return ExtractLinkPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}


STDMETHODIMP 
CLinkDataObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (SUCCEEDED(GetPropertiesSilent()))
    {
        InitializeLinkProperties();

        HPROPSHEETPAGE hPage = CreateGeneralPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
        //
        //  Is it a valid site-link
        //
        if ((m_FirstSiteId != GUID_NULL) &&
            (m_SecondSiteId != GUID_NULL))
        {
            hPage = CreateSiteGatePage();
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        }
    }
    else
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}

void
CLinkDataObject::InitializeLinkProperties(
    void
    )
{
    PROPVARIANT propVar;
    PROPID pid;

    //
    // Get first site ID
    //
    pid = PROPID_L_NEIGHBOR1;
    VERIFY(m_propMap.Lookup(pid, propVar));
    //
    //  check neighbor validity
    //
    if (propVar.vt == VT_EMPTY)
    {
        m_FirstSiteId = GUID_NULL;
    }
    else
    {
        m_FirstSiteId = *(propVar.puuid);
    }

    //
    // Get second site ID
    //
    pid = PROPID_L_NEIGHBOR2;
    VERIFY(m_propMap.Lookup(pid, propVar));
    //
    //  check neighbor validity
    //
    if (propVar.vt == VT_EMPTY)
    {
        m_SecondSiteId = GUID_NULL;
    }
    else
    {
        m_SecondSiteId = *(propVar.puuid);
    }

    pid = PROPID_L_ACTUAL_COST;
    VERIFY(m_propMap.Lookup(pid, propVar));
    m_LinkCost = propVar.ulVal; 

    pid = PROPID_L_DESCRIPTION;
    VERIFY(m_propMap.Lookup(pid, propVar));
	if (propVar.vt == VT_EMPTY)
	{
		m_LinkDescription = L"";
	}
	else
	{
		m_LinkDescription = propVar.pwszVal;
	}

}


HPROPSHEETPAGE 
CLinkDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CLinkGen> *pcpageGeneral = 
        new CMqDsPropertyPage<CLinkGen>(m_pDsNotifier, m_strMsmqPath, m_strDomainController);
    pcpageGeneral->Initialize(
                        &m_FirstSiteId, 
                        &m_SecondSiteId,
                        m_LinkCost,
						m_LinkDescription
                        );

    return CreatePropertySheetPage(&pcpageGeneral->m_psp);  
}


HPROPSHEETPAGE 
CLinkDataObject::CreateSiteGatePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid = PROPID_L_GATES_DN;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Note: CLinkDataObject is auto-delete by default
    //
	CSiteGate *pSiteGatePage = new CSiteGate(m_strDomainController, m_strMsmqPath);
    pSiteGatePage->Initialize(
                        &m_FirstSiteId, 
                        &m_SecondSiteId,
                        &propVar.calpwstr
                        );

	return CreatePropertySheetPage(&pSiteGatePage->m_psp);  
}


const 
DWORD  
CLinkDataObject::GetPropertiesCount(
    void
    )
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}


//
// IContextMenu
//
STDMETHODIMP 
CLinkDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

STDMETHODIMP 
CLinkDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}


STDMETHODIMP CLinkDataObject::Initialize(IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }
    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call CreateModal()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		//
		// If we failed to get IADs we will return
		// m_strDomainController will not be initialized, but this is ok
		//
		return S_OK;
	}

    VARIANT var;
    hr = pIADs->Get(L"distinguishedName", &var);
    ASSERT(SUCCEEDED(hr));

	GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerDispFormat);
    VariantClear(&var);

	BSTR bstr;
 	hr = pIADs->get_ADsPath(&bstr);
    ASSERT(SUCCEEDED(hr));
	hr = ExtractDCFromLdapPath(m_strDomainController, bstr);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

    return S_OK;
}

HRESULT 
CLinkDataObject::CreateModal(HWND hwndParent, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    R<CMsmqLink> pMsmqLink = new CMsmqLink(m_strDomainController, m_strContainerDispFormat);
	CGeneralPropertySheet propertySheet(pMsmqLink.get());
	pMsmqLink->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pMsmqLink data also after DoModal() exitst
	//
	pMsmqLink->AddRef();
    if (IDCANCEL == propertySheet.DoModal())
    {
        return S_FALSE;
    }

    LPCWSTR SiteLinkFullPath = pMsmqLink->GetSiteLinkFullPath();
    if (SiteLinkFullPath == NULL)
    {
        return S_FALSE;
    }

    CString strTemp = L"LDAP://";
    strTemp += SiteLinkFullPath;

    HRESULT rc = ADsOpenObject( 
		            (LPWSTR)(LPCWSTR)strTemp,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) ppADsObj
					);

    if(FAILED(rc))
    {   
        if ( ADProviderType() == eMqdscli)
        {
            AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        }
        else
        {
            MessageDSError(rc, IDS_CREATED_BUT_RETRIEVE_FAILED);
        }
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\linkgen.cpp ===
// LinkGen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "LinkGen.h"
#include "globals.h"

#include "linkgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLinkGen property page

IMPLEMENT_DYNCREATE(CLinkGen, CMqPropertyPage)

CLinkGen::CLinkGen(
    const CString& LinkPathName,
    const CString& strDomainController
    ) : 
    CMqPropertyPage(CLinkGen::IDD),
    m_LinkPathName(LinkPathName),
    m_strDomainController(strDomainController),
    m_pFirstSiteId(NULL),
    m_pSecondSiteId(NULL)
{
	//{{AFX_DATA_INIT(CLinkGen)
	m_LinkCost = 0;
	m_LinkLabel = _T("");
	//}}AFX_DATA_INIT
}

CLinkGen::~CLinkGen()
{
}

void CLinkGen::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLinkGen)
	DDX_Text(pDX, IDC_LINK_COST, m_LinkCost);
	DDV_MinMaxDWord(pDX, m_LinkCost, 1, MQ_MAX_LINK_COST);
	DDX_Text(pDX, IDC_LINK_LABEL, m_LinkLabel);
	DDX_Text(pDX, IDC_LINK_DESCR, m_strLinkDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLinkGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CLinkGen)
	ON_EN_CHANGE(IDC_LINK_COST, OnChangeRWField)
	ON_EN_CHANGE(IDC_LINK_DESCR, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLinkGen message handlers

BOOL CLinkGen::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //

    UpdateData( FALSE );
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


HRESULT
CLinkGen::GetSiteName(
    const GUID* pguidSiteId,
    CString *   pstrSiteName
    )
{
    //
    //  Is the site-id valid?
    //
    if (*pguidSiteId == GUID_NULL)
    {
        //
        //  Not a valid site
        //
        pstrSiteName->LoadString(IDS_UNKNOWN_OR_DELETED_SITE);
        return MQ_OK;
    }
    //
    // Get the site name
    //
    PROPID pid[1] = { PROPID_S_PATHNAME };
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;
    
    HRESULT hr = ADGetObjectPropertiesGuid(
                    eSITE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    pguidSiteId,
                    1, 
                    pid,
                    var
                    );

    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            CString strSite;
            strSite.LoadString(IDS_SITE);
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, strSite);
        }
        return hr;
    }

    *pstrSiteName = var[0].pwszVal;
    MQFreeMemory(var[0].pwszVal);
    return MQ_OK;
}


HRESULT
CLinkGen::Initialize(
    const GUID* FirstSiteId,
    const GUID* SecondSiteId,
    DWORD LinkCost,
	CString strLinkDescription
    )
{
    CString strFirstSiteName, strSecondSiteName;

    m_pFirstSiteId = FirstSiteId;
    m_pSecondSiteId = SecondSiteId;
    m_LinkCost = LinkCost;
	m_strLinkDescription = strLinkDescription;

    //
    // Get the site name
    //
    HRESULT hr = GetSiteName(
        FirstSiteId,
        &strFirstSiteName
        );
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // Get the second site name
    //
    hr = GetSiteName(
        SecondSiteId,
        &strSecondSiteName
        );
    if (FAILED(hr))
    {
        return hr;
    }

    m_LinkLabel.FormatMessage(IDS_SITE_LINK_LABEL, strFirstSiteName, strSecondSiteName);

    return hr;

}


BOOL CLinkGen::OnApply() 
{
	//
	// No changes
	//
    if (!m_fModified)
    {
        return TRUE;
    }

    PROPID paPropid[] = { PROPID_L_ACTUAL_COST, PROPID_L_DESCRIPTION };
	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_L_ACTUAL_COST
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty].ulVal = m_LinkCost;
	iProperty++;

    //
    // PROPID_L_DESCRIPTION
    //
    apVar[iProperty].vt = VT_LPWSTR;
    apVar[iProperty].pwszVal = (LPWSTR)(static_cast<LPCWSTR>(m_strLinkDescription));
	iProperty++;
    
    //
    // set the new value
    //
    HRESULT hr = ADSetObjectProperties(
                    eROUTINGLINK,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_LinkPathName,
                    x_iPropCount, 
                    paPropid, 
                    apVar
                    );


    if (MQ_OK != hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_LinkPathName);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\globals.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   globals.h

Abstract:

   Definition and partial implementation of various
    utility functions.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#include "snapres.h"
#include "..\..\mqutil\resource.h"
#include "atlsnap.h"
#include "_guid.h"
#include "machdomain.h"
#include "mqaddef.h"

#define MAX_GUID_LENGTH 40
#define MAX_QUEUE_FORMATNAME 300

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif


#define DS_ERROR_MASK 0x0000ffff
//
// Clipboard Formats
//
//
// Clipboard Formats
//
const CLIPFORMAT gx_CCF_FORMATNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_QUEUE_FORMAT_NAME"));
const CLIPFORMAT gx_CCF_PATHNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MESSAGE_QUEUING_PATH_NAME"));  
const CLIPFORMAT gx_CCF_COMPUTERNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

//
// A special flag, move to UpdateAllView to delete all the data in result pane
//
const int UPDATE_REMOVE_ALL_RESULT_NODES = -1;

LPWSTR newwcs(LPCWSTR p);

//
// for AD API: get domain controller name
//
inline LPCWSTR GetDomainController(LPCWSTR pDomainController)
{
	if((pDomainController == NULL) || (wcscmp(pDomainController, L"") == 0))
	{
		//
		// For empty string or NULL pointer, return NULL
		//
		return NULL;
	}

    return pDomainController;
}


/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))

/*-----------------------------------------------------------------------------
/ Other Macros
/----------------------------------------------------------------------------*/
//
// This macro is used after a DS call returns with error. It handle all the
// cases of "object no found" error. The most common cause of this kind of error
// is replication delays (sometimes the DS snap-in domain controller is not the
// same as the MSMQ domain controller) - Yoela, 29-June-98
//
// This macro was updated to display the replication delay popup, only in case AD
// is accessed through MQDSCli. When AD is accessed directly this popup
// is not relevant.
//
#define IF_NOTFOUND_REPORT_ERROR(rc) \
        if ((rc == MQDS_OBJECT_NOT_FOUND \
            || rc == MQ_ERROR_QUEUE_NOT_FOUND \
            || rc == MQ_ERROR_MACHINE_NOT_FOUND) && \
            (  ADProviderType() == eMqdscli)) \
        { \
            AFX_MANAGE_STATE(AfxGetStaticModuleState()); \
            AfxMessageBox(IDS_REPLICATION_PROBLEMS); \
        }


//
// EnumEntry
//
// Used to map a #define value to a resource string
//
//
#define ENUM_ENTRY(x) {x, IDS_ ## x}
struct EnumItem
{
    DWORD val;          //value
    DWORD StringId;     //Resource Id
};

// Scan a list of EnumEntry, and returns the string matching the specific value
void EnumToString(DWORD dwVal, EnumItem * pEnumList, DWORD dwListSize, CString & str);



int CALLBACK SortByString(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByULONG(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByINT(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByCreateTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByModifyTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int __cdecl QSortCompareQueues( const void *arg1, const void *arg2 );

HRESULT 
CreateMachineSecurityPage(
	HPROPSHEETPAGE *phPage, 
	IN LPCWSTR lpwcsMachineName, 
	IN LPCWSTR lpwcsDomainController, 
	IN bool fServerName
	);

//
// Utilities to convert useful propvariant types to string
//
void CALLBACK TimeToString(const PROPVARIANT *pPropVar, CString &str);
void CALLBACK BoolToString(const PROPVARIANT *pPropVar, CString &str);
void CALLBACK QuotaToString(const PROPVARIANT *pPropVar, CString &str);


HRESULT ExtractDCFromLdapPath(CString& strName, LPCWSTR lpcwstrLdapName);
HRESULT ExtractNameFromLdapName(CString &strName, LPCWSTR lpcwstrLdapName, DWORD dwIndex);
HRESULT ExtractComputerMsmqPathNameFromLdapName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName);
HRESULT ExtractComputerMsmqPathNameFromLdapQueueName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName);
HRESULT ExtractQueuePathNameFromLdapName(CString &strQueuePathName, LPCWSTR lpcwstrLdapName);
HRESULT ExtractLinkPathNameFromLdapName(CString& SiteLinkPathName, LPCWSTR lpwstrLdapPath);
HRESULT ExtractAliasPathNameFromLdapName(CString& AliasPathName, LPCWSTR lpwstrLdapPath);
HRESULT ExtractQueueNameFromQueuePathName(CString &strQueueName, LPCWSTR lpcwstrQueuePathName);
HRESULT ExtractQueuePathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    );
HRESULT ExtractQueuePathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    );
HRESULT ExtractPathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrObjectNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL                       fExtractAlsoComputerMsmqObjects
    );
HRESULT ExtractPathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL    fExtractAlsoComputerMsmqObjects
    );

int
MessageDSError(                         //  Error box: "Can not <op> <obj>.\n<rc>."
    HRESULT rc,                         //  DS Error code
    UINT nIDOperation,                  //  Operation string identifier,
                                        //  e.g., get premissions, delete, etc.
    LPCTSTR pObjectName = 0,            //  object that operation performed on
    UINT nType = MB_OK | MB_ICONERROR,  //  buttons & icon
    UINT nIDHelp = (UINT) -1            //  help context
    );

HRESULT MqsnapCreateQueue(CString& strPathName, BOOL fTransactional,
                       CString& strLabel, GUID* pTypeGuid,
                       PROPID aProp[], UINT cProp,
                       CString *pStrFormatName = 0);

HRESULT CreateEmptyQueue(CString &csDSName,
                         BOOL fTransactional, CString &csMachineName, 
                         CString &csPathName, CString *pStrFormatName = 0);

HRESULT CreateTypedQueue(CString& strPathname, CString& strLabel, GUID& TypeGuid);

BOOL MQErrorToMessageString(CString &csErrorText, HRESULT rc);
void DisplayErrorAndReason(UINT uiErrorMsgProblem, UINT uiErrorMsgReason, CString strObject, HRESULT errorCode);
void DisplayErrorFromCOM(UINT uiErrorMsg, const _com_error& e);


HRESULT GetDsServer(CString &strDsServer);
HRESULT GetComputerNameIntoString(CString &strComputerName);
HRESULT GetSiteForeignFlag(const GUID* pSiteId, BOOL *fForeign, const CString& strDomainController);
BOOL GetNetbiosName(CString &strFullDnsName, CString &strNetbiosName);

//
// DDX functions
//
void AFXAPI DDX_NumberOrInfinite(CDataExchange* pDX, int nIDCEdit, int nIDCCheck, DWORD& dwNumber);
void OnNumberOrInfiniteCheck(CWnd *pwnd, int idEdit, int idCheck);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& guid);


typedef void (CALLBACK *PFNDISPLAY)(const PROPVARIANT *pPropVar, CString &str);

#define NO_COLUMN   (DWORD)-1
#define HIDE        (DWORD)-2         // Dont display on the right pane
#define NO_INDEX    (DWORD)-1
#define NO_TITLE    (DWORD)-1
#define NO_PROPERTY (PROPID)-1

class VTHandler;
struct PropertyDisplayItem
{
    UINT        uiStringID;         // Description string
    PROPID         itemPid;         // Id
    VTHandler       *pvth;          // Handler object for the VT type
    PFNDISPLAY      pfnDisplay;     // Special display function. NULL means to call the VT display func.
    DWORD           offset;         // For variable len property, offset in struct
    DWORD           size;           // For variable len property - size, For fix size, default value
    INT            iWidth;          // Original column width
    PFNLVCOMPARE   CompareFunc;     // Compare function
};
//
// Display functions for PropertyDisplayItem
//
void CALLBACK QueuePathnameToName(const PROPVARIANT *pPropVar, CString &str);


void GetPropertyString(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString & strResult);
void GetPropertyVar(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, PROPVARIANT ** ppResult);
void ItemDisplay(PropertyDisplayItem * pItem,PROPVARIANT * pPropVar, CString & szTmp);
HRESULT InsertColumnsFromDisplayList(IHeaderCtrl* pHeaderCtrl, PropertyDisplayItem *aDisplayList);

//----------------------------------------
//
//  Global default width
//
//----------------------------------------
extern int g_dwGlobalWidth;

//----------------------------------------
//
// PROPVARIANT utility functions
//
//----------------------------------------

#define NO_OFFSET       (DWORD) 0xFFFFFFFF

//
// CLASS: VTHandler
// Base class.
// Pure class definiting the interface on a Propavariant class. Every implementation
// of a propvariant class must inherit this one.
//
//
class VTHandler
{
public:
    // Stringize a propvariant value
    virtual void Display(const PROPVARIANT *pPropVar, CString & str) =0;
    // Set a propvariant to a specfic value, at a specifc address (base + offset) for
    // variable length variant
    virtual void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size) =0;

    //
    // Clear the variant
    //
    virtual void Clear(PROPVARIANT *pPropVar)
    {
        //
        // Do nothing by default
        //
    }

};

class VTNumericHandler : public VTHandler
{
public:
    virtual void Clear(PROPVARIANT *pPropVar)
    {
        Set(pPropVar, 0, NO_OFFSET, 0);
    }
};

class VTUI1Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->bVal,szTmp,10);
        str = szTmp;
    }

    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        pPropVar->vt = VT_UI1;
        pPropVar->bVal = static_cast<UCHAR>(val);
    }
};

class VTUI2Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->uiVal,szTmp,10);
        str = szTmp;

    }

    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        pPropVar->vt = VT_UI2;
        pPropVar->uiVal = static_cast<USHORT>(val);
    }
};

class VTUI4Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->ulVal,szTmp,10);
        str = szTmp;

    }

    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        pPropVar->vt = VT_UI4;
        pPropVar->ulVal = val;
    }
};

class VTLPWSTRHandler : public VTHandler
{
public:

      void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        str = pPropVar->pwszVal;
    }

    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size)
    {
        pPropVar->vt = VT_LPWSTR;
        pPropVar->pwszVal = reinterpret_cast<LPWSTR> ((char *)pBase + offset);
    }
};


class VTCLSIDHandler : public VTHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        GUID_STRING szGuid;
        MQpGuidToString(pPropVar->puuid, szGuid);

        str = szGuid;

     }


    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size)
    {
        pPropVar->vt = VT_CLSID;
        pPropVar->puuid = reinterpret_cast<CLSID *> ((char *)pBase + offset);
    }
};

class VTVectLPWSTRHandler : public VTHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
      ASSERT(pPropVar->vt == (VT_LPWSTR|VT_VECTOR));

      str = L"";
      for (DWORD i = 0; i < pPropVar->calpwstr.cElems; i++)
      {
         str += pPropVar->calpwstr.pElems[i];
         str += L" ";
      }
   }


    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size)
    {
      ASSERT(0);
    }
};


class VTVectUI1Handler : public VTHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        str =L"VTVectUI1Handler";
    }


    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size)
    {
        pPropVar->vt = VT_UI1|VT_VECTOR;
        pPropVar->caui.pElems = (unsigned short *)((char *)pBase + offset);
        pPropVar->caui.cElems = size;
    }
};




extern VTUI1Handler        g_VTUI1;
extern VTUI2Handler        g_VTUI2;
extern VTUI4Handler        g_VTUI4;
extern VTLPWSTRHandler     g_VTLPWSTR;
extern VTCLSIDHandler      g_VTCLSID;
extern VTVectUI1Handler    g_VectUI1;
extern VTVectLPWSTRHandler g_VectLPWSTR;

void CaubToString(const CAUB* pcaub, CString& strResult);

//
// Automatic Global Pointer (Use GlobalAlloc and GlobalFree)
//
class CGlobalPointer
{
public:
    operator HGLOBAL() const;
    CGlobalPointer(UINT uFlags, DWORD dwBytes);
    CGlobalPointer(HGLOBAL hGlobal);
    ~CGlobalPointer();

private:
    HGLOBAL m_hGlobal;
};

inline CGlobalPointer::CGlobalPointer(UINT uFlags, DWORD dwBytes)
{
    m_hGlobal = GlobalAlloc(uFlags, dwBytes);
}

inline CGlobalPointer::CGlobalPointer(HGLOBAL hGlobal)
{
    m_hGlobal = hGlobal;
}

inline CGlobalPointer::~CGlobalPointer()
{
    if (0 != m_hGlobal)
    {
        VERIFY( 0 == GlobalFree(m_hGlobal));
    }
}

inline CGlobalPointer::operator HGLOBAL() const
{
    return m_hGlobal;
}

//
// Automatic CoTask memory Pointer (Use CoTaskMemAlloc and CoTaskMemFree)
//
class CCoTaskMemPointer
{
public:
    operator LPVOID() const;
    CCoTaskMemPointer &operator =(LPVOID p);
    CCoTaskMemPointer(DWORD dwBytes);
    ~CCoTaskMemPointer();

private:
    LPVOID m_pvCoTaskMem;
};

inline CCoTaskMemPointer::CCoTaskMemPointer(DWORD dwBytes)
{
    m_pvCoTaskMem = CoTaskMemAlloc(dwBytes);
}

inline CCoTaskMemPointer::~CCoTaskMemPointer()
{
    if (0 != m_pvCoTaskMem)
    {
        CoTaskMemFree(m_pvCoTaskMem);
    }
}

inline CCoTaskMemPointer::operator LPVOID() const
{
    return m_pvCoTaskMem;
}

inline CCoTaskMemPointer &CCoTaskMemPointer::operator =(LPVOID p)
{
    m_pvCoTaskMem = p;
    return *this;
}

//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     { FreeADsStr(m_p); }

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};

//
// CpropMap - creates a properties map for ADGetObjectProperties
//
class CPropMap : public CMap<PROPID, PROPID&, PROPVARIANT, PROPVARIANT &>
{
public:
	CPropMap() {};

    HRESULT GetObjectProperties (
        IN  DWORD                   dwObjectType,
	    IN  LPCWSTR					pDomainController,
        IN  LPCWSTR                 lpwcsPathName,
        IN  DWORD                   cp,
        IN  const PROPID            *aProp,
        IN  BOOL                    fUseMqApi   = FALSE,
        IN  BOOL                    fSecondTime = FALSE
        );
private:

	CPropMap(const CPropMap&);
	CPropMap& operator=(const CPropMap&);

    BOOL IsNt4Property(IN DWORD dwObjectType, IN PROPID pid);
    void GuessW2KValue(PROPID pidW2K);
    /*-----------------------------------------------------------------------------
    / Utility to convert to the new msmq object type
    /----------------------------------------------------------------------------*/
    AD_OBJECT GetADObjectType (DWORD dwObjectType);
};

inline
HRESULT CPropMap::GetObjectProperties (
    IN  DWORD                         dwObjectType,
	IN  LPCWSTR						  pDomainController,
    IN  LPCWSTR                       lpwcsPathNameOrFormatName,
    IN  DWORD                         cp,
    IN  const PROPID                  *aProp,
    IN  BOOL                          fUseMqApi   /* = FALSE */,
    IN  BOOL                          fSecondTime /* = FALSE */)
{
    P<PROPVARIANT> apVar = new PROPVARIANT[cp];
    HRESULT hr = MQ_OK;
    DWORD i;

    //
    // set NULL variants
    //
    for (i=0; i<cp; i++)
    {
        apVar[i].vt = VT_NULL;
    }

    if (fUseMqApi)
    {
        //
        // Only queue is supported right now
        //
        ASSERT(MQDS_QUEUE == dwObjectType);

        MQQUEUEPROPS mqp = {cp, (PULONG)aProp, apVar, 0};
 
        hr = MQGetQueueProperties(lpwcsPathNameOrFormatName, &mqp);
    }
    else
    {
        hr = ADGetObjectProperties(
                GetADObjectType(dwObjectType), 
                GetDomainController(pDomainController),
				true,	// fServerName
                lpwcsPathNameOrFormatName,
                cp,
                const_cast<PROPID *>(aProp),
                apVar
                );

    }
    if (SUCCEEDED(hr))
    {
        for (i = 0; i<cp; i++)
        {
            PROPID pid = aProp[i];

            //
            // Force deletion of old object, if any
            //
            RemoveKey(pid);

            SetAt(pid, apVar[i]);
        }
        return hr;
    }

    if ((hr == MQ_ERROR || hr == MQDS_GET_PROPERTIES_ERROR) && !fSecondTime)
    {
        //
        // Try again - this time just with NT4 properties. We may be working
        // against NT4 PSC
        //
        P<PROPID> aPropNt4 = new PROPID[cp];
        P<PROPID> aPropW2K = new PROPID[cp];
        DWORD cpNt4 = 0;
        DWORD cpW2K = 0;
        for (i = 0; i<cp; i++)
        {
            if (IsNt4Property(dwObjectType, aProp[i]))
            {
                aPropNt4[cpNt4] = aProp[i];
                cpNt4++;
            }
            else
            {
                aPropW2K[cpW2K] = aProp[i];
                cpW2K++;
            }
        }

        //
        // recursive call - get only the NT4 props
        //
        hr = GetObjectProperties(dwObjectType, pDomainController, lpwcsPathNameOrFormatName, cpNt4, 
                                   aPropNt4, fUseMqApi, TRUE);
        if (SUCCEEDED(hr))
        {
            for (i=0; i<cpW2K; i++)
            {
                //
                // Force deletion of old object, if any
                //
                RemoveKey(aPropW2K[i]);
                GuessW2KValue(aPropW2K[i]);
            }
        }
    }

    return hr;
}

inline
BOOL CPropMap::IsNt4Property(IN DWORD dwObjectType, IN PROPID pid)
{
    switch (dwObjectType)
    {
        case MQDS_QUEUE:
            return (pid < PROPID_Q_NT4ID || 
                    (pid > PPROPID_Q_BASE && pid < PROPID_Q_OBJ_SECURITY));

        case MQDS_MACHINE:
            return (pid < PROPID_QM_FULL_PATH || 
                    (pid > PPROPID_QM_BASE && pid <= PROPID_QM_ENCRYPT_PK));

        case MQDS_SITE:
            return (pid < PROPID_S_FULL_NAME || 
                    (pid > PPROPID_S_BASE && pid <= PROPID_S_PSC_SIGNPK));

        case MQDS_ENTERPRISE:
            return (pid < PROPID_E_NT4ID || 
                    (pid > PPROPID_E_BASE && pid <= PROPID_E_SECURITY));

        case MQDS_USER:
            return (pid <= PROPID_U_ID);

        case MQDS_SITELINK:
            return (pid < PROPID_L_GATES_DN);

        default:
            ASSERT(0);
            //
            // Other objects (like CNs) should have the same properties under NT4 or 
            // Win 2K
            //
            return TRUE;
    }
}


/*-----------------------------------------------------------------------------
/ Utility to convert to the new msmq object type
/----------------------------------------------------------------------------*/
inline
AD_OBJECT CPropMap::GetADObjectType (DWORD dwObjectType)
{
    switch(dwObjectType)
    {
    case MQDS_QUEUE:
        return eQUEUE;
        break;

    case MQDS_MACHINE:
        return eMACHINE;
        break;

    case MQDS_SITE:
        return eSITE;
        break;

    case MQDS_ENTERPRISE:
        return eENTERPRISE;
        break;

    case MQDS_USER:
        return eUSER;
        break;

    case MQDS_SITELINK:
        return eROUTINGLINK;
        break;

    case MQDS_SERVER:
        return eSERVER;
        break;

    case MQDS_SETTING:
        return eSETTING;
        break;

    case MQDS_COMPUTER:
        return eCOMPUTER;
        break;

    case MQDS_MQUSER:
        return eMQUSER;
        break;

    default:
        return eNumberOfObjectTypes;    //invalid value
    }

    return eNumberOfObjectTypes;
}

//
// Guess the value of a W2K specific property, based of the value of known NT4 properties
//
inline
void CPropMap::GuessW2KValue(PROPID pidW2K)
{
    PROPVARIANT propVarValue;

    switch(pidW2K)
    {
        case PROPID_QM_SERVICE_DSSERVER:  
        case PROPID_QM_SERVICE_ROUTING:
        case PROPID_QM_SERVICE_DEPCLIENTS:
        {
            PROPVARIANT propVar;
            PROPID pid;
            BOOL fValue = FALSE;

            pid = PROPID_QM_SERVICE;            
            VERIFY(Lookup(pid, propVar));
            ULONG ulService = propVar.ulVal;
            switch(pidW2K)
            {
                case PROPID_QM_SERVICE_DSSERVER:  
                    fValue = (ulService >= SERVICE_BSC);
                    break;

                case PROPID_QM_SERVICE_ROUTING:
                case PROPID_QM_SERVICE_DEPCLIENTS:
                    fValue = (ulService >= SERVICE_SRV);
                    break;
            }
            propVarValue.vt = VT_UI1;
            propVarValue.bVal = (UCHAR)fValue;
            break;
        }

        default:
            //
            // We cannot guess the value. Return.
            //
            return;
    }


    //
    // Put the "Guessed" value in the map
    //

    SetAt(pidW2K, propVarValue);
}

//
// CErrorCapture - used to route error messages to the screen or to 
// a buffer
//         
class CErrorCapture : public CString
{
public:
    CErrorCapture()
    {
        m_pstrOldErrorBuffer = 0;
        SetErrorBuffer(&m_pstrOldErrorBuffer, this);
    }
    ~CErrorCapture()
    {
        SetErrorBuffer(&m_pstrOldErrorBuffer, 0);
    }
    static DisplayError(CString &csPrompt, 
                          UINT nType = MB_OK | MB_ICONERROR, 
                          UINT nIDHelp = 0)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        if (ms_pstrCurrentErrorBuffer == 0)
        {
            return AfxMessageBox(csPrompt, nType, nIDHelp);
        }
        *ms_pstrCurrentErrorBuffer = csPrompt;
        return IDOK;
    }

private:
    static CString *ms_pstrCurrentErrorBuffer /* = 0 */;
    static void SetErrorBuffer(CString **pstrOldErrorBuffer, CString *pstrErrorBuffer)
    {
        if (pstrErrorBuffer != 0)
        {
            //
            // Push error buffer
            //
            *pstrOldErrorBuffer = ms_pstrCurrentErrorBuffer;
            ms_pstrCurrentErrorBuffer = pstrErrorBuffer;
        }
        else
        {
            //
            // Pop Error puffer
            //
            ms_pstrCurrentErrorBuffer = *pstrOldErrorBuffer;
        }
    }
    CString *m_pstrOldErrorBuffer;

};
 

class CMqPropertyPage;

class CGeneralPropertySheet : public CPropertySheetEx
{
public:
	CGeneralPropertySheet(CMqPropertyPage* pPropertyPage);
	~CGeneralPropertySheet(){};

	BOOL SetWizardButtons();

protected:
	void initHtmlHelpString(){};
	static HBITMAP GetHbmHeader(){};
	static HBITMAP GetHbmWatermark(){};

private:
	CGeneralPropertySheet(const CGeneralPropertySheet&);
	CGeneralPropertySheet& operator=(const CGeneralPropertySheet&);

};

inline
CGeneralPropertySheet::CGeneralPropertySheet(
	CMqPropertyPage* pPropertyPage
	) : CPropertySheetEx(L"New")
{
	AddPage(reinterpret_cast<CPropertyPageEx*>(pPropertyPage));

	//
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

extern CString s_finishTxt;

inline 
CGeneralPropertySheet::SetWizardButtons()
{
    CPropertySheetEx::SetWizardButtons(PSWIZB_FINISH);
	
	s_finishTxt.LoadString(IDS_OK);
	SetFinishText(s_finishTxt);

    return TRUE;
}

                                                                       
//
// Constants
//
const TCHAR x_tstrDigitsAndWhiteChars[] = TEXT("0123456789\n\t\b");
const DWORD x_dwMaxGuidLength = 40;

void MoveSelected(CListBox* plbSource, CListBox* plbDest);

//
// NOTE: Don't implement DestructElements. SiteGate use a double map with
//       double pointing. on the class destruction the RemoveAll for the maps
//       is called, but for the second map the keys and the values are not
//       valid anymore.
//
BOOL AFXAPI CompareElements(const LPCWSTR* MapName1, const LPCWSTR* MapName2);
UINT AFXAPI HashKey(LPCWSTR key);

void DDV_NotEmpty(CDataExchange* pDX, CString& str, UINT uiErrorMessage);

extern void AFXAPI DestructElements(PROPVARIANT *pElements, int nCount);

int CompareVariants(PROPVARIANT *propvar1, PROPVARIANT *propvar2);

//
// "Object" property page DS UUID
// 6dfe6488-a212-11d0-bcd5-00c04fd8d5b6
//
const GUID x_ObjectPropertyPageClass = 
  { 0x6dfe6488, 0xa212, 0x11d0, { 0xbc, 0xd5, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xb6 } };

//
// "Member Of" property page DSPropertyPages.MemberShip
// 0x6dfe648a-a212-11d0-bcd5-00c04fd8d5b6
//
const GUID x_MemberOfPropertyPageClass =
    { 0x6dfe648a,0xa212,0x11d0,{ 0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6} };


const GUID CQueueExtDatatGUID_NODETYPE = 
   { 0x9a0dc343, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } };

//
// DS Snapin CLSID - {E355E538-1C2E-11d0-8C37-00C04FD8FE93}
//
const CLSID CLSID_DSSnapin = { 0xe355e538, 0x1c2e, 0x11d0, { 0x8c, 0x37, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0x93 } };

//
// Find Window CLSID - {FE1290F0-CFBD-11CF-A330-00AA00C16E65}
//
const CLSID CLSID_FindWindow = { 0xfe1290f0, 0xcfbd, 0x11cf, { 0xa3, 0x30, 0x00, 0xaa, 0x00, 0xc1, 0x6e, 0x65 } };

const DWORD x_CnPrefixLen = sizeof(L"CN=")/sizeof(WCHAR) - 1;
const DWORD x_LdapPrefixLen = sizeof(L"LDAP://")/sizeof(WCHAR) - 1;

const WCHAR x_CnPrefix[] = L"CN=";
const WCHAR x_wstrLdapPrefix[] = L"LDAP://";

const WCHAR x_wstrDN[] = L"distinguishedName";
const WCHAR x_wstrAliasFormatName[] = L"mSMQ-Recipient-FormatName";
const WCHAR x_wstrDescription[] = L"description";

const WCHAR x_wstrAliasClass[] = L"mSMQ-Custom-Recipient";

struct CColumnDisplay
{
    DWORD m_columnNameId;
    int m_width;
};

//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
	void
	);

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	);


BOOL
GetContainerPathAsDisplayString(
	BSTR bstrContainerCNFormat,
	CString* pContainerDispFormat
	);

void
DDV_ValidFormatName(
	CDataExchange* pDX,
	CString& str
	);

void
SetScrollSizeForList(
	CListBox* pListBox
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\globals.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   globals.cpp

Abstract:

   Implementation of various utility routines

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "mqutil.h"
#include "resource.h"
#include "globals.h"
#include "tr.h"
#include "Fn.h"
#include "Ntdsapi.h"
#include "mqcast.h"

#include "globals.tmh"

const TraceIdEntry Globals = L"GLOBALS";

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CALLBACK SortByString(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){ return 1;}
int CALLBACK SortByULONG(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){return 1;}
int CALLBACK SortByINT(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){return 1;}
int CALLBACK SortByCreateTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){return 1;}
int CALLBACK SortByModifyTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){return 1;}


//
// Declaration of Propvariant Handlers
//
VTUI1Handler        g_VTUI1;
VTUI2Handler        g_VTUI2;
VTUI4Handler        g_VTUI4;
VTLPWSTRHandler     g_VTLPWSTR;
VTCLSIDHandler      g_VTCLSID;
VTVectUI1Handler    g_VectUI1;
VTVectLPWSTRHandler g_VectLPWSTR;
//
// Global default column width
//
int g_dwGlobalWidth = 150;

//
// Static text
//
CString s_finishTxt;

//
// static functions
//
static BOOL MQErrorToString(CString &str, HRESULT err);

//
// CErrorCapture
//
CString *CErrorCapture::ms_pstrCurrentErrorBuffer = 0;


extern HMODULE	    g_hResourceMod;


LPWSTR newwcs(LPCWSTR p)
{
    if(p == 0)
        return 0;

    LPWSTR dup = new WCHAR[wcslen(p) + 1];
    return wcscpy(dup, p);
}


/*====================================================

EnumToString

Scans a list of EnumItems, and return in <str> the
string corresponding to a value <dwVal>

=====================================================*/
void EnumToString(DWORD dwVal, EnumItem * pEnumList, DWORD dwListSize, CString & str)
{
    DWORD i=0;

    for(i = 0; i < dwListSize; i++)
    {
        if(pEnumList->val == dwVal)
        {
              str.LoadString(pEnumList->StringId);
              return;
        }
        pEnumList++;
    }


    //
    // Value not found
    //
    str.LoadString(IDS_UNKNOWN);
}


/*====================================================

TimeToString

Gets a PROPVARIANT datevalue, and return it as a string

=====================================================*/
void CALLBACK TimeToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);

	//
	// If time is not set, do not display it.
	// Converting time that is not set will show dd/mm/1970 date
	//
    if ( pPropVar->ulVal == 0 )
	{
		str = L"";
		return;
	}

	BOOL fShort = 0;
    TCHAR bufDate[128], bufTime[128];
    SYSTEMTIME sysTime;
	DWORD dwDateFormat;
	DWORD dwTimeFormat;
    CTime time(pPropVar->ulVal);

    sysTime.wYear = (WORD)time.GetYear();
    sysTime.wMonth = (WORD)time.GetMonth();
    sysTime.wDayOfWeek = (WORD)time.GetDayOfWeek();
    sysTime.wDay = (WORD)time.GetDay();
    sysTime.wHour = (WORD)time.GetHour();
    sysTime.wMinute = (WORD)time.GetMinute();
    sysTime.wSecond = (WORD)time.GetSecond();
    sysTime.wMilliseconds = 0;

   if(fShort)
   {
      dwDateFormat = DATE_SHORTDATE;
      dwTimeFormat = TIME_NOSECONDS;
   }
   else
   {
      dwDateFormat = DATE_LONGDATE;
      dwTimeFormat = 0;
   }

    GetDateFormat(
        LOCALE_USER_DEFAULT,
        dwDateFormat,   // flags specifying function options
        &sysTime,       // date to be formatted
        0,              // date format string - zero means default for locale
        bufDate,        // buffer for storing formatted string
        TABLE_SIZE(bufDate) // size of buffer
        );

    GetTimeFormat(
        LOCALE_USER_DEFAULT,
        dwTimeFormat,   // flags specifying function options
        &sysTime,       // date to be formatted
        0,              // time format string - zero means default for locale
        bufTime,        // buffer for storing formatted string
        TABLE_SIZE(bufTime) // size of buffer
        );

    str = bufDate;
    str += " ";
    str += bufTime;

}


/*====================================================

BoolToString

Gets a PROPVARIANT boolean, and return a Yes/No string
accordingly

=====================================================*/
void CALLBACK BoolToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI1);


   str.LoadString(pPropVar->bVal ? IDS_YES: IDS_NO);

}

/*====================================================

QuotaToString

Gets a PROPVARIANT qouta, returns a number or "Infinite"

=====================================================*/
void CALLBACK QuotaToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI4);
   if (pPropVar->ulVal == INFINITE)
   {
       str.LoadString(IDS_INFINITE_QUOTA);
   }
   else
   {
       str.Format(TEXT("%d"), pPropVar->ulVal);
   }
}


/*====================================================

ItemDisplay

Gets an ItemDisplay entry, and call the appropriate
display function.
=====================================================*/
void ItemDisplay(PropertyDisplayItem * pItem,PROPVARIANT * pPropVar, CString & szTmp)
{

    VTHandler * pvth = pItem->pvth;

    if(pItem->pfnDisplay == NULL)
    {
		//
		// Special treatment for VT_NULL
		//
		if(pPropVar->vt == VT_NULL)
		{
			szTmp = L"";
			return;
		}

        //
        // If no function defined, call the Propvariant handler
        //
        pvth->Display(pPropVar, szTmp);
    }
    else
    {
        //
        // Call the function defined
        //
        (pItem->pfnDisplay)(pPropVar, szTmp);
    }

}

/*====================================================

GetPropertyString

Given a property ID, and a array of Property display item,
returns a string of the property value
=====================================================*/
void GetPropertyString(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString & strResult)
{
    //
    // Scan the list
    //
    while(pItem->itemPid != 0)
    {
        if(pItem->itemPid == pid)
        {
            //
            // Property ID match, call the display function
            //
            ItemDisplay(pItem, pPropVar, strResult);
            return;
        }

        pItem++;
        pPropVar++;
    }

    ASSERT(0);

    return;


}

/*====================================================

GetProperyVar

Given a property ID, and a array of Property display item,
returns a the variant of the property value
=====================================================*/
void GetPropertyVar(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, PROPVARIANT ** ppResult)
{
    ASSERT(ppResult != NULL);
    ASSERT(pPropVar != NULL);
    //
    // Scan the list
    //
    while(pItem->itemPid != 0)
    {
        if(pItem->itemPid == pid)
        {
            //
            // Property ID match
            //
            *ppResult = pPropVar;
            return;
        }

        pItem++;
        pPropVar++;
    }

    ASSERT(0);

    return;


}


HRESULT ExtractDCFromLdapPath(CString &strName, LPCWSTR lpcwstrLdapName)
{
	//
	// Format of name: LDAP://servername.domain.com/CN=Name1,CN=Name2,...
	//
	const WCHAR x_wcFirstStr[] = L"://";

	UINT iSrc = numeric_cast<UINT>(wcscspn(lpcwstrLdapName, x_wcFirstStr));

    if (0 == lpcwstrLdapName[iSrc])
    {
		ASSERT(("did not find :// str in lpcwstrLdapName", 0));
        strName.ReleaseBuffer();
        return E_UNEXPECTED;
    }

	iSrc += numeric_cast<UINT>(wcslen(x_wcFirstStr));

	const WCHAR x_wcLastChar = L'/';
	int iDst=0;

    LPWSTR lpwstrNamePointer = strName.GetBuffer(numeric_cast<UINT>(wcslen(lpcwstrLdapName)));

	for (; lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcLastChar; iSrc++)
	{
		lpwstrNamePointer[iDst++] = lpcwstrLdapName[iSrc];
	}

	if(lpcwstrLdapName[iSrc] == 0)
	{
		ASSERT(("did not find last Char	in lpcwstrLdapName", 0));
        strName.ReleaseBuffer();
        return E_UNEXPECTED;
	}

	lpwstrNamePointer[iDst] = 0;

    strName.ReleaseBuffer();

	return S_OK;
}


/*====================================================

LDAPNameToQueueName

Translate an LDAP object name to a MSMQ queue name
This function allocates the memory which has to be freed by the caller
=====================================================*/

HRESULT ExtractComputerMsmqPathNameFromLdapName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=msmq,CN=computername,CN=...
   //
    return ExtractNameFromLdapName(strComputerMsmqName, lpcwstrLdapName, 2);
}

HRESULT ExtractComputerMsmqPathNameFromLdapQueueName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=QueueName,CN=msmq,CN=computername,CN=...
   //
    return ExtractNameFromLdapName(strComputerMsmqName, lpcwstrLdapName, 3);
}

HRESULT ExtractQueuePathNameFromLdapName(CString &strQueuePathName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=QueueName,CN=msmq,CN=computername,CN=...
   //
    CString strQueueName, strLdapQueueName, strComputerName;
    HRESULT hr;
    hr = ExtractComputerMsmqPathNameFromLdapQueueName(strComputerName, lpcwstrLdapName);
    if FAILED(hr)
    {
        return hr;
    }

    hr = ExtractNameFromLdapName(strLdapQueueName, lpcwstrLdapName, 1);
    if FAILED(hr)
    {
        return hr;
    }

    //
    // Remove all '\' from the queue name
    //
    strQueueName.Empty();
    for (int i=0; i<strLdapQueueName.GetLength(); i++)
    {
        if (strLdapQueueName[i] != '\\')
        {
            strQueueName+=strLdapQueueName[i];
        }
    }

    strQueuePathName.GetBuffer(strComputerName.GetLength() + strQueueName.GetLength() + 1);

    strQueuePathName = strComputerName + TEXT("\\") + strQueueName;

    strQueuePathName.ReleaseBuffer();

    return S_OK;
}

HRESULT ExtractLinkPathNameFromLdapName(
    CString& SiteLinkName,
    LPCWSTR lpwstrLdapPath
    )
{
    HRESULT hr;

    hr = ExtractNameFromLdapName(SiteLinkName, lpwstrLdapPath, 1);
    return hr;
}

HRESULT ExtractAliasPathNameFromLdapName(
    CString& AliasPathName,
    LPCWSTR lpwstrLdapPath
    )
{
    HRESULT hr;

    hr = ExtractNameFromLdapName(AliasPathName, lpwstrLdapPath, 1);
    return hr;
}

HRESULT ExtractNameFromLdapName(CString &strName, LPCWSTR lpcwstrLdapName, DWORD dwIndex)
{
    ASSERT(dwIndex >= 1);

   //
   // Format of name: LDAP://CN=Name1,CN=Name2,...
   //
   const WCHAR x_wcFirstChar=L'=';

   const WCHAR x_wcLastChar=L',';

   BOOL fCopy = FALSE;
   int iSrc=0, iDst=0;

    LPWSTR lpwstrNamePointer = strName.GetBuffer(numeric_cast<UINT>(wcslen(lpcwstrLdapName)));

    //
    // Go to the dwIndex appearance of the first char
    //
    for (DWORD dwAppearance=0; dwAppearance < dwIndex; dwAppearance++)
    {
        while(lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcFirstChar)
        {
            //
            // skip escape characters (composed of '\' + character)
            //
            if (lpcwstrLdapName[iSrc] == L'\\')
            {
                iSrc++;
                if (lpcwstrLdapName[iSrc] != 0)
                {
                    iSrc++;
                }
            }
            else
            {
                //
                // Skip one character
                //
                iSrc++;
            }
        }

        if (0 == lpcwstrLdapName[iSrc])
        {
            strName.ReleaseBuffer();
            return E_UNEXPECTED;
        }
        iSrc++;
    }

   for (; lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcLastChar; iSrc++)
   {
      lpwstrNamePointer[iDst++] = lpcwstrLdapName[iSrc];
   }

   lpwstrNamePointer[iDst] = 0;

    strName.ReleaseBuffer();

   return S_OK;
}


HRESULT ExtractQueueNameFromQueuePathName(CString &strQueueName, LPCWSTR lpcwstrQueuePathName)
{
    //
    // Get the name only out of the pathname
    //
    strQueueName = lpcwstrQueuePathName;

    int iLastSlash = strQueueName.ReverseFind(L'\\');
    if (iLastSlash != -1)
    {
        strQueueName = strQueueName.Right(strQueueName.GetLength() - iLastSlash - 1);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++
ExtractQueuePathNamesFromDataObject
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractQueuePathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    )
{
    return( ExtractPathNamesFromDataObject(
                pDataObject,
                astrQNames,
                astrLdapNames,
                FALSE   //fExtractAlsoComputerMsmqObjects
                ));
}

//////////////////////////////////////////////////////////////////////////////
/*++
ExtractQueuePathNamesFromDSNames
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractQueuePathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    )
{
    return( ExtractPathNamesFromDSNames(
                pDSObj,
                astrQNames,
                astrLdapNames,
                FALSE       // fExtractAlsoComputerMsmqObjects
                ));
}


//////////////////////////////////////////////////////////////////////////////
/*++

QueuePathnameToName

	Translates a pathname to a short name (display function for PropertyDisplayItem)

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK QueuePathnameToName(const PROPVARIANT *pPropVar, CString &str)
{
	if(pPropVar->vt != VT_LPWSTR)
	{
		str = L"";
		return;
	}

    ExtractQueueNameFromQueuePathName(str, pPropVar->pwszVal);

	return;
}


/*==============================================================

MessageDSError

  This function displays a DS error:
    Can not <operation> <object>.\n<error description>.
    "Can not %1 %2.\n%3."

Return Value:

================================================================*/
int
MessageDSError(
    HRESULT rc,                     //  Error code
    UINT nIDOperation,              //  Operation string identifier,
                                    //  e.g., get premissions, delete queue, etc.
    LPCTSTR pObjectName /* = 0*/,   //  object that operation performed on
    UINT nType /* = MB_OK | MB_ICONERROR */,
    UINT nIDHelp /* = (UINT) -1*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString csErrorText;
    CString csPrompt;

    CString csOperation;
    AfxFormatString1(csOperation, nIDOperation, pObjectName);

    MQErrorToMessageString(csErrorText, rc);
    AfxFormatString2(csPrompt, IDS_DS_ERROR, csOperation, csErrorText);

    return CErrorCapture::DisplayError(csPrompt, nType, nIDHelp);
}


/*=======================================================

MQErrorToString

  Translate an MQError to a string

========================================================*/
BOOL MQErrorToString(CString &str, HRESULT err)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD rc;
    TCHAR p[512];

    //
    // For MSMQ error code, we will take the message from MQUTIL.DLL based on the full
    // HRESULT. For Win32 error codes, we get the message from the system..
    // For other error codes, we assume they are DS error codes, and get the code
    // from ACTIVEDS dll.
    //

    DWORD dwErrorCode = err;
    HMODULE hLib = 0;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;

    switch (HRESULT_FACILITY(err))
    {
        case FACILITY_MSMQ:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = g_hResourceMod;
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
            dwErrorCode = HRESULT_CODE(err);
            break;

        default:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("ACTIVEDS.DLL"));
            break;
    }

    rc = FormatMessage( dwFlags,
                        hLib,
                        err,
                        0,
                        p,
                        TABLE_SIZE(p),
                        NULL);

    if (0 != hLib && g_hResourceMod != hLib)
    {
        FreeLibrary(hLib);
    }

    if(rc != 0)
    {
        str.FormatMessage(IDS_DISPLAY_ERROR_FORMAT, p);
    }

    return(rc);
}

/*==============================================================

MQErrorToMessageString

    Will set csMessage to an error message, displayable in a message box
================================================================*/
BOOL
MQErrorToMessageString(
    CString &csErrorText,          //  Returned message
    HRESULT rc                     //  Error code
    )
{
    if(!MQErrorToString(csErrorText,rc))
    {
        csErrorText.FormatMessage(IDS_UNKNOWN_ERROR_FORMAT, rc);
        return FALSE;
    }
    return TRUE;
}


/*==============================================================

DisplayErrorAndReason

    Will set strErrorText to an error message, displayable in a message box
================================================================*/
void
DisplayErrorAndReason(
	UINT uiErrorMsgProblem,
    UINT uiErrorMsgReason,
	CString strObject,
	HRESULT errorCode
	)
{
	CString strErrorProblem, strErrorReason;
    
	if ( strObject == L"" )
	{
		strErrorProblem.LoadString(uiErrorMsgProblem);
	}
	else
	{
		strErrorProblem.FormatMessage(uiErrorMsgProblem, strObject);
	}

	strErrorReason.LoadString(uiErrorMsgReason);
	strErrorProblem += (L"\n" + strErrorReason);

	if ( errorCode != 0 )
	{
		CString strErrorCode;
		strErrorCode.FormatMessage(IDS_ERROR_DW_FORMAT, errorCode);
		strErrorProblem += strErrorCode;
	}

	CErrorCapture::DisplayError(strErrorProblem, MB_OK | MB_ICONERROR, static_cast<UINT>(-1));
}


/*==============================================================

DisplayErrorFromCOM

    Will set strErrorText to an error message, displayable in a message box
================================================================*/
void
DisplayErrorFromCOM(
	UINT uiErrorMsg,
	const _com_error& e
	)
{
	WCHAR strDesc[256];
	wcscpy(strDesc, e.Description());		

	CString strError;
	strError.FormatMessage(uiErrorMsg, strDesc);

	AfxMessageBox(strError, MB_OK | MB_ICONERROR);
}


/*===================================================*
 *
 * DDX functions
 *
 *===================================================*/
//
// DDX function for numbers. When the number is INFINITE, the check box
// is not checked.
// (Good for queue qouta, for example)
//
void AFXAPI DDX_NumberOrInfinite(CDataExchange* pDX, int nIDCEdit, int nIDCCheck, DWORD& dwNumber)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HWND hWndCheck = pDX->PrepareCtrl(nIDCCheck);
    HWND hWndEdit = pDX->PrepareEditCtrl(nIDCEdit);

    if (pDX->m_bSaveAndValidate)
    {
        BOOL_PTR fChecked = SendMessage(hWndCheck, BM_GETCHECK, 0 ,0);
        if (!fChecked)
        {
            dwNumber = INFINITE;
        }
        else
        {
            //
            // Avoid negatives - MFC just translate them to positive
            // 2's complement numbers. We want to avoid this
            //
            int nLen = ::GetWindowTextLength(hWndEdit);
            CString strTemp;

            GetWindowText(hWndEdit, strTemp.GetBufferSetLength(nLen), nLen+1);
            strTemp.ReleaseBuffer();

            if (!(strTemp.SpanExcluding(x_tstrDigitsAndWhiteChars)).IsEmpty())
            {
                AfxMessageBox(AFX_IDP_PARSE_UINT);
                pDX->Fail();
            }

            DDX_Text(pDX, nIDCEdit, dwNumber);
            //
            // If number was out of range, DDX_Text returns Infinite
            //
            if (INFINITE == dwNumber)
            {
	            TCHAR szMax[32];
	            wsprintf(szMax, TEXT("%lu"), INFINITE-1);

	            CString prompt;
	            AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, TEXT("0"), szMax);
	            AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
	            prompt.Empty(); // exception prep
	            pDX->Fail();
            }
        }
    }
    else
    {
        if (INFINITE == dwNumber)
        {
            //
            // Note: The caller must handle BN_CLICKED to re-enable the edit box
            //
            SendMessage(hWndCheck, BM_SETCHECK, FALSE ,0);
            EnableWindow(hWndEdit, FALSE);
        }
        else
        {
            SendMessage(hWndCheck, BM_SETCHECK, TRUE ,0);
            DDX_Text(pDX, nIDCEdit, dwNumber);
        }
    }
}

void OnNumberOrInfiniteCheck(CWnd *pwnd, int idEdit, int idCheck)
{
    CEdit *pEdit = (CEdit*)pwnd->GetDlgItem(idEdit);
    CButton *pCheck = (CButton*)pwnd->GetDlgItem(idCheck);
    BOOL fChecked = pCheck->GetCheck();

    pEdit->EnableWindow(fChecked);
}


//------------- DDX_TEXT (for GUID) ---------------------------
// This function compliment the standard DDX_ function set, and
// used to exchange a a GUID property with an edit box
// in DoDataExchange.

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& guid)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);

    if (pDX->m_bSaveAndValidate)
    {
        int nLen = ::GetWindowTextLength(hWndCtrl);
        CString strTemp;

        ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
        strTemp.ReleaseBuffer();

        if (IIDFromString((LPTSTR)((LPCTSTR)strTemp), &guid))   // throws exception
        {
            //
            // Can't convert string to guid
            //
            CString strMessage;
            strMessage.LoadString(IDE_INVALIDGUID);

            AfxMessageBox(strMessage);
            pDX->Fail();    // throws exception
        }
    }
    else
    {
        TCHAR szTemp[x_dwMaxGuidLength];
        StringFromGUID2(guid, szTemp, TABLE_SIZE(szTemp));
        ::SetWindowText(hWndCtrl, szTemp);
    }
}


/*====================================================
MqsnapCreateQueue
Creates a queue given a set of parameters and a list of properties IDs. The list must
contain some or all of PROPID_Q_PATHNAME, PROPID_Q_LABEL, PROPID_Q_TRANSACTION and
PROPID_Q_TYPE. Parameters that do not have a corresponding property ID in the list are
ignored.

Arguments:

Return Value:

=====================================================*/
HRESULT MqsnapCreateQueue(CString& strPathName, BOOL fTransactional,
                       CString& strLabel, GUID* pTypeGuid,
                       PROPID aProp[], UINT cProp,
                       CString *pStrFormatName /* = 0 */)
{
#define MAX_EXPCQ_PROPS 10

    ASSERT(cProp <= MAX_EXPCQ_PROPS);

    PROPVARIANT apVar[MAX_EXPCQ_PROPS];
    HRESULT hr = MQ_OK, hr1 = MQ_OK;
    UINT iProp;

    for (iProp = 0; iProp<cProp; iProp++)
    {
        switch (aProp[iProp])
        {
            case PROPID_Q_PATHNAME:
                apVar[iProp].vt = VT_LPWSTR;

                apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(strPathName);
                break;

            case PROPID_Q_LABEL:
                apVar[iProp].vt = VT_LPWSTR;
                apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(strLabel);
                break;

            case PROPID_Q_TYPE:
                apVar[iProp].vt = VT_CLSID;
                apVar[iProp].puuid = pTypeGuid;
                break;

            case PROPID_Q_TRANSACTION:
                apVar[iProp].vt = VT_UI1;
                apVar[iProp].bVal = (UCHAR)fTransactional;
                break;

            default:
                ASSERT(0);
                break;
        }

    }

    MQQUEUEPROPS mqp = {cProp, aProp, apVar, 0};

    DWORD dwFormatLen;
    if (0 != pStrFormatName)
    {
        dwFormatLen = MAX_QUEUE_FORMATNAME;
        hr = MQCreateQueue(0, &mqp, pStrFormatName->GetBuffer(MAX_QUEUE_FORMATNAME), &dwFormatLen);
        pStrFormatName->ReleaseBuffer();
    }
    else
    {
        dwFormatLen=0;
        if ((hr1 = MQCreateQueue(0, &mqp, 0, &dwFormatLen)) != MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL)
           hr = hr1;
    }

    return hr;
}

/*====================================================
CreateEmptyQueue


Arguments:

Return Value:

=====================================================*/
HRESULT CreateEmptyQueue(CString &csDSName,
                         BOOL fTransactional, CString &csMachineName, CString &csPathName,
                         CString *pStrFormatName /* = 0 */)
{
    PROPID  aProp[] = {PROPID_Q_PATHNAME,
                       PROPID_Q_LABEL,
                       PROPID_Q_TRANSACTION
                       };

    csPathName.Format(TEXT("%s\\%s"), csMachineName, csDSName);

    HRESULT hr =  MqsnapCreateQueue(csPathName, fTransactional, csDSName, 0,
                                    aProp, sizeof(aProp) / sizeof(aProp[0]), pStrFormatName);
    if (hr != MQ_ERROR_INVALID_OWNER)
    {
        //
        // Either success or real error. Return.
        //
        return hr;
    }

    CString csNetBiosName;
    if (!GetNetbiosName(csMachineName, csNetBiosName))
    {
        //
        // Already a netbios name. No need to proceed
        //
        return hr;
    }

    //
    // This may be an NT4 server, and we may be using a full DNS name. Try again with
    // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
    //
    csPathName.Format(TEXT("%s\\%s"), csNetBiosName, csDSName);

    return MqsnapCreateQueue(csPathName, fTransactional, csDSName, 0,
                             aProp, sizeof(aProp) / sizeof(aProp[0]), pStrFormatName);
}

/*====================================================
CreateTypedQueue
  ( for report and test queues )

Arguments:

Return Value:

=====================================================*/

HRESULT CreateTypedQueue(CString& strPathname, CString& strLabel, GUID& TypeGuid)
{
    PROPID  aProp[] = {PROPID_Q_PATHNAME,
                       PROPID_Q_LABEL,
                       PROPID_Q_TYPE,
                       };

    return MqsnapCreateQueue(strPathname, FALSE, strLabel, &TypeGuid,
                          aProp, sizeof(aProp) / sizeof(aProp[0]));
}


/*==============================================================

CaubToString

  This function converts a CAUI1 buffer to a string displayable in the
  right hand side of an hex editor (every byte is a character, control characters
  are replaced by '.')
Arguments:

Return Value:

================================================================*/
void CaubToString(const CAUB* pcaub, CString& strResult)
{
    LPTSTR pstr = strResult.GetBuffer(pcaub->cElems);
    for (DWORD i=0; i<pcaub->cElems; i++)
    {
        //
        // Replace control characters with "."
        //
        if (pcaub->pElems[i]>=32)
        {
            pstr[i] = pcaub->pElems[i];
        }
        else
        {
            pstr[i] = L'.';
        }
    }
    strResult.ReleaseBuffer();
}

/*==============================================================

MoveSelected

  This function moves all the selected items from one list box to another.
  (Usefull for implementation of Add/Remove buttons)

Arguments:
  plbSource - pointer to source list box from which the selected item
              should be moved to the destination list box

  plbDest - pointer to the destination list box

Return Value:

================================================================*/
void
MoveSelected(
    CListBox* plbSource,
    CListBox* plbDest
    )
{
    try
    {
        int nTotalItems = plbSource->GetCount();
        AP<int> piRgIndex = new int[nTotalItems];
        int nSel =  plbSource->GetSelItems(nTotalItems, piRgIndex );
        int i;

        for (i=0; i<nSel; i++)
        {
            CString strItem;
            plbSource->GetText(piRgIndex[i], strItem);

            DWORD_PTR dwItemData = plbSource->GetItemData(piRgIndex[i]);

            int iDestIndex = plbDest->AddString(strItem);
            plbDest->SetItemData(iDestIndex, dwItemData);
        }

        for (i=0; i<nSel; i++)
        {
            plbSource->DeleteString(piRgIndex[i]-i);
        }
    }
    catch (CException &e)
    {
        DBGMSG((DBGMOD_EXPLORER, DBGLVL_ERROR, L"Exception  2 in MoveSelected"));
        e.ReportError();
    }
}

//
// Helper routine for handling LPWSTR map
//
BOOL
AFXAPI
CompareElements(
    const LPCWSTR* MapName1,
    const LPCWSTR* MapName2
    )
{
    return (wcscmp(*MapName1, *MapName2) == 0);
}


UINT
AFXAPI
HashKey(
    LPCWSTR key
    )
{
    UINT nHash = 0;
    while (*key)
    {
        nHash = (nHash<<5) + nHash + *key++;
    }

    return nHash;
}


/*==============================================================
DDV_NotEmpty

    The routine checks that the input is not empty

Arguments:
    pDX - pointer to Data exchange
    str - pointer to the selected string
    uiErrorMessage - Error message if the validation fails

Returned Value:
    None.

================================================================*/
void DDV_NotEmpty(
    CDataExchange* pDX,
    CString& str,
    UINT uiErrorMessage
    )
{
    if (pDX->m_bSaveAndValidate)
    {
        if (str.IsEmpty())
        {
            AfxMessageBox(uiErrorMessage);
            pDX->Fail();
        }
    }
}

//
// String comparison function for sorting queue nqmes
//
int __cdecl QSortCompareQueues( const void *arg1, const void *arg2 )
{
   /* Compare all of both strings: */
   return _wcsicmp( * (WCHAR ** ) arg1, * (WCHAR ** ) arg2 );
}


void AFXAPI DestructElements(PROPVARIANT *pElements, int nCount)
{
    DWORD i,j;
    for (i=0; i<(DWORD)nCount; i++)
    {
        switch(pElements[i].vt)
        {
            case VT_CLSID:
                MQFreeMemory(pElements[i].puuid);
                break;

            case VT_LPWSTR:
                MQFreeMemory(pElements[i].pwszVal);
                break;

            case VT_BLOB:
                MQFreeMemory(pElements[i].blob.pBlobData);
                break;

            case (VT_VECTOR | VT_CLSID):
                MQFreeMemory(pElements[i].cauuid.pElems);
                break;

            case (VT_VECTOR | VT_LPWSTR):
                for(j = 0; j < pElements[i].calpwstr.cElems; j++)
                {
                    MQFreeMemory(pElements[i].calpwstr.pElems[j]);
                }
                MQFreeMemory(pElements[i].calpwstr.pElems);
                break;

            case (VT_VECTOR | VT_VARIANT):
                DestructElements((PROPVARIANT*)pElements[i].capropvar.pElems, pElements[i].capropvar.cElems);
                MQFreeMemory(pElements[i].calpwstr.pElems);
                break;
            default:
                break;
        }

        pElements[i].vt = VT_EMPTY;
    }
}

//
// CompareVariants - compare two variants
//
#define _COMPAREVARFIELD(field) (propvar1->field == propvar2->field ?  0 : \
                                    propvar1->field > propvar2->field ? 1 : -1)

int CompareVariants(PROPVARIANT *propvar1, PROPVARIANT *propvar2)
{
    if (propvar1->vt != propvar2->vt)
    {
        //
        // Can't compare. Consider them equal
        //
        return 0;
    }

    char *pChar1, *pChar2;
    size_t nChar1, nChar2;
    switch (propvar1->vt)
    {
        case VT_UI1:
            return _COMPAREVARFIELD(bVal);

        case VT_UI2:
        case VT_I2:
            return _COMPAREVARFIELD(iVal);

        case VT_UI4:
        case VT_I4:
            return _COMPAREVARFIELD(lVal);

        case VT_CLSID:
        {
            for (int i = 0; i < sizeof(GUID); i++)
            {
                if (((BYTE*)propvar1->puuid)[i] > ((BYTE*)propvar2->puuid)[i])
                {
                    return 1;
                }
                else if (((BYTE*)propvar1->puuid)[i] < ((BYTE*)propvar2->puuid)[i])
                {
                    return -1;
                }
            }

            return 0;
        }

        case VT_LPWSTR:
        {
            int nCompResult = CompareString(0,0, propvar1->pwszVal, -1, propvar2->pwszVal, -1);
            switch(nCompResult)
            {
                case CSTR_LESS_THAN:
                    return -1;

                case CSTR_EQUAL:
                    return 0;

                case CSTR_GREATER_THAN:
                    return 1;
            }
        }

        case VT_BLOB:
            pChar1 = (char *)propvar1->blob.pBlobData;
            pChar2 = (char *)propvar2->blob.pBlobData;
            nChar1 = propvar1->blob.cbSize;
            nChar2 = propvar2->blob.cbSize;
            //
            // Fall through
            //
        case (VT_VECTOR | VT_UI1):
            if (propvar1->vt == (VT_VECTOR | VT_UI1)) // not fallen through
            {
                pChar1 = (char *)propvar1->caub.pElems;
                pChar2 = (char *)propvar2->caub.pElems;
                nChar1 = propvar1->caub.cElems;
                nChar2 = propvar2->caub.cElems;
            }
            {
                int iResult = memcmp(pChar1, pChar2, min (nChar1, nChar2));
                if (iResult == 0)
                {
                    if (nChar1 > nChar2)
                    {
                        return 1;
                    }
                    else if (nChar2 > nChar1)
                    {
                        return -1;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return iResult;
                }
            }

        case (VT_VECTOR | VT_CLSID):
        case (VT_VECTOR | VT_LPWSTR):
        case (VT_VECTOR | VT_VARIANT):
        default:
            //
            // can't compare these types - consider them equal
            //
            return 0;
    }
}
#undef _COMPAREVARFIELD

/*==============================================================
InsertColumnsFromDisplayList

This routine inserts columns into header using a display list.
It should be called from InsertColumns functions of classes derived from
CSnapinNode.
================================================================*/

HRESULT   InsertColumnsFromDisplayList(IHeaderCtrl* pHeaderCtrl,
                                       PropertyDisplayItem *aDisplayList)
{
    DWORD i = 0;
    DWORD dwColId = 0;
    while(aDisplayList[i].itemPid != 0)
    {
        if (aDisplayList[i].uiStringID != NO_TITLE)
        {
            CString title;
            title.LoadString(aDisplayList[i].uiStringID);

            pHeaderCtrl->InsertColumn(dwColId, title, LVCFMT_LEFT,aDisplayList[i].iWidth);
            dwColId++;
        }
        i++;
    }

    return(S_OK);
}


//
// GetDsServer - returns the current DS Server
//
HRESULT GetDsServer(CString &strDsServer)
{
    MQMGMTPROPS	  mqProps;
    PROPID  propIdDsServ = PROPID_MGMT_MSMQ_DSSERVER;
    PROPVARIANT propVarDsServ;
    propVarDsServ.vt = VT_NULL;

	mqProps.cProp = 1;
	mqProps.aPropID = &propIdDsServ;
	mqProps.aPropVar = &propVarDsServ;
	mqProps.aStatus = NULL;

    HRESULT hr = MQMgmtGetInfo(0, MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
       return(hr);
    }

	ASSERT(propVarDsServ.vt == (VT_LPWSTR));

    strDsServer = propVarDsServ.pwszVal;
    MQFreeMemory(propVarDsServ.pwszVal);

    return S_OK;
}

//
// GetComputerNameIntoString - Puts the local computer name in a string
//
HRESULT GetComputerNameIntoString(CString &strComputerName)
{
    const DWORD x_dwComputerNameLen = 256;
    DWORD dwComputerNameLen = x_dwComputerNameLen;

    HRESULT hr = GetComputerNameInternal(strComputerName.GetBuffer(dwComputerNameLen), &dwComputerNameLen);
    strComputerName.ReleaseBuffer();

    return hr;
}

//
// GetSiteForeignFlag - retrieves a site's foreign flag from the DS
//
HRESULT
GetSiteForeignFlag(
    const GUID* pSiteId,
    BOOL *fForeign,
	const CString& strDomainController
    )
{
    //
    // By default (and in case of error) return FALSE
    //
    *fForeign = FALSE;
    //
    // Get the site foreign flag
    //
    PROPID pid = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;
   
    HRESULT hr = ADGetObjectPropertiesGuid(
                    eSITE,
                    GetDomainController(strDomainController),
					true,	// fServerName
                    pSiteId,
                    1,
                    &pid,
                    &var
                    );
    if (FAILED(hr))
    {
        if (MQ_ERROR == hr)
        {
            //
            // In this case, we assume we are working against NT4 server.
            // There are no foreign sites in NT4, so we return FALSE in fForeign
            //
            return MQ_OK;
        }
        //
        // Another error - report error and return it.
        //
        CString strSite;
        strSite.LoadString(IDS_SITE);
        MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, strSite);
        return hr;
    }

    *fForeign = var.bVal;
    return MQ_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++
ExtractPathNamesFromDSNames
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractPathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrObjNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL    fExtractAlsoComputerMsmqObjects
    )
{
    //
    //  This routine extract queues pathnames and msmq-configuration pathnames (optional)
    //
    static const WCHAR x_strMsmqQueueClassName[] = L"mSMQQueue";
    static const WCHAR x_strMsmqClassName[] = L"mSMQConfiguration";
    for (DWORD i = 0; i < pDSObj->cItems; i++)
    {
  	    LPWSTR lpwstrLdapClass = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[i].offsetClass);
        CString strLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[i].offsetName);
        CString strObjectName;

        if (wcscmp(lpwstrLdapClass, x_strMsmqQueueClassName) == 0)
        {
            //
            // Translate (and keep in the Queue) the LDAP name to a queue name
            //
            HRESULT hr = ExtractQueuePathNameFromLdapName(strObjectName, strLdapName);
            if(FAILED(hr))
            {
                ATLTRACE(_T("ExtractPathNamesFromDataObject - Extracting queue name from LDP name %s failed\n"),
                         (LPTSTR)(LPCTSTR)strLdapName);
                return(hr);
            }
        }
        else if ( fExtractAlsoComputerMsmqObjects &&
                  wcscmp(lpwstrLdapClass, x_strMsmqClassName) == 0)
        {
            //
            // Translate  the LDAP name to a msmq object name
            //
            HRESULT hr = ExtractComputerMsmqPathNameFromLdapName(strObjectName, strLdapName);
            if(FAILED(hr))
            {
                ATLTRACE(_T("ExtractPathNamesFromDataObject - Extracting msmq configuration name from LDP name %s failed\n"),
                         (LPTSTR)(LPCTSTR)strLdapName);
                return(hr);
            }
        }
        else
        {
            //
            // We ignore any object not queues or msmq-configuration
            //
            continue;
        }


        astrObjNames.Add(strObjectName);
        astrLdapNames.Add(strLdapName);
    }

    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////
/*++
ExtractPathNamesFromDataObject
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractPathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrObjNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL                       fExtractAlsoComputerMsmqObjects
    )
{
    //
    // Get the object name from the DS snapin
    //
    LPDSOBJECTNAMES pDSObj;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    //
    // Get the LDAP name of the queue from the DS Snapin
    //
   	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);

    if(FAILED(hr))
    {
        ATLTRACE(_T("ExtractPathNamesFromDataObject::GetExtNodeObject - Get clipboard format from DS failed\n"));
        return(hr);
    }

    pDSObj = (LPDSOBJECTNAMES)stgmedium.hGlobal;

    hr = ExtractPathNamesFromDSNames(pDSObj,
                                     astrObjNames,
                                     astrLdapNames,
                                     fExtractAlsoComputerMsmqObjects
                                     );

    GlobalFree(stgmedium.hGlobal);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++
GetNetbiosName
This function gets a full DNS name and returns the Netbios name
return value - TRUE if Netbios name different than Full Dns Name
--*/
//////////////////////////////////////////////////////////////////////////////
BOOL GetNetbiosName(CString &strFullDnsName, CString &strNetbiosName)
{
    DWORD dwFirstDot = strFullDnsName.Find(L".");
    if (dwFirstDot == -1)
    {
        //
        // It is already a netbios name. Return it
        //
        strNetbiosName = strFullDnsName;
        return FALSE;
    }

    strNetbiosName = strFullDnsName.Left(dwFirstDot);
    return TRUE;
}

//
//  Temporary - until logging mechanism is decided
//  currently doesn't perform logging
//
void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
}

//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
	void
	)
{
	return NULL;
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	)
{
	return 0;
}

BOOL
GetContainerPathAsDisplayString(
	BSTR bstrContainerCNFormat,
	CString* pContainerDispFormat
	)
{
	PDS_NAME_RESULT pDsNameRes = NULL;
	DWORD dwRes = DsCrackNames(NULL,
						DS_NAME_FLAG_SYNTACTICAL_ONLY,
						DS_FQDN_1779_NAME,
						DS_CANONICAL_NAME,
						1,
						&bstrContainerCNFormat,
						&pDsNameRes
						);
	
	if (dwRes != DS_NAME_NO_ERROR)
	{
		return FALSE;
	}

	*pContainerDispFormat = pDsNameRes->rItems[0].pName;
	DsFreeNameResult(pDsNameRes);

	return TRUE;
}


void
DDV_ValidFormatName(
	CDataExchange* pDX,
	CString& str
	)
{
	if (!pDX->m_bSaveAndValidate)
		return;

	QUEUE_FORMAT qf;
	AP<WCHAR> strToFree;
	BOOL fRes = FnFormatNameToQueueFormat(str, &qf, &strToFree);

	if ( !fRes ||
		qf.GetType() == QUEUE_FORMAT_TYPE_DL ||
		qf.GetType() == QUEUE_FORMAT_TYPE_MULTICAST )
	{
        CString strNewAlias;
        strNewAlias.LoadString(IDS_ALIAS);

        MessageDSError(MQ_ERROR_ILLEGAL_FORMATNAME, IDS_OP_SET_FORMATNAME_PROPERTY, strNewAlias);
        pDX->Fail();
	}
}


void
SetScrollSizeForList(
	CListBox* pListBox
	)
{
	int dx=0;

	//
	// Find maximal string among all strings in the ListBox
	//
	CDC* pDC = pListBox->GetDC();
	
	for (int i = 0; i < pListBox->GetCount(); i++)
	{
		CString strItem;
		CSize sizeOfStr;

		pListBox->GetText( i, strItem );
		sizeOfStr = pDC->GetTextExtent(strItem);

		dx = max(dx, sizeOfStr.cx);
	}

	pListBox->ReleaseDC(pDC);

	pListBox->SetHorizontalExtent(dx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\linkdata.h ===
// linkdata.h : Declaration of the CLinkDataObject

#ifndef __LINKDATA_H_
#define __LINKDATA_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CLinkDataObject
class CLinkDataObject : 
	public CDataObject,
	public CComCoClass<CLinkDataObject, &CLSID_LinkDataObject>,
    public IDsAdminCreateObj

{
public:
    DECLARE_NOT_AGGREGATABLE(CLinkDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_LINKDATAOBJECT)

    BEGIN_COM_MAP(CLinkDataObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

public:

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateSiteGatePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    void
    InitializeLinkProperties(
        void
        );


    GUID m_FirstSiteId;
    GUID m_SecondSiteId;
    DWORD m_LinkCost;
	CString m_LinkDescription;

	CString m_strContainerDispFormat;

    static const PROPID mx_paPropid[];
};


inline 
const 
DWORD 
CLinkDataObject::GetObjectType(
    void
    )
{
    return MQDS_SITELINK;
};


inline 
const 
PROPID*
CLinkDataObject::GetPropidArray(
    void
    )
{
    return mx_paPropid;
}

#endif //__LINKDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localadm.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.cpp

Abstract:
	Implementation for the Local administration

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "rt.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "dsext.h"
#include "mqPPage.h"
#include "qname.h"

#define  INIT_ERROR_NODE
#include "snpnerr.h"
#include "lqDsply.h"
#include "localadm.h"
#include "dataobj.h"
#include "sysq.h"
#include "privadm.h"
#include "snpqueue.h"
#include "rdmsg.h"
#include "storage.h"
#include "localcrt.h"
#include "mobile.h"
#include "client.h"
#include "srvcsec.h"

#import "mqtrig.tlb" no_namespace
#include "trigadm.h"

#include "localadm.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
/*++

CPublicQueueNames
Used to supply names of public queues - either using the DS, or the cache.
The names of the queues are sorted.

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CCachedQueueNames class
//
class CCachedQueueNames : public CQueueNames
{
public:
    static HRESULT CreateInstance(CQueueNames **ppqueueNamesProducer,CString &strMachineName)
    {
        *ppqueueNamesProducer = new CCachedQueueNames();
        return (*ppqueueNamesProducer)->InitiateNewInstance(strMachineName);
    }

    virtual HRESULT GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps)
    {
        if (0 == m_calpwstrQFormatNames.pElems)
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }

        if (m_nQueue >= m_calpwstrQFormatNames.cElems)
        {
            strQueueFormatName = TEXT("");
            return S_OK;
        }

        strQueueFormatName = m_calpwstrQFormatNames.pElems[m_nQueue];
        m_nQueue++;

        //
        // We do not return the pathname when reading from cache
        //
        strQueuePathName = TEXT("");

        return GetOpenQueueProperties(m_szMachineName, strQueueFormatName, pmqQProps);
    }

protected:
    virtual HRESULT Init(CString &strMachineName)
    {       
        HRESULT hr = S_OK;
        CString strTitle;

	    MQMGMTPROPS	  mqProps;
        PROPVARIANT   propVar;

	    //
	    // Retreive the open queues of the QM
	    //
        PROPID  propId = PROPID_MGMT_MSMQ_ACTIVEQUEUES;
        propVar.vt = VT_NULL;

	    mqProps.cProp = 1;
	    mqProps.aPropID = &propId;
	    mqProps.aPropVar = &propVar;
	    mqProps.aStatus = NULL;

        hr = MQMgmtGetInfo((strMachineName == TEXT("")) ? (LPCWSTR)NULL : strMachineName, MO_MACHINE_TOKEN, &mqProps);

        if(FAILED(hr))
        {
            //
            // If failed, just display a message
            //
            MessageDSError(hr,IDS_NOCONNECTION_TO_SRVICE);
            return(hr);
        }

	    ASSERT(propVar.vt == (VT_VECTOR | VT_LPWSTR));
	    
	    //
	    // Sort the queues by their name
	    //
	    qsort(propVar.calpwstr.pElems, propVar.calpwstr.cElems, sizeof(WCHAR *), QSortCompareQueues);

        m_calpwstrQFormatNames = propVar.calpwstr;

        return hr;
    }

    CCachedQueueNames() :
        m_nQueue(0)
    {
       	memset(&m_calpwstrQFormatNames, 0, sizeof(m_calpwstrQFormatNames));
    };

    ~CCachedQueueNames()
    {
        for (DWORD i=0; i<m_calpwstrQFormatNames.cElems; i++)
        {
            MQFreeMemory(m_calpwstrQFormatNames.pElems[i]);
        }

       	MQFreeMemory(m_calpwstrQFormatNames.pElems);
    }

private:
    CALPWSTR m_calpwstrQFormatNames;
    DWORD m_nQueue;
};

//////////////////////////////////////////////////////////////////////////////
// CDsPublicQueueNames class
//
const struct 
{
    PROPID          pidMgmtPid;
    PROPID          pidDsPid;
} x_aMgmtToDsProps[] =
{
    {PROPID_MGMT_QUEUE_PATHNAME, PROPID_Q_PATHNAME}, // must be index 0 (x_dwMgmtToDsQPathNameIndex)
    {NO_PROPERTY, PROPID_Q_INSTANCE},                // must be index 1 (x_dwMgmtToDsQInstanceIndex)
    {PROPID_MGMT_QUEUE_XACT, PROPID_Q_TRANSACTION}
};

const DWORD x_dwMgmtToDsSize = sizeof(x_aMgmtToDsProps) / sizeof(x_aMgmtToDsProps[0]);
const DWORD x_dwMgmtToDsQPathNameIndex = 0;
const DWORD x_dwMgmtToDsQInstanceIndex = 1;
const DWORD x_dwQueuesCacheSize=20;

//
// Copy a management properties structure from a DS props structure.
// Assume that the DS props are organized according to x_aMgmtToDsProps
// Clears the DS prop's vt so it will not be auto destructed.
//
static void CopyManagementFromDsPropsAndClear(MQMGMTPROPS *pmqQProps, PROPVARIANT *apvar)
{
    for (DWORD i=0; i<pmqQProps->cProp; i++)
    {
        for (DWORD j=0; j<x_dwMgmtToDsSize; j++)
        {
            if (pmqQProps->aPropID[i] == x_aMgmtToDsProps[j].pidMgmtPid)
            {
                pmqQProps->aPropVar[i] = apvar[j];
                apvar[j].vt = VT_NULL; //Do not destruct this element
            }
        }
    }
}

class CDsPublicQueueNames : public CQueueNames
{
public:
    static HRESULT CreateInstance(CQueueNames **ppqueueNamesProducer,CString &strMachineName)
    {
        *ppqueueNamesProducer = new CDsPublicQueueNames();
        return (*ppqueueNamesProducer)->InitiateNewInstance(strMachineName);
    }

    virtual HRESULT GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps)
    {
        ASSERT (0 != (DSLookup *)m_pdslookup);

        HRESULT hr = MQ_OK;

        if (m_dwCurrentPropIndex >= m_dwNumPropsInQueuesCache)
        {
            //
            // Clear the previous cache and read from DS
            //
            DestructElements(m_apvarCache, m_dwNumPropsInQueuesCache);
            m_dwNumPropsInQueuesCache = 0;
            DWORD dwNumProps = sizeof(m_apvarCache) / sizeof(m_apvarCache[0]);
            for (DWORD i=0; i<dwNumProps; i++)
            {
                m_apvarCache[i].vt = VT_NULL;
            }

            hr = m_pdslookup->Next(&dwNumProps, m_apvarCache);
            m_dwNumPropsInQueuesCache = dwNumProps;
            m_dwCurrentPropIndex = 0;
            if FAILED(hr)
            {
                return hr;
            }
            if (0 == dwNumProps)
            {
                strQueueFormatName = TEXT("");
                return S_OK;
            }
        }

        //
        // Point to the current section in cache
        //
        PROPVARIANT *apvar = m_apvarCache + m_dwCurrentPropIndex;
        m_dwCurrentPropIndex += x_dwMgmtToDsSize;

        //
        // The queue instance guid appears at x_dwMgmtToDsQInstanceIndex
        //
        ASSERT(apvar[x_dwMgmtToDsQInstanceIndex].vt == VT_CLSID);
        CString szFormatName;
        szFormatName.Format(
        FN_PUBLIC_TOKEN     // "PUBLIC"
            FN_EQUAL_SIGN   // "="
            GUID_FORMAT,     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(apvar[x_dwMgmtToDsQInstanceIndex].puuid)
        );

        //
        // Put the format name into the output var
        //
        strQueueFormatName = szFormatName;

        //
        // Put the pathname into the output var
        //
        ASSERT(apvar[x_dwMgmtToDsQPathNameIndex].vt == VT_LPWSTR);
        strQueuePathName = apvar[x_dwMgmtToDsQPathNameIndex].pwszVal;

        //
        // If the queue is open - retrieve the dynamic properties
        //
        hr = GetOpenQueueProperties(m_szMachineName, strQueueFormatName, pmqQProps);
        if FAILED(hr)
        {
            //
            // We cannot get dynamic properties of the queue - it is probably not open.
            // We will try to fill it what we can using static properties
            //
            CopyManagementFromDsPropsAndClear(pmqQProps, apvar);

            return S_OK;
        }

        return hr;
    }


protected:
    virtual HRESULT Init(CString &strMachineName)
    { 
        //
        // Find the computer's GUID so we can look for queues
        //
        PROPID pid = PROPID_QM_MACHINE_ID;
        PROPVARIANT pvar;
        pvar.vt = VT_NULL;
        
        HRESULT hr = ADGetObjectProperties(
                        eMACHINE,
                        MachineDomain(strMachineName),
						false,	// fServerName
                        strMachineName, 
                        1, 
                        &pid, 
                        &pvar
                        );
        if FAILED(hr)
        {
            if (hr != MQDS_OBJECT_NOT_FOUND)
            {
                //
                // Real error. Return.
                //
                return hr;
            }
            //
            // This may be an NT4 server, and we may be using a full DNS name. Try again with
            // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
            //
            CString strNetBiosName;
            if (!GetNetbiosName(strMachineName, strNetBiosName))
            {
                //
                // Already a netbios name. No need to proceed
                //
                return hr;
            }
            
            hr = ADGetObjectProperties(
                        eMACHINE,
                        MachineDomain(strMachineName),
						false,	// fServerName
                        strNetBiosName, 
                        1, 
                        &pid, 
                        &pvar
                        );
            if FAILED(hr)
            {
                //
                // No luck with Netbios name as well... return
                //
                return hr;
            }
        }

        ASSERT(pvar.vt == VT_CLSID);
        GUID guidQM = *pvar.puuid;
        MQFreeMemory(pvar.puuid);

	    //
        // Query the DS for all the queues under the current computer
        //
        CRestriction restriction;
        restriction.AddRestriction(&guidQM, PROPID_Q_QMID, PREQ, 0);

        CColumns columns;
        for (int i=0; i<x_dwMgmtToDsSize; i++)
        {
            columns.Add(x_aMgmtToDsProps[i].pidDsPid);
        }        
        
        HANDLE hEnume;
        {
            CWaitCursor wc; //display wait cursor while query DS
            hr = ADQueryMachineQueues(
                    MachineDomain(strMachineName),
					false,		// fServerName
                    &guidQM,
                    columns.CastToStruct(),
                    &hEnume
                    );
        }
        
        m_pdslookup = new DSLookup(hEnume, hr);

        if (!m_pdslookup->HasValidHandle())
        {
            hr = m_pdslookup->GetStatusCode();
            delete m_pdslookup.detach();
        }

        return hr;
    }

    CDsPublicQueueNames() :
        m_pdslookup(0) ,
        m_dwCurrentPropIndex(0),
        m_dwNumPropsInQueuesCache(0)
        {};

    ~CDsPublicQueueNames()
    {
        DestructElements(m_apvarCache, m_dwNumPropsInQueuesCache);
    };
private:
    P<DSLookup> m_pdslookup;
    DWORD m_dwCurrentPropIndex;
    DWORD m_dwNumPropsInQueuesCache;
    PROPVARIANT m_apvarCache[x_dwMgmtToDsSize*x_dwQueuesCacheSize];
};


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingFolder::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer)
{
    HRESULT hr = S_OK;
    if (0 == m_pQueueNames)
    {
        hr = CCachedQueueNames::CreateInstance(&m_pQueueNames, m_szMachineName);
    }

    *ppqueueNamesProducer = m_pQueueNames;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicFolder::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer)
{
    HRESULT hr = S_OK;
    if (0 == m_pQueueNames)
    {
        CString strMachineNameForDs;
        if (!m_fOnLocalMachine)
        {
            strMachineNameForDs = m_szMachineName;
        }
        else
        {
            hr = GetComputerNameIntoString(strMachineNameForDs);

            if FAILED(hr)
            {
                return hr ;
            }
        }
        hr = CDsPublicQueueNames::CreateInstance(&m_pQueueNames, strMachineNameForDs);
        if FAILED(hr)
        {
			MessageDSError(hr, IDS_WARNING_DS_PUBLIC_QUEUES_NOT_AVAILABLE);
            //
            // Change the icons of the folder to indicate no DS state
            //
            //
            // Need IConsoleNameSpace
            //
            CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	        //
	        // We are OK 
	        // Change the ICON to disconnect state
	        //
	        m_scopeDataItem.nImage = IMAGE_PUBLIC_FOLDER_NODS_CLOSE;  
	        m_scopeDataItem.nOpenImage = IMAGE_PUBLIC_FOLDER_NODS_OPEN;
	        spConsoleNameSpace->SetItem(&m_scopeDataItem);
            hr = CCachedQueueNames::CreateInstance(&m_pQueueNames, m_szMachineName);
        }
   }

    *ppqueueNamesProducer = m_pQueueNames;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

LocalQueuePropertyToString

	Translates a property value into a string from String Resource file

--*/
//////////////////////////////////////////////////////////////////////////////
static void CALLBACK LocalQueuePropertyToString(const PROPVARIANT *pPropVar, CString &str)
{
	struct 
	{
		const WCHAR *pString;
		DWORD StringId;
	} ItemList[] = 
	{
		{MGMT_QUEUE_TYPE_PUBLIC,         IDS_MGMT_QUEUE_TYPE_PUBLIC},
		{MGMT_QUEUE_TYPE_PRIVATE,        IDS_MGMT_QUEUE_TYPE_PRIVATE},
		{MGMT_QUEUE_TYPE_MACHINE,        IDS_MGMT_QUEUE_TYPE_MACHINE},
		{MGMT_QUEUE_TYPE_CONNECTOR,      IDS_MGMT_QUEUE_TYPE_CONNECTOR},
		{MGMT_QUEUE_STATE_LOCAL,         IDS_MGMT_QUEUE_STATE_LOCAL},
		{MGMT_QUEUE_STATE_NONACTIVE,     IDS_MGMT_QUEUE_STATE_NONACTIVE},
		{MGMT_QUEUE_STATE_WAITING,       IDS_MGMT_QUEUE_STATE_WAITING},
		{MGMT_QUEUE_STATE_NEED_VALIDATE, IDS_MGMT_QUEUE_STATE_NEED_VALIDATE},
		{MGMT_QUEUE_STATE_ONHOLD,        IDS_MGMT_QUEUE_STATE_ONHOLD},
		{MGMT_QUEUE_STATE_CONNECTED,     IDS_MGMT_QUEUE_STATE_CONNECTED},
		{MGMT_QUEUE_STATE_DISCONNECTING, IDS_MGMT_QUEUE_STATE_DISCONNECTING},
		{MGMT_QUEUE_STATE_DISCONNECTED,  IDS_MGMT_QUEUE_STATE_DISCONNECTED},
		{MGMT_QUEUE_LOCAL_LOCATION,      IDS_MGMT_QUEUE_LOCAL_LOCATION},
		{MGMT_QUEUE_REMOTE_LOCATION,     IDS_MGMT_QUEUE_REMOTE_LOCATION},
		{MGMT_QUEUE_UNKNOWN_TYPE,        IDS_MGMT_QUEUE_UNKNOWN_TYPE},
		{MGMT_QUEUE_CORRECT_TYPE,        IDS_MGMT_QUEUE_CORRECT_TYPE},
		{MGMT_QUEUE_INCORRECT_TYPE,      IDS_MGMT_QUEUE_INCORRECT_TYPE},
		{L"",                             0}
	};


	if(pPropVar->vt == VT_NULL)
	{
		str = L"";
		return;
	}

    if (pPropVar->vt == VT_UI1) // Assume boolean value
    {
        if (pPropVar->bVal)
        {
			str.LoadString(IDS_MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
			str.LoadString(IDS_MGMT_QUEUE_INCORRECT_TYPE);
        }
        return;
    }

	ASSERT(pPropVar->vt == VT_LPWSTR);
	for(DWORD i = 0; ItemList[i].StringId != 0; i++)
	{
		if(wcscmp(pPropVar->pwszVal, ItemList[i].pString) == 0)
		{
			str.LoadString(ItemList[i].StringId);
			return;
		}
	}

	ASSERT(0);
	str=L"";

	return;
}

//------------------------------------------------
//
// Tables of Outgoing / public queues properties
//
//------------------------------------------------

PropertyDisplayItem OutgoingQueueDisplayList[] = {

    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+-----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, 200,         NULL},
	{ IDS_LQ_FORMATNM,  PROPID_MGMT_QUEUE_FORMATNAME,   &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_LOCATION,  PROPID_MGMT_QUEUE_LOCATION,     NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_XACT,      PROPID_MGMT_QUEUE_XACT,         NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},  
	{ IDS_LQ_FOREIGN,   PROPID_MGMT_QUEUE_FOREIGN,      NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_ACKCOUNT,  PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,        &g_VTUI4,    NULL,             NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_READCOUNT, PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,       &g_VTUI4,    NULL,             NO_OFFSET, 0,  50,         NULL},
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_STATE,     PROPID_MGMT_QUEUE_STATE,        NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, 100,         NULL},   
	{ IDS_LQ_NEXTHOP,   PROPID_MGMT_QUEUE_NEXTHOPS,     &g_VectLPWSTR,NULL,                       NO_OFFSET, 0, 180,         NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_TYPE,         NULL,                   NULL,             NO_OFFSET, 0,   0,         NULL},   


/*
	//
	// Properties that are not shown on the right pane (only in property pages)
	//
    // Str. |       Property    ID                 | VT Handler   |Dis.| Field    |Len|Width | Sort
    // Res  |                                      |              |func| Offset   |   |      |     
    //------+--------------------------------------+--------------+----+----------+---+------+-----
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_ACK,        NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EDO_LAST_ACK_COUNT,  NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NEXT_SEQ,        NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_RESEND_TIME,     NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL, NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EDO_RESEND_COUNT,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_SOURCE_INFO,     NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
*/


    {0,                 0,                              NULL }

};


PropertyDisplayItem *CLocalOutgoingFolder::GetDisplayList()
{
    return OutgoingQueueDisplayList;
}

const DWORD CLocalOutgoingFolder::GetNumDisplayProps()
{
    return ((sizeof(OutgoingQueueDisplayList)/sizeof(OutgoingQueueDisplayList[0])) - 1);
}

PropertyDisplayItem PublicQueueDisplayList[] = {

    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
	{ IDS_LQ_FORMATNM,  PROPID_MGMT_QUEUE_FORMATNAME,   &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_XACT,      PROPID_MGMT_QUEUE_XACT,         NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},  
	{ IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_TYPE,         NULL,                   NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_LOCATION,     NULL,                   NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }

};

PropertyDisplayItem *CLocalPublicFolder::GetDisplayList()
{
    return PublicQueueDisplayList;
}

const DWORD CLocalPublicFolder::GetNumDisplayProps()
{
    return ((sizeof(PublicQueueDisplayList)/sizeof(PublicQueueDisplayList[0])) - 1);
}

/****************************************************

CLocalOutgoingQueue Class
    
 ****************************************************/
// {B6EDE68F-29CC-11d2-B552-006008764D7A}
static const GUID CLocalOutgoingQueueGUID_NODETYPE = 
{ 0xb6ede68f, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalOutgoingQueue::m_NODETYPE = &CLocalOutgoingQueueGUID_NODETYPE;
const OLECHAR* CLocalOutgoingQueue::m_SZNODETYPE = OLESTR("B6EDE68F-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalOutgoingQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalOutgoingQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());   
    HRESULT hr = S_OK;
    CString strTitle;
    
    //
    // Create a node to Read Messages if on local machine
    //
    if (m_fOnLocalMachine)
    {
        CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, L"");

        // Pass relevant information
        strTitle.LoadString(IDS_READMESSAGE);
        p->m_bstrDisplayName = strTitle;
	    p->m_fAdminMode      = MQ_ADMIN_ACCESS;

        p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

   	    AddChild(p, &p->m_scopeDataItem);
    }

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::InitState

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::InitState()
{
    //
    // Set display name
    //
    CString strName;
	GetStringPropertyValue(m_aDisplayList, PROPID_MGMT_QUEUE_PATHNAME, m_mqProps.aPropVar, strName);
	if(strName == L"")
    {
		m_bstrDisplayName = m_szFormatName;
    }
    else
    {
        m_bstrDisplayName = strName;
    }

	//
	// Set queue state
	//
	CString strState;
	m_fOnHold = FALSE;

	GetStringPropertyValue(m_aDisplayList, PROPID_MGMT_QUEUE_STATE, m_mqProps.aPropVar, strState);

	if(strState == MGMT_QUEUE_STATE_ONHOLD)
		m_fOnHold = TRUE;
	
	//
	// Set the right icon
	//
	DWORD icon;
	icon = IMAGE_LOCAL_OUTGOING_QUEUE;
	if(m_fOnHold)
		icon = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;

	SetIcons(icon, icon);
	return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::UpdateMenuState

      Called when context menu is created. Used to enable/disable menu items.


--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *pflags)
{

	//
	// Gray out menu when in OnHold state
	//
	if(m_fOnHold == TRUE)
	{

		if (id == ID_MENUITEM_LOCALOUTGOINGQUEUE_PAUSE)
			*pflags |= MFS_DISABLED;

		return;
	}

	//
	// Gray out menu when in connected state
	//
	if(m_fOnHold == FALSE)
	{
		if (id == ID_MENUITEM_LOCALOUTGOINGQUEUE_RESUME)
			*pflags |= MFS_DISABLED;

		return;
	}

	return;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::OnPause


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::OnPause(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_fOnHold == FALSE);

    CString strConfirmation;

    strConfirmation.FormatMessage(IDS_PAUSE_QUESTION);
    if (IDYES != AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return(S_OK);
    }

    //
	// Pause
	//
	CString szObjectName = L"QUEUE=" + m_szFormatName;
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       szObjectName, 
                       QUEUE_ACTION_PAUSE);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }

	//
	// Refresh disaply
	//
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
	m_scopeDataItem.nImage = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;  
	m_scopeDataItem.nOpenImage = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_fOnHold = TRUE;

    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return(S_OK);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::OnResume


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::OnResume(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_fOnHold == TRUE);

    CString strConfirmation;

    strConfirmation.FormatMessage(IDS_RESUME_QUESTION);
    if (IDYES != AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return(S_OK);
    }
	
	//
	// Resume
	//
	CString szObjectName = L"QUEUE=" + m_szFormatName;
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       szObjectName, 
                       QUEUE_ACTION_RESUME);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }


	//
	// Refresh disaply
	//
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
	m_scopeDataItem.nImage = IMAGE_LOCAL_OUTGOING_QUEUE;  
	m_scopeDataItem.nOpenImage = IMAGE_LOCAL_OUTGOING_QUEUE;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_fOnHold = FALSE;

    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return(S_OK);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::ApplyCustomDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::ApplyCustomDisplay(DWORD dwPropIndex)
{
    CDisplayQueue<CLocalOutgoingQueue>::ApplyCustomDisplay(dwPropIndex);

    //
    // If pathname is blank, take the display name (in this case, the format name)
    //
    if (m_mqProps.aPropID[dwPropIndex] == PROPID_MGMT_QUEUE_PATHNAME && 
        (m_bstrLastDisplay == 0 || m_bstrLastDisplay[0] == 0))
    {
        m_bstrLastDisplay = m_bstrDisplayName;
    }
}


/****************************************************

CLocalOutgoingFolder Class
    
 ****************************************************/
// {B6EDE697-29CC-11d2-B552-006008764D7A}
static const GUID CLocalOutgoingFolderGUID_NODETYPE = 
{ 0xb6ede697, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalOutgoingFolder::m_NODETYPE = &CLocalOutgoingFolderGUID_NODETYPE;
const OLECHAR* CLocalOutgoingFolder::m_SZNODETYPE = OLESTR("B6EDE697-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalOutgoingFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalOutgoingFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

void CLocalOutgoingFolder::AddChildQueue(CString &szFormatName, 
                                         CString &,
                                         MQMGMTPROPS &mqQProps, 
										 CString &szLocation,   
                                         CString &)
{
	if(szLocation == MGMT_QUEUE_REMOTE_LOCATION)
	{
    	CLocalOutgoingQueue *pLocalOutgoing;
		//
		// Create a new Outgoing queue
		//
		pLocalOutgoing = new CLocalOutgoingQueue(this, m_pComponentData, m_fOnLocalMachine);

		pLocalOutgoing->m_szFormatName  = szFormatName;
		pLocalOutgoing->m_mqProps       = mqQProps;
		pLocalOutgoing->m_szMachineName = m_szMachineName;     
		pLocalOutgoing->InitState();

		AddChild(pLocalOutgoing, &pLocalOutgoing->m_scopeDataItem);
	}
}

/****************************************************

CLocalPublicFolder Class
    
 ****************************************************/
// {5c845756-8da1-11d2-829e-006094eb6406}
static const GUID CLocalPublicFolderGUID_NODETYPE = 
{ 0x5c845756, 0x8da1, 0x11d2,{0x82, 0x9e, 0x00, 0x60, 0x94, 0xeb, 0x64, 0x06} };
const GUID*  CLocalPublicFolder::m_NODETYPE = &CLocalPublicFolderGUID_NODETYPE;
const OLECHAR* CLocalPublicFolder::m_SZNODETYPE = OLESTR("5c845756-8da1-11d2-829e-006094eb6406");
const OLECHAR* CLocalPublicFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalPublicFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::AddChildQueue

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalPublicFolder::AddChildQueue(CString &szFormatName, 
                                       CString &szPathName,
                                       MQMGMTPROPS &mqQProps, 
									   CString &szLocation,   
                                       CString &szType)
{
	if(szLocation == MGMT_QUEUE_LOCAL_LOCATION || szLocation == TEXT(""))
	{
		//
		// if public, Create a new LocalQueue object
		//
		if(szType == MGMT_QUEUE_TYPE_PUBLIC || szType == TEXT(""))
		{
            CString strQueuePathName;
            BOOL fFromDS;
            if (szPathName == TEXT(""))
            {
                //
                // We got the queue from local cache
                //
        	    GetStringPropertyValue(GetDisplayList(), PROPID_MGMT_QUEUE_PATHNAME, mqQProps.aPropVar, strQueuePathName);
                fFromDS = FALSE;
            }
            else
            {
                strQueuePathName = szPathName;
                fFromDS = TRUE;
            }

            CLocalPublicQueue *pLocalQueue = new CLocalPublicQueue(this, GetDisplayList(), GetNumDisplayProps(), m_pComponentData, strQueuePathName, szFormatName, fFromDS);

            pLocalQueue->m_mqProps.cProp    = mqQProps.cProp;
            pLocalQueue->m_mqProps.aPropID  = mqQProps.aPropID;
            pLocalQueue->m_mqProps.aPropVar = mqQProps.aPropVar;
            pLocalQueue->m_mqProps.aStatus  = NULL;

			pLocalQueue->m_szMachineName = m_szMachineName;

            //
            // Extract the queue name only from the full public path name
            //
            CString strName;
            ExtractQueueNameFromQueuePathName(strName, strQueuePathName);
            pLocalQueue->m_bstrDisplayName = strName;

			AddChild(pLocalQueue, &pLocalQueue->m_scopeDataItem);
		}
	}

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::OnNewPublicQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicFolder::OnNewPublicQueue(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    R<CQueueName> pQueueNameDlg = new CQueueName(m_szMachineName);       
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();
    bHandled = TRUE;

    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        return S_FALSE;
    }
    
    HRESULT hr = AddPublicQueueToScope(pQueueNameDlg->GetNewQueueFormatName(), pQueueNameDlg->GetNewQueuePathName());
    if (FAILED(hr))
    {
        if ( ADProviderType() == eMqdscli)
        {
            //
            // We successfully added the queue, but AddPublicQueueToScope failed.
            // The most reasonable cause of this is replication delays. (YoelA, 25-Jul-99)
            //
            AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        }
        else
        {
            MessageDSError(hr, IDS_CREATED_BUT_RETRIEVE_FAILED);
        }
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CLocalPublicFolder::AddPublicQueueToScope(CString &strNewQueueFormatName, CString &strNewQueuePathName)
{
    PROPVARIANT pvar[x_dwMgmtToDsSize];
    PROPID  pid[x_dwMgmtToDsSize];

    for (DWORD i=0; i<x_dwMgmtToDsSize; i++)
    {
        pid[i] = x_aMgmtToDsProps[i].pidDsPid;
        pvar[i].vt = VT_NULL;
    }

    HRESULT hr = ADGetObjectProperties(
						eQUEUE,
						MachineDomain(m_szMachineName),
						false,	// fServerName
						strNewQueuePathName,
						x_dwMgmtToDsSize, 
						pid,
						pvar
						);

    if FAILED(hr)
    {
		TrERROR(mqsnap, "Failed to get properties for queue %ls, hr = 0x%x", strNewQueuePathName, hr);
        return hr;
    }

    //
    // Prepare the management properties structure
    //
	MQMGMTPROPS	  mqQProps;
	mqQProps.cProp    = GetNumDisplayProps();
	mqQProps.aPropID  = new PROPID[GetNumDisplayProps()];
	mqQProps.aPropVar = new PROPVARIANT[GetNumDisplayProps()];
	mqQProps.aStatus  = NULL;

	//
	// Initialize variant array
	//
    PropertyDisplayItem *aDisplayList = GetDisplayList();
	for(DWORD j = 0; j < GetNumDisplayProps(); j++)
	{
		mqQProps.aPropID[j] = aDisplayList[j].itemPid;
		mqQProps.aPropVar[j].vt = VT_NULL;
	}
    CString szLocation = MGMT_QUEUE_LOCAL_LOCATION;
    CString szType = MGMT_QUEUE_TYPE_PUBLIC;

    CopyManagementFromDsPropsAndClear(&mqQProps, pvar);

    AddChildQueue(strNewQueueFormatName, strNewQueuePathName, mqQProps, szLocation, szType);

    return S_OK;
}

/****************************************************

CSnapinLocalAdmin Class
    
 ****************************************************/
// {B6EDE69C-29CC-11d2-B552-006008764D7A}
static const GUID CSnapinLocalAdminGUID_NODETYPE = 
{ 0xb6ede69c, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CSnapinLocalAdmin::m_NODETYPE = &CSnapinLocalAdminGUID_NODETYPE;
const OLECHAR* CSnapinLocalAdmin::m_SZNODETYPE = OLESTR("B6EDE69C-29CC-11d2-B552-006008764D7A");
const OLECHAR* CSnapinLocalAdmin::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinLocalAdmin::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString strTitle;

    if (m_fIsDepClient)
    {
        //
        // don't add children if we are on Dep. Client
        //
        return hr;
    }

    //
    // Add a local outgoing queues folder
    //
    CLocalOutgoingFolder * logF;

    strTitle.LoadString(IDS_LOCALOUTGOING_FOLDER);
    logF = new CLocalOutgoingFolder(this, m_pComponentData, m_szMachineName, strTitle);

	AddChild(logF, &logF->m_scopeDataItem);

	if ( !m_fIsWorkgroup )
	{
		// Add a public queues folder
		//
		CLocalPublicFolder * lpubF;

		strTitle.LoadString(IDS_LOCALPUBLIC_FOLDER);
		lpubF = new CLocalPublicFolder(this, m_pComponentData, m_szMachineName, strTitle,
									   m_fUseIpAddress);

		AddChild(lpubF, &lpubF->m_scopeDataItem);
	}

    //
    // Add a private queues folder
    //
    CLocalPrivateFolder * pF;

    strTitle.LoadString(IDS_PRIVATE_FOLDER);
    pF = new CLocalPrivateFolder(this, m_pComponentData, m_szMachineName, strTitle);

	AddChild(pF, &pF->m_scopeDataItem);

    //
    // Add a system queue folder
    //
    {
        CSystemQueues *pSQ; 

        pSQ = new CSystemQueues(this, m_pComponentData, m_szMachineName);
        strTitle.LoadString(IDS_SYSTEM_QUEUES);
        pSQ->m_bstrDisplayName = strTitle;

  	    AddChild(pSQ, &pSQ->m_scopeDataItem);
    }

    if (m_szMachineName[0] == 0)
    {
		try
		{
			//
			// For local machine add MSMQ Trigger folder
			//
			CTriggerLocalAdmin* pTrig = new CTriggerLocalAdmin(this, m_pComponentData, m_szMachineName);

			strTitle.LoadString(IDS_MSMQ_TRIGGERS);
			pTrig->m_bstrDisplayName = strTitle;

			AddChild(pTrig, &pTrig->m_scopeDataItem);
		}
		catch (const _com_error&)
		{
		}
    }


    return(hr);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}

void CSnapinLocalAdmin::SetState(LPCWSTR pszState)
{
	if(wcscmp(pszState, MSMQ_CONNECTED) == 0)
	{
		SetIcons(IMAGE_PRODUCT_ICON, IMAGE_PRODUCT_ICON);
		m_bConnected = TRUE;
	}
	else if(wcscmp(pszState, MSMQ_DISCONNECTED) == 0)
	{
		SetIcons(IMAGE_PRODUCT_NOTCONNECTED, IMAGE_PRODUCT_NOTCONNECTED);
		m_bConnected = FALSE;
	}
    else
    {
        ASSERT(0);
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::UpdateMenuState

      Called when context menu is created. Used to enable/disable menu items.


--*/
//////////////////////////////////////////////////////////////////////////////
void CSnapinLocalAdmin::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *pflags)
{

	//
	// Gray out menu when in Connected state
	//
	if(m_bConnected == TRUE)
	{

		if (id == ID_MENUITEM_LOCALADM_CONNECT)
			*pflags |= MFS_DISABLED;

		return;
	}

	//
	// Gray out menu when in Disconnected state
	//
	if(m_bConnected == FALSE)
	{
		if (id == ID_MENUITEM_LOCALADM_DISCONNECT)
			*pflags |= MFS_DISABLED;

		return;
	}

	return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::OnConnect


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::OnConnect(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_bConnected == FALSE);

    CString strConfirmation;

    if (!ConfirmConnection(IDS_CONNECT_QUESTION))
    {
        return S_OK;
    }
	
	//
	// Connect
	//
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       MO_MACHINE_TOKEN,MACHINE_ACTION_CONNECT);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }


	//
	// Refresh disaply

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to connect state
	//
	m_scopeDataItem.nImage = IMAGE_PRODUCT_ICON;  
	m_scopeDataItem.nOpenImage = IMAGE_PRODUCT_ICON;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_bConnected = TRUE;


    return(S_OK);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::OnDisconnect


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::OnDisconnect(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_bConnected == TRUE);

    if (!ConfirmConnection(IDS_DISCONNECT_QUESTION))
    {
        return S_OK;
    }

	//
	// Connect
	//
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       MO_MACHINE_TOKEN,MACHINE_ACTION_DISCONNECT);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }

	//
	// Refresh disaply
	//
    
    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
	m_scopeDataItem.nImage = IMAGE_PRODUCT_NOTCONNECTED;  
	m_scopeDataItem.nOpenImage = IMAGE_PRODUCT_NOTCONNECTED;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_bConnected = FALSE;


    return(S_OK);

}

//
// ConfirmConnection - Ask for confirmation for connect / disconnect
//
BOOL CSnapinLocalAdmin::ConfirmConnection(UINT nFormatID)
{
    CString strConfirmation;

    //
    // strThisComputer is either the computer name or "this computer" for local
    //
    CString strThisComputer;
    if (m_szMachineName != TEXT(""))
    {
        strThisComputer = m_szMachineName;
    }
    else
    {
        strThisComputer.LoadString(IDS_THIS_COMPUTER);
    }

    //
    // Are you sure you want to take Message Queuing on *this computer* offline / online?
    //
    strConfirmation.FormatMessage(nFormatID, strThisComputer);
    if (IDYES == AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CheckEnvironment

  Check the site environment. This function will initialize the
  flag that is checked on mobile tab display.
  The mobile tab should be displayed only when:
  1. The client is not in workgroup mode AND
  2. The registry key 'MSMQ\Parameters\ServersCache' exists AND
  3. The work is done in MQIS mode

  In all other cases the mabile tab is irrelevant

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinLocalAdmin::CheckEnvironment(
	BOOL fIsWorkgroup,									
	BOOL* pfIsNT4Env
	)
{
	*pfIsNT4Env = FALSE;

	if ( fIsWorkgroup )
	{
		return S_OK;
	}

	WCHAR wszRegPath[512];
	wcscpy(wszRegPath, FALCON_REG_KEY);
	wcscat(wszRegPath, L"\\");
	wcscat(wszRegPath, MSMQ_SERVERS_CACHE_REGNAME);

	HKEY hKey;
	DWORD dwRes = RegOpenKeyEx(
						FALCON_REG_POS,
						wszRegPath,
						0,
						KEY_READ,
						&hKey
						);

	CRegHandle hAutoKey(hKey);

	if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if ( dwRes != ERROR_SUCCESS )
	{
		return S_OK;
	}

	if ( ADGetEnterprise() == eMqis )
	{
		*pfIsNT4Env = TRUE;
	}

	return S_OK;
}	


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitServiceFlagsInternal

  Get registry key and initilize MSMQ flags

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InitServiceFlagsInternal()
{
    //
    // Check if MSMQ Dep. Client
    //    
    DWORD dwType = REG_SZ ;
    TCHAR szRemoteMSMQServer[ MAX_PATH ];
    DWORD dwSize = sizeof(szRemoteMSMQServer) ;
    HRESULT rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
                                    &dwType,
                                    (PVOID) szRemoteMSMQServer,
                                    &dwSize ) ;
    if(rc == ERROR_SUCCESS)
    {
        //
        // Dep. Client
        //
        m_fIsDepClient = TRUE;      
        return S_OK;
    } 
    
    m_fIsDepClient = FALSE;    

    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwValue;
    rc = GetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME,
                           &dwType,
                           &dwValue,
                           &dwSize);
    if (rc != ERROR_SUCCESS) 
    {
        return HRESULT_FROM_WIN32(rc);
    }
    m_fIsRouter = (dwValue!=0);

    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue( MSMQ_MQS_DSSERVER_REGNAME,
                            &dwType,
                            &dwValue,
                            &dwSize);
    if (rc != ERROR_SUCCESS) 
    {
        return HRESULT_FROM_WIN32(rc);
    }
    m_fIsDs = (dwValue!=0);

	//
	// Check if local account
	//
    BOOL fLocalUser =  FALSE ;
    rc = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           NULL ) ;
	if ( FAILED(rc) )
	{
		return rc;
	}

	if ( fLocalUser )
	{
		m_fIsLocalUser = TRUE;
	}

    return CheckEnvironment(m_fIsWorkgroup, &m_fIsNT4Env);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitServiceFlags

  Called when creating a control panel property pages

--*/
//////////////////////////////////////////////////////////////////////////////
void CSnapinLocalAdmin::InitServiceFlags()
{
	HRESULT hr = InitAllMachinesFlags();
	if (FAILED(hr))
	{
        MessageDSError(hr, IDS_OP_DISPLAY_PAGES);
		return;
    }

	//
	// All further checks are relevant only for local machine
	//
	if (m_szMachineName[0] != 0)
	{
		return;
	}

    //
    // check if this machine is cluster
    //
    m_fIsCluster = IsLocalSystemCluster();
    if (m_fIsCluster)
    {
        //
        // BUGBUG: to get registry on cluster we have to use
        // different functions (maybe from mqclus.dll)
        // Currently we do not support it, so all control panel pages
        // will not be shown on cluster.
        // Bug 5794 falcon database
        //
        return;
    }

    hr = InitServiceFlagsInternal();
    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_DISPLAY_PAGES);                
    }
    else
    {       
        //
        // BUGBUG: we do not show control panel pages
        // on cluster machine
        // Bug 5794 falcon database
        //
        m_fAreFlagsInitialized = TRUE;     
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitAllMachinesFlags

  Called when creating the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InitAllMachinesFlags()
{
	HKEY hKey;
	DWORD dwRes = RegOpenKeyEx(
						FALCON_REG_POS,
						FALCON_REG_KEY,
						0,
						KEY_READ,
						&hKey
						);

	CRegHandle hAutoKey(hKey);

	if ( dwRes != ERROR_SUCCESS )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	DWORD dwVal = 0;
	DWORD dwSizeVal = sizeof(DWORD);
	DWORD dwType = REG_DWORD;

	dwRes = RegQueryValueEx(
					hKey,
					MSMQ_WORKGROUP_REGNAME,
					0,
					&dwType,
					reinterpret_cast<LPBYTE>(&dwVal),
					&dwSizeVal
					);
	
	if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if ( dwRes == ERROR_SUCCESS && dwVal == 1 )
	{
		m_fIsWorkgroup = TRUE;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (type == CCT_SCOPE || type == CCT_RESULT)
	{   
        HRESULT hr = S_OK;

        if (m_szMachineName[0] == 0 && m_fAreFlagsInitialized)
        {
            //
            // it is local computer and all flags from registry were
            // initialized successfully. It is not cluster machine also.
            // So, we have to add pages which were on control panel
            //     
            //
            // BUGBUG: currently we do not show control panel pages 
            // on cluster machine since all get/set registry operation
            // must be performed differently.
            // When we'll add this support we have to change the code
            // in storage.cpp too where we set/get registry and work with
            // directory. Maybe there is problem on other pages too.
            // Bug 5794 falcon database
            //

            //
            // add storage page on all computers except Dep. Client
            //        
            if (!m_fIsDepClient)
            {
                HPROPSHEETPAGE hStoragePage = 0;
                hr = CreateStoragePage (&hStoragePage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hStoragePage); 
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_STORAGE_PAGE);
                }
            }

            //
            // add Client page on Ind. Client
            //
            if (m_fIsDepClient)
            {
                HPROPSHEETPAGE hClientPage = 0;
                hr = CreateClientPage (&hClientPage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hClientPage); 
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_CLIENT_PAGE);
                }
            }

            //
            // add Local User Certificate page if the computer is not in
			// WORKGROUP mode, or the user is not local
            //
			if (!m_fIsWorkgroup && !m_fIsLocalUser)
			{
				HPROPSHEETPAGE hLocalUserCertPage = 0;
				hr = CreateLocalUserCertPage (&hLocalUserCertPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hLocalUserCertPage); 
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_MSMQSECURITY_PAGE);
				}
			}
        
            //
            // add Mobile page if we run on Ind. Client
            //        
            if (!m_fIsRouter && !m_fIsDs && !m_fIsDepClient && m_fIsNT4Env)
            {
                HPROPSHEETPAGE hMobilePage = 0;
                hr = CreateMobilePage (&hMobilePage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hMobilePage);
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_MOBILE_PAGE);
                }            
            }

            //
            // add Service Security page on all computers running MSMQ
			// except WORKGROUP computers
            //
			if ( !m_fIsWorkgroup )
			{
				HPROPSHEETPAGE hServiceSecurityPage = 0;
				hr = CreateServiceSecurityPage (&hServiceSecurityPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hServiceSecurityPage);
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_SRVAUTH_PAGE);
				}
			}
        }

        //
        // must be last page: create machine security page
        // don't add this page on/for Dep. Client
        //
        if (!m_fIsDepClient)  
        {
            HPROPSHEETPAGE hSecurityPage = 0;
            hr = CreateMachineSecurityPage(
					&hSecurityPage, 
					m_szMachineName, 
					MachineDomain(m_szMachineName), 
					false	// fServerName
					);

            if (SUCCEEDED(hr))
            {
                lpProvider->AddPage(hSecurityPage); 
            }
            else
            {
                MessageDSError(hr, IDS_OP_DISPLAY_SECURITY_PAGE);
            }
        }
        
        return(S_OK);
	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateStoragePage

  Called when creating a storage property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateStoragePage (OUT HPROPSHEETPAGE *phStoragePage)
{   
    CStoragePage *pcpageStorage = new CStoragePage;

    if (0 == pcpageStorage)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pcpageStorage->m_psp); 
    if (hPage)
    {
        *phStoragePage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateLocalUserCertPage

  Called when creating a MSMQ Security property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateLocalUserCertPage (
                   OUT HPROPSHEETPAGE *phLocalUserCertPage)
{       
    CLocalUserCertPage *pcpageLocalUserCert = new CLocalUserCertPage();

    if (0 == pcpageLocalUserCert)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pcpageLocalUserCert->m_psp); 
    if (hPage)
    {
        *phLocalUserCertPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateMobilePage

  Called when creating a mobile property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateMobilePage (OUT HPROPSHEETPAGE *phMobilePage)
{       
    CMobilePage *pcpageMobile = new CMobilePage;

    if (0 == pcpageMobile)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pcpageMobile->m_psp); 
    if (hPage)
    {
        *phMobilePage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateClientPage

  Called when creating a client property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateClientPage (OUT HPROPSHEETPAGE *phClientPage)
{
    CClientPage *pcpageClient = new CClientPage;

    if (0 == pcpageClient)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pcpageClient->m_psp); 
    if (hPage)
    {
        *phClientPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateServiceSecurityPage

  Called when creating a service security property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateServiceSecurityPage (OUT HPROPSHEETPAGE *phServiceSecurityPage)
{
    CServiceSecurityPage *pcpageServiceSecurity = 
            new CServiceSecurityPage(m_fIsDepClient, m_fIsDs);

    if (0 == pcpageServiceSecurity)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pcpageServiceSecurity->m_psp); 
    if (hPage)
    {
        *phServiceSecurityPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\linkgen.h ===
#if !defined(AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LinkGen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CLinkGen dialog

class CLinkGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CLinkGen)

// Construction
public:
	CLinkGen(const CString& LinkPathName, const CString& m_strDomainController);
    CLinkGen() {};
	~CLinkGen();

    HRESULT
    Initialize(
        const GUID* FirstSiteId,
        const GUID* SecondSiteId,
        DWORD LinkCost,
		CString strLinkDescription
        );

// Dialog Data
	//{{AFX_DATA(CLinkGen)
	enum { IDD = IDD_SITE_LINK_GENERAL };
	DWORD	m_LinkCost;
	CString	m_LinkLabel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLinkGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLinkGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HRESULT
    GetSiteName(
        const GUID* pguidSiteId,
        CString *   pstrSiteName
        );
	

    const GUID* m_pFirstSiteId;
    const GUID* m_pSecondSiteId;

    CString m_LinkPathName;
    CString m_strDomainController;
	CString m_strLinkDescription;

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localadm.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.h

Abstract:

	Definition for the Local administration
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __LOCALADM_H_
#define __LOCALADM_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

/****************************************************

        CLocalActiveFolder Class
    
 ****************************************************/
class CQueueNames
{
public:
    virtual LONG AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    };

    virtual LONG Release()
    {
        InterlockedDecrement(&m_lRef);
        if (0 == m_lRef)
        {
            delete this;
            return 0; // We cannot return m_lRef - it is not valid after delete this
        }
        return m_lRef;
    };

    virtual HRESULT GetNextQueue(CString &strQueueName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps) = 0;
    HRESULT InitiateNewInstance(CString &strMachineName)
    {
        m_szMachineName = strMachineName;
        HRESULT hr = Init(strMachineName);
        if FAILED(hr)
        {
            Release();
        }
        return hr;
    };

protected:
    CQueueNames() :
         m_lRef(1)
    {};

    virtual HRESULT Init(CString &strMachineName) = 0;

    static HRESULT GetOpenQueueProperties(CString &szMachineName, CString &szFormatName, MQMGMTPROPS *pmqQProps)
    {
		CString szObjectName = L"QUEUE=" + szFormatName;
	    HRESULT hr = MQMgmtGetInfo((szMachineName == TEXT("")) ? (LPCWSTR)NULL : szMachineName, szObjectName, pmqQProps);

		if(FAILED(hr))
		{
            return hr;
		}

        return S_OK;
    }

    CString m_szMachineName;

private:
    long m_lRef;
};

template <class T> 
class CLocalActiveFolder : public CLocalQueuesFolder<T>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalActiveFolder, FALSE)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALACTIVE_MENU)

    CLocalActiveFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                       LPCTSTR strMachineName, LPCTSTR strDisplayName) : 
        CLocalQueuesFolder<T>(pParentNode, pComponentData, strMachineName, strDisplayName),
        m_pQueueNames(0)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CLocalActiveFolder()
    {
        if (m_pQueueNames !=0)
        {
            m_pQueueNames->Release();
        }
    }

    
	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual PropertyDisplayItem *GetDisplayList() PURE;
    virtual const DWORD         GetNumDisplayProps() PURE;
	virtual void  AddChildQueue(CString &szFormatName, CString &szPathName, MQMGMTPROPS &mqQProps, 
							   CString &szLocation, CString &szType) PURE;
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer, BOOL fNew);

protected:
    CQueueNames *m_pQueueNames;
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer) PURE;

};

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer, BOOL fNew)
{
    if (fNew)
    {
        if (0 != m_pQueueNames)
        {
            m_pQueueNames->Release();
            m_pQueueNames = 0;
        }
    }

    return GetQueueNamesProducer(ppqueueNamesProducer);
};


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

    return(hr);
}
       

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CQueueNames *pQueueNames;
        
    HRESULT hr = GetQueueNamesProducer(&pQueueNames, TRUE);
    if FAILED(hr)
    {
        return hr;
    }

	//
	// Loop over all open queue and create queue objects
	//
	while(TRUE)
    {
		HRESULT hr;
		MQMGMTPROPS	  mqQProps;
		AP<PROPID> aPropId = new PROPID[GetNumDisplayProps()]; 
		AP<PROPVARIANT> aPropVar = new PROPVARIANT[GetNumDisplayProps()];

		//
		// Initialize variant array
		//
        PropertyDisplayItem *aDisplayList = GetDisplayList();
		for(DWORD j = 0; j < GetNumDisplayProps(); j++)
		{
			aPropId[j] = aDisplayList[j].itemPid;
			aPropVar[j].vt = VT_NULL;
		}

		mqQProps.cProp    = GetNumDisplayProps();
		mqQProps.aPropID  = aPropId;
		mqQProps.aPropVar = aPropVar;
		mqQProps.aStatus  = NULL;

		//
		// Get the format name of the local queue
		//
		CString szFormatName = TEXT("");
		CString szPathName = TEXT("");
   		CString szLocation = TEXT("");
        CString szType = TEXT("");

        hr = pQueueNames->GetNextQueue(szFormatName, szPathName, &mqQProps);
        //
        // Clear the properties with no value using the "Clear" function
        //
        for (DWORD i = 0; i < mqQProps.cProp; i++)
        {
            if (mqQProps.aPropVar[i].vt == VT_NULL)
            {
                VTHandler       *pvth = aDisplayList[i].pvth;
                if (pvth)
                {
                    pvth->Clear(&mqQProps.aPropVar[i]);
                }
            }
        }

        if FAILED(hr)
        {
            if (szFormatName != TEXT(""))
            {
   			    //
			    // if format name is valid, there is a queue but we could not get
                // its properties for some reason. Add an error node
			    //
			    CErrorNode *pErr = new CErrorNode(this, m_pComponentData);
			    CString szErr;

			    MQErrorToMessageString(szErr, hr);
			    pErr->m_bstrDisplayName = szFormatName + L" - " + szErr;
	  		    AddChild(pErr, &pErr->m_scopeDataItem);

			    continue;
            }

            //
            // If format name is not valid, there is no point in continuing fetching queues
            //
            return hr;
        }

        if (szFormatName == TEXT("")) // End of queues
        {
            break;
        }

        GetStringPropertyValue(aDisplayList, PROPID_MGMT_QUEUE_LOCATION, mqQProps.aPropVar, szLocation);
	    GetStringPropertyValue(aDisplayList, PROPID_MGMT_QUEUE_TYPE, mqQProps.aPropVar, szType);

		AddChildQueue(szFormatName, szPathName, mqQProps, szLocation, szType);
        aPropId.detach();
        aPropVar.detach();
    }

    return(hr);

}

class CLocalOutgoingFolder : public CLocalActiveFolder<CLocalOutgoingFolder>
{
public:
	virtual void AddChildQueue(CString &szFormatName, CString &, MQMGMTPROPS &mqQProps, 
							   CString &szLocation, CString &);
    CLocalOutgoingFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                         LPCTSTR strMachineName, LPCTSTR strDisplayName) : 
        CLocalActiveFolder<CLocalOutgoingFolder>(pParentNode, pComponentData, strMachineName, strDisplayName)
        {}
    virtual PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer);
};

class CLocalPublicFolder : public CLocalActiveFolder<CLocalPublicFolder>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalPublicFolder, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_NEW_PUBLIC_QUEUE, OnNewPublicQueue)
        CHAIN_SNAPINCOMMAND_MAP(CLocalActiveFolder<CLocalPublicFolder>)
	END_SNAPINCOMMAND_MAP()

   	UINT GetMenuID()
    {
        if (m_fUseIpAddress)
        {
            //
            // Admin using IP address. Do not allow creation of a new queue
            //
            return IDR_IPPUBLIC_MENU;
        }
        else
        {
            return IDR_LOCALPUBLIC_MENU;
        }
    }

	virtual void AddChildQueue(CString &szFormatName, 
                               CString &szPathName, 
                               MQMGMTPROPS &mqQProps, 
							   CString &szLocation, 
                               CString &szType);

    CLocalPublicFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                       LPCTSTR strMachineName, LPCTSTR strDisplayName, BOOL fUseIpAddress) : 
        CLocalActiveFolder<CLocalPublicFolder>(pParentNode, pComponentData, strMachineName, strDisplayName),
        m_fUseIpAddress(fUseIpAddress)
        {}
    virtual PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer);
    HRESULT  AddPublicQueueToScope(CString &strNewQueueFormatName, CString &strNewQueuePathName);
	HRESULT OnNewPublicQueue(bool &bHandled, CSnapInObjectRootBase* pObj);
	BOOL m_fUseIpAddress;
};


/****************************************************

        CLocalOutgoingQueue Class
    
 ****************************************************/

class CLocalOutgoingQueue : public CDisplayQueue<CLocalOutgoingQueue>
{
public:
	void InitState();

   	BEGIN_SNAPINCOMMAND_MAP(CLocalOutgoingQueue, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALOUTGOINGQUEUE_PAUSE,  OnPause)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALOUTGOINGQUEUE_RESUME, OnResume)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALOUTGOINGQUEUE_MENU)

    CLocalOutgoingQueue(CLocalOutgoingFolder * pParentNode, CSnapin * pComponentData, BOOL fOnLocalMachine = TRUE) : 
        CDisplayQueue<CLocalOutgoingQueue>(pParentNode, pComponentData )
    {
			m_mqProps.cProp = 0;
			m_mqProps.aPropID = NULL;
			m_mqProps.aPropVar = NULL;
			m_mqProps.aStatus = NULL;
            m_aDisplayList = pParentNode->GetDisplayList();
            m_dwNumDisplayProps = pParentNode->GetNumDisplayProps();
            m_fOnLocalMachine = fOnLocalMachine;
    }

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    
	virtual HRESULT PopulateScopeChildrenList();

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

protected:
    virtual void ApplyCustomDisplay(DWORD dwPropIndex);

private:
	//
	// Menu functions
	//
	HRESULT OnPause(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnResume(bool &bHandled, CSnapInObjectRootBase* pObj);

	BOOL m_fOnHold;			//Currently on Hold or not
    BOOL m_fOnLocalMachine;
};

/****************************************************

        CSnapinLocalAdmin Class
    
 ****************************************************/

class CSnapinLocalAdmin : public CNodeWithScopeChildrenList<CSnapinLocalAdmin, FALSE>
{
public:
    CString m_szMachineName;

	void SetState(LPCWSTR pszState);

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinLocalAdmin, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALADM_CONNECT, OnConnect)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALADM_DISCONNECT, OnDisconnect)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALADM_MENU)

    CSnapinLocalAdmin(CSnapInItem * pParentNode, CSnapin * pComponentData, CString strComputer) : 
        CNodeWithScopeChildrenList<CSnapinLocalAdmin, FALSE>(pParentNode, pComponentData ),
        m_szMachineName(strComputer),
        //
        // all these flags below are valid only for local admin of LOCAL machine
        //
        m_fIsDepClient(FALSE),
        m_fIsRouter(FALSE),
        m_fIsDs(FALSE),
        m_fAreFlagsInitialized(FALSE),
        m_fIsCluster(FALSE),
		m_fIsNT4Env(FALSE),
		m_fIsWorkgroup(FALSE),
		m_fIsLocalUser(FALSE)
    {
        CheckIfIpAddress();

		InitServiceFlags();            
    }

	~CSnapinLocalAdmin()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateScopeChildrenList();

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

    HRESULT CreateStoragePage (OUT HPROPSHEETPAGE *phStoragePage);
    
    HRESULT CreateLocalUserCertPage (OUT HPROPSHEETPAGE *phLocalUserCertPage);

    HRESULT CreateMobilePage (OUT HPROPSHEETPAGE *phMobilePage);

    HRESULT CreateClientPage (OUT HPROPSHEETPAGE *phClientPage);
    
    HRESULT CreateServiceSecurityPage (OUT HPROPSHEETPAGE *phServiceSecurityPage);

    const BOOL IsThisMachineDepClient()
    {
        return m_fIsDepClient;
    }

private:

	//
	// Menu functions
	//
	HRESULT OnConnect(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnDisconnect(bool &bHandled, CSnapInObjectRootBase* pObj);

    //
    // Identify if computer name is an IP address.
    // IP address contains exactly three dots, and the rest are digits
    //
    void CheckIfIpAddress()
    {
        int i = 0;
        int len = m_szMachineName.GetLength();

        DWORD dwNumDots = 0;
        m_fUseIpAddress = TRUE;

        while(i < len)
        {
            if (m_szMachineName[i] == _T('.'))
            {
                dwNumDots++;
            }
            else if (m_szMachineName[i] < _T('0') || m_szMachineName[i] > _T('9'))
            {
                //
                // Not a digit. Can't be an IP address
                //
                m_fUseIpAddress = FALSE;
                break;
            }
            i++;
        }

        if (dwNumDots != 3)
        {
            //
            // Contains more or less than three dots. Can't be an IP address
            //
            m_fUseIpAddress = FALSE;
        }
    }

    BOOL ConfirmConnection(UINT nFormatID);

	BOOL	m_bConnected;	//MSMQ Currently connected or disconnected
	BOOL    m_fUseIpAddress;    

    //
    // all these flags are valid only for local admin of LOCAL machine
    //
    void InitServiceFlags();
    HRESULT InitAllMachinesFlags();
    HRESULT InitServiceFlagsInternal();
	HRESULT CheckEnvironment(BOOL fIsWorkgroup, BOOL* pfIsNT4Env);
    BOOL   m_fIsDepClient;
    BOOL   m_fIsRouter;
    BOOL   m_fIsDs;
    BOOL   m_fAreFlagsInitialized;
    BOOL   m_fIsCluster;
	BOOL   m_fIsNT4Env;
	BOOL   m_fIsWorkgroup;
	BOOL   m_fIsLocalUser;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localcrt.cpp ===
//
// Security.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "localcrt.h"
#include <mqtempl.h>
#include <mqcrypt.h>
#include <_registr.h>
#include <mqsec.h>
#include <mqnames.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <rt.h>
#include <mqcertui.h>
#include <rtcert.h>
#include <_secutil.h>
#include "globals.h"

#include "localcrt.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage property page

IMPLEMENT_DYNCREATE(CLocalUserCertPage, CMqPropertyPage)

CLocalUserCertPage::CLocalUserCertPage() :
    CMqPropertyPage(CLocalUserCertPage::IDD)
{
    //{{AFX_DATA_INIT(CLocalUserCertPage)
    //}}AFX_DATA_INIT

    m_fModified = FALSE;
}

CLocalUserCertPage::~CLocalUserCertPage()
{
}

void CLocalUserCertPage::DoDataExchange(CDataExchange* pDX)
{
    CMqPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLocalUserCertPage)
    //}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(CLocalUserCertPage, CMqPropertyPage)
    //{{AFX_MSG_MAP(CLocalUserCertPage)
    ON_BN_CLICKED(ID_Register, OnRegister)
    ON_BN_CLICKED(ID_Remove, OnRemove)
    ON_BN_CLICKED(ID_View, OnView)
    ON_BN_CLICKED(ID_RenewCert, OnRenewCert)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage message handlers

void CLocalUserCertPage::OnRegister()
{
    HRESULT hr = MQ_OK ;
    CString strErrorMsg;
    R<CMQSigCertificate> pCert;
    static s_fCreateCert = TRUE ;
    BOOL   fCertCreated = FALSE ;

    //
    // don't check the return code from this api.
    // in MSMQ1.0, and in nt5 beta2, this api (RTCreateInternalCertificate)
    // was called whenever user run the msmq control panel. If a certificate
    // already exist then the api do nothing. The certificate was used
    // only here in "OnRegister". So we keep same semantic and are compatible
    // with new api MQRegisterCertificate(). If user does not explicitely
    // press "register", or "renewInternal", then an internal certificate is
    // not created on the machine.
    //
    if (s_fCreateCert)
    {
        hr = RTCreateInternalCertificate( NULL ) ;
        s_fCreateCert = FALSE ;
        if (SUCCEEDED(hr))
        {
            fCertCreated = TRUE ;
        }
    }
    else
    {
        //
        // Create an internal certificate only of not already exist.
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                FALSE,
                                FALSE,
                                NULL) ;
        if (FAILED(hr))
        {
            hr = RTCreateInternalCertificate( NULL ) ;
            if (SUCCEEDED(hr))
            {
                fCertCreated = TRUE ;
            }
        }
    }

    if (SelectPersonalCertificateForRegister(m_hWnd, NULL, 0, &pCert.ref()))
    {
        CWaitCursor wait; //display hourglass cursor
        hr = RTRegisterUserCert( pCert.get(),
                                 FALSE  ) ; //fMachine

        switch(hr)
        {
        case MQ_OK:
            break;
        case MQ_ERROR_INTERNAL_USER_CERT_EXIST:
            strErrorMsg.LoadString(IDS_CERT_EXIST1);
            AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);
            break;
        default:
            if (FAILED(hr))
            {
				MessageDSError(hr, IDS_REGISTER_ERROR1);
            }
            break;
        }
    }
    else if (fCertCreated)
    {
        //
        // If an internal certificate was created then delete it.
        // It was not registered in DS and we don't want to keep it
        // localy in registry.
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                TRUE,
                                FALSE,
                                NULL) ;
        if (SUCCEEDED(hr))
        {
            hr = RTDeleteInternalCert(pCertInt.get());
        }
    }
}

//+----------------------------------
//
//  void CLocalUserCertPage::OnRemove()
//
//+----------------------------------

void CLocalUserCertPage::OnRemove()
{
    HRESULT hr;
    R<CMQSigCertificate> p32Certs[32];
    AP< R<CMQSigCertificate> > pManyCerts = NULL;
    CMQSigCertificate **pCerts = &p32Certs[0].ref();
    DWORD nCerts = 32;
    CMQSigCertificate *pCertRem;
    CString strErrorMessage;

    CWaitCursor wait; //display hourglass cursor
    hr = RTGetUserCerts(pCerts, &nCerts, NULL);

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
        return;
    }

    if (nCerts > 32)
    {
        pManyCerts = new R<CMQSigCertificate>[nCerts];
        pCerts = &pManyCerts[0].ref();
        hr = RTGetUserCerts(pCerts, &nCerts, NULL);
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
            return;
        }
    }

    if (SelectPersonalCertificateForRemoval(m_hWnd, &pCerts[0], nCerts, &pCertRem))
    {
        hr = RTRemoveUserCert(pCertRem);
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_DELETE_USER_CERT_ERROR1);
            return;
        }

        //
        // If this is the internal certificate, then remove it from
        // local store (local HKCU registry) too.
        // Don't display any error if this fail.
        // That's new behavior of MSMQ2.0 !!!
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                TRUE,
                                FALSE,
                                NULL) ;
        if (SUCCEEDED(hr))
        {
            BYTE *pCertIntBlob = NULL ;
            DWORD dwCertIntSize = 0 ;
            hr = pCertInt->GetCertBlob( &pCertIntBlob,
                                        &dwCertIntSize ) ;

            BYTE *pCertRemBlob = NULL ;
            DWORD dwCertRemSize = 0 ;
            HRESULT hr1 = pCertRem->GetCertBlob( &pCertRemBlob,
                                                 &dwCertRemSize ) ;

            if (SUCCEEDED(hr) && SUCCEEDED(hr1))
            {
                if (dwCertRemSize == dwCertIntSize)
                {
                    ASSERT(dwCertRemSize != 0) ;

                    if (memcmp( pCertIntBlob,
                                pCertRemBlob,
                                dwCertIntSize ) == 0)
                    {
                        //
                        // The removed certificate is the internal one.
                        // delete from local store.
                        //
                        hr = RTDeleteInternalCert(pCertInt.get());
                        ASSERT(SUCCEEDED(hr)) ;
                    }
                }
            }
        }
    }
}


void CLocalUserCertPage::OnView()
{
    HRESULT hr;
    R<CMQSigCertificate> p32Certs[32];
    AP< R<CMQSigCertificate> > pManyCerts = NULL;
    CMQSigCertificate **pCerts = &p32Certs[0].ref();
    DWORD nCerts = 32;
    CString strErrorMessage;

    CWaitCursor wait; //display hourglass cursor
    hr = RTGetUserCerts(pCerts, &nCerts, NULL);
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
        return;
    }

    if (nCerts > 32)
    {
        pManyCerts = new R<CMQSigCertificate>[nCerts];
        pCerts = &pManyCerts[0].ref();
        hr = RTGetUserCerts(pCerts, &nCerts, NULL);
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
            return;
        }
    }

    ShowPersonalCertificates(m_hWnd, &pCerts[0], nCerts);
}

void CLocalUserCertPage::OnRenewCert()
{
    HRESULT hr;
    CString strCaption;
    CString strMessage;

    strMessage.LoadString(IDS_CERT_WARNING);
    if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
    {
        return;
    }

    CWaitCursor wait; //display hourglass cursor

    //
    // If we have an internal certificate, remove it.
    //
    R<CMQSigCertStore> pStore = NULL ;
    R<CMQSigCertificate> pCert = NULL ;

    hr = RTGetInternalCert(&pCert.ref(),
                           &pStore.ref(),
                            TRUE,
                            FALSE,
                            NULL) ;
     //
     // Open the certificates store with write access, so we can later
     // delete the internal certificate, before creating a new one.
     //

    if (SUCCEEDED(hr))
    {
		//
		// Hack!! Lets check if the PEC is online
		// and permissions are OK. To do so, we will write
		// the certificate in DS, to remove it right after
		// (RaphiR)
		//
		hr = RTRegisterUserCert( pCert.get(),
                                 FALSE  ) ; //fMachine
        if (SUCCEEDED(hr))
        {
            //
            // This internal certifcate was not yet registered in DS.
            // That's OK, go on !
            //
        }
        else if ((hr == MQ_ERROR_INTERNAL_USER_CERT_EXIST) ||
                 (hr == MQ_ERROR_INVALID_CERTIFICATE))
        {
            //
            // That's ok. we're not interested in errors indicating that
            // the certificate is already registered or is not valid.
            // We're mainly interested in NO_DS and ACCESS_DENIED errors.
            //
            // Note: the INVALID_CERTIFICATE can happen in the following
            // scenario:
            // 1. install win95 + msqm in domain A and run control panel.
            //    This will create an internal certificate in registry.
            // 2. remove msmq and login as user of domain B.
            // 3. reinstall msmq.
            // 4. upgrade to win2k and login as same user of domain B
            // 5. Now try to renew internal certificate. The problem is
            //    that the certificate of user of domain A (from first
            //    step) is still in registry.
            // Anyway, if present internal certificate is not valid, then
            // we certainly want to remove it from DS and create anothe one.
            //
            // Go on !
            //
        }
        else
        {
			MessageDSError(hr, IDS_CREATE_INTERNAL_CERT_ERROR1);
			return;
        }

        //
        // Remove the internal certificate from MQIS.
        //
        hr = RTRemoveUserCert(pCert.get()) ;
        if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
        {
            strMessage.LoadString(IDS_UNREGISTER_ERROR);
            if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            {
                return;
            }
        }

        //
        // Remove the internal certificate from the certificate store.
        //
        hr = RTDeleteInternalCert(pCert.get());
        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            strMessage.LoadString(IDS_DELETE_ERROR);
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
            return;
        }
    }

    //
    // Create the new internal certificate.
    //
    pCert.free();
    hr = RTCreateInternalCertificate( &pCert.ref() ) ;
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_CREATE_INTERNAL_CERT_ERROR1);
        return;
    }

    //
    // Register the newly created internal certificate in MQIS.
    //
    hr = RTRegisterUserCert( pCert.get(),
                             FALSE  ) ; //fMachine
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_REGISTER_ERROR1);
        return;
    }

    //
    // Display a confirmation message box.
    //
    strMessage.LoadString(IDS_INTERNAL_CERT_RENEWED);
    AfxMessageBox(strMessage, MB_OK | MB_ICONINFORMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localutl.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	cplutil.h

Abstract:

	Definition for the control panel utility function
Author:

    TatianaS


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __CPLUTIL_H_
#define __CPLUTIL_H_
#include "resource.h"

//cplutil.cpp
BOOL IsDirectory (HWND hWnd, LPCTSTR name);
void DisplayFailDialog();
void GetLastErrorText(CString &strErrorText);
BOOL SetDirectorySecurity(LPCTSTR szDirectory);
BOOL MoveFiles(
    LPCTSTR pszSrcDir,
    LPCTSTR pszDestDir,
    LPCTSTR pszFileProto,
    BOOL fRecovery =FALSE);
BOOL OnRestartWindows();

CString GetToken(LPCTSTR& p, TCHAR delimeter) throw();

//service.cpp
BOOL GetServiceRunningState(BOOL *pfServiceIsRunning);
BOOL StopService();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localcrt.h ===
// localcrt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage dialog

#include <mqtempl.h>
#include <mqprops.h>

class CLocalUserCertPage : public CMqPropertyPage
{
    DECLARE_DYNCREATE(CLocalUserCertPage)

// Construction
public:
    CLocalUserCertPage();  
    ~CLocalUserCertPage();       

// Dialog Data
    //{{AFX_DATA(CLocalUserCertPage)
    enum { IDD = IDD_LOCAL_USERCERT };   
    //}}AFX_DATA
    
// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLocalUserCertPage)
    public:    
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLocalUserCertPage)
    afx_msg void OnRegister();
    afx_msg void OnRemove();
    afx_msg void OnView();    
    afx_msg void OnRenewCert();    
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\lqdsply.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	lqDsply.cpp

Abstract:

	Display functions
Author:

    YoelA, Raphir


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "lqDsply.h"

#include "lqdsply.tmh"


//////////////////////////////////////////////////////////////////////////////
/*++

FreeMqProps

  Free all properties allocated by MSMQ

--*/
//////////////////////////////////////////////////////////////////////////////
void FreeMqProps(MQMGMTPROPS * mqProps)
{
	//
	// Free all the properties allocated by MSMQ
	//
	for(DWORD i = 0; i < mqProps->cProp; i++)
	{
		switch(mqProps->aPropVar[i].vt)
		{
		case VT_NULL:
		case VT_UI4:
		case VT_I4:
        case VT_UI1:
        case VT_I2:
			break;

		case VT_LPWSTR:
			MQFreeMemory(mqProps->aPropVar[i].pwszVal);
			break;

		case VT_CLSID:
			MQFreeMemory(mqProps->aPropVar[i].puuid);
			break;

		case VT_BLOB:
			MQFreeMemory(mqProps->aPropVar[i].blob.pBlobData);
			break;

		case (VT_VECTOR | VT_LPWSTR):
			{
				for(DWORD j = 0; j < mqProps->aPropVar[i].calpwstr.cElems; j++)
					MQFreeMemory(mqProps->aPropVar[i].calpwstr.pElems[j]);

				MQFreeMemory(mqProps->aPropVar[i].calpwstr.pElems);

				break;
			}

		default:

			ASSERT(0);
		}
	}

	//
	// Remove other allocations
	//
	delete [] mqProps->aStatus;
	delete [] mqProps->aPropID;
	delete [] mqProps->aPropVar;

	//
	// To be on the safe side...
	// 
	mqProps->cProp = 0;
	mqProps->aPropID = NULL;
	mqProps->aPropVar = NULL;
	mqProps->aStatus = NULL;


}


//////////////////////////////////////////////////////////////////////////////
/*++

GetStringPropertyValue

  Return the string value of a pid

--*/
//////////////////////////////////////////////////////////////////////////////
void GetStringPropertyValue(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString &str)
{
	PROPVARIANT * pProp;

	GetPropertyVar(pItem, pid, pPropVar, &pProp);

	if(pProp->vt == VT_NULL)
	{
		str = L"";
		return;
	}

	ASSERT(pProp->vt == VT_LPWSTR);

	str = pProp->pwszVal;

	return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\localutl.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	cplutil.cpp

Abstract:

	Implementation file for the control panel utility function

Author:

    TatianaS


--*/
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "localutl.h"
#include "mqcast.h"
#include "bkupres.h"

#include "localutl.tmh"

#define STORAGE_DIR_INHERIT_FLAG \
                       (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)

//////////////////////////////////////////////////////////////////////////////
/*++

 Function -
      SetDirectorySecurity.

 Parameter -
      szDirectory - The directory for which to set the security.

 Return Value -
      TRUE if successfull, else FALSE.

 Description -
      The function sets the security of the given directory such that
      any file that is created in the directory will have full control for
      the local administrators group and no access at all to anybody else.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL
SetDirectorySecurity(
    LPCTSTR szDirectory)
{
    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid))
    {
        return FALSE;
    }

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    P<ACL> pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = DWORD_TO_WORD(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    P<ACCESS_ALLOWED_ACE> pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = STORAGE_DIR_INHERIT_FLAG ;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    BOOL fRet = TRUE;

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, &SD))
    {
        fRet = FALSE;
    }

    FreeSid(pAdminSid);

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
/*++

 Get the text string that explains the error code returned by
 GetLastError()
--*/
//////////////////////////////////////////////////////////////////////////////

void GetLastErrorText(CString &strErrorText)
{
    LPTSTR szError;

    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            GetLastError(),
            0,
            (LPTSTR)&szError,
            128,
            NULL) == 0)
    {
        //
        // Faield in FormatMessage, so just display the error number.
        //
        strErrorText.FormatMessage(IDS_ERROR_CODE, GetLastError());
    }
    else
    {
        strErrorText = szError;
        LocalFree(szError);
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++


 Function -
      IsProperDirectorySecurity.

 Parameter -
      szDirectory - The directory for which to check the security.

 Return Value -
      TRUE if successfull and the security is OK, else FALSE.

 Description -
      The function verifies that the security of a given directory is set
      properly so that the files in the storage directory will be secured.

--*/
//////////////////////////////////////////////////////////////////////////////

static
BOOL
IsProperDirectorySecurity(
    LPCTSTR szDirectory)
{
    DWORD dwSdLen;

    //
    // Get the size of the directory security descriptor.
    //
    if (GetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, NULL, 0, &dwSdLen) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Get the directory security descriptor and retrieve the DACL out of it.
    //
    AP<BYTE> pbSd_buff = new BYTE[dwSdLen];
    PSECURITY_DESCRIPTOR pSd = (PSECURITY_DESCRIPTOR)pbSd_buff;
    BOOL bPresent;
    PACL pDacl;
    BOOL bDefault;

    if (!GetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, pSd, dwSdLen, &dwSdLen) ||
        !GetSecurityDescriptorDacl(pSd, &bPresent, &pDacl, &bDefault) ||
        !bPresent ||
        !pDacl)
    {
        return FALSE;
    }

    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid0;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid0))
    {
        return FALSE;
    }

    //
    // Copy the admin SID into a buffer that is freed automatically, and free
    // the SID that was allocated by the system.
    //
    DWORD dwAdminSidLen = GetLengthSid(pAdminSid0);
    AP<BYTE> pAdminSid_buff = new BYTE[dwAdminSidLen];
    PSID pAdminSid = (PSID)pAdminSid_buff;

    CopySid(dwAdminSidLen, pAdminSid, pAdminSid0);
    FreeSid(pAdminSid0);

    //
    // Get the ACE count of the security descriptor. There should be two ACEs there.
    // Retrieve the first ACE.
    //
    ACL_SIZE_INFORMATION AclInfo;
    LPVOID pAce0;

    if (!GetAclInformation(pDacl, &AclInfo, sizeof(AclInfo), AclSizeInformation) ||
        (AclInfo.AceCount != 2) ||
        !GetAce(pDacl, 0, &pAce0))
    {
        return FALSE;
    }

    //
    // See that the first ACE grant full control for the admin on the diretory it self.
    // And retrieve the second ACE.
    //
    PACCESS_ALLOWED_ACE pAce = (PACCESS_ALLOWED_ACE) pAce0;

    if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) ||
        (pAce->Header.AceFlags != 0) ||
        (pAce->Mask != FILE_ALL_ACCESS) ||
        !EqualSid(&pAce->SidStart, pAdminSid) ||
        !GetAce(pDacl, 1, &pAce0))
    {
        return FALSE;
    }

    //
    // See that the second ACE is an inherit ACE that sets the security of files in
    // the directory to full control for the admin.
    //
    pAce = (PACCESS_ALLOWED_ACE) pAce0;

    if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)   ||
        (pAce->Header.AceFlags != STORAGE_DIR_INHERIT_FLAG) ||
        (pAce->Mask != FILE_ALL_ACCESS)                     ||
        !EqualSid(&pAce->SidStart, pAdminSid))
    {
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

 If the passed string is of an existing directory on
 a fixed local drive.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL IsDirectory (HWND hWnd, LPCTSTR name)
{
    DWORD status;
    TCHAR szDrive[4];
    CString strError;
    CString strMessage;

    //
    // Does the path start with d: ?
    //
    if (!isalpha(name[0]) && (name[1] != ':'))
    {
        strError.FormatMessage(IDS_NOT_A_DIR, name);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    szDrive[0] = name[0];
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';

    //
    // See if the drive is a fixed drive. We only allow fixed drives.
    //
    if (GetDriveType(szDrive) != DRIVE_FIXED)
    {
        strError.FormatMessage(IDS_LOCAL_DRIVE, szDrive);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

    //
    // See whether this is a name of a directory.
    //
    status = GetFileAttributes(name);

    if (status == 0xFFFFFFFF)
    {
        //
        // The directory does not exist. Ask the user whether she wants to
        // create the directory.
        //
        strMessage.FormatMessage(IDS_ASK_CREATE_DIR, name);       
       
        if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
        {
            //
            // No thank you!
            //
            return FALSE;
        }

        //
        // OK, create the directory.
        //
        if (CreateDirectory(name, NULL))
        {
            //
            // The directory was created, set it's security.
            //
            if (!SetDirectorySecurity(name))
            {
                //
                // Faield to set the security on the directory. Delete the directory
                // and notify the user.
                //
                RemoveDirectory(name);

                GetLastErrorText(strError);
                strMessage.FormatMessage(IDS_SET_DIR_SECURITY_ERROR, name, (LPCTSTR)strError);
                AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

                return FALSE;
            }
            else
            {
                if (!IsProperDirectorySecurity(name))
                {
                    //
                    // This appears to be a FAT drive. Ask the user if she wants to use
                    // it anyway, without security.
                    //
                    strMessage.FormatMessage(IDS_FAT_WARNING, name);
                   
                    if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
                    {
                        //
                        // No thank you!
                        //
                        RemoveDirectory(name);
                        return FALSE;
                    }
                }
            }

            return TRUE;
        }
        else
        {
            //
            // Faield to create the directory, notify the user.
            //
            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_CREATE_DIR_ERROR, name, (LPCTSTR)strError);
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            return FALSE;
        }
    }
    else if (!(status & FILE_ATTRIBUTE_DIRECTORY))
    {
        //
        // This is not a directory (a file or what?)
        //
        strError.FormatMessage(IDS_NOT_A_DIR, name);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

    //
    // We got here because the directory is a valid existing directory, so
    // only see if the security is OK, if not, notify the user.
    //
    if (!IsProperDirectorySecurity(name))
    {
        strMessage.FormatMessage(IDS_DIR_SECURITY_WARNING, name);
        AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
    }

    return TRUE;
}

//
// display "Falcon not installed properlly" message
//
void DisplayFailDialog()
{       
    AfxMessageBox(IDS_REGISTRY_ERROR, MB_OK | MB_ICONEXCLAMATION);
}


//////////////////////////////////////////////////////////////////////////////
/*++

 Move files from source directory to a destination directory.
 If one of the files failed to move, the fiels that were already
 moved are placed back in the original source directory.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL MoveFiles(
    LPCTSTR pszSrcDir,
    LPCTSTR pszDestDir,
    LPCTSTR pszFileProto,
    BOOL fRecovery)
{
    TCHAR szSrcDir[MAX_PATH] = {0};
    TCHAR szSrcFile[MAX_PATH];
    TCHAR szDestDir[MAX_PATH] = {0};
    TCHAR szDestFile[MAX_PATH];

    //
    // Get the source directory and source file prototype
    //
	_tcsncpy(szSrcDir,pszSrcDir, (MAX_PATH-2-_tcslen(pszFileProto)));
    _tcscat(szSrcDir, TEXT("\\"));
    _tcscat(_tcscpy(szSrcFile, szSrcDir), pszFileProto);

    //
    // Get the destination directory
    //
	_tcsncpy(szDestDir,pszDestDir, MAX_PATH - 2);
    _tcscat(szDestDir, TEXT("\\"));

    //
    // Find the first file to be moved.
    //
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(szSrcFile, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // No files to move.
        //
        return TRUE;
    }

    do
    {
        //
        // Skip directories.
        //
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
            (FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            continue;
        }

        //
        // Get the full path of the source file and destination file.
        //
        _tcsncat(_tcscpy(szDestFile, szDestDir), FindData.cFileName, (MAX_PATH-1-_tcslen(szDestDir)));
        _tcsncat(_tcscpy(szSrcFile, szSrcDir), FindData.cFileName, (MAX_PATH-1-_tcslen(szSrcDir)));

        //
        // Move the file
        //
        if (!MoveFile(szSrcFile, szDestFile))
        {
            //
            // Faield to move the file, display an error message and try to
            // roll back.
            //
            CString strMessage;
            CString strError;

            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_MOVE_FILE_ERROR,
                (LPCTSTR)szSrcFile, (LPCTSTR)szDestFile, (LPCTSTR)strError);            
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            //
            // Try to roll back - do not roll back if failed while rolling back.
            //
            if (!fRecovery)
            {
                if (!MoveFiles(pszDestDir, pszSrcDir, pszFileProto, TRUE))
                {
                    //
                    // Failed to roll back, display and error message.
                    //
                    strMessage.LoadString(IDS_MOVE_FILES_RECOVERY_ERROR);
                    AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
                }
            }
            return FALSE;
        }
        //
        // Get the name of the next file to move.
        //
    } while (FindNextFile(hFindFile, &FindData));

    //
    // If we got this far, were all done successfully.
    //
    return TRUE;
}

//
// Reboot Windows
//
BOOL RestartWindows()
{
    HANDLE hToken;              // handle to process token
    TOKEN_PRIVILEGES tkp;       // ptr. to token structure


     //
     // Get the current process token handle
     // so we can get shutdown privilege.
     //

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
    {
        return FALSE;
    }

    // Get the LUID for shutdown privilege.

    if (!LookupPrivilegeValue(NULL, TEXT("SeShutdownPrivilege"),
                              &tkp.Privileges[0].Luid))
    {
        return FALSE;
    }

    tkp.PrivilegeCount = 1;  // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Get shutdown privilege for this process.

    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                               (PTOKEN_PRIVILEGES) NULL, 0))
    {
        return FALSE;
    }

    // Cannot test the return value of AdjustTokenPrivileges.

    if (!ExitWindowsEx(EWX_FORCE|EWX_REBOOT,0))
    {
        return FALSE;
    }

    // Disable shutdown privilege.

    tkp.Privileges[0].Attributes = 0;
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                          (PTOKEN_PRIVILEGES) NULL, 0);

    return(TRUE);
}

BOOL OnRestartWindows()
{
    BOOL fRet = RestartWindows();

    if (!fRet)
    {
        CString strMessage;
        CString strErrorText;

        GetLastErrorText(strErrorText);
        strMessage.FormatMessage(IDS_RESTART_WINDOWS_ERROR, (LPCTSTR)strErrorText);
        AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);       
    }

    return fRet;
}


CString GetToken(LPCTSTR& p, TCHAR delimeter) throw()
{
    //
    // Trim leading whitespace characters from the string
    //
    for(;*p != NULL && iswspace(*p); ++p)
    {
        NULL;
    }

    if (p == NULL)
        return CString();

    LPCTSTR pDelimeter = _tcschr(p, delimeter);
    LPCTSTR pBegin = p;

    if (pDelimeter == NULL)
    {
        p += _tcslen(p);
        return CString(pBegin);
    }

    p = pDelimeter;

    for(--pDelimeter; (pDelimeter >= pBegin) && iswspace(*pDelimeter); --pDelimeter)
    {
        NULL;
    }

    return CString(pBegin, numeric_cast<int>(pDelimeter - pBegin + 1));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\machdomain.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.h

Abstract:

	machine domain declarations

Author:		 

    Ilan  Herbst  (ilanh)  12-Mar-2001

--*/

#ifndef __MACHDOMAIN_H_
#define __MACHDOMAIN_H_

LPCWSTR MachineDomain(LPCWSTR pMachineName);

LPCWSTR MachineDomain();

LPCWSTR LocalMachineDomain();

#endif // __MACHDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\machdomain.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.cpp

Abstract:

	Handle machine domain

Author:		 

    Ilan  Herbst  (ilanh)  12-Mar-2001

--*/

#include "stdafx.h"
#include "globals.h"
#include "machdomain.h"
#include "autoreln.h"
#include "Dsgetdc.h"
#include <lm.h>
#include <lmapibuf.h>
#include "uniansi.h"
#include "tr.h"

#include "machdomain.tmh"

const TraceIdEntry MachDomain = L"MACHINE DOMAIN";

static LPWSTR FindMachineDomain(LPCWSTR pMachineName)
/*++
Routine Description:
	Find machine domain

Arguments:
	pMachineName - machine name

Returned Value:
	machine domain, NULL if not found

--*/
{
	TrTRACE(MachDomain, "FindMachineDomain(), MachineName = %ls", pMachineName);

	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					pMachineName, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		TrERROR(MachDomain, "FindMachineDomain(), DsGetDcName failed, error = %d", dw);
		return NULL;
	}

	ASSERT(pDcInfo->DomainName != NULL);
	TrTRACE(MachDomain, "DoamainName = %ls", pDcInfo->DomainName);
	AP<WCHAR> pMachineDomain = new WCHAR[wcslen(pDcInfo->DomainName) + 1];
    wcscpy(pMachineDomain, pDcInfo->DomainName);
	return pMachineDomain.detach();
}


static AP<WCHAR> s_pMachineName;
static AP<WCHAR> s_pMachineDomain; 

static bool s_fInitialize = false;

LPCWSTR MachineDomain(LPCWSTR pMachineName)
/*++
Routine Description:
	find machine domain.

Arguments:
	pMachineName - machine name

Returned Value:
	return machine domain

--*/
{
	if(s_fInitialize)
	{
	    if(CompareStringsNoCase(s_pMachineName, pMachineName) == 0)
		{
			//
			// Same machine name
			//
			return s_pMachineDomain;
		}

		//
		// Free previously machine domain
		//
		s_fInitialize = false;
		s_pMachineDomain.free();
	}

	//
	// Get computer domain
	//
	AP<WCHAR> pMachineDomain = FindMachineDomain(pMachineName);

	if(NULL != InterlockedCompareExchangePointer(
					&s_pMachineDomain.ref_unsafe(), 
					pMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fInitialize);
		ASSERT(s_pMachineDomain != NULL);
		ASSERT(CompareStringsNoCase(s_pMachineName, pMachineName) == 0);
		return s_pMachineDomain;
	}

	//
	// The exchange was done
	//
	ASSERT(s_pMachineDomain == pMachineDomain);
	pMachineDomain.detach();

	//
	// Update the machine name
	//
	s_pMachineName.free();
	s_pMachineName = newwcs(pMachineName);

	s_fInitialize = true;
	TrTRACE(MachDomain, "Initialize machine domain: machine = %ls", s_pMachineName.get());
	TrTRACE(MachDomain, "machine domain = %ls", s_pMachineDomain.get());
	return s_pMachineDomain;
}


LPCWSTR MachineDomain()
/*++
Routine Description:
	get current machine domain.

Arguments:

Returned Value:
	return current machine domain

--*/
{
	ASSERT(s_fInitialize);
	return s_pMachineDomain;
}


static bool s_fLocalInitialize = false;
static AP<WCHAR> s_pLocalMachineDomain; 

LPCWSTR LocalMachineDomain()
/*++
Routine Description:
	get local machine domain.

Arguments:

Returned Value:
	return local machine domain

--*/
{
	if(s_fLocalInitialize)
	{
		return s_pLocalMachineDomain;
	}

	//
	// Get local computer domain
	//
	AP<WCHAR> pLocalMachineDomain = FindMachineDomain(NULL);

	if(NULL != InterlockedCompareExchangePointer(
					&s_pLocalMachineDomain.ref_unsafe(), 
					pLocalMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fLocalInitialize);
		ASSERT(s_pLocalMachineDomain != NULL);
		return s_pLocalMachineDomain;
	}

	//
	// The exchange was done
	//
	ASSERT(s_pLocalMachineDomain == pLocalMachineDomain);
	pLocalMachineDomain.detach();

	s_fLocalInitialize = true;
	TrTRACE(MachDomain, "local machine domain = %ls", s_pLocalMachineDomain.get());
	return s_pLocalMachineDomain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\machtrac.cpp ===
// MachineTracking.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "dsext.h"
#include "admmsg.h"
#include "mqppage.h"
#include "testmsg.h"
#include "Machtrac.h"

#include "machtrac.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking property page

IMPLEMENT_DYNCREATE(CMachineTracking, CMqDialog)

CMachineTracking::CMachineTracking(
	const GUID& gMachineID /* = GUID_NULL */, 
	const CString& strDomainController /* CString(L"") */
	) : 
	CMqDialog(CMachineTracking::IDD), m_gMachineID(gMachineID),
	m_strDomainController(strDomainController)
{
    
    //{{AFX_DATA_INIT(CMachineTracking)
	m_ReportQueueName = _T("");
    m_iTestButton = 0;
	//}}AFX_DATA_INIT
    m_LastReportQName = _T("");
}

CMachineTracking::~CMachineTracking()
{
}

void CMachineTracking::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMachineTracking)
	DDX_Control(pDX, IDC_REPORTQUEUE_NAME, m_ReportQueueCtrl);
	DDX_CBString(pDX, IDC_REPORTQUEUE_NAME, m_ReportQueueName);
    DDX_Radio(pDX, IDC_TRACK_ALL, m_iTestButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMachineTracking, CMqDialog)
	//{{AFX_MSG_MAP(CMachineTracking)
	ON_BN_CLICKED(IDC_REPORTQUEUE_NEW, OnReportqueueNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking message handlers

BOOL CMachineTracking::OnInitDialog() 
{
	CMqDialog::OnInitDialog();
	CWaitCursor wc;

    //
    // Initialize report queue name combo box
    //
    GUID TestGuidType = MQ_QTYPE_REPORT;
    CComboBox *pcomboName = (CComboBox *)GetDlgItem(IDC_REPORTQUEUE_NAME);

	//
    // Query the DS for all the report-queues and insert them into 
    // the combo-box
    //
    CRestriction restriction;
    restriction.AddRestriction(&TestGuidType, PROPID_Q_TYPE, PREQ, 0);

    //
    // Insert blank to the top of the list
    //
    CString strNone;
    strNone.LoadString(IDS_LB_NONE);
    pcomboName->AddString(strNone);

    //
    // Insert the name of all the report queues to the list
    //
    CColumns columns;
    columns.Add(PROPID_Q_PATHNAME);
    columns.Add(PROPID_Q_INSTANCE);

    const DWORD x_dwResultBufferSize = 64;
    PROPVARIANT apResultProps[x_dwResultBufferSize];
    DWORD dwPropCount = x_dwResultBufferSize;
  
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryQueues(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    restriction.CastToStruct(),
                    columns.CastToStruct(),
                    0,
                    &hEnume
                    );
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        EndDialog(IDCANCEL);
        return TRUE;
    }

    while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
            && (dwPropCount != 0) )
    {
        for (DWORD i=0; i<dwPropCount; i++)
        {
            int iItem = m_ReportQueueCtrl.AddString(apResultProps[i].pwszVal);
            MQFreeMemory(apResultProps[i].pwszVal);

            i++;
            INT_PTR iArrayIndex = m_aguidAllQueues.Add(*apResultProps[i].puuid);
            m_ReportQueueCtrl.SetItemData(iItem, iArrayIndex);
            MQFreeMemory(apResultProps[i].puuid);
        }
        dwPropCount = x_dwResultBufferSize;
    }

    HRESULT rc = GetQMReportQueue(m_gMachineID, m_ReportQueueName, m_strDomainController);

    if (FAILED(rc))
    {
        MessageDSError(rc, IDS_CANNOT_GET_REPORT_QUEUE);
        m_ReportQueueName = strNone;
    }
    else
    {
        if (m_ReportQueueName.IsEmpty())
        {
            m_ReportQueueName = strNone;
        }
        m_LastReportQName = m_ReportQueueName;
    }

    //
    // Retrieve state of test all (propagate) flag from machine
    //
    hr = GetQMReportState(m_gMachineID, m_fTestAll);

    m_iTestButton = m_fTestAll ? 0 : 1;

    if(FAILED(hr))
    {
        MessageDSError(rc, IDS_CANNOT_GET_TRACKING_FLAG);
        EndDialog(IDCANCEL);
        return(TRUE);
    }

    //
    //  data has changed, update it
    //
    UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMachineTracking::OnOK() 
{
    UpdateData(TRUE);

    HRESULT hr;
    if (m_LastReportQName != m_ReportQueueName)
    {
        CString strNone;
        strNone.LoadString(IDS_LB_NONE);

        if (m_ReportQueueName != strNone)
        {
            int iReportQueueIndex = m_ReportQueueCtrl.GetCurSel();
            UINT_PTR uiGuidIndex = m_ReportQueueCtrl.GetItemData(iReportQueueIndex);
            hr = SetQMReportQueue(m_gMachineID, m_aguidAllQueues[uiGuidIndex]);
        }
        else
        {
            hr = SetQMReportQueue(m_gMachineID, GUID_NULL);
        }
            
        if(FAILED(hr))
        {
            MessageDSError(hr, IDS_OP_SET_REPORTQUEUE); 
            return;
        }
    }
       
    m_LastReportQName = m_ReportQueueName;

    //
    // Set the value of test all (propagate) flag
    //
    BOOL fTestAll = (m_iTestButton == 0);
    if (m_fTestAll != fTestAll)
    {
        m_fTestAll = fTestAll;

        hr = SetQMReportState(m_gMachineID, m_fTestAll);
        if(FAILED(hr))
        {
            MessageDSError(hr, IDS_OP_SET_PROPAGATION_FLAG);
        }
    }

	CMqDialog::OnOK();
}

void CMachineTracking::OnReportqueueNew() 
{
	static const GUID x_ReportGuidType = MQ_QTYPE_REPORT;

    CNewQueueDlg NewQDlg(this, IDS_REPORTQ_LABEL, x_ReportGuidType);
    if(NewQDlg.DoModal() == IDOK)
    {
        //
        // add queue to the combo-box.
        //
	    int iItem = m_ReportQueueCtrl.AddString(NewQDlg.m_strPathname);
        if (CB_ERR == iItem)
        {
            ASSERT(0);
            return;
        }

        INT_PTR iArrayIndex = m_aguidAllQueues.Add(NewQDlg.m_guid);
        m_ReportQueueCtrl.SetItemData(iItem, iArrayIndex);

        m_ReportQueueCtrl.SelectString(-1, NewQDlg.m_strPathname);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\lqdsply.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	lqDsply.h

Abstract:

	Local queues folder general functions
Author:

    YoelA, Raphir


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __LQDSPLY_H_
#define __LQDSPLY_H_

#include "mqcast.h"

void GetStringPropertyValue(PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString &str);
void FreeMqProps(MQMGMTPROPS * mqProps);

template <class T> 
class CLocalQueuesFolder : 
    public CNodeWithScopeChildrenList<T, FALSE>
{
public:
	MQMGMTPROPS	m_mqProps;

   	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

    CLocalQueuesFolder(CSnapInItem * pParentNode, CSnapin * pComponentData, 
                       LPCTSTR strMachineName, LPCTSTR strDisplayName) :
        CNodeWithScopeChildrenList<T, FALSE>(pParentNode, pComponentData),
        m_szMachineName(strMachineName)
        {
            m_bstrDisplayName = strDisplayName;
            //
            // If we are administrating the local machine, the machine name is empty
            //
            if (strMachineName[0] == 0)
            {
                m_fOnLocalMachine = TRUE;
            }
            else
            {
                m_fOnLocalMachine = FALSE;
            }
        };

protected:

	//
	// Menu functions
	//
    BOOL    m_fOnLocalMachine;
    virtual PropertyDisplayItem *GetDisplayList() = 0;
    virtual const DWORD         GetNumDisplayProps() = 0;

    CString m_szMachineName;

private:

	virtual CString GetHelpLink();

};

//
// CDisplayQueue - Queue that has display properties for right pane
//
template<class T>
class CDisplayQueue : public CNodeWithScopeChildrenList<T, FALSE>
{
public:
  	LPOLESTR GetResultPaneColInfo(int nCol);
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);
	MQMGMTPROPS	m_mqProps;
	CString m_szFormatName;
    CString m_szMachineName;

protected:
	CComBSTR m_bstrLastDisplay;
    PropertyDisplayItem *m_aDisplayList;
    DWORD m_dwNumDisplayProps;
    void Init()
    {
        m_aDisplayList = 0;
        m_mqProps.cProp = 0;
	    m_mqProps.aPropID = NULL;
	    m_mqProps.aPropVar = NULL;
	    m_mqProps.aStatus = NULL;
    }


    CDisplayQueue() :
    {
        Init();
    }

    CDisplayQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CNodeWithScopeChildrenList<T, FALSE>(pParentNode, pComponentData)
    {
        Init();
    }

    ~CDisplayQueue();

    //
    // Override this function to enable special treatment for display of specific 
    // property
    //
    virtual void ApplyCustomDisplay(DWORD dwPropIndex)
    {
    }

private:

	virtual CString GetHelpLink();
};

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueuesFolder::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
HRESULT CLocalQueuesFolder<T>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return InsertColumnsFromDisplayList(pHeaderCtrl, GetDisplayList());
}


template <class T>
CString CLocalQueuesFolder<T>::GetHelpLink(
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}

/***************************************************************************

  CDisplayQueue implementation

 ***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::GetResultPaneColInfo

  Param - nCol: Column number
  Returns - String to be displayed in the specific column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
LPOLESTR CDisplayQueue<T>::GetResultPaneColInfo(int nCol)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (0 == m_aDisplayList)
    {
     	if (nCol == 0)
	    {
		    return m_bstrDisplayName;
	    }

        //
	    // Return the blank for other columns
        //
	    return OLESTR(" ");
    }

#ifdef _DEBUG
    {
        //
        // Make sure that nCol is not larger than the last index in
        // m_aDisplayList
        //
        int i = 0;
        for (i=0; m_aDisplayList[i].itemPid != 0; i++)
		{
			NULL;
		}

        if (nCol >= i)
        {
            ASSERT(0);
        }
    }
#endif // _DEBUG

    //
    // Get a display string of that property
    //
    CString strTemp = m_bstrLastDisplay;
    ItemDisplay(&m_aDisplayList[nCol], &(m_mqProps.aPropVar[nCol]), strTemp);
    m_bstrLastDisplay=strTemp;
	
	ASSERT(m_mqProps.aPropID[nCol] == m_aDisplayList[nCol].itemPid);
    
    //
    // Apply custom display for that property
    //
    ApplyCustomDisplay(nCol);

    //
    // Return a pointer to the string buffer.
    //
    return(m_bstrLastDisplay);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::~CDisplayQueue
	Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
CDisplayQueue<T>::~CDisplayQueue()
{

	FreeMqProps(&m_mqProps);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
STDMETHODIMP CDisplayQueue<T>::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CNodeWithScopeChildrenList<T, FALSE>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

   	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szMachineName, 
            m_szMachineName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::GetHelpLink

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
CString CDisplayQueue<T>::GetHelpLink(
	VOID
	)
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);
	return strHelpLink;
}


#endif // __LQDSPLY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\machtrac.h ===
// MachineTracking.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking dialog

class CMachineTracking : public CMqDialog
{
	DECLARE_DYNCREATE(CMachineTracking)

// Construction
public:
	void Disable();
	CMachineTracking(const GUID& gMachineID = GUID_NULL, const CString& strDomainController = CString(""));
	~CMachineTracking();

// Dialog Data
	//{{AFX_DATA(CMachineTracking)
	enum { IDD = IDD_MACHINE_TRACKING };
	CComboBox	m_ReportQueueCtrl;
	CString	m_ReportQueueName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMachineTracking)
	public:
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	int m_iTestButton;
	BOOL m_fTestAll;
    CArray<GUID, const GUID&> m_aguidAllQueues;

	// Generated message map functions
	//{{AFX_MSG(CMachineTracking)
//	afx_msg void OnMtrackingSendtestmsg();
//	afx_msg void OnMtrackingSetpropflag();
//	afx_msg void OnMtrackingSetreportqueue();
	virtual BOOL OnInitDialog();
	afx_msg void OnReportqueueNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void DisableAllWindowChilds();
	CString m_LastReportQName;
	CString m_strDomainController;
    GUID m_gMachineID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\message.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	message.cpp

Abstract:

	Implementation file for the CMessage snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wincrypt.h"
#include "mqsnap.h"
#include "snapin.h"
#include "message.h"
#include "globals.h"
#include "mqPPage.h"
#include "msggen.h"
#include "msgsndr.h"
#include "msgq.h"
#include "msgbody.h"

#include "message.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
/*++

MsgIdToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgIdToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == (VT_VECTOR | VT_UI1));

   OBJECTID *pID = (OBJECTID*) pPropVar->caub.pElems ;

   TCHAR szGuid[MAX_GUID_LENGTH + 14]; // msgid= GUID + '\' + DWORD

   StringFromGUID2(pID->Lineage, szGuid, TABLE_SIZE(szGuid));

   TCHAR szI4[12];

   _ultot(pID->Uniquifier, szI4, 10);

   _tcscat(szGuid, _TEXT("\\")) ;
   _tcscat(szGuid, szI4) ;
   str = szGuid;
 
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgDeliveryToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgDeliveryToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI1);
    static EnumItem ItemList[] =
    { 
        ENUM_ENTRY(MQMSG_DELIVERY_EXPRESS),
        ENUM_ENTRY(MQMSG_DELIVERY_RECOVERABLE),
    };

    EnumToString(pPropVar->bVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgClassToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgClassToString(const PROPVARIANT *pPropVar, CString &str)
{

    ASSERT(pPropVar->vt == VT_UI2);
    static EnumItem ItemList[] =
    { 
        ENUM_ENTRY(MQMSG_CLASS_NORMAL),
        ENUM_ENTRY(MQMSG_CLASS_REPORT),
        ENUM_ENTRY(MQMSG_CLASS_ACK_REACH_QUEUE),
        ENUM_ENTRY(MQMSG_CLASS_ACK_RECEIVE),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_DST_Q),
        ENUM_ENTRY(MQMSG_CLASS_NACK_PURGED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_EXCEED_QUOTA),
        ENUM_ENTRY(MQMSG_CLASS_NACK_ACCESS_DENIED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_SIGNATURE),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_ENCRYPTION),
        ENUM_ENTRY(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q),
        ENUM_ENTRY(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_DELETED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_PURGED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_RECEIVE_TIMEOUT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER),
        ENUM_ENTRY(MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER)
    };

    EnumToString(pPropVar->uiVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

      
//////////////////////////////////////////////////////////////////////////////
/*++

MsgHashToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgHashToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);
    static EnumItem ItemList[] =
    { 

        ENUM_ENTRY(CALG_MD2),     
        ENUM_ENTRY(CALG_MD4),     
        ENUM_ENTRY(CALG_MD5),     
        ENUM_ENTRY(CALG_SHA),     
        ENUM_ENTRY(CALG_MAC),     
        ENUM_ENTRY(CALG_RSA_SIGN),
        ENUM_ENTRY(CALG_DSS_SIGN),
        ENUM_ENTRY(CALG_RSA_KEYX),
        ENUM_ENTRY(CALG_DES),     
        ENUM_ENTRY(CALG_RC2),
        ENUM_ENTRY(CALG_RC4),     
        ENUM_ENTRY(CALG_SEAL),    
        ENUM_ENTRY(CALG_DH_SF)
    };   

    EnumToString(pPropVar->ulVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgEncryptToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgEncryptToString(const PROPVARIANT *pPropVar, CString &str)
{       
    //
    // Same set of values
    //
    MsgHashToString(pPropVar, str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgSenderIdToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgSenderIdToString(const PROPVARIANT *pPropVar, CString &str)
{       
   ASSERT(pPropVar->vt == (VT_VECTOR | VT_UI1));


    PSID pSid = pPropVar->caub.pElems;          // binary SID
    LPTSTR pszTextBuffer;  // buffer for textual representaion of SID

    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    str.LoadString(IDS_UNKNOWN);
    //
    // test if SID passed in is valid
    //
    if(!IsValidSid(pSid)) 
        return;

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);


    //
    // Allocate the required size
    //
    pszTextBuffer = str.GetBuffer(dwSidSize);

    //
    // prepare S-SID_REVISION-
    //
    pszTextBuffer += swprintf(pszTextBuffer, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        pszTextBuffer += swprintf(pszTextBuffer,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        pszTextBuffer += swprintf(pszTextBuffer, TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        pszTextBuffer += swprintf(pszTextBuffer, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    str.ReleaseBuffer();

 
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgSendTypeToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgSendTypeToString(const PROPVARIANT *pPropVar, CString &str)
{       
    str.LoadString(MQMSG_SENDERID_TYPE_NONE == pPropVar->ulVal ?
                   IDS_NO : IDS_YES);

}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgPrivToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgPrivToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);
    static EnumItem ItemList[] =
    { 

        ENUM_ENTRY(MQ_PRIV_LEVEL_NONE), //BugBug - Assuming == MQMSG_PRIV_LEVEL_NONE   
        ENUM_ENTRY(MQMSG_PRIV_LEVEL_BODY_BASE),     
        ENUM_ENTRY(MQMSG_PRIV_LEVEL_BODY_ENHANCED)     
    };   

    EnumToString(pPropVar->ulVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//------------------------------------------------
//
// Table of message properties
//
//------------------------------------------------

PropertyDisplayItem MessageDisplayList[] = {

    // String resource                | Property ID            | VT Handler   | Display func     | Field Offset                          | Size                | Width     | Sort        | 
    //--------------------------------+------------------------+--------------+------------------+---------------------------------------+---------------------+-----------+-------------+-
    {IDS_REPORT_MESSAGETITLE,           PROPID_M_LABEL,          &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszLabel),        0,                    100,        SortByString},
    {IDS_REPORT_MESSAGEPRIORITY,        PROPID_M_PRIORITY,       &g_VTUI1,     NULL,               NO_OFFSET,                              0,                     50,        SortByString},
    {IDS_REPORT_MESSAGE_CLASS,          PROPID_M_CLASS,          &g_VTUI2,     MsgClassToString,   NO_OFFSET,                              0,                     50,        SortByString},
    {IDS_REPORT_MESSAGE_BODYSIZE,       PROPID_M_BODY_SIZE,      &g_VTUI4,     NULL,               NO_OFFSET,                              BODYLEN,               50,        SortByULONG},
    {IDS_REPORT_MESSAGEID,              PROPID_M_MSGID,          &g_VectUI1,   MsgIdToString,      FIELD_OFFSET(MsgProps,acMsgId),         PROPID_M_MSGID_SIZE,  275,        SortByString},
    {IDS_REPORT_MESSAGE_APPSPECIFIC,    PROPID_M_APPSPECIFIC,    &g_VTUI4,     NULL,               NO_OFFSET,                              0,                   HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGETITLE_LEN,       PROPID_M_LABEL_LEN,      &g_VTUI4,     NULL,               NO_OFFSET,                              LABELLEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGEDELIVERY,        PROPID_M_DELIVERY,       &g_VTUI1,     MsgDeliveryToString,NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_AUTHENTICATED,  PROPID_M_AUTHENTICATED,  &g_VTUI1,     BoolToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_HASH_ALG,       PROPID_M_HASH_ALG,       &g_VTUI4,     MsgHashToString,    NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_ENCRYPT_ALG,    PROPID_M_ENCRYPTION_ALG, &g_VTUI4,     MsgEncryptToString, NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SRC_MACHINE_ID, PROPID_M_SRC_MACHINE_ID, &g_VTCLSID,   NULL,               FIELD_OFFSET(MsgProps,guidSrcMachineId),0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENTTIME,       PROPID_M_SENTTIME,       &g_VTUI4,     TimeToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByCreateTime},
    {IDS_REPORT_MESSAGE_ARRIVEDTIME,    PROPID_M_ARRIVEDTIME,    &g_VTUI4,     TimeToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByModifyTime},
    {IDS_REPORT_MESSAGE_RCPT_QUEUE,     PROPID_M_DEST_QUEUE,     &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszDestQueue),    0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RCPT_QUEUE_LEN, PROPID_M_DEST_QUEUE_LEN, &g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_RESP_QUEUE,     PROPID_M_RESP_QUEUE,     &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszRespQueue),    0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RESP_QUEUE_LEN, PROPID_M_RESP_QUEUE_LEN, &g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_ADMIN_QUEUE,    PROPID_M_ADMIN_QUEUE,    &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszAdminQueue),   0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_ADMIN_QUEUE_LEN,PROPID_M_ADMIN_QUEUE_LEN,&g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_TRACE,          PROPID_M_TRACE,          &g_VTUI1,     BoolToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID,       PROPID_M_SENDERID,       &g_VectUI1,   MsgSenderIdToString,FIELD_OFFSET(MsgProps,acSenderId),      SENDERLEN,           HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID_LEN,   PROPID_M_SENDERID_LEN,   &g_VTUI4,     NULL,               NO_OFFSET,                              SENDERLEN,           HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID_TYPE,  PROPID_M_SENDERID_TYPE,  &g_VTUI4,     MsgSendTypeToString,NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_PRIV_LEVEL,     PROPID_M_PRIV_LEVEL,     &g_VTUI4,     MsgPrivToString,    NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_CORRELATIONID,  PROPID_M_CORRELATIONID,  &g_VectUI1,   MsgIdToString,      FIELD_OFFSET(MsgProps,acCorrelationId), PROPID_M_MSGID_SIZE, HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_DEST_FN,        PROPID_M_DEST_FORMAT_NAME,      &g_VTLPWSTR,NULL,          FIELD_OFFSET(MsgProps,wszMultiDestFN),  0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_DEST_FN_LEN,    PROPID_M_DEST_FORMAT_NAME_LEN,  &g_VTUI4,   NULL,          NO_OFFSET,                              MULTIFNLEN,          HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_RESP_FN,        PROPID_M_RESP_FORMAT_NAME,      &g_VTLPWSTR,NULL,          FIELD_OFFSET(MsgProps,wszMultiRespFN),  0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RESP_FN_LEN,    PROPID_M_RESP_FORMAT_NAME_LEN,  &g_VTUI4,   NULL,          NO_OFFSET,                              MULTIFNLEN,          HIDE_COLUMN, SortByULONG},   
    {NO_TITLE,                          PROPID_M_BODY,           &g_VectUI1,   NULL,               FIELD_OFFSET(MsgProps,acBody),          LABELLEN,            HIDE_COLUMN, SortByString},
    
    {0,                                 0,                       NULL }

};

//////////////////////////////////////////////////////////////////////////////
/*++

GetUserIdAndDomain

  Returned a domain\user string based on a sid

--*/
//////////////////////////////////////////////////////////////////////////////
void GetUserIdAndDomain(CString &strUser, PVOID psid)
{
#define USER_AND_DOMAIN_INIT_SIZE 256
    CString strUid;
    CString strDomain;
    SID_NAME_USE eUse;

    strUser = L"";
    
    if (psid == 0)
            return ;
    
    DWORD cbName = USER_AND_DOMAIN_INIT_SIZE;
    DWORD cpPrevName = 0;
    DWORD cbReferencedDomainName = USER_AND_DOMAIN_INIT_SIZE;
    DWORD cbPrevReferencedDomainName = 0;
    BOOL fReturnValue;

    while(cbPrevReferencedDomainName < cbReferencedDomainName ||
          cpPrevName < cbName)
    {
        cpPrevName = cbName;
        cbPrevReferencedDomainName = cbReferencedDomainName;

        fReturnValue = LookupAccountSid(
            0,          // address of string for system name
            psid, // address of security identifier
            strUid.GetBuffer(cbName / sizeof(TCHAR) + 1),   // address of string for account name
            &cbName,    // address of size account string
            strDomain.GetBuffer(cbReferencedDomainName / sizeof(TCHAR) + 1),    // address of string for referenced domain
            &cbReferencedDomainName,    // address of size domain string
            &eUse   // address of structure for SID type
        );
        strUid.ReleaseBuffer();
        strDomain.ReleaseBuffer();
    }

    strUser.Format(TEXT("%s\\%s"), strDomain, strUid);

}


/////////////////////////////////////////////////////////////////////////////
// CMessage
// {B1320C00-BCB2-11d1-9B9B-00E02C064C39}
static const GUID CMessageGUID_NODETYPE = 
{ 0xb1320c00, 0xbcb2, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CMessage::m_NODETYPE = &CMessageGUID_NODETYPE;
const OLECHAR* CMessage::m_SZNODETYPE = OLESTR("B1320C00-BCB2-11d1-9B9B-00E02C064C39");
const OLECHAR* CMessage::m_SZDISPLAY_NAME = OLESTR("MSMQ Message Admin");
const CLSID* CMessage::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetQueuePathName

  Get queue path name by format name

--*/
//////////////////////////////////////////////////////////////////////////////
void CMessage::GetQueuePathName(
                     CString  strFormatName,
                     CString &strPathName
                     )
{    
	if(strFormatName[0] == 0)
	{
		TrWARNING(mqsnap, "No format name was supplied");
	    strPathName.Empty();
		return;
	}

    PROPVARIANT   aPropVar[1];
    PROPID        aPropId[1];
    MQQUEUEPROPS  mqprops;
    CString       szError;


    aPropVar[0].vt = VT_NULL;
    aPropVar[0].pwszVal = NULL;
    aPropId[0] = PROPID_Q_PATHNAME;
             
    mqprops.cProp    = 1;
    mqprops.aPropID  = aPropId;
    mqprops.aPropVar = aPropVar;
    mqprops.aStatus  = NULL;        

	//
	// calling MQGetQueueProperties() will try the user domain and then the GC
	// which is ok.
	// We are not using ADGetObjectPropertiesGuid() with a specific domain\DomainController
	// because those are queues on the message and we don't want to limit the search for a specific domain,
	// we want to search the GC.
	//
    HRESULT hr = MQGetQueueProperties(strFormatName, &mqprops);

    if(SUCCEEDED(hr))
    {
        strPathName = aPropVar[0].pwszVal;
		TrTRACE(mqsnap, "PathName = %ls", aPropVar[0].pwszVal);
        MQFreeMemory(aPropVar[0].pwszVal);
		return;
    }

	TrERROR(mqsnap, "MQGetQueueProperties failed, QueueFormatName = %ls, hr = 0x%x", strFormatName, hr);

    MQErrorToMessageString(szError, hr);
    TRACE(_T("CMessage::CreatePropertyPages: Could not get %s pathname. %X - %s\n"), strFormatName,
          hr, szError);
    strPathName.Empty();
}

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMessage::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());
//    HRESULT hr;

	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
	
        //--------------------------------------
        //
        // Message General Page
        //
        //--------------------------------------      
	    CMessageGeneralPage *pGenPage = new CMessageGeneralPage();

        GetPropertyString(MessageDisplayList, PROPID_M_LABEL,       m_pMsgProps->aPropVar, pGenPage->m_szLabel);
        GetPropertyString(MessageDisplayList, PROPID_M_SENTTIME,    m_pMsgProps->aPropVar, pGenPage->m_szSent);
        GetPropertyString(MessageDisplayList, PROPID_M_ARRIVEDTIME, m_pMsgProps->aPropVar, pGenPage->m_szArrived);
        GetPropertyString(MessageDisplayList, PROPID_M_CLASS,       m_pMsgProps->aPropVar, pGenPage->m_szClass);
        GetPropertyString(MessageDisplayList, PROPID_M_MSGID,       m_pMsgProps->aPropVar, pGenPage->m_szId);
        GetPropertyString(MessageDisplayList, PROPID_M_PRIORITY,    m_pMsgProps->aPropVar, pGenPage->m_szPriority);
        GetPropertyString(MessageDisplayList, PROPID_M_TRACE,       m_pMsgProps->aPropVar, pGenPage->m_szTrack);
        pGenPage->m_iIcon = m_iIcon;

	    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pGenPage->m_psp);  

        HRESULT hr = MMCPropPageCallback(&pGenPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        lpProvider->AddPage(hPage); 

        //--------------------------------------
        //
        // Message Queues Page
        //
        //--------------------------------------        
        
        CMessageQueuesPage *pQueuePage = new CMessageQueuesPage();                      
        //
        // Get format name for queues. We ask new property _FORMAT_NAME
        // Even if there is only old property we get for this new property
        // old value. 
        //

        GetPropertyString(
                MessageDisplayList,
                PROPID_M_ADMIN_QUEUE, 
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szAdminFN);             
      
        //
        // get format name for response queue
        //        
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_RESP_FORMAT_NAME,
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szRespFN);        
        
        //
        // get format name for destination queue: we need both old and new values
        //
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_DEST_QUEUE, 
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szDestFN);             
      
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_DEST_FORMAT_NAME,
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szMultiDestFN);        

        //
        // Get the destination queue PathName (from Beta1 Whistler: Recipient frame)
        // only for single cast format name
        //                
        GetQueuePathName (pQueuePage->m_szDestFN, pQueuePage->m_szDestPN);           
        
        //
        // Get the response queue PathName only if it is single cast format name
        //
        pQueuePage->m_szRespPN = L"";

        //
        // old property: PROPID_M_RESP_QUEUE
        //
        CString strRespFN(m_pMsgProps->wszRespQueue);  

        if(strRespFN == pQueuePage->m_szRespFN)
        {
            //
            // it is single response queue
            //            
            GetQueuePathName (strRespFN, pQueuePage->m_szRespPN);        
        }

        CString strAdminFN(m_pMsgProps->wszAdminQueue);  
        
        GetQueuePathName (strAdminFN, pQueuePage->m_szAdminPN);            

	    hPage = CreatePropertySheetPage(&pQueuePage->m_psp);  


        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pQueuePage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 


        //--------------------------------------
        //
        // Message Senders Page
        //
        //--------------------------------------
        MQQMPROPS qmprops;        

        CMessageSenderPage *pSenderPage = new CMessageSenderPage();
        GetPropertyString(MessageDisplayList, PROPID_M_AUTHENTICATED, m_pMsgProps->aPropVar, pSenderPage->m_szAuthenticated);
        GetPropertyString(MessageDisplayList, PROPID_M_PRIV_LEVEL,    m_pMsgProps->aPropVar, pSenderPage->m_szEncrypt);
        GetPropertyString(MessageDisplayList, PROPID_M_ENCRYPTION_ALG,m_pMsgProps->aPropVar, pSenderPage->m_szEncryptAlg);
        GetPropertyString(MessageDisplayList, PROPID_M_SRC_MACHINE_ID,m_pMsgProps->aPropVar, pSenderPage->m_szGuid);
        GetPropertyString(MessageDisplayList, PROPID_M_HASH_ALG,      m_pMsgProps->aPropVar, pSenderPage->m_szHashAlg);
        GetPropertyString(MessageDisplayList, PROPID_M_SENDERID,      m_pMsgProps->aPropVar, pSenderPage->m_szSid);
        
        //
        // Get machine pathname
        //
        PROPVARIANT   aPropVar[1];
        PROPID        aPropId[1];        
        CString       szError;

        aPropVar[0].vt = VT_NULL;
        aPropVar[0].pwszVal = NULL;
        aPropId[0] = PROPID_QM_PATHNAME;

        qmprops.cProp    = 1;
        qmprops.aPropID  = aPropId;
        qmprops.aPropVar = aPropVar;
        qmprops.aStatus  = NULL;

		//
		// calling MQGetMachineProperties() will try the user domain and then the GC
		// which is ok. 
		// we are looking for the sending QM so we really wants to look in the GC.
		// We are not using ADGetObjectPropertiesGuid() with a specific domain\DomainController
		// because it will limit the search only
		// for a specific domain and will not search the GC.
		//
        hr = MQGetMachineProperties(NULL, &m_pMsgProps->guidSrcMachineId, &qmprops);
        if(SUCCEEDED(hr))
        {
            pSenderPage->m_szPathName = aPropVar[0].pwszVal;
            MQFreeMemory(aPropVar[0].pwszVal);
        }
        else
        {
            TCHAR szMachineGuid[x_dwMaxGuidLength];
            StringFromGUID2(m_pMsgProps->guidSrcMachineId, szMachineGuid, TABLE_SIZE(szMachineGuid));
            
            MQErrorToMessageString(szError, hr);

            TRACE(_T("CMessage::CreatePropertyPages: Could not get %s pathname. %X - %s\n"), szMachineGuid,
                  hr, szError);

            pSenderPage->m_szPathName = szMachineGuid;
        }

        //
        // Get user account and domain, based on Sid
        //
        GetUserIdAndDomain(pSenderPage->m_szUser, &m_pMsgProps->acSenderId);

	    hPage = CreatePropertySheetPage(&pSenderPage->m_psp);  

        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pSenderPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 

        
        //--------------------------------------
        //
        // Message Body Page
        //
        //--------------------------------------        
        CMessageBodyPage *pBodyPage = new CMessageBodyPage();
        PROPVARIANT * pvarSize;
        DWORD dwSize;
      
        GetPropertyVar(MessageDisplayList, PROPID_M_BODY_SIZE, m_pMsgProps->aPropVar, &pvarSize);

        ASSERT(pvarSize->vt == VT_UI4);
        dwSize = pvarSize->ulVal;

        pBodyPage->m_Buffer = m_pMsgProps->acBody;

        if (dwSize > BODYLEN)
        {
            pBodyPage->m_strBodySizeMessage.FormatMessage(
                IDS_BODY_SIZE_PARTIAL_MESSAGE,
                BODYLEN,
                dwSize);
            pBodyPage->m_dwBufLen = BODYLEN;
        }
        else
        {
            pBodyPage->m_strBodySizeMessage.FormatMessage(
                IDS_BODY_SIZE_NORMAL_MESSAGE,
                dwSize);
             pBodyPage->m_dwBufLen = dwSize;
       }

	    hPage = CreatePropertySheetPage(&pBodyPage->m_psp);  

        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pBodyPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 


        return(S_OK);


	}
	return E_UNEXPECTED;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMessage::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}
        
//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetResultPaneColInfo

  Param - nCol: Column number
  Returns - String to be displayed in the specific column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
LPOLESTR CMessage::GetResultPaneColInfo(int nCol)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Make sure that nCol is not larger than the last index in
    // MessageDisplayList
    //
    ASSERT(nCol < ARRAYSIZE(MessageDisplayList));

    //
    // Get a display string of that property
    //
    CString strTemp = m_bstrLastDisplay;
    ItemDisplay(&MessageDisplayList[nCol], &(m_pMsgProps->aPropVar[nCol]),strTemp);
    m_bstrLastDisplay = strTemp;
    
    //
    // Return a pointer to the string buffer.
    //
    return(m_bstrLastDisplay);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetValueInColumn

  Param - nCol: Column number
  Returns - Propvariant representing the value in the column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
PROPVARIANT *CMessage::GetValueInColumn(int nCol)
{
    ASSERT(nCol < ARRAYSIZE(MessageDisplayList));

    return &m_pMsgProps->aPropVar[nCol];
}

//////////////////////////////////////////////////////////////////////////////
void CMessage::UpdateIcon()
{
    PROPVARIANT * pvar;
    GetPropertyVar(MessageDisplayList, PROPID_M_CLASS, m_pMsgProps->aPropVar, &pvar);
    ASSERT(pvar->vt == VT_UI2);
    USHORT usClass = pvar->uiVal;

    GetPropertyVar(MessageDisplayList, PROPID_M_TRACE, m_pMsgProps->aPropVar, &pvar);
    ASSERT(pvar->vt == VT_UI1);
    BOOL fTrace = pvar->bVal;

    DWORD iImage;

    if (fTrace)
    {
        iImage = IMAGE_TEST_MESSAGE;
        m_iIcon = IDI_TEST_MSG;
    }
    else if(MQCLASS_NACK(usClass))
    {
        iImage = IMAGE_NACK_MESSAGE;
        m_iIcon = IDI_NACK_MSG;
    }
    else
    {
        switch(usClass)
        {
            case MQMSG_CLASS_ACK_REACH_QUEUE:
            case MQMSG_CLASS_ACK_RECEIVE:
            case MQMSG_CLASS_ORDER_ACK:
                iImage = IMAGE_ACK_MESSAGE;
                m_iIcon = IDI_ACK_MSG;
                break;

            case MQMSG_CLASS_REPORT:
                iImage = IMAGE_REPORT_MESSAGE;
                m_iIcon = IDI_REPORT_MSG;
                break;

            case MQMSG_CLASS_NORMAL:
            default:
                iImage = IMAGE_MESSAGE;
                m_iIcon = IDI_MSGICON;
                break;
        }
    }

    SetIcons(iImage, iImage);

}


//
// Compare two items in a given column. *pnResult contain column on entry,
// and -1 (<). 0 (==), or 1 (>) on exit.
//
HRESULT CMessage::Compare(LPARAM lUserParam, CMessage *pItemToCompare, int* pnResult)
{
    int nCol = *pnResult;
    PROPVARIANT *ppropvA = GetValueInColumn(nCol); 
    PROPVARIANT *ppropvB = pItemToCompare->GetValueInColumn(nCol);
    
    if (ppropvA == 0 || ppropvB == 0)
    {
        return E_UNEXPECTED;
    }

    *pnResult = CompareVariants(ppropvA, ppropvB);
    return S_OK;
}


CString 
CMessage::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_MESSAGES);
	return strHelpLink;
}

//////////////////////////////////////////////////////////////////////////////
/*++

MessageDataSize

   Returns the max possible size for message information

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD MessageDataSize(void)
{
    DWORD dwTableSize;
    DWORD dwItemSize;

    dwTableSize = sizeof(MessageDisplayList)/sizeof(PropertyDisplayItem);
    dwItemSize = sizeof(DWORD) + sizeof(INT);

    return(dwItemSize * dwTableSize);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\message.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	message.h

Abstract:

	Definition file for the CMessage snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __MSMQMSG_H_
#define __MSMQMSG_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnode.h"

#include "icons.h"

#define MAX_VAR     50
#define BODYLEN     260
#define LABELLEN    260
#define QUEUELEN    200
#define SENDERLEN   100
#define MULTIFNLEN  260

#define SET_LAST_CHAR_AS_ZERO(wsz)     (wsz)[ sizeof(wsz)/sizeof((wsz)[0]) - 1 ] = _T('\0')

struct MsgProps
{
    // 
    // Message properties that need buffer
    //
    WCHAR             wszLabel[LABELLEN];
    char              acMsgId[PROPID_M_MSGID_SIZE];
    UCHAR             acBody[BODYLEN];
    GUID              guidSrcMachineId;    
    WCHAR             wszDestQueue[QUEUELEN];        
    WCHAR             wszRespQueue[QUEUELEN];        
    WCHAR             wszAdminQueue[QUEUELEN];    
    char              acSenderId[SENDERLEN];
    char              acCorrelationId[PROPID_M_MSGID_SIZE];
    WCHAR             wszMultiDestFN[MULTIFNLEN];    
    WCHAR             wszMultiRespFN[MULTIFNLEN];


    PROPVARIANT aPropVar[MAX_VAR];
    PROPID      aPropId[MAX_VAR];

};

class CMessage : public CSnapinNode<CMessage, FALSE>
{
public:
 
	CComPtr<IControlbar> m_spControlBar; 

  	BEGIN_SNAPINCOMMAND_MAP(CMessage, FALSE)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_SNAPIN_MENU)

    CMessage(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CSnapinNode<CMessage, FALSE>(pParentNode, pComponentData)
	{
        
        SetIcons(IMAGE_MESSAGE, IMAGE_MESSAGE);

        m_pMsgProps = NULL;
        m_iIcon = IDI_MSGICON;
	}

	~CMessage()
	{
        delete m_pMsgProps;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

	LPOLESTR GetResultPaneColInfo(int nCol);

    void SetMsgProps(MsgProps * pMsgProps);

    PROPVARIANT *CMessage::GetValueInColumn(int nCol);

    virtual HRESULT Compare(LPARAM lUserParam, CMessage *pItemToCompare, int* pnResult);

private:
    void UpdateIcon();   

    void GetQueuePathName(CString strFormatName, CString &strPathName);  

	virtual CString GetHelpLink();

    MsgProps *  m_pMsgProps;                // Property value of the message
	CComBSTR    m_bstrLastDisplay;          // Last column displayed
    DWORD m_iIcon;
};

inline void CMessage::SetMsgProps(MsgProps * pMsgProps)
{   
    m_pMsgProps = pMsgProps;
    UpdateIcon();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mgmtext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	mgmtext.cpp

Abstract:
	Implementation for the Local Computer management extensions

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "rt.h"
#include "mgmtext.h"
#include "lqDsply.h"
#include "localadm.h"

#include "mgmtext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/****************************************************

CSnapinComputerMgmt Class
    
 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {2B39B2B2-2166-11d2-9BA5-00E02C064C39}
static const GUID CSnapinComputerMgmtGUID_NODETYPE = 
{ 0x2b39b2b2, 0x2166, 0x11d2, { 0x9b, 0xa5, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };


const GUID*  CSnapinComputerMgmt::m_NODETYPE = &CSnapinComputerMgmtGUID_NODETYPE;
const OLECHAR* CSnapinComputerMgmt::m_SZNODETYPE = OLESTR("2B39B2B2-2166-11d2-9BA5-00E02C064C39");
const OLECHAR* CSnapinComputerMgmt::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinComputerMgmt::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputerMgmt::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputerMgmt::PopulateScopeChildrenList()
{
    HRESULT hr = S_OK;
    CString strTitle;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSnapinLocalAdmin *pAdmin;

    pAdmin = new CSnapinLocalAdmin(this, m_pComponentData, m_szMachineName);
    strTitle.LoadString(IDS_LOCAL_MACHINE_ADM);
    pAdmin->m_bstrDisplayName = strTitle;

    if (pAdmin->IsThisMachineDepClient())
    {
        pAdmin->SetState(MSMQ_CONNECTED);
        
        AddChild(pAdmin, &pAdmin->m_scopeDataItem);
        return S_OK;
    }

	MQMGMTPROPS	  mqProps;
    PROPVARIANT   PropVar;

    //
    // Retreive the Connected state of the QM
    //
    PROPID        PropId = PROPID_MGMT_MSMQ_CONNECTED;
    PropVar.vt = VT_NULL;

    mqProps.cProp = 1;
    mqProps.aPropID = &PropId;
    mqProps.aPropVar = &PropVar;
    mqProps.aStatus = NULL;

    hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
					   MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
        //
        // If failed, Do not display the icon. No error message is displayed.
        // We do not display an error message because the user of Computer Management
        // snap-in may not be interested in MSMQ at all.
        //
        TRACE(_T("MQMgmtGetInfo failed on %s. Error = %X"), m_szMachineName, hr);                
        //
        // BUGBUG. memory leak: to free pAdmin here
        //
        return (hr);
    }

    ASSERT(PropVar.vt == VT_LPWSTR);

    pAdmin->SetState(PropVar.pwszVal);

    AddChild(pAdmin, &pAdmin->m_scopeDataItem);

    MQFreeMemory(PropVar.pwszVal);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputerMgmt::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputerMgmt::OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{

    ((CComputerMgmtExtData *)m_pParentNode)->RemoveChild(m_szMachineName);

	return (S_OK);
}
    
/****************************************************

        CComputerMgmtExtData Class
    
 ****************************************************/
//
// Extending the Local Computer Management MMC.
// We are extending the "SystemTools" folder of the local computer
//
// Nodes defined by the local Computer Management MMC are:
//
//#define struuidNodetypeComputer      "{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeDrive         "{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeSystemTools   "{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeServerApps    "{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeStorage       "{476e644a-aaff-11d0-b944-00c04fd8d5b0}"
//
//#define lstruuidNodetypeComputer    L"{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeDrive       L"{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeSystemTools L"{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeStorage     L"{476e644a-aaff-11d0-b944-00c04fd8d5b0}"
//
//#define structuuidNodetypeComputer    \
//    { 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeDrive       \
//    { 0x476e6447, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeSystemTools \
//    { 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeServerApps  \
//    { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeStorage     \
//    { 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//
//


// Extension of the ServerApps nodes
static const GUID CComputerMgmtExtDataGUID_NODETYPE = 
  { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

const GUID*  CComputerMgmtExtData::m_NODETYPE = &CComputerMgmtExtDataGUID_NODETYPE;
const OLECHAR* CComputerMgmtExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CComputerMgmtExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CComputerMgmtExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComputerMgmtExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

void ExtractComputerName(IDataObject* pDataObject, CString& strComputer)
{
    strComputer=L"";

	//
	// Find the computer name from the ComputerManagement snapin
	//
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { gx_CCF_COMPUTERNAME, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    //
    // Allocate memory for the stream
    //
    int len = 500;

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

	if(stgmedium.hGlobal == NULL)
		return;


	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);

    ASSERT(SUCCEEDED(hr));

	//
	// Get the computer name
	//
    strComputer = (WCHAR *)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);


}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::GetExtNodeObject

  Called with a node that we need to expand. 
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CComputerMgmtExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    CString strComputer; 
    CSnapinComputerMgmt *pCompMgmt;


    ExtractComputerName(pDataObject, strComputer);

    //
    // Already extending...
    //
    HRESULT rc = m_mapComputers.Lookup(strComputer, pCompMgmt);
    if(rc == TRUE)
        return(pCompMgmt);

	//
	// Create our extension
	//
	pCompMgmt = new CSnapinComputerMgmt(this, m_pComponentData, strComputer);

    //
    // Add it to the map
    //
    m_mapComputers.SetAt(strComputer, pCompMgmt);

    return(pCompMgmt);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::~CComputerMgmtExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComputerMgmtExtData::~CComputerMgmtExtData()
{

    //
    // bug!!! We must remove all children...
    //
    //RemoveChild(m_pCompMgmt);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerMgmtExtData::RemoveChild(CString &strCompName)
{    
    
    BOOL rc;
    CSnapinComputerMgmt *pCompMgmt;

    rc = m_mapComputers.Lookup(strCompName, pCompMgmt);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapComputers.RemoveKey(strCompName);
    ASSERT(rc == TRUE);

    //
    // BUGBUG: Must delete it but we get AV when exiting MMC
    //
    //delete pCompMgmt;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mgmtext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	mgmtext.h

Abstract:

	Definition for the Local Computer management extensions
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MGMTEXT_H_
#define __MGMTEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"


/****************************************************

        CSnapinComputerMgmt Class
    
 ****************************************************/

class CSnapinComputerMgmt : public CNodeWithScopeChildrenList<CSnapinComputerMgmt, TRUE>
{
public:
    CString m_szMachineName;


   	BEGIN_SNAPINCOMMAND_MAP(CSnapinComputerMgmt, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinComputerMgmt(CSnapInItem * pParentNode, CSnapin * pComponentData, 
                        CString strComputer) : 
        CNodeWithScopeChildrenList<CSnapinComputerMgmt, TRUE>(pParentNode, pComponentData ),
        m_szMachineName(strComputer)
    {
   		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    }

	~CSnapinComputerMgmt()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);


private:
};



/****************************************************

        CComputerMgmtExtData Class
    
 ****************************************************/

class CComputerMgmtExtData : public CSnapInItemImpl<CComputerMgmtExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *   m_pComponentData;


	BEGIN_SNAPINCOMMAND_MAP(CComputerMgmtExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CComputerMgmtExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CComputerMgmtExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CComputerMgmtExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);

   void RemoveChild(CString &strCompName);



private:

    CMap< CString, LPCWSTR, CSnapinComputerMgmt*, CSnapinComputerMgmt* > m_mapComputers;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mobile.cpp ===
// Mobile.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "localutl.h"
#include "Mobile.h"
#include "..\..\ds\h\servlist.h"
#include <winreg.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include <rt.h>
#include "_registr.h"
#include "mqcast.h"

#include "mobile.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMobilePage property page

IMPLEMENT_DYNCREATE(CMobilePage, CMqPropertyPage)

void CMobilePage::SetSiteName()
{
   HRESULT rc;
   DWORD dwSize;
   DWORD dwType;
   TCHAR tmp[1000];
   TCHAR szTmp[1000] ;
   TCHAR szRegName[100] ;	

	//read site name from registry
   dwSize = sizeof(tmp);
   dwType = REG_SZ;
   //ConvertToWideCharString(MSMQ_SITENAME_REGNAME, szRegName);
   _tcscpy(szRegName,MSMQ_SITENAME_REGNAME);	

   rc = GetFalconKeyValue( szRegName, &dwType, tmp, &dwSize, L"");
   //
   // BUGBUG:GetFalconKeyValue accepts WCHAR
   //
   //ConvertFromWideCharString(tmp, szTmp);
   _tcscpy(szTmp,tmp);

   if (_tcscmp(szTmp, TEXT("")))
   {
      m_fSiteRead = TRUE ;
   }
	m_strCurrentSite = szTmp ;
}

CMobilePage::CMobilePage() : CMqPropertyPage(CMobilePage::IDD)
{
    m_fModified = FALSE;  

    m_fSiteRead = FALSE ;
    SetSiteName() ;
}

CMobilePage::~CMobilePage()
{
}

void CMobilePage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMobilePage)
	DDX_Control(pDX, ID_SiteList, m_box);
	DDX_Text(pDX, ID_CurrentSite, m_strCurrentSite);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate)
    {
        DWORD iNewSite = m_box.GetCurSel();
        if (iNewSite != CB_ERR)
        {
            m_box.GetLBText(iNewSite, m_szNewSite);
            m_fModified = TRUE;            
        }
    }
    else
    {
       DWORD iSite = m_box.FindStringExact(0, m_szNewSite);
       m_box.SetCurSel(iSite) ;
    }
}


BEGIN_MESSAGE_MAP(CMobilePage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMobilePage)
    ON_CBN_SELCHANGE(ID_SiteList, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMobilePage message handlers

BOOL CMobilePage::OnInitDialog()
{
    return CMqPropertyPage::OnInitDialog();
}


BOOL CMobilePage::OnSetActive()
{

    if (!m_fSiteRead)
    {
       //
       // site name not yet read from registry. Try to read it now.
       //
       UpdateData(TRUE) ;
       SetSiteName() ;
       UpdateData(FALSE) ;
    }

    TCHAR tPrivKeyName[256] = {0} ;

    HKEY hServersCacheKey;
    HRESULT rc;
    DWORD dwSizeVal ;
    DWORD dwSizeData ;
    TCHAR  szName[1000];

    BYTE  data[1000];

    _tcscpy(tPrivKeyName, FALCON_REG_KEY) ;
    _tcscat(tPrivKeyName, TEXT("\\"));
    _tcscat(tPrivKeyName, MSMQ_SERVERS_CACHE_REGNAME);

    // obtain a handle to key ServersCache
    rc = RegOpenKeyEx( FALCON_REG_POS,
                       tPrivKeyName,
                       0L,
                       KEY_ALL_ACCESS,
                       &hServersCacheKey );
    if (rc != ERROR_SUCCESS)
    {
	    return TRUE;
    }

    m_box.ResetContent() ;
    DWORD dwIndex = 0;               // enumeration Index
    //
    //  enumerate the values of ServersCache
    //  and add them to list-box
    //
    do
    {
	    //dwSizeVal  = sizeof(szName) ;
	    //dwSizeData = sizeof(data) ;
	    dwSizeVal  = sizeof(szName)/sizeof(TCHAR) ;//size in characters
	    dwSizeData = sizeof(data);				// size in bytes

	    rc = RegEnumValue( hServersCacheKey,// handle of key to query
                         dwIndex,         // index of value to query
                         szName,	         // address of buffer for value string
                         &dwSizeVal,      // address for size of value buffer
                         0L,	            // reserved
                         NULL,            // type
                         data,            // address of buffer for value data
                         &dwSizeData      // address for size of value data
                       );

	    if (rc != ERROR_SUCCESS)
      {
	    break ;
	    }



	    //don't add values starting with '\'
	    if ((char)data[0] != (char) NEW_SITE_IN_REG_FLAG_CHR)
      {
          //add to list-box
          m_box.AddString(szName);
      }

	    dwIndex++;
    } while (TRUE);

    CMqPropertyPage::OnSetActive();

    RegCloseKey( hServersCacheKey );
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CMobilePage::OnApply()
{    
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    TCHAR tPrivKeyName[256] = {0} ;
    HKEY ServersCacheKey;
	TCHAR szData[1000];
	TCHAR szServersList[1000];

    HRESULT rc;
    DWORD dwSize;
    DWORD dwType;
	TCHAR  szTmp1[1000];
    TCHAR  szTmp[100];


	/*how to reconstruct the precious status */

    //ConvertFromWideCharString(MSMQ_SERVERS_CACHE_REGNAME, szTmp);
	_tcscpy(szTmp,MSMQ_SERVERS_CACHE_REGNAME);
    _tcscpy(tPrivKeyName, FALCON_REG_KEY);
    _tcscat(tPrivKeyName, TEXT("\\"));
    _tcscat(tPrivKeyName, szTmp);

    //open registry key ServersCache
    rc = RegOpenKeyEx(FALCON_REG_POS,
                      tPrivKeyName,
                      0L,
                      KEY_ALL_ACCESS,
                      &ServersCacheKey
                      );
    if (rc != ERROR_SUCCESS) {
        DisplayFailDialog();
        return TRUE;
    }


    //get the servers list (value of key ServersCache)
    dwSize=sizeof(szData);
    rc = RegQueryValueEx(ServersCacheKey,        // handle of key to query
                         m_szNewSite,           // address of name of value to query
                         NULL,                   // reserved
                         NULL,                   // address of buffer for value type
                         (BYTE *)szData,                   // address of data buffer
                         &dwSize                 // address of data buffer size
                         );
    if (rc != ERROR_SUCCESS) {
        DisplayFailDialog();
        return TRUE;
    }


    //make the servers list Unicode
    //ConvertToWideCharString((char*)data,szServersList);
	_tcscpy(szServersList,szData);

    //write servers list as new value for key MQISServer
    dwType = REG_SZ;
	dwSize = (numeric_cast<DWORD>(_tcslen(szServersList) +1 )) * sizeof(TCHAR);
    rc = SetFalconKeyValue(MSMQ_DS_SERVER_REGNAME,
                           &dwType,
                           szServersList,
                           &dwSize
                           );
    //
    // BUGBUG:SetFalconKeyValue accepts WCHAR
    //
    ASSERT(rc == ERROR_SUCCESS);

    //save in registry new value for key SiteName
	//ConvertToWideCharString(pageMobile.m_szNewSite,wcsTmp);
	_tcscpy(szTmp1, m_szNewSite);

    dwSize = (numeric_cast<DWORD>(_tcslen(szTmp1) + 1)) * sizeof(TCHAR);
    dwType = REG_SZ;
    rc = SetFalconKeyValue(MSMQ_SITENAME_REGNAME,
                           &dwType,
                           szTmp1,
                           &dwSize
                           );
     //
     // BUGBUG:SetFalconKeyValue accepts WCHAR
     //
    ASSERT(rc == ERROR_SUCCESS);


    //save in registry new value for key SiteId
    dwType = REG_BINARY;
    dwSize = sizeof(GUID_NULL);
    rc = SetFalconKeyValue(MSMQ_SITEID_REGNAME,
                           &dwType,
                           (void*)&GUID_NULL,
                           &dwSize
                           );
    //
    // BUGBUG:SetFalconKeyValue accepts WCHAR
    //
    ASSERT(rc == ERROR_SUCCESS);

    m_fNeedReboot = TRUE;
    
    return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mqdspage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqdspage.h

Abstract:

   General property page class for all the property pages of DS objects,
   that are called using display specifiers. Inherits from general property 
   page - see mqppage.h

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MQDSPAGE_H__
#define __MQDSPAGE_H__

/////////////////////////////////////////////////////////////////////////////
// CMqDsPropertyPage
template<class T>
class CMqDsPropertyPage : public T
{
public:
    CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier) :
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

    CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier, CString& strPathName) :
        T(strPathName),
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

	CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier, CString& strPathName, const CString& strDomainController) :
        T(strPathName, strDomainController),
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

    ~CMqDsPropertyPage()
    {
        if (0 != m_pDsNotifier)
        {
            m_pDsNotifier->Release();
        }
    }

protected:
  	//{{AFX_MSG(CMqDsPropertyPage)
	//}}AFX_MSG
    CDisplaySpecifierNotifier *m_pDsNotifier;

    void init()
    {
        if (0 != m_pDsNotifier)
        {
            m_pDsNotifier->AddRef();
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mqppage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqppage.cpp

Abstract:

   General property page class - used as base class for all
   mqsnap property pages.

Author:

    YoelA


--*/

#include "stdafx.h"
#include "resource.h"
#include "mqPPage.h"
#include "mqsnhlps.h"
#include "globals.h"
#include "Restart.h"
#include "localutl.h"

#include "mqppage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMqPropertyPage

IMPLEMENT_DYNCREATE(CMqPropertyPage, CPropertyPageEx)

BEGIN_MESSAGE_MAP(CMqPropertyPage, CPropertyPageEx)
	//{{AFX_MSG_MAP(CMqPropertyPage)
	    ON_WM_HELPINFO()
	    ON_WM_CONTEXTMENU()
    	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_DISPLAYCHANGE, OnDisplayChange)
END_MESSAGE_MAP()

CMqPropertyPage::CMqPropertyPage(UINT nIDTemplate, UINT nIDCaption /* = 0 */)
 : CPropertyPageEx(nIDTemplate, nIDCaption),
 m_fModified(FALSE),
 m_fNeedReboot(FALSE)
{
    m_psp.lParam = (LPARAM)this;
    m_pfnOldCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = MqPropSheetPageProc;
}

/////////////////////////////////////////////////////////////////////////////
// MqPropSheetPageProc - replaces the MMC / MFC callback and add release of the
// allocated window.

UINT CALLBACK CMqPropertyPage::MqPropSheetPageProc(
    HWND hWnd, //Reserved, will always be 0
    UINT uMsg,		
    LPPROPSHEETPAGE ppsp)
{
    CMqPropertyPage *pThis = (CMqPropertyPage *)ppsp->lParam;

    ASSERT(0 != pThis->m_pfnOldCallback);

    UINT uiRetVal = pThis->m_pfnOldCallback(hWnd, uMsg, ppsp);

    switch(uMsg)
    {
        case PSPCB_RELEASE:                       
            pThis->OnReleasePage() ;            
            pThis->Release();
    }

    return uiRetVal;
}

BOOL CMqPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
	    ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		    AfxGetApp()->m_pszHelpFilePath,
		    HELP_WM_HELP,
		    (DWORD_PTR)(LPVOID)g_aHelpIDs);
    }
    return TRUE;
}

void CMqPropertyPage::OnContextMenu(CWnd* pWnd, CPoint point)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (this == pWnd)
		return;

	::WinHelp (pWnd->m_hWnd,
		AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU,
		(DWORD_PTR)(LPVOID)g_aHelpIDs);
}

void CMqPropertyPage::OnChangeRWField(BOOL bChanged)
{
    m_fModified = bChanged;
    SetModified(bChanged);	
}

//
// Note: do not change this to use default parameter - this will not work since we use
// this function in message maps
//
void CMqPropertyPage::OnChangeRWField()
{
    OnChangeRWField(TRUE);
}

void CMqPropertyPage::RestartWindowsIfNeeded()
{    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    
    CRestart dlgRestart;     

    if (m_fNeedReboot && dlgRestart.DoModal() == IDOK)
    {
       BOOL fRet = OnRestartWindows();                	       
    }
    
}


void CMqPropertyPage::OnReleasePage()
{       
    RestartWindowsIfNeeded();
}

LRESULT CMqPropertyPage::OnDisplayChange(WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());        
    return CPropertyPageEx::OnDisplayChange(wParam, lParam);
}

void CMqPropertyPage::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CPropertyPageEx::OnSettingChange(uFlags, lpszSection);
}

/////////////////////////////////////////////////////////////////
// CMqDialog

IMPLEMENT_DYNCREATE(CMqDialog, CDialog)

BEGIN_MESSAGE_MAP(CMqDialog, CDialog)
	//{{AFX_MSG_MAP(CMqDialog)
	    ON_WM_HELPINFO()
	    ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMqDialog::CMqDialog()
{
}

CMqDialog::CMqDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd /* = NULL */) :
    CDialog(lpszTemplateName, pParentWnd)
{
}

CMqDialog::CMqDialog(UINT nIDTemplate, CWnd* pParentWnd /* = NULL */) :
    CDialog(nIDTemplate, pParentWnd)
{
}


void CMqDialog::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if (this == pWnd)
		return;

	::WinHelp (pWnd->m_hWnd,
		AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU,
		(DWORD_PTR)(LPVOID)g_aHelpIDs);
}

BOOL CMqDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
	    ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		    AfxGetApp()->m_pszHelpFilePath,
		    HELP_WM_HELP,
		    (DWORD_PTR)(LPVOID)g_aHelpIDs);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mobile.h ===
// Mobile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMobilePage dialog

class CMobilePage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMobilePage)

// Construction
public:
	CMobilePage();
	~CMobilePage();

// Dialog Data
	//{{AFX_DATA(CMobilePage)
	enum { IDD = IDD_MOBILE };
	CComboBox	m_box;
	CString	m_strCurrentSite;
	//}}AFX_DATA
	CString m_szNewSite;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMobilePage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMobilePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   void SetSiteName() ;   
   BOOL  m_fSiteRead ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mqppage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqppage.h

Abstract:

   General property page class - used as base class for all
   mqsnap property pages.

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MQPPAGE_H__
#define __MQPPAGE_H__

#include <tr.h>
#include <ref.h>

/////////////////////////////////////////////////////////////////////////////
// CMqPropertyPage
class CMqPropertyPage : public CPropertyPageEx, public CReference
{
DECLARE_DYNCREATE(CMqPropertyPage)

public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqPropertyPage)
	//}}AFX_VIRTUAL

protected:
  	//{{AFX_MSG(CMqPropertyPage)
    	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
    afx_msg virtual void OnChangeRWField();
    virtual void OnChangeRWField(BOOL bChanged);
    BOOL m_fModified;
    BOOL m_fNeedReboot;
  	CMqPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
    CMqPropertyPage() {};    

    void RestartWindowsIfNeeded(); 

    
    static UINT CALLBACK MqPropSheetPageProc(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    virtual void OnReleasePage() ;

    afx_msg LRESULT OnDisplayChange(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);

private:
    LPFNPSPCALLBACK m_pfnOldCallback;
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMqDialog
class CMqDialog : public CDialog
{
DECLARE_DYNCREATE(CMqDialog)

public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqDialog)
	//}}AFX_VIRTUAL

protected:
  	//{{AFX_MSG(CMqDialog)
    	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	CMqDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CMqDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	CMqDialog();

	DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mqsnhlps.h ===
#define IDH_196_1110 	1110 // IDC_TESTMESSAGE_DESTQ
#define IDH_196_1121 	1121 // IDC_TESTMESSAGE_SEND
#define IDH_196_1122 	1122 // IDC_TESTMESSAGE_CLOSE
#define IDH_196_1111 	1111 // IDC_TESTMESSAGE_NEW
#define IDH_352_1115 	1115 // IDC_NEWQTYPE_QUEUENAME
#define IDH_159_1026 	1026 // IDC_QUEUENAME
#define IDH_159_1128 	1128 // IDC_TRANSACTIONAL
#define IDH_189_1086 	1309 // IDC_LINK_LABEL
#define IDH_189_1036 	1001 // IDC_LINK_COST
#define IDH_146_1004 	1020 // IDC_INROUT_LABEL
#define IDH_146_1091 	1017 // IDC_INROUTCOMBO_0
#define IDH_146_1093 	1018 // IDC_INROUTCOMBO_1
#define IDH_146_1095 	1019 // IDC_INROUTCOMBO_2
#define IDH_146_1006 	1021 // IDC_OUTROUT_LABEL
#define IDH_146_1097 	1023 // IDC_OUTROUTCOMBO_0
#define IDH_146_1100 	1024 // IDC_OUTROUTCOMBO_1
#define IDH_146_1102 	1025 // IDC_OUTROUTCOMBO_2
#define IDH_151_1013 	1304 // IDC_SITE_GATES_LIST
#define IDH_151_1081 	1302 // IDB_SITE_GATE_ADD
#define IDH_151_1084 	1301 // IDC_SITE_FRS_LIST
#define IDH_151_1087 	1303 // IDB_SITE_GATE_REMOVE
#define IDH_153_1005 	1005 // IDC_QGENERAL_QLABEL
#define IDH_153_1007 	1007 // IDC_QGENERAL_TYPEID
#define IDH_155_1015 	1015 // IDC_QMESSAGES_QUOTA
#define IDH_155_1129 	1006 // IDC_QGENERAL_TRANSACTIONAL
#define IDH_155_1014 	1014 // IDC_QMESSAGES_JOURNAL
#define IDH_155_1016 	1016 // IDC_QMESSAGES_JOURNAL_QUOTA
#define IDH_155_1018 	1357 // IDC_QMESSAGES_PRIVLEVEL
#define IDH_351_1108 	1108 // IDC_REPORTQUEUE_NEW
#define IDH_351_1119 	1119 // IDC_TRACK_ALL
#define IDH_351_1120 	1120 // IDC_TRACK_TEST
#define IDH_166_1032 	209  // IDC_MSGLABEL
#define IDH_166_1034 	211  // IDC_MSGID
#define IDH_166_1038 	215  // IDC_MSGPRIORITY
#define IDH_144_1001 	1002 // IDC_COMPUTER_MSMQ_NAME
#define IDH_144_1002 	1318 // IDC_CURRENTSITES_LIST
#define IDH_144_1003 	1356 // IDC_COMPUTER_MSMQ_ID
#define IDH_149_1008 	1317 // IDC_ALLSITES_LIST
#define IDH_153_1010 	1004 // IDC_QGENERAL_NAME
#define IDH_144_1144 	1144 // IDC_MGENERAL_CREATED
#define IDH_144_1145 	1145 // IDC_MGENERAL_MODIFIED
#define IDH_166_1040 	216  // IDC_MSGCLASS
#define IDH_166_1044 	214  // IDC_MSGTRACK
#define IDH_169_1153 	1348 // IDC_FCOMPNAME_LABEL 
#define IDH_169_1154 	1349 // IDC_FOREIGN_COMPUTER_SITE
#define IDH_366_1131 	227  // IDC_MSG_DST_FN
#define IDH_366_1132 	230  // IDC_MSG_DST_PN
#define IDH_366_1133 	228  // IDC_MSG_RSP_FN
#define IDH_366_1134 	231  // IDC_MSG_RSP_PN
#define IDH_366_1135 	229  // IDC_MSG_ADMIN_FN
#define IDH_366_1136 	232  // IDC_MSG_ADMIN_PN
#define IDH_367_1141 	219  // IDC_MSGGUID
#define IDH_367_1142 	220  // IDC_MSGPATHNAME
#define IDH_367_1043 	223  // IDC_MSGAUTHENTICATED
#define IDH_367_1148 	224  // IDC_MSGHASHALG
#define IDH_367_1045 	225  // IDC_MSGENCRYPT
#define IDH_367_1041 	226  // IDC_MSGENCRYPTALG
#define IDH_144_1146 	1146 // IDC_COMPUTER_MSMQ_QUOTA
#define IDH_144_1147 	1147 // IDC_COMPUTER_MSMQ_JOURNAL_QUOTA
#define IDH_155_1164 	1164 // IDC_QUEUE_MQUOTA_CHECK
#define IDH_155_1165 	1165 // IDC_QUEUE_JQUOTA_CHECK
#define IDH_144_1169 	1169 // IDC_COMPUTER_MSMQ_MQUOTA_CHECK
#define IDH_144_1170 	1170 // IDC_COMPUTER_MSMQ_JQUOTA_CHECK
#define IDH_144_1240 	1240 // IDC_COMPUTER_MSMQ_SERVICE
#define IDH_155_1245 	1245 // IDC_QMESSAGES_AUTHENTICATED
#define IDH_155_1241 	1358 // IDC_QUEUE_BASEPRIORITY
#define IDH_166_1242 	217  // IDC_MSGSENT
#define IDH_166_1243 	218  // IDC_MSGARRIVED
#define IDH_169_1251 	1332 // IDC_FOREIGN_SITE_NAME
#define IDH_183_1252 	1252 // IDC_ENT_GEN_LONGLIVE_EDIT
#define IDH_183_1256 	1256 // IDC_ENT_GEN_LONGLIVE_UNITS_COMBO
#define IDH_196_1239 	1123 // IDC_TESTMESSAGE_NO_SENT
#define IDH_364_1246 	1300 // IDC_MESSAGE_BODY_EDIT
#define IDH_367_1250 	221  // IDC_MSGUSER
#define IDH_367_1249 	222  // IDC_MSGSID
#define IDH_151_1077 	1320 // IDC_SITES_REMOVE
#define IDH_151_1244 	1319 // IDC_SITES_ADD
#define IDH_351_1188 	1188 // IDC_MESSAGE_TRACKING_EXPLANATION
#define IDH_351_1109 	1109 // IDC_REPORTQUEUE_NAME
#define IDH_153_1012 	1003 // IDC_QGENERAL_ID
#define IDH_DC_button 	1266 // IDC_DEPENDENT_CLIENTS_REFRESH
#define IDH_DC_window 	1269 // IDC_DEPENDENT_CLIENTS
#define idh_new_link_from 	244 // IDC_FIRST_SITE_COMBO 
#define idh_new_link_to		245 // IDC_SECOND_SITE_COMBO 
#define idh_new_link_cost 	1355 // IDC_LINK_COST_EDIT
#define idh_mqping_button 	1331 // IDC_CERT_VIEW
#define idh_send_test_button 	1327 // IDC_DIAG_SEND_TEST
#define idh_tracking_button 	1329 // IDC_DIAG_TRACKING
#define idh_computer_os 	1241 // IDC_COMPUTER_MSMQ_OS
#define idh_message_size 250 // IDC_MBODY_SIZE_MESSAGE
#define idh_cert_list 1310 // IDC_CERT_LIST
#define idh_cert_view 1311 // IDC_CERT_VIEW
#define idh_cert_remove 1312 // IDC_CERT_REMOVE
#define IDH_ALIAS_LABEL			1411 // IDC_ALIAS_LABEL
#define IDH_ALIAS_FORMATNAME    1413 // IDC_ALIAS_FORMATNAME
#define IDH_ALIAS_DESCRIPTION	1415 // IDC_ALIAS_DESCRIPTION
#define IDH_NEWALIAS_PATHNAME	1419 // IDC_NEWALIAS_PATHNAME
#define IDH_NEWALIAS_FORMATNAME	1421 // IDC_NEWALIAS_FORMATNAME
#define IDH_MSG_MULTIDST_FN     1173 // IDC_MSG_MULTIDST_FN
#define IDH_QMULTICAST_QADDRESS 1009 // IDC_QMULTICAST_QADDRESS
#define IDH_FIND_EDITLABEL              1353 // IDC_FIND_EDITLABEL
#define IDH_FIND_EDITTYPE               1000 // IDC_FIND_EDITTYPE
#define IDH_QNAME_PRIVATE_TITLE         1369 // IDC_QNAME_PRIVATE_TITLE
#define IDH_CREATE_IN                   1514 // IDC_CREATE_IN
#define IDH_ALIAS_CONTAINER             1515 // IDC_ALIAS_CONTAINER
#define IDH_ROUTING_LINK_CONTAINER      1519 // IDC_ROUTING_LINK_CONTAINER
#define IDH_FOREIGN_SITE_CONTAINER      1523 // IDC_FOREIGN_SITE_CONTAINER
#define IDH_QUEUE_CONTAINER             1525 // IDC_QUEUE_CONTAINER
#define IDH_FOREIGN_COMPUTER_CONTAINER  1528 // IDC_FOREIGN_COMPUTER_CONTAINER
#define IDH_LINK_DESCR                  10930 //IDC_LINK_DESCR


//
// Trigger UI
//
#define IDH_TRIGGER_GENERAL_HEADER      1424 // IDC_TRIGGER_GENERAL_HEADER
#define IDH_InitThreadsCount            1428 // IDC_InitThreadsCount
#define IDH_MaxThreadCount              1429 // IDC_MaxThreadCount
#define IDH_DefaultMsgBodySize          1430 // IDC_DefaultMsgBodySize
#define IDH_ConditionValue              1431 // IDC_ConditionValue
#define IDH_RULE_DESCRIPTION            1432 // IDC_RULE_DESCRIPTION
#define IDH_RULE_COND_TYPES             1434 // IDC_RULE_COND_TYPES
#define IDH_RULECOND_LIST              10835 // IDC_RULECOND_LIST
#define IDH_AddRuleCondition_BTM        1437 // IDC_AddRuleCondition_BTM
#define IDH_RULE_LIST                   1438 // IDC_RULE_LIST
#define IDH_RemoveCondition             1439 // IDC_RemoveCondition
#define IDH_RULE_NAME                   1440 // IDC_RULE_NAME
#define IDH_INVOKE_COM                  1446 // IDC_INVOKE_COM
#define IDH_INVOKE_EXE                  1447 // IDC_INVOKE_EXE
#define IDH_SHOW_WINDOW                 1448 // IDC_SHOW_WINDOW
#define IDH_COMPONENT_PROGID            1452 // IDC_COMPONENT_PROGID
#define IDH_COMMETHOD_NAME              1453 // IDC_COMMETHOD_NAME
#define IDH_EXE_PATH                    1454 // IDC_EXE_PATH
#define IDH_RULE_GENERAL_TITLE          1464 // IDC_RULE_GENERAL_TITLE
#define IDH_FIND_EXE_BTM                1469 // IDC_FIND_EXE_BTM
#define IDH_PARAM_BTM                   1470 // IDC_PARAM_BTM
#define IDH_PARAM_ORDER_UP              1478 // IDB_PARAM_ORDER_UP
#define IDH_PARM_REMOVE                 1479 // IDB_PARM_REMOVE
#define IDH_PARAM_ADD                   1480 // IDB_PARAM_ADD
#define IDH_PARM_ORDER_DOWN             1481 // IDB_PARM_ORDER_DOWN
#define IDH_PARAM_COMBO                 1482 // IDC_PARAM_COMBO
#define IDH_LITERAL_PARAM               1483 // IDC_LITERAL_PARAM
#define IDH_INVOKE_PARMETER_LIST        1485 // IDC_INVOKE_PARMETER_LIST
#define IDH_TriggerName_EDIT            1488 // IDC_TriggerName_EDIT
#define IDH_QueuePathName               1489 // IDC_QueuePathName
#define IDH_FRAME_GROUP                 1490 // IDC_SysyetmQueue_GROUP (use this IDH for all frames)
#define IDH_QueueMessages_RDB           1491 // IDC_QueueMessages_RDB
#define IDH_JournalMessages_RDB         1492 // IDC_JournalMessages_RDB
#define IDH_DeadlLetter_RDB             1493 // IDC_DeadlLetter_RDB
#define IDH_TransactionalDeadLetter_RDB 1494 // IDC_TransactionalDeadLetter_RDB
#define IDH_Enabled_CHK                 1496 // IDC_Enabled_CHK
#define IDH_Serialized_CHK              1497 // IDC_Serialized_CHK
#define IDH_AttachedRule                1501 // IDC_AttachedRule
#define IDH_RemoveRule_BTM              1503 // IDC_RemoveRule_BTM
#define IDH_UpRule_BTM                  1504 // IDC_UpRule_BTM
#define IDH_Down_BTM                    1505 // IDC_Down_BTM
#define IDH_ATTACH_RULES_BTM            1506 // IDC_ATTACH_RULES_BTM
#define IDH_ADD_RULE                    1507 // IDC_ADD_RULE
#define IDH_PeekMessage_RDB             1508 // IDC_PeekMessage_RDB
#define IDH_ReceiveMessage_RDB          1509 // IDC_ReceiveMessage_RDB
#define IDH_ReceiveMessageXact_RDB      1510 // IDC_ReceiveMessageXact_RDB

//
// From control panel: cpl\cplhlps.h
//
#define IDH_107_1038	68026475	// Storage: "To maximize MSMQ messaging speed, specify multiple disk drives for storing message information." (Static)
#define IDH_110_1017	66650222	// Mobile: "" (ComboBox)
#define IDH_110_1018	66715758	// Mobile: "" (Edit)
#define IDH_107_1046	68550763	// Storage: "" (Edit)
#define IDH_150_1047	68616342	// MSMQ Client: "" (Edit)
#define IDH_107_1048	68681835	// Storage: "" (Edit)
#define IDH_108_1025	67174508	// Security: "Controller Server Communications" (Button)
#define IDH_108_1026	67240044	// Security: "Use only secured connections when communicating with MSMQ controller server?" (Static)
#define IDH_108_1027	67305580	// Security: "Encryption Key" (Button)
#define IDH_110_1030	67502190	// Mobile: "If you are moving your computer to a new site and expect your messages to be waiting there when you arrive, specify the new site before disconnecting from the network" (Static)
#define IDH_108_1031	67567724	// Security: "User Certificates" (Button)
#define IDH_108_1032	67633260	// Security: "Register certificates in MSMQ Information Store (MQIS)" (Static)
#define IDH_108_1033	67698796	// Security: "View a list of all registered certificates in MQIS" (Static)
#define IDH_108_1034	67764332	// Security: "Remove certificates from MQIS" (Static)
#define IDH_108_1035	67829868	// Security: "Internal Certificate" (Button)
#define IDH_107_1012	66322539	// Storage: "" (Edit)
#define IDH_158_1063    69664926    // Server Certificates 
#define IDH_FRAME_HELP  60000001    // Unified help for all frames

const DWORD g_aHelpIDs[]=
{
    IDC_TESTMESSAGE_DESTQ,  IDH_196_1110,   // Send Test Message: "" (ComboBox)
    IDC_TESTMESSAGE_DESTQ_LABEL,    IDH_196_1110,   // Send Test Message: "Destination Queue:" (Static)
    IDC_TESTMESSAGE_SEND,   IDH_196_1121,   // Send Test Message: "&Send" (Button)
    IDC_TESTMESSAGE_CLOSE,  IDH_196_1122,   // Send Test Message: "&Close" (Button)
    IDC_TESTMESSAGE_NEW,    IDH_196_1111,   // Send Test Message: "&New Queue..." (Button)
    IDC_NEWQTYPE_QUEUENAME_LABEL,   IDH_352_1115,   // New Queue Pathname?: "Pathname (computer\queue):" (Static)
    IDC_NEWQTYPE_QUEUENAME, IDH_352_1115,
    IDC_QUEUENAME,  IDH_159_1026,   // Queue Name: "" (Edit)
    IDC_QUEUENAME_LABEL,  IDH_159_1026,   // Queue Name: "" (Edit)
    IDC_TRANSACTIONAL,  IDH_159_1128,   // Queue Name: "&Transactional" (Button)
    IDC_LINK_LABEL, IDH_189_1086,   // Site links: "" (Edit)
    IDC_LINK_COST_LABEL, IDH_189_1036,   // Site links: "" (Edit)
    IDC_LINK_COST, IDH_189_1036,   // Site links: "" (Edit)
    IDC_INROUT_LABEL,    IDH_146_1004,   // Client: "&In Routing Servers" (Button)
    IDC_INROUTCOMBO_0, IDH_146_1091,
    IDC_INROUTCOMBO_1, IDH_146_1093,
    IDC_INROUTCOMBO_2, IDH_146_1095,
    IDC_OUTROUT_LABEL, IDH_146_1006,
    IDC_OUTROUTCOMBO_0, IDH_146_1097,
    IDC_OUTROUTCOMBO_1, IDH_146_1100,
    IDC_OUTROUTCOMBO_2, IDH_146_1102,
    IDC_SITE_GATES_LIST,IDH_151_1013,   // Connections: "List1" (SysListView32)
    IDC_SITE_GATE_LABEL,IDH_151_1013,   // Connections: "Site &Gates" (Static)
    IDB_SITE_GATE_ADD,  IDH_151_1081,   // Connections: "Add ..." (Button)
    IDC_SITE_FRS_LIST,  IDH_151_1084,   // Connections: "Edit ..." (Button)
    IDC_SITE_FRS_LABEL,  IDH_151_1084,   // Connections: "Edit ..." (Button)
    IDB_SITE_GATE_REMOVE,IDH_151_1087,   // Connections: "Remove" (Button)
    IDC_QGENERAL_NAME, IDH_153_1010,
    IDC_QGENERAL_QLABEL,IDH_153_1005,   // General: "" (Edit)
    IDC_QGENERAL_QLABEL_LABEL,    IDH_153_1005,   // General: "&Label:" (Static)
    IDC_QGENERAL_TYPEID,    IDH_153_1007,   // General: "" (Edit)
    IDC_QGENERAL_TYPEID_LABEL,  IDH_153_1007,   // General: "&Type ID:" (Static)
    IDC_QMESSAGES_QUOTA,    IDH_155_1015,   // Advanced: "" (Edit)
    IDC_QGENERAL_TRANSACTIONAL_LABEL,    IDH_155_1129,   // Advanced: "&Transactional" (Button)
    IDC_QGENERAL_TRANSACTIONAL,    IDH_155_1129,   // Advanced: "&Transactional" (Button)
    IDC_QMESSAGES_JOURNAL,  IDH_155_1014,   // Advanced: "&Enabled" (Button)
    IDC_QUEUE_JQUOTA_CHECK, IDH_155_1016,   // Advanced: "" (Edit)
    IDC_QMESSAGES_JOURNAL_QUOTA, IDH_155_1016,   // Advanced: "" (Edit)
    IDC_QMESSAGES_PRIVLEVEL,    IDH_155_1018,   // Advanced: "" (ComboBox)
    IDC_QUEUE_ENCRIPTION_LABEL, IDH_155_1018,   // Advanced: "Privacy &Level:" (Static)
    IDC_REPORTQUEUE_NEW,    IDH_351_1108,   // Tracking: "&New..." (Button)
    IDC_TRACK_ALL,  IDH_351_1119,   // Tracking: "Track &all messages" (Button)
    IDC_TRACK_TEST, IDH_351_1120,   // Tracking: "Track only &test message" (Button)
    IDC_MSGGNRL_TITLE_LABEL,    IDH_166_1032,   // General: "Label:" (Static)
    IDC_MSGLABEL,  IDH_166_1032,   // General: "" (Edit)
    IDC_MSGGNRL_ID_LABEL,   IDH_166_1034,   // General: "ID:" (Static)
    IDC_MSGID, IDH_166_1034,   // General: "" (Edit)
    IDC_MSGGNRL_PRIORITY_LABEL, IDH_166_1038,   // General: "Priority:" (Static)
    IDC_MSGPRIORITY,   IDH_166_1038,   // General: "" (Edit)
    IDC_COMPUTER_MSMQ_NAME,    IDH_144_1001, 
    IDC_CURRENTSITES_LIST,    IDH_144_1002,  
    IDC_CURRENTSITES_LABEL,    IDH_144_1002,  
    IDC_COMPUTER_MSMQ_ID,  IDH_144_1003,
    IDC_COMPUTER_MSMQ_ID_LABEL,  IDH_144_1003,
    IDC_ALLSITES_LIST,    IDH_149_1008,
    IDC_ALLSITES_LABEL,    IDH_149_1008,
    IDC_MSGGNRL_CLASS_LABEL,    IDH_166_1040,   // General: "Class:" (Static)
    IDC_MSGCLASS,  IDH_166_1040, 
    IDC_MSGTRACK,    IDH_166_1044, 
    IDC_MSGGNRL_TRACKED_LABEL,  IDH_166_1044,   // General: "Tracked:" (Static)
    IDC_FOREIGN_COMPUTER_NAME,   IDH_169_1153,   // New Foreign Computer: "&Foreign Connected Networks:" (Static)
    IDC_FCOMPNAME_LABEL,   IDH_169_1153,   // New Foreign Computer: "&Foreign Connected Networks:" (Static)
    IDC_FOREIGN_COMPUTER_SITE,  IDH_169_1154,   // New Foreign Computer: "" (ListBox)
    IDC_FCOMPSITE_LABEL,    IDH_169_1154,   // New Foreign Computer: "&Member of:" (Static)
    IDC_MSG_DST_FN, IDH_366_1131, 
    IDC_MQUEUE_DEST_FORMAT_LABEL,   IDH_366_1131,   // Queues: "Format Name:" (Static)
    IDC_MSG_DST_PN,   IDH_366_1132, 
    IDC_MQUEUE_DEST_PATH_LABEL, IDH_366_1132,   // Queues: "Name:" (Static)
    IDC_MSG_RSP_FN, IDH_366_1133,   // Queues: "" (Edit)
    IDC_MQUEUE_RESPONSE_FORMAT_LABEL,   IDH_366_1133,   // Queues: "Format Name:" (Static)
    IDC_MSG_RSP_PN,   IDH_366_1134,   // Queues: "" (Edit)
    IDC_MQUEUE_RESPONSE_PATH_LABEL, IDH_366_1134,   // Queues: "Name:" (Static)
    IDC_MSG_ADMIN_FN,    IDH_366_1135, 
    IDC_MQUEUE_ADMIN_FORMAT_LABEL,  IDH_366_1135,   // Queues: "Format Name:" (Static)
    IDC_MQUEUE_ADMIN_PATH_LABEL,    IDH_366_1136,   // Queues: "Name:" (Static)
    IDC_MSG_ADMIN_PN,  IDH_366_1136,   // Queues: "" (Edit)
    IDC_MSENDER_SOURCE_GUID_LABEL,  IDH_367_1141,   // Sender: "GUID:" (Static)
    IDC_MSGGUID,    IDH_367_1141,   // Sender: "" (Edit)
    IDC_MSENDER_SOURCE_PATH_LABEL,  IDH_367_1142,   // Sender: "Pathname:" (Static)
    IDC_MSGPATHNAME,    IDH_367_1142,
    IDC_MSGAUTHENTICATED,  IDH_367_1043,   // Sender: "" (Edit)
    IDC_MSENDER_AUTHENTICATED_LABEL,    IDH_367_1043,   // Sender: "Authenticated:" (Static)
    IDC_MSENDER_HASH_ALG_LABEL, IDH_367_1148,   // Sender: "Hash Algorithm:" (Static)
    IDC_MSGHASHALG,   IDH_367_1148,
    IDC_MSGENCRYPT,  IDH_367_1045,   // Sender: "" (Edit)
    IDC_MSENDER_ENCRYPTED_LABEL,    IDH_367_1045,   // Sender: "Encrypted:" (Static)
    IDC_MSGENCRYPTALG,    IDH_367_1041,   // Sender: "" (Edit)
    IDC_MSENDER_ENCRYPT_ALG_LABEL,  IDH_367_1041,   // Sender: "Encryption Algorithm:" (Static)
    IDC_COMPUTER_MSMQ_QUOTA, IDH_144_1146,   // General: "" (Edit)
    IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDH_144_1147,   // General: "" (Edit)
    IDC_QUEUE_MQUOTA_CHECK, IDH_155_1164,   // Advanced: "Limit &message storage (in K) to:" (Button)
    IDC_QUEUE_JQUOTA_CHECK, IDH_155_1165,   // Advanced: "Limit journal &storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_MQUOTA_CHECK,   IDH_144_1169,   // General: "Limit &message storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_JQUOTA_CHECK,   IDH_144_1170,   // General: "Limit journal &storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_SERVICE_LABEL, IDH_144_1240,   // General: "Service:" (Static)
    IDC_COMPUTER_MSMQ_SERVICE,   IDH_144_1240,   // General: "" (Edit)
    IDC_QMESSAGES_AUTHENTICATED,    IDH_155_1245,   // Advanced: "&Authenticated" (Button)
    IDC_BASEPRIORITY_SPIN,  IDH_155_1241,   // Advanced: "Spin1" (msctls_updown32)
    IDC_QUEUE_BASEPRIORITY_LABEL,   IDH_155_1241,   // Advanced: "Base &Priority:" (Static)
    IDC_QUEUE_BASEPRIORITY, IDH_155_1241,   // Advanced: "0" (Edit)
    IDC_MSGGNRL_SENT_TIME_LABEL,    IDH_166_1242,   // General: "Sent:" (Static)
    IDC_MSGSENT,  IDH_166_1242,   // General: "" (Edit)
    IDC_MSGARRIVED,   IDH_166_1243,   // General: "" (Edit)
    IDC_MSGGNRL_ARRIVED_TIME_LABEL, IDH_166_1243,   // General: "Arrived:" (Static)
    IDC_FOREIGN_SITE_NAME,  IDH_169_1251,   // New Object - Foreign Site: "" (Edit)
    IDC_FOREIGN_SITE_LABEL,  IDH_169_1251,   // New Object - Foreign Site: "Foreign site name:" (Static)
    IDC_ENT_GEN_LONGLIVE_EDIT,  IDH_183_1252,   // General: "" (Edit)
    IDC_ENT_GEN_LONGLIVE_EDIT_LABEL,  IDH_183_1252,   // General: "" (Edit)
    IDC_EGENERAL_DEFINITIONS_FRAME,  IDH_183_1252,   // General: "" (Edit)
    IDC_ENT_GEN_LONGLIVE_UNITS_COMBO,   IDH_183_1256,   // General: "" (ComboBox)
    IDC_TESTMESSAGE_NO_SENT,    IDH_196_1239,   // Send Test Message: "0" (Static)
    IDC_TESTMESSAGE_NO_SENT_LABEL,  IDH_196_1239,   // Send Test Message: "Messages sent" (Static)
    IDC_MESSAGE_BODY_EDIT,  IDH_364_1246,   // Body: "" (Edit)
    IDC_MSGUSER,    IDH_367_1250,   // Sender: "" (Edit)
    IDC_MSENDER_UID_LABEL,  IDH_367_1250,   // Sender: "User:" (Static)
    IDC_MSGSID,    IDH_367_1249,   // Sender: "" (Edit)
    IDC_MSENDER_SID_LABEL,  IDH_367_1249,   // Sender: "SID:" (Static)
    IDC_SITES_REMOVE,  IDH_151_1077,   // Connections: "Edit ..." (Button)
    IDC_SITES_ADD,   IDH_151_1244,   // Connections: "Add ..." (Button)
    IDC_MESSAGE_TRACKING_EXPLANATION,   IDH_351_1188,   // Tracking: "Route tracking messages will be sent to the report queue." (Static)
    IDC_REPORTQUEUE_NAME,   IDH_351_1109,   // Tracking: "" (ComboBox)
    IDC_REPORTQUEUE_NAME_LABEL, IDH_351_1109,   // Tracking: "Pathname of &report queue:" (Static)
    IDC_QGENERAL_ID,       IDH_153_1012,   // General: "" (Edit)
    IDC_QGENERAL_ID_LABEL, IDH_153_1012,   // General: "" (Edit)
    IDC_DEPENDENT_CLIENTS_REFRESH, IDH_DC_button,
    IDC_DEPENDENT_CLIENTS, IDH_DC_window,
    IDC_DEPCLIENTS_LABEL, IDH_DC_window,
    IDC_FIRST_SITE_LABEL, idh_new_link_from,
    IDC_FIRST_SITE_COMBO, idh_new_link_from,
    IDC_SECOND_SITE_LABEL, idh_new_link_to,
    IDC_SECOND_SITE_COMBO, idh_new_link_to,
    IDC_LINK_COST_LABEL, idh_new_link_cost,
    IDC_LINK_COST_EDIT, idh_new_link_cost,
    IDC_DIAG_PING, idh_mqping_button,
    IDC_DIAG_PING_ICON, idh_mqping_button,
    IDC_DIAG_PING_LABEL, idh_mqping_button,
    IDC_DIAG_SEND_TEST, idh_send_test_button,
    IDC_DIAG_SENDTEST_ICON, idh_send_test_button,
    IDC_DIAG_SENDTEST_LABEL, idh_send_test_button,
    IDC_DIAG_TRACKING, idh_tracking_button,
    IDC_DIAG_TRACKING_ICON, idh_tracking_button,
    IDC_DIAG_TRACKING_LABEL, idh_tracking_button,  
    IDC_MBODY_SIZE_MESSAGE, idh_message_size,
    IDC_CERT_LIST, idh_cert_list,
    IDC_CERT_VIEW, idh_cert_view,
    IDC_CERT_REMOVE, idh_cert_remove,
    IDC_ALIAS_LABEL, IDH_ALIAS_LABEL,                   // 1411
    IDC_ALIAS_FORMATNAME_LABEL, IDH_ALIAS_FORMATNAME,   // 1412
    IDC_ALIAS_FORMATNAME, IDH_ALIAS_FORMATNAME,         // 1413
    IDC_ALIAS_DESCRIPTION_LABEL, IDH_ALIAS_DESCRIPTION, // 1414
    IDC_ALIAS_DESCRIPTION, IDH_ALIAS_DESCRIPTION,       // 1415
    IDC_NEWALIAS_PATHNAME_LABEL, IDH_NEWALIAS_PATHNAME, // 1418
    IDC_NEWALIAS_PATHNAME, IDH_NEWALIAS_PATHNAME,       // 1419
    IDC_NEWALIAS_FORMATNAME_LABEL, IDH_NEWALIAS_FORMATNAME, // 1420
    IDC_NEWALIAS_FORMATNAME, IDH_NEWALIAS_FORMATNAME,   // 1421
    IDC_MQUEUE_MULTIDEST_FORMAT_LABEL, IDH_MSG_MULTIDST_FN, //1172
    IDC_MSG_MULTIDST_FN, IDH_MSG_MULTIDST_FN,               //1173
    IDC_MQUEUE_DEST_FRAME, IDH_FRAME_GROUP, //  = 1200 = 1490
    IDC_MQUEUE_MULTIDEST_FRAME, IDH_FRAME_GROUP, // 1171 = 1490
    IDC_MQUEUE_ADMIN_FRAME, IDH_FRAME_GROUP, //  1206 = 1490
    IDC_MQUEUE_RESP_FRAME, IDH_FRAME_GROUP, //  1203 = 1490
    IDC_QMULTICAST_QADDRESS, IDH_QMULTICAST_QADDRESS, //1009
    IDC_QMULTICAST_QADDRESS_LABEL, IDH_QMULTICAST_QADDRESS, //1009 = 1227
    IDC_QMULTICAST_QADDRESS_DESCRIPTION, IDH_QMULTICAST_QADDRESS, //1009 = 1512
    IDC_MSENDER_SOURCE_FRAME, IDH_FRAME_GROUP, //  1209 = 1490
    IDC_MSENDER_SENDER_FRAME, IDH_FRAME_GROUP, //  1212 = 1490
    IDC_MSENDER_SECURITY_FRAME, IDH_FRAME_GROUP, //  1213 = 1490
    IDC_FIND_EDITLABEL, IDH_FIND_EDITLABEL, // 1353
    IDC_FIND_LABEL_LABEL, IDH_FIND_EDITLABEL, // 1354 = 1353
    IDC_FIND_EDITTYPE, IDH_FIND_EDITTYPE,  // 1000
    IDC_FIND_TYPE_LABEL, IDH_FIND_EDITTYPE,  // 1516 = 1000
    IDC_QNAME_PRIVATE_TITLE, IDH_QNAME_PRIVATE_TITLE, //1369
    IDC_CREATE_IN, IDH_CREATE_IN, // 1514
    IDC_ALIAS_CONTAINER, IDH_ALIAS_CONTAINER, // 1515
    IDC_ROUTING_LINK_CONTAINER, IDH_ROUTING_LINK_CONTAINER, // 1519
    IDC_FOREIGN_SITE_CONTAINER, IDH_FOREIGN_SITE_CONTAINER, // 1523
    IDC_QUEUE_CONTAINER, IDH_QUEUE_CONTAINER, // 1525
    IDC_FOREIGN_COMPUTER_CONTAINER, IDH_FOREIGN_COMPUTER_CONTAINER, // 1528
	IDC_LINK_DESCR, IDH_LINK_DESCR, // 10930
	IDC_LINK_DESCR_LABEL, IDH_LINK_DESCR, // 10929 = 10930

    //
    // Trigger UI
    //
    IDC_TRIGGER_GENERAL_HEADER, IDH_TRIGGER_GENERAL_HEADER, //1424
    IDC_InitThreadsCount_LABEL, IDH_InitThreadsCount, //1425 = 1428 (these have the same help)
    IDC_MaxThreadCount_LABEL, IDH_MaxThreadCount, // 1426 = 1429
    IDC_DefaultMsgBodySize_LABEL, IDH_DefaultMsgBodySize, //1427 = 1430
    IDC_InitThreadsCount, IDH_InitThreadsCount, //1428
    IDC_MaxThreadCount, IDH_MaxThreadCount, //1429
    IDC_DefaultMsgBodySize, IDH_DefaultMsgBodySize, // 1430
    IDC_ConditionValue, IDH_ConditionValue, // 1431
    IDC_RULE_DESCRIPTION, IDH_RULE_DESCRIPTION, // 1432
    IDC_RULE_COND_TYPES, IDH_RULE_COND_TYPES, // 1434
	IDC_RULECOND_LIST, IDH_RULECOND_LIST, // 10835
    IDC_AddRuleCondition_BTM, IDH_AddRuleCondition_BTM, // 1437
    IDC_RULE_LIST, IDH_RULE_LIST, //1438
    IDC_RemoveCondition, IDH_RemoveCondition, // 1439
    IDC_RULE_NAME, IDH_RULE_NAME, // 1440
    IDC_RuleName_LABEL, IDH_RULE_NAME, // 1441 = 1440
    IDC_RuleDescription_LABEL, IDH_RULE_DESCRIPTION, // 1442 = 1432
    IDC_INVOKE_COM, IDH_INVOKE_COM, // 1446
    IDC_INVOKE_EXE, IDH_INVOKE_EXE, // 1447
    IDC_SHOW_WINDOW, IDH_SHOW_WINDOW, // 1448
    IDC_PROID_LABEL, IDH_COMPONENT_PROGID, // 1449 = 1452
    IDC_EXEPATH_LABEL, IDH_EXE_PATH, // 1450 = 1454
    IDC_METHOD_LABEL, IDH_COMMETHOD_NAME, // 1451 = 1453
    IDC_COMPONENT_PROGID, IDH_COMPONENT_PROGID, // 1452
    IDC_COMMETHOD_NAME, IDH_COMMETHOD_NAME, // 1453
    IDC_EXE_PATH, IDH_EXE_PATH, // 1454
    IDC_RULE_GENERAL_TITLE, IDH_RULE_GENERAL_TITLE, // 1464
    IDC_EXE_INVOKE, IDH_FRAME_GROUP, // 1465 = 1490
    IDC_COM_INVOKE, IDH_FRAME_GROUP, // 1466 = 1490
    IDC_FIND_EXE_BTM, IDH_FIND_EXE_BTM, // 1469
    IDC_PARAM_BTM, IDH_PARAM_BTM, // 1470
    IDC_RULE_PARM_LABEL, IDH_PARAM_COMBO, // 1471 = 1482
    IDC_INVOKE_PARAM_LABEL, IDH_INVOKE_PARMETER_LIST, // 1473 = 1485
    IDB_PARAM_ORDER_UP, IDH_PARAM_ORDER_UP, // 1478
    IDB_PARM_REMOVE, IDH_PARM_REMOVE, //1479
    IDB_PARAM_ADD, IDH_PARAM_ADD, // 1480
    IDB_PARM_ORDER_DOWN, IDH_PARM_ORDER_DOWN, // 1481
    IDC_PARAM_COMBO, IDH_PARAM_COMBO, // 1482
    IDC_LITERAL_PARAM, IDH_LITERAL_PARAM, // 1483
    IDC_LITERAL_VALUE, IDH_LITERAL_PARAM, // 1484 = 1483
    IDC_INVOKE_PARMETER_LIST, IDH_INVOKE_PARMETER_LIST, // 1485
    IDC_TriggerName_LABEL, IDH_TriggerName_EDIT, // 1486 = 1488
    IDC_QueuePathname_LABEL, IDH_QueuePathName, // 1487 = 1489
    IDC_TriggerName_EDIT, IDH_TriggerName_EDIT, // 1488
    IDC_QueuePathName, IDH_QueuePathName, // 1489
    IDC_SysyetmQueue_GROUP, IDH_FRAME_GROUP, // 1490
    IDC_QueueMessages_RDB, IDH_QueueMessages_RDB, // 1491
    IDC_JournalMessages_RDB, IDH_JournalMessages_RDB, // 1492
    IDC_DeadlLetter_RDB, IDH_DeadlLetter_RDB, // 1493
    IDC_TransactionalDeadLetter_RDB, IDH_TransactionalDeadLetter_RDB, // 1494
    IDC_Enabled_CHK, IDH_Enabled_CHK, // 1496
    IDC_Serialized_CHK, IDH_Serialized_CHK, // 1497
    IDC_ATTACHED_RULE_LIST, IDH_AttachedRule, // 1499 = 1501
    IDC_RuleList_LABEL, IDH_RULE_LIST, // 1500 = 1438
    IDC_AttachedRule, IDH_AttachedRule, // 1501
    IDC_RemoveRule_BTM, IDH_RemoveRule_BTM, // 1503
    IDC_UpRule_BTM, IDH_UpRule_BTM, // 1504
    IDC_Down_BTM, IDH_Down_BTM, // 1505
    IDC_ATTACH_RULES_BTM, IDH_ATTACH_RULES_BTM, // 1506
    IDC_ADD_RULE, IDH_ADD_RULE, // 1507
    IDC_PeekMessage_RDB, IDH_PeekMessage_RDB, // 1508 
    IDC_ReceiveMessage_RDB, IDH_ReceiveMessage_RDB, // 1509
    IDC_ReceiveMessageXact_RDB, IDH_ReceiveMessageXact_RDB, // 1510
    IDC_MsgProcessingType_Group, IDH_FRAME_GROUP, // 1511 = 1490
    //
    // from control panel: cpl\cplhlps.h
    //
    IDC_Storage_Explanation_LABEL1, IDH_107_1038,
    IDC_Storage_Explanation_LABEL2, IDH_107_1038,
    ID_SiteList_LABEL, IDH_110_1017,
    ID_SiteList, IDH_110_1017,
    ID_CurrentSite, IDH_110_1018,
    ID_CurrentSite_LABEL, IDH_110_1018,
    ID_MessageLogger_LABEL, IDH_107_1046,
    ID_MessageLogger, IDH_107_1046,
    IDC_ServerName, IDH_150_1047,
    IDC_ServerName_LABEL, IDH_150_1047,
    ID_TransactionLogger_LABEL , IDH_107_1048,
    ID_TransactionLogger , IDH_107_1048,
    IDC_CAS, IDH_108_1025,
    IDC_USE_SECURED_SEVER_COMM, IDH_108_1026,
    ID_RenewCryp, IDH_108_1027,
    IDC_CRYPTO_KEYS_LABEL, IDH_108_1027,
    IDC_Mobile_Explanation_LABEL, IDH_110_1030,
    ID_RenewCert, IDH_108_1031,
    ID_Register, IDH_108_1032,
    ID_Register_LABEL, IDH_108_1032,
    ID_View_LABEL, IDH_108_1033,
    ID_View, IDH_108_1033,
    ID_Remove_LABEL, IDH_108_1034,
    ID_Remove, IDH_108_1034,
    ID_RenewCert, IDH_108_1035,
    ID_MessageFiles_LABEL, IDH_107_1012,
    ID_MessageFiles, IDH_107_1012,
    IDC_SERVER_AUTHENTICATION_LABEL, IDH_158_1063,
    IDC_SERVER_AUTHENTICATION, IDH_158_1063,
    IDC_MOBILE_FRAME, IDH_FRAME_HELP,
    IDC_Security_Cert_FRAME, IDH_FRAME_HELP,
    IDC_SERVER_COMM_FRAME, IDH_FRAME_HELP,
    IDC_Security_InternalCert_LABEL, IDH_FRAME_HELP,
    IDC_CRYPTO_KEYS_FRAME, IDH_FRAME_HELP,
    IDC_SERVER_AUTHENTICATION_FRAME, IDH_FRAME_HELP,  
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgbody.cpp ===
// msgbody.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgbody.h"
#include "globals.h"

#include "msgbody.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage property page

IMPLEMENT_DYNCREATE(CMessageBodyPage, CMqPropertyPage)

CMessageBodyPage::CMessageBodyPage() : CMqPropertyPage(CMessageBodyPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageBodyPage)
	m_strBodySizeMessage = _T("");
	//}}AFX_DATA_INIT
}

CMessageBodyPage::~CMessageBodyPage()
{
}

void CMessageBodyPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessageBodyPage)
	DDX_Control(pDX, IDC_MESSAGE_BODY_EDIT, m_ctlBodyEdit);
	DDX_Text(pDX, IDC_MBODY_SIZE_MESSAGE, m_strBodySizeMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageBodyPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageBodyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage message handlers

BOOL CMessageBodyPage::OnInitDialog() 
{
  	UpdateData( FALSE );
	
    static CFont font;
    static UINT nBytesPerLine = 0;

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        //
        // Create font and calculate char width - needed only once in the
        // application's activation
        //
        if (0 == nBytesPerLine)
        {
            LOGFONT lf = {0,0,0,0,0,0,0,0,0,0,0,0, FIXED_PITCH, TEXT("")};
            font.CreateFontIndirect(&lf);
            m_ctlBodyEdit.SetFont(&font);

            CDC *pdc = m_ctlBodyEdit.GetDC();
    
            INT iCharWidth;
            //
            // This is a fixed pitch font - so it is enough to pick one 
            // char by random ("A" in this case) and calculate its width
            //
            pdc->GetCharWidth(65,65,&iCharWidth);
            m_ctlBodyEdit.ReleaseDC(pdc);
  
            RECT rectText;
            m_ctlBodyEdit.GetRect(&rectText);

            //
            // We always have a vertical scroll bar
            //
            UINT nNumChars = (rectText.right - rectText.left - GetSystemMetrics(SM_CXVSCROLL)) / iCharWidth;

            //
            // Every byte occupys one char for ASCII representation, and three (two digits and 
            // a space) for hex representation - total of four.
            //
            nBytesPerLine = nNumChars/4;
        }
        else
        {
            m_ctlBodyEdit.SetFont(&font);
        }

        CString strFullText(TEXT(""));

        for (DWORD iStartLine = 0; iStartLine < m_dwBufLen;
             iStartLine += nBytesPerLine)
        {
            CString strHexLine(TEXT(""));
            DWORD iEndOfLine = min(m_dwBufLen, iStartLine + nBytesPerLine);
	        for (DWORD i=iStartLine; i<iStartLine + nBytesPerLine; i++)
            {
                if (i<m_dwBufLen)
                {
                    CString strHex;
                    ULONG ulTempValue = m_Buffer[i];
                    strHex.Format(TEXT("%02X "), ulTempValue);
                    strHexLine += strHex;
                }
                else
                {
                    //
                    // Pad the hex line with spaces
                    //
                    strHexLine += TEXT("   ");
                }
            }
            CString strLineText;
            CAUB caubLine;
            caubLine.cElems = iEndOfLine - iStartLine;
            caubLine.pElems = &m_Buffer[iStartLine];
            CaubToString(&caubLine, strLineText);

            strFullText += strHexLine + strLineText + TEXT("\r\n");
        }
    
        m_ctlBodyEdit.SetWindowText(strFullText);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\mqsnap.cpp ===
// mqsnap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mqsnapps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "cmnquery.h" // re-include for GUID initialization
#include "dsadmin.h" // re-include for GUID initialization
#include "mqsnap.h"
#include "mqsnap_i.c"
#include "Snapin.h"
#include "dataobj.h"
#include "SnpQueue.h"
#include "edataobj.h"
#include "linkdata.h"
#include "UserCert.h"
#include "ForgData.h"
#include "aliasq.h"
#include "_mqres.h"


#include "mqsnap.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;

//
// define the resource only dll handle
//
HMODULE     g_hResourceMod=NULL;


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MSMQSnapin, CSnapin)
    OBJECT_ENTRY(CLSID_MSMQSnapinAbout, CSnapinAbout)
    OBJECT_ENTRY(CLSID_MsmqQueueExt, CQueueDataObject)
    OBJECT_ENTRY(CLSID_MsmqCompExt, CComputerMsmqDataObject)
    OBJECT_ENTRY(CLSID_EnterpriseDataObject, CEnterpriseDataObject)
    OBJECT_ENTRY(CLSID_LinkDataObject, CLinkDataObject)
    OBJECT_ENTRY(CLSID_UserCertificate, CRegularUserCertificate)
    OBJECT_ENTRY(CLSID_MigratedUserCertificate, CMigratedUserCertificate)
    OBJECT_ENTRY(CLSID_ForeignSiteData, CForeignSiteData)
    OBJECT_ENTRY(CLSID_AliasQObject, CAliasQObject)
END_OBJECT_MAP()

class CMqsnapApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CMqsnapApp theApp;



BOOL CMqsnapApp::InitInstance()
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    _Module.Init(ObjectMap, m_hInstance);
    CSnapInItem::Init();
    
    g_hResourceMod=MQGetResourceHandle();
    
    if(g_hResourceMod == NULL)return FALSE;
    
    AfxSetResourceHandle(g_hResourceMod);


    //
    //  Previously m_pszAppName string is coming from AFX_IDS_APP_TITLE
    //  resource ID. However, due to the localization effort which centralized all the resource
    //  in mqutil.dll, AFX_IDS_APP_TITLE was removed from mqsnap.dll.  Now we just need to  
    //  get it from mqutil.dll     
    //

    CString csTitle;
    
    if( csTitle.LoadString(AFX_IDS_APP_TITLE) )
    {
        //
        // Free m_pszAppName first
        //
        if(m_pszAppName)
        {
            free((void*)m_pszAppName);
        }

        //
        //  The CWinApp destructor will free the memory.
        //
        m_pszAppName = _tcsdup((LPCTSTR)csTitle);
    }
    
    
    return  CWinApp::InitInstance();
}

int CMqsnapApp::ExitInstance()
{
    WPP_CLEANUP();

    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msggen.h ===
#if !defined(AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msggen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage dialog

class CMessageGeneralPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageGeneralPage)

// Construction
public:
	DWORD m_iIcon;
	CMessageGeneralPage();
	~CMessageGeneralPage();

// Dialog Data
	//{{AFX_DATA(CMessageGeneralPage)
	enum { IDD = IDD_MESSAGE_GENERAL };
	CStatic	m_cstaticMessageIcon;
	CString	m_szLabel;
	CString	m_szId;
	CString	m_szArrived;
	CString	m_szClass;
	CString	m_szPriority;
	CString	m_szSent;
	CString	m_szTrack;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   	BOOL m_bAutoDelete;

	// Generated message map functions
	//{{AFX_MSG(CMessageGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msggen.cpp ===
// msggen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msggen.h"

#include "msggen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage property page

IMPLEMENT_DYNCREATE(CMessageGeneralPage, CMqPropertyPage)

CMessageGeneralPage::CMessageGeneralPage() : CMqPropertyPage(CMessageGeneralPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageGeneralPage)
	m_szLabel = _T("");
	m_szId = _T("");
	m_szArrived = _T("");
	m_szClass = _T("");
	m_szPriority = _T("");
	m_szSent = _T("");
	m_szTrack = _T("");
	//}}AFX_DATA_INIT
    m_iIcon = IDI_MSGICON;
}

CMessageGeneralPage::~CMessageGeneralPage()
{
}

void CMessageGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//{{AFX_DATA_MAP(CMessageGeneralPage)
	DDX_Control(pDX, IDC_MESSAGE_ICON, m_cstaticMessageIcon);
	DDX_Text(pDX, IDC_MSGLABEL, m_szLabel);
	DDX_Text(pDX, IDC_MSGID, m_szId);
	DDX_Text(pDX, IDC_MSGARRIVED, m_szArrived);
	DDX_Text(pDX, IDC_MSGCLASS, m_szClass);
	DDX_Text(pDX, IDC_MSGPRIORITY, m_szPriority);
	DDX_Text(pDX, IDC_MSGSENT, m_szSent);
	DDX_Text(pDX, IDC_MSGTRACK, m_szTrack);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        HICON hIcon = AfxGetApp()->LoadIcon(m_iIcon);
        ASSERT(0 != hIcon);
        m_cstaticMessageIcon.SetIcon(hIcon);
    }
}


BEGIN_MESSAGE_MAP(CMessageGeneralPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage message handlers

BOOL CMessageGeneralPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgq.cpp ===
// msgq.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgq.h"

#include "msgq.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage property page

IMPLEMENT_DYNCREATE(CMessageQueuesPage, CMqPropertyPage)

CMessageQueuesPage::CMessageQueuesPage() : CMqPropertyPage(CMessageQueuesPage::IDD)
{
    //{{AFX_DATA_INIT(CMessageQueuesPage)
    m_szAdminFN = _T("");
    m_szAdminPN = _T("");
    m_szDestFN = _T("");
    m_szDestPN = _T("");
    m_szRespFN = _T("");
    m_szRespPN = _T("");
    m_szMultiDestFN = _T("");    
    //}}AFX_DATA_INIT
}

CMessageQueuesPage::~CMessageQueuesPage()
{
}

void CMessageQueuesPage::DoDataExchange(CDataExchange* pDX)
{
    CMqPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMessageQueuesPage)
    DDX_Text(pDX, IDC_MSG_ADMIN_FN, m_szAdminFN);
    DDX_Text(pDX, IDC_MSG_ADMIN_PN, m_szAdminPN);
    DDX_Text(pDX, IDC_MSG_DST_FN, m_szDestFN);
    DDX_Text(pDX, IDC_MSG_DST_PN, m_szDestPN);
    DDX_Text(pDX, IDC_MSG_RSP_FN, m_szRespFN);
    DDX_Text(pDX, IDC_MSG_RSP_PN, m_szRespPN);
    DDX_Text(pDX, IDC_MSG_MULTIDST_FN, m_szMultiDestFN); 
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageQueuesPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageQueuesPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage message handlers

BOOL CMessageQueuesPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgq.h ===
#if !defined(AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgq.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage dialog

class CMessageQueuesPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageQueuesPage)

// Construction
public:
	CMessageQueuesPage();
	~CMessageQueuesPage();

// Dialog Data
    //{{AFX_DATA(CMessageQueuesPage)
    enum { IDD = IDD_MESSAGE_QUEUE };
    CString	m_szAdminFN;
    CString	m_szAdminPN;
    CString	m_szDestFN;
    CString	m_szDestPN;
    CString	m_szRespFN;
    CString	m_szRespPN;
    CString m_szMultiDestFN;
    //}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageQueuesPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMessageQueuesPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgbody.h ===
#if !defined(AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_)
#define AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgbody.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage dialog

class CMessageBodyPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageBodyPage)

// Construction
public:
	DWORD   m_dwBufLen;
	UCHAR * m_Buffer;


	CMessageBodyPage();
	~CMessageBodyPage();

// Dialog Data
	//{{AFX_DATA(CMessageBodyPage)
	enum { IDD = IDD_MESSAGE_BODY };
	CEdit	m_ctlBodyEdit;
	CString	m_strBodySizeMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageBodyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMessageBodyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgsndr.h ===
#if !defined(AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgsndr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage dialog

class CMessageSenderPage : public CMqPropertyPage
{
  	DECLARE_DYNCREATE(CMessageSenderPage)

// Construction
public:
	CMessageSenderPage();   // standard constructor
    ~CMessageSenderPage();

// Dialog Data
	//{{AFX_DATA(CMessageSenderPage)
	enum { IDD = IDD_MESSAGE_SENDER };
	CString	m_szAuthenticated;
	CString	m_szEncrypt;
	CString	m_szEncryptAlg;
	CString	m_szHashAlg;
	CString	m_szGuid;
	CString	m_szPathName;
	CString	m_szSid;
	CString	m_szUser;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessageSenderPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMessageSenderPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msmqlink.cpp ===
// MsmqLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "MsmqLink.h"
#include "dsext.h"

#include "msmqlink.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CSiteInfo Implementation
//
inline
CSiteInfo::CSiteInfo(
    GUID* pSiteId,
    LPWSTR pSiteName
    ) :
    m_SiteId(*pSiteId),
    m_SiteName(pSiteName)
{
}

CSiteInfo::~CSiteInfo()
{
}

inline
LPCWSTR 
CSiteInfo::GetSiteName(
    void
    )
{
    return m_SiteName;
}

inline
const
GUID*
CSiteInfo::GetSiteId(
    void
    ) const
{
    return &m_SiteId;
}

/////////////////////////////////////////////////////////////////////////////
// CMsmqLink dialog

void
CMsmqLink::CheckLinkValidityAndForeignExistance (    
    CDataExchange* pDX
	)
/*++
Routine Description:
    The routine checks the validity of the site link, after the individual parameters
    were validated already (no NULL siteID or zero cost). It makes sure that the
    site link does not connect two foreign site, and that a site gate exists whenever
    a foreign site is part of the link.

Arguments:
    None.

Returned Value:
    TRUE - valid, FALSE - invalid

--*/
{
    ASSERT(m_FirstSiteId != NULL);
    ASSERT(m_SecondSiteId != NULL);

    BOOL fFirstForeign, fSecondForeign;

    HRESULT hr = GetSiteForeignFlag(m_FirstSiteId, &fFirstForeign, m_strDomainController);
    if FAILED(hr)
    //
    // Apparently, no DS connection. A message was already displayed
    //
    {
        pDX->Fail();
    }

    hr = GetSiteForeignFlag(m_SecondSiteId, &fSecondForeign, m_strDomainController);
    if FAILED(hr)
    {
        pDX->Fail();
    }


    //
    // It is illegal to create site link between two foreign sites
    //
    if (fFirstForeign && fSecondForeign)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_FOREIGN);
        pDX->Fail();
    }

    //
    // If at least one site is a foreign site, the final message should 
    // tell the user to add site gates.
    //
    if (fFirstForeign || fSecondForeign)
    {
        m_fThereAreForeignSites = TRUE;
    }
    else
    {
        m_fThereAreForeignSites = FALSE;
    }
}

HRESULT
CMsmqLink::CreateSiteLink (
    void
	)
/*++
Routine Description:
    The routine create a Site Link object in the DS. The routine is called OnOk
    after the sites ids and the cost were retrieved and the site gates array 
    was initialized.

Arguments:
    None.

Returned Value:
    the operation result

--*/
{
    ASSERT(m_FirstSiteId != NULL);
    ASSERT(m_SecondSiteId != NULL);
    ASSERT(m_dwLinkCost > 0);

    //
    // Build the description
    //
    CString strLinkDescription;

    strLinkDescription.FormatMessage(IDS_LINK_DESCRIPTION, m_strFirstSite, m_strSecondSite);

    //
    // Prepare the properties for DS call.
    //
    PROPID paPropid[] = { 
                PROPID_L_NEIGHBOR1, 
                PROPID_L_NEIGHBOR2,
                PROPID_L_ACTUAL_COST,
                PROPID_L_DESCRIPTION
                };

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    DWORD iProperty = 0;


    ASSERT(paPropid[iProperty] == PROPID_L_NEIGHBOR1);    //PropId
    apVar[iProperty].vt = VT_CLSID;          //Type
    apVar[iProperty].puuid = const_cast<GUID*>(m_FirstSiteId);
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_NEIGHBOR2);    //PropId
    apVar[iProperty].vt = VT_CLSID;          //Type
    apVar[iProperty].puuid = const_cast<GUID*>(m_SecondSiteId);
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_ACTUAL_COST);    //PropId
    apVar[iProperty].vt = VT_UI4;       //Type
    apVar[iProperty].ulVal =  m_dwLinkCost;
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_DESCRIPTION);    //PropId
    apVar[iProperty].vt = VT_LPWSTR;       //Type
    apVar[iProperty].pwszVal =  (LPWSTR)((LPCWSTR)strLinkDescription);
    ++iProperty;

    GUID SiteLinkId;  
    HRESULT hr = ADCreateObject(
                    eROUTINGLINK,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    NULL, //pwcsObjectName
                    NULL, //pSecurityDescriptor,
                    iProperty,
                    paPropid,
                    apVar,
                    &SiteLinkId
                    );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the New object Full path name
    //
    PROPID x_paPropid[] = {PROPID_L_FULL_PATH};
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;
    
    hr = ADGetObjectPropertiesGuid(
                eROUTINGLINK,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                &SiteLinkId,
                1, 
                x_paPropid,
                var
                );

    if (SUCCEEDED(hr))
    {
        m_SiteLinkFullPath = var[0].pwszVal;
        MQFreeMemory(var[0].pwszVal);
    }
    else
    {
        //
        // Site link was created, but does not exist in the DS.
        // Reason not clear (QM failed? Switched DC?)
        //
        ASSERT(0);
        AfxMessageBox(IDS_CREATED_CLICK_REFRESH);
    }

    return MQ_OK;

}


HRESULT
CMsmqLink::InitializeSiteInfo(
    void
    )
/*++
Routine description:
    The routine retreives information about the site from the DS
    and initializes internal data structure

Arguments:
    None.

Returned value:
    operation result

--*/
{
    HRESULT rc = MQ_OK;

    //
    // Get the site name and ID from DS
    //
    PROPID aPropId[] = {
        PROPID_S_SITEID, 
        PROPID_S_PATHNAME
        };

	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);
    CColumns AttributeColumns;

	for (DWORD i=0; i<x_nProps; i++)
	{
		AttributeColumns.Add(aPropId[i]);
	}   
    
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS        
        hr = ADQueryAllSites(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    AttributeColumns.CastToStruct(),
                    &hEnume
                    );        
    }

    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return MQ_ERROR;
    }

    //
    // Get the site properties
    //
    PROPVARIANT result[x_nProps*3];
    DWORD dwPropCount = sizeof(result) /sizeof(result[0]);

    rc = dslookup.Next(&dwPropCount, result);

    while (SUCCEEDED(rc) && (dwPropCount != 0))
    {
        for (DWORD i =0; i < dwPropCount; i += AttributeColumns.Count())
        {
            CSiteInfo* p = new CSiteInfo(result[i].puuid, result[i+1].pwszVal);
            MQFreeMemory(result[i].puuid);
            MQFreeMemory(result[i+1].pwszVal);

            m_SiteInfoArray.SetAtGrow(m_SiteNumber, p);
            ++m_SiteNumber;
        }
        rc = dslookup.Next(&dwPropCount, result);
    }

    return rc;

}

CMsmqLink::CMsmqLink(
	const CString& strDomainController,
	const CString& strContainerPathDispFormat
	) : 
	CMqPropertyPage(CMsmqLink::IDD),
	m_strDomainController(strDomainController),
	m_strContainerPathDispFormat(strContainerPathDispFormat)
{
	//{{AFX_DATA_INIT(CMsmqLink)
	m_dwLinkCost = 0;
	m_strFirstSite = _T("");
	m_strSecondSite = _T("");
	//}}AFX_DATA_INIT

    //
    // Set the array size to 10
    //
    m_SiteInfoArray.SetSize(10);
    m_SiteNumber = 0;

    m_FirstSiteSelected = FALSE;
    m_SecondSiteSelected = FALSE;

    //
    // set pointer to combox to NULL
    //
    m_pFirstSiteCombo = NULL;
    m_pSecondSiteCombo = NULL;

    m_FirstSiteId = NULL;
    m_SecondSiteId = NULL;
}


CMsmqLink::~CMsmqLink()
{
    //
    // delete the site info
    //
    for(DWORD i = 0; i < m_SiteNumber; ++i)
    {
        delete  m_SiteInfoArray[i];
    }
    m_SiteInfoArray.RemoveAll();
}


void
CMsmqLink::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CMsmqLink::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);


	//{{AFX_DATA_MAP(CMsmqLink)
	DDX_Text(pDX, IDC_LINK_COST_EDIT, m_dwLinkCost);
	DDV_MinMaxDWord(pDX, m_dwLinkCost, 1, MQ_MAX_LINK_COST);
	DDX_CBString(pDX, IDC_FIRST_SITE_COMBO, m_strFirstSite);
	DDV_NotEmpty(pDX, m_strFirstSite, IDS_MISSING_SITE_NAME);
	DDX_CBString(pDX, IDC_SECOND_SITE_COMBO, m_strSecondSite);
	DDV_NotEmpty(pDX, m_strSecondSite, IDS_MISSING_SITE_NAME);
	//}}AFX_DATA_MAP

    DWORD_PTR Index;
    int iSelected;

    //
    // Get First Site ID
    //
    VERIFY(CB_ERR != (iSelected = m_pFirstSiteCombo->GetCurSel()));
    VERIFY(CB_ERR != (Index = m_pFirstSiteCombo->GetItemData(iSelected)));
    m_FirstSiteId = m_SiteInfoArray[Index]->GetSiteId();

    //
    // Get Second Site ID
    //
    VERIFY(CB_ERR != (iSelected = m_pSecondSiteCombo->GetCurSel()));
    VERIFY(CB_ERR != (Index = m_pSecondSiteCombo->GetItemData(iSelected)));
    m_SecondSiteId = m_SiteInfoArray[Index]->GetSiteId();

    if (pDX->m_bSaveAndValidate)
    {
        if (m_strFirstSite == m_strSecondSite)
        {
            AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
            pDX->Fail();
        }
        CheckLinkValidityAndForeignExistance(pDX);
    }
}


BEGIN_MESSAGE_MAP(CMsmqLink, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMsmqLink)
	ON_CBN_SELCHANGE(IDC_FIRST_SITE_COMBO, OnSelchangeFirstSiteCombo)
	ON_CBN_SELCHANGE(IDC_SECOND_SITE_COMBO, OnSelchangeSecondSiteCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMsmqLink message handlers
BOOL CMsmqLink::OnInitDialog() 
{
	SetDlgItemText(IDC_ROUTING_LINK_CONTAINER, m_strContainerPathDispFormat);
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        HRESULT rc;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
        //
        // Initialize pointer to combox
        //
        m_pFirstSiteCombo = (CComboBox *)GetDlgItem(IDC_FIRST_SITE_COMBO);
        m_pSecondSiteCombo = (CComboBox *)GetDlgItem(IDC_SECOND_SITE_COMBO);

        rc = InitializeSiteInfo();
        if (SUCCEEDED(rc))
        {
            //
            // Initialize the Site name combo boxes
            //
            for (DWORD i = 0; i < m_SiteNumber; ++i)
            {
                CString SiteName(m_SiteInfoArray[i]->GetSiteName());
                int iNewItem;

                VERIFY(CB_ERR != (iNewItem = m_pFirstSiteCombo->AddString(SiteName)));
                VERIFY(CB_ERR != m_pFirstSiteCombo->SetItemData(iNewItem, i));

                VERIFY(CB_ERR != (iNewItem = m_pSecondSiteCombo->AddString(SiteName)));
                VERIFY(CB_ERR != m_pSecondSiteCombo->SetItemData(iNewItem, i));
            }
        }
    }	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CMsmqLink::OnSelchangeFirstSiteCombo() 
{
    int FirstSiteIndex = m_pFirstSiteCombo->GetCurSel();
    ASSERT(FirstSiteIndex != CB_ERR);

    if (m_SecondSiteSelected &&
        m_pSecondSiteCombo->GetCurSel() == FirstSiteIndex)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
        m_FirstSiteSelected = FALSE;
        return;
    }

    m_FirstSiteSelected = TRUE;
    
}

void CMsmqLink::OnSelchangeSecondSiteCombo() 
{
    int SecondSiteIndex = m_pSecondSiteCombo->GetCurSel();
    ASSERT(SecondSiteIndex != CB_ERR);

    if (m_FirstSiteSelected &&
        m_pFirstSiteCombo->GetCurSel() == SecondSiteIndex)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
        m_SecondSiteSelected = FALSE;
        return;
    }

    m_SecondSiteSelected = TRUE;
}


BOOL CMsmqLink::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create Site link in the DS
    //
    HRESULT rc = CreateSiteLink();
    if(FAILED(rc))
    {
        CString strSiteLink;
        strSiteLink.LoadString(IDS_SITE_LINK);

        MessageDSError(rc, IDS_OP_CREATE, strSiteLink);
        return FALSE;
    }

    //
    // Display a warning in case of foreign site existance
    //
    if (m_fThereAreForeignSites)
    {
        AfxMessageBox(IDS_WARN_ABOUT_FOREIGN_SITES, MB_ICONINFORMATION);
    }


    return CMqPropertyPage::OnWizardFinish();
}


BOOL CMsmqLink::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msgsndr.cpp ===
// msgsndr.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgsndr.h"

#include "msgsndr.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage  property page

IMPLEMENT_DYNCREATE(CMessageSenderPage, CMqPropertyPage)


CMessageSenderPage::CMessageSenderPage() : CMqPropertyPage(CMessageSenderPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageSenderPage)
	m_szAuthenticated = _T("");
	m_szEncrypt = _T("");
	m_szEncryptAlg = _T("");
	m_szHashAlg = _T("");
	m_szGuid = _T("");
	m_szPathName = _T("");
	m_szSid = _T("");
	m_szUser = _T("");
	//}}AFX_DATA_INIT
}

CMessageSenderPage::~CMessageSenderPage()
{
}

void CMessageSenderPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessageSenderPage)
	DDX_Text(pDX, IDC_MSGAUTHENTICATED, m_szAuthenticated);
	DDX_Text(pDX, IDC_MSGENCRYPT, m_szEncrypt);
	DDX_Text(pDX, IDC_MSGENCRYPTALG, m_szEncryptAlg);
	DDX_Text(pDX, IDC_MSGHASHALG, m_szHashAlg);
	DDX_Text(pDX, IDC_MSGGUID, m_szGuid);
	DDX_Text(pDX, IDC_MSGPATHNAME, m_szPathName);
	DDX_Text(pDX, IDC_MSGSID, m_szSid);
	DDX_Text(pDX, IDC_MSGUSER, m_szUser);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageSenderPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageSenderPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage message handlers

BOOL CMessageSenderPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newalias.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    newalias.cpp

Abstract:

    New alias queue implementation file

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "newalias.h"
#include "adsutil.h"

#include "newalias.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewAlias dialog

HRESULT
CNewAlias::CreateNewAlias (
    void
	)
/*++
Routine Description:
    The routine create an Alias Queue object in the DS.

Arguments:
    None.

Returned Value:
    the operation result

--*/
{    
    ASSERT(!m_strPathName.IsEmpty());
    ASSERT(!m_strContainerPath.IsEmpty());
    ASSERT(!m_strFormatName.IsEmpty());
    
    CAdsUtil AdsUtil (m_strContainerPath, m_strPathName, m_strFormatName);
    HRESULT hr = AdsUtil.CreateAliasObject(&m_strAliasFullPath);
    
    if (FAILED(hr))
    {        
        return hr;
    }
  
    return MQ_OK;

}

CNewAlias::CNewAlias()
	: CMqPropertyPage(CNewAlias::IDD)
{
	//{{AFX_DATA_INIT(CNewAlias)
	m_strPathName = _T("");
    m_strFormatName = _T("");
	//}}AFX_DATA_INIT    
}

CNewAlias::CNewAlias(
	CString strContainerPath, 
	CString strContainerPathDispFormat
	) : CMqPropertyPage(CNewAlias::IDD)
{
	//{{AFX_DATA_INIT(CNewAlias)
	m_strPathName = _T("");
    m_strFormatName = _T("");
	//}}AFX_DATA_INIT    
	m_strContainerPath = strContainerPath;
	m_strContainerPathDispFormat = strContainerPathDispFormat;
}


CNewAlias::~CNewAlias()
{
	m_pParentSheet = NULL;
}

void
CNewAlias::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}

void CNewAlias::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);


	//{{AFX_DATA_MAP(CNewAlias)
    DDX_Text(pDX, IDC_NEWALIAS_PATHNAME, m_strPathName);
    DDX_Text(pDX, IDC_NEWALIAS_FORMATNAME, m_strFormatName);		
    DDV_NotEmpty(pDX, m_strPathName, IDS_MISSING_ALIAS_NAME);
    DDV_NotEmpty(pDX, m_strFormatName, IDS_MISSING_ALIAS_FORMATNAME);
	DDV_ValidFormatName(pDX, m_strFormatName);
	//}}AFX_DATA_MAP
       
}


BEGIN_MESSAGE_MAP(CNewAlias, CMqPropertyPage)
	//{{AFX_MSG_MAP(CNewAlias)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CNewAlias::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	SetDlgItemText(IDC_ALIAS_CONTAINER, m_strContainerPathDispFormat);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewAlias message handlers

BOOL CNewAlias::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create alias queue in the DS
    //
    m_hr = CreateNewAlias();
    if(FAILED(m_hr))
    {
        CString strNewAlias;
        strNewAlias.LoadString(IDS_ALIAS);

        MessageDSError(m_hr, IDS_OP_CREATE, strNewAlias);
        return FALSE;        
    }    

    return CMqPropertyPage::OnWizardFinish();
}


BOOL CNewAlias::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


HRESULT CNewAlias::GetStatus()
{
    return m_hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\msmqlink.h ===
#if !defined(AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MsmqLink.h : header file
//

#include "resource.h"

class CSiteInfo
{
public:
    CSiteInfo(
        GUID* pSiteId,
        LPWSTR pSiteName
        );

    ~CSiteInfo();

    LPCWSTR 
    GetSiteName(
        void
        );

    const
    GUID*
    GetSiteId(
        void
        ) const;

private:
    GUID m_SiteId;
    CString m_SiteName;
};


/////////////////////////////////////////////////////////////////////////////
// CMsmqLink dialog

class CMsmqLink : public CMqPropertyPage
{
// Construction
public:
	CMsmqLink(const CString& strDomainController, const CString& strContainerPathDispFormat);   // standard constructor
    ~CMsmqLink();

    HRESULT
    CreateSiteLink (
        void
	    );

    LPCWSTR 
    GetSiteLinkFullPath(
       void
       );

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);


    // Dialog Data
	//{{AFX_DATA(CMsmqLink)
	enum { IDD = IDD_NEW_MSMQ_LINK };
	DWORD	m_dwLinkCost;
	CString	m_strFirstSite;
	CString	m_strSecondSite;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmqLink)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMsmqLink)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeFirstSiteCombo();
	afx_msg void OnSelchangeSecondSiteCombo();
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fThereAreForeignSites;
    HRESULT 
    InitializeSiteInfo(
        void
        );

    void
    CheckLinkValidityAndForeignExistance (    
        CDataExchange* pDX
	    );

    DWORD m_SiteNumber;
    CArray<CSiteInfo*, CSiteInfo*&> m_SiteInfoArray;

    BOOL m_FirstSiteSelected;
    BOOL m_SecondSiteSelected;

	CComboBox*	m_pSecondSiteCombo;
	CComboBox*	m_pFirstSiteCombo;

    const GUID* m_FirstSiteId;
    const GUID* m_SecondSiteId;

    CString m_SiteLinkFullPath;
    CString m_strDomainController;

	CString m_strContainerPathDispFormat;
	CGeneralPropertySheet* m_pParentSheet;
};


inline
LPCWSTR 
CMsmqLink::GetSiteLinkFullPath(
   void
   )
{
    return m_SiteLinkFullPath;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newrule.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"

#import "mqtrig.tlb" no_namespace

#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"

#include "newrule.tmh"


CNewRule::CNewRule(CRuleSet* pRuleSet) :
    CPropertySheetEx(IDS_NEW_RULE_CAPTION, 0, 0, NULL, 0, NULL),
    m_pRuleSet(SafeAddRef(pRuleSet)),
    m_newRule(NULL)
{	
    m_pGeneral = new CNewRuleGeneral(this);
    AddPage(m_pGeneral);

    m_pCondition = new CRuleCondition(this);
    AddPage(m_pCondition);

    m_pAction = new CRuleAction(this);
    AddPage(m_pAction);

    //
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

    
CNewRule::~CNewRule()
{
}


BOOL CNewRule::SetWizardButtons()
{
    if (GetActiveIndex() == 0)
	{
        //
		//first page
        //
        CPropertySheetEx::SetWizardButtons(PSWIZB_NEXT);
        return TRUE;
	}

    if (GetActiveIndex() == GetPageCount() - 1)
	{
        //
		//last page
        //
		CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_FINISH );
        return TRUE;
	}

    CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_NEXT );
    return TRUE;
}


void CNewRule::OnFinishCreateRule(void) throw (_com_error)
{
    _bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_ruleName);
    _bstr_t description = static_cast<LPCTSTR>(m_pGeneral->m_ruleDescription);
    _bstr_t condition = static_cast<LPCTSTR>(m_pCondition->GetCondition());
    _bstr_t action = static_cast<LPCTSTR>(m_pAction->GetAction());
    long fShowWindow = m_pAction->m_fShowWindow;

    m_newRule = m_pRuleSet->AddRule(
                              name, 
                              description, 
                              condition,
                              action, 
                              fShowWindow
                              );
}


HBITMAP CNewRule::GetHbmWatermark()
{
    return NULL;
}


HBITMAP CNewRule::GetHbmHeader()
{
    return NULL;
}

void CNewRule::initHtmlHelpString()
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newrule.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    newrule.h

Abstract:
	Definition for the new rule property sheet

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __NEWRULE_H__
#define __NEWRULE_H__

class CRuleGeneral;
class CRuleCondition;
class CRuleAction;

class CNewRule : public CPropertySheetEx
{
public:
	CNewRule(CRuleSet* pRuleSet);
    ~CNewRule();

    BOOL SetWizardButtons();

    void OnFinishCreateRule(void) throw (_com_error);

    R<CRule> GetRule()
    {
        return m_newRule;
    }

	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();

private:
    R<CRuleSet> m_pRuleSet;
    HICON m_hIcon;

    CRuleGeneral* m_pGeneral;
    CRuleCondition* m_pCondition;
    CRuleAction* m_pAction;

    R<CRule> m_newRule;
};

#endif //__NEWRULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newalias.h ===
#if !defined(AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// newalias.h : header file
//

#include "resource.h"

class CGeneralPropertySheet;

/////////////////////////////////////////////////////////////////////////////
// CNewAlias dialog

class CNewAlias : public CMqPropertyPage
{
// Construction
public:
	CNewAlias();   // standard constructor
    CNewAlias(CString strContainerPath, CString strContainerPathDispFormat);   
    ~CNewAlias();

    HRESULT
    CreateNewAlias (
        void
	    );

    LPCWSTR 
    GetAliasFullPath(
       void
       );

    HRESULT 
    GetStatus(
        void
        );

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

    // Dialog Data
	//{{AFX_DATA(CNewAlias)
	enum { IDD = IDD_NEW_ALIAS };	
	CString	m_strPathName;
	CString	m_strFormatName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewAlias)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewAlias)
	virtual BOOL OnWizardFinish();
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:

    CString m_strAliasFullPath;
    CString m_strContainerPath;
	CString m_strContainerPathDispFormat;
    HRESULT m_hr;
	CGeneralPropertySheet* m_pParentSheet;
};


inline
LPCWSTR 
CNewAlias::GetAliasFullPath(
   void
   )
{
    return m_strAliasFullPath;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newtrig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "newtrig.h"
#include "trigprop.h"

#include "newtrig.tmh"


CNewTrigger::CNewTrigger(
    CTriggerSet* pTrigSet,
    CRuleSet* pRuleSet,
    LPCTSTR queueName
    ) :
    CPropertySheetEx(IDS_NEW_TRIGGER_CAPTION, 0, 0, NULL, 0, NULL),
    m_pTriggerSet(SafeAddRef(pTrigSet)),
    m_pRuleSet(SafeAddRef(pRuleSet))
{	
    m_pGeneral = new CNewTriggerProp(this, queueName);
    AddPage(m_pGeneral);


    m_pAttachRule = new CAttachedRule(this);
    AddPage(m_pAttachRule);

    //
    // Use help
    m_psh.dwFlags |= PSP_HASHELP;

    //
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

    
CNewTrigger::~CNewTrigger()
{
}


BOOL CNewTrigger::SetWizardButtons()
{
    if (GetActiveIndex() == 0)
	{
        //
		//first page
        //
        CPropertySheetEx::SetWizardButtons(PSWIZB_NEXT);
        return TRUE;
	}

    if (GetActiveIndex() == GetPageCount() - 1)
	{
        //
		//last page
        //
		CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_FINISH );
        return TRUE;
	}

    CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_NEXT );
    return TRUE;
}


void CNewTrigger::OnFinishCreateTrigger(void) throw (_com_error)
{
    _bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_triggerName);
    _bstr_t queuePathName = static_cast<LPCTSTR>(m_pGeneral->m_queuePathName);
    SystemQueueIdentifier queueType = m_pGeneral->m_queueType;
    long fEnabled = m_pGeneral->m_fEnabled;
    long fSerialized = m_pGeneral->m_fSerialized;
	MsgProcessingType msgProcType = m_pGeneral->m_msgProcType;

    R<CTrigger> pTrig = m_pTriggerSet->AddTrigger(
                                          name, 
                                          queuePathName, 
                                          queueType,
                                          fEnabled, 
                                          fSerialized,
										  msgProcType
                                          );


    pTrig->UpdateAttachedRules(m_pAttachRule->GetAttachedRules());
}


HBITMAP CNewTrigger::GetHbmWatermark()
{
    return NULL;
}


HBITMAP CNewTrigger::GetHbmHeader()
{
    return NULL;
}

void CNewTrigger ::initHtmlHelpString()
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\privsec.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    privsec.cpp

Abstract:

    Private queue security property page

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "ntdsapi.h"
#include "aclui.h"
#include "resource.h"
#include "globals.h"

#include "privsec.tmh"

extern HMODULE g_hResourceMod;

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0, MAKEINTRESOURCE(IDS_MQ_PRIV_LEVEL_NONE),
};

//
// SetSecurityProp - Utility function - sets the security 
// property in the AD.
//
HRESULT 
SetSecurityProp(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD,
	AD_OBJECT            eObject,
	LPCWSTR              pwcsDomainController,
	bool				 fServerName,
	LPCWSTR              pwcsObjectName,
	GUID                *pObjGuid,
	PROPID               pidSecurityProp
	)
{
    ASSERT((NULL != pSD) && IsValidSecurityDescriptor(pSD));

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;

    //
    // Verify that the destination security descriptor answers to all
    // requirements.
    //
    DWORD dwRevision;
    BOOL bRet = GetSecurityDescriptorControl(pSD, &sdc, &dwRevision);
    ASSERT(bRet);

    //
    // Note: It may be OK to get self relative here, although we always got
    //       absolute. Need to see if MakeSelfRelativeSD still returns the right
    //       result. (YoelA, 4/25/2001)
    //
    //
    ASSERT(!(sdc & SE_SELF_RELATIVE));
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

	AP<BYTE> pSelfRelativeSecDesc;
    DWORD dwSelfRelativeLen = 0;

    //
    // We must convert security descriptor to a self relative one,
    // since it is going to cross process boundaries .
    //

    //
    // Get the length of self relative SD
    //
    BOOL fSuccess = MakeSelfRelativeSD(pSD, 0, &dwSelfRelativeLen);
    ASSERT(FALSE == fSuccess);

    //
    // Alocate buffer and get the actual descriptor
    //
    pSelfRelativeSecDesc = new BYTE[dwSelfRelativeLen];

    if (0==(PVOID)pSelfRelativeSecDesc)
    {
        return E_OUTOFMEMORY;
    }

    fSuccess = MakeSelfRelativeSD(pSD, pSelfRelativeSecDesc, &dwSelfRelativeLen);
    if (FALSE == fSuccess)
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }   

    MQPROPVARIANT var;
    var.vt = VT_BLOB;
    var.blob.cbSize = GetSecurityDescriptorLength( pSelfRelativeSecDesc);
    var.blob.pBlobData = pSelfRelativeSecDesc; 

    HRESULT hr;

    if (NULL == pwcsObjectName)
    {
        ASSERT(NULL != pObjGuid);
        hr = ADSetObjectSecurityGuid(
					eObject,
					pwcsDomainController,
					fServerName,
					pObjGuid,
					si,
					pidSecurityProp,
					&var
					);
    }
    else
    {
        hr = ADSetObjectSecurity(
					eObject,
					pwcsDomainController,
					fServerName,
					pwcsObjectName,
					si,
					pidSecurityProp,
					&var
					);
    }

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_SECURITY_DESCRIPTOR);
        return hr;
    };

    return hr;
}

//
// GetSecurityProp - Utility function. Gets the security descriptor from AD
//
HRESULT 
GetSecurityProp(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL                 fDefault,
	AD_OBJECT            eObject,
	LPCWSTR              pwcsDomainController,
	bool				 fServerName,
	LPCWSTR              pwcsObjectName,
	GUID                *pObjGuid,
	PROPID               pidSecurityProp
	)
{
    DWORD dwSecLength = 0;
    *ppSD = NULL;

    if (fDefault)
    {
        return E_NOTIMPL;
    }
 
    HRESULT hr;
    
    PROPVARIANT var;
    var.vt = VT_NULL;
    if (NULL == pwcsObjectName)
    {
        ASSERT(NULL != pObjGuid);

        hr = ADGetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pObjGuid,
                si,
                pidSecurityProp,
                &var
                );
    }
    else
    {
        hr = ADGetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                si,
                pidSecurityProp,
                &var
                );
    }
    
    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        return hr;
    }

    PBYTE pSecurityDescriptor = 0;
    dwSecLength = var.blob.cbSize;

    if (0 != dwSecLength) pSecurityDescriptor = (PBYTE)LocalAlloc(LPTR, dwSecLength);        

    if (pSecurityDescriptor)
    {
        memcpy (pSecurityDescriptor, var.blob.pBlobData, dwSecLength);
    }
    else
    {
        ASSERT(0);
        return E_FAIL;
    }

    *ppSD = (PSECURITY_DESCRIPTOR)pSecurityDescriptor;    
    MQFreeMemory(var.blob.pBlobData);
   
    return hr;
}

//
// CObjSecurity - Base class for security info. editor. Also used for private queue
//
class CObjSecurity : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    DWORD                   m_dwSIFlags;

    CString                 m_lpwcsFormatName;
    CString                 m_lpwcsDescriptiveName;
    CString                 m_lpwcsDomainController;
	bool					m_fServerName;

public:
    CObjSecurity(
			LPCWSTR                    lpwcsFormatName,
			LPCWSTR                    lpwcsDescriptiveName,
			LPCWSTR                    lpwcsDomainController,
			bool					   fServerName,
			DWORD                      dwFlags
			) : 
    m_cRef(1),
    m_lpwcsFormatName(lpwcsFormatName),
    m_lpwcsDescriptiveName(lpwcsDescriptiveName),
    m_lpwcsDomainController(lpwcsDomainController),
    m_fServerName(fServerName),
    m_dwSIFlags(dwFlags)
    {}

    virtual ~CObjSecurity();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////

//
// CreatePrivateQueueSecurityPage - Creates security page for either a private queue,
//                                  or a public queue in NT4 environment
//
HRESULT
CreatePrivateQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsFormatName,
    IN LPCWSTR lpwcsDescriptiveName
    )
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED | SI_NO_ACL_PROTECT; // Used by security editor
    CObjSecurity *psi;

    psi = new CObjSecurity(
					lpwcsFormatName, 
					lpwcsDescriptiveName, 
					TEXT(""),	// lpwcsDomainController
					false,		// fServerName
					x_dwSIFlags
					);
    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}


CObjSecurity::~CObjSecurity()
{
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CObjSecurity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CObjSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CObjSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CObjSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hResourceMod;
    pObjectInfo->pszServerName = m_lpwcsDomainController == TEXT("") ? 
                                        NULL : (LPTSTR)(LPCTSTR)m_lpwcsDomainController; 
    pObjectInfo->pszObjectName = (LPTSTR)(LPCTSTR)m_lpwcsDescriptiveName;

    return S_OK;
}

STDMETHODIMP
CObjSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    DWORD dwSecLength = 0;
    *ppSD = NULL;

    if (fDefault)
    {
        return E_NOTIMPL;
    }
 
    HRESULT hr;
    DWORD dwDummy;
    hr = MQGetQueueSecurity(
                    m_lpwcsFormatName,
                    si,
                    &dwDummy, //    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                    0,    //    IN DWORD nLength,
                    &dwSecLength
					);

    ASSERT(hr != MQ_OK);
    if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        return hr;
    }

    PBYTE pSecurityDescriptor = 0;
    if (0 != dwSecLength) pSecurityDescriptor = (PBYTE)LocalAlloc(LPTR, dwSecLength);;

    hr = MQGetQueueSecurity(
                m_lpwcsFormatName,
                si,
                pSecurityDescriptor,
                dwSecLength,
                &dwSecLength);

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        LocalFree(pSecurityDescriptor);
        return hr;
    }

    *ppSD = (PSECURITY_DESCRIPTOR)pSecurityDescriptor;

    return hr;
}

STDMETHODIMP
CObjSecurity::SetSecurity(SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = 
        MQSetQueueSecurity(
            m_lpwcsFormatName,
            si,
            pSD
            );

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_SECURITY_DESCRIPTOR);
        return hr;
    };

    return hr;
}

STDMETHODIMP
CObjSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siObjAccesses[] = 
    {
        { &GUID_NULL, MQSEC_QUEUE_GENERIC_ALL,       MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_QUEUE,            MAKEINTRESOURCE(IDS_SEC_DELETE),                 SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_MESSAGE,         MAKEINTRESOURCE(IDS_SEC_RECEIVE_MESSAGE),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_PEEK_MESSAGE,            MAKEINTRESOURCE(IDS_SEC_PEEK_MESSAGE),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_JOURNAL_MESSAGE, MAKEINTRESOURCE(IDS_SEC_RECEIVE_JOURNAL_MESSAGE),SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_QUEUE_PROPERTIES,    MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_SET_QUEUE_PROPERTIES,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_QUEUE_PERMISSIONS,   MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CHANGE_QUEUE_PERMISSIONS,MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_TAKE_QUEUE_OWNERSHIP,    MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_WRITE_MESSAGE,           MAKEINTRESOURCE(IDS_SEC_WRITE_MESSAGE),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_MESSAGE,          MAKEINTRESOURCE(IDS_SEC_DELETE_MESSAGE),         SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_JOURNAL_MESSAGE,  MAKEINTRESOURCE(IDS_SEC_DELETE_JOURNAL_MESSAGE), SI_ACCESS_SPECIFIC },
    };

    *ppAccesses = x_siObjAccesses;
    *pcAccesses = sizeof(x_siObjAccesses)/sizeof(x_siObjAccesses[0]);
    *piDefaultAccess = 10; // ordinal 10 in the table above - MQSEC_WRITE_MESSAGE

    return S_OK;
}

STDMETHODIMP
CObjSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        MQSEC_QUEUE_GENERIC_READ,
        MQSEC_QUEUE_GENERIC_WRITE,
        MQSEC_QUEUE_GENERIC_EXECUTE,
        MQSEC_QUEUE_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CObjSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CObjSecurity::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT /*uMsg*/,
                                         SI_PAGE_TYPE /*uPage*/)
{
    return S_OK;
}

//
// CMachineSecurity - Security page for machine in the AD
//
class CMachineSecurity : public CObjSecurity
{
protected:
    CString                 m_lpwcsMachineName;

public:
    CMachineSecurity(
		LPCWSTR                    lpwcsMachineName,
		LPCWSTR                    lpwcsDomainController,
		bool					   fServerName,
		DWORD                      dwFlags
		) : 
    m_lpwcsMachineName(lpwcsMachineName),
    CObjSecurity(TEXT(""), lpwcsMachineName, lpwcsDomainController, fServerName, dwFlags)
    {
        if (lpwcsMachineName == NULL || m_lpwcsMachineName == TEXT(""))
        {
            GetComputerNameIntoString(m_lpwcsMachineName);
        }
    }

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);


    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CMachineSecurity::GetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL fDefault
	)
{
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault,
				eMACHINE, 
				m_lpwcsDomainController, 
				m_fServerName,
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_OBJ_SECURITY
				);
}

STDMETHODIMP
CMachineSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    return SetSecurityProp(
				si, 
				pSD, 
				eMACHINE, 
				m_lpwcsDomainController, 
				m_fServerName,
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_OBJ_SECURITY
				);
}

STDMETHODIMP
CMachineSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    static GUID guidQueueObject =
        { 0x9a0dc343, 0xc100, 0x11d1,
            { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 }} ;

    static GUID guidRightsReceiveDeadletter = 
        { 0x4b6e08c0, 0xdf3c, 0x11d1,
            { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekDeadletter =
    { 0x4b6e08c1, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsReceiveJournal =
    { 0x4b6e08c2, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekJournal =
    { 0x4b6e08c3, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siMachineAccesses[] = 
    {
        { &GUID_NULL,                  DS_GENERIC_ALL,         MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),                  SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidQueueObject,            ACTRL_DS_CREATE_CHILD,  MAKEINTRESOURCE(IDS_SEC_CREATE_QUEUE),                SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveDeadletter,ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_DEAD_LETTER_MESSAGE), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveJournal,   ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MACHINE_JOURNAL),     SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_READ_PROP,     MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_WRITE_PROP,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  READ_CONTROL,           MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  WRITE_DAC,              MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  WRITE_OWNER,            MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  DELETE,                 MAKEINTRESOURCE(IDS_SEC_DELETE),                      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsPeekDeadletter,   ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_DEAD_LETTER_MESSAGE),                        SI_ACCESS_SPECIFIC },
        { &guidRightsPeekJournal,      ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_COMPUTER_JOURNAL),                           SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_ALL_EXTENDED_RIGHTS),                             SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_CREATE_CHILD,  MAKEINTRESOURCE(IDS_SEC_CREATE_ALL_CHILD_OBJECTS),                        SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_DELETE_CHILD,  MAKEINTRESOURCE(IDS_SEC_DELETE_ALL_CHILD_OBJECTS),                        SI_ACCESS_SPECIFIC }
    };

    *ppAccesses = x_siMachineAccesses;
    *pcAccesses = sizeof(x_siMachineAccesses)/sizeof(x_siMachineAccesses[0]);
    *piDefaultAccess = 4; // Ordinal 4 in the table above - MQSEC_GET_MACHINE_PROPERTIES

    return S_OK;
}

STDMETHODIMP
CMachineSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        DS_GENERIC_READ,
        DS_GENERIC_WRITE,
        DS_GENERIC_EXECUTE,
        DS_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CMachineSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


//
// CNT4MachineSecurity - Security page for machine in an NT4 environment
//
class CNT4MachineSecurity : public CObjSecurity
{
protected:
    CString                 m_lpwcsMachineName;

public:
    CNT4MachineSecurity(LPCWSTR                    lpwcsMachineName,
                        DWORD                      dwFlags) : 
    m_lpwcsMachineName(lpwcsMachineName),
    CObjSecurity(
		TEXT(""), 
		lpwcsMachineName, 
		TEXT(""),	// lpwcsDomainController
		false,		// fServerName
		dwFlags
		)
    {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);


    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CNT4MachineSecurity::GetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL fDefault
	)
{
    //
    // Note: We do not need domain for NT4 MQIS
    //
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault,
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_SECURITY
				);
}

STDMETHODIMP
CNT4MachineSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    //
    // Note: We do not need domain for NT4 MQIS
    //
    return SetSecurityProp(
				si, 
				pSD, 
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_SECURITY
				);
}

STDMETHODIMP
CNT4MachineSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siMachineAccesses[] = 
    {
        { &GUID_NULL, MQSEC_MACHINE_GENERIC_ALL,          MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),                  SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CREATE_QUEUE,                 MAKEINTRESOURCE(IDS_SEC_CREATE_QUEUE),                SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_DEADLETTER_MESSAGE,   MAKEINTRESOURCE(IDS_SEC_RECEIVE_DEAD_LETTER_MESSAGE), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MACHINE_JOURNAL),     SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_MACHINE_PROPERTIES,       MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_SET_MACHINE_PROPERTIES,       MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_MACHINE_PERMISSIONS,      MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CHANGE_MACHINE_PERMISSIONS,   MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_TAKE_MACHINE_OWNERSHIP,       MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_MACHINE,               MAKEINTRESOURCE(IDS_SEC_DELETE),                      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_PEEK_DEADLETTER_MESSAGE,      MAKEINTRESOURCE(IDS_SEC_PEEK_DEAD_LETTER_MESSAGE),    SI_ACCESS_SPECIFIC},
        { &GUID_NULL, MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE,   MAKEINTRESOURCE(IDS_SEC_PEEK_COMPUTER_JOURNAL),       SI_ACCESS_SPECIFIC},
    };

    *ppAccesses = x_siMachineAccesses;
    *pcAccesses = sizeof(x_siMachineAccesses)/sizeof(x_siMachineAccesses[0]);
    *piDefaultAccess = 4; // Ordinal 4 in the table above - MQSEC_GET_MACHINE_PROPERTIES

    return S_OK;
}

STDMETHODIMP
CNT4MachineSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        MQSEC_MACHINE_GENERIC_READ,
        MQSEC_MACHINE_GENERIC_WRITE,
        MQSEC_MACHINE_GENERIC_EXECUTE,
        MQSEC_MACHINE_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CNT4MachineSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//
// CreateMachineSecurityPage - used for MSMQ config security.
// Detects the environment and displays AD or NT4 page
//
HRESULT
CreateMachineSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsMachineNameIn,
    IN LPCWSTR lpwcsDomainController,
	IN bool fServerName
	)
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED; // Used by security editor
    CObjSecurity *psi;

    LPCWSTR lpwcsMachineName;
    CString strMachineName;

    ASSERT(0 != lpwcsMachineNameIn);
    if (lpwcsMachineNameIn[0] == 0)
    {
        GetComputerNameIntoString(strMachineName);
        lpwcsMachineName = (LPCWSTR)strMachineName;
    }
    else
    {
        lpwcsMachineName = lpwcsMachineNameIn;
    }

    if (eAD == ADGetEnterprise())
    {
        psi = new CMachineSecurity(lpwcsMachineName, lpwcsDomainController, fServerName, x_dwSIFlags);
    }
    else
    {
        psi = new CNT4MachineSecurity(lpwcsMachineName, x_dwSIFlags | SI_NO_ACL_PROTECT);
    }

    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}

//
// CPublicQueueSecurity - Security page for public queue in the AD
//
class CPublicQueueSecurity : public CObjSecurity
{
protected:
    GUID                 m_guid;

public:
    CPublicQueueSecurity(
		LPCWSTR  lpwcsDescriptiveName,
		LPCWSTR  lpwcsDomainController,
		bool	 fServerName,
		DWORD    dwFlags,
		GUID*    pguid
		) : 
    m_guid(*pguid),
    CObjSecurity(TEXT(""), lpwcsDescriptiveName, lpwcsDomainController, fServerName, dwFlags)
    {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);

    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CPublicQueueSecurity::GetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD,
                                  BOOL fDefault)
{
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault, 
				eQUEUE, 
				m_lpwcsDomainController, 
				m_fServerName, 
				NULL, 
				&m_guid, 
				PROPID_Q_OBJ_SECURITY
				);
}

STDMETHODIMP
CPublicQueueSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    return SetSecurityProp(
				si, 
				pSD, 
				eQUEUE, 
				m_lpwcsDomainController, 
				m_fServerName,
				NULL, 
				&m_guid, 
				PROPID_Q_OBJ_SECURITY
				);
}

STDMETHODIMP
CPublicQueueSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    static GUID guidRightsReceiveMessage = 
      { 0x06bd3200, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekMessage = 
      { 0x06bd3201, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsSendMessage = 
     { 0x06bd3202, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsReceiveJournal = 
     { 0x06bd3203, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siObjAccesses[] = 
    {
        { &GUID_NULL,                DS_GENERIC_ALL,         MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                DELETE,                 MAKEINTRESOURCE(IDS_SEC_DELETE),                 SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveMessage, ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MESSAGE),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsPeekMessage,    ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_MESSAGE),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveJournal, ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_JOURNAL_MESSAGE),SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_READ_PROP,     MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_WRITE_PROP,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                READ_CONTROL,           MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                WRITE_DAC,              MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                WRITE_OWNER,            MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsSendMessage,    ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_WRITE_MESSAGE),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_ALL_EXTENDED_RIGHTS),                        SI_ACCESS_SPECIFIC }
    };

    *ppAccesses = x_siObjAccesses;
    *pcAccesses = sizeof(x_siObjAccesses)/sizeof(x_siObjAccesses[0]);
    *piDefaultAccess = 10; // ordinal 10 in the table above - Send message

    return S_OK;
}

STDMETHODIMP
CPublicQueueSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        DS_GENERIC_READ,
        DS_GENERIC_WRITE,
        DS_GENERIC_EXECUTE,
        DS_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CPublicQueueSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//
// CreatePublicQueueSecurityPage - Returns the security page of a public queue in AD
//
HRESULT
CreatePublicQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsDescriptiveName,
    IN LPCWSTR lpwcsDomainController,
	IN bool	   fServerName,
    IN GUID*   pguid
	)
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED; // Used by security editor
    CObjSecurity *psi;

    psi = new CPublicQueueSecurity(lpwcsDescriptiveName, lpwcsDomainController, fServerName, x_dwSIFlags, pguid);
    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	qext.cpp

Abstract:


Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "qext.h"
#include "snapin.h"
#include "globals.h"
#include "rdmsg.h"
#include "mqcast.h"

#include "qext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************

        CSnapinQueue Class
    
 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {0C0F8CE2-D475-11d1-9B9D-00E02C064C39}
static const GUID CSnapinQueueGUID_NODETYPE = 
{ 0xc0f8ce2, 0xd475, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };


const GUID*  CSnapinQueue::m_NODETYPE = &CSnapinQueueGUID_NODETYPE;
const OLECHAR* CSnapinQueue::m_SZNODETYPE = OLESTR("0C0F8CE2-D475-11d1-9B9D-00E02C064C39");
const OLECHAR* CSnapinQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::CSnapinQueue 
Constractor. Set initial values and determines wheather or not the queue should be
expanded.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapinQueue::CSnapinQueue(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR lpcwstrLdapName) : 
    CNodeWithScopeChildrenList<CSnapinQueue, TRUE>(pParentNode, pComponentData ),
    m_hrError(MQ_OK)
{
   	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
	memset(&m_resultDataItem, 0, sizeof(m_resultDataItem));
    m_szFormatName[0] = L'\0';
    Init(lpcwstrLdapName);
}

void CSnapinQueue::Init(LPCWSTR lpcwstrLdapName)
{
    //
    // Check if the computer is a foreign computer. If it is, we don't
    // want to expand the current queue. We also don't want to expand 
    // the current queue if there is an error getting its details from MSMQ DS.
    // (Such error can occur, for example, when the DS snap-in and MSMQ are accessing 
    // two different domain controllers, and the queue data did not arrive to the
    // MSMQ domain controller yet).
    //
    m_fDontExpand = FALSE;

    HRESULT hr;
    CString strComputerMsmqName;
    hr = ExtractComputerMsmqPathNameFromLdapQueueName(strComputerMsmqName, lpcwstrLdapName);
    if (FAILED(hr))
    {
        ASSERT(0);
        return;
    }

    m_strMsmqPathName = strComputerMsmqName;

	//
	// Get Domain Controller name
	//
	CString strDomainController;
	hr = ExtractDCFromLdapPath(strDomainController, lpcwstrLdapName);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));
	
	PROPVARIANT   PropVar;
    PROPID        PropId = PROPID_QM_FOREIGN;

    PropVar.vt = VT_NULL;

    hr = ADGetObjectProperties(
                    eMACHINE,
	                GetDomainController(strDomainController),
					true,	// fServerName
                    strComputerMsmqName,
                    1, 
                    &PropId,
                    &PropVar
                    );

    if(SUCCEEDED(hr))
    {
        //
        // Do not expand (do not show messages) for
        // queues on foreign computers
        //
        if (PropVar.bVal)
        {
            m_fDontExpand = TRUE;
        }
        else
        {
            m_fDontExpand = FALSE;
        }
    }
    else
    {
        //
        // Most probably, MSMQ is not running. We do not want to report an
        // error - we simply don't display the messages.
        //
        m_fDontExpand = TRUE;
    }
    //
    // We keep the error condition to see if the "don't expand" situation
    // is permanent
    //
    m_hrError = hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinQueue::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Return right away if you should not expand parent
    //
    if (m_fDontExpand)
    {
        //
        // We don't need the scode data item if we do not expand the node
        //
       	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
        return m_hrError;
    }

    HRESULT hr = S_OK;
    CString strTitle;
    
    //
    // Create a node to Read Messages
    //
    CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, m_strMsmqPathName);

    // Pass relevant information
    strTitle.LoadString(IDS_READMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

   	AddChild(p, &p->m_scopeDataItem);

    

    //
    // Create a node to Read journal messages
    //
    // Compose the format name of the journal queue
    CString strJournal = m_szFormatName;
    strJournal = strJournal + L";JOURNAL";

    p = new CReadMsg(this, m_pComponentData, strJournal, m_strMsmqPathName);
    
   
    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);


   	AddChild(p, &p->m_scopeDataItem);


    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinQueue::OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{

    ((CQueueExtData *)m_pParentNode)->RemoveChild(m_pwszQueueName);

	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinQueue::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CNodeWithScopeChildrenList<CSnapinQueue, TRUE>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

	if (cf == gx_CCF_PATHNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_pwszQueueName, 
            m_pwszQueueName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_strMsmqPathName, 
            m_strMsmqPathName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}


/****************************************************

        CQueueExtData Class
    
 ****************************************************/
//
// Extending the DS Queue node type
//  taken from object:   GC://CN=MSMQ-Queue,CN=Schema,CN=Configuration,DC=raphirdom,DC=Com
//             property: schemaIDGUID
//             value:    x43 xc3 x0d x9a x00 xc1 xd1 x11 xbb xc5 x00 x80 xc7 x66 x70 xc0
//
// static const GUID CQueueExtDatatGUID_NODETYPE = 
//   { 0x9a0dc343, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } }; - was moved to globals.h
const GUID*  CQueueExtData::m_NODETYPE = &CQueueExtDatatGUID_NODETYPE;
const OLECHAR* CQueueExtData::m_SZNODETYPE = OLESTR("9a0dc343-c100-11d1-bbc5-0080c76670c0");
const OLECHAR* CQueueExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CQueueExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CQueueExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::GetExtNodeObject

  Called with a node that we need to expand. 
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CQueueExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    CSnapinQueue *pQ;

    CArray<CString, CString&> astrQNames;
	CArray<CString, CString&> astrLdapNames;

    HRESULT hr = ExtractQueuePathNamesFromDataObject(pDataObject, astrQNames, astrLdapNames);
    if(FAILED(hr))
    {
        ATLTRACE(_T("CQueueExtData::GetExtNodeObject - Extracting queue name failed\n"));
        return(pDefault);
    }

    //
    // We should get one and only one queue in this interface
    //
    if (astrQNames.GetSize() != 1)
    {
        ASSERT(0);
        return(pDefault);
    }

    //
    // Do we already have this object
    //
    BOOL fQueueExist = m_mapQueues.Lookup(astrQNames[0], pQ);
    if(fQueueExist == TRUE)
    {
        if (SUCCEEDED(pQ->m_hrError))
        {
            //
            // If there was no error last time, simply return the cashed 
            // result. Otherwise continue.
            //
            return(pQ);
        }
        //
        // In case last time ended with error, attempt to re-initiate the object
        //
        pQ->Init(astrLdapNames[0]);
    }
    else
    {

        //
        // Not in the list, so create a queue object
        //
        pQ = new CSnapinQueue(this, m_pComponentData, astrLdapNames[0]);
    }

    //
    // Set the queue name and format name in the object
    //
    pQ->m_pwszQueueName = astrQNames[0];
    DWORD dwSize =  sizeof(pQ->m_szFormatName);
    pQ->m_hrError = MQPathNameToFormatName(pQ->m_pwszQueueName,pQ->m_szFormatName, &dwSize); 

    if (FALSE == fQueueExist)
    {
        //
        // Add it to the map, if not there already
        //
        m_mapQueues.SetAt(astrQNames[0], pQ);
    }

    return(pQ);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::~CQueueExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CQueueExtData::~CQueueExtData()
{

    RemoveAllChildrens();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::RemoveAllChildrens


--*/
//////////////////////////////////////////////////////////////////////////////
void CQueueExtData::RemoveAllChildrens(void)
{

    POSITION pos;
    CString str;
    CSnapinQueue * pQ;

    //
    // Delete all the nodes from the map
    //
    pos = m_mapQueues.GetStartPosition();
    while(pos != NULL)
    {

        m_mapQueues.GetNextAssoc(pos, str, pQ);
        delete pQ;
    }

    //
    // Empty the map
    //
    m_mapQueues.RemoveAll();

}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CQueueExtData::RemoveChild(CString& strQName)
{
    BOOL rc;
    CSnapinQueue *pQ;

    rc = m_mapQueues.Lookup(strQName, pQ);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapQueues.RemoveKey(strQName);
    ASSERT(rc == TRUE);

    delete pQ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qgeneral.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qgeneral.cpp

Abstract:

    Queue/General property page implementation

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "QGeneral.h"
#include "tr.h"

#include "qgeneral.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TraceIdEntry QGen = L"QUEUE GENERAL";

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral property page

IMPLEMENT_DYNCREATE(CQueueGeneral, CMqPropertyPage)

CQueueGeneral::CQueueGeneral(
		BOOL fPrivate /* = FALSE */,
		BOOL fLocalMgmt /* = FALSE */
		) : 
    CMqPropertyPage(CQueueGeneral::IDD)
{
	m_fTransactional = FALSE;
    m_fPrivate = fPrivate;
    m_fLocalMgmt = fLocalMgmt;
	//{{AFX_DATA_INIT(CQueueGeneral)
	m_strName = _T("");
	m_strLabel = _T("");
	m_guidID = GUID_NULL;
	m_guidTypeID = GUID_NULL;
	m_fAuthenticated = FALSE;
	m_fJournal = FALSE;
	m_lBasePriority = 0;
	m_iPrivLevel = -1;
	//}}AFX_DATA_INIT

}

CQueueGeneral::~CQueueGeneral()
{
}

void CQueueGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!pDX->m_bSaveAndValidate)
    {
        CString strYesNo;
        strYesNo.LoadString(m_fTransactional ? IDS_TRANSACTIONAL_Q : IDS_NONTRANSACTIONAL_Q);
    	DDX_Text(pDX, IDC_QGENERAL_TRANSACTIONAL, strYesNo);
    }
    //
    // Save last values for comparison
    //
	//{{AFX_DATA_MAP(CQueueGeneral)
	DDX_Control(pDX, IDC_QGENERAL_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_BASEPRIORITY_SPIN, m_spinPriority);
	DDX_Text(pDX, IDC_QGENERAL_NAME, m_strName);
	DDX_Text(pDX, IDC_QGENERAL_QLABEL, m_strLabel);
	DDX_Text(pDX, IDC_QGENERAL_ID, m_guidID);
	DDX_Text(pDX, IDC_QGENERAL_TYPEID, m_guidTypeID);
	DDX_Check(pDX, IDC_QMESSAGES_AUTHENTICATED, m_fAuthenticated);
	DDX_Check(pDX, IDC_QMESSAGES_JOURNAL, m_fJournal);
	DDX_Text(pDX, IDC_QUEUE_BASEPRIORITY, m_lBasePriority);
	DDV_MinMaxLong(pDX, m_lBasePriority, MIN_BASE_PRIORITY, MAX_BASE_PRIORITY);
	DDX_CBIndex(pDX, IDC_QMESSAGES_PRIVLEVEL, m_iPrivLevel);
	//}}AFX_DATA_MAP
	DDX_NumberOrInfinite(pDX, IDC_QMESSAGES_QUOTA, IDC_QUEUE_MQUOTA_CHECK, m_dwQuota);
	DDX_NumberOrInfinite(pDX, IDC_QMESSAGES_JOURNAL_QUOTA, IDC_QUEUE_JQUOTA_CHECK, m_dwJournalQuota);
}


BEGIN_MESSAGE_MAP(CQueueGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CQueueGeneral)
	ON_EN_CHANGE(IDC_QGENERAL_QLABEL, OnChangeRWField)
	ON_BN_CLICKED(IDC_QUEUE_MQUOTA_CHECK, OnQueueMquotaCheck)
	ON_EN_CHANGE(IDC_QGENERAL_TYPEID, OnChangeRWField)
	ON_EN_CHANGE(IDC_QMESSAGES_QUOTA, OnChangeRWField)
	ON_BN_CLICKED(IDC_QMESSAGES_AUTHENTICATED, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_QMESSAGES_PRIVLEVEL, OnChangeRWField)
	ON_EN_CHANGE(IDC_QUEUE_BASEPRIORITY, OnChangeRWField)
	ON_BN_CLICKED(IDC_QMESSAGES_JOURNAL, OnChangeRWField)
	ON_EN_CHANGE(IDC_QMESSAGES_JOURNAL_QUOTA, OnChangeRWField)
	ON_BN_CLICKED(IDC_QUEUE_JQUOTA_CHECK, OnQueueJquotaCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral message handlers

BOOL CQueueGeneral::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Initialize the privacy level combo box
        //
        CComboBox *ccomboPrivLevel = (CComboBox *)GetDlgItem(IDC_QMESSAGES_PRIVLEVEL);

        //
        // Note: Order must be the same as the order of the constants
        //       MQ_PRIV_LEVEL_NONE, OPTIONAL and BODY. We assume that 
        //       MQ_PRIV_LEVEL_NONE is zero, and the rest are consecutive.
        //
        UINT uiPrivacyValues[] = {IDS_QUEUE_ENCRYPT_NONE, 
                                  IDS_QUEUE_ENCRYPT_OPTIONAL, 
                                  IDS_QUEUE_ENCRYPT_BODY};

        CString strValueToInsert;

        for (UINT i=0; i<(sizeof(uiPrivacyValues) / sizeof(uiPrivacyValues[0])); i++)
        {
            VERIFY(strValueToInsert.LoadString(uiPrivacyValues[i]));
            VERIFY(CB_ERR != ccomboPrivLevel->AddString(strValueToInsert));
        }
    
        VERIFY(CB_ERR != ccomboPrivLevel->SetCurSel(m_iPrivLevel));  
        
        //
        // Hide ID for private queue
        //
        if (m_fPrivate)
        {
            GetDlgItem(IDC_QGENERAL_ID)->ShowWindow(FALSE);
            GetDlgItem(IDC_QGENERAL_ID_LABEL)->ShowWindow(FALSE);
            GetDlgItem(IDC_QUEUE_BASEPRIORITY)->ShowWindow(FALSE);
            GetDlgItem(IDC_QUEUE_BASEPRIORITY_LABEL)->ShowWindow(FALSE);
            GetDlgItem(IDC_BASEPRIORITY_SPIN)->ShowWindow(FALSE);
        }
    }


	UpdateData( FALSE );

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        if (m_fPrivate)
        {
            m_staticIcon.SetIcon(LoadIcon(g_hResourceMod, (LPCTSTR)IDI_PRIVATE_QUEUE));
        }

        m_spinPriority.SetRange(MIN_BASE_PRIORITY, MAX_BASE_PRIORITY);
        m_fModified = FALSE;
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CQueueGeneral::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }
    //
    // BugBug Can we check what really changed and set only that? Does it matter?
    //
	PROPID paPropid[] = 
        {PROPID_Q_LABEL, PROPID_Q_TYPE,  PROPID_Q_QUOTA, PROPID_Q_AUTHENTICATE, 
         PROPID_Q_JOURNAL, PROPID_Q_JOURNAL_QUOTA, 
         PROPID_Q_PRIV_LEVEL, 
         
         //
         // Begin public only properties - remember to change x_iNumPublicOnlyProps
         // If you add properties hee
         //
         PROPID_Q_BASEPRIORITY};

	const DWORD x_iNumPublicOnlyProps = 1;

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;
	//
	// PROPID_Q_LABEL
	//
    ASSERT(PROPID_Q_LABEL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_LPWSTR;
	apVar[iProperty++].pwszVal = (LPWSTR)(LPCWSTR)m_strLabel;

	//
	// PROPID_Q_TYPE
	//
    ASSERT(PROPID_Q_TYPE == paPropid[iProperty]);
    apVar[iProperty].vt = VT_CLSID;
	apVar[iProperty++].puuid = &m_guidTypeID;

    //
    // PROPID_Q_QUOTA
    //
    ASSERT(PROPID_Q_QUOTA == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwQuota ;
    
    //
    // PROPID_Q_AUTHENTICATE
    //
    ASSERT(PROPID_Q_AUTHENTICATE == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI1;
	apVar[iProperty++].bVal = (UCHAR)m_fAuthenticated;
     
    //
    // PROPID_Q_JOURNAL
    // 
    ASSERT(PROPID_Q_JOURNAL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI1;
	apVar[iProperty++].bVal = (UCHAR)m_fJournal;
    
    //
    // PROPID_Q_JOURNAL_QUOTA
    //
    ASSERT(PROPID_Q_JOURNAL_QUOTA == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwJournalQuota;
    
    //
    // PROPID_Q_PRIV_LEVEL
    //
    ASSERT(PROPID_Q_PRIV_LEVEL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_iPrivLevel;

    //
    // Public only properties
    //
    if (!m_fPrivate)
    {
        //
        // PROPID_Q_BASEPRIORITY
        //
        ASSERT(PROPID_Q_BASEPRIORITY == paPropid[iProperty]);
        apVar[iProperty].vt = VT_I2;
	    apVar[iProperty++].iVal = (short)m_lBasePriority;
    }

    HRESULT hr = MQ_OK;

    MQQUEUEPROPS mqp = {x_iPropCount, paPropid, apVar, 0};

    if (m_fPrivate)
    {
        //
        // For private queue, we do not want to set the public only properties
        //
        mqp.cProp -= x_iNumPublicOnlyProps;
    }

	if(m_fPrivate)
	{
		hr = MQSetQueueProperties(m_strFormatName, &mqp);
	}
	else
	{
		ASSERT(m_guidID != GUID_NULL);

		hr = ADSetObjectPropertiesGuid(
				   eQUEUE,
				   m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
				   m_fLocalMgmt ? false : true,		// fServerName
				   &m_guidID,
				   mqp.cProp,
				   mqp.aPropID,
				   mqp.aPropVar 
				   );

	}

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strName);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}

void CQueueGeneral::OnQueueMquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_QMESSAGES_QUOTA, IDC_QUEUE_MQUOTA_CHECK);	
    OnChangeRWField();
}

void CQueueGeneral::OnQueueJquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_QMESSAGES_JOURNAL_QUOTA, IDC_QUEUE_JQUOTA_CHECK);	
    OnChangeRWField();
}


HRESULT 
CQueueGeneral::InitializeProperties(
		CString &strMsmqPath, 
		CPropMap &propMap, 
		CString* pstrDomainController, 
        CString* pstrFormatName /* = 0 */
		)
{
	TrTRACE(QGen, "InitializeProperties(), QueuePathName = %ls", strMsmqPath);

	if(!m_fLocalMgmt)
	{
		//
		// In MMC we will get the domain controller that is used by the MMC
		//
		ASSERT(pstrDomainController != NULL);
		m_strDomainController = *pstrDomainController;
		TrTRACE(QGen, "InitializeProperties(), domain controller = %ls", m_strDomainController);
	}

	m_strName = strMsmqPath;
    if (0 != pstrFormatName)
    {
	    m_strFormatName = *pstrFormatName;
    }
    else
    {
        const x_dwFormatNameMaxSize = 255;
        DWORD dwSize = x_dwFormatNameMaxSize;
        HRESULT hr = MQPathNameToFormatName(strMsmqPath, m_strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
        m_strFormatName.ReleaseBuffer();
        if(FAILED(hr))
        {
            //
            // If failed, just display a message
            //
            MessageDSError(hr,IDS_OP_PATHNAMETOFORMAT, strMsmqPath);
            return(hr);
        }
    }

    PROPVARIANT propVar;
    PROPID pid;

	//
	// PROPID_Q_INSTANCE
	//
    if (m_fPrivate)
    {
    	m_guidID = GUID_NULL;
    }
    else
    {
        pid = PROPID_Q_INSTANCE;
        VERIFY(propMap.Lookup(pid, propVar));
    	m_guidID = *propVar.puuid;
    }

	//
	// PROPID_Q_LABEL
	//
    pid = PROPID_Q_LABEL;
    VERIFY(propMap.Lookup(pid, propVar));
    m_strLabel = propVar.pwszVal;

	//
	// PROPID_Q_TYPE
	//
    pid = PROPID_Q_TYPE;
    VERIFY(propMap.Lookup(pid, propVar));
	m_guidTypeID = *propVar.puuid;

    //
    // PROPID_Q_QUOTA
    //
    pid = PROPID_Q_QUOTA;
    VERIFY(propMap.Lookup(pid, propVar));
	m_dwQuota = propVar.ulVal;
    
    //
    // PROPID_Q_AUTHENTICATE
    //
    pid = PROPID_Q_AUTHENTICATE;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fAuthenticated = propVar.bVal;
    
    //
    // PROPID_Q_TRANSACTION
    //
    pid = PROPID_Q_TRANSACTION;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fTransactional = propVar.bVal;
     
    //
    // PROPID_Q_JOURNAL
    // 
    pid = PROPID_Q_JOURNAL;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fJournal = propVar.bVal;
    
    //
    // PROPID_Q_JOURNAL_QUOTA
    //
    pid = PROPID_Q_JOURNAL_QUOTA;
    VERIFY(propMap.Lookup(pid, propVar));
	m_dwJournalQuota = propVar.ulVal;
    
    //
    // PROPID_Q_PRIV_LEVEL
    //
    pid = PROPID_Q_PRIV_LEVEL;
    VERIFY(propMap.Lookup(pid, propVar));
	m_iPrivLevel = propVar.ulVal;

    //
    // PROPID_Q_BASEPRIORITY
    //
    pid = PROPID_Q_BASEPRIORITY;
    VERIFY(propMap.Lookup(pid, propVar));
	m_lBasePriority = propVar.iVal;

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\newtrig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    newtrig.h

Abstract:
	Definition for the new trigger property sheet

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __NEWTRIGGER_H__
#define __NEWTRIGGER_H__

class CAttachedRule;
class CTriggerProp;

class CNewTrigger : public CPropertySheetEx
{
public:
	CNewTrigger(
        CTriggerSet* pTrigSet,
        CRuleSet* pRuleSet,
        LPCTSTR queueName
        );

     ~CNewTrigger();

    BOOL SetWizardButtons();

    void OnFinishCreateTrigger(void) throw (_com_error);

    RuleList GetRuleList()
    {
        return m_pRuleSet->GetRuleList();
    }

	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();

private:
    R<CTriggerSet> m_pTriggerSet;
    R<CRuleSet> m_pRuleSet;

    CTriggerProp* m_pGeneral;
    CAttachedRule* m_pAttachRule;
};

#endif //__NEWTRIGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	qext.h

Abstract:

	Definition for the queue extension snapnin node class.

Author:

    RaphiR

--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __QEXT_H_
#define __QEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"


#include "icons.h"

/****************************************************

        CSnapinQueue Class
    
 ****************************************************/

class CSnapinQueue : public CNodeWithScopeChildrenList<CSnapinQueue, TRUE>
{
public:

    CString     m_pwszQueueName;            // Queue name
    WCHAR       m_szFormatName[256];        // Format name
    HRESULT     m_hrError;

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinQueue, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinQueue(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR lpcwstrLdapName);
    void Init(LPCWSTR lpcwstrLdapName);

	~CSnapinQueue()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

private:
	BOOL    m_fDontExpand;
protected:
	CString m_strMsmqPathName;
};



/****************************************************

        CQueueExtData Class
    
 ****************************************************/

class CQueueExtData : public CSnapInItemImpl<CQueueExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;


    CSnapin *   m_pComponentData;

	BEGIN_SNAPINCOMMAND_MAP(CQueueExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CQueueExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CQueueExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CQueueExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

    IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);
    
    void RemoveAllChildrens(void);

    void RemoveChild(CString& strQName);


private:

    CMap< CString, LPCWSTR, CSnapinQueue*, CSnapinQueue* > m_mapQueues;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\privadm.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	privadm.cpp

Abstract:
	Implementation for the private queues administration

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "rt.h"
#include "lqDsply.h"
#include "privadm.h"
#include "rdmsg.h"
#include "SnpQueue.h"
#include "snpnerr.h"
#include "strconv.h"
#include "mqPPage.h"
#include "qname.h"

#include "privadm.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/****************************************************

        CLocalPrivateFolder Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CLocalPrivateFolder
// {7198f3d8-4baf-11d2-8292-006094eb6406}
static const GUID CLocalPrivateFolderGUID_NODETYPE = 
{ 0x7198f3d8, 0x4baf, 0x11d2, { 0x82, 0x92, 0x0, 0x60, 0x94, 0xeb, 0x64, 0x6 } };

const GUID*  CLocalPrivateFolder::m_NODETYPE = &CLocalPrivateFolderGUID_NODETYPE;
const OLECHAR* CLocalPrivateFolder::m_SZNODETYPE = OLESTR("7198f3d8-4baf-11d2-8292-006094eb6406");
const OLECHAR* CLocalPrivateFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalPrivateFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//------------------------------------------------
//
// Table of private queue properties
//
//------------------------------------------------
static void CALLBACK DisplayPrivacyToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI4);
   str = PrivacyToString(pPropVar->ulVal);
}

PropertyDisplayItem PrivateQueueMQDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_Q_PATHNAME,   PROPID_Q_PATHNAME,              &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
	{ IDS_Q_LABEL,      PROPID_Q_LABEL,                 &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, 200,         NULL},
	{ IDS_Q_QUOTA,      PROPID_Q_QUOTA,                 &g_VTUI4,     QuotaToString,              NO_OFFSET, 0, HIDE_COLUMN, NULL},
    { IDS_Q_TRANSACTION,PROPID_Q_TRANSACTION,           &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_TYPE,       PROPID_Q_TYPE,                  &g_VTCLSID,   NULL,                       NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_AUTHENTICATE,PROPID_Q_AUTHENTICATE,         &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_JOURNAL,    PROPID_Q_JOURNAL,               &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
	{ IDS_Q_JOURNAL_QUOTA,PROPID_Q_JOURNAL_QUOTA,       &g_VTUI4,     QuotaToString,              NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_Q_PRIV_LEVEL, PROPID_Q_PRIV_LEVEL,            &g_VTUI4,     DisplayPrivacyToString,     NO_OFFSET, 0, HIDE_COLUMN, NULL},
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumPrivateQueueMQDisplayProps = 
    ((sizeof(PrivateQueueMQDisplayList)/sizeof(PrivateQueueMQDisplayList[0])) - 1);

PropertyDisplayItem PrivateQueueMGMTDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width         |Sort
    // Resource       |                              |              | function                   |Offset  |   |              |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+--------------+----
    { IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,          NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0,  HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0,  HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0,  HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumPrivateQueueMGMTDisplayProps = 
    ((sizeof(PrivateQueueMGMTDisplayList)/sizeof(PrivateQueueMGMTDisplayList[0])) - 1);

PropertyDisplayItem RemotePrivateQueueDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
    { IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumRemotePrivateQueueDisplayProps = 
    ((sizeof(RemotePrivateQueueDisplayList)/sizeof(RemotePrivateQueueDisplayList[0])) - 1);

PropertyDisplayItem *InitPrivateQueueDisplayList()
{
    static PropertyDisplayItem tempPrivateQueueDisplayList[x_dwNumPrivateQueueMQDisplayProps + x_dwNumPrivateQueueMGMTDisplayProps + 1] = {0};
    //
    // First time - initialize
    //
    memcpy(
		tempPrivateQueueDisplayList, 
		PrivateQueueMQDisplayList, 
		x_dwNumPrivateQueueMQDisplayProps * sizeof(PrivateQueueMQDisplayList[0])
		);

    memcpy(
		tempPrivateQueueDisplayList + x_dwNumPrivateQueueMQDisplayProps, 
		PrivateQueueMGMTDisplayList,
		sizeof(PrivateQueueMGMTDisplayList)
		);

    return tempPrivateQueueDisplayList;
}

PropertyDisplayItem *PrivateQueueDisplayList = InitPrivateQueueDisplayList();



PropertyDisplayItem *CLocalPrivateFolder::GetDisplayList()
{
    if (m_fOnLocalMachine) 
    {
        return PrivateQueueDisplayList;
    }
    else
    {
        return RemotePrivateQueueDisplayList;
    }
}

const DWORD CLocalPrivateFolder::GetNumDisplayProps()
{
    if (m_fOnLocalMachine) 
    {
        return x_dwNumPrivateQueueMQDisplayProps + x_dwNumPrivateQueueMGMTDisplayProps;
    }
    else
    {
        return x_dwNumRemotePrivateQueueDisplayProps;
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    HRESULT hr = S_OK;
    CString strTitle;

	MQMGMTPROPS	  mqProps;
    PROPVARIANT   propVar;

	//
	// Retreive the private queues of the QM
	//
    PROPID  propId = PROPID_MGMT_MSMQ_PRIVATEQ;
    propVar.vt = VT_NULL;

	mqProps.cProp = 1;
	mqProps.aPropID = &propId;
	mqProps.aPropVar = &propVar;
	mqProps.aStatus = NULL;

    hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_NOCONNECTION_TO_SRVICE);
        return(hr);
    }

	ASSERT(propVar.vt == (VT_VECTOR | VT_LPWSTR));
	
	//
	// Sort the queues by their name
	//
	qsort(propVar.calpwstr.pElems, propVar.calpwstr.cElems, sizeof(WCHAR *), QSortCompareQueues);

	//
	// Loop over all private queue and create queue objects
	//
	for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
        //
		// Get the format name of the private queue
		//
		CString szPathName = propVar.calpwstr.pElems[i];
        MQFreeMemory(propVar.calpwstr.pElems[i]);

        //
        // We add the private queue to the scope WITHOUT checking for errors.
        // Reason: AddPrivateQueueToScope reports its errors to the user, and even if
        // one queue is corrupted for some reason, we still want to display the rest.
        //
        AddPrivateQueueToScope(szPathName);
	
    }

	MQFreeMemory(propVar.calpwstr.pElems);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::AddPrivateQueueToScope

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::AddPrivateQueueToScope(CString &szPathName)
{
    PropertyDisplayItem *aDisplayList = GetDisplayList();
    CString strFormatName;
    HRESULT hr = S_OK;

    AP<PROPID> aPropId = new PROPID[GetNumDisplayProps()]; 
    AP<PROPVARIANT> aPropVar = new PROPVARIANT[GetNumDisplayProps()];

    //
    // Initialize variant array
    //
    for(DWORD j = 0; j < GetNumDisplayProps(); j++)
    {
	    aPropId[j] = aDisplayList[j].itemPid;
	    aPropVar[j].vt = VT_NULL;
    }

    DWORD dwMgmtPropOffset = 0;
    if (m_fOnLocalMachine) 
    {
        hr = GetPrivateQueueQMProperties(szPathName, aPropId, aPropVar, strFormatName);

        if(FAILED(hr))
        {
            //
            // If failed, put an error node
            //
		    CErrorNode *pErr = new CErrorNode(this, m_pComponentData);
		    CString szErr;

		    MQErrorToMessageString(szErr, hr);
		    pErr->m_bstrDisplayName = szPathName + L" - " + szErr;
	  	    AddChild(pErr, &pErr->m_scopeDataItem);
            return(hr);
        }
        dwMgmtPropOffset = x_dwNumPrivateQueueMQDisplayProps;
    }
    else // Remote queue
    {
        strFormatName.Format(TEXT("%s%s%s%s"), 
                             FN_DIRECT_TOKEN, FN_EQUAL_SIGN, FN_DIRECT_OS_TOKEN,
                             szPathName);
    }

    //
    // Note: We do not check error code from GetPrivateQueueMGMTProperties
    // This is because this function will clear the management properties if
    // the management API call fails
    //
    GetPrivateQueueMGMTProperties(szPathName, 
                                  GetNumDisplayProps() - dwMgmtPropOffset,
                                  &aPropId[dwMgmtPropOffset], 
                                  &aPropVar[dwMgmtPropOffset], 
                                  strFormatName,
                                  aDisplayList + dwMgmtPropOffset);
    //
    // Create Private queue object
    //
    CPrivateQueue *pQ = new CPrivateQueue(this, GetDisplayList(), GetNumDisplayProps(), m_pComponentData, m_fOnLocalMachine);

    pQ->m_mqProps.cProp    = GetNumDisplayProps();
    pQ->m_mqProps.aPropID  = aPropId;
    pQ->m_mqProps.aPropVar = aPropVar;
    pQ->m_mqProps.aStatus  = NULL;

    pQ->m_szFormatName = strFormatName;
    pQ->m_szPathName   = szPathName;
	pQ->m_szMachineName = m_szMachineName;

    //
    // Extract the queue name only from the full private path name
    //
    CString csName = szPathName;
    CString szUpperName = csName;
    szUpperName.MakeUpper();

    int n = szUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR);
    ASSERT(n != -1);

    pQ->m_bstrDisplayName = csName.Mid(n + PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

    //
    // Add it to the left pane
    //
    AddChild(pQ, &pQ->m_scopeDataItem);

    //
    // If all is well, do not free propid / propvar - they will be freed when the node
    // is deleted
    //
    aPropId.detach();
    aPropVar.detach();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::GetPrivateQueueQMProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::GetPrivateQueueQMProperties(
            CString &szPathName, 
            PROPID *aPropId, 
            PROPVARIANT *aPropVar, 
            CString &strFormatName)
{
    const x_dwFormatNameMaxSize = 255;
    DWORD dwSize = x_dwFormatNameMaxSize;
    HRESULT hr = MQPathNameToFormatName(szPathName, strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
    strFormatName.ReleaseBuffer();
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Retrieve the queue properties
    //
    MQQUEUEPROPS  mqProps;
	mqProps.cProp    = x_dwNumPrivateQueueMQDisplayProps;   
	mqProps.aPropID  = aPropId; 
	mqProps.aPropVar = aPropVar;
	mqProps.aStatus  = NULL; 

	hr = MQGetQueueProperties(strFormatName, &mqProps);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::GetPrivateQueueMGMTProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::GetPrivateQueueMGMTProperties(
            CString &szPathName,
            DWORD dwNumProperties,
            PROPID *aPropId, 
            PROPVARIANT *aPropVar, 
            CString &strFormatName,
            PropertyDisplayItem *aDisplayList)
{
    MQMGMTPROPS  mqQProps;
	mqQProps.cProp    = dwNumProperties;   
	mqQProps.aPropID  = aPropId;
	mqQProps.aPropVar = aPropVar;
	mqQProps.aStatus  = NULL;

    CString szObjectName = L"QUEUE=" + strFormatName;
	HRESULT hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, szObjectName, &mqQProps);
    //
    // BugBug - Should check error here, and decide wheather the queue is simply not open 
    // (then display only MQ properties) or something is wrong. This is not done today because
    // the error code when the queue is not opened is MQ_ERROR - not detailed enough
    //
    if FAILED(hr)
    {
        //
        // Clear the properties using the "Clear" function
        //
        for (DWORD i = 0; i < mqQProps.cProp; i++)
        {
            VTHandler       *pvth = aDisplayList[i].pvth;
            pvth->Clear(&mqQProps.aPropVar[i]);
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::OnNewPrivateQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::OnNewPrivateQueue(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	R<CQueueName> pQueueNameDlg = new CQueueName(m_szMachineName, L"", TRUE);       
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

    bHandled = TRUE;

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();
    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        return S_FALSE;
    }

    return AddPrivateQueueToScope(pQueueNameDlg->GetNewQueuePathName());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\privadm.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.h

Abstract:

	Definition for the Private queues administration
Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __PRIVADM_H_
#define __PRIVADM_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"
#include "dataobj.h"
#include "sysq.h"

#include "icons.h"

/****************************************************

        CLocalPrivateFolder Class
    
 ****************************************************/

class CLocalPrivateFolder : public CLocalQueuesFolder<CLocalPrivateFolder>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalPrivateFolder, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_NEW_PRIVATE_QUEUE, OnNewPrivateQueue)
	END_SNAPINCOMMAND_MAP()

	UINT GetMenuID()
    {
        if (m_fOnLocalMachine)
        {
            //
            // Admin on local machine
            //
            return IDR_LOCALPRIVATE_MENU;
        }
        else
        {
            return IDR_REMOTEPRIVATE_MENU;
        }
    }


    CLocalPrivateFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                        CString &strMachineName, LPCTSTR strDisplayName) : 
             CLocalQueuesFolder<CLocalPrivateFolder>(pParentNode, pComponentData, strMachineName, strDisplayName)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CLocalPrivateFolder()
	{
	}

    virtual PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
	virtual HRESULT PopulateScopeChildrenList();
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    HRESULT OnNewPrivateQueue(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot);
    HRESULT AddPrivateQueueToScope(CString &szPathName);
    HRESULT GetPrivateQueueQMProperties(CString &szPathName, PROPID *aPropId, PROPVARIANT *aPropVar, CString &strFormatName);
    HRESULT GetPrivateQueueMGMTProperties(CString &szPathName, DWORD dwNumProperties, PROPID *aPropId, PROPVARIANT *aPropVar, CString &strFormatName, PropertyDisplayItem *aDisplayList);
};

//
// Persistency functions
//
HRESULT PrivateQueueDataSave(IStream* pStream);
HRESULT PrivateQueueDataLoad(IStream* pStream);
DWORD PrivateQueueDataSize(void);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qmltcast.h ===
#if !defined(AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
#define AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// qmltcast.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast dialog

class CQueueMulticast : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CQueueMulticast)

// Construction
public:
	CQueueMulticast(
		BOOL fPrivate = FALSE, 
		BOOL fLocalMgmt = FALSE
		);

	~CQueueMulticast();

    HRESULT 
	InitializeProperties(
			CString &strMsmqPath,
			CPropMap &propMap,                                  
			CString* pstrDomainController, 
			CString* pstrFormatName = 0
			);

// Dialog Data
	//{{AFX_DATA(CQueueMulticast)
	enum { IDD = IDD_QUEUE_MULTICAST };
	CString m_strMulticastAddress;
    CString m_strInitialMulticastAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CQueueMulticast)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CQueueMulticast)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
  
    BOOL IsMulticastAddressAvailable ();

    BOOL m_fPrivate;
    BOOL m_fLocalMgmt;

    CString m_strFormatName;
    CString	m_strName;
    CString m_strDomainController;

    void DDV_ValidMulticastAddress(CDataExchange* pDX, CString& str);    

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rdmsg.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   rdmsg.cpp

Abstract:

   Implementation file for the CReadMsg snapin node class

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "mqprops.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "rt.h"
#include "mqsnap.h"
#include "snapin.h"
#include "mqppage.h"
#include "rdmsg.h"
#include "globals.h"
#include "message.h"
#include "mqcast.h"

#include "rdmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern PropertyDisplayItem MessageDisplayList[];


/////////////////////////////////////////////////////////////////////////////
// CReadMsg
// {B3351249-BEFC-11d1-9B9B-00E02C064C39}
static const GUID CReadMsgGUID_NODETYPE =
{ 0xb3351249, 0xbefc, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CReadMsg::m_NODETYPE = &CReadMsgGUID_NODETYPE;
const OLECHAR* CReadMsg::m_SZNODETYPE = OLESTR("B3351249-BEFC-11d1-9B9B-00E02C064C39");
const OLECHAR* CReadMsg::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CReadMsg::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return InsertColumnsFromDisplayList(pHeaderCtrl, MessageDisplayList);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::OpenQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::OpenQueue(DWORD dwAccess, HANDLE *phQueue)
{
    HRESULT rc;    
    rc = MQOpenQueue(
            m_szFormatName,
            dwAccess,
            0,
            phQueue
            );
    return rc;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::PopulateResultChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::PopulateResultChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wc;

	HRESULT  hr;	

	// Check for preconditions:
	// None.

    //
    // Read the messages
    //
    DWORD cProps;
    MQMSGPROPS      msgprops;
    VTHandler       *pvth;
    QUEUEHANDLE     qh;

    //
    // Open the queue
    //    
    hr = OpenQueue(MQ_PEEK_ACCESS | m_fAdminMode, &qh);
    if(FAILED(hr))
    {     
		if ( hr == MQ_ERROR_NO_DS )
		{
			DisplayErrorAndReason(IDS_OP_READMESSAGE, IDS_NO_DS_ERROR, L"", 0);
			return hr;
		}
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OP_READMESSAGE);
        return(hr);
    }
              
    //
    // Create a cursor
    //
    HANDLE hCursor = 0;
    hr = MQCreateCursor(qh, &hCursor);
    if(FAILED(hr))
    {
        //
        // If failed, display the error
        MessageDSError(hr, IDS_OP_READMESSAGE);
        return(hr);
    }

    //
    // Create the 1st message object
    //
    CMessage * pMessage = new CMessage(this, m_pComponentData);

    //
    // Read all messages in queue
    //
    DWORD dwAction = MQ_ACTION_PEEK_CURRENT;
    DWORD dwMsg = 0;
    do
    {
        //
        // Prepare message properties
        //
        MsgProps * pMsgProps = new MsgProps;
        memset(pMsgProps, 0, sizeof(MsgProps));

        DWORD i = 0;
        while(MessageDisplayList[i].itemPid != 0)
        {
            pMsgProps->aPropId[i] = MessageDisplayList[i].itemPid;
            pvth = MessageDisplayList[i].pvth;
            pvth->Set(&(pMsgProps->aPropVar[i]),
                      (void *)pMsgProps,
                      MessageDisplayList[i].offset,
                      MessageDisplayList[i].size);
            i++;
        }


        cProps = i;
        msgprops.cProp    = cProps;
        msgprops.aPropID  = pMsgProps->aPropId;
        msgprops.aPropVar = pMsgProps->aPropVar;
        msgprops.aStatus  = NULL;

        //
        // Peek next message
        //
        hr = MQReceiveMessage(qh, 0, dwAction, &msgprops, NULL, NULL, hCursor, NULL);
        dwAction = MQ_ACTION_PEEK_NEXT;

        if(FAILED(hr))
        {
            switch(hr)
            {
                case MQ_ERROR_BUFFER_OVERFLOW:
                case MQ_ERROR_SENDERID_BUFFER_TOO_SMALL:
                case MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL:
                case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL:
                    //
                    //  In all these cases some buffers are too small, nevertheless
                    //  the buffer is filled to its extent.
                    //
                    //  It is useful to put '\0' at the end of string since in this
                    //  case we can get buffer without null-terminated string and 
                    //  it can cause GP later
                    //
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszLabel);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszDestQueue);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszRespQueue);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszAdminQueue);            
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszMultiDestFN);    
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszMultiRespFN);

                    break;

                default:

                    //
                    // No more messages
                    //
                    delete pMessage;
                    delete pMsgProps;

                   	MQCloseCursor(hCursor);
                    MQCloseQueue(qh);
                    return(S_OK);
            }
        }

        //
        // Save the property values in the message object
        //
        pMessage->SetMsgProps(pMsgProps);

        //
        // Add the message to the result list
        //
    	AddChildToList(pMessage);

        //
        // Get ready with new message
        //
        pMessage = new CMessage(this, m_pComponentData);

        dwMsg++;

     // Bugbug. Read up to 1000 messages (we need to replace this with Virtual list
    }while(dwMsg < 1000);

    delete pMessage;

	MQCloseCursor(hCursor);
    MQCloseQueue(qh);

    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );


    return(hr);
}
        


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::OnPurge

    Called when menu item to purge the queue is selected

Note that if you want to retrieve the IConsole from the
CSnapInObjectRootBase, you should write the following code:


    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::OnPurge(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot)
{

      AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Get the console pointer
    //
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    int res;
    CString title;
    CString text;
    text.LoadString(IDS_CONFIRM_PURGE);
    title.LoadString(IDS_MSMQADMIN);
    spConsole->MessageBox(text, title,MB_YESNO | MB_ICONWARNING, &res);

    if(IDNO == res)
        return(S_OK);

    CWaitCursor wc;

    //
    // Open the queue for receive (MQ_RECEIVE_ACCESS)
    //
    HRESULT rc;
    HANDLE hQueue;    
    rc = OpenQueue(            
            MQ_RECEIVE_ACCESS | m_fAdminMode,            
            &hQueue
            );

    if(FAILED(rc))
    {
        MessageDSError(rc, IDS_OP_PURGE);
        return (S_OK);
    }

    rc = MQPurgeQueue(hQueue);
    if(SUCCEEDED(rc))
    {
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }
    else
    {
        MessageDSError(rc, IDS_OP_PURGE);
    }

    MQCloseQueue(hQueue);


    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CReadMsg::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

   	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szComputerName, 
            m_szComputerName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}


    hr = CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >::FillData(cf, pStream);
	return hr;
}


CString 
CReadMsg::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_MESSAGES);

	return strHelpLink;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CReadSystemMsg::GetComputerGuid

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadSystemMsg::GetComputerGuid()
{
    if (m_ComputerGuid != GUID_NULL)
    {
        return S_OK;
    }

    //
    // Find the computer's GUID so we can look for queues
    //
    PROPID pid = PROPID_QM_MACHINE_ID;
    PROPVARIANT pvar;
    pvar.vt = VT_NULL;
    
    HRESULT hr = ADGetObjectProperties(
                        eMACHINE,
                        GetDomainController(NULL),
						false,	// fServerName
                        m_szComputerName, 
                        1, 
                        &pid, 
                        &pvar
                        );
    if FAILED(hr)
    {
        if (hr != MQDS_OBJECT_NOT_FOUND)
        {
            //
            // Real error. Return.
            //
            return hr;
        }
        //
        // This may be an NT4 server, and we may be using a full DNS name. Try again with
        // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
        //
        CString strNetBiosName;
        if (!GetNetbiosName(m_szComputerName, strNetBiosName))
        {
            //
            // Already a netbios name. No need to proceed
            //
            return hr;
        }
       
        hr = ADGetObjectProperties(
                eMACHINE,
                GetDomainController(NULL),
				false,	// fServerName
                strNetBiosName, 
                1, 
                &pid, 
                &pvar
                );

        if FAILED(hr)
        {
            //
            // No luck with Netbios name as well... return
            //
            return hr;
        }
    }

    ASSERT(pvar.vt == VT_CLSID);
    m_ComputerGuid = *pvar.puuid;
    MQFreeMemory(pvar.puuid);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadSystemMsg::OpenQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadSystemMsg::OpenQueue(DWORD dwAccess, HANDLE *phQueue)
{
    HRESULT rc;    
    rc = MQOpenQueue(
            m_szFormatName,
            dwAccess,
            0,
            phQueue
            );

    if (rc != MQ_ERROR_QUEUE_NOT_FOUND &&
        rc != MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION)
    {           
        return(rc);
    }
        
    //
    // bug 5411: we try to open system queue of NT4 machine.
    // So, we have to try with NT4 format
    //

    //
    // verify if it is local computer: if so, we run on NT5
    // and the format was NOT problem.     
    // if m_szComputerName equals to "" it means "local computer"   
    //    
    // verify if suffix is defined
    //
    if (m_szComputerName == TEXT("") ||      
        m_szSuffix == TEXT(""))
    {        
        return(rc);
    }

    //
    // get computer guid 
    //
    rc = GetComputerGuid();
    if (FAILED(rc))
    {
        return (rc);
    }
    
    //
    // try to build formatname in NT4 format:
    // MACHINE=<machine guid>;<suffix>    
    //
        
    GUID_STRING strUuid;
    MQpGuidToString(&m_ComputerGuid, strUuid);
              
    CString strNT4FormatName;
    strNT4FormatName.Format(L"%s%s%s", 
                        FN_MACHINE_TOKEN FN_EQUAL_SIGN, //MACHINE=
                        strUuid,                         //<machine guid>
                        m_szSuffix);                     //<suffix> like :JOURNAL
    
    //
    // try to open queue again
    //
    rc = MQOpenQueue(
            strNT4FormatName,
            dwAccess,
            0,
            phQueue
            );
    if (FAILED(rc))
    {        
        return(rc);
    }

    m_szFormatName = strNT4FormatName;
    return rc;
}


CString 
CReadSystemMsg::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qmltcast.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qmltcast.cpp

Abstract:

    Queue/Multicast Address property page implementation

Author:

    Tatiana Shubin (tatianas)

--*/
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "qmltcast.h"
#include "qformat.h"
#include "Tr.h"
#include "Fn.h"

#include "qmltcast.tmh"

const TraceIdEntry QMulticast = L"QUEUE MULTICAST";

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast property page

IMPLEMENT_DYNCREATE(CQueueMulticast, CMqPropertyPage)

CQueueMulticast::CQueueMulticast(
		 BOOL fPrivate /* = FALSE */, 
		 BOOL fLocalMgmt /* = FALSE */
		 ) : 
    CMqPropertyPage(CQueueMulticast::IDD)
{    
    m_fPrivate = fPrivate;
    m_fLocalMgmt = fLocalMgmt;
    //{{AFX_DATA_INIT(CQueueMulticast)
    m_strMulticastAddress = _T("");
    m_strInitialMulticastAddress = _T("");
	//}}AFX_DATA_INIT

}

CQueueMulticast::~CQueueMulticast()
{
}

void CQueueMulticast::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
	//{{AFX_DATA_MAP(CQueueMulticast)
	DDX_Text(pDX, IDC_QMULTICAST_QADDRESS, m_strMulticastAddress);
	//}}AFX_DATA_MAP	
    DDV_ValidMulticastAddress(pDX, m_strMulticastAddress);
}

BEGIN_MESSAGE_MAP(CQueueMulticast, CMqPropertyPage)
    //{{AFX_MSG_MAP(CQueueMulticast)  
    ON_EN_CHANGE(IDC_QMULTICAST_QADDRESS, OnChangeRWField)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast message handlers

BOOL CQueueMulticast::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        if (!IsMulticastAddressAvailable ())
        {
            GetDlgItem(IDC_QMULTICAST_QADDRESS)->EnableWindow(FALSE);
            GetDlgItem(IDC_QMULTICAST_QADDRESS_LABEL)->EnableWindow(FALSE);
            //
            // BUGBUG: Add text box with explanation that this feature is not
            // supported. Maybe instead of EnableWindow(FALSE) use
            // ShowWindow(FALSE)
            //
        }        
    }

	UpdateData( FALSE );
  
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}   

BOOL CQueueMulticast::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    if (m_strInitialMulticastAddress == m_strMulticastAddress)
    {  
        //
        // there is no change
        //
        return TRUE;
    } 

    PROPID paMulticastPropid[] = {PROPID_Q_MULTICAST_ADDRESS};

	DWORD iProperty = 0;           
    PROPVARIANT apMulticastVar[1];
    
    if (m_strMulticastAddress == _T("")) 
    {
        apMulticastVar[iProperty++].vt = VT_EMPTY;	   
    }
    else
    {
        apMulticastVar[iProperty].vt = VT_LPWSTR;
	    apMulticastVar[iProperty++].pwszVal = (LPWSTR)(LPCWSTR)m_strMulticastAddress;
    }                         

    MQQUEUEPROPS mqp = {iProperty, paMulticastPropid, apMulticastVar, 0};
        
    HRESULT hr = MQ_OK;
	if(m_fPrivate)
	{
		hr = MQSetQueueProperties(m_strFormatName, &mqp);
	}
	else
	{
		AP<WCHAR> pStrToFree;
        QUEUE_FORMAT QueueFormat;
		if (!FnFormatNameToQueueFormat(m_strFormatName, &QueueFormat, &pStrToFree))
		{
			MessageDSError(MQ_ERROR_ILLEGAL_FORMATNAME, IDS_OP_SET_PROPERTIES_OF, m_strFormatName);
			return FALSE;
		}

        ASSERT(QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC);

		hr = ADSetObjectPropertiesGuid(
				   eQUEUE,
				   m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
				   m_fLocalMgmt ? false : true,		// fServerName
				   &QueueFormat.PublicID(),
				   mqp.cProp,
				   mqp.aPropID,
				   mqp.aPropVar 
				   );

	}

    if (FAILED(hr))
    {     
        MessageDSError(hr, IDS_OP_SET_MULTICAST_PROPERTY, m_strName);
        return FALSE;
    }
	
    m_strInitialMulticastAddress = m_strMulticastAddress;
  
	return CMqPropertyPage::OnApply();
}

HRESULT 
CQueueMulticast::InitializeProperties( 
         CString  &strMsmqPath,                                              
         CPropMap &propMap,                 
		 CString* pstrDomainController, 
         CString* pstrFormatName /* = 0 */
         )
{
	TrTRACE(QMultiCast, "InitializeProperties(), QueuePathName = %ls", strMsmqPath);

	if(!m_fLocalMgmt)
	{
		//
		// In MMC we will get the domain controller that is used by the MMC
		//
		ASSERT(pstrDomainController != NULL);
		m_strDomainController = *pstrDomainController;
		TrTRACE(QMultiCast, "InitializeProperties(), domain controller = %ls", m_strDomainController);
	}

	m_strName = strMsmqPath;
    
    if (0 != pstrFormatName)
    {
	    m_strFormatName = *pstrFormatName;
    }
    else
    {
        const x_dwFormatNameMaxSize = 255;
        DWORD dwSize = x_dwFormatNameMaxSize;
        HRESULT hr = MQPathNameToFormatName(strMsmqPath, m_strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
        m_strFormatName.ReleaseBuffer();
        if(FAILED(hr))
        {
            //
            // If failed, just display a message
            //
            MessageDSError(hr,IDS_OP_PATHNAMETOFORMAT, strMsmqPath);
            return(hr);
        }
    }                

    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_Q_MULTICAST_ADDRESS
    //
    pid = PROPID_Q_MULTICAST_ADDRESS;
    BOOL fFound = propMap.Lookup(pid, propVar);
	if(!fFound)
	{
		return MQ_ERROR_PROPERTY;
	}

    if (propVar.vt == VT_LPWSTR)
    {
        m_strMulticastAddress = propVar.pwszVal;
    }
    else
    {
        ASSERT(propVar.vt == VT_EMPTY);
        m_strMulticastAddress = _T("");
    }
    m_strInitialMulticastAddress = m_strMulticastAddress;
  
    return MQ_OK;
}

BOOL CQueueMulticast::IsMulticastAddressAvailable ()
{
    //
    // veriy if this property is available in AD. If not return FALSE 
    // in order DO NOT SHOW or SHOW this page GRAYED. If we decide
    // to show this page grayed it is necessary to add text box with
    // text like "This property is not available"
    //
    return TRUE;
}

void CQueueMulticast::DDV_ValidMulticastAddress(
                           CDataExchange* pDX, 
                           CString& str)
{
    if (!pDX->m_bSaveAndValidate)
        return;

    //
    // do nothing if string is empty
    //
    if (m_strMulticastAddress == _T(""))
        return;

    //
    // verify here if the new value is valid. If it is wrong
    // call MessageDSError and then return FALSE;
    //    

    MULTICAST_ID id;
    try
    {        
        LPCWSTR p = FnParseMulticastString(m_strMulticastAddress, &id);
		if(*p != L'\0')
			throw bad_format_name(p);
    }
    catch(const bad_format_name&)
    {        
        MessageDSError(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, IDS_OP_SET_MULTICAST_PROPERTY, m_strName);
        pDX->Fail();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qname.cpp ===
// QName.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "QName.h"

#include "qname.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueueName dialog


CQueueName::CQueueName(
	CString &strComputerName, 
	CString strContainerDispFormat /* = "" */, 
	BOOL fPrivate /* = FALSE */
	): 
CMqPropertyPage(CQueueName::IDD, fPrivate ? IDS_NEW_PRIVATE_QUEUE : 0),
    m_fPrivate(fPrivate),
    m_strNewPathName(_T("")),
    m_strFormatName(_T("")),
	m_strContainerDispFormat(strContainerDispFormat),
    m_hr(S_FALSE)
{
	//{{AFX_DATA_INIT(CQueueName)
	m_strQueueName = _T("");
	m_fTransactional = FALSE;
	m_strPrivatePrefix = x_strPrivatePrefix;
	//}}AFX_DATA_INIT
    if (strComputerName == TEXT(""))
    {
        //
        // Local computer
        //
		DWORD dwNameBufferSize = MAX_PATH;
		m_hr = GetComputerNameInternal(
				m_strComputerName.GetBuffer(dwNameBufferSize),
				&dwNameBufferSize);
		m_strComputerName.ReleaseBuffer();
    }
    else
    {
        m_strComputerName = strComputerName;
    }

}


void
CQueueName::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void
CQueueName::StretchPrivateLabel(
	CStatic *pPrivateTitle,
	CEdit *pQueueNameWindow
	)
{
	CString privStr;
	pPrivateTitle->GetWindowText(privStr);

	CDC* pDC = pPrivateTitle->GetDC();
	CSize textSize = pDC->GetTextExtent(privStr);
	pPrivateTitle->ReleaseDC(pDC);

	//
	// Stretch "private$\" control to fit text
	// Distract the original control size, add the text size
	//
	RECT rectPrivTitleClient;
	RECT rectPrivTitleWindow;
	pPrivateTitle->GetClientRect(&rectPrivTitleClient);
	pPrivateTitle->GetWindowRect(&rectPrivTitleWindow);
	ScreenToClient(&rectPrivTitleWindow);

	rectPrivTitleWindow.right = rectPrivTitleWindow.right - rectPrivTitleClient.right + textSize.cx;
	pPrivateTitle->MoveWindow(&rectPrivTitleWindow);

	//
	// Move queue pathname edit box
	//
	RECT rectEdit;
	pQueueNameWindow->GetWindowRect(&rectEdit);
	ScreenToClient(&rectEdit);
	
	rectEdit.left += textSize.cx;
	rectEdit.right += textSize.cx;
	pQueueNameWindow->MoveWindow(&rectEdit);
}


void CQueueName::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueueName)
	DDX_Control(pDX, IDC_PUBLIC_QUEUE_ICON, m_staticIcon);
	DDX_Text(pDX, IDC_QUEUENAME, m_strQueueName);
	DDX_Check(pDX, IDC_TRANSACTIONAL, m_fTransactional);
	DDX_Text(pDX, IDC_QNAME_PRIVATE_TITLE, m_strPrivatePrefix);
	//}}AFX_DATA_MAP
}

CString &CQueueName::GetFullQueueName()
{
    static CString strFullQueueName;
    if (m_fPrivate)
    {
        strFullQueueName = x_strPrivatePrefix + m_strQueueName;
    }
    else
    {
        strFullQueueName = m_strQueueName;
    }

    return strFullQueueName;
}

BEGIN_MESSAGE_MAP(CQueueName, CMqPropertyPage)
	//{{AFX_MSG_MAP(CQueueName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueName message handlers

BOOL CQueueName::OnInitDialog() 
{

	CMqPropertyPage::OnInitDialog();

	CStatic *pPrivateTitle = (CStatic *)GetDlgItem(IDC_QNAME_PRIVATE_TITLE);
    if (m_fPrivate)
    {
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		SetDlgItemText(IDC_QUEUE_CONTAINER, m_strComputerName);
        m_staticIcon.SetIcon(LoadIcon(g_hResourceMod, (LPCTSTR)IDI_PRIVATE_QUEUE));

		CEdit *pQueueNameWindow = (CEdit*)GetDlgItem(IDC_QUEUENAME);
		StretchPrivateLabel(pPrivateTitle, pQueueNameWindow);
		
    }
    else
    {

		CString strTitle;
		if ( m_strContainerDispFormat != L"" )
		{
			SetDlgItemText(IDC_QUEUE_CONTAINER, m_strContainerDispFormat);
		}
		else
		{
			SetDlgItemText(IDC_QUEUE_CONTAINER, m_strComputerName);
		}

		pPrivateTitle->ShowWindow(FALSE);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CQueueName::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


BOOL CQueueName::OnWizardFinish() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (0 == UpdateData(TRUE))
    {
        //
        // Update data failed
        //
        return FALSE;
    }

    m_hr = CreateEmptyQueue(
            GetFullQueueName(),
            m_fTransactional,
            m_strComputerName, 
            m_strNewPathName,
            &m_strFormatName
            );

    if(FAILED(m_hr))
    {
		if ( m_hr == MQ_ERROR_PROPERTY )
		{
			// 
			// Queue path name is the only property on this dialog - convert 
			// it just to be user friendly
			//
			m_hr = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
		}

        MessageDSError(m_hr, IDS_OP_CREATE, m_strQueueName);
        return FALSE;
    }

    return CMqPropertyPage::OnWizardFinish();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qgeneral.h ===
#if !defined(AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
#define AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QGeneral.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral dialog

class CQueueGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CQueueGeneral)

// Construction
public:
	CQueueGeneral(
		BOOL fPrivate = FALSE, 
		BOOL fLocalMgmt = FALSE
		);

	~CQueueGeneral();

    HRESULT 
	InitializeProperties(
		CString &strMsmqPath, 
		CPropMap &propMap, 
		CString* pstrDomainController, 
		CString* pstrFormatName = 0
		);

    DWORD m_dwQuota;
	DWORD m_dwJournalQuota;
	BOOL	m_fTransactional;

// Dialog Data
	//{{AFX_DATA(CQueueGeneral)
	enum { IDD = IDD_QUEUE_GENERAL };
	CStatic	m_staticIcon;
	CSpinButtonCtrl	m_spinPriority;
	CString	m_strName;
	CString	m_strLabel;
	GUID m_guidID;
	GUID m_guidTypeID;
	BOOL	m_fAuthenticated;
	BOOL	m_fJournal;
	LONG	m_lBasePriority;
	int		m_iPrivLevel;
	COleDateTime	m_dateCreateTime;
	COleDateTime	m_dateModifyTime;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CQueueGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CQueueGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnQueueMquotaCheck();
	afx_msg void OnQueueJquotaCheck();
	//}}AFX_MSG

    BOOL m_fPrivate;
    BOOL m_fLocalMgmt;

    CString m_strFormatName;
    CString m_strDomainController;

	DECLARE_MESSAGE_MAP()
};

#define MAX_BASE_PRIORITY  32678
#define MIN_BASE_PRIORITY -32678

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\resource.h ===
#include "snapres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\qname.h ===
#ifndef _NEW_QUEUE_NAME
#define _NEW_QUEUE_NAME

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QName.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueName dialog

class CQueueName : public CMqPropertyPage
{
// Construction
public:
	CQueueName(CString &strComputerName, CString m_strContainerDispFormat = L"", BOOL fPrivate=FALSE);

// Dialog Data
	//{{AFX_DATA(CQueueName)
	enum { IDD = IDD_QUEUENAME };
	CStatic	m_staticIcon;
	CString	m_strQueueName;
	BOOL	m_fTransactional;
	CString	m_strPrivatePrefix;
	//}}AFX_DATA

    CString &GetNewQueuePathName()
    {
        return m_strNewPathName;
    };

    CString &GetNewQueueFormatName()
    {
        return m_strFormatName;
    };

    HRESULT GetStatus()
    {
        return m_hr;
    };

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueueName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    CString &GetFullQueueName();
    BOOL m_fPrivate;
    CString m_strNewPathName;
    CString m_strFormatName;
    HRESULT m_hr;
    CString m_strComputerName;
	CString m_strContainerDispFormat;

	// Generated message map functions
	//{{AFX_MSG(CQueueName)
	virtual BOOL OnInitDialog();
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	void
	CQueueName::StretchPrivateLabel(
		CStatic *pPrivateTitle,
		CEdit *pQueueNameWindow
		);

private:

	CGeneralPropertySheet* m_pParentSheet;

};

const LPTSTR x_strPrivatePrefix=TEXT("private$\\");


#endif // _NEW_QUEUE_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rdmsg.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	rdmsg.h

Abstract:

	Definition CReadMsg snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __MSMQRMSG_H_
#define __MSMQRMSG_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnres.h"

#include "icons.h"
#include "message.h"

class CReadMsg : public CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >
{
public:

	DWORD   m_fAdminMode;		// Specifying or not MQ_ADMIN_ACCESS when opening a queue


    CReadMsg(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR szFormatName, LPCWSTR szComputerName): 
            CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >(pParentNode, pComponentData),
            m_szFormatName(szFormatName),
            m_szComputerName(szComputerName)
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		m_fAdminMode = 0;
	}

   	BEGIN_SNAPINCOMMAND_MAP(CReadMsg, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_RDMSG_PURGE, OnPurge)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_RDMSG_MENU)

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    
	virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

protected:
    CString m_szFormatName;     // Format name of the queue
	CString m_szComputerName;   // The computer that the queue belongs to, or "" for local computer
    virtual HRESULT OpenQueue(DWORD dwAccess, HANDLE *phQueue);

private:
	HRESULT OnPurge(bool &bHandled, CSnapInObjectRootBase * pObj);    
	void UpdateColumnWidth(const LPHEADERCTRL pHeader);    
	virtual CString GetHelpLink();
	
};


class CReadSystemMsg : public CReadMsg
{
public:
    CReadSystemMsg (CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR szFormatName, LPCWSTR szComputerName, LPCWSTR szSuffix): 
            CReadMsg(pParentNode, pComponentData, szFormatName, szComputerName),                    
            m_szSuffix(szSuffix)            
    {         
        m_ComputerGuid = GUID_NULL;
    }   
    
protected:
    virtual HRESULT OpenQueue(DWORD dwAccess, HANDLE *phQueue);  

private:
    HRESULT GetComputerGuid ();    
	virtual CString GetHelpLink();

    GUID m_ComputerGuid;
    CString m_szSuffix;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\restart.cpp ===
// Restart.cpp : implementation file
//

#include "stdafx.h"
#include "mqPPage.h"
#include "resource.h"
#include "Restart.h"

#include "restart.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRestart dialog


CRestart::CRestart(CWnd* pParent /*=NULL*/)
	: CMqDialog(CRestart::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRestart)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CRestart::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRestart)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRestart, CMqDialog)
	//{{AFX_MSG_MAP(CRestart)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRestart message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rule.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rule.cpp                                     *

Abstract:
	Implementation for rule the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/
#include "stdafx.h"
#include "autoptr.h" 

#import "mqtrig.tlb" no_namespace
#include "rule.h"

#include "rule.tmh"

using namespace std;

static CRuleSet* s_pRuleSet = NULL;

R<CRuleSet> GetRuleSet(const CString& strComputer)
{
    if (s_pRuleSet == NULL)
    {
        s_pRuleSet = new CRuleSet(strComputer);
    }

    return SafeAddRef(s_pRuleSet);
}


CRule::CRule(
    CRuleSet* pRuleSet,
    _bstr_t  id,
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) :
    m_pRuleSet(SafeAddRef(pRuleSet)),
    m_name(name),
    m_description(description),
    m_id(id),
    m_action(action),
    m_condition(condition),
    m_fShowWindow(fShowWindow)
{
}


void CRule::Update(
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) throw(_com_error)
{
    if ((name == m_name) &&
        (description == m_description) &&
        (condition == m_condition) &&
        (action == m_action) &&
        (fShowWindow == m_fShowWindow))
        return;

    m_pRuleSet->Update(
            m_id, 
            name, 
            description, 
            condition, 
            action, 
            fShowWindow
            );

    m_name = name;
    m_description =description;
    m_action = action;
    m_condition =condition;
    m_fShowWindow =fShowWindow;
}


void CRule::Update(
    _bstr_t  name
    ) throw(_com_error)
{
    m_pRuleSet->Update(
                    m_id, 
                    name, 
                    m_description, 
                    m_condition, 
                    m_action, 
                    m_fShowWindow
                    );

    m_name = name;
}


CRuleSet::CRuleSet(
     const CString& strComputer
    ) :
    m_ruleSet(L"MSMQTriggerObjects.MSMQRuleSet.1"),
    m_fChanged(false)
{
    m_ruleSet->Init(static_cast<LPCWSTR>(strComputer));
    Refresh();
}


void CRuleSet::Refresh(void)
{
    m_ruleSet->Refresh();

    long noOfRules;
    m_ruleSet->get_Count(&noOfRules);

    m_ruleList.erase(m_ruleList.begin(), m_ruleList.end());

    for(long ruleIndex = 0; ruleIndex < noOfRules; ++ruleIndex)
    {        
        BSTR ruleId = NULL;
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCondition = NULL;
        BSTR ruleAction = NULL;
        BSTR ruleProg = NULL;
        long ruleShowWindow = NULL;

        m_ruleSet->GetRuleDetailsByIndex(
                        ruleIndex,
                        &ruleId,
                        &ruleName,
                        &ruleDescription,
                        &ruleCondition,
                        &ruleAction,
                        NULL,
                        &ruleShowWindow
                        );

        R<CRule> pRule = new CRule(
                                this,
                                ruleId, 
                                ruleName, 
                                ruleDescription, 
                                ruleCondition, 
                                ruleAction,
                                (ruleShowWindow != 0)
                                );
    
        m_ruleList.push_back(pRule);
    }
}


R<CRule>
CRuleSet::AddRule(
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    long fShowWindow
)
{
    BSTR impl = NULL;
    BSTR ruleId = NULL;

    m_ruleSet->Add(
            name, 
            description, 
            condition,
            action, 
            impl,
            fShowWindow,
            &ruleId
            );

    R<CRule> pRule = new CRule(
                            this,
                            ruleId, 
                            name, 
                            description, 
                            condition, 
                            action,
                            (fShowWindow != 0)
                            );

    m_ruleList.push_back(pRule);
    return pRule;
}

    
void CRuleSet::DeleteRule(const _bstr_t& ruleId)
{
    m_ruleSet->Delete(ruleId);

    for(RuleList::iterator it = m_ruleList.begin(); it != m_ruleList.end(); ++it)
    {
        if (ruleId == (*it)->GetRuleId())
        {
            m_ruleList.erase(it);
            return;
        }
    }

    ASSERT(0);
}


void CRuleSet::Update(
    _bstr_t  ruleId, 
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) throw(_com_error)
{
    BSTR Implementation = NULL;

    m_ruleSet->Update(
                    ruleId, 
                    name, 
                    description, 
                    condition, 
                    action, 
                    Implementation, 
                    fShowWindow
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rule.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rule.h                                     *

Abstract:
	Definition for rule the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULE_H__
#define __RULE_H__

#include <Tr.h>
#include <Ref.h>
#include <autoptr.h>
#include <comdef.h>

#pragma warning(push, 3)
#include <list>
#pragma warning(pop)

class CRule;

typedef std::list< R<CRule> > RuleList;

class CRuleSet :public CReference
{
public:
    CRuleSet(const CString& strComputer);

    void Refresh(void);

    R<CRule> 
    AddRule(
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        long fShowWindow
        );

    void DeleteRule(const _bstr_t& ruleId);

    void 
    Update(
        _bstr_t  ruleid, 
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        ) throw(_com_error);

    RuleList GetRuleList(void)
    {
        return m_ruleList;
    }

private:
    IMSMQRuleSetPtr m_ruleSet;
    RuleList m_ruleList;

    bool m_fChanged;
};


class CRule : public CReference
{
public:
    CRule(
        CRuleSet* pRuleSet,
        _bstr_t  id,
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        );


    void Update(
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        ) throw(_com_error);

    
    void Update(
        _bstr_t  name
        ) throw(_com_error);


    void 
    DeleteRule(
        void
        ) throw(_com_error)
    {
        m_pRuleSet->DeleteRule(m_id);
    }


    const _bstr_t& GetRuleName(void) const
    {
        return m_name;
    }


    const _bstr_t& GetRuleDescription(void) const
    {
        return m_description;
    }


    const _bstr_t& GetRuleId(void) const
    {
        return m_id;
    }
 

    const _bstr_t& GetRuleAction(void) const
    {
        return m_action;
    }
 

    const _bstr_t& GetRuleCondition(void) const
    {
        return m_condition;
    }
 

    bool GetShowWindow(void) const
    {
        return m_fShowWindow;
    }
 

private:
    R<CRuleSet> m_pRuleSet;

    _bstr_t  m_name; 
	_bstr_t  m_description; 
    _bstr_t  m_id;
    _bstr_t  m_action;
    _bstr_t  m_condition;
    bool m_fShowWindow;
};


R<CRuleSet> GetRuleSet(const CString& strComputer);

#endif // __RULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rulecond.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rulecond.h                                     *

Abstract:
	Definition for the rule condition class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULECOND_H__
#define __RULECOND_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

#include <list>

/////////////////////////////////////////////////////////////////////////////
// CRuleCondition dialog

class CRuleParent;

class CRuleCondition : public CMqPropertyPage
{
friend class CNewRule;

// Construction
public:
	CRuleCondition(
        CRuleParent* pParentNode, 
        _bstr_t condition
        );

	CRuleCondition(
        CNewRule* pParentNode
        );


	virtual ~CRuleCondition()
    {
    }

    CString GetCondition(void) const;

// Dialog Data
	//{{AFX_DATA(CRuleCondition)
	enum { IDD_NEW = IDD_NEW_TRIGGER_RULE_COND, IDD_VIEW = IDD_TRIGGER_RULE_COND };
	CString	m_newCondValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleCondition)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleCondition)
	virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
	afx_msg void OnAddRuleConditionBTM();
	afx_msg void OnRemoveCondition();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
    class CCondition
    {
    public:
        CCondition(DWORD index, CString value) :
            m_index(index),
            m_value(value)
        {
        }
    
    public:
        DWORD m_index;
        CString m_value;
    };

private:
    static void InitConditionTypeCombo(CComboBox* pCombo);
	static CString AddEscapeCharacterToConditionValue(const CString& val);
	static CString RemoveEscapeCharacterFromConditionValue(const CString& val);

private:
    void InitConditionList(void);
    void ParseConditionStr(LPCTSTR cond);
    int GetCondTypeIndex(LPCTSTR condType);
    void DisplayConditionList(int selectedCell) const;


private:
	CListBox*	m_pRuleConditionList;
	CComboBox*	m_pConditionTypesCombo;
	CEdit*      m_pCondValueEditBox;

    R<CRuleParent> m_pParentNode;
    CNewRule* m_pNewParentNode;

    _bstr_t m_originalCondVal;
    
    std::list<CCondition> m_condValues;

    bool m_fChanged;
};



#endif //__RULECOND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\ruleact.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    ruleact.h                                     

Abstract:
	Definition for the rule action class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULEACT_H__
#define __RULEACT_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"


class CRuleResult;
class CNewRule;

const DWORD xMaxParameters = 256;

//
//
// CRuleParam dialog
//
//
class CRuleParam : public CMqDialog
{
// Construction
public:
    CRuleParam();

// Dialog Data
	//{{AFX_DATA(CRuleParam)
	enum { IDD = IDD_RULE_ACTION_PARAM };
	CString	m_literalValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRuleParam)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CRuleParam)
	afx_msg void OnParamAdd();
	afx_msg void OnParamOrderHigh();
	afx_msg void OnParmOrderDown();
	afx_msg void OnParmRemove();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeParamCombo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    void ParseInvokeParameters(LPCTSTR paramList);
    CString GetParametersList(void) const;
    
    bool IsChanged(void) const
    {
        return m_fChanged;
    }


private:
    static DWORD GetParameterTypeId(LPCTSTR param);

private:
    void Display(int selectedCell) const;

private:
    //
    // CParam is a private class that used to hold information for
    // each parameter in rule invokation list. The class hold an ID
    // of parameter type and the value. For string and number the value 
    // literal value, for the others parameters it holds parameter string
    // as it should appear in rule action string
    //
    class CParam
    {
        public:
            CParam() : m_id(0) 
            {
            }

            CParam(DWORD id, CString& value) :
              m_id(id),
              m_value(value)
            {
            }

        public:
            DWORD m_id;
            CString m_value;
    };


private:
    //
    // List of invocation parameters. Each parameter can appear multiple times
    // and they are ordered
    //
    CParam m_invokeParamArray[xMaxParameters];
    DWORD m_NoOfParams;

    CParam m_tempInvokeParam[xMaxParameters];
    DWORD m_NoOftempParams;

    //
    // Indicates if the action property was changed
    //
    bool m_fChanged;

    //
    // Pointer to dialog elements
    //
    CListBox* m_pInvokeParams;
    CComboBox* m_pParams;
};



//
//
// CRuleAction dialog
//
//

class CRuleAction : public CMqPropertyPage
{

// Construction
public:
    //
    // This constuctor is use when display rule property page and it used 
    // for display and rule update
    //
	CRuleAction(
        CRuleParent* pParentNode, 
        _bstr_t action,
        BOOL fShowWindow
        ) :
        CMqPropertyPage(CRuleAction::IDD_VIEW),
        m_pParentNode(SafeAddRef(pParentNode)),
        m_pNewParentNode(NULL),
        m_orgAction(static_cast<LPCTSTR>(action)),
        m_fShowWindow(fShowWindow),
        m_executableType(eCom),
        m_fInit(false)
    {
    }


    //
    // This constructure is called when a new rule is created
    //
	CRuleAction(
        CNewRule* pParentNode
        ) :
        CMqPropertyPage(CRuleAction::IDD_NEW, IDS_NEW_RULE_CAPTION),
        m_pParentNode(NULL),
        m_pNewParentNode(pParentNode),
        m_orgAction(_T("")),
        m_fShowWindow(false),
        m_executableType(eCom),
        m_fInit(false)
    {
    }


    ~CRuleAction();

    CString GetAction(void) const;


// Dialog Data
	//{{AFX_DATA(CRuleAction)
	enum { IDD_NEW = IDD_NEW_TRIGGER_RULE_ACTION, IDD_VIEW = IDD_TRIGGER_RULE_ACTION };
	BOOL	m_fShowWindow;
	CString	m_exePath;
	CString	m_comProgId;
	CString	m_method;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleAction)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleAction)
	virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
	afx_msg void OnInvocationSet();
	afx_msg void OnFindExeBtm();
	afx_msg void OnParamBtm();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    //
    // Invocation type COM or standalone EXE
    //
    enum EXECUTABLE_TYPE {
        eExe,
        eCom
    };

private:
	static void ParseExecutableType(LPCTSTR exeType, EXECUTABLE_TYPE* pType);

private:
	void 
    ParseActionStr(
        LPCTSTR action
        ) throw(exception);

    void SetComFields(BOOL fSet);

private:
    R<CRuleParent> m_pParentNode;
    CNewRule* m_pNewParentNode;

    CString m_orgAction;
    EXECUTABLE_TYPE m_executableType;

    CRuleParam m_ruleParam;
    bool m_fInit;
};



#endif //__RULEACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\rulecond.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruledef.cpp

Abstract:
	Implementation for the rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "localutl.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "triggen.h"
#include "newrule.h"

#include "rulecond.tmh"

using namespace std;

class CCondTypes
{
public:
    typedef bool (WINAPI* IS_VALID_VALUE_ROUTINE)(const CString& condValue);

public:
    CCondTypes(
        DWORD id,
		DWORD condShortDescrId,
        const _bstr_t& condType, 
        IS_VALID_VALUE_ROUTINE pfnIsValidValue
        ) :
        m_condTypeId(id),
		m_condShortDescrId(condShortDescrId),
        m_condType(condType),
        m_pfnIsValidValue(pfnIsValidValue)
    {
    }

public:
    DWORD m_condTypeId;
	DWORD m_condShortDescrId;
    const _bstr_t& m_condType;
    IS_VALID_VALUE_ROUTINE m_pfnIsValidValue;
};


static
bool
WINAPI
IsValidCondStringValue(
    const CString& condValue
    )
{
	DWORD NoOfQuote = 0;
	for(int quoteIndex = condValue.Find(L'\"');	 quoteIndex != -1; quoteIndex = condValue.Find(L'\"', quoteIndex + 1))
	{	
		++NoOfQuote;
	}

	if ((NoOfQuote % 2) == 0)
		return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEGAL_STRING_VALUE, condValue);

    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;

}


bool
WINAPI
IsValidNumericValue(
    const CString& condValue
    )
{
    TCHAR* pEnd;
    _tcstoul(condValue, &pEnd, 10);

    if (*pEnd == NULL)
        return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEAGL_NUMERIC_VALUE, condValue);

    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;

}


static
bool
WINAPI
IsValidPriorityValue(
    const CString& condValue
    )
{
    if (!IsValidNumericValue(condValue))
        return false;

    int priority = _ttoi(condValue);
    if ((priority >= MQ_MIN_PRIORITY) && (MQ_MAX_PRIORITY >= priority))
        return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEAGL_PRIORITY_VALUE, MQ_MIN_PRIORITY, MQ_MAX_PRIORITY);
    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;
}


static
bool
WINAPI
IsValidGuidValue(
    const CString& condValue
    )
{
    UUID temp;
    LPCTSTR pUiid = condValue;

    HRESULT hr = IIDFromString(const_cast<LPTSTR>(pUiid), &temp);
    if (hr == S_OK)
        return true;

    AfxMessageBox(IDS_ILLEAGL_SRC_MACHINE_VALUE, MB_OK | MB_ICONERROR);
    return false;
}


const CCondTypes xContionTypeIds[] = {
    CCondTypes(IDS_COND_LABEL_CONTAIN,      IDS_COND_LABEL_CONTAIN,			xConditionTypes[eMsgLabelContains],         IsValidCondStringValue), 
    CCondTypes(IDS_COND_LABEL_NOT_CONTAIN,	IDS_COND_LABEL_NOT_CONTAIN,		xConditionTypes[eMsgLabelDoesNotContain],   IsValidCondStringValue), 
    CCondTypes(IDS_COND_BODY_CONTAIN,		IDS_SHORT_COND_BODY_CONTAIN,	xConditionTypes[eMsgBodyContains],          IsValidCondStringValue), 
    CCondTypes(IDS_COND_BODY_NOT_CONTAIN,	IDS_SHORT_COND_BODY_NOT_CONTAIN,xConditionTypes[eMsgBodyDoesNotContain],    IsValidCondStringValue), 
    CCondTypes(IDS_COND_PRIORITY_EQUAL,		IDS_COND_PRIORITY_EQUAL,		xConditionTypes[ePriorityEquals],           IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_NOT_EQUAL,	IDS_COND_PRIORITY_NOT_EQUAL,	xConditionTypes[ePriorityNotEqual],         IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_GRATER,	IDS_COND_PRIORITY_GRATER,		xConditionTypes[ePriorityGreaterThan],      IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_LESS,		IDS_COND_PRIORITY_LESS,			xConditionTypes[ePriorityLessThan],         IsValidPriorityValue), 
    CCondTypes(IDS_COND_APP_EQUAL,			IDS_SHORT_COND_APP_EQUAL,		xConditionTypes[eAppspecificEquals],        IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_NOT_EQUAL,		IDS_SHORT_COND_APP_NOT_EQUAL,	xConditionTypes[eAppspecificNotEqual],      IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_GREATER,		IDS_SHORT_COND_APP_GREATER,		xConditionTypes[eAppSpecificGreaterThan],   IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_LESS,			IDS_SHORT_COND_APP_LESS,		xConditionTypes[eAppSpecificLessThan],      IsValidNumericValue), 
    CCondTypes(IDS_COND_SRCID_EQUAL,		IDS_SHORT_COND_SRCID_EQUAL,		xConditionTypes[eSrcMachineEquals],         IsValidGuidValue), 
    CCondTypes(IDS_COND_SRCID_NOT_EQUAL,	IDS_SHORT_COND_SRCID_NOT_EQUAL,	xConditionTypes[eSrcMachineNotEqual],       IsValidGuidValue), 
};


static
BOOL
IsStringTypeCondition(
	DWORD condIndex
	)
{
	ASSERT(ARRAYSIZE(xContionTypeIds) >= condIndex);

	DWORD condTypeId = xContionTypeIds[condIndex].m_condTypeId;

	if (condTypeId == IDS_COND_LABEL_CONTAIN ||
		condTypeId == IDS_COND_LABEL_NOT_CONTAIN ||
		condTypeId == IDS_COND_BODY_CONTAIN ||
		condTypeId == IDS_COND_BODY_NOT_CONTAIN )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRuleCondition property page


CRuleCondition::CRuleCondition(
    CRuleParent* pParentNode, 
    _bstr_t condition
    ) : 
    CMqPropertyPage(CRuleCondition::IDD_VIEW),
    m_pParentNode(SafeAddRef(pParentNode)),
    m_pNewParentNode(NULL),
    m_originalCondVal(condition),
    m_fChanged(false)
{
	//{{AFX_DATA_INIT(CRuleCondition)
	m_newCondValue = _T("");
	//}}AFX_DATA_INIT
}


CRuleCondition::CRuleCondition(
    CNewRule* pParentNode
    ) : 
    CMqPropertyPage(CRuleCondition::IDD_NEW, IDS_NEW_RULE_CAPTION),
    m_pParentNode(NULL),
    m_pNewParentNode(pParentNode),
    m_originalCondVal(_T("")),
    m_fChanged(false)
{
	//{{AFX_DATA_INIT(CRuleCondition)
	m_newCondValue = _T("");
	//}}AFX_DATA_INIT
}


void CRuleCondition::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleCondition)
	DDX_Text(pDX, IDC_ConditionValue, m_newCondValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuleCondition, CMqPropertyPage)
	//{{AFX_MSG_MAP(CRuleCondition)
	ON_BN_CLICKED(IDC_AddRuleCondition_BTM, OnAddRuleConditionBTM)
	ON_BN_CLICKED(IDC_RemoveCondition, OnRemoveCondition)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRuleCondition message handlers

void CRuleCondition::OnAddRuleConditionBTM() 
{
    UpdateData();

    if (m_newCondValue.IsEmpty())
    {
        AfxMessageBox(IDS_RULE_CONDITION_REQUIRED);
        GetDlgItem(IDC_ConditionValue)->SetFocus();
        return;
    }

	if (m_newCondValue.GetLength() > xMaxRuleConditionLen)
    {
        CString strError;
        strError.FormatMessage(IDS_COND_LEGTH_EXCEEDED,xMaxRuleConditionLen);
        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        GetDlgItem(IDC_ConditionValue)->SetFocus();
        return;
    }

    ASSERT(!m_newCondValue.IsEmpty());

    DWORD condTypeIndex = m_pConditionTypesCombo->GetCurSel();
    
    if(condTypeIndex == LB_ERR)
    {
        AfxMessageBox(IDS_COND_TYPE_NOT_SELECTED, MB_OK | MB_ICONERROR);
        m_pCondValueEditBox->SetFocus();

        return;
    }

    ASSERT(ARRAYSIZE(xContionTypeIds) >= condTypeIndex);

    if (! xContionTypeIds[condTypeIndex].m_pfnIsValidValue(m_newCondValue))
    {
        m_pCondValueEditBox->SetFocus();
        return;
    }

    CCondition cond(condTypeIndex, m_newCondValue);

    m_condValues.push_back(cond);

    m_fChanged = true;
    
    //
    // re display the condition list
    //
    DisplayConditionList(static_cast<int>(m_condValues.size()) - 1);

    CMqPropertyPage::OnChangeRWField();

    //
    // clear the condition value field
    //
    m_pCondValueEditBox->SetWindowText(_T(""));
}


void CRuleCondition::InitConditionTypeCombo(CComboBox*	pCombo)
{
    for (DWORD i = 0; i < ARRAYSIZE(xContionTypeIds); ++i)
    {
        CString condType;
        condType.Format(xContionTypeIds[i].m_condTypeId);

        pCombo->InsertString(i, condType);
    }
}


void CRuleCondition::InitConditionList(void)
{    
    ParseConditionStr(m_originalCondVal);
    DisplayConditionList(0);
}


void CRuleCondition::DisplayConditionList(int selectedCell) const
{
    //
    // Clear the list box before adding a list of condition
    //
    m_pRuleConditionList->ResetContent();

    DWORD index = 0;
    for(list<CCondition>::iterator it = m_condValues.begin(); it != m_condValues.end(); ++it, ++index)
    {
		int condListIndex = (*it).m_index;

        CString strCondType;
        strCondType.Format(xContionTypeIds[condListIndex].m_condShortDescrId);

		
		CString strValue = (*it).m_value;

		if ( IsStringTypeCondition(condListIndex) )
		{
			strValue = L"\"" + strValue + L"\"";
		}

        
		CString strCondIteam;
        if (index != (m_condValues.size() - 1))
        {
            strCondIteam.FormatMessage(IDS_COND_ITEAM, strCondType, strValue);
        }
        else
        {
            strCondIteam.FormatMessage(IDS_LAST_COND_ITEAM, strCondType, strValue);
        }

        m_pRuleConditionList->InsertString(index, strCondIteam);
    }

	//
	// Check that the sellected cell isn't out of the list boundray
	//
	if (selectedCell >= m_pRuleConditionList->GetCount())
	{	  
		selectedCell = m_pRuleConditionList->GetCount() - 1;
	}	  
	m_pRuleConditionList->SetCurSel(selectedCell);

	SetScrollSizeForList(m_pRuleConditionList);
}


BOOL CRuleCondition::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Initialize pointer to ListBox
    //
    m_pRuleConditionList = (CListBox *)GetDlgItem(IDC_RULECOND_LIST);
    m_pConditionTypesCombo = (CComboBox *)GetDlgItem(IDC_RULE_COND_TYPES);
	m_pCondValueEditBox = (CEdit*)GetDlgItem(IDC_ConditionValue);

    //               `
    // Clear the conditon value
    //
    m_pCondValueEditBox->SetWindowText(_T(""));
    InitConditionTypeCombo(m_pConditionTypesCombo);
    InitConditionList();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

}


int CRuleCondition::GetCondTypeIndex(LPCTSTR condType)
{
    for (DWORD i = 0; i < ARRAYSIZE(xContionTypeIds); ++i)
    {
        if (xContionTypeIds[i].m_condType == _bstr_t(condType))
            return i;
    }

    return -1;
}


void CRuleCondition::ParseConditionStr(LPCTSTR strCond)
{
	while (strCond != NULL)
	{
		//
		// Get condition type
		//
		CString condType = GetToken(strCond, xConditionValueDelimiter);
		if (condType.IsEmpty())
			break;

		//
		// skip delimeter
		//
		if (*strCond != NULL)
		{
			++strCond;
		}

		//
		// Get condition value
		//
		CString condValue = GetToken(strCond, xConditionDelimiter);

		DWORD condIndex = GetCondTypeIndex(condType);
		if ((condValue.IsEmpty()) || (condIndex == -1))
		{
			AfxMessageBox(IDS_ILLEAGL_CONDITION);
			return;
		}

		CCondition cond(condIndex, RemoveEscapeCharacterFromConditionValue(condValue));
		m_condValues.push_back(cond);

		//
		// Skip condition delimeter
		//
		if (*strCond != NULL)
		{
			++strCond;
		}
	}
}


CString CRuleCondition::AddEscapeCharacterToConditionValue(const CString& val)
{
	LPCWSTR pStart = val;

	CString token;
	LPCWSTR p = pStart;
	LPCWSTR pEnd;

	for(;;)
	{
		pEnd = wcschr(p, xConditionValueDelimiter);

		if (pEnd == NULL)
		{
			token += pStart;
			return token;
		}

		//
		// Check that this is a valid delimeter
		// 
		if((pStart != pEnd) && (*(pEnd - 1) == L'\\'))
		{
			p = pEnd + 1;
			continue;
		}
	
		//
		// Test, we are not in exiting a quoted item
		//
		DWORD NoOfQuote = 0;
		LPCWSTR pQuote;
		for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
		{	
			++NoOfQuote;
			++pQuote;
		}

		if ((NoOfQuote % 2) == 1)
		{
			p = wcschr(pEnd + 1, L'\"');
			if (p == NULL)
				throw exception();
			continue;
		}

		//
		// copy the token and insert it to token list 
		// 
		DWORD len = static_cast<DWORD>(pEnd - pStart);
		token += CString(pStart, len);
		token += L'\\';
		token += xConditionValueDelimiter;

		pStart = p = pEnd + 1;
	}
}


CString CRuleCondition::RemoveEscapeCharacterFromConditionValue(const CString& val)
{
	LPCWSTR pStart = val;

	CString token;
	LPCWSTR p = pStart;
	LPCWSTR pEnd;

	for(;;)
	{
		pEnd = wcschr(p, xConditionValueDelimiter);

		if (pEnd == NULL)
		{
			token += pStart;
			return token;
		}

		//
		// Test, we are not in exiting a quoted item
		//
		DWORD NoOfQuote = 0;
		LPCWSTR pQuote;
		for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
		{	
			++NoOfQuote;
			++pQuote;
		}

		if ((NoOfQuote % 2) == 1)
		{
			p = wcschr(pEnd + 1, L'\"');
			if (p == NULL)
				throw exception();
			continue;
		}

		//
		// Check that this is a valid delimeter
		// 
		if((pStart != pEnd) && (*(pEnd - 1) == L'\\'))
		{
			DWORD len = static_cast<DWORD>(pEnd - pStart - 1);
			token += CString(pStart, len);
			token += xConditionValueDelimiter;
		}
	
		pStart = p = pEnd + 1;
	}
}


CString CRuleCondition::GetCondition(void) const
{
    if (!m_fChanged)
        return static_cast<LPCTSTR>(m_originalCondVal);

    //
    // Build rule condition string
    //
    CString strCond;

    for(list<CCondition>::iterator it = m_condValues.begin(); it != m_condValues.end(); ++it)
    {
        //
        // for each value in rhe map, build 'condition=value\t"
        //
        LPCTSTR condType = xContionTypeIds[it->m_index].m_condType;
        strCond += condType;
        strCond += xConditionValueDelimiter;
        strCond += AddEscapeCharacterToConditionValue(it->m_value);
        strCond += xConditionDelimiter;
    }
    
    return strCond;
}


BOOL CRuleCondition::OnApply() 
{
    try
    {
	    m_pParentNode->OnRuleApply();

        m_originalCondVal = static_cast<LPCTSTR>(GetCondition());
        m_fChanged = false;

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}


void CRuleCondition::OnRemoveCondition() 
{
    int nIndex = m_pRuleConditionList->GetCurSel();
	int selectedCell = nIndex;
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_CONDITION_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }
    

    for(list<CCondition>::iterator it = m_condValues.begin(); nIndex > 0; ++it, --nIndex)
    {
        NULL;
    }
    m_condValues.erase(it);

    m_fChanged = true;

    //
    // re display the condition list
    //
    DisplayConditionList(selectedCell);

    CMqPropertyPage::OnChangeRWField();
}


BOOL CRuleCondition::OnSetActive() 
{
    if (m_pNewParentNode == NULL)
        return TRUE;

    return m_pNewParentNode->SetWizardButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\restart.h ===
// Restart.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRestart dialog

class CRestart : public CMqDialog
{
// Construction
public:
	CRestart(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRestart)
	enum { IDD = IDD_RESTART };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRestart)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRestart)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\ruleact.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruleact.cpp

Abstract:
	Implementation for the rule action definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "localutl.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"
#include "mqcast.h"
#include <cderr.h>

#include "ruleact.tmh"

static
bool
IsValidNumericValue(
    const CString& value
    )

{
    TCHAR* pEnd;
    _tcstoul(value, &pEnd, 10);

    if (*pEnd == NULL)
        return true;

    return false;
}


//
// CInvokeParam - used to hold parameter information. For each valid parameter we
// hold its string ID in string table and its enumeration value
// 
class CInvokeParam
{
public:
    CInvokeParam(
        DWORD id, 
        eInvokeParameters paramIndex 
        ) :
        m_paramTableStringId(id),
        m_paramIndex(paramIndex)
    {
    }

public:
    DWORD m_paramTableStringId;
    eInvokeParameters m_paramIndex;
};


const CInvokeParam xParameterTypeIds[] = {
    CInvokeParam(IDS_MSG_ID_PARAM,             eMsgId),
    CInvokeParam(IDS_MSG_LABEL_PARAM,          eMsgLabel),
    CInvokeParam(IDS_MSG_BODY_PARAM,           eMsgBody),
    CInvokeParam(IDS_MSG_BODY_STR_PARAM,       eMsgBodyAsString),
    CInvokeParam(IDS_MSG_PREIORITY_PARAM,      eMsgPriority),
    CInvokeParam(IDS_MSG_ARRIVED_TIME_PARAM,   eMsgArrivedTime),
    CInvokeParam(IDS_MSG_SENT_TIME_PARAM,      eMsgSentTime),
    CInvokeParam(IDS_MSG_CORRELATION_PARAM,    eMsgCorrelationId),
    CInvokeParam(IDS_MSG_APP_PARAM,            eMsgAppspecific),
    CInvokeParam(IDS_MSG_QUEUE_PN_PARAM,       eMsgQueuePathName),
    CInvokeParam(IDS_MSG_QUEUE_FN_PARAM,       eMsgQueueFormatName),
    CInvokeParam(IDS_MSG_RESP_QUEUE_PARAM,     eMsgRespQueueFormatName),
    CInvokeParam(IDS_MSG_ADMIN_QUEUE_PARAM,    eMsgAdminQueueFormatName),
    CInvokeParam(IDS_MSG_SRC_MACHINE_PARAM,    eMsgSrcMachineId),
    CInvokeParam(IDS_MSG_LOOKUP_ID,            eMsgLookupId),
    CInvokeParam(IDS_TRIGGER_NAME_PARAM,       eTriggerName),
    CInvokeParam(IDS_TRIGGER_ID_PARAM,         eTriggerId),
    CInvokeParam(IDS_STRING_PARAM,             eLiteralString),
    CInvokeParam(IDS_NUM_PARAM,                eLiteralNumber),
};


/////////////////////////////////////////////////////////////////////////////
// CRuleParam dialog


CRuleParam::CRuleParam() :
    CMqDialog(CRuleParam::IDD),
    m_NoOftempParams(0),
    m_NoOfParams(0),
    m_fChanged(false),
    m_pInvokeParams(NULL),
    m_pParams(NULL)
{
	//{{AFX_DATA_INIT(CRuleParam)
	m_literalValue = _T("");
	//}}AFX_DATA_INIT
}


void CRuleParam::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleParam)
	DDX_Text(pDX, IDC_LITERAL_PARAM, m_literalValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuleParam, CMqDialog)
	//{{AFX_MSG_MAP(CRuleParam)
	ON_BN_CLICKED(IDB_PARAM_ADD, OnParamAdd)
	ON_BN_CLICKED(IDB_PARAM_ORDER_UP, OnParamOrderHigh)
	ON_BN_CLICKED(IDB_PARM_ORDER_DOWN, OnParmOrderDown)
	ON_BN_CLICKED(IDB_PARM_REMOVE, OnParmRemove)
	ON_CBN_SELCHANGE(IDC_PARAM_COMBO, OnSelchangeParamCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRuleParam message handlers

void CRuleParam::OnParamAdd() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (ARRAYSIZE(m_invokeParamArray) == m_NoOftempParams)
    {
        CString strError;
        strError.FormatMessage(IDS_PARAM_NO_EXEEDED, ARRAYSIZE(m_invokeParamArray));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);
        return;
    }
    //
    // Add the new parameter at the end of invokation parameter list
    //
    DWORD paramIndex = static_cast<DWORD>(m_pParams->GetItemData(nIndex));
    DWORD paramId = xParameterTypeIds[paramIndex].m_paramTableStringId;

    if ((paramId == IDS_STRING_PARAM) ||
        (paramId == IDS_NUM_PARAM))
    {
        UpdateData();

        if (m_literalValue.IsEmpty())
        {
            AfxMessageBox(IDS_LITERAL_VALUE_REQUIRES, MB_OK | MB_ICONERROR);
            return;
        }

        if (paramId == IDS_NUM_PARAM)
        {
            //
            // Check parameter validity
            //
            if (!IsValidNumericValue(m_literalValue))
            {
                CString strError;
                strError.FormatMessage(IDS_ILLEGAL_NUMERIC_VALUE, m_literalValue);

                AfxMessageBox(strError, MB_OK | MB_ICONERROR);
                return;
            }
        }

        if ((paramId == IDS_STRING_PARAM) &&
            (m_literalValue[0] != _T('"')))
        {
            m_literalValue = _T('"') + m_literalValue + _T('"');
        }

        m_tempInvokeParam[m_NoOftempParams] = CParam(paramId, m_literalValue);
    }
    else
    {
        eInvokeParameters paramType = xParameterTypeIds[paramIndex].m_paramIndex;
        CString strParam = static_cast<LPCTSTR>(xIvokeParameters[paramType]);

        m_tempInvokeParam[m_NoOftempParams] = CParam(paramId, strParam);
    }

    ++m_NoOftempParams;        
    Display(m_NoOftempParams - 1);

    m_fChanged = true;
}


void CRuleParam::OnParmRemove() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
	int selectedCell = nIndex;

    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    //
    // remove the parameter from invoke parameter list. 
    //
    for (DWORD i = nIndex; i < m_NoOftempParams - 1; ++i)
    {
        m_tempInvokeParam[i] = m_tempInvokeParam[i + 1];
    }

    --m_NoOftempParams;

    Display(selectedCell);

    m_fChanged = true;
}


void CRuleParam::OnParamOrderHigh() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (nIndex == 0)
        return;

    //
    // Change order in invoke parameter list
    //
    CParam temp = m_tempInvokeParam[nIndex -1];
    m_tempInvokeParam[nIndex - 1] = m_tempInvokeParam[nIndex];
    m_tempInvokeParam[nIndex] = temp;

    Display(nIndex - 1);

    m_fChanged = true;
}



void CRuleParam::OnParmOrderDown() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (numeric_cast<DWORD>(nIndex) == (m_NoOftempParams - 1))
        return;

    //
    // Change order in invoke parameter list
    //
    CParam temp = m_tempInvokeParam[nIndex];
    m_tempInvokeParam[nIndex] = m_tempInvokeParam[nIndex + 1];
    m_tempInvokeParam[nIndex + 1] = temp;

    Display(nIndex + 1);

    m_fChanged = true;
}


void CRuleParam::Display(int selectedCell) const
{
    //
    // Clear the list box before adding a list of condition
    //
    m_pInvokeParams->ResetContent();

    for(DWORD i = 0; i < m_NoOftempParams; ++i)
    {
        CString strParam;
        if ((m_tempInvokeParam[i].m_id == IDS_STRING_PARAM) ||
            (m_tempInvokeParam[i].m_id == IDS_NUM_PARAM))
        {
            strParam = m_tempInvokeParam[i].m_value;
        }
        else
        {
            strParam.FormatMessage(m_tempInvokeParam[i].m_id);
        }

        m_pInvokeParams->InsertString(i, strParam);
        m_pInvokeParams->SetItemData(i, i);
    }


	//
	// Check that the sellected cell isn't out of the list boundray
	//
	if (selectedCell >= m_pInvokeParams->GetCount())
	{	  
		selectedCell = m_pInvokeParams->GetCount() - 1;
	}	  
    m_pInvokeParams->SetCurSel(selectedCell);
}


BOOL CRuleParam::OnInitDialog() 
{
    m_pInvokeParams = static_cast<CListBox*>(GetDlgItem(IDC_INVOKE_PARMETER_LIST));
    m_pParams = static_cast<CComboBox*>(GetDlgItem(IDC_PARAM_COMBO));

    //
    // Set the temporary array according the latest values
    //
    for (DWORD i = 0; i < m_NoOfParams; ++i)
    {
        m_tempInvokeParam[i] = m_invokeParamArray[i];
    }

    m_NoOftempParams = m_NoOfParams;

    //
    // Disable literal edit box
    //
    GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(FALSE);

    //
    // Add parameters types to combox
    //
    for(DWORD i = 0; i < ARRAYSIZE(xParameterTypeIds); ++i)
    {
        CString strParam;
        strParam.FormatMessage(xParameterTypeIds[i].m_paramTableStringId);

        m_pParams->InsertString(i, strParam);
        m_pParams->SetItemData(i, i);
    }

    //
    // Display list of parameters and selected parameters
    //
    Display(0);

	CMqDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


DWORD CRuleParam::GetParameterTypeId(LPCTSTR param)
{
    for(DWORD i = 0; i < ARRAYSIZE(xParameterTypeIds); ++i)
    {
		eInvokeParameters paramIndex = xParameterTypeIds[i].m_paramIndex;

		if ((paramIndex == eLiteralString) || (paramIndex == eLiteralNumber))
			continue;

        if (xIvokeParameters[paramIndex] == static_cast<_bstr_t>(param))
            return xParameterTypeIds[i].m_paramTableStringId;
    }

    if ((param[0] == _T('"')) && (param[_tcslen(param) - 1] == _T('"')))
        return IDS_STRING_PARAM;

    if (IsValidNumericValue(param))
        return IDS_NUM_PARAM;

    throw exception();
}


void CRuleParam::ParseInvokeParameters(LPCTSTR p)
{
    //
    // Parse the program parameters
    //
    for(;;)
    {
        CString token = GetToken(p, xActionDelimiter);
        if (token.IsEmpty())
            break;
        
        DWORD paramId = GetParameterTypeId(token);
        
        m_invokeParamArray[m_NoOfParams] = CParam(paramId, token);
        ++m_NoOfParams;
    }
}


CString CRuleParam::GetParametersList(void) const
{
    CString paramList;

    for (DWORD i = 0; i < m_NoOfParams; ++i)
    {
        paramList += m_invokeParamArray[i].m_value;
        paramList += xActionDelimiter;
    }

    return paramList;
}


void CRuleParam::OnSelchangeParamCombo() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pParams->GetCurSel();
    if (nIndex == LB_ERR)
        return;

    DWORD paramIndex = static_cast<DWORD>(m_pParams->GetItemData(nIndex));
    
    if ((xParameterTypeIds[paramIndex].m_paramTableStringId == IDS_STRING_PARAM) ||
        (xParameterTypeIds[paramIndex].m_paramTableStringId == IDS_NUM_PARAM))
    {
        GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(TRUE);
		return;
    }
    
	//
	// Disable literal window when non literal parameter is selected
	//
	GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(FALSE);
}


void CRuleParam::OnOK()
{
    for (DWORD i = 0; i < m_NoOftempParams; ++i)
    {
        m_invokeParamArray[i] = m_tempInvokeParam[i];
    }

    m_NoOfParams = m_NoOftempParams;

    CMqDialog::OnOK();

}


//
//
//
void CRuleAction::ParseActionStr(LPCTSTR p) throw (exception)
{
    CString token = GetToken(p, xActionDelimiter);

    //
    // First token is mandatory and it specifies the executable type, COM or EXE
    //
    if (token.IsEmpty())
        throw exception();

    ParseExecutableType(token, &m_executableType);

    //
    // Second token is manadatory and for COM object it identifies the PROGID
    // while for EXE it specifies the exe path;
    //
    token = GetToken(p, xActionDelimiter);
    if (token.IsEmpty())
        throw exception();

    if (m_executableType == eExe)
    {
        m_exePath = token;
    }
    else
    {
        m_comProgId = token;

        //
        // Third token specifies the method name to invoke
        // 
        token = GetToken(p, xActionDelimiter);
        if (token.IsEmpty())
            throw exception();

        m_method = token;
    }

    m_ruleParam.ParseInvokeParameters(p);
}

 
void 
CRuleAction::ParseExecutableType(
    LPCTSTR exeType, 
    EXECUTABLE_TYPE *pType
    ) throw(exception)
{
    ASSERT(_T('C') == xCOMAction[0]);
    ASSERT(_T('E') == xEXEAction[0]);

    //
    //  accelarate token recognition by checking 3rd character
    //
    switch(_totupper(exeType[0]))
    {
        //  pUblic
        case _T('C'):
            if(_tcsncicmp(exeType, xCOMAction, STRLEN(xCOMAction)) == 0)
            {
                *pType = eCom;
                return;
            }

            break;

        case L'E':
            if(_tcsncicmp(exeType, xEXEAction, STRLEN(xEXEAction)) == 0)
            {
                *pType = eExe;
                return;
            }

            break;
            
        default:
            break;
    }

    throw exception();
}

/////////////////////////////////////////////////////////////////////////////
// CRuleAction property page

CRuleAction::~CRuleAction()
{
}

void CRuleAction::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleAction)
	DDX_Check(pDX, IDC_SHOW_WINDOW, m_fShowWindow);
	DDX_Text(pDX, IDC_EXE_PATH, m_exePath);
	DDX_Text(pDX, IDC_COMPONENT_PROGID, m_comProgId);
	DDX_Text(pDX, IDC_COMMETHOD_NAME, m_method);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuleAction, CMqPropertyPage)
	//{{AFX_MSG_MAP(CRuleAction)
	ON_BN_CLICKED(IDC_INVOKE_EXE, OnInvocationSet)
	ON_BN_CLICKED(IDC_INVOKE_COM, OnInvocationSet)
	ON_BN_CLICKED(IDC_FIND_EXE_BTM, OnFindExeBtm)
	ON_BN_CLICKED(IDC_PARAM_BTM, OnParamBtm)
	ON_EN_CHANGE(IDC_COMPONENT_PROGID, OnChangeRWField)
	ON_EN_CHANGE(IDC_COMMETHOD_NAME, OnChangeRWField)
	ON_EN_CHANGE(IDC_EXE_PATH, OnChangeRWField)
	ON_BN_CLICKED(IDC_SHOW_WINDOW, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRuleAction message handlers


void CRuleAction::SetComFields(BOOL fSet)
{
    //
    // Disable EXE input
    //
    GetDlgItem(IDC_EXE_PATH)->EnableWindow(!fSet);
    GetDlgItem(IDC_FIND_EXE_BTM)->EnableWindow(!fSet);
    GetDlgItem(IDC_SHOW_WINDOW)->EnableWindow(!fSet);

    //
    // Enable COM input
    //
    GetDlgItem(IDC_COMPONENT_PROGID)->EnableWindow(fSet);
    GetDlgItem(IDC_COMMETHOD_NAME)->EnableWindow(fSet);
}

void CRuleAction::OnInvocationSet() 
{
    CMqPropertyPage::OnChangeRWField();

    if (((CButton*)GetDlgItem(IDC_INVOKE_EXE))->GetCheck() == TRUE)
    {
        SetComFields(FALSE);
        m_executableType = eExe;
    }

    if (((CButton*)GetDlgItem(IDC_INVOKE_COM))->GetCheck() == TRUE)
    {
        SetComFields(TRUE);
        m_executableType = eCom;
    }
}


BOOL CRuleAction::OnInitDialog() 
{
    if (!m_orgAction.IsEmpty())
    {
        try
        {
            ParseActionStr(m_orgAction);
        }
        catch (const exception&)
        {
            AfxMessageBox(IDS_BAD_RULE_ACTION);

            m_executableType = eCom;
            m_method = _TCHAR("");
            m_comProgId = _TCHAR("");
            m_exePath = _TCHAR("");
        }
    }
                
    CFont font;
    font.CreatePointFont(180, _T("Arial"));
    GetDlgItem(IDC_FIND_EXE_BTM)->SetFont(&font);

    if (m_executableType == eCom)
    {
        ((CButton*)GetDlgItem(IDC_INVOKE_COM))->SetCheck(TRUE);
        SetComFields(TRUE);
    }
    else
    {
        ((CButton*)GetDlgItem(IDC_INVOKE_EXE))->SetCheck(TRUE);
        SetComFields(FALSE);
    }

    m_fInit = true;
    CMqPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CRuleAction::OnFindExeBtm() 
{
	CString strCurrentPath;
	GetDlgItemText(IDC_EXE_PATH, strCurrentPath);

    CFileDialog	 fd(
                    TRUE, 
                    NULL, 
                    strCurrentPath, 
                    OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST, 
                    _T("Executable Files (*.exe)|*.exe|All Files (*.*)|*.*||")
                    );

    if (fd.DoModal() == IDOK)
    {
        SetDlgItemText(IDC_EXE_PATH, fd.GetPathName());
        CMqPropertyPage::OnChangeRWField();
		return;
    }

	DWORD dwErr = CommDlgExtendedError();
	if (dwErr == FNERR_INVALIDFILENAME)
	{
		//
		// If file name was invlaid, try again with empty initial path.
		// Invalid path name is usually a string with illegal characters <> ":|/\
		// This one should not fail.
		//
		CFileDialog	 fd(
						TRUE, 
						NULL, 
						L"", 
						OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST, 
						_T("Executable Files (*.exe)|*.exe|All Files (*.*)|*.*||")
						);

		if (fd.DoModal() == IDOK)
		{
			SetDlgItemText(IDC_EXE_PATH, fd.GetPathName());
			CMqPropertyPage::OnChangeRWField();
		}
	}

}


void CRuleAction::OnParamBtm() 
{
    if ((m_ruleParam.DoModal() == IDOK) &&
        (m_ruleParam.IsChanged()))
    {
        CMqPropertyPage::OnChangeRWField();
    }
}


CString CRuleAction::GetAction(void) const
{
    if (!m_fInit)
        return static_cast<LPCTSTR>(m_orgAction);

    CString paramList;    
    if (m_executableType == eCom)
    {
        paramList += xCOMAction;
        paramList += xActionDelimiter;

        paramList += m_comProgId;
        paramList += xActionDelimiter;

        paramList += m_method;
        paramList += xActionDelimiter;
    }
    else
    {
        paramList += xEXEAction;
        paramList += xActionDelimiter;

        paramList += m_exePath;
        paramList += xActionDelimiter;
    }

    paramList += m_ruleParam.GetParametersList();
    
    return paramList;
}


BOOL CRuleAction::OnApply() 
{
    UpdateData();

	//
	// remove leading space
	//
	m_exePath.TrimLeft();
	m_comProgId.TrimLeft();
	m_method.TrimLeft();

    if ((m_exePath.IsEmpty()) &&
        (m_comProgId.IsEmpty() || m_method.IsEmpty()))
    {
        AfxMessageBox(IDS_ILLEGAL_INVOCE, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    try
    {
	    m_pParentNode->OnRuleApply();

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}


BOOL CRuleAction::OnSetActive() 
{
    if (m_pNewParentNode == NULL)
        return TRUE;

    return m_pNewParentNode->SetWizardButtons();
}


BOOL CRuleAction::OnWizardFinish()
{
    //
    // We reach here only when creating a new rule
    //
    ASSERT(m_pNewParentNode != NULL);
    
    UpdateData();

	//
	// remove leading space
	//
	m_exePath.TrimLeft();
	m_comProgId.TrimLeft();
	m_method.TrimLeft();

    if ((m_exePath.IsEmpty()) &&
        (m_comProgId.IsEmpty() || m_method.IsEmpty()))
    {
        AfxMessageBox(IDS_ILLEGAL_INVOCE, MB_OK | MB_ICONERROR);
        return FALSE;                           
    }   
       
    try
    {
        m_pNewParentNode->OnFinishCreateRule();
        return TRUE;
    }
    catch(const _com_error& e)
    {
		DisplayErrorFromCOM(IDS_NEW_RULE_FAILED, e);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\service.cpp ===
#include <stdafx.h>

//#include "cpldef.h"
#include <winsvc.h>
//#include "ctlpnl.h"
#include <mqtypes.h>
#include <_mqdef.h>
/*
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif
*/
#include <_registr.h>
#include <tlhelp32.h>
#include "localutl.h"
#include "globals.h"
#include "autorel.h"
#include "autorel2.h"
#include "mqtg.h"
#include "acioctl.h"
#include "acdef.h"
#include "acapi.h"

#include "service.tmh"

#define MQQM_SERVICE_FILE_NAME  TEXT("mqsvc.exe")
#define MQDS_SERVICE_NAME       TEXT("MQDS")

#define WAIT_INTERVAL	50
#define MAX_WAIT_FOR_SERVICE_TO_STOP	5*60*1000  // 5 minutes


static
BOOL
DisplayErrorInternal(DWORD dwErrorCode, LPCWSTR szParameter, BOOL fRetry)
{
    CString strError;
    CString strMessage;   

    GetLastErrorText(strError);

	if ( szParameter != NULL )
	{
		strMessage.FormatMessage(dwErrorCode, szParameter, strError);
	}
	else
	{
		strMessage.FormatMessage(dwErrorCode, strError);
	}

	if ( fRetry )
	{
		return (AfxMessageBox(strMessage, MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDRETRY);
	}

    AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
	return FALSE;
}


static
BOOL
DisplayErrorWithRetry(DWORD dwErrorCode, LPCWSTR szParameter)
{
	return DisplayErrorInternal(dwErrorCode, szParameter, TRUE);
}


static
void
DisplayError(DWORD dwErrorCode)
{
	DisplayErrorInternal(dwErrorCode, NULL, FALSE);
}


static
BOOL
GetServiceAndScmHandles(
    SC_HANDLE *phServiceCtrlMgr,
    SC_HANDLE *phService,
    DWORD dwAccessType)
{
    *phServiceCtrlMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (*phServiceCtrlMgr == NULL)
    {
        DisplayError(IDS_SERVICE_MANAGER_PRIVILEGE_ERROR);

        return FALSE;
    }

    *phService = OpenService(*phServiceCtrlMgr, MQQM_SERVICE_NAME, dwAccessType);
    if (*phService == NULL)
    {
        DisplayError(IDS_SERVICE_PRIVILEGE_ERROR);

        CloseServiceHandle(*phServiceCtrlMgr);
        return FALSE;
    }
    return TRUE;
}


static
BOOL
AskUserIfStopServices(
	LPENUM_SERVICE_STATUS lpServiceStruct,
	DWORD nServices
	)
{
	CString strServicesList;
	UINT numOfDepServices = 0;
	//
	// Build a list of all active dependent services
	// Write each one at new line
	//
	for ( DWORD i = 0; i < nServices; i ++ )
	{
		if ( (_wcsicmp(lpServiceStruct[i].lpServiceName, xDefaultTriggersServiceName) == 0) ||
			 (_wcsicmp(lpServiceStruct[i].lpServiceName, MQDS_SERVICE_NAME) == 0) )
		{
			continue;
		}

		strServicesList += "\n";
		strServicesList += "\"";
		strServicesList += lpServiceStruct[i].lpDisplayName;
		strServicesList += "\"";
		
		numOfDepServices++;
	}

	if ( numOfDepServices == 0 )
	{
		return TRUE;
	}

	CString strMessage;
	strMessage.FormatMessage(IDS_DEP_SERVICES_LIST, strServicesList);
	return ( AfxMessageBox(strMessage, MB_OKCANCEL) == IDOK );
}


static
BOOL
WaitForServiceToStop(
	SC_HANDLE hService
	)
{
	DWORD dwWait = 0;

	for (;;)
	{
		SERVICE_STATUS ServiceStatus;
		if (!QueryServiceStatus(hService, &ServiceStatus))
		{
			//
			//  indication here is not helpful for the user.
			//
			return FALSE;
		}

		if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
		{
			return TRUE;
		}
		
		if ( dwWait > MAX_WAIT_FOR_SERVICE_TO_STOP )
		{
			//
			// If this routine fails, and error message will be displayed.
			// The routine that displays the message does GetLastError()
			// In this case we need to specify what happened.
			//
			SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
			return FALSE;
		}

		Sleep(WAIT_INTERVAL);
		dwWait += WAIT_INTERVAL;
	}
}


static
BOOL
StopSingleDependentService(
	SC_HANDLE hServiceMgr,
	LPCWSTR pszServiceName
	)	
{
	CServiceHandle hService( OpenService(
								hServiceMgr, 
								pszServiceName, 
								SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS
								) );	
	if (hService == 0)
	{
		return FALSE;
	}

	SERVICE_STATUS ServiceStatus;
	BOOL fRet = ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);

	if ( !fRet && GetLastError() != ERROR_SERVICE_NOT_ACTIVE)
	{
		return FALSE;
	}

	//
	// Wait untill state = SERVICE_STOPPED
	//
	fRet = WaitForServiceToStop(hService);

	return fRet;
}


//
// StopDependentServices
//
// This function stops all services dependent on MSMQ. 
// Enumeration of dependent services gives a list in descending
// degree of depedency. Stopping the services in order that the 
// enumeration gives will not cause dependency clashes.
//
static
BOOL
StopDependentServices(
	SC_HANDLE hServiceMgr,
	SC_HANDLE hService,
	CWaitCursor& wc
	)
{
	DWORD dwBytesNeeded, nServices;

	//
	// Try to find out how much memory is needed for data
	//
	BOOL fRet = EnumDependentServices(
					hService,
					SERVICE_ACTIVE,
					NULL,
					0,
					&dwBytesNeeded,
					&nServices
					);

	//
	// Zero dependent services
	//
	if ( fRet )
	{
		return TRUE;
	}

	if ( !fRet && GetLastError() != ERROR_MORE_DATA )
	{
		DisplayError(IDS_STOP_SERVICE_ERROR);
		return FALSE;
	}

	AP<ENUM_SERVICE_STATUS> lpServiceStruct = reinterpret_cast<LPENUM_SERVICE_STATUS>(new BYTE[dwBytesNeeded]);
	DWORD dwBuffSize = dwBytesNeeded;

	//
	// Get all the data
	//
	if ( !EnumDependentServices(
					hService,
					SERVICE_ACTIVE,
					lpServiceStruct,
					dwBuffSize,
					&dwBytesNeeded,
					&nServices
					) )
	{
		DisplayError(IDS_STOP_SERVICE_ERROR);
		return FALSE;
	}

	//
	// Ask user if it is OK to stop all dependent services
	//
	if ( !AskUserIfStopServices(lpServiceStruct, nServices))
	{
		return FALSE;
	}

	wc.Restore();

	for ( DWORD i = 0; i < nServices; i ++ )
	{
		for(;;)
		{
			fRet = StopSingleDependentService(
							hServiceMgr, 
							lpServiceStruct[i].lpServiceName
							);
			if ( !fRet )
			{
				BOOL fRetry = DisplayErrorWithRetry(IDS_STOP_SERVICE_ERR, lpServiceStruct[i].lpDisplayName);
				
				//
				// User asked for retry
				//
				if (fRetry)
				{
					wc.Restore();
					continue;
				}

				return FALSE;
			}

			break;
		}
	}

	return TRUE;	
}


//
// See whether the service is running.
//
BOOL
GetServiceRunningState(
    BOOL *pfServiceIsRunning)
{
    SC_HANDLE hServiceCtrlMgr;
    SC_HANDLE hService;

    //
    // Get a handle to the service.
    //
    if (!GetServiceAndScmHandles(&hServiceCtrlMgr,
                             &hService,
                             SERVICE_QUERY_STATUS))
    {
        return FALSE;
    }

	//
	// Automatic wrappers
	//
	CServiceHandle hSCm(hServiceCtrlMgr);
	CServiceHandle hSvc(hService);

    //
    // Query the service status.
    //
    SERVICE_STATUS SrviceStatus;
    if (!QueryServiceStatus(hService, &SrviceStatus))
    {
        DisplayError(IDS_QUERY_SERVICE_ERROR);
		return FALSE;
    }
    else
    {
        *pfServiceIsRunning = SrviceStatus.dwCurrentState == SERVICE_RUNNING;
    }

    return TRUE;
}


//
// Stop the MQQM service.
//
BOOL
StopService()
{
	CWaitCursor wc;

    //
    // Get the name of the device driver.
    //
    TCHAR szDriverPath[MAX_DEV_NAME_LEN];

    if (FAILED(MQUGetAcName(szDriverPath)))
    {           
        AfxMessageBox(IDS_NO_DRIVER, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }
	

    //
    // Get a handle to the device driver and a pointer to
    // NtDeviceIoControlFile in NTDLL.DLL
    //
    CAutoCloseFileHandle hAc;

    if (((hAc = CreateFile(szDriverPath,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                           NULL)) == INVALID_HANDLE_VALUE))
    {
        AfxMessageBox(IDS_NO_DRIVER, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    //
    // Get a handle to the service.
    //
    SC_HANDLE hServiceCtrlMgr;
    SC_HANDLE hService;

    if (!GetServiceAndScmHandles(&hServiceCtrlMgr,
                             &hService,
                             SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS))
    {
        return FALSE;
    }

 	//
	// Automatic wrappers
	//
	CServiceHandle hSCm(hServiceCtrlMgr);
	CServiceHandle hSvc(hService);

	//
    // Stop the service.
    //
	SERVICE_STATUS SrviceStatus;
	DWORD dwErr;
	BOOL fRet;

	for(;;)
	{
		fRet = ControlService(hService,
							  SERVICE_CONTROL_STOP,
							  &SrviceStatus);

		dwErr = GetLastError();

		//
		// If service is already stopped, or there are dependent services active
		// it is normal situtation. Other cases are errors.
		//
		if (!fRet && 
			dwErr != ERROR_SERVICE_NOT_ACTIVE && 
			dwErr != ERROR_DEPENDENT_SERVICES_RUNNING)
		{
			if ( DisplayErrorWithRetry(IDS_STOP_SERVICE_ERROR, NULL) )
			{
				wc.Restore();
				continue;
			}

			return FALSE;
		}

		break;
	}

	//
	// If there are dependent serivices running, attempt to stop them
	//
	if ( !fRet && dwErr == ERROR_DEPENDENT_SERVICES_RUNNING)
	{
		fRet = StopDependentServices(hServiceCtrlMgr, hService, wc);
		if ( !fRet )
		{
			return FALSE;
		}

		for(;;)
		{
			//
			// Send Stop control to QM again - it should not fail this time
			//
			fRet = ControlService(hService,
					  SERVICE_CONTROL_STOP,
					  &SrviceStatus);

			
			if ( !fRet && 
			   (GetLastError() != ERROR_SERVICE_NOT_ACTIVE) )
			{
				if ( DisplayErrorWithRetry(IDS_STOP_SERVICE_ERROR, NULL) )
				{
					wc.Restore();
					continue;
				}

				return FALSE;
			}

			break;
		}

	}

	for(;;)
	{
		if (!WaitForServiceToStop(hService) )
		{
			if ( DisplayErrorWithRetry(IDS_STOP_SERVICE_ERROR, NULL) )
			{
				wc.Restore();
				continue;
			}

			return FALSE;
		}

		break;
	}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\sitegate.cpp ===
// SiteGate.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqPPage.h"
#include "SiteGate.h"
#include "dsext.h"

#include "sitegate.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSiteGate property page

IMPLEMENT_DYNCREATE(CSiteGate, CMqPropertyPage)


CSiteGate::CSiteGate(
    const CString& strDomainController /* CString(L"") */,
    const CString& LinkPathName  /* CString(L"") */
    ) :
    CMqPropertyPage(CSiteGate::IDD),
	m_strDomainController(strDomainController),
    m_LinkPathName(LinkPathName)
{
    //{{AFX_DATA_INIT(CSiteGate)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    //
    // Set Pointer to List Box to NULL
    //
    m_pFrsListBox = NULL;
    m_pSiteGatelistBox = NULL;

    m_SiteGateFullName.cElems = 0;
    m_SiteGateFullName.pElems = NULL;

}


CSiteGate::~CSiteGate()
{
    //
    // Don't use DestructElement. Since CSiteGate contains few maps and Clist
    // that pointe to the same object. Using of DestructElement cause destruction
    // of same object twice.
    //
    POSITION pos = m_Name2FullPathName.GetStartPosition();
    while(pos != NULL)
    {
        LPCWSTR FrsName;
        LPCWSTR FrsFullPathName;

        m_Name2FullPathName.GetNextAssoc(pos, FrsName, FrsFullPathName);
        MQFreeMemory(const_cast<LPWSTR>(FrsName));
        MQFreeMemory(const_cast<LPWSTR>(FrsFullPathName));
    }

    delete [] m_SiteGateFullName.pElems;
}


BEGIN_MESSAGE_MAP(CSiteGate, CMqPropertyPage)
    //{{AFX_MSG_MAP(CSiteGate)
    ON_BN_CLICKED(IDB_SITE_GATE_ADD, OnSiteGateAdd)
    ON_BN_CLICKED(IDB_SITE_GATE_REMOVE, OnSiteGateRemove)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteGate message handlers

void CSiteGate::OnSiteGateAdd() 
{
    MoveSelected(m_pFrsListBox, m_pSiteGatelistBox);
    OnChangeRWField();
}

void CSiteGate::OnSiteGateRemove() 
{
    MoveSelected(m_pSiteGatelistBox, m_pFrsListBox);
    OnChangeRWField();
}

BOOL CSiteGate::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
        //
        // Initialize pointer to ListBox
        //
        m_pFrsListBox = (CListBox *)GetDlgItem(IDC_SITE_FRS_LIST);
        m_pSiteGatelistBox = (CListBox *)GetDlgItem(IDC_SITE_GATES_LIST);

        POSITION pos = m_Name2FullPathName.GetStartPosition();
        while(pos != NULL)
        {
            LPCWSTR FrsName;
            LPCWSTR FrsFullPathName;

            m_Name2FullPathName.GetNextAssoc(pos, FrsName, FrsFullPathName);
            VERIFY(m_pFrsListBox->AddString(FrsName) != CB_ERR);
        }

        pos = m_SiteGateList.GetHeadPosition();
        while (pos != NULL)
        {
            LPCWSTR SitegateName;
            SitegateName = m_SiteGateList.GetNext(pos);

            //
            // remove the site gate from the FRS list Box
            //
            int Index = m_pFrsListBox->FindString(-1, SitegateName);
            VERIFY(Index != LB_ERR);
            VERIFY(m_pFrsListBox->DeleteString(Index) != CB_ERR);

            //
            // Add the site gate to Site gate list box
            //
            VERIFY(m_pSiteGatelistBox->AddString(SitegateName) != CB_ERR);
        }

    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSiteGate::OnApply() 
{
    //
    // Call DoDataExchange
    //
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;
    }

    UpdateSiteGateArray();

    PROPID paPropid[] = { PROPID_L_GATES_DN };
    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
    PROPVARIANT apVar[x_iPropCount];
    
    DWORD iProperty = 0;

    //
    // PROPID_L_GATES_DN
    //
    ASSERT(paPropid[iProperty] == PROPID_L_GATES_DN);
    apVar[iProperty].vt = VT_LPWSTR | VT_VECTOR;
    apVar[iProperty++].calpwstr = m_SiteGateFullName;
    
    //
    // set the new value
    //    
    HRESULT hr = ADSetObjectProperties(
                eROUTINGLINK,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                m_LinkPathName,
                x_iPropCount, 
                paPropid, 
                apVar
                );

    if (MQ_OK != hr)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        CString strSiteLink;
        strSiteLink.LoadString(IDS_SITE_LINK);

        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, strSiteLink);
        return FALSE;
    }
    
    return CMqPropertyPage::OnApply();

}


HRESULT
CSiteGate::Initialize(
    const GUID* FirstSiteId,
    const GUID* SecondSiteId,
    const CALPWSTR* SiteGateFullPathName
    )
{ 
    HRESULT hr;

    hr = InitializeSiteFrs(FirstSiteId);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InitializeSiteFrs(SecondSiteId);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get Site Link
    //
    for (DWORD i = 0; i < SiteGateFullPathName->cElems; ++i)
    {
        LPCWSTR SiteGateName;
        BOOL f = m_FullPathName2Name.Lookup(SiteGateFullPathName->pElems[i], SiteGateName);

        //
        // If we did not find the site gate, it means that it no longer exists as a server
        // (for example, MSMQ was uninstalled) so we do not add it.
        //
        if (f)
        {
            m_SiteGateList.AddTail(SiteGateName);
        }
    }

    return hr;
}

HRESULT
CSiteGate::InitializeSiteFrs(
    const GUID* pSiteId
    )
/*++

Routine Description:
    The routine retrieves from the DS the FRS machines that belong to the site    

Arguments:
     pSiteId - Pointer to site id.
     FrsList - a return list of FRS machine that belong to the site

Returned value:
    Operation result

--*/
{    
    //
    // Get the FRS machine name
    //
    //
    PROPID aPropId[] = {PROPID_QM_PATHNAME, PROPID_QM_FULL_PATH};
    const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);
    CColumns AttributeColumns;

    for (DWORD i=0; i<x_nProps; i++)
    {
        AttributeColumns.Add(aPropId[i]);
    }

    //
    // This search request will be recognized and specially simulated by DS
    //    
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQuerySiteServers(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    pSiteId,
                    eRouter,
                    AttributeColumns.CastToStruct(),
                    &hEnume
                    );
    }

    DSLookup dslookup (hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return MQ_ERROR;
    }

    //
    // Get the properties
    //
    PROPVARIANT result[x_nProps*3];
    DWORD dwPropCount = sizeof(result) / sizeof(result[0]);;

    HRESULT rc = dslookup.Next(&dwPropCount, result);

    while (SUCCEEDED(rc) && (dwPropCount != 0))
    {
        for (DWORD i =0; i < dwPropCount; i += AttributeColumns.Count())
        {
            LPWSTR FrsName = result[i].pwszVal;
            LPWSTR FrsFullPathName = result[i+1].pwszVal;

            //
            // Can't add the same FRS twice
            //
            #ifdef _DEBUG
                LPCWSTR temp;
                ASSERT(!m_Name2FullPathName.Lookup(FrsName, temp));
            #endif

            m_Name2FullPathName[FrsName] = FrsFullPathName;
            m_FullPathName2Name[FrsFullPathName] = FrsName;
        }
        rc = dslookup.Next(&dwPropCount, result);
    }

    return rc;
}


void
CSiteGate::UpdateSiteGateArray(
    void
    )
/*++
Routine Description:
    The routine Initiaize an array of site gates full path name. The routine
    is called OnOk and initialize the array before calling the DS API.

Arguments: 
    None

Returned Value:
    None
--*/
{
    //
    // Get the number of site gates
    //
    DWORD NumOfSiteGates = m_pSiteGatelistBox->GetCount();
    VERIFY(NumOfSiteGates != LB_ERR);

    //
    // Craete a new site gates array
    //
    delete [] m_SiteGateFullName.pElems;
    m_SiteGateFullName.cElems = 0;
    m_SiteGateFullName.pElems = NULL;
    
    if (m_fModified && (NumOfSiteGates > 0))
    {
        m_SiteGateFullName.cElems = NumOfSiteGates;
        m_SiteGateFullName.pElems = new LPWSTR[NumOfSiteGates];

        for (DWORD i=0; i < NumOfSiteGates; ++i)
        {
            CString FrsName;

            m_pSiteGatelistBox->GetText(i, FrsName);
            BOOL f = m_Name2FullPathName.Lookup(FrsName, m_SiteGateFullName.pElems[i]);

            //
            // The full path should be exist. It was retrieved with the FRS.
            // 
            ASSERT(f);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\sitegate.h ===
#if !defined(AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SiteGate.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSiteGate dialog

class CSiteGate : public CMqPropertyPage
{
    DECLARE_DYNCREATE(CSiteGate)

// Construction
public:
	CSiteGate(const CString& strDomainController = CString(L""), const CString& LinkPathName = CString(L""));
    ~CSiteGate();

    HRESULT
    Initialize(
        const GUID* FirstSiteId,
        const GUID* SecondSiteId,
        const CALPWSTR* SiteGateFullPathName
        );


// Dialog Data
	//{{AFX_DATA(CSiteGate)
	enum { IDD = IDD_SITE_LINK_GATES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSiteGate)
	public:
    virtual BOOL OnApply();
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSiteGate)
	afx_msg void OnSiteGateAdd();
	afx_msg void OnSiteGateRemove();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    typedef CList<LPCWSTR, LPCWSTR&> SiteFrsList;

    
    HRESULT
    InitializeSiteFrs(
        const GUID* pSiteId
        );

    void
    UpdateSiteGateArray(
        void
        );


    CMap<LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR&> m_Name2FullPathName;
    CMap<LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR&> m_FullPathName2Name;
    SiteFrsList m_SiteGateList;

    CListBox* m_pFrsListBox;
    CListBox* m_pSiteGatelistBox;

    CString m_LinkPathName;
    CString m_strDomainController;
    CALPWSTR m_SiteGateFullName;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\ruledef.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruledef.cpp

Abstract:
	Implementation for the rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "triggen.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"

#include "ruledef.tmh"

static CString s_strYes;
static CString s_strNo;


/****************************************************

CRulesDefinition Class
    
 ****************************************************/

// {FB19702B-EB46-4ec4-9B0B-F41EA2A61410}
static const GUID CRulesDefinitionGUID_NODETYPE = 
{ 0xfb19702b, 0xeb46, 0x4ec4, {0x9b, 0xb, 0xf4, 0x1e, 0xa2, 0xa6, 0x14, 0x10} };

const GUID*  CRulesDefinition::m_NODETYPE = &CRulesDefinitionGUID_NODETYPE;
const OLECHAR* CRulesDefinition::m_SZNODETYPE = OLESTR("FB19702B-EB46-4ec4-9B0B-F41EA2A61410");
const OLECHAR* CRulesDefinition::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CRulesDefinition::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CRulesDefinition::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
   
                                
HRESULT CRulesDefinition::PopulateResultChildrenList()
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());


    try
    {
        m_pRuleSet->Refresh();
        RuleList ruleList = m_pRuleSet->GetRuleList();

        for(RuleList::iterator it = ruleList.begin(); it != ruleList.end(); ++it)
        {        
            P<CRuleResult> pRule = new CRuleResult(this, m_pComponentData, (*it).get());

            AddChildToList(pRule);

            pRule.detach();
        }
    }
    catch (const _com_error&)
    {
    }
    return S_OK;
    
}


HRESULT 
CRulesDefinition::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return(S_OK);
}


HRESULT 
CRulesDefinition::OnNewRule(
    bool & bHandled, 
    CSnapInObjectRootBase* pSnapInObjectRoot
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CNewRule newRule(m_pRuleSet.get());
    if (newRule.DoModal() == ID_WIZFINISH)
    {        
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }

    return(S_OK);
}


CColumnDisplay RuleDefintionColumn[] = {
    { IDS_RULE_NAME,  150 },
    { IDS_RULE_DESCRIPTION, 200 },
    { IDS_RULE_SHOW_WINDOW, 100 },
    { IDS_RULE_ID, HIDE_COLUMN },
};

HRESULT 
CRulesDefinition::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
	//
	// Initialize column values
	//
	s_strYes.LoadString(IDS_YES);
	s_strNo.LoadString(IDS_NO);

    for (DWORD i = 0; i < ARRAYSIZE(RuleDefintionColumn); ++i)
    {
        CString title;
        title.LoadString(RuleDefintionColumn[i].m_columnNameId);

        HRESULT hr = pHeaderCtrl->InsertColumn(
                                        i, 
                                        title, 
                                        LVCFMT_LEFT, 
                                        RuleDefintionColumn[i].m_width
                                        );
        if (FAILED(hr))
            return hr;
    }

    return(S_OK);
}


CString 
CRulesDefinition::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);

	return strHelpLink;
}

/////////////////////////////////////////////////////////////////////////////
// CRuleParent base class

void CRuleParent::OnRuleApply() throw (_com_error)
{
	try
	{
		_bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_ruleName);
		_bstr_t description = static_cast<LPCTSTR>(m_pGeneral->m_ruleDescription);
		_bstr_t cond = static_cast<LPCTSTR>(m_pCond->GetCondition());
		_bstr_t action = static_cast<LPCTSTR>(m_pAction->GetAction());
		long fShowWindow = m_pAction->m_fShowWindow;

		m_rule->Update(name, description, cond, action, (fShowWindow != 0));
	}
	catch(const _com_error& e)
	{
		if (e.Error() == MQTRIG_RULE_NOT_FOUND)
		{
			CString strError;
			strError.FormatMessage(IDS_RULE_ALREADY_DELETED, static_cast<LPCWSTR>(GetRuleName()));
			AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

			throw;
		}

		DisplayErrorFromCOM(IDS_RULE_UPDATE_FAILED, e);
		throw;
	}
}


void
CRuleParent::OnDestroyPropertyPages()
{
	m_pGeneral = NULL;
	m_pCond = NULL;
	m_pAction = NULL;
}

/****************************************************

CRuleResult Class
    
 ****************************************************/

// {3A8D70C9-C74F-4333-B493-43A14442D24B}
static const GUID CRuleResultGUID_NODETYPE = 
{ 0x3a8d70c9, 0xc74f, 0x4333, { 0xb4, 0x93, 0x43, 0xa1, 0x44, 0x42, 0xd2, 0x4b} };

const GUID*  CRuleResult::m_NODETYPE = &CRuleResultGUID_NODETYPE;
const OLECHAR* CRuleResult::m_SZNODETYPE = OLESTR("3A8D70C9-C74F-4333-B493-43A14442D24B");
const OLECHAR* CRuleResult::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CRuleResult::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CRuleResult::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr;

    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}

HRESULT 
CRuleResult::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// If the propery page already open bring it to top
	//
	if ((m_pGeneral != NULL) && (m_pGeneral->GetParent() != NULL))
	{		
		(m_pGeneral->GetParent())->BringWindowToTop();
		return S_FALSE;
	}

    //
    // Add general rule property page
    //
    HPROPSHEETPAGE hGeneralRule = 0;
    HRESULT hr = CreateGenralPage(&hGeneralRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_GENERAL_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hGeneralRule); 

    //
    // Add rule condition property page
    //
    HPROPSHEETPAGE hCondition = 0;
    hr = CreateConditionPage(&hCondition);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_COND_FAILE, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hCondition);
    
    //
    // Add action property page
    //
    HPROPSHEETPAGE hAction = 0;
    hr = CreateActionPage(&hAction);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_ACTION_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hAction);

    return S_OK;
}


HRESULT 
CRuleResult::CreateGenralPage(
    HPROPSHEETPAGE *phGeneralRule
    )
{   
    try
    {
        m_pGeneral = new CViewRuleGeneral(this, GetRuleName(), GetRuleDescription());
    
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&m_pGeneral->m_psp); 
        if (hPage)
        {
            *phGeneralRule = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CRuleResult::CreateConditionPage(
    HPROPSHEETPAGE *phCondition
    )
{   
    try
    {
        m_pCond  = new CRuleCondition(this, GetRuleCondition());

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&m_pCond->m_psp); 
        if (hPage)
        {
            *phCondition = hPage;
            return S_OK;
        }
    }
    catch(const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CRuleResult::CreateActionPage(
    HPROPSHEETPAGE *phAction
    )
{      
    try
    {
        m_pAction = new CRuleAction(this, GetRuleAction(), GetShowWindow());

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&m_pAction->m_psp); 
        if (hPage)
        {
            *phAction = hPage;
            return S_OK;
        }
    }
    catch(const exception&)
    {
    }

    return E_UNEXPECTED;    
}


LPOLESTR CRuleResult::GetResultPaneColInfo(int nCol)
{
    ASSERT(ARRAYSIZE(RuleDefintionColumn) >= nCol);
    
    switch (RuleDefintionColumn[nCol].m_columnNameId)
    {
        case IDS_RULE_NAME:
            return m_rule->GetRuleName();

        case IDS_RULE_ID:
            return m_rule->GetRuleId();

        case IDS_RULE_DESCRIPTION:
            return m_rule->GetRuleDescription();

        case IDS_RULE_SHOW_WINDOW:
            if (m_rule->GetShowWindow())
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strYes));
			}

			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strNo));

        default:
            ASSERT(0);
            return _T("");
    }
}


HRESULT CRuleResult::OnDelete( 
			LPARAM,
			LPARAM,
			IComponentData* pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES,
            BOOL
			)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, static_cast<LPCTSTR>(GetRuleName()));

    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

    try
    {
        ASSERT(m_pParentNode != NULL);

        m_rule->DeleteRule();
        
		//
		// Remove the trigger from result list so next time the reult pane view it will
		// not present the deleted trigger
		//
		R<CRuleResult> ar = this;
		HRESULT hr = static_cast<CRulesDefinition*>(m_pParentNode)->RemoveChild(this);
		ASSERT(SUCCEEDED(hr));

        return S_OK;
    }
    catch(const _com_error&)
    {
        CString strError;
        strError.FormatMessage(IDS_OP_DELETE, static_cast<LPCWSTR>(GetRuleName()));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        return S_FALSE;
    }
}


void 
CRuleResult::Compare(
	CRuleResult* pItem1, 
	CRuleResult* pItem2,
	int* pnResult
	)
{
	LPCWSTR pVal1 = pItem1->GetResultPaneColInfo(*pnResult);
	LPCWSTR pVal2 = pItem2->GetResultPaneColInfo(*pnResult);

	*pnResult = wcscmp(pVal2, pVal1);
}


CString 
 CRuleResult::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}


/////////////////////////////////////////////////////////////////////////////
// CRuleGeneral property page

CRuleGeneral::CRuleGeneral(
	UINT nIDPage,
	UINT nIDCaption
    ) : 
    CMqPropertyPage(nIDPage, nIDCaption)
{
}

  
void CRuleGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleGeneral)
	DDX_Text(pDX, IDC_RULE_DESCRIPTION, m_ruleDescription);
	DDV_MaxChars(pDX, m_ruleDescription, xMaxRuleDescriptionLen);
	//}}AFX_DATA_MAP
}


BOOL CRuleGeneral::OnInitDialog() 
{
	SetDlgTitle();
	
	return CMqPropertyPage::OnInitDialog();
}


/////////////////////////////////////////////////////////////////////////////
// CNewRuleGeneral property page

CNewRuleGeneral::CNewRuleGeneral(
    CNewRule* pParentNode
    ) : 
    CRuleGeneral(CNewRuleGeneral::IDD, IDS_NEW_RULE_CAPTION),
    m_pNewParentNode(pParentNode)
{
    m_ruleName = _T("");
	m_ruleDescription = _T("");
}


void CNewRuleGeneral::DoDataExchange(CDataExchange* pDX)
{
	CRuleGeneral::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleGeneral)
	DDX_Text(pDX, IDC_RULE_NAME, m_ruleName);
    DDV_NotEmpty(pDX, m_ruleName, IDS_RULE_NAME_REQUIRED);
	DDV_MaxChars(pDX, m_ruleName, xMaxRuleNameLen);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNewRuleGeneral, CRuleGeneral)
	//{{AFX_MSG_MAP(CNewRuleGeneral)
	ON_EN_CHANGE(IDC_RULE_DESCRIPTION, OnChangeRWField)
	ON_EN_CHANGE(IDC_RULE_NAME, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CNewRuleGeneral::OnSetActive() 
{
	ASSERT(m_pNewParentNode != NULL);
    return m_pNewParentNode->SetWizardButtons();
}


/////////////////////////////////////////////////////////////////////////////
// CViewRuleGeneral property page

CViewRuleGeneral::CViewRuleGeneral(
    CRuleParent* pParentNode,
    _bstr_t ruleName, 
    _bstr_t ruleDescription
    ) : 
    CRuleGeneral(CViewRuleGeneral::IDD),
    m_pParentNode(SafeAddRef(pParentNode))
{
	//{{AFX_DATA_INIT(CRuleGeneral)
	m_ruleName = static_cast<LPTSTR>(ruleName);
	m_ruleDescription = static_cast<LPTSTR>(ruleDescription);
	//}}AFX_DATA_INIT
}


CViewRuleGeneral::~CViewRuleGeneral()
{
	ASSERT(m_pParentNode.get() != NULL);
	m_pParentNode->OnDestroyPropertyPages();
}


BEGIN_MESSAGE_MAP(CViewRuleGeneral, CRuleGeneral)
	//{{AFX_MSG_MAP(CViewRuleGeneral)
	ON_EN_CHANGE(IDC_RULE_DESCRIPTION, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CViewRuleGeneral::OnApply() 
{
    try
    {
	    m_pParentNode->OnRuleApply();

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
       return FALSE;
    }
}


void CViewRuleGeneral::SetDlgTitle()
{
	SetDlgItemText(IDC_RULE_GENERAL_TITLE, m_ruleName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\ruledef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    ruledef.h                                     *

Abstract:
	Definition for the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULDEF_H__
#define __RULDEF_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"

#include "rule.h"

class CRuleResult;
class CNewRule;
class CRuleCondition;
class CRuleParent;

// -----------------------------------------------------
//
// CRulesDefinition
//
// -----------------------------------------------------
class CRulesDefinition :  public CNodeWithResultChildrenList<CRulesDefinition, CRuleResult, CSimpleArray<CRuleResult*>, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CRulesDefinition, FALSE)
		SNAPINCOMMAND_ENTRY(ID_NEW_NEWRULE, OnNewRule)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_RULE_DEF_MENU)

    CRulesDefinition(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CRuleSet* pRuleSet
        ) : 
        CNodeWithResultChildrenList<CRulesDefinition, CRuleResult, CSimpleArray<CRuleResult*>, FALSE>(pParentNode, pComponentData),
        m_pRuleSet(SafeAddRef(pRuleSet))
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		SetIcons(IMAGE_RULES_DEFINITION,IMAGE_RULES_DEFINITION);
    }

	~CRulesDefinition()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateResultChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
	//
	// Menu functions
	//
	HRESULT OnNewRule(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

private:
    R<CRuleSet> m_pRuleSet;
};



/////////////////////////////////////////////////////////////////////////////
// CRuleGeneral dialog

class CRuleGeneral : public CMqPropertyPage
{
friend class CNewRule;

// Construction
public:
    CRuleGeneral(UINT nIDPage, UINT nIDCaption = 0);

// Dialog Data
	//{{AFX_DATA(CRuleGeneral)
	CString	m_ruleName;
	CString	m_ruleDescription;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleGeneral)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

private:
	virtual void SetDlgTitle() {};

};


/////////////////////////////////////////////////////////////////////////////
// CNewRuleGeneral page

class CNewRuleGeneral : public CRuleGeneral
{

public:
    CNewRuleGeneral(CNewRule* pParentNode);

	enum { IDD = IDD_NEW_TRIGGER_RULE_GENEARL };

	// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleGeneral)
    virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    CNewRule* m_pNewParentNode;

};


/////////////////////////////////////////////////////////////////////////////
// CViewRuleGeneral page

class CViewRuleGeneral : public CRuleGeneral
{

public:
	CViewRuleGeneral(
        CRuleParent* pParentNode, 
        _bstr_t name, 
        _bstr_t description
        );

	~CViewRuleGeneral();

	enum { IDD = IDD_TRIGGER_RULE_GENEARL };

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	public:
	virtual BOOL OnApply();
	//}}AFX_VIRTUAL

protected:
	DECLARE_MESSAGE_MAP()

private:
	void SetDlgTitle();

    R<CRuleParent> m_pParentNode;

};


class CRuleParent
{
friend class CViewRuleGeneral;
friend class CRuleCondition;
friend class CRuleAction;

public:
	CRuleParent(
		) :
		m_pGeneral(NULL),
		m_pCond(NULL),
		m_pAction(NULL),
		m_rule(NULL)
	{
	}

	CRuleParent(
		CRule* pRule
		) :
		m_pGeneral(NULL),
		m_pCond(NULL),
		m_pAction(NULL),
		m_rule(SafeAddRef(pRule))
	{
	}

	virtual void AddRef() = 0;
	virtual void Release() = 0;

    const _bstr_t& GetRuleId(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleId();
    }

    const _bstr_t& GetRuleName(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleName();
    }

    const _bstr_t& GetRuleDescription(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleDescription();
    }

    const _bstr_t& GetRuleAction(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleAction();
    }

    const _bstr_t& GetRuleCondition(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleCondition();
    }

    bool GetShowWindow(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetShowWindow();
    }

	void OnDestroyPropertyPages(void);

protected:
    void OnRuleApply() throw (_com_error);

protected:
    R<CRule> m_rule;

    CRuleGeneral* m_pGeneral;
    CRuleCondition* m_pCond;
    CRuleAction* m_pAction;

};


class CRuleResult : public CSnapinNode<CRuleResult, FALSE>, public CRuleParent
{

public:
    CRuleResult(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData,
        CRule* pRule
        ): 
        CSnapinNode<CRuleResult, FALSE>(pParentNode, pComponentData),
		CRuleParent(pRule)
    {   
        //
        // Set display name
        //
        m_bstrDisplayName = (BSTR) m_rule->GetRuleName();

		SetIcons(IMAGE_RULES_DEFINITION, IMAGE_RULES_DEFINITION);
	}

    
    virtual ~CRuleResult() 
    {
    }

	virtual void AddRef()
	{
		return CSnapinNode<CRuleResult, FALSE>::AddRef();
	}
	virtual void Release()
	{
		return CSnapinNode<CRuleResult, FALSE>::Release();
	}
    
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type
        );

    LPOLESTR GetResultPaneColInfo(int nCol);

    HRESULT OnDelete( 
			LPARAM arg,
			LPARAM param,
			IComponentData * pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES type,
            BOOL fSilent
			);

public:
	static void Compare(CRuleResult *pItem1, CRuleResult *pItem2, int* pnResult);


private:
    HRESULT CreateGenralPage(HPROPSHEETPAGE *phGeneralRule);
    HRESULT CreateConditionPage(HPROPSHEETPAGE *phGeneralRule);
    HRESULT CreateActionPage(HPROPSHEETPAGE *phGeneralRule);
	virtual CString GetHelpLink();
};




#endif // __RULDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snapin.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	snapin.cpp

Abstract:

	Implementation file for the CSnapinExt snapin node class.
    This class expands the DS Snapin objects

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mqsnap.h"
#include "Snapin.h"
#include "rdmsg.h"
#include "globals.h"
#include "message.h"
#include "lqDsply.h"
#include "localadm.h"
#include "privadm.h"

#import "mqtrig.tlb" no_namespace

#include "mqppage.h"
#include "rule.h"
#include "trigger.h"
#include "trigdef.h"
#include "ruledef.h"

#include "snapin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSnapinComponentData
static const GUID CSnapinGUID_NODETYPE = 
{ 0x74e5637c, 0xb98c, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };
const GUID*  CSnapinData::m_NODETYPE = &CSnapinGUID_NODETYPE;
const OLECHAR* CSnapinData::m_SZNODETYPE = OLESTR("74E5637C-B98C-11D1-9B9B-00E02C064C39");
const OLECHAR* CSnapinData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CSnapinData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

HRESULT CSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
		CSnapinPage* pPage = new CSnapinPage(handle, true, _T("Snapin"));
		lpProvider->AddPage(pPage->Create());
		// The second parameter  to the property page class constructor
		// should be true for only one page.

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

HRESULT CSnapinData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}

HRESULT CSnapinData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

HRESULT CSnapinData::Notify( MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch (event)
	{
	case MMCN_SHOW:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			// TODO : Enumerate the result pane items
			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			// TODO : Enumerate scope pane items
			hr = S_OK;
			break;
		}
	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
			if (hBitmap16 != NULL)
			{
				CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_32x32));
				if (hBitmap32 != NULL)
				{
					hr = pImageList->ImageListSetStrip(
										reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
										reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32),
										0, 
										RGB(0, 128, 128)
										);
					if (FAILED(hr))
						ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
				}
			}
			break;
		}  
	}
	return hr;
}

LPOLESTR CSnapinData::GetResultPaneColInfo(int nCol)
{
	if (nCol == 0)
		return m_bstrDisplayName;
	// TODO : Return the text for other columns
	return OLESTR("Override GetResultPaneColInfo");
}

/******************************************************************
 *
 *                  CSnapin
 *
 ******************************************************************/
//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::GetClassID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::GetClassID(CLSID* pClassID)
{
	ATLTRACE(_T("CSnapin::GetClassID\n"));
	_ASSERTE( pClassID != NULL );

	*pClassID = CLSID_MSMQSnapin;
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::IsDirty

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::IsDirty()
{
	ATLTRACE(_T("CSnapin::IsDirty\n"));

	// We just return S_OK because we're always dirty.
	return S_OK;
}


//
// Version number of the file data
// To be incremented each time the data of the 
// saved file changes.
//              
static const DWORD x_dwFileVersion = 5;
//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Load


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Load(IStream* pStream)
{
	ATLTRACE(_T("CSnapin::Load"));

	
	_ASSERTE( pStream != NULL );
    HRESULT hr;
    DWORD version;
    DWORD res;

    //
    // Load Version
    //
    hr = pStream->Read(&version, sizeof(DWORD), &res);

    //
    // res will be zero if the msc file was saved without mqsnap information
    //
    if(FAILED(hr) || res == 0)
        return(hr);


    ASSERT(res == sizeof(DWORD));

    //
    // Check version number
    //
    if(version != x_dwFileVersion)
        return(S_OK);

    //
    // Placeholder - load any information that the snapin had saved
    //

    return(hr);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::Save


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Save(IStream* pStream, BOOL  clearDirty)
{
	ATLTRACE(_T("CComponentData::Save"));


	_ASSERTE( pStream != NULL );
    HRESULT hr;
    DWORD res;

    //
    // Save Version
    //
    hr = pStream->Write(&x_dwFileVersion, sizeof(DWORD), &res);
    ASSERT(res == sizeof(DWORD));

    if(FAILED(hr))
        return(hr);

    //
    // Placeholder - any saved data should be placed here.
    //

    return(hr);


}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::GetSizeMax

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER* size)
{
	ATLTRACE(_T("CSnapin::GetSizeMax\n"));
    DWORD dwSize;

    //
    // Add version number size
    //
    dwSize = sizeof(DWORD);


	size->HighPart = 0;
	size->LowPart = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::Initialize

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapin::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CSnapin, CSnapinComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap16 == NULL)
		return S_OK;

	CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip(
						reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
						reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32),
						0, 
						RGB(0, 128, 128)
						) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::Notify

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CSnapinComponent::Notify(
	LPDATAOBJECT lpDataObject, 
	MMC_NOTIFY_TYPE event, 
	LPARAM arg, 
	LPARAM param
	)
{
    HRESULT hr = S_OK;


    if(lpDataObject != NULL && MMCN_SHOW != event)
     		return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);


    //
    // In this routine we handle only 
    // lpDataObject ==NULL, or we have a MMCN_SHOW event.
    //

    
    switch (event)
	{
		case MMCN_SHOW:
		{
		  //
		  // On Show event, we want to keep, or reset
		  // the node currenlty selected
		  //
		  ASSERT(lpDataObject != NULL);

		  //
		  // Retreive the pItem data type
		  //
		  CSnapInItem* pItem;
		  DATA_OBJECT_TYPES type;
		  hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
  
		  if(FAILED(hr))
			  return(hr);

		  if( arg )
		  {
			 // We are being selected.   
			 m_pSelectedNode = pItem;

		  }
		  else
		  {
			 // We are being deselected.

			 // Check to make sure that our result view doesn't think
			 // this node is the currently selected one.
			 if( m_pSelectedNode == pItem)
			 {
				// We don't want to be the selected node anymore.
				m_pSelectedNode = NULL;
			 }

		  }

		  //
		  // Call SnapinItem notification routine
		  //
		  return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
		}

		case MMCN_COLUMN_CLICK:
		{
			//
			// A column was clicked. We will sort the result pane accordingly
			//
            return S_OK;
		}
	}



    //
    // lpDataObject == NULL
    //

    // Currently handling only View Change (UpdateAllViews)
	ASSERT(event == MMCN_VIEW_CHANGE);

    if (param == UPDATE_REMOVE_ALL_RESULT_NODES) // delete all result items
	{
		CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);

		hr = spResultData->DeleteAllRsltItems();
		return hr;
	}
     
	if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
    {

      // We basically tell MMC to simulate reselecting the
      // currently selected node, which causes it to redraw.
      // This will cause MMC to send the MMCN_SHOW notification
      // to the selected node.
      // This function requires an HSCOPEITEM.  This is the ID member
      // of the HSCOPEDATAITEM associated with this node.
      SCOPEDATAITEM *pScopeDataItem;
      m_pSelectedNode->GetScopeData( &pScopeDataItem );
      return m_spConsole->SelectScopeItem( pScopeDataItem->ID );
   }

  return(hr);	

}

//
// IResultDataCompare
//
STDMETHODIMP CSnapinComponent::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    ASSERT(cookieA != 0 && cookieB != 0);

	CSnapInItem* pItemA = (CSnapInItem*) cookieA;
	CSnapInItem* pItemB = (CSnapInItem*) cookieB;

    GUID guidTypeA, guidTypeB;

    HRESULT hr = GetSnapinItemNodeType(pItemA, &guidTypeA);
    if FAILED(hr)
    {
        return hr;
    }

    hr = GetSnapinItemNodeType(pItemB, &guidTypeB);
    if FAILED(hr)
    {
        return hr;
    }

    if (guidTypeA != guidTypeB)
    {
        //
        // Different types. Consider them equal
        //
        *pnResult = 0;
        return S_OK;
    }

    //
    // Handle different types
    //
    if (guidTypeA == *CMessage::m_NODETYPE)
    {
        return ((CMessage*)pItemA)->Compare(lUserParam, (CMessage*)pItemB, pnResult);
    }

	if (guidTypeA == *CTrigResult::m_NODETYPE)
	{
		CTrigResult::Compare(
			reinterpret_cast<CTrigResult*>(pItemA),
			reinterpret_cast<CTrigResult*>(pItemB),
			pnResult
			);
		return S_OK;
	} 

	if (guidTypeA == *CRuleResult::m_NODETYPE)
	{
		CRuleResult::Compare(
			reinterpret_cast<CRuleResult*>(pItemA),
			reinterpret_cast<CRuleResult*>(pItemB),
			pnResult
			);
		return S_OK;
	} 

    return E_NOTIMPL;
};

//////////////////////////////////////////////////////////////////////////////
/*++
ISnapinHelp interface support

CSnapin::GetHelpTopic
This routine returns the path of the msmq.chm help file

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT 
STDMETHODCALLTYPE
CSnapin::GetHelpTopic(
    LPOLESTR* lpCompiledHelpFile
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    WCHAR Path[MAX_PATH];

    ASSERT( lpCompiledHelpFile != NULL );

    CString strHelpPath;
    strHelpPath.LoadString(IDS_HELPPATH);

    ExpandEnvironmentStrings(strHelpPath, Path, sizeof(Path)/sizeof(WCHAR));
    *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc((wcslen(Path) + 1) * sizeof(Path[0]));
    wcscpy(*lpCompiledHelpFile, Path );

    return S_OK;
}

//
// GetSnapinItemNodeType - Get the GUID node type of a snapin item
//
HRESULT GetSnapinItemNodeType(CSnapInItem *pNode, GUID *pGuidNode)
{
    //
    // Gets the other Node type (note - alloc will be auto free when spStream
    // goes out of context)
    //
    HGLOBAL hGlobal = GlobalAlloc(GPTR, sizeof(GUID));
    if (0 == hGlobal)
    {
        return E_OUTOFMEMORY;
    }

	CComPtr<IStream> spStream;
	HRESULT hr = CreateStreamOnHGlobal(hGlobal, TRUE, &spStream);
	if (FAILED(hr))
    {
        return hr;
    }

    hr = pNode->FillData(CSnapInItem::m_CCF_NODETYPE, spStream);
    if FAILED(hr)
    {
        return hr;
    }

    *pGuidNode = *(GUID *)hGlobal;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpnerr.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	snperr.h

Abstract:

	Definition and implementation file for the CErrorNode snapin node class 

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __SNPNERR_H_
#define __SNPNERR_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnode.h"


/////////////////////////////////////////////////////////////////////////////
// CErrorNode
// {B1320C00-BCB2-11d1-9B9B-00E02C064C39}
static const GUID CErrorNodeGUID_NODETYPE = 
{ 0xb1320c00, 0xbcb2, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

//////////////////////////////////////////////////////////////////////////////

class CErrorNode : public CSnapinNode<CErrorNode, FALSE>
{
public:
 
	CComPtr<IControlbar> m_spControlBar; 

  	BEGIN_SNAPINCOMMAND_MAP(CErrorNode, FALSE)
	END_SNAPINCOMMAND_MAP()


    CErrorNode(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CSnapinNode<CErrorNode, FALSE>(pParentNode, pComponentData)
	{       
        SetIcons(IMAGE_ERROR, IMAGE_ERROR);
	}

	~CErrorNode()
	{
	}



private:
};

#ifdef INIT_ERROR_NODE
    const GUID*  CErrorNode::m_NODETYPE = &CErrorNodeGUID_NODETYPE;
    const OLECHAR* CErrorNode::m_SZNODETYPE = OLESTR("B1320C00-BCB2-11d1-9B9B-00E02C064C39");
    const OLECHAR* CErrorNode::m_SZDISPLAY_NAME = OLESTR("MSMQ Message Admin");
    const CLSID* CErrorNode::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snapin.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	snapin.h

Abstract:

	Definition for the SnapinExt snapnin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SNAPIN_H_
#define __SNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "compext.h"
#include "qext.h"
#include "mgmtext.h"
#include "version.h"

class CSnapinPage : public CSnapInPropertyPageImpl<CSnapinPage>
{
public :
	CSnapinPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL) : 
		CSnapInPropertyPageImpl<CSnapinPage> (pTitle),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
	}

	~CSnapinPage()
	{
		if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_SNAPIN };

BEGIN_MSG_MAP(CSnapinPage)
	CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CSnapinPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT PropertyChangeNotify(LPARAM param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

public:
	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;
};


class CSnapinData : public CSnapInItemImpl<CSnapinData>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CComPtr<IControlbar> m_spControlBar;

	BEGIN_SNAPINCOMMAND_MAP(CSnapinData, FALSE)
	END_SNAPINCOMMAND_MAP()

	SNAPINMENUID(IDR_SNAPIN_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CSnapinData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CSnapinData()
	{
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 0;			// May need modification
		m_scopeDataItem.nOpenImage = 0;		// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 0;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;
	}

	~CSnapinData()
	{
	}

   STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);
};


class CSnapin;

class CSnapinComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CSnapin >,
  	public IExtendPropertySheetImpl<CSnapinComponent>,
    public IExtendContextMenuImpl<CSnapinComponent>,
	public IExtendControlbarImpl<CSnapinComponent>,
	public IComponentImpl<CSnapinComponent>,
    public IResultDataCompare
{
public:
BEGIN_COM_MAP(CSnapinComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

	// A pointer to the currently selected node used for refreshing views.
	// When we need to update the view, we tell MMC to reselect this node.
	CSnapInItem * m_pSelectedNode;

public:
	CSnapinComponent()
	{
        m_pSelectedNode = NULL;
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IResultDataCompare
    //
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);
};


class CSnapin : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<1, CSnapin>,
	public IComponentDataImpl<CSnapin, CSnapinComponent>,
   	public IExtendPropertySheetImpl<CSnapin>,
    public IExtendContextMenuImpl<CSnapin>,
	public IExtendControlbarImpl<CSnapin>,
	public IPersistStream,
    public ISnapinHelp,
    public CComCoClass<CSnapin, &CLSID_MSMQSnapin>
{
public:
	CSnapin()
	{
		m_pNode = new CSnapinData;
		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;

        m_CQueueExtData.m_pComponentData = this;
        m_CComputerExtData.m_pComponentData = this;
		m_CComputerMgmtExtData.m_pComponentData = this;
	}
	~CSnapin()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CQueueExtData)
EXTENSION_SNAPIN_DATACLASS(CComputerExtData)
EXTENSION_SNAPIN_DATACLASS(CComputerMgmtExtData)


BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CQueueExtData)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CComputerExtData)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CComputerMgmtExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

//
// The standard macro "DECLARE_REGISTRY_RESOURCEID(IDR_SNAPIN);" was replaced with this 
// code to allow localization of the snapin name - bug #4187
// This solution was suggested by Jeff Miller (YoelA, 30-Jun-99)
//
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// name of the snapin is stored in the string resource IDS_PROJNAME
	//
	CString strPorjectName;
	strPorjectName.LoadString(IDS_PROJNAME);

	_ATL_REGMAP_ENTRY re[] = 
	{
		L"SNAPINNAME", (LPCTSTR)strPorjectName,
		NULL, NULL
	};
	
	//
	// I don't just do "return _Module.UpdateRegistryFromResource" as
	// strPorjectName would get destroyed before the method finishes
	//
	HRESULT hr = _Module.UpdateRegistryFromResource(IDR_SNAPIN, 
		bRegister, re);

	return hr;
}

DECLARE_NOT_AGGREGATABLE(CSnapin)


    //
    // IPersist Interface
    // 
   	STDMETHOD(GetClassID)(CLSID* pClassID);

    //
    // IPersistStream Interface
    //
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream* stream);
	STDMETHOD(Save)(IStream* stream, BOOL /* clearDirty */);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* size);


    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    //
    // ISnapinHelp Interface
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
};

class ATL_NO_VTABLE CSnapinAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CSnapinAbout, &CLSID_MSMQSnapinAbout>
{
public:
	DECLARE_REGISTRY(CSnapinAbout, _T("MSMQSnapinAbout.1"), _T("MSMQSnapinAbout.1"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

private:
HRESULT
AboutHelper(
	UINT		nID, 
	LPOLESTR*	lpPtr)
{
	CString		szString;

    if (lpPtr == NULL)
	{
        return E_POINTER;
	}

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	szString.LoadString(nID);

    return AboutHelper(szString, lpPtr);
}

HRESULT
AboutHelper(
	CString &szString, 
	LPOLESTR*	lpPtr)
{
	UINT len = szString.GetLength() + 1;
    *lpPtr = reinterpret_cast<LPOLESTR>( CoTaskMemAlloc(len * sizeof(WCHAR)) );          		

    if (*lpPtr == NULL)
	{
        return E_OUTOFMEMORY;
	}

    lstrcpy(*lpPtr, szString);
    return S_OK;
}

public:
	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        return AboutHelper(IDS_PRODUCT_DESCRIPTION, lpDescription);
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        return AboutHelper(IDS_COMPANY, lpName);
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString strVersion;

        strVersion.FormatMessage(IDS_VERSION_FORMAT, rmj, rmm, rup);
        return AboutHelper(strVersion, lpVersion);
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        if (hAppIcon == NULL)
            return E_POINTER;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        *hAppIcon = LoadIcon(g_hResourceMod, MAKEINTRESOURCE(IDI_COMPUTER_MSMQ));

        ASSERT(*hAppIcon != NULL);
        return (*hAppIcon != NULL) ? S_OK : E_FAIL;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

//
// GetSnapinItemNodeType - Get the GUID node type of a snapin item
//
HRESULT GetSnapinItemNodeType(CSnapInItem *pNode, GUID *pGuidNode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpnode.h

Abstract:

	Header for the CSnapinNode class.

	This is our virtual base class for an MMC Snap-in node.

	As this is a template class and is all implemented inline,
	there is no SnapinNode.cpp for implementation.


Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Specific MSMQ support:
        Default images
        Default columns
    Support for Extension snapins 
    Add a CComponentData pointer
    SetIcons method
    

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_SNAPIN_NODE_H_)
#define _SNAPIN_NODE_H_

#include <tr.h>
#include <ref.h>


class CSnapin;



template <class T, BOOL bIsExtension>
class CSnapinNode : public CSnapInItemImpl< T, bIsExtension>, public CReference
{

protected:

	// Constructor/Destructor	
	CSnapinNode(CSnapInItem * pParentNode, CSnapin * pComponentData);
	~CSnapinNode();

private:

	virtual CString GetHelpLink();


public:


	// For IDataObject handling.
	IDataObject* m_pDataObject;
	void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);


    //
    // Change the default icon id
    //
    void SetIcons(DWORD idStandard, DWORD idOpen);

	// Clipboard formats which IDataObjects on all MMC nodes must support.
	static const GUID* m_NODETYPE;
	static const TCHAR* m_SZNODETYPE;
	static const TCHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;



	// Pointer to parent node.  This is passed in the call to our 
	// constructor.  Needed so that a node can access its parent.
	// For example, when we receive the MMCN_DELETE notification, we might tell
	// our parent node to remove us from its list of children.
	CSnapInItem * m_pParentNode;

    //
    // Pointer to the component data. Allow us to
    // access Snapin global data
    //
    CSnapin *     m_pComponentData;


public:


	// Standard MMC functionality -- override if you need to.
	STDMETHOD(CreatePropertyPages)(
		  LPPROPERTYSHEETCALLBACK lpProvider
		, LONG_PTR handle
		, IUnknown* pUnk
		, DATA_OBJECT_TYPES type
		);
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
	void* GetDisplayName();
    STDMETHOD(GetScopePaneInfo)( SCOPEDATAITEM *pScopeDataItem );
	STDMETHOD(GetResultPaneInfo)( RESULTDATAITEM *pResultDataItem );
	virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );


	// Notify method will call notification handlers below -- shouldn't need to override.
	STDMETHOD( Notify ) ( 
			  MMC_NOTIFY_TYPE event
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);


	// Notification handlers -- override when you want to intercept.
	virtual HRESULT OnActivate( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnAddImages( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnButtonClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnContextHelp( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnContextMenu( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnDoubleClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnDelete( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				, BOOL fSilent = FALSE
				);
	virtual HRESULT OnExpand(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnHelp(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnMenuButtonClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnMinimized( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnPaste( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnPropertyChange( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnQueryPaste( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRefresh( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRemoveChildren( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRename( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnSelect( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnShow( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnViewChange( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnColumnsChanged( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);


	// Special notification handler -- saves off the currently selected node.
	HRESULT PreOnShow( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);



	// Taskpad functionality.
	STDMETHOD(TaskNotify)(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);
	STDMETHOD(EnumTasks)(
				  IDataObject * pDataObject
				, BSTR szTaskGroup
				, IEnumTASK** ppEnumTASK
				);


};




//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:SetIcons

    Specify the Open and Close icons of the snapin node

Remarks: 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::SetIcons(DWORD idStandard, DWORD idOpen)
{
	m_scopeDataItem.nImage = idStandard;  
	m_scopeDataItem.nOpenImage = idOpen;

	m_resultDataItem.nImage = idStandard;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CreatePropertyPages

Adds pages to a property sheet.


HRESULT CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK lpProvider,
							  // Pointer to the callback interface
  LONG_PTR handle,            // Handle for routing notification
  LPDATAOBJECT lpIDataObject  // Pointer to the data object
);


Remarks: 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::CreatePropertyPages(
	  LPPROPERTYSHEETCALLBACK lpProvider
	, LONG_PTR handle
	, IUnknown* pUnk
	, DATA_OBJECT_TYPES type
	)
{
	ATLTRACE(_T("# CSnapinNode::CreatePropertyPages -- override in your derived class\n"));

	return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:QueryPagesFor

Determines whether the object requires pages.


HRESULT QueryPagesFor(  DATA_OBJECT_TYPES type  );


Parameters

	void


Return Value

	S_OK 
	Properties exist for this cookie.

	E_UNEXPECTED 
	An unexpected error occurred.

	E_INVALID 
	The parameter is invalid. 

	ISSUE: So what do we return if an item doesn't have property pages?  
		S_FALSE is used in sburns' localsec code

Remarks

	The console calls this method to determine whether the Properties menu 
	item should be added to the context menu.


  Override this in your derived class, if your object supports menu

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::QueryPagesFor( DATA_OBJECT_TYPES type )
{
	ATLTRACE(_T("# CSnapinNode::QueryPagesFor -- override in your derived class if you have property pages\n"));

	// this method should be overriden and should return S_OK if you
	// have property pages for this node otherwise it should return S_FALSE.

	return S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:InitDataClass

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
	// The default code stores off the pointer to the Dataobject the class is wrapping
	// at the time. 
	// Alternatively you could convert the dataobject to the internal format
	// it represents and store that information

	m_pDataObject = pDataObject;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetDisplayName

ISSUE: what are the parameters to this function?  Why not void?

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void* CSnapinNode<T, bIsExtension>::GetDisplayName()
{
	ATLTRACE(_T("# CSnapinNode::GetDisplayName\n"));

//		ISSUE: It looks as thought the m_SZDISPLAY_NAME is a totally
//		bogus variable -- we should think about eliminating it
//		Problematic -- const m_SZDISPLAY_NAME can't be localized
//		return (void*)m_SZDISPLAY_NAME;

	return (void*)m_bstrDisplayName;
}

//	void* GetSnapInCLSID()
//	{
//		ATLTRACE(_T("# CSnapinNode::GetSnapInCLSID\n"));
//
//		return (void*)m_SNAPIN_CLASSID;
//	}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetScopePaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetScopePaneInfo( SCOPEDATAITEM *pScopeDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetScopePaneInfo\n"));

	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetResultPaneInfo( RESULTDATAITEM *pResultDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneInfo\n"));

	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::Notify


This method is this node's response to the MMC calling Notify on 
IComponent or IComponentData.


STDMETHOD( Notify ) ( 
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type 
		
		
		)


Parameters 

	event 
	[in] Identifies an action taken by a user. IComponent::Notify and 
	IComponentData::Notify can receive the following notifications for a 
	specific node: 

		MMCN_ACTIVATE
		MMCN_ADD_IMAGES
		MMCN_BTN_CLICK
		MMCN_CLICK
		MMCN_CONTEXTMENU
		MMCN_DBLCLICK
		MMCN_DELETE
		MMCN_EXPAND
		MMCN_HELP
		MMCN_MENU_BTNCLICK
		MMCN_MINIMIZED
		MMCN_PROPERTY_CHANGE
		MMCN_REFRESH
		MMCN_REMOVE_CHILDREN
		MMCN_RENAME
		MMCN_SELECT
		MMCN_SHOW
		MMCN_VIEW_CHANGE
		MMCN_CONTEXTHELP

	See CSnapinNode::OnActivate, OnAddImages, OnButtonClick, etc. for
	a detailed explanation of each of these notify events

	arg 
	Depends on the notification type.

	param 
	Depends on the notification type. 


Return Values 

	S_OK 
	Depends on the notification type.

	E_UNEXPECTED 
	An unexpected error occurred. 


Remarks

	Our IComponentData and IComponent implementations were passed a LPDATAOBJECT 
	which corresponds to a node.  This was converted to a pointer to
	a node object.  Below is the Notify method on this node object, were
	the node object can deal with the Notify event itself.

	Our implementation of Notify is a large switch statement which delegates the
	task of dealing with virtual OnXxxxxx methods which can overridden in
	derived classes.  As all events are dealt with this way here, you shouldn't
	need to implement a Notify method for any of your derived nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>:: Notify ( 
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type
		)
{
	ATLTRACE(_T("# CSnapinNode::Notify\n"));

	HRESULT hr = S_FALSE;

	// this makes for faster code.
	T* pT = static_cast<T*> (this);



	switch( event )
	{

	case MMCN_ACTIVATE:
		hr = pT->OnActivate( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_ADD_IMAGES:
		hr = pT->OnAddImages( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_BTN_CLICK:
		hr = pT->OnButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CLICK:
		hr = pT->OnClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SNAPINHELP:
	case MMCN_CONTEXTHELP:
		hr = pT->OnContextHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CONTEXTMENU:
		hr = pT->OnContextMenu( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CUTORMOVE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, TRUE );
		break;

	case MMCN_DBLCLICK:
		hr = pT->OnDoubleClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_DELETE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, FALSE );
		break;

	case MMCN_EXPAND:
		hr = pT->OnExpand( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_HELP:
		hr = pT->OnHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MENU_BTNCLICK:
		hr = pT->OnMenuButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MINIMIZED:
		hr = pT->OnMinimized( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PASTE:
		hr = pT->OnPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PROPERTY_CHANGE:
		hr = pT->OnPropertyChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_QUERY_PASTE:
		hr = pT->OnQueryPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REFRESH:
		hr = pT->OnRefresh( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REMOVE_CHILDREN:
		hr = pT->OnRemoveChildren( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_RENAME:
		hr = pT->OnRename( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SELECT: 
		// For nodes with result-pane children
		hr = pT->OnSelect( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SHOW: 
		// For nodes with result-pane children
		// We call PreOnShow which will then call OnShow.
		// PreOnShow will save away the selected node in a member variable
		// of out CComponent class.
		//hr = pT->PreOnShow( arg, param, pComponentData, pComponent, type );
		hr = pT->OnShow( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_VIEW_CHANGE:
		hr = pT->OnViewChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_COLUMNS_CHANGED:
		hr = pT->OnColumnsChanged( arg, param, pComponentData, pComponent, type );
		break;

	default:
		// Unhandled notify event.
		//  MMC wants E_NOTIMPL if you can't do something or it will crash
		hr = E_NOTIMPL;
		break;

	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CSnapinNode 

Constructor

This class is to be the virtual base class for all our nodes
We never want people instantiating it so the constructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::CSnapinNode(CSnapInItem * pParentNode, CSnapin * pComponentData)
{
	ATLTRACE(_T("# +++ CSnapinNode::CSnapinNode\n"));

	// Set the parent node below which this node is displayed.
	m_pParentNode = pParentNode;

    // Set the componet data
    m_pComponentData = pComponentData;



	// We set cookie for both scope and result pane data items,
	// as this class can be subclassed for either a scope-pane
	// or a result-pane-only node.

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = 0;			// May need modification
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	// If this node is inserted in to the scope pane using
	// IConsoleNamespace->InsertItem, the value stored in lParam 
	// will be what MMC later passes back as the cookie for this node.
	m_scopeDataItem.lParam = (LPARAM) this;

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = 0;		// May need modification
	// If this node is inserted in to the result pane using 
	// IResultData->InsertItem, the value stored in lParam will
	// be what MMC later passes back as the cookie for this node.
	m_resultDataItem.lParam = (LPARAM) this;


}






//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:~CSnapinNode 

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::~CSnapinNode()
{
	ATLTRACE(_T("# --- CSnapinNode::~CSnapinNode\n"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneColInfo


  By default, we return the display name in the first column, and blank ("") 
  for other columns.
  Override in your derived class if you want more columns support
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
LPOLESTR CSnapinNode<T, bIsExtension>::GetResultPaneColInfo(int nCol)
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneColInf\n"));

	if (nCol == 0)
	{
		return m_bstrDisplayName;
	}

	// Return the blank for other columns
	return OLESTR(" ");
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnActivate

virtual HRESULT OnActivate(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_ACTIVATE 
Notify message is sent for this node.  

MMC sends this message to the snap-in's IComponent::Notify method when a window is 
being activated or deactivated.


Parameters

	arg 
	TRUE if the window is activated; otherwise, it is FALSE.

	param 
	Not used. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnActivate( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnActivate  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnAddImages

virtual HRESULT OnAddImages(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

We have chosen to handle this on a per-IComponent object basis, since it has
very little to do (for us at least) with the particular IDataObject.

See CComponent::OnAddImages for where we add images.


This method loads the default ImageList we have
Override this, if you want different imagelist

By default, Loads specific images for this project

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnAddImages( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnAddImages  -- Override in your derived class\n"));
    HRESULT hr;

	IImageList* pImageList = (IImageList*) arg;
	hr = E_FAIL;
	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap16 != NULL)
	{
		CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_32x32));
		if (hBitmap32 != NULL)
		{
			hr = pImageList->ImageListSetStrip(
								reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
								reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32), 
								0, 
								RGB(0, 128, 128)
								);
			if (FAILED(hr))
				ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		}
	}
	return(hr);
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnButtonClick

virtual HRESULT OnButtonClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_BTN_CLICK Notify message is 
sent for this node.  

MMC sends this message to the snap-in's IComponent, IComponentData, 
or IExtendControlbar implementation when a user clicks on one of the 
toolbar buttons.


Parameters

For IComponent::Notify or IComponentData::Notify:

	arg 
	Must be zero.

	param 
	CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration. 

For IExtendControlBar::ControlbarNotify:

	arg 
	Data object of the currently selected scope or result pane item.

	param 
	[in] CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnButtonClick( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnClick

virtual HRESULT OnClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CLICK Notify message is 
sent for this node.  

MMC sends this message to IComponent when a user clicks a mouse button 
on a list view item.


Parameters

 	arg 
	Not used.

	param 
	Not used. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnClick( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::GetHelpLink

virtual CString GetHelpLink(	
	VOID
	)

	Called when user requests help about a selected item


Parameters

	arg 
	0.

	param 
	0. 


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CString CSnapinNode<T, bIsExtension>::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_GENERAL); // sag_MSMQtopnode.htm

	return strHelpLink;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextHelp

virtual HRESULT OnContextHelp(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CONTEXTHELP Notify message is 
sent for this node.  

MMC sends this message when the user requests help about a selected item


Parameters

	arg 
	0.

	param 
	0. 


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextHelp( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    //
    // Get Display help interface
    //
	CComPtr<IConsole> spConsole;
 	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
        //
		// We should have a non-null pComponent
        //
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

    CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> spDisplayHelp(spConsole);
    _ASSERTE( spDisplayHelp != NULL );

    if (spDisplayHelp == NULL)
    {
        return E_FAIL;
    }

    //
    // construct help topic path = (help file::topic string)
    //
    CString strTopicPath;
    CString strHelpTopic;

    CString strHelpPath;
    strTopicPath.LoadString(IDS_HTMLHELP_NAME); // \help\msmqconcepts.chm

	strHelpTopic = GetHelpLink();

    strTopicPath += _T("::/");
    strTopicPath += strHelpTopic;           // \help\msmqconcepts.chm::/sag_MSMQtopnode.htm

    return spDisplayHelp->ShowTopic(strTopicPath.AllocSysString());
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextMenu

virtual HRESULT OnContextMenu(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CONTEXTMENU Notify 
message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as not used. 


Parameters

	arg 
	TBD

	param 
	TBD 

Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextMenu( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnContextMenu  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDoubleClick

virtual HRESULT OnDoubleClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_DBLCLICK Notify message is 
sent for this node.  

MMC sends this message to IComponent when a user double clicks a mouse 
button on a list view item.


Parameters

	arg 
	Not used.

	param 
	Not used. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDoubleClick( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnDoubleClick  -- Override in your derived class if you don't want default verb action\n"));

	// Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
	// here, the default verb action will occur when the user double clicks on a node.
	// For the most part we have Properties as default verb, so a double click
	// will cause property sheet on a node to pop up.
//		return E_NOTIMPL;
	return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDelete

virtual HRESULT OnDelete(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_DELETE Notify
message is sent for this node.  

MMC sends this message to the snap-in's IComponent and IComponentData implementation to inform the snap-in that the object should be deleted.


Parameters

	arg 
	Not used.

	param 
	Not used. 

Return Values

	Not used.


Remarks

	This message is generated when the user presses the delete key or uses
	the mouse to click on the toolbar's delete button.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDelete( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			, BOOL fSilent
			)
{
	ATLTRACE(_T("# CSnapinNode::OnDelete  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnExpand

virtual HRESULT OnExpand(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

If your node will have scope-pane children, 
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_EXPAND Notify message is 
sent for this node.  

MMC sends this message to the snap-in's IComponentData 
implementation when a folder node needs to be expanded or contracted.


Parameters

	arg 
	[in] If TRUE, the folder needs to be expanded. If FALSE, the folder needs to be contracted.

	Param 
	[in] The HSCOPEITEM of the item that needs to be expanded. 


Return Values

	HRESULT


Remarks

	On receipt of this notification the snap-in should enumerate the 
	children (sub-containers only) of the specified scope item, if any, 
	using IConsoleNameSpace methods. Subsequently, if a new item is added to 
	or deleted from this scope object through some external means, then 
	that item should also be added to or deleted from the console's 
	namespace using IConsoleNameSpace methods.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnExpand(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnExpand  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnHelp

virtual HRESULT OnHelp(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_HELP Notify 
message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as not used. 

MMC sends this message when the user presses the F1 help key. 


Parameters

	arg 
	TBD

	param 
	Pointer to a GUID. If NULL, the NodeType is used instead. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnHelp(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnHelp  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMenuButtonClick

virtual HRESULT OnMenuButtonClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)


In our implementation, this method gets called when the MMCN_MENU_BTNCLICK Notify
message is sent for this node.  

MMC sends this ify message is sent Sent to the snap-in's IExtendControlbar 
interface when a user clicks on a menu button.


Parameters

	arg 
	Data object of currently selected scope or result pane item. 

	param 
	[in] Pointer to a MENUBUTTONDATA structure. 


Return Values
	
	  Not Used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMenuButtonClick( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnMenuButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMinimized

virtual HRESULT OnMinimized(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)


In our implementation, this method gets called when the MMCN_MINIMIZED Notify message is 
sent for this node.  
  
MMC sends this message to the snap-in's IComponent implementation when 
a window is being minimized or maximized.


Parameters

	arg 
	TRUE if the window has been minimized; otherwise, it is FALSE.

	Param 
	Not used. 


Return Values

  Not Used


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMinimized( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnMinimized  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPaste

virtual HRESULT OnPaste(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_PASTE 
Notify message is sent for this node.  

Called to ask the snap-ins folder to paste the selected items. 


Parameters

	pDataobject 
	The data object in which to paste the selected items provided by the snap-in. 
	arg 
	The data object of the selected item(s) provided by the source snap-in that need to be pasted. 
	param 
	NULL for move (as opposed to cut). 
	For a single-item paste: 

	BOOL* pPasted = (BOOL*)param; Set this to TRUE here if the item was successfully pasted. 

	For a multiitem paste: 

	LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param; 

	Use this to return a pointer to a data object consisting of the items successfully pasted. See MMCN_CUTORMOVE.


Return Values
	
	Not used.


See Also
	
	MMCN_CUTORMOVE 

 
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPaste( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPropertyChange

virtual HRESULT OnPropertyChange(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_PROPERTY_CHANGE 
Notify message is sent for this node.  

When the snap-in uses the MMCPropertyChangeNotify function to notify it's 
views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's 
IComponentData and IComponent implementations.


Parameters

	arg 
	[in] TRUE if the property change is for a scope pane item.

	lParam 
	This is the param passed into MMCPropertyChangeNotify. 


Return Values
	
	  Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPropertyChange( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnPropertyChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnQueryPaste

virtual HRESULT OnQueryPaste(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_QUERY_PASTE
Notify message is sent for this node.  

Sent to the snap-in before pasting into the snap-in's folder to determine if the 
snap-in can accept the data. 


Parameters

	pdataobject 
	The dataobject of the selected item provided by the snap-in. 
	arg 
	The dataobject of the item(s) provided by the source snap-in that need to be pasted. 
	param 
	Not used. 

  
Return Values

	Not used.


See Also

	MMCN_PASTE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnQueryPaste( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnQueryPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRefresh

virtual HRESULT OnRefresh(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as TBD.


Parameters


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRefresh( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRefresh  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRemoveChildren

virtual HRESULT OnRemoveChildren(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_REMOVE_CHILDREN 
Notify message is sent for this node.  

MMC sends this message to the snap-in's IComponentData implementation to inform 
the snap-in that it must delete all the cookies (the entire subtree) it has 
added below the specified node.


Parameters

	arg 
	Specifies the HSCOPEITEM of the node whose children need to be deleted.

	param 
	Not used. 


Return Values
	
	  Not used.


Remarks

  	Use IConsoleNameSpace methods GetChildItem and GetNextItem to traverse
	the tree and determine the cookies to be deleted.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRemoveChildren  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRename

virtual HRESULT OnRename(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_RENAME Notify 
message is sent for this node.  
	
ISSUE: I do not seem to be seeing the two-call behaviour documented below

MMC sends this message the first time to query for a rename and the 
second time to do the rename. 


Parameters

	arg 
	Not used. 

	param 
	LPOLESTR for containing the new name. 

Return Values

	S_OK 
	Allows the rename.

	S_FALSE 
	Disallows the rename. 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRename( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRename  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnSelect

virtual HRESULT OnSelect(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

You shouldn't need to override this method.  The OnSelect method has common 
behaviour for all nodes, only the verbs to be set are different.  Rather 
than overriding OnSelect in each node, simply override SetVerbs, which this
implementation of OnSelect calls.

In our implementation, this method gets called when the MMCN_SELECT Notify message is 
sent through IComponent::Notify for this node.  

Note: MMC also sends the MMCN_SELECT message through IExtendControlbar::ControlbarNotify
but we don't respond to that here -- See CSnapInItem::ControlbarNotify for that.


Parameters

For IComponent::Notify:

	arg 
	BOOL bScope = (BOOL) LOWORD(arg);
	BOOL bSelec = (BOOL) HIWORD(arg); 

	bScope
	TRUE if an item in the scope pane is selected.
	FALSE if an item in the result view pane is selected.

	bSelect 
	TRUE if the item is selected. 
	FALSE if the item is deselected.

	param 
	This parameter is ignored. 

Return Values

	Not used.


Remarks

	When an IComponent::Notify method receives the MMCN_SELECT notification
	it should update the standard verbs. 

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnSelect( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnSelect\n"));

	
	
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;
	CComPtr<IConsoleVerb> spConsoleVerb;

	BOOL bSelected = (BOOL) HIWORD( arg );

	if( bSelected )
	{

		// Need IConsoleVerb

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );

		hr = spConsole->QueryConsoleVerb( &spConsoleVerb );
		_ASSERT( SUCCEEDED( hr ) );

		hr = SetVerbs( spConsoleVerb );

	}
	else
	{

		// Anything to do here? Don't think so -- see sburns localsec example.

		hr = S_OK;

	}


	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::SetVerbs

virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb )

Override this method in your derived class.

This method is called by our default implementation of OnSelect 
when the verbs for this node need to be set.

Parameters

	IConsoleVerb * pConsoleVerb


Return Values

	HRESULT


Remarks

	The OnSelect method has common behaviour for all nodes, only the verbs 
	to be set are different.  Rather than duplicate code by implementing OnSelect
	in each node, simply override this SetVerbs method

	Every time an item is selected, the verb states for all the commands 
	are returned to disabled and visible. It is up to the snap-in writer 
	to use IConsoleVerb to update the verb state every time an item is selected.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::SetVerbs( IConsoleVerb * pConsoleVerb )
{
	ATLTRACE(_T("# CSnapinNode::SetVerbs -- Override in your derived class\n"));

	HRESULT hr = S_OK;

	// Override in your derived class and do something like:
/*		
	// We want the user to be able to choose properties on this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

	// We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

	// We want the user to be able to rename this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
*/	
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::PreOnShow

virtual HRESULT PreOnShow(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

We call this instead of OnShow, so that we can save away the selected node.

This method will then just call OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::PreOnShow( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::PreOnShow  -- Don't override in your derived class\n"));


	if( NULL != pComponent )
	{

		CSnapinComponent * pMyComponent = static_cast<CSnapinComponent *>( pComponent );

		if( arg ) 
		{
			// We are being selected.

			// Save our 'this' pointer as the currently selected node for this result view.  
			pMyComponent->m_pSelectedNode = static_cast<CSnapInItem *>( this );

		}
		else
		{
			// We are being deselected.

			// Check to make sure that our result view doesn't think
			// this node is the currently selected one.
			if( pMyComponent->m_pSelectedNode == static_cast<CSnapInItem *>( this ) )
			{
				// We don't want to be the selected node anymore.
				pMyComponent->m_pSelectedNode = NULL;
			}

		}

	}

	return OnShow( arg, param, pComponentData, pComponent, type );
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnShow

virtual HRESULT OnShow(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

If your node will have result-pane children, 
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_SHOW Notify message is 
sent for this node.  

MMC sends this message when a scope item is selected or deselected for the 
first time. 


Parameters

	arg 
	TRUE (<>0 ) if selecting; True indicates that the snap-in should set 
	up the result pane and add the enumerated items. 
	FALSE (0) if deselecting. indicates that the snap-in is going out of 
	focus and that it should clean up all cookies the right hand side 
	(the result pane), because current result pane will be replaced by a new one.

	param 
	The HSCOPEITEM of the selected or deselected item. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnShow( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnShow  -- Override in your derived class\n"));

	// Returning E_NOTIMPL seems to be a bad thing here.  
	// It caused all kinds of problems with toolbar buttons persisting to
	// the wrong node, as well as verbs not getting set correctly for nodes.
	// Basically, if you don't respond with S_OK to the MMCN_SHOW notification,
	// you won't get sent the appropriate MMCN_SELECT notification.
	// return E_NOTIMPL;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnViewChange

virtual HRESULT OnViewChange(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_VIEW_CHANGE Notify 
message is sent for this node.  

MMC sends this message to the snap-in's IComponent implementation so it 
can update all views when a change occurs.  This node data object passed 
to IConsole::UpdateAllViews.


Parameters

	arg 
	[in] The data parameter passed to IConsole::UpdateAllViews.

	param 
	[in] The hint parameter passed to IConsole::UpdateAllViews. 


Return Values

	Not used.


Remarks

	This notification is generated when the snap-in (IComponent or
	IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnViewChange( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnViewChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}
/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnColumnsChanged

virtual HRESULT OnColumnsChanged(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_COLUMNS_CHANGED Notify 
message is sent for this node.  

MMC sends this message to the snap-in's IComponent implementation when some of the columns were
changed. By default, we return S_OK - meaning that the change is accepted. In result,
MMC will actually update the columns.
To prevent MMC from updating the columns, return E_UNEXPECTED.


Parameters

	arg 
	[in] Not used.

	param 
	[in] pointer to MMC_VISIBLE_COLUMNS structure.


Return Values

	S_OK to accept the changes, E_UNEXPECTED to reject them.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnColumnsChanged( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::OnColumnsChanged  -- Override in your derived class\n"));

	//
	// By default - accept the columns change
	//
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::TaskNotify

Called when MMC wants to notify us that the user clicked on a task 
on a taskpad belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::TaskNotify(
			  IDataObject * pDataObject
			, VARIANT * pvarg
			, VARIANT * pvparam
			)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::TaskNotify\n"));

}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::EnumTasks

Called when MMC wants us to enumerate the tasks	on a taskpad 
belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::EnumTasks(
			  IDataObject * pDataObject
			, BSTR szTaskGroup
			, IEnumTASK** ppEnumTASK
			)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::EnumTasks\n"));
}






#endif // _SNAPIN_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpnres.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpres.h

Abstract:

	This is the header file for CNodeWithResultChildrenList, a class which 
	implements a node that has a list of scope pane children.

	This is an inline template class.
	Include NodeWithScopeChildrenList.cpp in the .cpp files
	of the classes in which you use this template.

Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Support for Extension snapins 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_RESULT_CHILDREN_LIST_H_)
#define _NODE_WITH_RESULT_CHILDREN_LIST_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>			// for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T, class CChildNode, class TArray, BOOL bIsExtension>
class CNodeWithResultChildrenList : public CSnapinNode< T, bIsExtension>
{

	// Constructor/Destructor

public:
	CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);
	~CNodeWithResultChildrenList();


	// Child list management.

public:
	// Flag indicating whether list has been initially populated
	BOOL m_bResultChildrenListPopulated;

protected:
	// Override these in your derived classes
	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
   	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );
	virtual HRESULT PopulateResultChildrenList(void );

	// Stuff which must be accessible to subclasses.  These methods shouldn't need to be overidden.
	virtual HRESULT RepopulateResultChildrenList(void);
	
	virtual HRESULT AddChildToList( CChildNode * pChildNode );

	virtual HRESULT EnumerateResultChildren( IResultData * pResultData );

	// Array of pointers to children nodes.
	// This is protected so that it can be visible in the derived classes.
 	TArray m_ResultChildrenList;


	// Overrides for standard MMC functionality.	
public:
    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild( CChildNode * pChildNode );

	virtual HRESULT OnShow(	
					  LPARAM arg
					, LPARAM param
					, IComponentData * pComponentData
					, IComponent * pComponent
					, DATA_OBJECT_TYPES type 
					);
	virtual HRESULT OnRefresh(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);


};


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate 
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::InsertColumns -- override in your derived class\n"));
	

	// Check for preconditions:
	_ASSERTE( pHeaderCtrl );


	HRESULT hr;

	// override in your derived class and do something like:
	hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
	_ASSERT( S_OK == hr );

	hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
	_ASSERT( S_OK == hr );

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if you want to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnUnSelect -- override in your derived class\n"));
	

	//
	// Check for preconditions:
	//
	ASSERT( pHeaderCtrl != NULL );

	//
	// Delete result pane columns
	//
	while(SUCCEEDED(pHeaderCtrl->DeleteColumn(0)))
	{
		NULL;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::PopulateResultChildrenList

Override this in your derived class.

This is called by EnumerateResultChildren which is called by OnShow when
you need to populate the list of children of this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::PopulateResultChildrenList( void )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::PopulateResultChildrenList -- override in your derived class\n"));
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RepopulateResultChildrenList

DON'T Override this in your derived class.

Call this to empty the list of children and repopulate it.
This method will call PopulateResultChildrenList, which you should override.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RepopulateResultChildrenList(void)
{

	// Check for preconditions:
	// None.


	HRESULT hr;

	// Get rid of what we had.

	// Delete each node in the list of children
	int iSize = m_ResultChildrenList.GetSize();
	for (int i = 0; i < iSize; i++)
	{
		R<CChildNode> pChildNode = m_ResultChildrenList[i];
	}

	// Empty the list
	m_ResultChildrenList.RemoveAll();


	// We no longer have a populated list.
	m_bResultChildrenListPopulated = FALSE;


	// Repopulate the list.
	hr = PopulateResultChildrenList();
	if( FAILED(hr) )
	{
		return( hr );
	}

	// We've already loaded our children ClientNode objects with
	// data necessary to populate the result pane.
	m_bResultChildrenListPopulated = TRUE;	// We only want to do this once.

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::CNodeWithResultChildrenList

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode, TArray,bIsExtension>::CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): CSnapinNode<T,bIsExtension>(pParentNode, pComponentData)
{
	ATLTRACE(_T("# +++ CNodeWithResultChildrenList::CNodeWithResultChildrenList\n"));
	

	// Check for preconditions:
	// None.


	// We have not yet loaded the child nodes' data
	m_bResultChildrenListPopulated = FALSE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::~CNodeWithResultChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::~CNodeWithResultChildrenList()
{
	ATLTRACE(_T("# --- CNodeWithResultChildrenList::~CNodeWithResultChildrenList\n"));
	

	// Check for preconditions:
	// None.



	// Delete each node in the list of children
	int iSize = m_ResultChildrenList.GetSize();
	for (int i = 0; i < iSize; i++)
	{
		R<CChildNode> pChildNode = m_ResultChildrenList[i];
	}

	// Empty the list
	m_ResultChildrenList.RemoveAll();

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddChildToList

Adds a child to the list of children.  Does not cause a view update.

Use this in your PopulateResultChildrenList method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, bIsExtension>::AddChildToList( CChildNode * pChildNode )
{
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;
	
	if( m_ResultChildrenList.Add(pChildNode ) )
	{

		hr = S_OK;

	}
	else
	{
		// Failed to add => out of memory
		hr = E_OUTOFMEMORY;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods 
which it calls: InsertColumns and (indirectly) PopulateResultChildrenList

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node, we are to add children into the 
result pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnShow(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				)
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnShow\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;

	T * pT = static_cast<T*>( this );


	// Need IHeaderCtrl.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
	_ASSERT( spHeaderCtrl != NULL );

	if( arg ) 
	{

		// arg <> 0 => we are being selected.

		// Note: This method will only get called with 
		// arg <> 0 (i.e. selected) if you responded appropriately to
		// the MMCN_ADD_IMAGES method

		// We have been asked to display result pane nodes belonging under this node.

		// It appears we must do IResultData->InsertItems each time we receive 
		// the MMCN_SHOW message -- MMC doesn't remember what nodes
		// we have previously inserted.

		
		// Set the column headers in the results pane
		// Note: if you don't set these, MMC will never 
		// bother to put up your result-pane only items

		// When this Notify method is called from IComponentDataImpl, we 
		// get pHeader (and pToolbar) passed in as NULL, so we aren't
		// going to bother using it and will instead always
		// QI pConsole for this pointer
		

		// 
		// In some cases MMC calls us twice with same IHeaderCtrl. try to delete 
		// previous colums
		//					Uri Habusha, 28-Jan-2001
		//
		while(SUCCEEDED(spHeaderCtrl->DeleteColumn(0)))
		{
			NULL;
		}

		hr = pT->InsertColumns( spHeaderCtrl );
		ASSERT( S_OK == hr );

		// Display our list of children in the result pane

		// Need IResultData
		CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
		_ASSERT( spResultData != NULL );

		hr = pT->EnumerateResultChildren(spResultData );
    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
	}

	return hr;


}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnRefresh(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnRefresh\n"));
	
	//
	// Before calling RepopulateResultChildrenList ensures that MMC release all reference to 
	// the result pane items in all views. It can't be done directly since in this stage we
	// don't have an access to result data in all view. UpdateAllViews reach to 
	// CSnapinComponent::notify with MMCN_VIEW_CHANGE event. If the param value is 
	// UPDATE_REMOVE_ALL_RESULT_NODES the routine only deletes all the items in the current view
	// 
    HRESULT hr = m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, UPDATE_REMOVE_ALL_RESULT_NODES);
    ASSERT(("UpdateAllView Failed", SUCCEEDED(hr)));

	// Rebuild our list of nodes from the uderlying data source.
	T * pT = static_cast<T*> (this);
	hr = pT->RepopulateResultChildrenList();
	

	// Update the views.

	// We weren't passed an IConsole pointer here, so 
	// we use the one we saved in out CComponentData object.
	_ASSERTE( m_pComponentData != NULL );
	_ASSERTE( m_pComponentData->m_spConsole != NULL );

	// We pass in a pointer to 'this' because we want each
	// of our CComponent objects to update its result pane
	// view if 'this' node is the same as the saved currently
	// selected node.
	m_pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM)this, NULL);

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::EnumerateResultChildren

Don't override this in your derived class. Instead, override the method 
it calls, PopulateResultChildrenList.  

This is called by the OnShow method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::EnumerateResultChildren( IResultData * pResultData )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::EnumerateResultChildren\n"));
	

	// Check for preconditions:
	_ASSERTE( pResultData != NULL );


	HRESULT hr = S_OK;

	T * pT = static_cast<T*> (this);

	if ( FALSE == m_bResultChildrenListPopulated )
	{
		// We have not yet loaded all of our children into our list.
		// This call will add items to the list from whatever data source.
		hr = pT->PopulateResultChildrenList();
		if( FAILED(hr) )
		{
			return( hr );
		}

		// We've already loaded our children ClientNode objects with
		// data necessary to populate the result pane.
		m_bResultChildrenListPopulated = TRUE;	// We only want to do this once.

	}


	// From MeanGene's Step4 -- need to first remove all items from result pane
	hr = pResultData->DeleteAllRsltItems();
	if( FAILED(hr) )
	{
		return hr;
	}

	// The ResultChildrenList is already populated, so we
	// just need to show the CChildNode objects to the world
	// by populating the result pane.

	CChildNode* pChildNode;
	for (int i = 0; i < m_ResultChildrenList.GetSize(); i++)
	{
		pChildNode = m_ResultChildrenList[i];
		if ( NULL == pChildNode )
		{
			continue;
		}

		// Insert the item into the result pane.
		hr = pResultData->InsertItem( &(pChildNode->m_resultDataItem) );
		if (FAILED(hr))
		{
			return hr;
		}

		// Check: On return, the itemID member of 'm_resultDataItem' 
		// contains the handle to the newly inserted item.
		_ASSERT( NULL != pChildNode->m_resultDataItem.itemID );
	
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RemoveChild

Removes a child from the list of children.

This is declared public because it must be accessed from a child node when that
node receives the MMCN_DELETE message and tries to delete itself.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RemoveChild( CChildNode * pChildNode )
{
	ATLTRACE(_T("CNodeWithResultChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Remove( pChildNode ) )
    {

        // We don't remove the item directly from the result pane now
        // using IResultData->RemoveItem, as we have no way of
        // removing it from all the possible views.
        // Instead, we call IConsole->UpdateAllViews which will
        // cause MMC to call Notify on each of our IComponent objects
        // with the MMCN_VIEW_CHANGE notification, and we will
        // repopulate the result view when we handle that notification.

        // We weren't passed an IConsole pointer here, so
        // we use the one we saved in out CComponentData object.
        _ASSERTE( m_pComponentData != NULL );
        _ASSERTE( m_pComponentData->m_spConsole != NULL );

        // We pass in a pointer to 'this' because we want each
        // of our CComponent objects to update its result pane
        // view if 'this' node is the same as the saved currently
        // selected node.
        m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );
        hr = S_FALSE;
    }

    return hr;
}

#endif // _NODE_WITH_RESULT_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpnscp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    NodeWithScopeChildrenList.h

Abstract:

	This is the header file for CNodeWithScopeChildrenList, a class which 
	implements a node that has a list of scope pane children.

	This is an inline template class.
	Include NodeWithScopeChildrenList.cpp in the .cpp files
	of the classes in which you use this template.

Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Support for Extension snapins 
    Enables multiple class of childs

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_SCOPE_CHILDREN_LIST_H_)
#define _NODE_WITH_SCOPE_CHILDREN_LIST_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>			// for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



template <class T,BOOL bIsExtension>
class CNodeWithScopeChildrenList : public CSnapinNode< T, bIsExtension >
{

public:

	
	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::AddChild

	Adds a child to the list of children.

	This has to be public as it must be accessible even from a separate dialog
	(e.g. a Connect to Server dialog) that may want to add a child.

	Here we add the child item to the list of children and call InsertItem
	to add the child to the scope pane.

	This is one difference between adding nodes into the scope
	pane and the result pane.  When we were inserting a child into
	the result pane, we didn't call InsertItem in the AddChild methods(s)
	because we needed to worry about sending an UpdataAllViews
	notification and repopulating the result pane in each view.
	
	Because MMC takes care of replicating scope pane changes to all views, 
	we don't need to worry about this.  Instead, we just do InsertItem once here.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT AddChild(CSnapInItem * pChildNode, SCOPEDATAITEM* pScopeDataItem);



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::RemoveChild

	Removes a child from the list of children.

	This has to be public so that child nodes can ask their parent to be deleted
	from the list of children when they receive the MMCN_DELETE notification.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	// virtual HRESULT RemoveChild(CSnapInItem * pChildNode );



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnShow

	Don't override this in your derived class.  Instead, override methods
	which it calls: InsertColumns 

	This method is an override of CSnapinNode::OnShow.  When MMC passes the
	MMCN_SHOW method for this node.
	
	For more information, see CSnapinNode::OnShow.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnShow(	
					  LPARAM arg
					, LPARAM param
					, IComponentData * pComponentData
					, IComponent * pComponent
					, DATA_OBJECT_TYPES type 
					);

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnRefresh

    You shouldn't need to override this in your derived method.  Simply
    enable the MMC_VERB_REFRESH for your node.

    In our implementation, this method gets called when the MMCN_REFRESH
    Notify message is sent for this node.  

    For more information, see CSnapinNode::OnRefresh.


	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnRefresh(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildren::OnExpand

	Don't override this in your derived class.  Instead, override methods 
	which it calls: PopulateScopeChildrenList

	This method is an override of CSnapinNode::OnExpand.  When MMC passes the
	MMCN_EXPAND method for this node, we are to add children into the 
	scope pane.  In this class we add them from a list we maintain.
	
	For more information, see CSnapinNode::OnExpand.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnExpand(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	



protected:

    // The ScopeChild structure contains all the information needed to modify or remove a node
    // in the scope pane: A pointer to CSnapinItem (needs to be freed) and a scope item id
    // that can be used to modify or remove the node itself
    struct ScopeChild
    {
        CSnapInItem *pChildNode;
        HSCOPEITEM  ID;
    };

	// Array of scope items representing children nodes
	CSimpleArray<ScopeChild> m_ScopeChildrenList;

	// Flag indicating whether list has been initially populated
	BOOL m_bScopeChildrenListPopulated;


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

	Constructor

	This is an base class which we don't want instantiated on its own,
	so the contructor is protected

	--*/
	//////////////////////////////////////////////////////////////////////////////
	CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

	Destructor

	--*/
	//////////////////////////////////////////////////////////////////////////////
	~CNodeWithScopeChildrenList();



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::PopulateScopeChildrenList

	Override this in your derived class to populate the list of children nodes.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT PopulateScopeChildrenList();

	// override in your derived class and do something like:

/*
	virtual HRESULT PopulateScopeChildrenList( void )
	{
		CSomeChildNode *myChild1 = new CSomeChildNode();
		AddChild(myChild1);
	
		CSomeChildNode *myChild2 = new CSomeChildNode();
		AddChild(myChild2);
	
		CSomeChildNode *myChild3 = new CSomeChildNode();
		AddChild(myChild3);

		return S_OK;
	}
*/

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::InsertColumns

	Override this in your derived class.

	This method is called by OnShow when it needs you to set the appropriate 
	column headers to be displayed in the result pane for this node.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );


	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnUnSelect

    Override this in your derived class.

    This method is called by OnShow when the node is unselected.
    Useful to overidde this if to retreive columns header width for example

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::EnumerateScopeChildren

	Don't override this in your derived class. Instead, override the method 
	it calls, PopulateScopeChildrenList.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace );
};




//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::AddChild

Adds a child to the list of children.

This has to be public as it must be accessible even from a separate dialog
(e.g. a Connect to Server dialog) that may want to add a child.

Here we add the child item to the list of children and call InsertItem
to add the child to the scope pane.

This is one difference between adding nodes into the scope
pane and the result pane.  When we were inserting a child into
the result pane, we didn't call InsertItem in the AddChild methods(s)
because we needed to worry about sending an UpdataAllViews
notification and repopulating the result pane in each view.

Because MMC takes care of replicating scope pane changes to all views, 
we don't need to worry about this.  Instead, we just do InsertItem once here.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::AddChild(
                                             CSnapInItem*       pChildNode,
                                             SCOPEDATAITEM*     pScopeDataItem)
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::AddChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;

    //
    // Get the Console
    //
    CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> spConsoleNameSpace(m_pComponentData->m_spConsole); 


	// We hand our HSCOPEITEM as the parent ID for this child.
    pScopeDataItem->relativeID = (HSCOPEITEM) m_scopeDataItem.ID;


	hr = spConsoleNameSpace->Expand(m_scopeDataItem.ID);
	if ( hr == S_OK )
	{
		//
		// Do not insert new item if the node was not expanded yet.
		// OnExpand() calls populate function, and the new object will 
		// be showed twice. In order to avoid it, we return here.
		delete pChildNode;
		return hr;
	}

	hr = spConsoleNameSpace->InsertItem(pScopeDataItem);
	if (FAILED(hr))
	{
		delete pChildNode;
		return hr;
	}

	// Check: On return, the ID member of 'm_scopeDataItem' 
	// contains the handle to the newly inserted item.
	_ASSERT( NULL != pScopeDataItem->ID);

    // scopeChild item is created added to the list to allow deletion 
    // or modification of the object
    ScopeChild scopeChild = {pChildNode, pScopeDataItem->ID};
    if( 0 == m_ScopeChildrenList.Add( scopeChild ) )
    {
		// Failed to add => out of memory
        spConsoleNameSpace->DeleteItem(pScopeDataItem->ID, TRUE);
        hr = E_OUTOFMEMORY;
    }

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::RemoveChild

Removes a child from the list of children.

This has to be public so that child nodes can ask their parent to be deleted
from the list of children when they receive the MMCN_DELETE notification.

--*/
//////////////////////////////////////////////////////////////////////////////
/*
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::RemoveChild(CSnapInItem * pChildNode )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::RemoveChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;


	if( m_ScopeChildrenList.Remove(pChildNode ) )
	{
        //
        // Need IConsoleNameSpace
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 
		
        //
        // Need to see if this works because of multi node scope
        //

        //hr = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE ); 


		if (FAILED(hr))
		{
			return hr;
		}

	}
	else
	{
		// If we failed to remove, probably the child was never in the list
		// ISSUE: determine what do here -- this should never happen
		_ASSERTE( FALSE );

		hr = S_FALSE;
	}

	return hr;
}
*/


/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

Constructor

This is an base class which we don't want instantiated on its own,
so the contructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T,bIsExtension>::CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): 
                CSnapinNode< T, bIsExtension >(pParentNode, pComponentData)
{
	ATLTRACE(_T("# +++ CNodeWithScopeChildrenList::CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.


	// We have not yet loaded the child nodes' data
	m_bScopeChildrenListPopulated = FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T, bIsExtension>::~CNodeWithScopeChildrenList()
{
	ATLTRACE(_T("# --- CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.



	// Delete each node in the list of children
	for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
	{
        delete m_ScopeChildrenList[i].pChildNode;
        m_ScopeChildrenList[i].pChildNode = 0;
	}

	// Empty the list
	m_ScopeChildrenList.RemoveAll();

}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::PopulateScopeChildrenList

Override this in your derived class to populate the list of children nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::PopulateScopeChildrenList()
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::PopulateScopeChildren -- override in your derived class\n"));
		

	// Check for preconditions:
	// None.


	// override in your derived class and do something like:
/*
	CSomeChildNode *myChild1 = new CSomeChildNode();
	m_CChildrenList.Add(myChild1);

	CSomeChildNode *myChild2 = new CSomeChildNode();
	m_CChildrenList.Add(myChild2);

	CSomeChildNode *myChild3 = new CSomeChildNode();
	m_CChildrenList.Add(myChild3);
*/
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns 

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::OnShow(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				)
{
	ATLTRACE(_T("# CNodeScopeChildrenList::OnShow\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;



	// Need IHeaderCtrl.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
	_ASSERT( spHeaderCtrl != NULL );

	if( arg ) 
	{
		// 
		// In some cases MMC calls us twice with same IHeaderCtrl. try to delete 
		// previous colums
		//					Uri Habusha, 28-Jan-2001
		//
		while(SUCCEEDED(spHeaderCtrl->DeleteColumn(0)))
		{
			NULL;
		}

		// arg <> 0 => we are being selected.
		hr = InsertColumns( spHeaderCtrl );
		_ASSERT( S_OK == hr );

	}
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
    }

	return hr;


}

/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::OnRefresh(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::OnRefresh\n"));

	HRESULT hr;

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 


    // Get rid of what we had.
    // Calling DeleteItem with FALSE deletes all the child objects of the current 
    // node but does not delete the current node itself.
    hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, FALSE ); 
	if (FAILED(hr))
	{
		return hr;
	}

	// Free the memory allocated for each child
	for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
	{
        delete m_ScopeChildrenList[i].pChildNode;
        m_ScopeChildrenList[i].pChildNode = 0;
	}

	// Empty the list
	m_ScopeChildrenList.RemoveAll();


	// Repopulate the children list: Unst the flag, fill the list with data,
    // reset the flag
	m_bScopeChildrenListPopulated = FALSE;
	hr = PopulateScopeChildrenList();
	if( FAILED(hr) )
	{
		return( hr );
	}
	m_bScopeChildrenListPopulated = TRUE;
	
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate 
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::InsertColumns -- override in your derived class\n"));
	

	// Check for preconditions:
	_ASSERTE( pHeaderCtrl != NULL );


	HRESULT hr;

	// override in your derived class and do something like:
	hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
	_ASSERT( S_OK == hr );

	hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
	_ASSERT( S_OK == hr );

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::OnUnSelect -- override in your derived class\n"));
	
	//
	// Check for preconditions:
	//
	ASSERT( pHeaderCtrl != NULL );

	//
	// Delete result pane columns
	//
	while(SUCCEEDED(pHeaderCtrl->DeleteColumn(0)))
	{
		NULL;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildren::OnExpand

Don't override this in your derived class.  Instead, override methods 
which it calls: PopulateScopeChildrenList

This method is an override of CSnapinNode::OnExpand.  When MMC passes the
MMCN_EXPAND method for this node, we are to add children into the 
scope pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnExpand.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnExpand(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CNodeWithScopeChildren::OnExpand\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );



	HRESULT hr = S_FALSE;

	if( TRUE == arg )
	{

		// Need IConsoleNameSpace

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );


		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
		_ASSERT( spConsoleNameSpace != NULL );

        if(bIsExtension)
        {
            //
            // For extensions, keep the scope
            //
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }

		hr = EnumerateScopeChildren( spConsoleNameSpace );

	}
	else	// arg != TRUE so not expanding
	{

		// do nothing for now -- I don't think arg = FALSE is even implemented 
		// for MMC v. 1.0 or 1.1

	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::EnumerateScopeChildren

Don't override this in your derived class. Instead, override the method 
it calls, PopulateScopeChildrenList.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::EnumerateScopeChildren\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr;

	if ( FALSE == m_bScopeChildrenListPopulated )
	{
		// We have not yet loaded all of our children into our list.
		hr = PopulateScopeChildrenList();
		if( FAILED(hr) )
		{
			return( hr );
		}

		// We've already loaded our children objects with
		// data necessary to populate the result pane.
		m_bScopeChildrenListPopulated = TRUE;	// We only want to do this once.
	}


	// We don't need any code here to InsertItem the children into the
	// scope pane as we did in the EnumerateScopeChildren method
	// for CNodeWithResultChildrenList.
	// This is one difference between adding nodes into the scope
	// pane and the result pane.  Because MMC takes care of replicating
	// scope pane changes to all views, we don't need to worry about
	// sending an UpdateAllViews notification and handling insertion
	// there for each result pane.  Instead, we just do InsertItem once.
	// So for CNodeWithScopePaneChildren, we call InsertItem
	// in the AddChild method which is called by PopulateScopeChildrenList
	// above.

	return S_OK;
}



#endif // _NODE_WITH_SCOPE_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpqueue.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	SnpQueue.cpp

Abstract:
	General queue (private, public...) functionality

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "strconv.h"
#include "QGeneral.h"
#include "QMltcast.h"
#include "Qname.h"
#include "rdmsg.h"
#include "icons.h"
#include "generrpg.h"
#include "SnpQueue.h"

#import "mqtrig.tlb" no_namespace
#include "rule.h"
#include "trigger.h"
#include "trigdef.h"
#include "mqcast.h"

#include "snpqueue.tmh"

EXTERN_C BOOL APIENTRY RTIsDependentClient(); //implemented in mqrt.dll

const PROPID CQueue::mx_paPropid[] = 
            {
             //
             // Public Queue only properties
             // Note: If you change this, you must change mx_dwNumPublicOnlyProps below!
             //
             PROPID_Q_INSTANCE, 
             PROPID_Q_FULL_PATH,

             //
             // Public & Private queue properties
             //
             PROPID_Q_LABEL,  PROPID_Q_TYPE,
        	 PROPID_Q_QUOTA, PROPID_Q_AUTHENTICATE, PROPID_Q_TRANSACTION,
             PROPID_Q_JOURNAL, PROPID_Q_JOURNAL_QUOTA, PROPID_Q_PRIV_LEVEL,
             PROPID_Q_BASEPRIORITY, PROPID_Q_MULTICAST_ADDRESS};

const DWORD CQueue::mx_dwPropertiesCount = sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
const DWORD CQueue::mx_dwNumPublicOnlyProps = 2;


///////////////////////////////////////////////////////////////////////////////////////////
//
// CQueueDataObject
//
CQueueDataObject::CQueueDataObject()
{
}

HRESULT CQueueDataObject::ExtractMsmqPathFromLdapPath(LPWSTR lpwstrLdapPath)
{
    return ExtractQueuePathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}

//
// HandleMultipleObjects
//
HRESULT CQueueDataObject::HandleMultipleObjects(LPDSOBJECTNAMES pDSObj)
{
    return ExtractQueuePathNamesFromDSNames(pDSObj, m_astrQNames, m_astrLdapNames);
}

//
// IShellPropSheetExt
//
STDMETHODIMP CQueueDataObject::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hPage = 0;
    HRESULT hr = S_OK;

    //
    // Call GetProperties and capture the errors
    //
    {
        CErrorCapture errstr;
        hr = GetProperties();
        if (FAILED(hr))
        {
            hPage = CGeneralErrorPage::CreateGeneralErrorPage(m_pDsNotifier, errstr);
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        return S_OK;
        }
    }

    hPage = CreateGeneralPage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }
   

	//
	// Create Multicast page only for non-transactional queues
	//
	PROPVARIANT propVarTransactional;
	PROPID pid = PROPID_Q_TRANSACTION;
	VERIFY(m_propMap.Lookup(pid, propVarTransactional));

	if ( !propVarTransactional.bVal )
	{
		hPage = CreateMulticastPage();    
		if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
		{
			ASSERT(0);
			return E_UNEXPECTED;
		}
	}

    //
    // Add the "Member Of" page using the cached interface
    //
    if (m_spMemberOfPage != 0)
    {
        VERIFY(SUCCEEDED(m_spMemberOfPage->AddPages(lpfnAddPage, lParam)));
    }

    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }
    
    //
    // Add security page
    //
    PROPVARIANT propVarGuid;
    pid = PROPID_Q_INSTANCE;
    VERIFY(m_propMap.Lookup(pid, propVarGuid));

    hr = CreatePublicQueueSecurityPage(
				&hPage, 
				m_strMsmqPath, 
				GetDomainController(m_strDomainController), 
				true,	// fServerName
				propVarGuid.puuid
				);

    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}

HPROPSHEETPAGE CQueueDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CQueueGeneral> *pqpageGeneral = 
        new CMqDsPropertyPage<CQueueGeneral>(m_pDsNotifier);

    if FAILED(pqpageGeneral->InitializeProperties(
									m_strMsmqPath, 
									m_propMap, 
									&m_strDomainController
									))
    {
        delete pqpageGeneral;

        return 0;
    }

	return CreatePropertySheetPage(&pqpageGeneral->m_psp); 
}

HPROPSHEETPAGE CQueueDataObject::CreateMulticastPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueMulticast and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CQueueMulticast> *pqpageMulticast = 
        new CMqDsPropertyPage<CQueueMulticast>(m_pDsNotifier);
    
    if FAILED(pqpageMulticast->InitializeProperties(
									m_strMsmqPath, 
                                    m_propMap,
									&m_strDomainController
									))
    {
        delete pqpageMulticast;

        return 0;
    }   

	return CreatePropertySheetPage(&pqpageMulticast->m_psp); 
}

const DWORD CQueueDataObject::GetPropertiesCount()
{
    return mx_dwPropertiesCount;
}

STDMETHODIMP CQueueDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // If we are not called from "Find" window, users can use the regular "Delete"
    //
    if (!m_fFromFindWindow)
    {
        return 0;
    }

    CString strDeleteQueueMenuEntry;
    strDeleteQueueMenuEntry.LoadString(IDS_DELETE);

    InsertMenu(hmenu,
         indexMenu, 
         MF_BYPOSITION|MF_STRING,
         idCmdFirst + mneDeleteQueue,
         strDeleteQueueMenuEntry);

    return 1;
}

STDMETHODIMP CQueueDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case mneDeleteQueue:
        {
            HRESULT hr;
            CString strDeleteQuestion;
            CString strError;
            CString strErrorMsg;
            CString strMultiErrors;
            DWORD_PTR dwQueuesCount = m_astrQNames.GetSize();
            ASSERT(dwQueuesCount > 0);

            if (dwQueuesCount == 1)
            {
                strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, m_strMsmqPath);
            }
            else
            {
                strDeleteQuestion.FormatMessage(IDS_MULTI_DELETE_QUESTION, DWORD_PTR_TO_DWORD(dwQueuesCount));
            }

            if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
            {
                break;
            }

            CArray<CString, CString&> astrFormatNames;
            hr = GetFormatNames(astrFormatNames);

            if (FAILED(hr))
            {
                return hr;
            }

            dwQueuesCount = astrFormatNames.GetSize();
            for (DWORD_PTR i=0; i<dwQueuesCount; i++)
            {
                HRESULT hr1 = MQDeleteQueue(astrFormatNames[i]);

                if(FAILED(hr1))
                {
       			    MQErrorToMessageString(strError, hr1);
                    strErrorMsg.FormatMessage(IDS_DELETE_ONE_QUEUE_ERROR, m_astrQNames[i], strError);
                    strMultiErrors += strErrorMsg;

                    hr = hr1;
                }
            }
            if FAILED(hr)
            {
                CString strErrorPrompt;
                strErrorPrompt.FormatMessage(IDS_MULTI_DELETE_ERROR, strMultiErrors);
                AfxMessageBox(strErrorPrompt);
                return hr;
            }

            AfxMessageBox(IDS_QUEUES_DELETED_HIT_REFRESH);
        }
    }

    return S_OK;
}

//
// IDsAdminCreateObj methods
//


STDMETHODIMP CQueueDataObject::Initialize(
                        IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }

    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));

    //
    // Get the container distinguish name
    //
    BSTR bstrDN = L"distinguishedName";
    VARIANT var;

    hr = pIADs->Get(bstrDN, &var);
    ASSERT(SUCCEEDED(hr));

	//
    // Extract the machine name
    //
    hr = ExtractComputerMsmqPathNameFromLdapName(m_strComputerName, var.bstrVal);
    ASSERT(SUCCEEDED(hr));

	GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerDispFormat);

    VariantClear(&var);

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call CreateModal()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
	BSTR bstr;
 	hr = pIADs->get_ADsPath(&bstr);
    ASSERT(SUCCEEDED(hr));
	hr = ExtractDCFromLdapPath(m_strDomainController, bstr);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));
	
    return S_OK;
}


HRESULT CQueueDataObject::CreateModal(HWND hwndParent, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	R<CQueueName> pQueueNameDlg = new CQueueName(m_strComputerName, m_strContainerDispFormat);
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();

    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        //
        // We should return S_FALSE here to instruct the framework to 
        // do nothing. If we return an error code, the framework will 
        // pop up an additional error dialog box.
        //
        return S_FALSE;
    }

    //
    // Get the New object Full path name
    //
    PROPID x_paPropid[] = {PROPID_Q_FULL_PATH};
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;

    HRESULT hr = ADGetObjectProperties(
                    eQUEUE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    pQueueNameDlg->GetNewQueuePathName(),
                    1, 
                    x_paPropid,
                    var
                    );
    if(FAILED(hr))
    {
        //
        // Queue was created, but does not exist in the DS. This is probably 
        // a private queue.
        //
        AfxMessageBox(IDS_CREATED_CLICK_REFRESH);
        return S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // 
        // Transfering to LDAP name: Add escape characters and prefix
        //        
        const WCHAR x_wchLimitedChar   = L'/';

        CString strTemp = x_wstrLdapPrefix;
        for (DWORD i =0; i < lstrlen(var[0].pwszVal); i++)
        {
            if (var[0].pwszVal[i] == x_wchLimitedChar)
            {
                strTemp += L'\\';
            }
            strTemp += var[0].pwszVal[i];
        }

        MQFreeMemory(var[0].pwszVal);

	    hr = ADsOpenObject( 
		        (LPWSTR)(LPCWSTR)strTemp,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IADs,
				(void**) ppADsObj
				);

        if(FAILED(hr))
        {
            if (  ADProviderType() == eMqdscli)
            {
                AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
            }
            else
            {
                MessageDSError(hr, IDS_CREATED_BUT_RETRIEVE_FAILED);
            }
            return S_FALSE;
        }
    }
    return S_OK;
}


HRESULT CQueueDataObject::EnableQueryWindowFields(HWND hwnd, BOOL fEnable)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_EDITLABEL), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_EDITTYPE), fEnable);
    return S_OK;
}

void CQueueDataObject::ClearQueryWindowFields(HWND hwnd)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    SetDlgItemText(hwnd, IDC_FIND_EDITLABEL, TEXT(""));
    SetDlgItemText(hwnd, IDC_FIND_EDITTYPE, TEXT(""));
}


/*---------------------------------------------------------------------------*/
//
// Build a parameter block to pass to the query handler.  Each page is called
// with a pointer to a pointer which it must update with the revised query
// block.   For the first page this pointer is NULL, for subsequent pages
// the pointer is non-zero and the page must append its data into the
// allocation.
//
// Returning either and error or S_FALSE stops the query.   An error is
// reported to the user, S_FALSE stops silently.
//

FindColumns CQueueDataObject::Columns[] =
{
    0, 50, IDS_NAME, TEXT("cn"),
    0, 50, IDS_LABEL, TEXT("mSMQLabelEx"),
    0, 50, IDS_FULL_PATH, TEXT("distinguishedName")
};

HRESULT CQueueDataObject::GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    const LPWSTR x_wstrQueueFilterPrefix = TEXT("(&(objectClass=mSMQQueue)");
    const LPWSTR x_wstrQueueTypeFilterPrefix = TEXT("(mSMQQueueType=");
    const LPWSTR x_wstrQueueLabelFilterPrefix = TEXT("(mSMQLabelEx=");
    const LPWSTR x_wstrDefaultValuePrefix = TEXT("(|(!");
    const LPWSTR x_wstrDefaultValuePostfix = TEXT("*))");
    const LPWSTR x_wstrFilterPostfix = TEXT(")");

    HRESULT hr;
    LPDSQUERYPARAMS pDsQueryParams = 0;
    CString szFilter;
    ULONG offset, cbStruct = 0;
    INT i;
    ADsFree  szOctetGuid;

    //
    // This page doesn't support appending its query data to an
    // existing DSQUERYPARAMS strucuture, only creating a new block,
    // therefore bail if we see the pointer is not NULL.
    //

    if ( *ppDsQueryParams )
    {
        ASSERT(0);
        return E_INVALIDARG;
    }
    szFilter = x_wstrQueueFilterPrefix;

    TCHAR szGuid[MAX_PATH];
    if (0 < GetDlgItemText(hWnd, IDC_FIND_EDITTYPE, szGuid, ARRAYSIZE(szGuid)))
    {
        GUID guid;
        hr = IIDFromString(szGuid, &guid);
        BOOL fDefaultValue = FALSE;
        //
        // GUID_NULL is the default value for type guid.
        // We need special handling for default values, that will catch
        // the case where the attribute is not defined at all, and thus
        // treated as it has the default value
        //
        if (GUID_NULL == guid)
        {
            fDefaultValue = TRUE;
            szFilter += x_wstrDefaultValuePrefix;
            szFilter += x_wstrQueueTypeFilterPrefix;
            szFilter += x_wstrDefaultValuePostfix;
        }

        szFilter += x_wstrQueueTypeFilterPrefix;
        if (FAILED(hr))
        {
            AfxMessageBox(IDE_INVALIDGUID);
            SetActiveWindow(GetDlgItem(hWnd, IDC_FIND_EDITTYPE));
            return hr;
        }

        hr = ADsEncodeBinaryData(
            (unsigned char *)&guid,
            sizeof(GUID),
            &szOctetGuid
            );
        if (FAILED(hr))
        {
            ASSERT(0);
            return hr;
        }

        szFilter += szOctetGuid;
        szFilter += x_wstrFilterPostfix;
        //
        // In case f default, this is an "or" query and needs an additional
        // postfix.
        //
        if (fDefaultValue)
        {
            szFilter += x_wstrFilterPostfix;
        }
    }

    TCHAR szLabel[MAX_PATH];
    if (0 < GetDlgItemText(hWnd, IDC_FIND_EDITLABEL, szLabel, ARRAYSIZE(szGuid)))
    {
        szFilter += x_wstrQueueLabelFilterPrefix;
        szFilter += szLabel;
        szFilter += x_wstrFilterPostfix;
    }

    szFilter += x_wstrFilterPostfix;

    offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(Columns)-1)*sizeof(DSCOLUMN));
   
    cbStruct += numeric_cast<ULONG>(StringByteSize(szFilter));
    for (int iColumn = 0; iColumn<ARRAYSIZE(Columns); iColumn++)
    {
        cbStruct += numeric_cast<ULONG>(StringByteSize(Columns[iColumn].pDisplayProperty));
    }

    //
    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.  StringByteSize and StringByteCopy
    // make handling this considerably easier.
    //

    CCoTaskMemPointer CoTaskMem(cbStruct);

    if ( 0 == (PVOID)CoTaskMem )
    {
        ASSERT(0);
        return E_OUTOFMEMORY;
    }


    pDsQueryParams = (LPDSQUERYPARAMS)(PVOID)CoTaskMem;

    pDsQueryParams->cbStruct = cbStruct;
    pDsQueryParams->dwFlags = 0;
    pDsQueryParams->hInstance = g_hResourceMod;
    pDsQueryParams->offsetQuery = offset;
    pDsQueryParams->iColumns = ARRAYSIZE(Columns);

    //
    // Copy the filter string and bump the offset
    //

    StringByteCopy(pDsQueryParams, offset, szFilter);
    offset += numeric_cast<ULONG>(StringByteSize(szFilter));

    //
    // Fill in the array of columns to dispaly, the cx is a percentage of the
    // current view, the propertie names to display are UNICODE strings and
    // are referenced by offset, therefore we bump the offset as we copy
    // each one.
    //

    for ( i = 0 ; i < ARRAYSIZE(Columns); i++ )
    {
        pDsQueryParams->aColumns[i].fmt = Columns[i].fmt;
        pDsQueryParams->aColumns[i].cx = Columns[i].cx;
        pDsQueryParams->aColumns[i].idsName = Columns[i].uID;
        pDsQueryParams->aColumns[i].offsetProperty = offset;

        StringByteCopy(pDsQueryParams, offset, Columns[i].pDisplayProperty);
        offset += numeric_cast<ULONG>(StringByteSize(Columns[i].pDisplayProperty));
    }
   
    //
    // Success, therefore set the pointer to referenece this parameter
    // block and return S_OK!
    //

    *ppDsQueryParams = pDsQueryParams;
    //
    // Prevent auto-release
    //
    CoTaskMem = (LPVOID)0;


    return S_OK;
}


STDMETHODIMP CQueueDataObject::AddForms(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CQFORM cqf;

    if ( !pAddFormsProc )
        return E_INVALIDARG;

    cqf.cbStruct = sizeof(cqf);
    //
    // Do not display the global pages (advanced search). Also, display
    // this search property pages only if the optional flag is set - that is,
    // only when called from MMC, and not when called from "My Network Place" 
    // in the shell.
    //
    cqf.dwFlags = CQFF_NOGLOBALPAGES | CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_MsmqQueueExt;
    cqf.hIcon = NULL;

    CString strFindTitle;
    strFindTitle.LoadString(IDS_FIND_QUEUE_TITLE);

    cqf.pszTitle = (LPTSTR)(LPCTSTR)strFindTitle;

    return pAddFormsProc(lParam, &cqf);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueueDataObject::AddPages(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CQPAGE cqp;

    // AddPages is called after AddForms, it allows us to add the pages for the
    // forms we have registered.  Each page is presented on a seperate tab within
    // the dialog.  A form is a dialog with a DlgProc and a PageProc.  
    //
    // When registering a page the entire structure passed to the callback is copied, 
    // the amount of data to be copied is defined by the cbStruct field, therefore
    // a page implementation can grow this structure to store extra information.   When
    // the page dialog is constructed via CreateDialog the CQPAGE strucuture is passed
    // as the create param.

    if ( !pAddPagesProc )
        return E_INVALIDARG;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC)QueryPageProc;
    cqp.hInstance = AfxGetResourceHandle( );
    cqp.idPageName = IDS_FIND_QUEUE_TITLE;
    cqp.idPageTemplate = IDD_FINDQUEUE;
    cqp.pDlgProc = FindDlgProc;        
    cqp.lParam = (LPARAM)this;

    return pAddPagesProc(lParam, CLSID_MsmqQueueExt, &cqp);
}

HRESULT CQueueDataObject::GetFormatNames(CArray<CString, CString&> &astrFormatNames)
{
    HRESULT hr;

    const DWORD x_dwInitFormatnameLen = 128;
    DWORD dwFormatNameLen = x_dwInitFormatnameLen;
    BOOL fFailedOnce = FALSE;
    CString strFormatName;

    for (int i=0; i<m_astrQNames.GetSize(); i++)
    {
        do
        {
            //
            // Loop at most twice to get the right buffer length
            //
            hr = MQPathNameToFormatName(m_astrQNames[i], strFormatName.GetBuffer(dwFormatNameLen), 
                                        &dwFormatNameLen);
            strFormatName.ReleaseBuffer();
            if (MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL == hr)
            {
                if (fFailedOnce)
                {
                    ASSERT(0);
                    break;
                }
                fFailedOnce = TRUE;;

                //
                // At this stage, dwFormatNameLen contains the right value. We can simply re-do the procedure
                //
                continue;
            }
        } while (FALSE);

        if (FAILED(hr))
        {
            //
            // If the queue was not found using MSMQ DS APIs, it is probably because of
            // replication delays between the DC that MSMQ is using and the DC that the
            // DS snap-in is using. Either the queue was created in the later and was 
            // not replicated to the former, or the queue was already deleted in the former,
            // and the deletion was not replicated to the later. (YoelA, 29-Jun-98).
            //
            IF_NOTFOUND_REPORT_ERROR(hr)
            else
            {
                MessageDSError(hr, IDS_OP_GETFORMATNAME, m_strMsmqPath);
            }
            return hr;
        }
        astrFormatNames.Add(strFormatName);
    }
    return S_OK;
}

//
// IDsAdminNotifyHandler
//
STDMETHODIMP CQueueDataObject::Initialize(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                      /*OUT*/ ULONG* puEventFlags)
{
  if (puEventFlags == NULL)
    return E_INVALIDARG;

  *puEventFlags = DSA_NOTIFY_DEL;
  return S_OK;
}

STDMETHODIMP CQueueDataObject::Begin(THIS_ /*IN*/ ULONG uEvent,
                 /*IN*/ IDataObject* pArg1,
                 /*IN*/ IDataObject* pArg2,
                 /*OUT*/ ULONG* puFlags,
                 /*OUT*/ BSTR* pBstr)
{
	//
    //  This routine handles delete-notification of queue and
    //  msmq-configuration objects.
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT (uEvent & DSA_NOTIFY_DEL);

    if (pBstr != NULL)
    {
        *pBstr = NULL;
    }
    *puFlags = 0;

    HRESULT hr =  ExtractPathNamesFromDataObject(
                                pArg1,
                                m_astrQNames,
                                m_astrLdapNames,
                                TRUE    // fExtractAlsoComputerMsmqObjects
                                );

    if FAILED(hr)
    {
        CString szError;
        MQErrorToMessageString(szError, hr);
        TRACE(_T("CQueueDataObject::Begin: Could not Extract queue pathname from data object. Error %X - %s\n"),
              hr, szError);
        ASSERT(0);
        return hr;
    }
    DWORD_PTR dwNumQueues = m_astrQNames.GetSize();

    if (dwNumQueues == 0) // No queues in the list
    {
        //
        // Don't do anything - simply return S_OK for non-queues
        //
        return S_OK;
    }

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call Begin()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
	hr = ExtractDCFromLdapPath(m_strDomainController, m_astrLdapNames[0]);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

    for (DWORD_PTR i=0; i<dwNumQueues; i++)
    {
		HANDLE hNotifyEnum; 
        //
        // it may be msmq object too, so check if there is delimiter in m_astrQNames[i]
        // if there is "\" it means that it is queue object
        // otherwise msmq object
        //
        int iSlash = m_astrQNames[i].Find(L'\\');

        if ( iSlash != -1 )
        {
            //
            // it is queue object
            //
            hr = ADBeginDeleteNotification(
                    eQUEUE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_astrQNames[i],
                    &hNotifyEnum
                    );            
        }
        else
        {
            //
            // it was only computer name
            //
            hr = ADBeginDeleteNotification(
                    eMACHINE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_astrQNames[i],
                    &hNotifyEnum
                    );
        }       

        if (hr == MQ_INFORMATION_QUEUE_OWNED_BY_NT4_PSC && *pBstr == NULL)
        {
            CString strNt4Object;
            strNt4Object.LoadString(IDS_QUEUES_BELONG_TO_NT4);
            *pBstr = strNt4Object.AllocSysString();
            *puFlags = DSA_NOTIFY_FLAG_ADDITIONAL_DATA | DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA;
        }
        if (hr == MQ_INFORMATION_MACHINE_OWNED_BY_NT4_PSC && *pBstr == NULL)
        {
            CString strNt4Object;
            strNt4Object.LoadString(IDS_MACHINE_BELONG_TO_NT4);
            *pBstr = strNt4Object.AllocSysString();
            *puFlags = DSA_NOTIFY_FLAG_ADDITIONAL_DATA | DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA;
        }
        else if FAILED(hr)
        {
            CString szError;
            MQErrorToMessageString(szError, hr);
            TRACE(_T("CQueueDataObject::Begin: DSBeginDeleteNotification failed. Error %X - %s\n"), 
                  hr, szError);
            hNotifyEnum = 0;
        }
        m_ahNotifyEnums.Add(hNotifyEnum);
    }

    m_astrQNames.RemoveAll();

    return S_OK;
}

STDMETHODIMP CQueueDataObject::Notify(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CQueueDataObject::End(THIS_) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD_PTR dwNumQueues = m_ahNotifyEnums.GetSize();
    for (DWORD_PTR i=0; i<dwNumQueues; i++)
    {
        if (m_ahNotifyEnums[i])
        {
            IADs* pADsObj;
			HRESULT hr = ADsOpenObject( 
							(LPWSTR)(LPCWSTR)m_astrLdapNames[i],
							NULL,
							NULL,
							ADS_SECURE_AUTHENTICATION,
							IID_IADs,
							(void**) &pADsObj
							);

            if FAILED(hr)
            {
                //
                // If we get that error, the object was deleted. Otherwise,
                // we have problems accessing the DS server
                //
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                {                    
                    hr = ADNotifyDelete(
                            m_ahNotifyEnums[i]
                            );
                    if (hr == MQ_ERROR_WRITE_REQUEST_FAILED)
                    {
                        AfxMessageBox(IDS_WRITE_REQUEST_FAILED);
                    }
                }
                else
                {
                    //
                    // Some unexpected error
                    //
                    ASSERT(0);
                }
            }
            else
            {
                pADsObj->Release();
            }
            
            hr = ADEndDeleteNotification(
                    m_ahNotifyEnums[i]
                    );

            m_ahNotifyEnums[i] = 0;
        }
    }
    m_ahNotifyEnums.RemoveAll();
    m_astrLdapNames.RemoveAll();
    
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString strTitle;

    //
    // Create a node to Read Messages
    //
    CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, m_szMachineName);

    // Pass relevant information
    strTitle.LoadString(IDS_READMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

  	AddChild(p, &p->m_scopeDataItem);
  

    //
    // Create the journal queue
    //
    p = new CReadMsg(this, m_pComponentData, m_szFormatName + L";JOURNAL", m_szMachineName);
     
    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);

  	AddChild(p, &p->m_scopeDataItem);

    //
    // Create Trigger definition
    //
    if (m_szMachineName[0] == 0)
    {
		try
		{
			R<CRuleSet> pRuleSet = GetRuleSet(m_szMachineName);
			R<CTriggerSet> pTrigSet = GetTriggerSet(m_szMachineName);

			CTriggerDefinition* pTrigger = new CTriggerDefinition(this, m_pComponentData, pTrigSet.get(), pRuleSet.get(), m_szPathName);
			if (pTrigger == NULL)
				return S_OK;

			strTitle.LoadString(IDS_TRIGGER_DEFINITION);
			pTrigger->m_bstrDisplayName = strTitle;

			AddChild(pTrigger, &pTrigger->m_scopeDataItem);
		}
		catch (const _com_error&)
		{
		}
    }

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
        if (SUCCEEDED(GetProperties()))
        {
            //--------------------------------------
            //
            // Queue General Page
            //
            //--------------------------------------
            CQueueGeneral *pqpageGeneral = new CQueueGeneral(
													m_fPrivate, 
													true  // Local Managment
													);

            if (0 == pqpageGeneral)
            {
                return E_OUTOFMEMORY;
            }

            HRESULT hr = pqpageGeneral->InitializeProperties(
											m_szPathName, 
											m_propMap, 
											NULL,	// pstrDomainController
											&m_szFormatName
											);

            if FAILED(hr)
            {
                delete pqpageGeneral;
                return hr;
            }

            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pqpageGeneral->m_psp);

            if (hPage == NULL)
	        {
                delete pqpageGeneral;
		        return E_UNEXPECTED;  
	        }
    
            lpProvider->AddPage(hPage); 

			
			//
			// Queue Multicast Address Page
			// Do not create the page for a dependent client machine
			// or for a transactional queue
			//
			PROPVARIANT propVarTransactional;
			PROPID pid = PROPID_Q_TRANSACTION;
			VERIFY(m_propMap.Lookup(pid, propVarTransactional));

			if ( !RTIsDependentClient() && !propVarTransactional.bVal)
			{
				CQueueMulticast *pqpageMulticast = new CQueueMulticast(
															m_fPrivate, 
															true  // Local Managment
															);
				if (0 == pqpageMulticast)
				{
					return E_OUTOFMEMORY;
				}
            
				hr = pqpageMulticast->InitializeProperties(
										m_szPathName,
										m_propMap,                                     
										NULL,	// pstrDomainController
										&m_szFormatName
										);

				if (FAILED(hr))
				{
					//
					// We can fail to initialize Multicast property.
					// This is the case in MQIS environment, the multicast property
					// for public queue will not be in m_propMap.
					// in that case we will not display the multicast page.
					//
					delete pqpageMulticast;
				}
				else
				{
					hPage = CreatePropertySheetPage(&pqpageMulticast->m_psp);

					if (hPage == NULL)
					{
						delete pqpageMulticast;
						return E_UNEXPECTED;  
					}

					lpProvider->AddPage(hPage);             
				}
			}

            if (m_szPathName != TEXT(""))
            {
                hr = CreateQueueSecurityPage(&hPage, m_szFormatName, m_szPathName);
            }
            else
            {
                hr = CreateQueueSecurityPage(&hPage, m_szFormatName, m_szFormatName);
            }

            if SUCCEEDED(hr)
            {
                lpProvider->AddPage(hPage); 
            }
            else
            {
                MessageDSError(hr, IDS_OP_DISPLAY_SECURITY_PAGE);
            }
        }

        return(S_OK);


	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
    hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Default menu should be displayed for local / unknow location queues only
    //
    if (m_QLocation != PRIVQ_REMOTE)
    {
        return CLocalQueue::SetVerbs(pConsoleVerb);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::GetProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(MQDS_QUEUE, 
                                               NULL,	// pDomainController
                                               m_szFormatName,
                                               mx_dwPropertiesCount-mx_dwNumPublicOnlyProps,
                                               (mx_paPropid + mx_dwNumPublicOnlyProps),
                                               TRUE);
    if (FAILED(hr))
    {
		if ( hr == MQ_ERROR_QUEUE_NOT_FOUND )
		{
			AfxMessageBox(IDS_PRIVATE_Q_NOT_FOUND);
		}
        else if (MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION == hr)
        {
            AfxMessageBox(IDS_REMOTE_PRIVATE_QUEUE_OPERATION);
        }
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_szFormatName);
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::ApplyCustomDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
void CPrivateQueue::ApplyCustomDisplay(DWORD dwPropIndex)
{
    CLocalQueue::ApplyCustomDisplay(dwPropIndex);

    //
    // For management
    //
    if (m_mqProps.aPropID[dwPropIndex] == PROPID_MGMT_QUEUE_PATHNAME && m_bstrLastDisplay[0] == 0)
    {
        m_bstrLastDisplay = m_bstrDisplayName;
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::ApplyCustomDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                               IN LPCWSTR lpwcsFormatName, 
                                               IN LPCWSTR lpwcsDescriptiveName)
{
    return CreatePrivateQueueSecurityPage(phPage, lpwcsFormatName, lpwcsDescriptiveName);
}


/****************************************************

CLocalQueue Class
    
 ****************************************************/
// {B6EDE68C-29CC-11d2-B552-006008764D7A}
static const GUID CLocalQueueGUID_NODETYPE = 
{ 0xb6ede68c, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalQueue::m_NODETYPE = &CLocalQueueGUID_NODETYPE;
const OLECHAR* CLocalQueue::m_SZNODETYPE = OLESTR("B6EDE68C-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::GetProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(MQDS_QUEUE, 
                                               MachineDomain(),
                                               m_szPathName,
                                               mx_dwPropertiesCount,
                                               (mx_paPropid));
    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_szFormatName);
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Default menu should be displayed for local / unknow location queues only
    //
    HRESULT hr;
    if (m_fFromDS)
    {
        hr = CLocalQueue::SetVerbs(pConsoleVerb);
    }
    else
    {
        //
        // Properties and delete are not functioning when there is no DS connection.
        // However, we want them to remain visable, but disabled.
        //
        hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE );
        hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, FALSE );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::CreateQueueSecurityPage

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                IN LPCWSTR lpwcsFormatName,
                                IN LPCWSTR lpwcsDescriptiveName)
{
    if (eAD != ADGetEnterprise())
    {
        // We are working with an NT4 PSC.
        // For NT4, public queue security is done in the same fasion as 
        // private queue security
        //
        return CreatePrivateQueueSecurityPage(phPage, lpwcsFormatName, lpwcsDescriptiveName);
    }

    //
    // We are working with AD
    //
    PROPVARIANT propVarGuid;

    PROPID pidInstance;

    pidInstance = PROPID_Q_INSTANCE;
    VERIFY(m_propMap.Lookup(pidInstance, propVarGuid));
    return CreatePublicQueueSecurityPage(
				phPage, 
				lpwcsDescriptiveName, 
				MachineDomain(), 
				false,	// fServerName 
				propVarGuid.puuid
				);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::OnDelete

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::OnDelete( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			, BOOL fSilent
			)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, m_szPathName);
    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

    HRESULT hr = MQDeleteQueue(m_szFormatName);

    if (FAILED(hr))
    {
        if (MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION == hr)
        {
            AfxMessageBox(IDS_REMOTE_PRIVATE_QUEUE_OPERATION);
        }
        else
        {
            MessageDSError(hr, IDS_OP_DELETE, m_szPathName);
        }
        return hr;
    }

	// Need IConsoleNameSpace.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	ASSERT( spConsole != NULL );

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole); 
	
    //
    // Need to see if this works because of multi node scope
    //

    hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, TRUE ); 


	if (FAILED(hr))
	{
		return hr;
	}
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLocalQueue::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CDisplayQueue<CLocalQueue>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_PATHNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szPathName, 
            (m_szPathName.GetLength() + 1) * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\srvcsec.cpp ===
// SrvAuthn.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "srvcsec.h"

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include <wincrypt.h>
#include <cryptui.h>
#include "mqcert.h"
#include "uniansi.h"
#include "_registr.h"
#include "mqcast.h"
#include <mqnames.h>
#include <rt.h>
#include <mqcertui.h>
#include "srvcsec.tmh"
#include "globals.h"

#define  MY_STORE	L"My"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage property page

IMPLEMENT_DYNCREATE(CServiceSecurityPage, CMqPropertyPage)

CServiceSecurityPage::CServiceSecurityPage(BOOL fIsDepClient, BOOL fIsDsServer) : 
    CMqPropertyPage(CServiceSecurityPage::IDD),    
    m_fClient(fIsDepClient),
    m_fDSServer(fIsDsServer)
{
	//{{AFX_DATA_INIT(CServiceSecurityPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT    
    m_fModified = FALSE; 
    

    m_nCaCerts = 0 ;

    //
    // Get registry value for SecuredServerConnection
    //
    m_fOldSecuredConnection = MQsspi_IsSecuredServerConn(FALSE /*fRefresh*/);
    m_fSecuredConnection = m_fOldSecuredConnection;   
}

CServiceSecurityPage::~CServiceSecurityPage()
{
}

void CServiceSecurityPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);    
	//{{AFX_DATA_MAP(CServiceSecurityPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
        DDX_Control(pDX, IDC_SERVER_COMM_FRAME, m_ServerCommFrame);
        DDX_Control(pDX, IDC_CRYPTO_KEYS_FRAME, m_CryptoKeysFrame); 
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION_FRAME, m_ServerAuthFrame);
        DDX_Control(pDX, ID_RenewCryp, m_RenewCryp);
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION, m_ServerAuth);
        DDX_Control(pDX, IDC_USE_SECURED_SEVER_COMM, m_UseSecuredConnection);
        DDX_Control(pDX, IDC_CAS, m_CertificationAuthorities);
        DDX_Control(pDX, IDC_CRYPTO_KEYS_LABEL, m_CryptoKeysLabel);
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION_LABEL, m_ServerAuthLabel);
	//}}AFX_DATA_MAP    

    DDX_Check(pDX, IDC_USE_SECURED_SEVER_COMM, m_fSecuredConnection);   

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Detect changes.
        //
        if (m_fOldSecuredConnection != m_fSecuredConnection)
        {
            m_fModified = TRUE;
            
        }

        if (m_CaConfig)
        {
            for (DWORD i = 0; i < m_nCaCerts && !m_fModified; i++)
            {
                if (m_CaConfig[i].fDeleted)
                {
                    m_fModified = m_afOrigConfig[i];
                }
                else
                {
                    m_fModified = m_CaConfig[i].fEnabled != m_afOrigConfig[i];
                }
            }
        }
    }
}

BOOL CServiceSecurityPage::OnInitDialog()
{
    CMqPropertyPage::OnInitDialog();
  
    m_UseSecuredConnection.SetCheck(m_fOldSecuredConnection);
    m_CertificationAuthorities.EnableWindow(m_fOldSecuredConnection);  

    if(m_fClient)
    {
        //
        // Hide useless stuff when running on dep. clients
        //
        m_ServerCommFrame.ShowWindow(SW_HIDE);

        m_CryptoKeysFrame.ShowWindow(SW_HIDE);        
        m_RenewCryp.ShowWindow(SW_HIDE);
        m_CryptoKeysLabel.ShowWindow(SW_HIDE);        
    }

    if (!m_fDSServer)
    {
        //
        // it will be hidden on non-DC computer
        //
        m_ServerAuthFrame.ShowWindow(SW_HIDE);
        m_ServerAuth.ShowWindow(SW_HIDE);
        m_ServerAuthLabel.ShowWindow(SW_HIDE);
    }

    if (m_fDSServer)
    {
        //
        // it will be grayed on DC
        //
        m_UseSecuredConnection.EnableWindow(FALSE);
        m_CertificationAuthorities.EnableWindow(FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_MESSAGE_MAP(CServiceSecurityPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CServiceSecurityPage)
	ON_BN_CLICKED(IDC_SERVER_AUTHENTICATION, OnServerAuthentication)
    ON_BN_CLICKED(ID_RenewCryp, OnRenewCryp)    
    ON_BN_CLICKED(IDC_USE_SECURED_SEVER_COMM, OnUseSecuredSeverComm)
    ON_BN_CLICKED(IDC_CAS, OnCas)    
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage message handlers

void CServiceSecurityPage::OnServerAuthentication()
{   
    SelectCertificate() ;
}


#define STORE_NAME_LEN  48
WCHAR  g_wszStore[ STORE_NAME_LEN ] ;
GUID   g_guidDigest ;

void CServiceSecurityPage::SelectCertificate()
{	    
    CString strErrorMsg;
       
    CHCertStore hStoreMy = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                          0,
                                          0,
                                          CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                          MY_STORE );
    if (!hStoreMy)
    {
        strErrorMsg.LoadString(IDS_FAIL_OPEN_MY) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    HCERTSTORE hStores[]   = { hStoreMy } ;
    LPWSTR wszStores[] = { MY_STORE } ;
    DWORD cStores = TABLE_SIZE(hStores);

    CString strCaption;
    strCaption.LoadString(IDS_SELECT_SRV_CERT) ;
    
	PCCERT_CONTEXT pCertContext = CryptUIDlgSelectCertificateFromStore(
										hStoreMy,
										0,
										strCaption,
										L"",
										CRYPTUI_SELECT_EXPIRATION_COLUMN,
										0,
										NULL
										);
    if (!pCertContext)
    {
        return ;
    }

    R<CMQSigCertificate> pCert = NULL ;
    HRESULT hr = MQSigCreateCertificate( &pCert.ref(),
                                         pCertContext ) ;
    if (FAILED(hr))
    {
        strErrorMsg.LoadString(IDS_FAIL_CERT_OBJ) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    hr = pCert->GetCertDigest( &g_guidDigest) ;
    if (FAILED(hr))
    {
        strErrorMsg.LoadString(IDS_FAIL_CERT_OBJ) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    LPWSTR  lpwszStore = NULL ;
    for ( DWORD j = 0 ; j < cStores ; j++ )
    {
        if ( pCertContext->hCertStore == hStores[j])
        {
            lpwszStore = wszStores[j] ;
            break ;
        }
    }

    if (!lpwszStore)
    {
        strErrorMsg.LoadString(IDS_FAIL_OPEN_MY) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    wcsncpy(g_wszStore, lpwszStore, STORE_NAME_LEN);
    m_fModified = TRUE ;
    
}

BOOL CServiceSecurityPage::OnApply() 
{
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    //
    // Save changes to registry
    // 

    if (m_fDSServer)
    {
        DWORD dwSize = sizeof(GUID) ;
        DWORD dwType = REG_BINARY ;

        LONG  rc = SetFalconKeyValue( SRVAUTHN_CERT_DIGEST_REGNAME,
                                      &dwType,
                                      &g_guidDigest,
                                      &dwSize );

        dwSize = (numeric_cast<DWORD>(_tcslen(g_wszStore) + 1)) * sizeof(WCHAR) ;
        dwType = REG_SZ ;

        rc = SetFalconKeyValue( SRVAUTHN_STORE_NAME_REGNAME,
                                &dwType,
                                g_wszStore,
                                &dwSize );
    }

    BOOL fRet;
    
    fRet = MQsspi_SetSecuredServerConn(m_fSecuredConnection);

    ASSERT(fRet);

    //
    // Save CA certificates configuration.
    //
    if (m_CaConfig)
    {
        HRESULT hr;

        hr = MQSetCaConfig(m_nCaCerts, m_CaConfig);

        ASSERT(SUCCEEDED(hr));
    }            

    m_fNeedReboot = TRUE;    
    
    
    //
    // There is a problem that after you hit apply and then enter OK
    // DoDataExchange( ) will set the m_fModified whenever
    // there is a fDeleted flag set and the CA is enabled in m_CaConfig table.
    // I have a option to remove that code on DoDataExchange, 
    // but I think a better solution is to clean up m_caConfig whenever an CA is deleted since
    // the CA list has changed now. 
    //
    m_fModified = FALSE;        // Reset the m_fModified flag
    if (m_CaConfig)
    {
        for (DWORD i = 0; i < m_nCaCerts; i++)
        {
            if (m_CaConfig[i].fDeleted)
            {
                MQFreeCaConfig(m_CaConfig.detach());
                break;
            }
        }
    }



    return CMqPropertyPage::OnApply();
}

void CServiceSecurityPage::OnRenewCryp()
{
    HRESULT hr;
    CString strCaption;
    CString strErrorMessage;
    
    strCaption.LoadString(IDS_NEW_CRYPT_KEYS_CAPTION);
    strErrorMessage.LoadString(IDS_NEW_CRYPT_KEYS_WARNING);

    if (MessageBox(strErrorMessage,
                   strCaption,
                   MB_YESNO | MB_DEFBUTTON1 | MB_ICONQUESTION) == IDYES)
    {

        CWaitCursor wait;  //display hourglass cursor

        //
        // [adsrv] Update the machine object
        //
        hr = MQSec_StorePubKeysInDS( TRUE,
                                     NULL,
                                     MQDS_MACHINE) ;
        if (FAILED(hr))
        {
            MessageDSError(hr, IDS_RENEW_CRYP_ERROR);
            return;
        }
        else
        {              
              m_fModified = TRUE;
              
        }
    }
}

BOOL CServiceSecurityPage::UpdateCaConfig(BOOL fOldCertsOnly,
                                   BOOL fShowError)
{
    HRESULT hr;
    CWaitCursor wait;   

    if (fOldCertsOnly)
    {
        if (!m_CaConfig)
        {
            //
            // Update the list of authorities.
            //
            hr = MQsspi_UpdateCaConfig(TRUE);
            if (FAILED(hr))
            {
                if (fShowError)
                {
                    AfxMessageBox(IDS_FAILED_TO_UPDATE_CAS, MB_OK | MB_ICONEXCLAMATION);                  
                }
                return FALSE;
            }
            //
            // Retrive the current CA configuration.
            //
            DWORD dwPrevCertsCount = m_nCaCerts ;
            hr = MQGetCaConfig(&m_nCaCerts, &m_CaConfig);
            if (FAILED(hr))
            {
                m_nCaCerts =  dwPrevCertsCount ;
                if (fShowError)
                {                    
                    AfxMessageBox(IDS_FAILED_TO_RETRIEVE_CAS, MB_OK | MB_ICONEXCLAMATION);                  
                }
                return FALSE;
            }

            if (!m_nCaCerts)
            {
                //
                // No certificates.
                //
                if (fShowError)
                {                   
                    AfxMessageBox(IDS_NO_CAS, MB_OK | MB_ICONEXCLAMATION);                  
                }
                return FALSE;
            }

            DWORD i;

            //
            // Copy the original list so we'll know if there were changes in
            // the configuration.
            //
            m_afOrigConfig = new BOOL[m_nCaCerts];
            for (i = 0; i < m_nCaCerts; i++)
            {
                m_afOrigConfig[i] = m_CaConfig[i].fEnabled;
            }
        }
    }
    else
    {
        //
        // Update the list of authorities.
        //
        hr = MQsspi_UpdateCaConfig(FALSE);
        if (FAILED(hr))
        {            
            AfxMessageBox(IDS_FAILED_TO_UPDATE_CAS, MB_OK | MB_ICONEXCLAMATION);
            return FALSE;
        }

        //
        // Retrive the new CA configuration.
        //
        CCaConfigPtr pNewCaConfig;
        DWORD nNewCerts;

        hr = MQGetCaConfig(&nNewCerts, &pNewCaConfig);
        if (FAILED(hr))
        {            
            AfxMessageBox(IDS_FAILED_TO_RETRIEVE_CAS, MB_OK | MB_ICONEXCLAMATION);
            return FALSE;
        }

        if (m_nCaCerts <= nNewCerts)
        {
            m_fModified = TRUE;
            

            for (DWORD i = 0; i < nNewCerts; i++)
            {
                BOOL fAlreadyExist;
                DWORD j;

                for (j = 0, fAlreadyExist = FALSE;
                     j < m_nCaCerts;
                     j++)
                {
                    fAlreadyExist =
                        (m_CaConfig[j].dwSha1HashSize ==
                         pNewCaConfig[i].dwSha1HashSize) &&
                        (memcmp(m_CaConfig[j].pbSha1Hash,
                                pNewCaConfig[i].pbSha1Hash,
                                m_CaConfig[j].dwSha1HashSize) == 0);
                    if (fAlreadyExist)
                    {
                        break;
                    }
                }

                if (fAlreadyExist)
                {
                    if (!m_CaConfig[j].fDeleted)
                    {
                        pNewCaConfig[i].fEnabled = m_CaConfig[j].fEnabled;
                    }
                }
            }
            
			MQFreeCaConfig(m_CaConfig.detach());
            m_CaConfig = pNewCaConfig.detach();
            m_nCaCerts = nNewCerts;
        }
    }

    return(TRUE);

}

static BOOL IsIE4(void)
{
    HINSTANCE hCrypt32 = GetModuleHandle(TEXT("CRYPT32"));

    return (hCrypt32 != NULL) &&
           (GetProcAddress(hCrypt32, "CertGetEnhancedKeyUsage") != NULL);
}


void CServiceSecurityPage::OnUseSecuredSeverComm()
{
    //
    // Toggle the state of secured server comm.
    //
    m_fSecuredConnection = m_UseSecuredConnection.GetCheck();   

    if (m_fSecuredConnection)
    {
        //
        // Update the list of authorities.
        //
        if (!UpdateCaConfig(TRUE, FALSE))
        {
            BOOL fUpd = FALSE ;
            if (IsIE4())
            {
                //
                // this may happen if machine has IE4 installed and it's
                // a fresh install of Falcon. There is no CA cert store
                // in IE3 format. So update only the IE4 CA certificates.
                //
                fUpd = UpdateCaConfig(FALSE) ;
            }
            else
            {
                //
                // Call again to show error to user.
                //
                fUpd = UpdateCaConfig(TRUE) ;
                ASSERT(!fUpd) ;
            }

            if (!fUpd)
            {
                m_fSecuredConnection = FALSE;
                m_UseSecuredConnection.SetCheck(0);
            }
        }
    }
    m_CertificationAuthorities.EnableWindow(m_fSecuredConnection);
    OnChangeRWField(TRUE);
}

void CServiceSecurityPage::OnCas()
{
    BOOL fLoop;   

    do
    {
        fLoop = FALSE;
        //
        // Update the list of authorities.
        //
        if (!UpdateCaConfig(TRUE))
        {
            //
            // An error message was already displayed.
            //
            return;
        }

        HRESULT hr;
        DWORD i;

        AP< CAutoMQFree<BYTE> > ppbCerts = new CAutoMQFree<BYTE>[m_nCaCerts];
        AP<DWORD> pdwCertSize = new DWORD[m_nCaCerts];
        AP<LPCTSTR> pszCaNames = new LPCTSTR[m_nCaCerts];
        AP<BOOL> pfEnabled = new BOOL[m_nCaCerts];
        AP<BOOL> pfDeleted = new BOOL[m_nCaCerts];

        for (i = 0; i < m_nCaCerts; i++)
        {
            pfEnabled[i] = m_CaConfig[i].fEnabled;
            pfDeleted[i] = m_CaConfig[i].fDeleted;
            pszCaNames[i] = m_CaConfig[i].szCaRegName;
            hr = MQsspi_GetCaCert( pszCaNames[i],
                                   m_CaConfig[i].pbSha1Hash,
                                   m_CaConfig[i].dwSha1HashSize,
                                   &pdwCertSize[i],
                                   &ppbCerts[i] );
            if (FAILED(hr))
            {               
                AfxMessageBox(IDS_FAILED_TO_GET_CA_CERT, MB_OK | MB_ICONEXCLAMATION);
                return;
            }
        }

        DWORD_PTR dwAction;

        dwAction = ::CaConfig(this->m_hWnd,
                              m_nCaCerts,
                              (BYTE **)(PVOID)ppbCerts,
                              pdwCertSize,
                              pszCaNames,
                              pfEnabled,
                              pfDeleted,
                              m_CaConfig[0].pbSha1Hash != NULL);

        switch (dwAction)
        {
        case IDOK:
        case ID_UPDATE_CERTS:
            for (i = 0; i < m_nCaCerts; i++)
            {
                m_CaConfig[i].fEnabled = pfEnabled[i];
                m_CaConfig[i].fDeleted = pfDeleted[i];
            }
            if (dwAction == ID_UPDATE_CERTS)
            {
                UpdateCaConfig(FALSE);
                fLoop = TRUE;
            }
            OnChangeRWField(TRUE);
            break;

        case IDCANCEL:
            break;
        }
    } while (fLoop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\srvcsec.h ===
#if !defined(AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_)
#define AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// srvcsec. : header file
//

#include <mqcacert.h>

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage dialog

class CServiceSecurityPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CServiceSecurityPage)

// Construction
public:
	CServiceSecurityPage(BOOL fIsDepClient = FALSE, BOOL fIsDsServer = FALSE);
	~CServiceSecurityPage();

// Dialog Data
	//{{AFX_DATA(CServiceSecurityPage)
	enum { IDD = IDD_SERVICE_SECURITY };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
    CButton m_ServerCommFrame;
    CButton m_CryptoKeysFrame;
    CButton m_RenewCryp;
    CButton m_UseSecuredConnection;
    CButton m_CertificationAuthorities;
    CButton m_ServerAuthFrame; 
    CButton m_ServerAuth;
    CStatic m_CryptoKeysLabel;
    CStatic m_ServerAuthLabel;
	//}}AFX_DATA  

    BOOL m_fSecuredConnection;
    BOOL m_fOldSecuredConnection;    
    BOOL m_fClient;  
    BOOL m_fDSServer;

    DWORD m_nCaCerts;
    CCaConfigPtr m_CaConfig;
    AP<BOOL> m_afOrigConfig;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServiceSecurityPage)
    public:
    virtual BOOL OnApply();
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServiceSecurityPage)
	afx_msg void OnServerAuthentication();
    afx_msg void OnRenewCryp();    
    virtual BOOL OnInitDialog();
    afx_msg void OnUseSecuredSeverComm();
    afx_msg void OnCas();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void SelectCertificate() ;
    BOOL UpdateCaConfig(BOOL, BOOL fShowError = TRUE);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\snpqueue.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	SnpQueue.h

Abstract:
	General queue (private, public...) functionality

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SNPQUEUE_H_
#define __SNPQUEUE_H_

#include "snpnscp.h"
#include "lqDsply.h"
#include "privadm.h"
//
// CQueue - general queue class
//
class CQueue
{
protected:
    static const PROPID mx_paPropid[];
    static const DWORD  mx_dwPropertiesCount;
    static const DWORD  mx_dwNumPublicOnlyProps;
};


///////////////////////////////////////////////////////////////////////////////////////////
//
// CQueueDataObject - used for public queue extention
//
class CQueueDataObject : 
    public CQueue,
    public CMsmqDataObject,
   	public CComCoClass<CQueueDataObject,&CLSID_MsmqQueueExt>,
    public IDsAdminCreateObj,
    public IDsAdminNotifyHandler
{
public:
    DECLARE_NOT_AGGREGATABLE(CQueueDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_MsmqQueueExt)

    BEGIN_COM_MAP(CQueueDataObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY(IDsAdminNotifyHandler)
	    COM_INTERFACE_ENTRY_CHAIN(CMsmqDataObject)
    END_COM_MAP()

    CQueueDataObject();
    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    // IQueryForm
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

    //
    // IDsAdminNotifyHandler
    //
    STDMETHOD(Initialize)(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                          /*OUT*/ ULONG* puEventFlags);
    STDMETHOD(Begin)(THIS_ /*IN*/ ULONG uEvent,
                     /*IN*/ IDataObject* pArg1,
                     /*IN*/ IDataObject* pArg2,
                     /*OUT*/ ULONG* puFlags,
                     /*OUT*/ BSTR* pBstr);

    STDMETHOD(Notify)(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags); 

    STDMETHOD(End)(THIS_); 


protected:
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateMulticastPage();
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
    virtual HRESULT HandleMultipleObjects(LPDSOBJECTNAMES pDSObj);

   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable);
	virtual void ClearQueryWindowFields(HWND hwnd);
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);
    HRESULT GetFormatNames(CArray<CString, CString&> &astrFormatNames);

    enum _MENU_ENTRY
    {
        mneDeleteQueue = 0
    };


private:
    CString m_strComputerName;
	CString m_strContainerDispFormat;
	CArray<CString, CString&> m_astrLdapNames;
	CArray<CString, CString&> m_astrQNames;
    CArray<HANDLE, HANDLE&> m_ahNotifyEnums;

};

inline const DWORD CQueueDataObject::GetObjectType()
{
    return MQDS_QUEUE;
};

inline const PROPID *CQueueDataObject::GetPropidArray()
{
    return mx_paPropid;
}



/****************************************************

        CLocalQueue Class
    
 ****************************************************/
class CLocalQueue : public CDisplayQueue<CLocalQueue>,
                    public CQueue
{
public:

    CString m_szFormatName;           // Format name of the private queue
    CString m_szPathName;             // Path name of the private queue

   	BEGIN_SNAPINCOMMAND_MAP(CPrivateQueue, FALSE)
	END_SNAPINCOMMAND_MAP()

    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CLocalQueue(CSnapInItem * pParentNode, PropertyDisplayItem *aDisplayList, DWORD dwDisplayProps, CSnapin * pComponentData) :
        CDisplayQueue<CLocalQueue> (pParentNode, pComponentData)
	{
        m_aDisplayList = aDisplayList;
        m_dwNumDisplayProps = dwDisplayProps;
	}

    //
    // DS constructor - called from DS snapin
    //
    CLocalQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CDisplayQueue<CLocalQueue> (pParentNode, pComponentData)
	{
	}

	~CLocalQueue()
	{
	}

    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
	virtual HRESULT OnDelete( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				, BOOL fSilent = FALSE
				);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

protected:
    //
    // CQueueDataObject
    //
	virtual HRESULT GetProperties() PURE;
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName) PURE;

	CPropMap m_propMap;
    BOOL m_fPrivate;
};

class CPrivateQueue : public CLocalQueue
{
public:
    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CPrivateQueue(CSnapInItem * pParentNode, PropertyDisplayItem *aDisplayList, DWORD dwDisplayProps, CSnapin * pComponentData, BOOL fOnLocalMachine) :
        CLocalQueue (pParentNode, aDisplayList, dwDisplayProps, pComponentData)
	{
        Init();
        if (fOnLocalMachine)
        {
            m_QLocation = PRIVQ_LOCAL;
        }
        else
        {
            m_QLocation = PRIVQ_REMOTE;
        }
	}

    //
    // DS constructor - called from DS snapin
    //
    CPrivateQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CLocalQueue (pParentNode, pComponentData)
	{
        Init();
        m_QLocation = PRIVQ_UNKNOWN;
	}

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

protected:
    enum
    {
        PRIVQ_LOCAL,
        PRIVQ_REMOTE,
        PRIVQ_UNKNOWN
    } m_QLocation;

	virtual HRESULT GetProperties();
    virtual void Init()
    {
        SetIcons(IMAGE_PRIVATE_QUEUE, IMAGE_PRIVATE_QUEUE);
        m_fPrivate = TRUE;
    }
    virtual void ApplyCustomDisplay(DWORD dwPropIndex);
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName);

};

class CLocalPublicQueue : public CLocalQueue
{
public:
    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CLocalPublicQueue(CSnapInItem * pParentNode, 
                      PropertyDisplayItem *aDisplayList, 
                      DWORD dwDisplayProps, 
                      CSnapin * pComponentData,
                      CString &strPathName,
                      CString &strFormatName,
                      BOOL fFromDS) :
        CLocalQueue (pParentNode, aDisplayList, dwDisplayProps, pComponentData),
        m_fFromDS(fFromDS)
	{
        m_szFormatName = strFormatName;
        m_szPathName = strPathName;
        Init();
	}

    ~CLocalPublicQueue()
    {
    }

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

protected:
	virtual HRESULT GetProperties();
    virtual void Init()
    {
        SetIcons(IMAGE_PUBLIC_QUEUE, IMAGE_PUBLIC_QUEUE);
        m_fPrivate = FALSE;
    }
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName);
    BOOL m_fFromDS;
};

HRESULT 
CreatePrivateQueueSecurityPage(
       HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsFormatName,
    IN LPCWSTR lpwcsDescriptiveName);

HRESULT
CreatePublicQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsDescriptiveName,
    IN LPCWSTR lpwcsDomainController,
	IN bool	   fServerName,
    IN GUID*   pguid
	);


#endif // __SNPQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED_


#include "_stdafx.h"

#pragma warning(push, 3)

#include <afxcmn.h>
#include <iostream>
#include <lim.h>

#pragma warning(pop)
 

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "ad.h"
#include "_rstrct.h"
#include "_mqdef.h"
#include "rt.h"
#include "_guid.h"
#include "admcomnd.h"

#pragma warning(disable: 4201)
#include "mmc.h"

#include "shlobj.h"
#include "dsclient.h"
#include "dsadmin.h"

#include "automqfr.h"

#include "winsock2.h"
#include "autohandle.h"



#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxtempl.h>


#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#pragma warning(disable: 4267)
#include <comdef.h>
#pragma warning(default: 4267)

#include <autoptr.h>

//
// ISSUE-2000/12/19-urih: duplicate decleration. Need to be removed and using decleration form mm.h
//
// mqsnap working in mix enviroment, it uses include files from lib\inc while it isn't using
// mqenv.h. This cause a conflict. For now I declared MmIsStaticAddress	here instead include
// mm.h, but we need to change snap-in to use MSMQ enviroment.
//
inline bool
MmIsStaticAddress(
    const void* Address
    )
{
	return true;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\storage.h ===
// Storage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStoragePage dialog


#define MAX_STORAGE_DIR 248


class CStoragePage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CStoragePage)

// Construction
public:
	CStoragePage();
	~CStoragePage();    

// Dialog Data
	//{{AFX_DATA(CStoragePage)
	enum { IDD = IDD_STORAGE };
	CString	m_MsgFilesDir;
	CString	m_MsgLoggerDir;
	CString	m_TxLoggerDir;
	//}}AFX_DATA
	CString m_OldMsgFilesDir;
	CString m_OldMsgLoggerDir;
	CString m_OldTxLoggerDir;
 
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStoragePage)
    public:
    virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStoragePage)   
	afx_msg void OnBrowseLogFolder();
	afx_msg void OnBrowseMsgFolder();
	afx_msg void OnBrowseXactFolder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void DDV_FullPathNames(CDataExchange* pDX);
	BOOL MoveFilesToNewFolders(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\storage.cpp ===
// Storage.cpp : implementation file
//
#include <winreg.h>
#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqppage.h"
#include "_registr.h"
#include "localutl.h"
#include "Storage.h"
#include "infodlg.h"
#include "mqsnhlps.h"
#include "mqcast.h"

#include "storage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Verify that an edit control is a directory
//
static
void 
DDV_IsDirectory(
	HWND hWnd, 
	CDataExchange* pDX, 
	int Id, 
	LPCTSTR szDir)
{
	if(IsDirectory(hWnd, szDir))
	{
		return;
	}

	//
	// If this is not a directory IsDirectory() already displayed
	// a corresponding error mesage.
    // Set the focus on the edit control
    //
    pDX->PrepareEditCtrl(Id);

    //
    // And fail the validation
    //
    pDX->Fail();
}


static
void
DDV_SingleFullPath(
	CString& strPath,
	CDataExchange* pDX, 
	int Id
	)
{
	//
	// Note: MAX_DIR_LENGTH defined in storage.h is used here instead of
	// MAX_PATH since we are talking about a drectory. 
	// Later, CreateDirectory() with a full path will be called and it
	// allows only pathnames that are shorter than 248 chars.
	// The limitation is applied here already in order not to confuse the user
	// and alert on long pathname always before trying to create it.
	//

	TCHAR szFullPathName[MAX_STORAGE_DIR];
	LPTSTR szFilePart;

	DWORD dwSize = GetFullPathName(
							strPath, 
							MAX_STORAGE_DIR, 
							szFullPathName, 
							&szFilePart
							);


	if ( dwSize == 0 )
	{
		CString strError;
		GetLastErrorText(strError);

		CString strMessage;
        strMessage.FormatMessage(IDS_ERROR_NOT_A_DIR, strPath, strError);

        AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

		pDX->PrepareEditCtrl(Id);
	    pDX->Fail();
	}

	if ( dwSize > MAX_STORAGE_DIR )
	{
		CString strError;
        strError.FormatMessage(IDS_FOLDERNAME_TOO_LONG, strPath);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

	    pDX->PrepareEditCtrl(Id);
	    pDX->Fail();
	}

	CharUpper(szFullPathName);
	strPath = szFullPathName;
}


/////////////////////////////////////////////////////////////////////////////
// CStoragePage property page

IMPLEMENT_DYNCREATE(CStoragePage, CMqPropertyPage)

CStoragePage::CStoragePage() : CMqPropertyPage(CStoragePage::IDD)
{
    HRESULT rc;
    DWORD dwSize;
    DWORD dwType = REG_SZ;
	TCHAR szTemp[1000];
	TCHAR szRegName[1000];
	

	//
	// Get Message Files Folder
	//
	_tcscpy(szRegName, MSMQ_STORE_PERSISTENT_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);

    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldMsgFilesDir = szTemp;


	//
	// Get Message Logger Folder
	//
	_tcscpy(szRegName,MSMQ_STORE_LOG_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);

    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldMsgLoggerDir = szTemp;


	//
	// Get Transaction Logger Folder
	//
	_tcscpy(szRegName,FALCON_XACTFILE_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);
    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldTxLoggerDir = szTemp;

    //{{AFX_DATA_INIT(CStoragePage)
    m_MsgFilesDir = m_OldMsgFilesDir;
    m_MsgLoggerDir = m_OldMsgLoggerDir;
    m_TxLoggerDir = m_OldTxLoggerDir;
    //}}AFX_DATA_INIT
}

CStoragePage::~CStoragePage()
{
}


void CStoragePage::DDV_FullPathNames(CDataExchange* pDX)
{
	DDV_SingleFullPath(m_MsgFilesDir, pDX, ID_MessageFiles);
	DDV_SingleFullPath(m_MsgLoggerDir, pDX, ID_MessageLogger);
	DDV_SingleFullPath(m_TxLoggerDir, pDX, ID_TransactionLogger);
}


void CStoragePage::DoDataExchange(CDataExchange* pDX)
{    
    CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //{{AFX_DATA_MAP(CStoragePage)
    DDX_Text(pDX, ID_MessageFiles, m_MsgFilesDir);
	DDV_NotEmpty(pDX, m_MsgFilesDir, IDS_MISSING_MSGFILES_FOLDER);

    DDX_Text(pDX, ID_MessageLogger, m_MsgLoggerDir);
	DDV_NotEmpty(pDX, m_MsgLoggerDir, IDS_MISSING_LOGGER_FOLDER);

    DDX_Text(pDX, ID_TransactionLogger, m_TxLoggerDir);
	DDV_NotEmpty(pDX, m_TxLoggerDir, IDS_MISSING_TX_LOGGER_FOLDER);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {

		DDV_FullPathNames(pDX);


        //
        // Identify changes in directory names. For each directory name that
        // had changed, verify that it is a valid directory and create it if
        // neccessary. The check should be done only once per directory name.
        // This is because we warn about the security of the directroy and
        // we do not want to warn more than once per directory.
        //

        if (_tcsicmp(m_MsgFilesDir, m_OldMsgFilesDir) != 0)
        {
            DDV_IsDirectory(this->m_hWnd, pDX, ID_MessageFiles, m_MsgFilesDir);
            m_fModified = TRUE;
        }

        if (_tcsicmp(m_MsgLoggerDir, m_OldMsgLoggerDir) != 0)
        {
            if (m_MsgLoggerDir != m_MsgFilesDir)
            {
                DDV_IsDirectory(this->m_hWnd, pDX, ID_MessageLogger, m_MsgLoggerDir);
            }
            
			m_fModified = TRUE;
        }

        if (_tcsicmp(m_TxLoggerDir, m_OldTxLoggerDir) != 0)
        {
			BOOL fCheckedTxDir = (m_TxLoggerDir == m_MsgFilesDir || m_TxLoggerDir == m_MsgLoggerDir);

            if (!fCheckedTxDir)
            {
                DDV_IsDirectory(this->m_hWnd, pDX, ID_TransactionLogger, m_TxLoggerDir);
            }
            
			m_fModified = TRUE;
        }      
    }
}


BOOL CStoragePage::MoveFilesToNewFolders()
{
    //
    // Get the current persistent storage directory and compare it with the new
    // directory. Only if the directories are different, we try to move the files.
    // Otherwise we will end up with an error becasue we try to move the files over
    // them selves.
    //
	TCHAR szPrevDir[MAX_PATH];
	DWORD dwType = REG_SZ;
    DWORD dwSize = sizeof(szPrevDir);
    
	HRESULT rc = GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	TCHAR szNewDir[MAX_PATH];
	_tcscpy(szNewDir,m_MsgFilesDir);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
		TCHAR szPrevLQSDir[MAX_PATH];
        TCHAR wszNewLQSDir[MAX_PATH];
        TCHAR szNewLQSDir[MAX_PATH];

        //
        // The LQS moves together with the persistent storage. So first find
        // the source and edstination LQS directories. Try to create the
        // destination LQS directory.
        //

		_tcscat(_tcscpy(szPrevLQSDir, szPrevDir), TEXT("\\LQS"));
        _tcscat(_tcscpy(wszNewLQSDir, szNewDir), TEXT("\\LQS"));

		_tcscpy(szNewLQSDir,wszNewLQSDir);

		if (CreateDirectory(szNewLQSDir, NULL))
        {
            if (!SetDirectorySecurity(szNewLQSDir))
            {
       			CString strMessage;
                CString strError;

                RemoveDirectory(szNewLQSDir);

                GetLastErrorText(strError);
                strMessage.FormatMessage(IDS_SET_DIR_SECURITY_ERROR, szNewLQSDir, (LPCTSTR)strError);
                AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

                return FALSE;                    
            }
        }
        else if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            //
            // Failed to create the destination LQS directory.
            //
            CString strMessage;
            CString strError;

            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_FAILED_TO_CREATE_LQS_DIR, (LPCTSTR)strError);            
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            return FALSE;                
        }

        //
        // Move the persistent messages.
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("p*.mq")))
        {
            return FALSE;                
        }

        //
        // Move the LQS files.
        //
        if (!MoveFiles(szPrevLQSDir, wszNewLQSDir, TEXT("*.*")))
        {
            //
            // Faield to copy the LQS files, replace the persistent messages in the
            // original directory.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("p*.mq"), TRUE);
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the journal messages.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("j*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,szNewDir,&dwSize);
		ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the reliable messages.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("r*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the message log files.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	_tcscpy(szNewDir, m_MsgLoggerDir);
    
    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("l*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize =(numeric_cast<DWORD>( _tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the transaction files.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	_tcscpy(szNewDir, m_TxLoggerDir);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        //
        // move the *.lg1 files.
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("*.lg1")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // move the *.lg2 files.
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("*.lg2")))
        {
            //
            // Faield to move the *.lg2 files. Replace the *.lg1 files in the
            // original source directory and do not update the registry.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg1"), TRUE);
            return FALSE;                
        }

        //
        // Move the QMLog file
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("QMLog")))
        {
            //
            // Faield to move the QMLog file. Replace the *.lg1 and *.lg2 files
            // in the original source directory and do not update the registry.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg1"), TRUE);
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg2"), TRUE);
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) +1 )) * sizeof(TCHAR);

        rc = SetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }
	
	return TRUE;
}


BOOL CStoragePage::OnApply() 
{

    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    BOOL fServiceIsRunning;
    if (!GetServiceRunningState(&fServiceIsRunning))
    {
        //
        // Failed to get service status - do not do anything
		// GetServiceRunningState() displays error in this case
        //
        return FALSE;        
    }


    //
    // The service is running, ask the user whether it wants to stop it.
    // If the service is not stopped, we do not move the files and do not
    // update the registry.
    //
    if (fServiceIsRunning)
    {
		CString strMessage;
        strMessage.LoadString(IDS_Q_STOP_SRVICE);           
        
		if (AfxMessageBox(strMessage, 
						MB_YESNO | MB_ICONQUESTION) == IDNO)
        {
            //
            // So, the user doesn't want to stop the service, be it.
            //
            return FALSE;            
        }

        //
        // Stop the service.
        //
        CString strStopService;

        strStopService.LoadString(IDS_STOP_SERVICE);
        CInfoDlg StopServiceDlg(strStopService, this);

        if (!StopService())
        {
            //
            // Failed to stop the service.
            //
            return FALSE;            
        }
    }
   

    CString strMovingFiles;
    strMovingFiles.LoadString(IDS_MOVING_FILES);

    {
		CInfoDlg CopyFilesDlg(strMovingFiles, this);

		BOOL fRes = MoveFilesToNewFolders();

		if (!fRes)
		{
			return FALSE;
		}
    }

	if (fServiceIsRunning)
	{
		m_fNeedReboot = TRUE;
	}
	
	//
	// Update old values
	//
	m_OldMsgFilesDir = m_MsgFilesDir;
	m_OldMsgLoggerDir = m_MsgLoggerDir;
	m_OldTxLoggerDir = m_TxLoggerDir;

	m_fModified = FALSE;

    return CMqPropertyPage::OnApply();
}

BEGIN_MESSAGE_MAP(CStoragePage, CMqPropertyPage)
    //{{AFX_MSG_MAP(CStoragePage)  
    ON_EN_CHANGE(ID_MessageFiles, OnChangeRWField)
    ON_EN_CHANGE(ID_MessageLogger, OnChangeRWField)
    ON_EN_CHANGE(ID_TransactionLogger, OnChangeRWField)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStoragePage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\strconv.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    strconv.h

Abstract:

    String conversion functions. This module contains conversion functions of
    MSMQ codes to strings - for display

Author:

    Yoel Arnon (yoela)

--*/

#ifndef _STRCONV_H_
#define _STRCONV_H_

#define DEFINE_CONVERSION_FUNCTION(fName) LPTSTR fName(DWORD dwCode);

DEFINE_CONVERSION_FUNCTION(PrivacyToString)

LPTSTR MsmqServiceToString(BOOL fRout, BOOL fDepCl, BOOL fForeign);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\strconv.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    strconv.cpp

Abstract:

    String conversion functions. This module contains conversion functions of
    MSMQ codes to strings - for display

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "mqsnap.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include "resource.h"
#include "dataobj.h"
#include "globals.h"
#include "strconv.h"

#include "strconv.tmh"

//
// Max display length - this is the maximum number of characters we will display anywhere
//
static const DWORD x_dwMaxDisplayLen = 256;
struct StringIdMap 
{
    DWORD dwCode;
    UINT  uiStrId;
};

#define BEGIN_CONVERSION_FUNCTION(fName) \
LPTSTR fName(DWORD dwCode) \
{ \
    static StringIdMap l_astrIdMap[] = { 

#define STRING_CONV_ENTRY(Code) \
        {Code, IDS_ ## Code},

#define END_CONVERSION_FUNCTION \
    }; \
    static const  DWORD x_dwMapSize = sizeof(l_astrIdMap) / sizeof(l_astrIdMap[0]); \
    static BOOL l_fFirstTime = TRUE; \
    static TCHAR l_atstrResults[x_dwMapSize][x_dwMaxDisplayLen]; \
    return CodeToString(dwCode, l_atstrResults, l_astrIdMap, \
                        x_dwMapSize, &l_fFirstTime); \
}


LPTSTR CodeToString (
    DWORD dwCode,
    TCHAR atstrResults[][x_dwMaxDisplayLen], 
    const StringIdMap astrIdMap[],
    DWORD dwMapSize,
    BOOL *fFirstTime)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
    if (*fFirstTime)
    {
        *fFirstTime = FALSE;
        for (DWORD i = 0; i<dwMapSize; i++)
        { 
            DWORD nChars = 
				::LoadString(g_hResourceMod, astrIdMap[i].uiStrId, 
					         atstrResults[i], x_dwMaxDisplayLen);
            if (0 == nChars) 
            {
				#ifdef _DEBUG
					HRESULT hr = GetLastError();
				#endif
				ASSERT(0);
                atstrResults[i][0] = 0;
            }
        }
    }
    for (DWORD i=0; i < dwMapSize; i++)
    { 
        if (astrIdMap[i].dwCode == dwCode) 
        {
            return atstrResults[i]; 
        } 
    } 
    return TEXT("");
}

BEGIN_CONVERSION_FUNCTION(PrivacyToString)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_NONE)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_OPTIONAL)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_BODY)
END_CONVERSION_FUNCTION


//---------------------------------------------------------
//
//  Get a string describing the service type
//
//---------------------------------------------------------
//
// Service codes - internal for the snapin
//
enum MsmqServiceCodes
{
    MQSRV_ROUTING_SERVER,
    MQSRV_SERVER,
    MQSRV_FOREIGN_WORKSTATION,
    MQSRV_INDEPENDENT_CLIENT
};

BEGIN_CONVERSION_FUNCTION(MsmqInternalSeriveToString)
    STRING_CONV_ENTRY(MQSRV_ROUTING_SERVER)
    STRING_CONV_ENTRY(MQSRV_SERVER)
    STRING_CONV_ENTRY(MQSRV_FOREIGN_WORKSTATION)
    STRING_CONV_ENTRY(MQSRV_INDEPENDENT_CLIENT)
END_CONVERSION_FUNCTION


LPTSTR MsmqServiceToString(BOOL fRout, BOOL fDepCl, BOOL fForeign)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Routing server
    //
    if (fRout)
    {
        return MsmqInternalSeriveToString(MQSRV_ROUTING_SERVER);
    }

    //
    // MSMQ server (no routing)
    //
    if (fDepCl)
    {
        return MsmqInternalSeriveToString(MQSRV_SERVER);
    }

    //
    // Foreign client
    //
	if ( fForeign)
	{
		return MsmqInternalSeriveToString(MQSRV_FOREIGN_WORKSTATION);
	}


    //
    // Independent client
    //
	return MsmqInternalSeriveToString(MQSRV_INDEPENDENT_CLIENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\sysq.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	sysq.h

Abstract:

	Definition for the computer extension snapnin node class.

Author:

    RaphiR

--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SYSQ_H_
#define __SYSQ_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "rdmsg.h"

#include "icons.h"

/****************************************************

        CPrivateFolder Class
    
 ****************************************************/
class CPrivateFolder : public CNodeWithScopeChildrenList<CPrivateFolder, FALSE>
{
public:
	GUID                    m_guidId;           // Guid of the computer
	CString                 m_pwszGuid;         // Ditto - but as a string
	CString					m_szMachineName;

   	BEGIN_SNAPINCOMMAND_MAP(CPrivateFolder, FALSE)
	END_SNAPINCOMMAND_MAP()

    CPrivateFolder(CSnapInItem * pParentNode, CSnapin * pComponentData, CString strMachineName) : 
		CNodeWithScopeChildrenList<CPrivateFolder, FALSE>(pParentNode, pComponentData),
		m_szMachineName(strMachineName)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CPrivateFolder()
	{
	}

    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
};


/****************************************************

        CSystemQueues Class
    
 ****************************************************/
class CSystemQueues : public CNodeWithScopeChildrenList<CSystemQueues, FALSE>
{
public:
	GUID                    m_guidId;           // Guid of the computer
	CString                 m_pwszGuid;         // Ditto - but as a string

   	BEGIN_SNAPINCOMMAND_MAP(CSystemQueues, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSystemQueues(CSnapInItem * pParentNode, CSnapin * pComponentData, CString &pwszComputerName) : 
        CNodeWithScopeChildrenList<CSystemQueues, FALSE>(pParentNode, pComponentData)
    {
        m_guidId = GUID_NULL;
        m_pwszGuid = L"";

        if(pwszComputerName == L"")
        {
            HRESULT hr = GetComputerNameIntoString(m_pwszComputerName);
            if FAILED(hr)
            {
                ASSERT(0);
                m_pwszComputerName = L"" ;
            }
        }
        else
        {
            m_pwszComputerName = pwszComputerName;
        }
        SetIcons(IMAGE_SYSTEM_FOLDER_CLOSE, IMAGE_SYSTEM_FOLDER_OPEN);
    }

	~CSystemQueues()
	{
	}

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

private:

	virtual CString GetHelpLink();

protected:
	CString m_pwszComputerName;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\sysq.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	sysq.cpp

Abstract:


Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "mqsnap.h"
#include "globals.h"
#include "sysq.h"
#include "snapin.h"
#include "rdmsg.h"
#include "rt.h"
#include "SnpQueue.h"
#include "admmsg.h"

#include "sysq.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************

        CPrivateFolder Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CPrivateFolder
// {3F965592-CF62-11d1-9B9D-00E02C064C39}
static const GUID CPrivateFolderGUID_NODETYPE = 
{ 0x3f965592, 0xcf62, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CPrivateFolder::m_NODETYPE = &CPrivateFolderGUID_NODETYPE;
const OLECHAR* CPrivateFolder::m_SZNODETYPE = OLESTR("3F965592-CF62-11d1-9B9D-00E02C064C39");
const OLECHAR* CPrivateFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CPrivateFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CString strTitle;
    CPrivateQueue *pQ;
    CString strFn;
    CString strPrefix;

    //
    // Display private queues
    //
    AP<UCHAR> pListofPrivateQ;
    DWORD dwNoofQ;

    {
        CWaitCursor wc;

        //
        // Send an admin message to request the list of private queues
        //
        hr = RequestPrivateQueues(m_guidId, &pListofPrivateQ, &dwNoofQ);
    }

    if(FAILED(hr))
    {
		//
		// Issue clear error message in timeout case
		//
		if ( hr == MQ_ERROR_IO_TIMEOUT )
		{
			DisplayErrorAndReason(IDS_OP_REQUESTPRIVATEQUEUE, IDS_MSMQ_MAY_BE_DOWN, L"", hr);
			return S_OK;
		}

        MessageDSError(hr, IDS_OP_REQUESTPRIVATEQUEUE);
        return(S_OK);
    }


    strPrefix = L"PRIVATE=" + m_pwszGuid;

    PUCHAR pPrivQPos = (PUCHAR)pListofPrivateQ;

    for(DWORD i = 0; i < dwNoofQ; i++)
    {
        //
        //Retrieve Private Queue ID;
        //
        DWORD dwQueueID = *(DWORD UNALIGNED *)pPrivQPos;
        pPrivQPos += sizeof(DWORD);
        //
        // Retreive PATHNAME
        //   
        CString csName = (LPTSTR)pPrivQPos; 

        pPrivQPos += (wcslen(csName) + 1)*sizeof(WCHAR);

        //
        // Create Private queue
        //
        pQ = new CPrivateQueue(this, m_pComponentData);

        pQ->m_szPathName = csName;
		pQ->m_szMachineName = m_szMachineName;

        //
        // Extract the queue name only from the full private path name
        //
        CString szUpperName = csName;
        szUpperName.MakeUpper();

        int n = szUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR);
        ASSERT(n != -1);

        pQ->m_bstrDisplayName = csName.Mid(n + PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

        // Set the format name
        strFn.Format(L"%s"
                     FN_PRIVATE_SEPERATOR    // "\\"
                     FN_PRIVATE_ID_FORMAT,
                     strPrefix, dwQueueID);
        pQ->m_szFormatName = strFn;
        pQ->SetIcons(IMAGE_PRIVATE_QUEUE, IMAGE_PRIVATE_QUEUE);

        // Add it to the left pane

    	AddChild(pQ, &pQ->m_scopeDataItem);
    }

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );


    return(hr);
}
        

/****************************************************

        CSystemQueues Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CSystemQueues
// {A97E9501-D2BF-11d1-9B9D-00E02C064C39}
static const GUID CSystemQueuesGUID_NODETYPE = 
{ 0xa97e9501, 0xd2bf, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CSystemQueues::m_NODETYPE = &CSystemQueuesGUID_NODETYPE;
const OLECHAR* CSystemQueues::m_SZNODETYPE = OLESTR("A97E9501-D2BF-11d1-9B9D-00E02C064C39");
const OLECHAR* CSystemQueues::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSystemQueues::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CString strTitle;

    CReadSystemMsg *p;
    CString strPrefix;
    strPrefix.Format(L"%s%s%s", FN_DIRECT_TOKEN FN_EQUAL_SIGN FN_DIRECT_OS_TOKEN, 
                m_pwszComputerName, FN_PRIVATE_SEPERATOR 
                SYSTEM_QUEUE_PATH_INDICATIOR);

    //
    // Create a Journal queue
    //   
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_JOURNAL_SUFFIX, 
                m_pwszComputerName,
                FN_JOURNAL_SUFFIX);    

    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);

    AddChild(p, &p->m_scopeDataItem);


    //
    // Create a DeadLetter queue
    //    
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_DEADLETTER_SUFFIX, 
                m_pwszComputerName,
                FN_DEADLETTER_SUFFIX);

    strTitle.LoadString(IDS_MACHINEQ_TYPE_DEADLETTER);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_DEADLETTER_QUEUE,IMAGE_DEADLETTER_QUEUE);

    AddChild(p, &p->m_scopeDataItem);


    //
    // Create a Xact DeadLetter queue
    //    
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_DEADXACT_SUFFIX, 
                m_pwszComputerName,
                FN_DEADXACT_SUFFIX );

    strTitle.LoadString(IDS_MACHINEQ_TYPE_DEADXACT);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_DEADLETTER_QUEUE,IMAGE_DEADLETTER_QUEUE);

    AddChild(p, &p->m_scopeDataItem);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::GetHelpLink

--*/
//////////////////////////////////////////////////////////////////////////////
CString 
CSystemQueues::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigadm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "ruledef.h"
#include "trigadm.h"
#include "trigdef.h"
#include "triggen.h"

#include "trigadm.tmh"

/****************************************************

CTriggerLocalAdmin Class
    
 ****************************************************/
// {34C7ED18-4933-417f-8E88-EE832F0F580E}
static const GUID CCTriggerLocalAdminGUID_NODETYPE = 
{ 0x34c7ed18, 0x4933, 0x417f,{0x8e, 0x88, 0xee, 0x83, 0x2f, 0xf, 0x58, 0xe} };

const GUID*  CTriggerLocalAdmin::m_NODETYPE = &CCTriggerLocalAdminGUID_NODETYPE;
const OLECHAR* CTriggerLocalAdmin::m_SZNODETYPE = OLESTR("34C7ED18-4933-417f-8E88-EE832F0F580E");
const OLECHAR* CTriggerLocalAdmin::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTriggerLocalAdmin::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTriggerLocalAdmin::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;

    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    if (m_szMachineName[0] != 0)
        return S_OK;

    //
    // On local machine, the user can set the trigger configuration parameters
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    //
    // We want the default verb to be Properties
    //
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
                                   

HRESULT CTriggerLocalAdmin::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CString strTitle;
    HRESULT hr;

    //
    // Add trigger definition folder
    //
    CTriggerDefinition* pTrigger = new CTriggerDefinition(this, m_pComponentData, m_pTrigSet.get(), m_pRuleSet.get(), NULL);
    if (pTrigger == NULL)
        return S_OK;

    strTitle.LoadString(IDS_TRIGGER_DEFINITION);
    pTrigger->m_bstrDisplayName = strTitle;

    hr = AddChild(pTrigger, &pTrigger->m_scopeDataItem);
    if (FAILED(hr))
        return hr;

    //
    // Add Rule definition folder
    //
    CRulesDefinition* pRule = new CRulesDefinition(this, m_pComponentData, m_pRuleSet.get());
    if (pRule == NULL)
        return S_OK;

    strTitle.LoadString(IDS_RULE_DEFINITION);
    pRule->m_bstrDisplayName = strTitle;

	hr = AddChild(pRule, &pRule->m_scopeDataItem);
    
    return hr;
}


HRESULT 
CTriggerLocalAdmin::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HPROPSHEETPAGE hConfigPage = 0;
    HRESULT hr = CreateConfigurationPage(&hConfigPage);
    
    if (SUCCEEDED(hr))
    {
        lpProvider->AddPage(hConfigPage); 
        return S_OK;
    }

    MessageDSError(hr, IDS_OP_DISPLAY_TRIGGER_CONFIG_PAGE);
    return(S_OK);
}


HRESULT 
CTriggerLocalAdmin::CreateConfigurationPage(
    HPROPSHEETPAGE *phConfig
    )
{   
    CTriggerGen* pConfig = NULL;

    try
    {
        pConfig = new CTriggerGen;
    }
    catch(const _com_error&)
    {
        return E_UNEXPECTED;
    }

    if (pConfig == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pConfig->m_psp); 
    if (hPage)
    {
        *phConfig = hPage;
        return S_OK;
    }

    ASSERT(0);
    return E_UNEXPECTED;    
}


HRESULT 
CTriggerLocalAdmin::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    CString title;
    title.LoadString(IDS_NAME);

    return pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);
}


CString 
CTriggerLocalAdmin::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\testmsg.cpp ===
// testmsg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqppage.h"
#include "admmsg.h"
#include "testmsg.h"

#include "testmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static HRESULT GetGuidFromFormatName(LPCTSTR szFormatName, GUID *pGuid);

/////////////////////////////////////////////////////////////////////////////
// CSetReportQDlg dialog



/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog


CTestMsgDlg::CTestMsgDlg(
	const GUID& gMachineID,
	const CString& strMachineName, 
	const CString& strDomainController, 
	CWnd* pParentWnd
	) : 
	CMqDialog(IDD, pParentWnd), m_gMachineID(gMachineID),
    m_strMachineName(strMachineName),
	m_strDomainController(strDomainController)
{
	//{{AFX_DATA_INIT(CTestMsgDlg)
	//}}AFX_DATA_INIT
    m_iSentCount = 0;
}


void CTestMsgDlg::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTestMsgDlg)
	DDX_Control(pDX, IDC_TESTMESSAGE_SEND, m_ctlSendButton);
	DDX_Control(pDX, IDC_TESTMESSAGE_DESTQ, m_DestQueueCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTestMsgDlg, CMqDialog)
	//{{AFX_MSG_MAP(CTestMsgDlg)
	ON_BN_CLICKED(IDC_TESTMESSAGE_NEW, OnTestmessageNew)
	ON_BN_CLICKED(IDC_TESTMESSAGE_SEND, OnTestmessageSend)
	ON_BN_CLICKED(IDC_TESTMESSAGE_CLOSE, OnTestmessageClose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg private functions

    
/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg message handlers


void CTestMsgDlg::OnTestmessageNew() 
{
	static const GUID x_TestGuidType = MQ_QTYPE_TEST;

    CNewQueueDlg NewQDlg(this, IDS_TESTQ_LABEL, x_TestGuidType);
    if(NewQDlg.DoModal() == IDOK)
    {

        //
        // add queue to the combo-box. Enable "Send" button in case
        // the list was empty previousely
        //
	    int iItem = m_DestQueueCtrl.AddString(NewQDlg.m_strPathname);
        if (CB_ERR == iItem)
        {
            ASSERT(0);
            return;
        }

        INT_PTR iArrayIndex = m_aguidAllQueues.Add(NewQDlg.m_guid);
        m_DestQueueCtrl.SetItemData(iItem, iArrayIndex);

        m_DestQueueCtrl.SelectString(-1, NewQDlg.m_strPathname);
        m_ctlSendButton.EnableWindow(TRUE);
    }
}

BOOL CTestMsgDlg::OnInitDialog() 
{
    GUID TestGuidType = MQ_QTYPE_TEST;

    CMqDialog::OnInitDialog();
    //
    // Set the title to "Sending messages from ..."
    //
    CString strTitleFormat;
    strTitleFormat.LoadString(IDS_TEST_TITLE_FORMAT);

    CString strTitle;
    strTitle.FormatMessage(strTitleFormat, m_strMachineName);

    SetWindowText(strTitle);
	
	//
    // Query the DS for all the test-queues and insert them into 
    // the combo-box
    //
    CRestriction restriction;
    restriction.AddRestriction(&TestGuidType, PROPID_Q_TYPE, PREQ, 0);

    CColumns columns;
    columns.Add(PROPID_Q_PATHNAME);
    columns.Add(PROPID_Q_INSTANCE);

    const DWORD x_dwResultBufferSize = 64;
    PROPVARIANT apResultProps[x_dwResultBufferSize];
    DWORD dwPropCount = x_dwResultBufferSize;
  
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryQueues(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    restriction.CastToStruct(),
                    columns.CastToStruct(),
                    0,
                    &hEnume
                    );
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return TRUE;
    }

    while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
            && (dwPropCount != 0) )
    {
        for (DWORD i=0; i<dwPropCount; i++)
        {
            int iItem = m_DestQueueCtrl.AddString(apResultProps[i].pwszVal);
            MQFreeMemory(apResultProps[i].pwszVal);

            i++;
            INT_PTR iArrayIndex = m_aguidAllQueues.Add(*apResultProps[i].puuid);
            m_DestQueueCtrl.SetItemData(iItem, iArrayIndex);
            MQFreeMemory(apResultProps[i].puuid);
        }
        dwPropCount = x_dwResultBufferSize;
    }

    //
    // make the first item the default selection (if any items exist)
    //
    if (CB_ERR == m_DestQueueCtrl.SetCurSel(0))
    {
        m_ctlSendButton.EnableWindow(FALSE);
    }
    else
    {
        m_ctlSendButton.EnableWindow(TRUE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewQueueDlg dialog


CNewQueueDlg::CNewQueueDlg(CWnd* pParent /*=NULL*/,
                                           UINT uiLabel /* = IDS_TESTQ_LABEL */,
                                           const GUID &guid_Type /* = GUID_NULL */
                                           )
	: CMqDialog(CNewQueueDlg::IDD, pParent),
      m_fValid(FALSE)
{
	//{{AFX_DATA_INIT(CNewQueueDlg)
	m_strPathname = _T("");
	//}}AFX_DATA_INIT
    VERIFY(m_strQLabel.LoadString(uiLabel));
    m_guidType = guid_Type;
}


void CNewQueueDlg::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewQueueDlg)
	DDX_Text(pDX, IDC_NEWQTYPE_QUEUENAME, m_strPathname);
	//}}AFX_DATA_MAP
    DDV_NotPrivateQueue(pDX, m_strPathname);
}


BEGIN_MESSAGE_MAP(CNewQueueDlg, CMqDialog)
	//{{AFX_MSG_MAP(CNewQueueDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CNewQueueDlg::OnOK() 
{
    if (0 == UpdateData(TRUE))
    {
        //
        // Update data failed
        //
        return;
    }

    CWaitCursor wait;
    CString csNewPathName;

    HRESULT hr;
    //
    // Create the queue
    //
    PROPID aProp[] = {PROPID_Q_PATHNAME, PROPID_Q_LABEL, PROPID_Q_TYPE};
    const x_nProps = sizeof(aProp) / sizeof(aProp[0]);
    PROPVARIANT apVar[x_nProps];

    DWORD iProp = 0;

    ASSERT(PROPID_Q_PATHNAME == aProp[iProp]);
    apVar[iProp].vt = VT_LPWSTR;
    apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(m_strPathname);
    iProp++;

    ASSERT(PROPID_Q_LABEL == aProp[iProp]);
    apVar[iProp].vt = VT_LPWSTR;
    apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(m_strQLabel);
    iProp++;

    ASSERT(PROPID_Q_TYPE == aProp[iProp]);
    apVar[iProp].vt = VT_CLSID;
    apVar[iProp].puuid = &m_guidType;

    MQQUEUEPROPS mqp = {x_nProps, aProp, apVar, 0};

    WCHAR strFormatName[64];
    DWORD dwFormatLen = sizeof(strFormatName) / sizeof(strFormatName[0]);

    hr = MQCreateQueue(0, &mqp, strFormatName, &dwFormatLen);

    if(FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_CREATE, m_strPathname);
        return;
    }

    if (FAILED(GetGuidFromFormatName(strFormatName, &m_guid)))
    {
        ASSERT(0);
        return;
    }
	
	CMqDialog::OnOK();
}


//
// This function verifies that the given queue pathname is not a private
// queue pathname
//
void CNewQueueDlg::DDV_NotPrivateQueue(CDataExchange * pDX, CString& strQueuePathname)
{
    if (pDX->m_bSaveAndValidate)
    {
        CString strUpperName = strQueuePathname;
        strUpperName.MakeUpper();

        if (-1 != strUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR))
        {
            //
            // This is a private queue pathname
            //
            AfxMessageBox(IDS_PRIVATE_QUEUE_NOT_SUPPORTED);
            pDX->Fail();
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog


void CTestMsgDlg::OnTestmessageSend() 
{
    CWaitCursor wc;
	//
    // retrieve the selected queue
    //
	int iSelectedQueue = m_DestQueueCtrl.GetCurSel();

	if (iSelectedQueue == CB_ERR)
    {
        //
        // If nothing is selected, send should not be enabled
        //
        ASSERT(0);
        return;
    }
    
    INT_PTR iArrayIndex = m_DestQueueCtrl.GetItemData(iSelectedQueue);
    ASSERT(CB_ERR != iArrayIndex);

    HRESULT rc = SendQMTestMessage(m_gMachineID, m_aguidAllQueues[iArrayIndex]);
    if(FAILED(rc))
    {
        MessageDSError(rc, IDS_OP_SEND_TEST_MESSAGE, m_strMachineName);
    }
    else
    {
        IncrementSentCount();
    }
}

void CTestMsgDlg::IncrementSentCount() 
{
    CStatic *pstaticCounter = (CStatic *)GetDlgItem(IDC_TESTMESSAGE_NO_SENT);
    CString strCountText;
    m_iSentCount++;

    strCountText.Format(TEXT("%d"), m_iSentCount);

    pstaticCounter->SetWindowText(strCountText);
}

void CTestMsgDlg::OnTestmessageClose() 
{
    EndDialog(TRUE);
}

/*===================================================
GetGuidFromFormatName

Get a Format Name of the form "PUBLIC=xxxx.x.x.x" and
return the GUID
(Quite ugly code - but it is better than a query to the DS)

 ===================================================*/
HRESULT GetGuidFromFormatName(LPCTSTR szFormatName, GUID *pGuid)
{
    TCHAR szTmpName[64];
    HRESULT hr;


    if(memcmp(szFormatName, TEXT("PUBLIC="), 14) != 0)
        return(MQ_ERROR);

    lstrcpy(szTmpName,&szFormatName[6]);

    szTmpName[0] = L'{';
    szTmpName[37] = L'}';
    szTmpName[38] = 0;

    hr = IIDFromString(&szTmpName[0], pGuid);

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigadm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.h

Abstract:
	Definition for the trigger objects

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGADM_H__
#define __TRIGADM_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

#include "rule.h"
#include "trigger.h"

// -----------------------------------------------------
//
// CTriggerLocalAdmin
//
// -----------------------------------------------------
class CTriggerLocalAdmin : public CNodeWithScopeChildrenList<CTriggerLocalAdmin, FALSE>
{
public:
   	SNAPINMENUID(IDR_TRIGADM_MENUE)

    CTriggerLocalAdmin(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CString strComputer
        ) : 
        CNodeWithScopeChildrenList<CTriggerLocalAdmin, FALSE>(pParentNode, pComponentData),
        m_szMachineName(strComputer),
        m_pRuleSet(GetRuleSet(strComputer)),
        m_pTrigSet(GetTriggerSet(strComputer))
    {
		SetIcons(IMAGE_TRIGGERS_GENERAL,IMAGE_TRIGGERS_GENERAL);
    }

	~CTriggerLocalAdmin()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateScopeChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
    HRESULT CreateConfigurationPage(HPROPSHEETPAGE *phConfig);
	virtual CString GetHelpLink();

public:
    CString m_szMachineName;
    R<CRuleSet> m_pRuleSet;
    R<CTriggerSet> m_pTrigSet;
};

#endif // __TRIGADM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\testmsg.h ===
// SetRQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog

class CTestMsgDlg : public CMqDialog
{
// Construction
public:
	CTestMsgDlg(
		const GUID& gMachineID, 
		const CString& strMachineName, 
		const CString& strDomainController, 
		CWnd* pParentWnd
		);

    

// Dialog Data

    CString m_strSelectedQueue;

	//{{AFX_DATA(CTestMsgDlg)
	enum { IDD = IDD_TESTMESSAGE };
	CButton	m_ctlSendButton;
	CComboBox	m_DestQueueCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestMsgDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    GUID m_gMachineID;
	CString m_strMachineName;
	CString m_strDomainController;
	int m_iSentCount;
	void IncrementSentCount();
    CArray<GUID, const GUID&> m_aguidAllQueues;

	// Generated message map functions
	//{{AFX_MSG(CTestMsgDlg)
	afx_msg void OnTestmessageNew();
	virtual BOOL OnInitDialog();
	afx_msg void OnTestmessageSend();
	afx_msg void OnTestmessageClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CNewQueueDlg dialog

class CNewQueueDlg : public CMqDialog
{
// Construction
public:
	CString m_strQLabel;
	BOOL m_fValid;
	GUID m_guid;
	CNewQueueDlg(CWnd* pParent = NULL,
                         UINT uiLabel = IDS_TESTQ_LABEL,
                         const GUID &guid_Type = GUID_NULL);

// Dialog Data
	//{{AFX_DATA(CNewQueueDlg)
	enum { IDD = IDD_NEWTYPED_QUEUE };
	CString	m_strPathname;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewQueueDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewQueueDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void DDV_NotPrivateQueue(CDataExchange* pDX, CString& strQueuePathname);
	GUID m_guidType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\triggen.cpp ===
// triggen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "triggen.h"

#include "triggen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTriggerGen property page

IMPLEMENT_DYNCREATE(CTriggerGen, CMqPropertyPage)

CTriggerGen::CTriggerGen() : 
    CMqPropertyPage(CTriggerGen::IDD),
    m_triggerCnf(L"MSMQTriggerObjects.MSMQTriggersConfig.1")
{
    long temp;

    //
    // get defaultmsg body size. 
    //
    m_triggerCnf->get_DefaultMsgBodySize(&temp);
    m_orgDefaultMsgBodySize = static_cast<DWORD>(temp);

    //
    // Vaidate default message body size. If it's greater then the max value
    // set the maximum
    //
    if (m_orgDefaultMsgBodySize > xDefaultMsbBodySizeMaxValue)
    {
        m_defaultMsgBodySize = xDefaultMsbBodySizeMaxValue;
    }
    else
    {
        m_defaultMsgBodySize = static_cast<DWORD>(temp);
    }

    //
    // Get maximume number of trhead
    //
    m_triggerCnf->get_MaxThreads(&temp);
    m_orgMaxThreadsCount = static_cast<DWORD>(temp);

    //
    // Validate max number of thread. If it's greater then the max value set the maximum
    //
    if (m_orgMaxThreadsCount > xMaxThreadNumber)
    {
        m_maxThreadsCount = xMaxThreadNumber;
    }
    else
    {
        m_maxThreadsCount = static_cast<DWORD>(temp);
    }

    //
    // Get Initial number of thread. If it's greater then the max number of thread set the value
    // to max thread number
    //
    m_triggerCnf->get_InitialThreads(&temp);
    m_orgInitThreadsCount = static_cast<DWORD>(temp);
    if (m_orgInitThreadsCount > m_maxThreadsCount)
    {
        m_initThreadsCount = m_maxThreadsCount;
    }
    else
    {
        m_initThreadsCount = static_cast<DWORD>(temp);
    }
}

CTriggerGen::~CTriggerGen()
{
}

void CTriggerGen::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTriggerGen)
	DDX_Text(pDX, IDC_DefaultMsgBodySize, m_defaultMsgBodySize);
    DDV_DefualtBodySize(pDX);

	DDX_Text(pDX, IDC_MaxThreadCount, m_maxThreadsCount);
    DDV_MaxThreadCount(pDX);

	DDX_Text(pDX, IDC_InitThreadsCount, m_initThreadsCount);
    DDV_InitThreadCount(pDX);
	//}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(CTriggerGen, CPropertyPage)
	//{{AFX_MSG_MAP(CTriggerGen)
	ON_EN_CHANGE(IDC_InitThreadsCount, OnChangeRWField)
	ON_EN_CHANGE(IDC_MaxThreadCount, OnChangeRWField)
	ON_EN_CHANGE(IDC_DefaultMsgBodySize, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTriggerGen::DDV_MaxThreadCount(CDataExchange* pDX)
{
    if (! pDX->m_bSaveAndValidate)
        return;

    if ((m_maxThreadsCount > xMaxThreadNumber) || (m_maxThreadsCount < 1))
    {
        CString strError;
        strError.FormatMessage(IDS_MAX_MUST_BE_LESS_THEN, xMaxThreadNumber);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        pDX->Fail();
    }
}


void CTriggerGen::DDV_InitThreadCount(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        return;
    

    if ((m_initThreadsCount > m_maxThreadsCount) || (m_initThreadsCount < 1))
    {
        CString strError;
        strError.FormatMessage(IDS_INIT_THREAD_MUST_BE_LESS_THEN_MAX, m_maxThreadsCount);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        pDX->Fail();
    }
}


void CTriggerGen::DDV_DefualtBodySize(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        return;
    
    if (m_defaultMsgBodySize > xDefaultMsbBodySizeMaxValue)
    {
        CString strError;
        strError.FormatMessage(IDS_ILLEGAL_DEAFULT_MSG_BODY_SIZE, xDefaultMsbBodySizeMaxValue);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        pDX->Fail();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTriggerGen message handlers

BOOL CTriggerGen::OnApply() 
{
    try
    {
        //
        // Propogate Trigger configuration parameters to registry
        //
        if (m_defaultMsgBodySize != m_orgDefaultMsgBodySize)
        {
            m_triggerCnf->put_DefaultMsgBodySize(m_defaultMsgBodySize);
            m_orgDefaultMsgBodySize = m_defaultMsgBodySize;
        }

        if (m_maxThreadsCount != m_orgMaxThreadsCount)
        {

            m_triggerCnf->put_MaxThreads(m_maxThreadsCount);
            m_orgMaxThreadsCount = m_maxThreadsCount;
        }

        if (m_initThreadsCount != m_orgInitThreadsCount)
        {
            m_triggerCnf->put_InitialThreads(m_initThreadsCount); 
            m_orgInitThreadsCount = m_initThreadsCount;
        }

	    return CPropertyPage::OnApply();
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigdef.h

Abstract:
	Definition for the triggers class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGDEF_H__
#define __TRIGDEF_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"

class CTriggerSet;
class CTrigger;
class CRuleResult;
class CTriggerProp;
class CAttachedRule;
class CTrigResult;
class CTriggerDefinition;


// -----------------------------------------------------
//
// CTriggerDefinition
//
// -----------------------------------------------------
class CTriggerDefinition :  public CNodeWithResultChildrenList<CTriggerDefinition, CTrigResult, CSimpleArray<CTrigResult*>, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CTriggerDefinition, FALSE)
		SNAPINCOMMAND_ENTRY(ID_NEW_TRIGGER, OnNewTrigger)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_TRIGGER_DEF_MENU)

    CTriggerDefinition(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CTriggerSet* pTrigSet,
        CRuleSet* pRuleSet,
        LPCTSTR queuePathName
        ) : 
        CNodeWithResultChildrenList<CTriggerDefinition, CTrigResult, CSimpleArray<CTrigResult*>, FALSE>(pParentNode, pComponentData),
        m_pRuleSet(SafeAddRef(pRuleSet)),
        m_pTriggerSet(SafeAddRef(pTrigSet)),
        m_queuePathName(queuePathName)
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		SetIcons(IMAGE_TRIGGERS_DEFINITION,IMAGE_TRIGGERS_DEFINITION);
    }

	~CTriggerDefinition()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateResultChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);
    
    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    R<CRuleSet> GetRuleSet(void) const
    {
        return m_pRuleSet;
    }


    RuleList GetRuleList(void)
    {
        return m_pRuleSet->GetRuleList();
    }

private:
	//
	// Menu functions
	//
	HRESULT OnNewTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

private:
    R<CTriggerSet> m_pTriggerSet;
    R<CRuleSet> m_pRuleSet;

    LPCTSTR m_queuePathName;
};


//*********************************************
//
// CTrigResult
//
//*********************************************

class CTrigResult : public CSnapinNode<CTrigResult, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CTrigResult, FALSE)
		SNAPINCOMMAND_ENTRY(ID_TASK_ENABLE, OnEnableTrigger)
		SNAPINCOMMAND_ENTRY(ID_TASK_DISABLE, OnDisableTrigger)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_TRIGGER_MENU)

    CTrigResult(
        CTriggerDefinition * pParentNode, 
        CSnapin * pComponentData,
        CTrigger* pTrigger
        ) : 
        CSnapinNode<CTrigResult, FALSE>(pParentNode, pComponentData),
        m_pTrigger(SafeAddRef(pTrigger)),
		m_pGeneral(NULL)
    {
        m_bstrDisplayName = static_cast<LPCTSTR>(GetTriggerName());

		SetIcons(IMAGE_TRIGGERS_DEFINITION, IMAGE_TRIGGERS_DEFINITION);
    }

	~CTrigResult()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

    LPOLESTR GetResultPaneColInfo(int nCol);

    HRESULT OnDelete( 
			LPARAM arg,
			LPARAM param,
			IComponentData * pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES type,
            BOOL fSilent
			);

    void OnApply(CTriggerProp* p) throw(_com_error);
    void OnApply(CAttachedRule* p) throw(_com_error);

    RuleList GetRuleList(void);
    RuleList GetAttachedRulesList(void) throw(_com_error);

	void OnDestroyPropertyPages(void);

public:
	static void Compare(CTrigResult *pItem1, CTrigResult *pItem2, int* pnResult);


private:
    HRESULT CreateGenralPage(HPROPSHEETPAGE *phGeneral);
    HRESULT CreateAttachedRulePage(HPROPSHEETPAGE *phGeneral);


	//
	// Menu functions
	//
	HRESULT OnEnableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnDisableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

public:

    const _bstr_t& GetTriggerId(void) const
    {
        return m_pTrigger->GetTriggerId();
    }


    const _bstr_t& GetTriggerName(void) const
    {
        return m_pTrigger->GetTriggerName();
    }

    
    const _bstr_t& GetQeuePathName(void) const
    {
        return m_pTrigger->GetQueuePathName();
    }

    
    SystemQueueIdentifier GetQueueType(void) const
    {
        return m_pTrigger->GetQueueType();
    }

    
    long GetNumberOfAttachedRule(void) const
    {
        return m_pTrigger->GetNumberOfAttachedRule();
    }


    bool IsEnabled(void) const
    {
        return m_pTrigger->IsEnabled();
    }


    bool IsSerialize(void) const
    {
        return m_pTrigger->IsSerialize();
    }

	MsgProcessingType GetMsgProcessingType(void) const
	{
		return m_pTrigger->GetMsgProcessingType();
	}

private:
    R<CTrigger> m_pTrigger;

    WCHAR m_strNoOfRules[20];

    CTriggerProp* m_pGeneral;
};



#endif // __TRIGDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigdef.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigdef.cpp

Abstract:
	Implementation for the triggers and rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "triggen.h"
#include "trigdef.h"
#include "ruledef.h"
#include "trigprop.h"
#include "newtrig.h"
#include "qname.h"

#include "trigdef.tmh"

static CString s_strYes;
static CString s_strNo;
static CString	s_strPeek;
static CString	s_strReceive;
static CString	s_strReceiveXact;

/****************************************************

CTriggerDefinition Class
    
 ****************************************************/
// {BA3FA90D-70AE-4414-9459-2299E98BC485}
static const GUID CTRiggerDefinitionGUID_NODETYPE = 
{ 0xba3fa90d, 0x70ae, 0x4414, {0x94, 0x59, 0x22, 0x99, 0xe9, 0x8b, 0xc4, 0x85} };

const GUID*  CTriggerDefinition::m_NODETYPE = &CTRiggerDefinitionGUID_NODETYPE;
const OLECHAR* CTriggerDefinition::m_SZNODETYPE = OLESTR("BA3FA90D-70AE-4414-9459-2299E98BC485");
const OLECHAR* CTriggerDefinition::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTriggerDefinition::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTriggerDefinition::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
                                   

HRESULT CTriggerDefinition::PopulateResultChildrenList()
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());


    try
    {
        m_pTriggerSet->Refresh();
        TriggerList trigList = m_pTriggerSet->GetTriggerList(m_queuePathName);

        for(TriggerList::iterator it = trigList.begin(); it != trigList.end(); ++it)
        {        
            P<CTrigResult> pTrigger = new CTrigResult(this, m_pComponentData, (*it).get());

            AddChildToList(pTrigger);

            pTrigger.detach();
        }
    }
    catch (const _com_error&)
    {
    }
    return S_OK;
}


HRESULT 
CTriggerDefinition::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return(S_OK);
}


HRESULT 
CTriggerDefinition::OnNewTrigger(
    bool & bHandled, 
    CSnapInObjectRootBase* pSnapInObjectRoot
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CNewTrigger newTrig(m_pTriggerSet.get(), m_pRuleSet.get(), m_queuePathName);
    if (newTrig.DoModal() == ID_WIZFINISH)
    {
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }

    return(S_OK);
}


CColumnDisplay TriggerDefintionColumn[] = {
    { IDS_TRIGGER_NAME, 80 },
    { IDS_TRIGGER_QUEUE, 150 },
    { IDS_NUM_OF_RULES, 90 },
    { IDS_TRIGGER_ENABLED, 50 },
    { IDS_TRIGGER_SERIALIZED, 60 },
	{ IDS_PROC_TYPE, 150 },
    { IDS_TRIGGER_ID, HIDE_COLUMN },
};


HRESULT 
CTriggerDefinition::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
	//
	// Initialize column values
	//
	s_strYes.LoadString(IDS_YES);
	s_strNo.LoadString(IDS_NO);
	s_strPeek.LoadString(IDS_DISPLAY_PEEK);
	s_strReceive.LoadString(IDS_DISPLAY_RECEIVE);
	s_strReceiveXact.LoadString(IDS_DISPLAY_RECEIVE_XACT);

    for (DWORD i = 0; i < ARRAYSIZE(TriggerDefintionColumn); ++i)
    {
        CString title;
        title.LoadString(TriggerDefintionColumn[i].m_columnNameId);

        HRESULT hr = pHeaderCtrl->InsertColumn(
                                        i, 
                                        title, 
                                        LVCFMT_LEFT, 
                                        TriggerDefintionColumn[i].m_width
                                        );
        if (FAILED(hr))
            return hr;
    }

    return(S_OK);
}


CString 
CTriggerDefinition::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);

	return strHelpLink;
}


/****************************************************

CTrigResult Class
    
 ****************************************************/

// {081FFF0E-1922-4f86-9D5F-3664ECAF8968}
static const GUID CTrigResultGUID_NODETYPE = 
{ 0x081fff0e, 0x1922, 0x4f86, {0x9d, 0x5f, 0x36, 0x64, 0xec, 0xaf, 0x89, 0x68} };

const GUID*  CTrigResult::m_NODETYPE = &CTrigResultGUID_NODETYPE;
const OLECHAR* CTrigResult::m_SZNODETYPE = OLESTR("081FFF0E-1922-4f86-9D5F-3664ECAF8968");
const OLECHAR* CTrigResult::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTrigResult::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTrigResult::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr;

    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}


void CTrigResult::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *pflags)
{

	//
	// Gray out menu when in enable state
	//
	if((id == ID_TASK_ENABLE) && IsEnabled())
	{
        *pflags |= MFS_DISABLED;
		return;
	}

	//
	// Gray out menu when in disable state
	//
	if((id == ID_TASK_DISABLE) && !IsEnabled())
	{
        *pflags |= MFS_DISABLED;
		return;
	}
}


HRESULT 
CTrigResult::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// If the propery page already open bring it to top
	//
	if ((m_pGeneral != NULL) && (m_pGeneral->GetParent() != NULL))
	{		
		(m_pGeneral->GetParent())->BringWindowToTop();
		return S_FALSE;
	}

    //
    // Add general trigger property page
    //
    HPROPSHEETPAGE hGeneralRule = 0;
    HRESULT hr = CreateGenralPage(&hGeneralRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_TRIGGER_GENERAL_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hGeneralRule); 


    //
    // Add attached rule page
    //
    
    HPROPSHEETPAGE hAttachedRule = 0;
    hr = CreateAttachedRulePage(&hAttachedRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_TRIGGER_ATTACHED_RULE_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hAttachedRule); 

    return S_OK;
}


HRESULT 
CTrigResult::CreateGenralPage(
    HPROPSHEETPAGE *phGeneral
    )
{   
    try
    {
        m_pGeneral = new CViewTriggerProp(this);
    
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&m_pGeneral->m_psp); 
        if (hPage)
        {
            *phGeneral = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CTrigResult::CreateAttachedRulePage(
    HPROPSHEETPAGE *phAtachedRule
    )
{  
    try
    {
        CAttachedRule* pAttachedRule = new CAttachedRule(this);
    
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pAttachedRule->m_psp); 
        if (hPage)
        {
            *phAtachedRule = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}



LPOLESTR CTrigResult::GetResultPaneColInfo(int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ARRAYSIZE(TriggerDefintionColumn) >= nCol);

    switch (TriggerDefintionColumn[nCol].m_columnNameId)
    {
        case IDS_TRIGGER_NAME:
            return GetTriggerName();

        case IDS_TRIGGER_ID:
            return GetTriggerId();

        case IDS_TRIGGER_QUEUE:
            return GetQeuePathName();

        case IDS_NUM_OF_RULES:
            swprintf(m_strNoOfRules, L"%d",GetNumberOfAttachedRule());
            return m_strNoOfRules;

        case IDS_TRIGGER_ENABLED:
			if ( IsEnabled() )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strYes));
			}
			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strNo));

        case IDS_TRIGGER_SERIALIZED:
			if ( IsSerialize() )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strYes));
			}

			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strNo));

		case IDS_PROC_TYPE:
			if ( GetMsgProcessingType() == PEEK_MESSAGE )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strPeek));
			}
			
			if ( GetMsgProcessingType() == RECEIVE_MESSAGE )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strReceive));
			}

			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strReceiveXact));

        default:
            ASSERT(0);
            return _T("");
    }
}


HRESULT CTrigResult::OnEnableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj)
{
    try
    {
        m_pTrigger->UpdateEnabled(true);
        return S_OK;
    }
    catch(const _com_error&)
    {
        //
        // BUGBUG: error message
        //
        return E_UNEXPECTED;
    }
}


HRESULT CTrigResult::OnDisableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj)
{
    try
    {
        m_pTrigger->UpdateEnabled(false);
        return S_OK;
    }
    catch(const _com_error&)
    {
        //
        // BUGBUG: error message
        //
        return E_UNEXPECTED;
    }
}


HRESULT CTrigResult::OnDelete( 
			LPARAM,
			LPARAM,
			IComponentData* pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES,
            BOOL
			)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, static_cast<LPCTSTR>(GetTriggerName()));

    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

    try
    {
        ASSERT(m_pParentNode != NULL);

        m_pTrigger->Delete();

		//
		// Remove the trigger from result list so next time the reult pane view it will
		// not present the deleted trigger
		//
		R<CTrigResult> ar = this;
		HRESULT hr = static_cast<CTriggerDefinition*>(m_pParentNode)->RemoveChild(this);
		ASSERT(SUCCEEDED(hr));

        return S_OK;
    }
    catch(const _com_error&)
    {
        CString strError;
        strError.FormatMessage(IDS_OP_DELETE, static_cast<LPCWSTR>(GetTriggerName()));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        return S_FALSE;
    }
}


void CTrigResult::OnApply(CTriggerProp* p) throw(_com_error)
{
    m_pTrigger->Update(
                    static_cast<LPCTSTR>(p->m_triggerName),
                    static_cast<LPCTSTR>(p->m_queuePathName),
                    p->m_queueType,
                    (p->m_fEnabled != 0),
                    (p->m_fSerialized != 0),
					p->m_msgProcType
                    );
}


void CTrigResult::OnApply(CAttachedRule* p) throw(_com_error)
{
    m_pTrigger->UpdateAttachedRules(p->GetAttachedRules());
}


RuleList CTrigResult::GetRuleList(void)
{
    CTriggerDefinition* pTrigDef = reinterpret_cast<CTriggerDefinition*>(m_pParentNode);
    return pTrigDef->GetRuleList();
}


RuleList CTrigResult::GetAttachedRulesList(void) throw(_com_error)
{
    CTriggerDefinition* pTrigDef = reinterpret_cast<CTriggerDefinition*>(m_pParentNode);
    R<CRuleSet> pRuleSet = pTrigDef->GetRuleSet();
    
    return m_pTrigger->GetAttachedRules(pRuleSet.get());
}



void 
CTrigResult::Compare(
	CTrigResult* pItem1, 
	CTrigResult* pItem2,
	int* pnResult
	)
{
	LPCWSTR pVal1 = pItem1->GetResultPaneColInfo(*pnResult);
	LPCWSTR pVal2 = pItem2->GetResultPaneColInfo(*pnResult);

	*pnResult = wcscmp(pVal2, pVal1);
}


CString 
CTrigResult::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}


void
CTrigResult::OnDestroyPropertyPages()
{
	m_pGeneral = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigger.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.cpp

Abstract:
	Implementation for trigger class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/
#include "stdafx.h"

#import "mqtrig.tlb" no_namespace
#include "rule.h"
#include "trigger.h"
#include "mqsymbls.h"

#include "trigger.tmh"

using namespace std;

static CTriggerSet* s_pTriggerSet = NULL;

R<CTriggerSet> GetTriggerSet(const CString& strComputer)
{
    if (s_pTriggerSet == NULL)
    {
        s_pTriggerSet = new CTriggerSet(strComputer);
    }

    return SafeAddRef(s_pTriggerSet);
}


//
// CTrigger Class implementation
//

CTrigger::CTrigger(
    CTriggerSet* pTrigSet,
    const _bstr_t& id,
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long noOfRules,
    bool fEnabled,
    bool fSerialize,
	MsgProcessingType msgProcType
    ) :
    m_pTrigSet(SafeAddRef(pTrigSet)),
    m_id(id),
    m_name(name),
    m_queuePathName(queuePathName),
    m_queueType(queueType),
    m_noOfAttachedRules(noOfRules),
    m_fEnabled(fEnabled),
    m_fSerialize(fSerialize),
	m_msgProcType(msgProcType)
{
}


void CTrigger::Update(
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    bool fEnabled,
    bool fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    if ((name == m_name) &&
        (queuePathName == m_queuePathName) &&
        (queueType == m_queueType) &&
        (fEnabled == m_fEnabled) &&
        (fSerialize == m_fSerialize) &&
		(m_msgProcType == msgProcType))
    {
        return;
    }

    m_pTrigSet->Update(
            m_id, 
            name, 
            queuePathName, 
            queueType, 
            fEnabled, 
            fSerialize,
			msgProcType
            );

    m_name = name;
    m_queuePathName = queuePathName;
    m_queueType = queueType;
    m_fEnabled = fEnabled;
    m_fSerialize = fSerialize;
	m_msgProcType = msgProcType;
}


void 
CTrigger::Update(
    const _bstr_t&  name
    ) throw(_com_error)
{
    if (name == m_name)
        return;

    m_pTrigSet->Update(
            m_id, 
            name, 
            m_queuePathName, 
            m_queueType, 
            m_fEnabled, 
            m_fSerialize,
			m_msgProcType
            );

    m_name = name;
}


void 
CTrigger::UpdateEnabled(
    bool fEnabled
    ) throw(_com_error)
{
    if (m_fEnabled == fEnabled)
        return;

    m_pTrigSet->Update(
            m_id, 
            m_name, 
            m_queuePathName, 
            m_queueType, 
            fEnabled, 
            m_fSerialize,
			m_msgProcType
            );

    m_fEnabled = fEnabled;
}


void
CTrigger::UpdateAttachedRules(
    RuleList newRuleList
    ) throw(_com_error)
{
	// 
	// Attaching a rule to a trigger isn't atomic operation. For every rule attachment, a notification 
	// message is sent to the service and as a result the service adds the rule to the trigger.
    // When the trigger has its first rule it begins to process the messages in the queue so in some cases 
	// the first message processing will take place before the processing of the notification message about 
	// the second rule attachment.	From user point of view attaching a rule to a trigger is atomic operation.
	// For achiving this, the MSMQ snapin disables the trigger before attaching the rule and re-enabls it 
	// (if needed) after all rules have been attached.
	//
	bool fEnable = m_fEnabled;

	UpdateEnabled(false);
    m_pTrigSet->UpdateAttachedRules(m_id, newRuleList);
	UpdateEnabled(fEnable);

    m_noOfAttachedRules = numeric_cast<long>(newRuleList.size());
}



//
// CTriggerSet implementation
//

CTriggerSet::CTriggerSet(
     const CString& strComputer
    ) :
    m_trigSet(L"MSMQTriggerObjects.MSMQTriggerSet.1"),
    m_fChanged(false)
{
    m_trigSet->Init(static_cast<LPCWSTR>(strComputer));
    Refresh();
}


void 
CTriggerSet::Refresh(
    void
    ) throw(_com_error)
{
    m_trigSet->Refresh();

    m_triggerList.erase(m_triggerList.begin(), m_triggerList.end());

    long noOfTriggers = m_trigSet->GetCount();
    for(long trigIndex = 0; trigIndex < noOfTriggers; ++trigIndex)
    {        
        BSTR id = NULL;
        BSTR name = NULL;
        BSTR queuePathName = NULL;
        SystemQueueIdentifier queueType;
        long noOfRules;
        long fEnabled;
        long fSerialize;
		MsgProcessingType msgProcType;

        m_trigSet->GetTriggerDetailsByIndex(
                        trigIndex,
                        &id,
                        &name,
                        &queuePathName,
                        &queueType,
                        &noOfRules,
                        &fEnabled,
                        &fSerialize,
						&msgProcType
                        );

        R<CTrigger> pTrigger = new CTrigger(
                                this,
                                id, 
                                name, 
                                queuePathName, 
                                queueType, 
                                noOfRules,
                                (fEnabled != 0),
                                (fSerialize != 0),
								msgProcType
                                );
    
        m_triggerList.push_back(pTrigger);
    }
}


R<CTrigger> 
CTriggerSet::AddTrigger(
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long fEnabled,
    long fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    BSTR trigId = NULL;

    m_trigSet->AddTrigger(
            name, 
            queuePathName, 
            queueType,
            fEnabled, 
            fSerialize,
			msgProcType,
            &trigId
            );

    R<CTrigger> pTrigger = new CTrigger(
                            this,
                            trigId, 
                            name, 
                            queuePathName, 
                            queueType, 
                            0,
                            (fEnabled != 0),
                            (fSerialize != 0),
							msgProcType
                            );

    m_triggerList.push_back(pTrigger);
    m_fChanged = true;

    return pTrigger;

}

    
void 
CTriggerSet::DeleteTrigger(
    const _bstr_t& trigId
    )throw (_com_error)
{
    m_trigSet->DeleteTrigger(trigId);

    for(TriggerList::iterator it = m_triggerList.begin(); it != m_triggerList.end(); ++it)
    {
        if (trigId == (*it)->GetTriggerId())
        {
            m_triggerList.erase(it);
            m_fChanged = true;
            return;
        }
    }

    ASSERT(0);
}


void 
CTriggerSet::Update(
    const _bstr_t& id,
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long fEnabled,
    long fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    m_trigSet->UpdateTrigger(
                    id, 
                    name, 
                    queuePathName, 
                    queueType, 
                    fEnabled, 
                    fSerialize,
					msgProcType
                    );
}


void
CTriggerSet::UpdateAttachedRules(
    const _bstr_t& id,
    RuleList newRuleList
    ) throw(_com_error)
{
    m_trigSet->DetachAllRules(id);

    long index = 0;

    for(RuleList::iterator it = newRuleList.begin(); it != newRuleList.end(); ++it)
    {  
        m_trigSet->AttachRule(id, (*it)->GetRuleId(), index++);
    }
}


RuleList
CTriggerSet::GetAttachedRules(
    const _bstr_t& triggerId, 
    CRuleSet* pRuleSet,
    long noOfRules
    ) throw(_com_error)
{
    RuleList ruleList;

    for(long ruleIndex = 0; ruleIndex < noOfRules; ++ruleIndex)
    {
        BSTR ruleId = NULL;
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCondition = NULL;
        BSTR ruleAction = NULL;
        long ruleShowWindow = NULL;

		try
		{
			m_trigSet->GetRuleDetailsByTriggerID(
                                        triggerId,
                                        ruleIndex,
                                        &ruleId,
                                        &ruleName,
                                        &ruleDescription,
                                        &ruleCondition,
                                        &ruleAction,
                                        NULL,
                                        &ruleShowWindow
                                        );

			R<CRule> pRule = new CRule(
									pRuleSet,
									ruleId, 
									ruleName, 
									ruleDescription, 
									ruleCondition, 
									ruleAction,
									(ruleShowWindow != 0)
									);  
        
			ruleList.push_back(pRule);
		}
		catch(const _com_error& e)
		{
			//
			// Legal case that the trigger already deleted
			//
			ASSERT(e.Error() == MQTRIG_TRIGGER_NOT_FOUND);
			DBG_USED(e);
		}
    }

    return ruleList;
}


TriggerList 
CTriggerSet::GetTriggerListForQueue(
    LPCTSTR queuePathName, 
    SystemQueueIdentifier queueType
    )
{
    TriggerList retList;

    for(TriggerList::iterator it = m_triggerList.begin(); it != m_triggerList.end(); ++it)
    {  
        R<CTrigger> pTrig = *it;

        if (pTrig->GetQueueType() != queueType)
            continue;

        if ((queueType != SYSTEM_QUEUE_NONE) || 
            _tcsicmp(pTrig->GetQueuePathName(), queuePathName) == 0)
        {
            retList.push_back(pTrig);
        }
    }

    return retList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigger.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.h 

Abstract:
	Definition for trigger class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGGER_H__
#define __TRIGGER_H__

#include <Tr.h>
#include <Ref.h>
#include <autoptr.h>
#include <comdef.h>
#include <list>
#include "mqcast.h"

class CTrigger;

typedef std::list< R<CTrigger> > TriggerList;

class CTriggerSet : public CReference
{
public:
    CTriggerSet(const CString& strComputer);

    void Refresh(void);

    R<CTrigger> 
    AddTrigger(
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long fEnabled,
        long fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    void 
    DeleteTrigger(
        const _bstr_t& id
        ) throw(_com_error);

    void 
    Update(
        const _bstr_t& id,
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long fEnabled,
        long fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    void
    UpdateAttachedRules(
        const _bstr_t& id,
        RuleList newRuleList
        ) throw(_com_error);

    RuleList 
    GetAttachedRules(
        const _bstr_t& triggerId,
        CRuleSet* pRuleSet,
        long noOfRules
        ) throw(_com_error);

    TriggerList GetTriggerList(LPCTSTR queuePathName)
    {
        if (queuePathName == NULL)
            return m_triggerList;

        return GetTriggerListForQueue(queuePathName, SYSTEM_QUEUE_NONE);
    }

private:
    TriggerList 
    GetTriggerListForQueue(
        LPCTSTR queuePathName, 
        SystemQueueIdentifier queueType
        );

private:
    IMSMQTriggerSetPtr m_trigSet;
    TriggerList m_triggerList;

    bool m_fChanged;
};


class CTrigger : public CReference
{
public:
    CTrigger(
        CTriggerSet* pTrigSet,
        const _bstr_t& id,
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long noOfRules,
        bool fEnabled,
        bool fSerialize,
		MsgProcessingType msgProcType
        );


    void Update(
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        bool fEnabled,
        bool fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    
    void 
    Update(
        const _bstr_t&  name
        ) throw(_com_error);


    void 
    UpdateEnabled(
        bool f
        ) throw(_com_error);


    void
    UpdateAttachedRules(
        RuleList newRuleList
        ) throw(_com_error);


    void
    Delete(
        void
        ) throw(_com_error)
    {
        m_pTrigSet->DeleteTrigger(m_id);
    }


    RuleList 
    GetAttachedRules(
        CRuleSet* pRuleSet
        ) throw(_com_error)
    {
        return m_pTrigSet->GetAttachedRules(m_id,  pRuleSet, m_noOfAttachedRules);
    }


    const _bstr_t& GetTriggerName(void) const
    {
        return m_name;
    }


    const _bstr_t& GetTriggerId(void) const
    {
        return m_id;
    }
 

    const _bstr_t& GetQueuePathName(void) const
    {
        return m_queuePathName;
    }


    SystemQueueIdentifier GetQueueType(void) const
    {
        return m_queueType;
    }

    
    long GetNumberOfAttachedRule(void) const
    {
        return m_noOfAttachedRules;
    }


    bool IsEnabled(void) const
    {
        return m_fEnabled;
    }


    bool IsSerialize(void) const
    {
        return m_fSerialize;
    }

	MsgProcessingType GetMsgProcessingType(void) const
	{
		return m_msgProcType;
	}

private:
    R<CTriggerSet> m_pTrigSet;

    _bstr_t m_id;
    _bstr_t m_name;
    _bstr_t m_queuePathName;
    SystemQueueIdentifier m_queueType;
    long m_noOfAttachedRules;
    bool m_fSerialize;
    bool m_fEnabled;
	MsgProcessingType m_msgProcType;
};


R<CTriggerSet> GetTriggerSet(const CString& strComputer);

#endif // __TRIGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\triggen.h ===
#if !defined(AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_)
#define AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// triggen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CTriggerGen dialog


class CTriggerGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CTriggerGen)

// Construction
public:
    CTriggerGen();
	~CTriggerGen();

// Dialog Data
	//{{AFX_DATA(CTriggerGen)
	enum { IDD = IDD_TRIGGER_CONFIG };
	DWORD	m_defaultMsgBodySize;
	DWORD	m_maxThreadsCount;
	DWORD	m_initThreadsCount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerGen)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void DDV_MaxThreadCount(CDataExchange* pDX);
    void DDV_InitThreadCount(CDataExchange* pDX);
    void DDV_DefualtBodySize(CDataExchange* pDX);

private:
    IMSMQTriggersConfigPtr m_triggerCnf;

	DWORD	m_orgDefaultMsgBodySize;
	DWORD	m_orgMaxThreadsCount;
	DWORD	m_orgInitThreadsCount;

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\usercert.cpp ===
// UserCert.cpp : Implementation of CUserCertificate
#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqcert.h"
#include "rtcert.h"
#include "mqPPage.h"
#include "UserCert.h"
#include "CertGen.h"

#include "usercert.tmh"

/////////////////////////////////////////////////////////////////////////////
// CUserCertificate

HRESULT 
CUserCertificate::InitializeUserSid(
    LPCWSTR lpcwstrLdapName
    )
{
    //
    // bind to the obj
    //
    R<IADs> pIADs;
    CoInitialize(NULL);
 
	HRESULT hr = ADsOpenObject( 
					lpcwstrLdapName,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pIADs
					);

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::InitializeUserSid. ADsOpenObject failed. User - %ls, hr - %x"), lpcwstrLdapName, hr));
        return hr;
    }
    
	VARIANT var;
    VariantInit(&var);
 
    //
    // Get the SID as a safe array
    //
    hr = pIADs->Get(GetSidPropertyName(), &var);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::InitializeUserSid. pIADs->Get failed. User - %ls, hr - %x"), lpcwstrLdapName, hr));
        VariantClear(&var);
        return hr; 
    }
    
	if (var.vt != (VARTYPE)(VT_ARRAY | VT_UI1))
    {
        ASSERT(0);
        VariantClear(&var);
        DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::InitializeUserSid. User - %ls, Wrong VT %x"), lpcwstrLdapName, var.vt));
        hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
        return hr; 
    }

    //
    // Extract value out of the safe array, to m_psid
    //
    ASSERT(SafeArrayGetDim(var.parray) == 1);

    LONG    lUbound;
    LONG    lLbound;

    SafeArrayGetUBound(var.parray, 1, &lUbound);
    SafeArrayGetLBound(var.parray, 1, &lLbound);
    LONG len = lUbound - lLbound + 1;

    ASSERT(0 == m_psid);
    m_psid = new BYTE[len];

    for ( long i = 0; i < len; i++)
    {
        hr = SafeArrayGetElement(var.parray, &i, m_psid + i);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::InitializeUserSid. SafeArrayGetElement failed. User - %ls, Wrong VT %x"), lpcwstrLdapName, var.vt));
            VariantClear(&var);
            return hr;
        }
    }

    VariantClear(&var);
    return hr;
}


HRESULT
CUserCertificate::InitializeMQCretificate(
    void
    )
{
    HRESULT hr;

    delete [] m_pMsmqCertificate;
    m_pMsmqCertificate = NULL;
    m_NumOfCertificate = 0;
    //
    // Get the number of Certificate
    //
    hr = RTGetUserCerts(NULL, &m_NumOfCertificate, m_psid);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pMsmqCertificate = new CMQSigCertificate*[m_NumOfCertificate];

    CMQSigCertificate **pCerts = &m_pMsmqCertificate[0];
    hr = RTGetUserCerts(pCerts, &m_NumOfCertificate, m_psid);

    return hr;
}


//
// IShellExtInit
//
STDMETHODIMP CUserCertificate::Initialize (
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if (0 == lpdobj || IsBadReadPtr(lpdobj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    //
    // Gets the LDAP path
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

	LPDSOBJECTNAMES pDSObj;
	
	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	hr = lpdobj->GetData(&formatetc, &stgmedium);

    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        pDSObj = (LPDSOBJECTNAMES)(HGLOBAL)gpDSObj;
		m_lpwstrLdapName = (LPCWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);
    }

    return hr;
}


STDMETHODIMP
CUserCertificate::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (0 == m_psid)
    {
        HRESULT hr = InitializeUserSid(m_lpwstrLdapName);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::AddPages. InitializeUserSid failed. hr - %x"), hr));
            return E_UNEXPECTED;
        }
        
        hr = InitializeMQCretificate();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_EXPLORER,DBGLVL_ERROR,_TEXT("CUserCertificate::AddPages. InitializeMQCretificate failed. hr - %x"), hr));
            return E_UNEXPECTED;
        }
    }

    //
    // Display the property page only if exist MSMQ
    // personal certificate
    //
    if (m_NumOfCertificate != 0)
    {
        HPROPSHEETPAGE hPage = CreateMSMQCertificatePage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}


CUserCertificate::CUserCertificate() :
    m_psid(NULL),
    m_pMsmqCertificate(NULL),
    m_NumOfCertificate(0)
{
}


CUserCertificate::~CUserCertificate()
{
    delete [] m_psid;
    //
    // Don't delete m_pMsmqCertificate. The class pass it to
    // CCertGen class that will release it when destruct
    //
}

HPROPSHEETPAGE 
CUserCertificate::CreateMSMQCertificatePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_NumOfCertificate != 0);

    //
    // Note: CEnterpriseDataObject is auto-delete by default
    //
	CCertGen  *pGeneral = new CCertGen();
    pGeneral->Initialize(m_pMsmqCertificate, m_NumOfCertificate);

	return CreatePropertySheetPage(&pGeneral->m_psp);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigprop.cpp ===
// trigprop.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "rulecond.h"
#include "ruleact.h"
#include "trigger.h"
#include "trigdef.h"
#include "trigprop.h"
#include "ruledef.h"
#include "newtrig.h"
#include "mqcast.h"
#include "fn.h"

#include "trigprop.tmh"

using namespace std;


static
HRESULT
IsQueueTransactional(
	LPCWSTR queuePathName,
	LPWSTR queueFormatName,
	bool* isXact
	)
{
	DWORD cPropId = 0;
	MQQUEUEPROPS qprops;
	PROPVARIANT aQueuePropVar[1];
	QUEUEPROPID aQueuePropId[1];
	HRESULT aQueueStatus[1];

	aQueuePropId[cPropId] = PROPID_Q_TRANSACTION; // Property ID
	aQueuePropVar[cPropId].vt = VT_UI1;            // Type indicator
	cPropId++;

	qprops.cProp = cPropId;           // Number of properties
	qprops.aPropID = aQueuePropId;        // Ids of properties
	qprops.aPropVar = aQueuePropVar;      // Values of properties
	qprops.aStatus = aQueueStatus;        // Error reports


	////////////////////////////////////////////////////////////////////
	// Get queue property.
	////////////////////////////////////////////////////////////////////

	//
	// The option to use triggers is enabled only in computer managment on local machine.
	// so for public queues we need to call ADGetObjectProperties() and specify the local machine domain
	//

	HRESULT hr;
	if(FnIsPrivatePathName(queuePathName))
	{	
		//
		// for Private queues call MQGetQueueProperties
		//
		TrTRACE(mqsnap, "queue %ls is private queue", queuePathName);
		hr = MQGetQueueProperties(queueFormatName, &qprops);
	}
	else
	{
		//
		// for Public queues call ADGetObjectProperties and specify the local machine domain
		//
		TrTRACE(mqsnap, "queue %ls is public queue", queuePathName);
		hr = ADGetObjectProperties(
					eQUEUE,
					LocalMachineDomain(),
					false,	// fServerName
					queuePathName,
					cPropId, 
					aQueuePropId,
					aQueuePropVar
					);
	}
		
	if (FAILED(hr))
	{
		TrERROR(mqsnap, "Failed to get PROPID_Q_TRANSACTION for queue %ls, hr = 0x%x", queuePathName, hr);
		return hr;
	}


	if (aQueuePropVar[0].bVal == MQ_TRANSACTIONAL)
	{
		*isXact = true;
	}
	else
	{
		*isXact = false;
	}

	return S_OK;
}


static
bool
ValidateTransactionalQueue(
	CString queuePathName,
	LPWSTR queueFormatName
	)
{
	bool isXact;
	HRESULT hr = IsQueueTransactional(queuePathName, queueFormatName, &isXact);
	if ( FAILED(hr) )
	{
		CString strMessage;
		strMessage.FormatMessage(IDS_XACT_NO_RETRIEVE, queuePathName);
		if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
		{
			return false;   
		}
	}

	if ( SUCCEEDED(hr) && !isXact )
	{
		CString strError;
		strError.FormatMessage(IDS_QUEUE_NOT_XACT, queuePathName);

		AfxMessageBox(strError);
		return false;   
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp property page

CTriggerProp::CTriggerProp(
	UINT nIDPage,
	UINT nIdCaption
    ) : 
	CMqPropertyPage(nIDPage, nIdCaption)
{
}


CTriggerProp::~CTriggerProp()
{
}


void CTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTriggerProp)
	DDX_Check(pDX, IDC_Enabled_CHK, m_fEnabled);
	DDX_Check(pDX, IDC_Serialized_CHK, m_fSerialized);
	//}}AFX_DATA_MAP

	SetMsgProcessingType();
}


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp message handlers

BOOL CTriggerProp::OnInitDialog() 
{
	SetDialogHeading();
	//
	// Initialize the Message Processing Type Property
	//
	if ( m_msgProcType == PEEK_MESSAGE )
	{
		((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->SetCheck(1);
	}
	else if ( m_msgProcType == RECEIVE_MESSAGE )
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->SetCheck(1);
	}
	else
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->SetCheck(1);
		((CButton*)GetDlgItem(IDC_Serialized_CHK))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(FALSE);
	}

	return CMqPropertyPage::OnInitDialog();
}


void CTriggerProp::SetMsgProcessingType(void)
{
    if (((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->GetCheck() == 1)
    {
        m_msgProcType = PEEK_MESSAGE;
    }
    else if (((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->GetCheck() == 1)
    {
        m_msgProcType = RECEIVE_MESSAGE;
    }
    else if (((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1)
    {
        m_msgProcType = RECEIVE_MESSAGE_XACT;
    }
    else
    {
        ASSERT(0);
        m_msgProcType = PEEK_MESSAGE;
    }
}


void CTriggerProp::OnReceiveXact() 
{
    CMqPropertyPage::OnChangeRWField();

	//
	// If ReceiveXact is really selected, set and disable the serialized check box
	//
	if (((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1)
	{
		((CButton*)GetDlgItem(IDC_Serialized_CHK))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(FALSE);
	}
}


void CTriggerProp::OnReceiveOrPeek() 
{
    CMqPropertyPage::OnChangeRWField();

	if ((((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->GetCheck() == 1) ||
		(((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->GetCheck() == 1))
	{
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(TRUE);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewTriggerProp page


CNewTriggerProp::CNewTriggerProp(
    CNewTrigger* pParent,
    LPCTSTR queuePathName
    ) : 
    m_pNewTrig(pParent),
	CTriggerProp(CNewTriggerProp::IDD, IDS_NEW_TRIGGER_CAPTION)
{
	m_triggerName = _T("");
	m_queuePathName = queuePathName;
    m_queueType = SYSTEM_QUEUE_NONE;
	m_fEnabled = TRUE;
	m_fSerialized = FALSE;
	m_msgProcType = PEEK_MESSAGE;
}


void CNewTriggerProp::DDV_ValidQueuePathName(CDataExchange* pDX, CString& queuePathName)
{
    if (!pDX->m_bSaveAndValidate)
        return;

    if (m_queueType != SYSTEM_QUEUE_NONE)
        return;

    if (queuePathName.IsEmpty())
    {
        AfxMessageBox(IDS_MISSING_QUEUE_PATHNAME);
        pDX->Fail();
        return;
    }

    WCHAR queueFormatName[256];
    DWORD length = ARRAYSIZE(queueFormatName);

    HRESULT hr = MQPathNameToFormatName(queuePathName, queueFormatName, &length);

    if (hr == MQ_ERROR_ILLEGAL_QUEUE_PATHNAME)
    {
       AfxMessageBox(IDS_ILLEGAL_QUEUE_PATH);
       pDX->Fail();
       return;
    }

    if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
    {
        CString strError;
        strError.FormatMessage(IDS_QUEUE_NOT_REGISTER, queuePathName);

        AfxMessageBox(strError);
        pDX->Fail();
        return;

    }

	//
	// Operation not supported in workgroup - this error will return 
	// when processing public queue pathname while in workgroup mode
	//
	if (hr == MQ_ERROR_UNSUPPORTED_OPERATION)
	{
		CString strIllegal;
		strIllegal.LoadString(IDS_ILLEGAL_QUEUE_PATH);

		CString strWorkgroup;
		strWorkgroup.LoadString(IDS_PUBLIC_PATHNAME_IN_WORKGROUP);

		AfxMessageBox(strIllegal + L"\n" + strWorkgroup);
        pDX->Fail();
        return;
	}

    if ((hr == MQ_ERROR_SERVICE_NOT_AVAILABLE) || 
        (hr == MQ_ERROR_NO_DS))
    {
        if (AfxMessageBox(IDS_QUEUE_NOT_VALIDATE, MB_YESNO | MB_ICONQUESTION) == IDYES)
           return;

        pDX->Fail();
        return;
    }

	//
	// This is the handler for all other error cases
	// Just inform about illegal pathname
	//
	if ( FAILED(hr) )
	{
       AfxMessageBox(IDS_ILLEGAL_QUEUE_PATH);
       pDX->Fail();
       return;
	}

	if (m_msgProcType == RECEIVE_MESSAGE_XACT)
	{
		if ( !ValidateTransactionalQueue(queuePathName, queueFormatName) )
		{
			pDX->Fail();
			return;   
		}
	}

}


void CNewTriggerProp::SetQueueType(void)
{
    if (((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_NONE;
    }
    else if (((CButton*)GetDlgItem(IDC_JournalMessages_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_JOURNAL;
    }
    else if (((CButton*)GetDlgItem(IDC_DeadlLetter_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_DEADLETTER;
    }
    else if (((CButton*)GetDlgItem(IDC_TransactionalDeadLetter_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_DEADXACT;
    }
    else
    {
        ASSERT(0);
        m_queueType = SYSTEM_QUEUE_NONE;
    }
}


void CNewTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CTriggerProp::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewTriggerProp)
	DDX_Text(pDX, IDC_TriggerName_EDIT, m_triggerName);
    DDV_NotEmpty(pDX, m_triggerName, IDS_MISSING_TRIGGER_NAME);
	DDX_Text(pDX, IDC_QueuePathName, m_queuePathName);
	//}}AFX_DATA_MAP

    SetQueueType();
    DDV_ValidQueuePathName(pDX, m_queuePathName);
}


BEGIN_MESSAGE_MAP(CNewTriggerProp, CTriggerProp)
	//{{AFX_MSG_MAP(CNewTriggerProp)
	ON_BN_CLICKED(IDC_QueueMessages_RDB, OnQueueMessages)
	ON_BN_CLICKED(IDC_JournalMessages_RDB, OnSystemQueue)
	ON_BN_CLICKED(IDC_DeadlLetter_RDB, OnSystemQueue)
	ON_BN_CLICKED(IDC_TransactionalDeadLetter_RDB, OnSystemQueue)
	ON_EN_CHANGE(IDC_TriggerName_EDIT, OnChangeRWField)
	ON_BN_CLICKED(IDC_Enabled_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_Serialized_CHK, OnChangeRWField)
	ON_EN_CHANGE(IDC_QueuePathName, OnChangeRWField)
	ON_BN_CLICKED(IDC_PeekMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessageXact_RDB, OnReceiveXact)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CNewTriggerProp::OnInitDialog() 
{

	if (m_queuePathName != _T(""))
    {
        //
        // Queue path name was specified. The new trigger wizard was called for a 
        // specific queue. disable the queue windows
        //
        ((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->SetCheck(1);
        GetDlgItem(IDC_QueuePathName)->EnableWindow(FALSE);
        GetDlgItem(IDC_QueueMessages_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_JournalMessages_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_DeadlLetter_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_TransactionalDeadLetter_RDB)->EnableWindow(FALSE);

	    return CTriggerProp::OnInitDialog();
    }

    ((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->SetCheck(1);

	return CTriggerProp::OnInitDialog();
}


void CNewTriggerProp::OnQueueMessages() 
{
    CMqPropertyPage::OnChangeRWField();
	if(((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->GetCheck() == 1) 
	{
		GetDlgItem(IDC_QueuePathName)->EnableWindow(TRUE);
		GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(TRUE);
	}
}


void CNewTriggerProp::OnSystemQueue() 
{
    CMqPropertyPage::OnChangeRWField();

	//
	// If no one of the system queues was choosen; no further change is required.
	//
	if ((((CButton*)GetDlgItem(IDC_JournalMessages_RDB))->GetCheck() == 0) &&
		(((CButton*)GetDlgItem(IDC_DeadlLetter_RDB))->GetCheck() == 0) &&
		(((CButton*)GetDlgItem(IDC_TransactionalDeadLetter_RDB))->GetCheck() == 0))
		return;

    GetDlgItem(IDC_QueuePathName)->EnableWindow(FALSE);
	
	if ( ((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1 )
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->SetCheck(0);
		((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(TRUE);
	}

	GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(FALSE);
}


BOOL CNewTriggerProp::OnSetActive() 
{
    return m_pNewTrig->SetWizardButtons();
}



/////////////////////////////////////////////////////////////////////////////
// CViewTriggerProp page

CViewTriggerProp::CViewTriggerProp(
    CTrigResult* pParent
    ) : 
    m_pParent(SafeAddRef(pParent)),
	CTriggerProp(CViewTriggerProp::IDD)
{
	//{{AFX_DATA_INIT(CTriggerProp)
	m_fEnabled = pParent->IsEnabled();
	m_fSerialized = pParent->IsSerialize();
	m_triggerName = static_cast<LPCTSTR>(pParent->GetTriggerName());
	m_queuePathName = static_cast<LPCTSTR>(pParent->GetQeuePathName());
	m_queueType = pParent->GetQueueType();
	m_msgProcType = pParent->GetMsgProcessingType();
	m_initMsgProcessingType = m_msgProcType;
	//}}AFX_DATA_INIT

	InitQueueDisplayName();
}


CViewTriggerProp::~CViewTriggerProp(
	VOID
	)
{
	ASSERT(m_pParent.get() != NULL);
	m_pParent->OnDestroyPropertyPages();
}


void CViewTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CTriggerProp::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CViewTriggerProp)
	DDX_Text(pDX, IDC_Monitored_Queue, m_strDisplayQueueName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewTriggerProp, CTriggerProp)
	//{{AFX_MSG_MAP(CViewTriggerProp)
	ON_BN_CLICKED(IDC_Enabled_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_Serialized_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_PeekMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessageXact_RDB, OnReceiveXact)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CViewTriggerProp::InitQueueDisplayName()
{
	if (m_queueType == SYSTEM_QUEUE_NONE)
	{
		m_strDisplayQueueName = m_queuePathName;
	}
	else if (m_queueType == SYSTEM_QUEUE_JOURNAL)
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_JOURNAL);
	}
	else if (m_queueType == SYSTEM_QUEUE_DEADLETTER)
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_DEADLETTER);
	}
	else
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_XACT_DEADLETTER);
	}
}


void CViewTriggerProp::SetDialogHeading()
{
	SetDlgItemText(IDC_TRIGGER_GENERAL_HEADER, m_triggerName);
}


BOOL CViewTriggerProp::OnInitDialog() 
{
	if ( m_queueType != SYSTEM_QUEUE_NONE)
	{
		GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(FALSE);
	}

	return CTriggerProp::OnInitDialog();
}


BOOL CViewTriggerProp::OnApply() 
{
	if (!m_fModified)
	{
		return TRUE;
	}

    UpdateData();

    try
    {
		//
		// Do not perform queue path check if message proccessing type
		// was not changed. This was already done on trigger creation.
		// 
		if (m_initMsgProcessingType !=  m_msgProcType &&
			m_msgProcType == RECEIVE_MESSAGE_XACT)
		{
		    WCHAR queueFormatName[256];
			DWORD length = ARRAYSIZE(queueFormatName);

			HRESULT hr = MQPathNameToFormatName(m_queuePathName, queueFormatName, &length);
			if ( FAILED(hr) )
			{
				CString strMessage;
				strMessage.FormatMessage(IDS_XACT_NO_RETRIEVE, m_queuePathName);

				if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
				{
					return FALSE;   
				}
			}

			if( SUCCEEDED(hr) && 
				!ValidateTransactionalQueue(m_queuePathName, queueFormatName) )
			{
				return FALSE;
			}
		}
				
		ASSERT(m_pParent.get() != NULL);
        m_pParent->OnApply(this);
    }
    catch(const _com_error& e)
    {
		CString strError;

		if (e.Error() == MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER)
		{
			AfxMessageBox(IDS_MULTIPLERECEIVE_TRIGGER, MB_OK | MB_ICONEXCLAMATION);
			return FALSE;
		}

		if (e.Error() == MQTRIG_TRIGGER_NOT_FOUND)
		{
			ASSERT(m_pParent.get() != NULL);

			strError.FormatMessage(IDS_TRIGGER_ALREADY_DELETED, static_cast<LPCWSTR>(m_pParent->GetTriggerName()));
			AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
			return FALSE;
		}


		strError.FormatMessage(IDS_TRIGGER_UPDATE_FAILED, e.Error());
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

	OnChangeRWField(FALSE);
	return CTriggerProp::OnApply();
}


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule dialog


CAttachedRule::CAttachedRule(
    CTrigResult* pParent
    ) : 
	CMqPropertyPage(CAttachedRule::IDD_VIEW),
    m_pParent(SafeAddRef(pParent)),
    m_pNewTrig(NULL)
{
	//{{AFX_DATA_INIT(CAttachedRule)
	//}}AFX_DATA_INIT
    m_attachedRuleList = m_pParent->GetAttachedRulesList();

	BuildExistingRulesList();
}


CAttachedRule::CAttachedRule(
    CNewTrigger* pParent
    ) : 
    CMqPropertyPage(CAttachedRule::IDD_NEW, IDS_NEW_TRIGGER_CAPTION),
    m_pParent(NULL),
    m_pNewTrig(pParent)
{
	//{{AFX_DATA_INIT(CAttachedRule)
	//}}AFX_DATA_INIT
    m_existingRuleList = m_pNewTrig->GetRuleList();
}


bool CAttachedRule::IsAttachedRule(const _bstr_t& id)
{
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if ((*it)->GetRuleId() == id)
            return true;
    }

    return false;
}


void CAttachedRule::BuildExistingRulesList()
{
	m_existingRuleList = m_pParent->GetRuleList();
    
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end();)
    {
        if(IsAttachedRule((*it)->GetRuleId()))
        {
            it = m_existingRuleList.erase(it);
			continue;
        }
		
		++it;
    }
}


void CAttachedRule::SetScrollSize() 
{
	SetScrollSizeForList(m_pAttachedRuleList);
	SetScrollSizeForList(m_pExistingRuleList);
}


//
// Selection functions
// Handle different configurations of selection
// For example, if only one attached rule is selected, all actions for
// attached rules are allowed, but if more that one attached rule is selected
// only detaching is allowed (up/down forbidden for multiple selection).
//
void CAttachedRule::SetAttachedNoOrSingleSelectionButtons(bool fSingleSelection) 
{
	GetDlgItem(IDC_RemoveRule_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_UpRule_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_Down_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_ATTACHED_RULE_PROPS)->EnableWindow(fSingleSelection);
}


void CAttachedRule::SetAttachedMultipleSelectionButtons() 
{
	GetDlgItem(IDC_RemoveRule_BTM)->EnableWindow(TRUE);
	GetDlgItem(IDC_UpRule_BTM)->EnableWindow(FALSE);
	GetDlgItem(IDC_Down_BTM)->EnableWindow(FALSE);
	GetDlgItem(IDC_ATTACHED_RULE_PROPS)->EnableWindow(FALSE);
}


void CAttachedRule::SetExistingNoOrSingleSelectionButtons(bool fSingleSelection) 
{
	GetDlgItem(IDC_ATTACH_RULES_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_EXISTING_RULE_PROPS)->EnableWindow(fSingleSelection);
}


void CAttachedRule::SetExistingMultipleSelectionButtons() 
{
	GetDlgItem(IDC_ATTACH_RULES_BTM)->EnableWindow(TRUE);
	GetDlgItem(IDC_EXISTING_RULE_PROPS)->EnableWindow(FALSE);
}


void CAttachedRule::Display(int dwAttachedSelIndex, int dwExistSelIndex)
{

    m_pAttachedRuleList->ResetContent();
	m_pExistingRuleList->ResetContent();

	//
	// Display attached rules
	//
    DWORD index = 0;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
		m_pAttachedRuleList->InsertString(index, (*it)->GetRuleName());

        ++index;
    }

	//
	// Display existing rules
	//
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
    {
		int pos = m_pExistingRuleList->AddString((*it)->GetRuleName());
		m_pExistingRuleList->SetItemDataPtr(pos, (*it).get());
    }

	bool fSingleSelection = ( m_attachedRuleList.size() != 0 );
	
	SetAttachedNoOrSingleSelectionButtons(fSingleSelection);

	fSingleSelection = ( m_existingRuleList.size() != 0 );
	
	SetExistingNoOrSingleSelectionButtons(fSingleSelection);


	m_pAttachedRuleList->SetSel(dwAttachedSelIndex);
	m_pExistingRuleList->SetSel(dwExistSelIndex);

	SetScrollSize();
}


BEGIN_MESSAGE_MAP(CAttachedRule, CMqPropertyPage)
	//{{AFX_MSG_MAP(CAttachedRule)
	ON_BN_CLICKED(IDC_ATTACH_RULES_BTM, OnAttachRule)
	ON_BN_CLICKED(IDC_RemoveRule_BTM, OnDetachRule)
	ON_LBN_DBLCLK(IDC_RULE_LIST, OnAttachRule)
	ON_LBN_DBLCLK(IDC_ATTACHED_RULE_LIST, OnDetachRule)
	ON_BN_CLICKED(IDC_UpRule_BTM, OnUpRule)
	ON_BN_CLICKED(IDC_Down_BTM, OnDownRule)
	ON_BN_CLICKED(IDC_ATTACHED_RULE_PROPS, OnViewAttachedRulesProperties)
	ON_BN_CLICKED(IDC_EXISTING_RULE_PROPS, OnViewExistingRulesProperties)
	ON_LBN_SELCHANGE(IDC_ATTACHED_RULE_LIST, OnAttachedSelChanged)
	ON_LBN_SELCHANGE(IDC_RULE_LIST, OnExistingSelChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule message handlers

BOOL CAttachedRule::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_pAttachedRuleList = (CListBox*)GetDlgItem(IDC_ATTACHED_RULE_LIST);
	m_pExistingRuleList = (CListBox*)GetDlgItem(IDC_RULE_LIST);
     
    Display(0, 0);

    return CMqPropertyPage::OnInitDialog();
}


void CAttachedRule::OnDetachRule() 
{
    int numSel = m_pAttachedRuleList->GetSelCount();
	ASSERT(numSel != 0);

	AP<int> pSelItems = new int[numSel];
	
	int nSucc = m_pAttachedRuleList->GetSelItems(numSel, pSelItems);
	ASSERT(("Did not get all selections", nSucc == numSel));

	bool fLastSelected = (pSelItems[numSel-1] == numeric_cast<int>(m_attachedRuleList.size()-1));
    DWORD noOfDeletedRules = 0;

    for (int i = 0; i < numSel; i++)
    {
		DWORD nItem = pSelItems[i] - noOfDeletedRules;

        for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
        {
            if (nItem == 0)
            {
                R<CRule> pRule = *it;

                m_attachedRuleList.erase(it);
				m_existingRuleList.push_back(pRule);
                break;
            }
            --nItem;
        }
        ++noOfDeletedRules;
    }
    
	Display(
		pSelItems[numSel-1] - noOfDeletedRules + (fLastSelected ? 0 : 1), 
		0
		);
    
	CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnAttachRule() 
{ 
    int numSel = m_pExistingRuleList->GetSelCount();
	ASSERT(numSel != 0);

	AP<int> pSelItems = new int[numSel];
	
	int nSucc = m_pExistingRuleList->GetSelItems(numSel, pSelItems);
	ASSERT(("Did not get all selections", nSucc == numSel));

	DWORD noOfDeletedRules = 0;
	bool fLastSelected = (pSelItems[numSel-1] == numeric_cast<int>(m_existingRuleList.size()-1));

    for (int i = 0; i < numSel; i++)
    {
		void* pSelectedRule = m_pExistingRuleList->GetItemDataPtr(pSelItems[i]);

		for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
        {
            R<CRule> pRule = *it;

			//
			// Check pointer to rule to distinguish between rules with identical names
			//
			if (pRule.get() == pSelectedRule)
			{
				m_existingRuleList.erase(it);
				m_attachedRuleList.push_back(pRule);
				break;
			}
        }
        ++noOfDeletedRules;
    }

    Display(
		numeric_cast<int>(m_attachedRuleList.size()-1), 
		pSelItems[numSel-1] - noOfDeletedRules + (fLastSelected ? 0 : 1)
		);

    CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnUpRule() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    if (nItem == 0)
    {
        m_pAttachedRuleList->SetSel(0);
        return;
    }

    int newIndex = nItem - 1;
    m_pAttachedRuleList->DeleteString(nItem);

    RuleList::iterator preit = NULL;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if (nItem == 0)
        {
            R<CRule> pRule = *it;
            m_attachedRuleList.erase(it);
            m_attachedRuleList.insert(preit, pRule);

            m_pAttachedRuleList->InsertString(newIndex, pRule->GetRuleName());
            break;
        }
         
        preit = it;
        --nItem;
    }

    m_pAttachedRuleList->SetSel(newIndex);

    CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnDownRule() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    if ( (numeric_cast<DWORD>(nItem + 1))  == m_attachedRuleList.size() )
    {
		m_pAttachedRuleList->SetSel(nItem);
        return;
    }

    int newIndex = nItem + 1;
    m_pAttachedRuleList->DeleteString(nItem);

    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if (nItem == 0)
        {
            R<CRule> pRule = *it;
            it = m_attachedRuleList.erase(it);
            ++it;
            m_attachedRuleList.insert(it, pRule);

            m_pAttachedRuleList->InsertString(newIndex, pRule->GetRuleName());
            break;
        }

        --nItem;
    }

    m_pAttachedRuleList->SetSel(newIndex);

    CMqPropertyPage::OnChangeRWField();	
}


BOOL CAttachedRule::OnApply() 
{
	if (m_fModified)
    {
        try
        {
            m_pParent->OnApply(this);
        }
        catch(_com_error&)
        {
            //
            // BUGBUG: Error message
            //
            return FALSE;
        }
    }

    CMqPropertyPage::OnChangeRWField(false);
	return CMqPropertyPage::OnApply();
}



BOOL CAttachedRule::OnSetActive() 
{
    if (m_pNewTrig == NULL)
        return TRUE;

    return m_pNewTrig->SetWizardButtons();
}


BOOL CAttachedRule::OnWizardFinish()
{
    //
    // We reach here only when creating a new trigger
    //
    ASSERT(m_pNewTrig != NULL);
    
    UpdateData();

    try
    {
        m_pNewTrig->OnFinishCreateTrigger();
        return TRUE;
    }
    catch(const _com_error& e)
    {
		DisplayErrorFromCOM(IDS_NEW_TRIGGER_FAILED, e);
        return FALSE;
    }
}


void CAttachedRule::OnViewAttachedRulesProperties() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    R<CRule> pRule;
	int index = 0;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it, index++)
    {
        if (index == nItem)
        {
			pRule = *it;
            break;
        }
    }

	DisplaySingleRuleProperties(pRule.get());
}


void CAttachedRule::OnViewExistingRulesProperties() 
{
    ASSERT(m_pExistingRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pExistingRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

	void* pSelectedRule = m_pExistingRuleList->GetItemDataPtr(nItem);

    R<CRule> pRule;
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
    {
	    pRule = *it;

		if (pRule.get() == pSelectedRule)
		{
				break;
        }
    }

	DisplaySingleRuleProperties(pRule.get());
}


void CAttachedRule::DisplaySingleRuleProperties(CRule* pRule)
{
	m_rule = SafeAddRef(pRule);

	AP<WCHAR> pRuleName = new WCHAR[wcslen(m_rule->GetRuleName()) + 1];
	wcscpy(pRuleName, m_rule->GetRuleName());
	
	CString strPropSheetTitle;
	strPropSheetTitle.FormatMessage(IDS_PROPERTIES, pRuleName);
	
	CPropertySheetEx rulePropSheet(strPropSheetTitle);
	
	m_pGeneral = new CViewRuleGeneral(this, m_rule->GetRuleName(), m_rule->GetRuleDescription());
	rulePropSheet.AddPage(m_pGeneral);

	m_pCond = new CRuleCondition(this, m_rule->GetRuleCondition());
	rulePropSheet.AddPage(m_pCond);

	m_pAction = new CRuleAction(this, m_rule->GetRuleAction(), m_rule->GetShowWindow());
	rulePropSheet.AddPage(m_pAction);

	rulePropSheet.DoModal();
}


void CAttachedRule::OnAttachedSelChanged()
{
	int nSel = m_pAttachedRuleList->GetSelCount();

	if (nSel == 0 || nSel == 1)
	{
		SetAttachedNoOrSingleSelectionButtons(nSel == 1);
		return;
	}

	SetAttachedMultipleSelectionButtons();
}


void CAttachedRule::OnExistingSelChanged()
{
	int nSel = m_pExistingRuleList->GetSelCount();

	if (nSel == 0 || nSel == 1)
	{
		SetExistingNoOrSingleSelectionButtons(nSel == 1);
		return;
	}

	SetExistingMultipleSelectionButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\trigprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigprop.h                                     *

Abstract:
	Definition for the trigger property page

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGPROP_H__
#define __TRIGPROP_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"
#include "ruledef.h"

#include <map>
#include <list>

// trigprop.h : header file
//

class CTrigResult;
class CNewTrigger;


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp dialog

class CTriggerProp : public CMqPropertyPage
{
friend class CTrigResult;
friend class CNewTrigger;

// Construction
public:
	CTriggerProp(UINT nIDPage, UINT nIdCaption = 0);
	~CTriggerProp();

// Dialog Data
	//{{AFX_DATA(CTriggerProp)
	BOOL	m_fEnabled;
	BOOL	m_fSerialized;
    CString	m_triggerName;
	CString	m_queuePathName;
	MsgProcessingType m_msgProcType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnInitDialog();
	afx_msg void OnReceiveXact();
	afx_msg void OnReceiveOrPeek();
	//}}AFX_MSG
	//DECLARE_MESSAGE_MAP()

protected:
    SystemQueueIdentifier m_queueType;

private:
	void SetMsgProcessingType(void);
	virtual void SetDialogHeading(void) {};

};


/////////////////////////////////////////////////////////////////////////////
// CNewTriggerProp page

class CNewTriggerProp : public CTriggerProp
{

public:
	CNewTriggerProp(CNewTrigger* pParent, LPCTSTR queuePathName);

	// Dialog Data
	enum { IDD = IDD_NEW_TRIGGER_GEN };

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	afx_msg void OnQueueMessages();
	afx_msg void OnSystemQueue();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
    void SetQueueType(void);
    void DDV_ValidQueuePathName(CDataExchange* pDX, CString& str);
 
	CNewTrigger* m_pNewTrig;
};


/////////////////////////////////////////////////////////////////////////////
// CViewTriggerProp page

class CViewTriggerProp : public CTriggerProp
{

public:
	CViewTriggerProp(CTrigResult* pParent);
	~CViewTriggerProp();

	// Dialog Data
	enum { IDD = IDD_TRIGGER_GEN };

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:

	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()


private:
	void SetDialogHeading(void);
	void InitQueueDisplayName();

    R<CTrigResult> m_pParent;
	CString m_strDisplayQueueName;
	MsgProcessingType m_initMsgProcessingType;
};


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule dialog

class CAttachedRule : public CMqPropertyPage, public CRuleParent
{
public:
	CAttachedRule(
        CTrigResult* pParent
        );

	CAttachedRule(
        CNewTrigger* pParent
        );

	virtual void AddRef() 
	{
		CMqPropertyPage::AddRef();
	}

	virtual void Release()
	{
		CMqPropertyPage::Release();
	}

    //{{AFX_DATA(CAttachedRule)
	enum { IDD_NEW = IDD_NEW_ATTACH_RULE, IDD_VIEW = IDD_ATTACH_RULE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttachedRule)
	public:
	virtual BOOL OnApply();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttachedRule)
    virtual BOOL OnWizardFinish();
	virtual BOOL OnInitDialog();
	afx_msg void OnDetachRule();
    afx_msg void OnAttachRule();
	afx_msg void OnUpRule();
	afx_msg void OnDownRule();
	afx_msg void OnViewAttachedRulesProperties();
	afx_msg void OnViewExistingRulesProperties();
	afx_msg void OnAttachedSelChanged();
	afx_msg void OnExistingSelChanged();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    RuleList GetAttachedRules(void)
    {
        return m_attachedRuleList;
    }

    BOOL OnSetActive();

private:
    void Display(int dwAttachedSelIndex, int dwExistSelIndex);
	void BuildExistingRulesList(void);
	void DisplaySingleRuleProperties(CRule* pRule);
	void SetScrollSize();

    bool IsAttachedRule(const _bstr_t& id);

	void SetAttachedNoOrSingleSelectionButtons(bool fSingleSelection);
	void SetAttachedMultipleSelectionButtons(); 
	void SetExistingNoOrSingleSelectionButtons(bool fSingleSelection);
	void SetExistingMultipleSelectionButtons();

private:       
    CListBox* m_pAttachedRuleList;
	CListBox* m_pExistingRuleList;

    RuleList m_attachedRuleList; 
    RuleList m_existingRuleList;

    R<CTrigResult> m_pParent;
    CNewTrigger* m_pNewTrig;
};


#endif // __TRIGPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\admin\mqsnap\usercert.h ===
// UserCert.h : Declaration of the CUserCertificate

#ifndef __USERCERTIFICATE_H_
#define __USERCERTIFICATE_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

#define USER_OBJECT_SID_ATTRIBUTE   (L"objectSid")
#ifndef MSMQ_OBJECT_SID_ATTRIBUTE
    #define MSMQ_OBJECT_SID_ATTRIBUTE   (L"mSMQUserSid")
#endif

class CMQSigCertificate;

/////////////////////////////////////////////////////////////////////////////
// CUserCertificate
class CUserCertificate : 
	public CDataObject
{
public:

    CUserCertificate();
    ~CUserCertificate();

    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateMSMQCertificatePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


protected:

    virtual 
    HRESULT 
    InitializeUserSid(
        LPCWSTR lpwstrLdapName
        );

    HRESULT
    InitializeMQCretificate(
        void
        );

    BYTE* m_psid;
    CMQSigCertificate** m_pMsmqCertificate;
    DWORD m_NumOfCertificate;
    CString m_lpwstrLdapName;

private:
	virtual BSTR GetSidPropertyName() = 0;
};


inline
HRESULT 
CUserCertificate::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    return MQ_OK;
}

inline
const 
DWORD 
CUserCertificate::GetObjectType()
{
    ASSERT(0);
    return 0;
}

inline
const 
PROPID*
CUserCertificate::GetPropidArray()
{
    ASSERT(0);
    return NULL;
}

inline
const 
DWORD  
CUserCertificate::GetPropertiesCount()
{
    ASSERT(0);
    return 0;
}


//
// IContextMenu
//
inline
STDMETHODIMP 
CUserCertificate::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT idCmdLast, 
    UINT uFlags
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

inline
STDMETHODIMP 
CUserCertificate::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}

//
// Derived classes
//
class CRegularUserCertificate : 
    public CUserCertificate,
	public CComCoClass<CRegularUserCertificate, &CLSID_UserCertificate>
{
public:
    DECLARE_NOT_AGGREGATABLE(CRegularUserCertificate)
    DECLARE_REGISTRY_RESOURCEID(IDR_USERCERTIFICATE)
private:
	virtual BSTR GetSidPropertyName()
	{
		return USER_OBJECT_SID_ATTRIBUTE;
	}
};

class CMigratedUserCertificate : 
    public CUserCertificate,
	public CComCoClass<CMigratedUserCertificate, &CLSID_MigratedUserCertificate>
{
public:
    DECLARE_NOT_AGGREGATABLE(CMigratedUserCertificate)
    DECLARE_REGISTRY_RESOURCEID(IDR_MIGRATEDUSERCERTIFICATE)

private:
	virtual BSTR GetSidPropertyName()
	{
		return MSMQ_OBJECT_SID_ATTRIBUTE;
	}
};

#endif //__USERCERTIFICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\autorec\autorec.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <activeds.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include "mqtempl.h"
#include "getmqds.h"

HRESULT autorec()
{
    LPSTR pszSiteName;
    DWORD rc = DsGetSiteName(NULL, &pszSiteName);
    if (rc == NO_ERROR)
    {
        printf("Site name is %hs\n", pszSiteName);
        NetApiBufferFree(pszSiteName);
    }
    else if (rc == ERROR_NO_SITENAME)
    {
        printf("DsGetSiteMame() returned ERROR_NO_SITENAME (%lx). The computer is not in a site.\n", rc);
    }
    else
    {
        printf("DsGetSiteMame() failed with error code = %lx\n", rc);
    }

    CGetMqDS cGetMqDS;
    HRESULT hr;
    ULONG cServers;
    AP<MqDsServerInAds> rgServers;

    hr = cGetMqDS.FindMqDsServersInAds(&cServers, &rgServers);
    if (FAILED(hr)) {
      printf("cGetMqDS.FindMqDsServersInAds()=%lx\n", hr);
      return hr;
    }

    printf("Number of servers is %lu\n", cServers);
    for (ULONG ulTmp = 0; ulTmp < cServers; ulTmp++) {
      printf("%ls %s\n", rgServers[ulTmp].pwszName, (rgServers[ulTmp].fIsADS ? "NT5" : "NT4"));
    }

    return NOERROR;
}

int main (int argc, char * argv[])
{
  HRESULT hr;

  hr = CoInitialize(NULL);
  if (FAILED(hr)) {
    printf("CoInitialize()=%lx\n", hr);
    return 1;
  }

  hr = autorec();
  CoUninitialize();
  if (FAILED(hr)) {
    printf("autorec()=%lx\n", hr);
    return 1;
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\br.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    br.h

Abstract:

    Common function for MSMQ 1.0 Backup & Restore.

Author:

    Erez Haba (erezh) 14-May-98

--*/

#ifndef __BR_H__
#define __BR_N__

extern HMODULE	g_hResourceMod;

class CResString
{
public:
    explicit CResString(UINT id=0) { Load(id); }

    WCHAR * const Get() { return m_sz; }

    void Load(UINT id)
    {
        m_sz[0] = 0;
        if (id != 0)
        {
            LoadString(g_hResourceMod, id, m_sz, sizeof(m_sz) / sizeof(m_sz[0]));
        }
    }
        
private:
    WCHAR m_sz[1024];
};
  
typedef struct _EnumarateData
{
	BOOL fFound;
	LPCWSTR pModuleName;
}EnumarateData,*pEnumarateData;

void
BrErrorExit(
    DWORD Status,
    LPCWSTR pErrorMsg,
    ...
    );

void
BrpWriteConsole(
    LPCWSTR pBuffer
    );

void
BrInitialize(
     LPCWSTR pPrivilegeName
    );

void
BrEmptyDirectory(
    LPCWSTR pDirName
    );

void
BrVerifyFileWriteAccess(
    LPCWSTR pDirName
    );


enum sdIndex {
    ixExpress,
    ixRecover,
    ixLQS = ixRecover,
    ixJournal,
    ixLog,
    ixXact,
    ixLast
};

typedef WCHAR STORAGE_DIRECTORIES[ixLast][MAX_PATH];

void
BrGetStorageDirectories(
    STORAGE_DIRECTORIES& StorageDirectories
    );

void
BrGetMappingDirectory(
    LPWSTR MappingDirectory,
    DWORD  MappingDirectorySize
    );

void
BrGetWebDirectory(
    LPWSTR WebDirectory,
    DWORD  WebDirectorySize
    );

BOOL
BrStopMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    );

void
BrStartMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * pDependentServices,
    DWORD NumberOfDependentServices
    );

ULONGLONG
BrGetUsedSpace(
    LPCWSTR pDirName,
    LPCWSTR pMask
    );

ULONGLONG
BrGetXactSpace(
    LPCWSTR pDirName
    );

ULONGLONG
BrGetFreeSpace(
    LPCWSTR pDirName
    );

HKEY
BrCreateKey(
    void
    );

void
BrSaveKey(
    HKEY hKey,
    LPCWSTR pDirName
    );

void
BrRestoreKey(
    HKEY hKey,
    LPCWSTR pDirName
    );
    
void
BrSetRestoreSeqID(
    void
    );
    
void
BrCloseKey(
    HKEY hKey
    );

void
BrCopyFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pMask,
    LPCWSTR pDstDir
    );

void
BrCopyXactFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pDstDir
    );

void
BrCreateDirectory(
    LPCWSTR pDirName
    );

void
BrCreateDirectoryTree(
    LPCWSTR pDirName
    );

void
BrVerifyBackup(
    LPCWSTR pBackupDir,
    LPCWSTR pBackupDirStorage
    );

void
BrSetDirectorySecurity(
    LPCWSTR pDirName
    );

BOOL 
BrIsSystemNT5(
		void
		);

void
BrNotifyAffectedProcesses(
		LPCWSTR pModuleName
		);


#endif // __BR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\backup.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    backup.cpp

Abstract:

    Backup MSMQ 1.0, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include "br.h"
#include "resource.h"
#include "snapres.h"

void DoBackup(LPCWSTR pBackupDir)
{
    //
    //  1. Verify that the backup directory is empty
    //  2. Verify that the backup directory is writeable
    //  3. Get Registry Values for all subdirectories
    //  4. Stop MSMQ Service if running and remember running state. Detach MQAC from the files.
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //  6. Save Registry \HKLM\Software\Microsoft\MSMQ to file on destination path
    //  7. Copy all message files to target directory
    //  8. Copy logger files and mapping files to target directory
    //  9. Copy LQS files to target backup directory
    // 10. Restart MSMQ service if needed.
    // 11. Issue a warning about running applications
    //

    WCHAR BackupDir[MAX_PATH];
    wcscpy(BackupDir, pBackupDir);
    if (BackupDir[wcslen(BackupDir)-1] != L'\\')
    {
        wcscat(BackupDir, L"\\");
    }

    WCHAR BackupDirMapping[MAX_PATH];
    wcscpy(BackupDirMapping, BackupDir);
    wcscat(BackupDirMapping, L"MAPPING\\");

    WCHAR BackupDirStorage[MAX_PATH];
    wcscpy(BackupDirStorage, BackupDir);
    wcscat(BackupDirStorage, L"STORAGE\\");

    WCHAR BackupDirStorageLqs[MAX_PATH];
    wcscpy(BackupDirStorageLqs, BackupDirStorage);
    wcscat(BackupDirStorageLqs, L"LQS\\");

    //
    // 0. Verify user permissions to backup.
    //
    CResString str(IDS_VERIFY_BK_PRIV);
    BrpWriteConsole(str.Get());
    BrInitialize(SE_BACKUP_NAME);
    
    //
    //  1. Verify that the backup directory is empty
    //
    str.Load(IDS_CHECK_BK_DIR);
    BrpWriteConsole(str.Get());
    BrCreateDirectoryTree(BackupDir);
    BrEmptyDirectory(BackupDir);
    BrCreateDirectory(BackupDirMapping);
    BrEmptyDirectory(BackupDirMapping);
    BrCreateDirectory(BackupDirStorage);
    BrEmptyDirectory(BackupDirStorage);
    BrCreateDirectory(BackupDirStorageLqs);
    BrEmptyDirectory(BackupDirStorageLqs);

    //
    //  2. Verify that the backup directory is writeable
    //
    BrVerifyFileWriteAccess(BackupDir);

    //
    //  3. Get Registry Values for subdirectories
    //
    str.Load(IDS_READ_FILE_LOCATION);
    BrpWriteConsole(str.Get());
    STORAGE_DIRECTORIES sd;
    BrGetStorageDirectories(sd);
    
    WCHAR MappingDirectory[MAX_PATH];
    BrGetMappingDirectory(MappingDirectory, sizeof(MappingDirectory));

	 
    //  
    //  4.  A. Notify the user on affected application due to the stopping of MSMQ service (only on NT5)
	//		B. Stop MSMQ Service and dependent services if running and remember running state. 
    //      C. Detach MQAC from the files.
    //

	if(BrIsSystemNT5())
	{
		BrNotifyAffectedProcesses(L"mqrt.dll");
	}
    str.Load(IDS_BKRESTORE_STOP_SERVICE);
    BrpWriteConsole(str.Get());
    ENUM_SERVICE_STATUS * pDependentServices = NULL;
    DWORD NumberOfDependentServices = 0;
    BOOL fStartService = BrStopMSMQAndDependentServices(&pDependentServices, &NumberOfDependentServices);

    //
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //     pre allocate 32K for registry save.
    //
    str.Load(IDS_CHECK_AVAIL_DISK_SPACE);
    BrpWriteConsole(str.Get());
    ULONGLONG RequiredSpace = 32768;
    RequiredSpace += BrGetUsedSpace(sd[ixRecover], L"\\p*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixJournal], L"\\j*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixLog],     L"\\l*.mq");

    RequiredSpace += BrGetXactSpace(sd[ixXact]);
    RequiredSpace += BrGetUsedSpace(sd[ixLQS], L"\\LQS\\*");

    RequiredSpace += BrGetUsedSpace(MappingDirectory, L"*");

    ULONGLONG AvailableSpace = BrGetFreeSpace(BackupDir);
    if(AvailableSpace < RequiredSpace)
    {
        str.Load(IDS_NOT_ENOUGH_DISK_SPACE_BK);
        BrErrorExit(0, str.Get(), BackupDir);
    }

    //
    //  6. Save Registry \HKLM\Software\Microsoft\MSMQ to file on destination path
    //
    str.Load(IDS_BACKUP_REGISTRY);
    BrpWriteConsole(str.Get());
    HKEY hKey = BrCreateKey();
    BrSaveKey(hKey, BackupDir);
    BrCloseKey(hKey);

    //
    //  7. Copy all message files to target directory
    //
    str.Load(IDS_BACKUP_MSG_FILES);
    BrpWriteConsole(str.Get());
    BrCopyFiles(sd[ixRecover], L"\\p*.mq", BackupDirStorage);
    BrCopyFiles(sd[ixJournal], L"\\j*.mq", BackupDirStorage);
    BrCopyFiles(sd[ixLog],     L"\\l*.mq", BackupDirStorage);

    //
    //  8. Copy logger files and mapping files to target directory
    //
    BrCopyXactFiles(sd[ixXact], BackupDirStorage);
    BrCopyFiles(MappingDirectory, L"\\*", BackupDirMapping);

    //
    //  9. Copy LQS files to target directory
    //
    BrCopyFiles(sd[ixLQS], L"\\LQS\\*", BackupDirStorageLqs);
    BrpWriteConsole(L"\n");

    //
    // 10. Restart MSMQ and dependent services if needed.
    //
    if(fStartService)
    {
        str.Load(IDS_START_SERVICE);
        BrpWriteConsole(str.Get());
        BrStartMSMQAndDependentServices(pDependentServices, NumberOfDependentServices);
    }

    //
    // 11. Issue a warning about running applications
    //
    str.Load(IDS_DONE);
    BrpWriteConsole(str.Get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\resource.h ===
#include "bkupres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\main.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Backup & Restore MSMQ 1.0, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include "br.h"
#include "resource.h"
#include "stdlib.h"
#include "_mqres.h"

bool g_fNoPrompt = false;

void DoBackup(LPCWSTR pBackupDir);
void DoRestore(LPCWSTR pBackupDir);

//
// Handle to the resource only DLL, i.e. mqutil.dll
//
HMODULE	g_hResourceMod = NULL;

static void Usage()
{
    CResString str(IDS_USAGE);
    BrpWriteConsole(str.Get());

	exit(-1);
}


extern "C" int _cdecl wmain(int argc, WCHAR* argv[])
{
    //
    // If you add/change these constants, change also
    // the usage message.
    //
    const WCHAR x_cBackup = L'b';
    const WCHAR x_cRestore = L'r';
    const WCHAR x_cNoPrompt = L'y';


    WCHAR cAction = 0;
    WCHAR cNoPrompt = 0;
    WCHAR szPath[MAX_PATH] = {0};

	//
	// Obtain the handle to the resource only dll, i.e. mqutil.dll
	//
	g_hResourceMod = MQGetResourceHandle();



    for (int i=1; i < argc; ++i)
    {
        WCHAR c = argv[i][0];
        if (c == L'-' || c == L'/')
        {
            if (wcslen(argv[i]) != 2)
            {
                Usage();
            }

            c = static_cast<WCHAR>(towlower(argv[i][1]));
            switch (c)
            {
                case x_cBackup:
                case x_cRestore:
                {
                    if (cAction != 0)
                    {
                        Usage();
                    }
                    cAction = c;
                    break;
                }

                case x_cNoPrompt:
                {
                    if (cNoPrompt != 0)
                    {
                        Usage();
                    }
                    cNoPrompt = c;
                    break;
                }

                default:
                {
                    Usage();
                    break;
                }
            }
        }
        else
        {
            if (szPath[0] != 0)
            {
                Usage();
            }
            wcscpy(szPath, argv[i]);
        }
    }

    //
    // Some arguments are must
    //
    if (cAction == 0      ||
        szPath[0] == 0)
    {
        Usage();
    }

    //
    // Some arguments are optional
    //
    if (cNoPrompt != 0)
    {
        g_fNoPrompt = true;
    }

    WCHAR szFullPath[MAX_PATH];
    DWORD dwLenFullPath = sizeof(szFullPath) / sizeof(szFullPath[0]);
    LPWSTR pFilePart = 0;
    DWORD rc = GetFullPathName(
        szPath,                                     // pointer to name of file to find path for
        dwLenFullPath,                              // size, in characters, of path buffer
        szFullPath,                                 // pointer to path buffer
        &pFilePart                                  // pointer to filename in path
        );
    if (0 == rc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_GET_FULL_PATH);
        BrErrorExit(gle, strErr.Get(), szPath);
    }
    if (rc > dwLenFullPath)
    {
        CResString strErr(IDS_PATH_TOO_LONG_ERROR);
        BrErrorExit(0, strErr.Get(), szPath, dwLenFullPath-1);
    }

	

    switch(cAction)
    {
        case x_cBackup:          
            DoBackup(szFullPath);
            break;

        case x_cRestore:          
            DoRestore(szFullPath);
            break;

        default:
            Usage();
            break;
    }




    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\br.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    br.cpp

Abstract:

    Common function for MSMQ 1.0 Backup & Restore.

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include "br.h"
#include "resource.h"
#include "mqtime.h"
#include <acioctl.h>
#include "uniansi.h"
#include "autorel.h"
#include <winbase.h>
#include <tlhelp32.h>
#include <dbghelp.h>
#include <assert.h>
#include <stdlib.h>
#include <_mqini.h>
#include "snapres.h"

extern bool g_fNoPrompt;


typedef BOOL (WINAPI *EnumerateLoadedModules_ROUTINE) (HANDLE, PENUMLOADED_MODULES_CALLBACK, PVOID);


//-----------------------------------------------------------------------------
//
// Configuration
//

//
// File name to write into backup directory
//
const WCHAR xBackupIDFileName[] = L"\\mqbackup.id";

//
// Signature written in the signature file (need to be in chars)
//
const char xBackupSignature[] = "MSMQ Backup\n";

//
// Registry backup file name
//
const WCHAR xRegFileName[] = L"\\msmqreg";

//
// MSMQ Registry settings location
//
const WCHAR xRegNameMSMQ[] = L"Software\\Microsoft\\MSMQ";
const WCHAR xRegNameParameters[] = L"Software\\Microsoft\\MSMQ\\Parameters";
const WCHAR xRegNameSeqIDAtRestore[] = L"Software\\Microsoft\\MSMQ\\Parameters\\SeqIDAtLastRestore";

const LPCWSTR xXactFileList[] = {
    L"\\qmlog",
    L"\\mqinseqs.*",
    L"\\mqtrans.*",
};

const int xXactFileListSize = sizeof(xXactFileList) / sizeof(xXactFileList[0]);

//-----------------------------------------------------------------------------

BOOL
BrpFileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;
 
    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}
 

void
BrpWriteConsole(
    LPCWSTR  pBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //
 
    static HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD NumOfChars = static_cast<DWORD>(wcslen(pBuffer));

    if (BrpFileIsConsole(hStdOut))
    {
        WriteConsole(hStdOut, pBuffer, NumOfChars, &NumOfChars, NULL);
        return;
    }

    DWORD NumOfBytes = (NumOfChars + 1) * sizeof(WCHAR);
    LPSTR pAnsi = (LPSTR)LocalAlloc(LMEM_FIXED, NumOfBytes);
    if (pAnsi == NULL)
    {
        return;
    }

    NumOfChars = WideCharToMultiByte(CP_OEMCP, 0, pBuffer, NumOfChars, pAnsi, NumOfBytes, NULL, NULL);
    if (NumOfChars != 0)
    {
        WriteFile(hStdOut, pAnsi, NumOfChars, &NumOfChars, NULL);
    }

    LocalFree(pAnsi);
}


static
DWORD
BrpFormatMessage(
    IN DWORD   dwFlags,
    IN LPCVOID lpSource,
    IN DWORD   dwMessageId,
    IN DWORD   dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN  DWORD  nSize,
    IN ...
    )
/*++

Routine Description:
    Wrapper for FormatMessage()

    Caller of this wrapper should allocate a large enough buffer 
    for the formatted string and pass a valid pointer (lpBuffer).
    
    Allocation made by FormatMessage() is deallocated by this
    wrapper before returning to caller. 

    Caller of this wrapper should simply pass arguments for formatting.
    Packing to va_list is done by this wrapper.
    (Caller of FormatMessage() needs to pack arguments for 
    formatting to a va_list or an array and pass a pointer
    to this va_list or array) 

Arguments:
    dwFlags      -  passed as is to FormatMessage()
    lpSource     -  passed as is to formatMessage()
    dwMessageId  -  passed as is to FormatMessage()
    dwLanguageId -  passed as is to FormatMessage()
    lpBuffer     -  pointer to a large enough buffer allocated by
                    caller. This buffer will hold the formatted string.
    nSize        -  passed as is to FormatMessage 
    ...          -  arguments for formatting

Return Value:
    passed as is from FormatMessage()

--*/
{
    va_list va;
    va_start(va, nSize);

    LPTSTR pBuf = 0;
    DWORD dwRet = FormatMessage(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        reinterpret_cast<LPWSTR>(&pBuf),
        nSize,
        &va
        );
    if (dwRet != 0)
    {
        wcscpy(lpBuffer, pBuf);
        LocalFree(pBuf);
    }

    va_end(va);
    return dwRet;

} //BrpFormatMessage


void
BrErrorExit(
    DWORD Status,
    LPCWSTR pErrorMsg,
    ...
    )
{
    va_list va;
    va_start(va, pErrorMsg);

    LPTSTR pBuf = 0;
    DWORD dwRet = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        pErrorMsg,
        0,
        0,
        reinterpret_cast<LPWSTR>(&pBuf),
        0,
        &va
        );
    if (dwRet != 0)
    {
        BrpWriteConsole(pBuf);
        LocalFree(pBuf);
    }

    va_end(va);

    if(Status != 0)
    {
         //
        // Display error code
        //
        WCHAR szBuf[1024] = {0};
        CResString strErrorCode(IDS_ERROR_CODE);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strErrorCode.Get(),
            0,
            0,
            szBuf,
            0,
            Status
            );

        if (rc != 0)
        {
            BrpWriteConsole(L" ");
            BrpWriteConsole(szBuf);
        }
        BrpWriteConsole(L"\n");

        //
        // Display error description
        //
        rc = BrpFormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            L"%1",
            Status,
            0,
            szBuf,
            0,
            0
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
            BrpWriteConsole(L"\n");
        }
    }

	exit(-1);

} //BrErrorExit


static
void
BrpEnableTokenPrivilege(
    HANDLE hToken,
    LPCWSTR pPrivilegeName
    )
{
    BOOL fSucc;
    LUID Privilege;
    fSucc = LookupPrivilegeValue(
                NULL,       // system name
                pPrivilegeName,
                &Privilege
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_LOOKUP_PRIV_VALUE);
        BrErrorExit(gle, strErr.Get(), pPrivilegeName);
    }


    TOKEN_PRIVILEGES TokenPrivilege;
    TokenPrivilege.PrivilegeCount = 1;
    TokenPrivilege.Privileges[0].Luid = Privilege;
    TokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    fSucc = AdjustTokenPrivileges(
                hToken,
                FALSE,  // Do not disable all
                &TokenPrivilege,
                sizeof(TOKEN_PRIVILEGES),
                NULL,   // Ignore previous info
                NULL    // Ignore previous info
                );

    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_ENABLE_PRIV);
        BrErrorExit(gle, strErr.Get(), pPrivilegeName);
    }
}


void
BrInitialize(
    LPCWSTR pPrivilegeName
    )
{
    BOOL fSucc;
    HANDLE hToken;
    fSucc = OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES,
                &hToken
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_PROCESS_TOKEN);
        BrErrorExit(gle, strErr.Get());
    }

    BrpEnableTokenPrivilege(hToken, pPrivilegeName);

    CloseHandle(hToken);
}


static
void
BrpWarnUserBeforeDeletion(
    LPCTSTR pDirName
    )
{
    WCHAR szBuf[1024] = {L'\0'};

    if (g_fNoPrompt)
    {
        CResString strDeleting(IDS_DELETING_FILES);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strDeleting.Get(),
            0,
            0,
            szBuf,
            0,
            pDirName
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

    CResString strWarn(IDS_WARN_BEFORE_DELETION);
    CResString strY(IDS_Y);
    CResString strN(IDS_N);

    DWORD rc = BrpFormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        strWarn.Get(),
        0,
        0,
        szBuf,
        0,
        pDirName,
        strY.Get(),
        strN.Get()
        );

    if (rc == 0)
    {
        //
        // Failed to generate "are you sure" message,
        // don't take any chances - abort!
        //
        exit(-1);
    }

    for (;;)
    {
        BrpWriteConsole(szBuf);
        
        WCHAR sz[80] = {0};
        wscanf(L"%s", sz);

        if (0 == CompareStringsNoCase(sz, strY.Get()))
        {
            break;
        }

        if (0 == CompareStringsNoCase(sz, strN.Get()))
        {
            CResString strAbort(IDS_ABORT);
            BrpWriteConsole(strAbort.Get());
            exit(-1);
        }
    }

} //BrpWarnUserBeforeDeletion


void
BrEmptyDirectory(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Deletes all files in the directory. 
    Ignores files with zero size (eg subdirectories)

Arguments:
    pDirName - Directory Path.

Return Value:
    None.

--*/
{
    WCHAR szDirName[MAX_PATH];
    wcscpy(szDirName, pDirName);
    if (szDirName[wcslen(szDirName)-1] != L'\\')
    {
        wcscat(szDirName, L"\\");
    }

    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, szDirName);
    wcscat(FileName, L"*");

    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                FileName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();

        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // Great, no files found. 
            // If path does not exists this is another error (3).
            //
            return;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    bool fUserWarned = false;
    do
    {
        if (FindData.nFileSizeLow == 0 && FindData.nFileSizeHigh == 0)
        {
            continue;
        }

        if (!fUserWarned)
        {
            BrpWarnUserBeforeDeletion(pDirName);
            fUserWarned = true;
        }

        wcscpy(FileName, szDirName);
        wcscat(FileName, FindData.cFileName);
        if (!DeleteFile(FileName))
        {
            DWORD gle = GetLastError();
            CResString strErr(IDS_CANT_DEL_FILE);
            BrErrorExit(gle, strErr.Get(), FindData.cFileName);
        }

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);

} //BrEmptyDirectory


void
BrVerifyFileWriteAccess(
    LPCWSTR pDirName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, xBackupIDFileName);

    HANDLE hFile;
    hFile = CreateFile(
                FileName,
                GENERIC_WRITE,
                0,              // share mode
                NULL,           // pointer to security attributes
                CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL            // template file
                );
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_CREATE_FILE);
        BrErrorExit(gle, strErr.Get(), FileName);
    }

    BOOL fSucc;
    DWORD nBytesWritten;
    fSucc = WriteFile(
                hFile,
                xBackupSignature,
                sizeof(xBackupSignature) - 1,
                &nBytesWritten,
                NULL    // overlapped structure
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_WRITE_FILE);
        BrErrorExit(gle, strErr.Get(), FileName);
    }

    CloseHandle(hFile);
}


static
void
BrpQueryStringValue(
    HKEY hKey,
    LPCWSTR pValueName,
    LPWSTR pValue,
    DWORD cbValue
    )
{
    LONG lRes;
    DWORD dwType;
    lRes = RegQueryValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(pValue),
            &cbValue
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_QUERY_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

static
void
BrpQueryDwordValue(
    HKEY hKey,
    LPCWSTR pValueName,
    DWORD *pValue
    )
{
    LONG lRes;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    lRes = RegQueryValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(pValue),
            &dwSize
            );
    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_QUERY_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

static
void
BrpSetDwordValue(
    HKEY hKey,
    LPCWSTR pValueName,
    DWORD dwValue
    )
{
    LONG lRes;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    lRes = RegSetValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            dwType,
            reinterpret_cast<PBYTE>(&dwValue),
            dwSize
            );
    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_SET_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

 


void
BrGetStorageDirectories(
    STORAGE_DIRECTORIES& sd
    )
{
    LONG lRes;
    HKEY hKey;
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            xRegNameParameters,
            0,      // reserved
            KEY_READ,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), xRegNameParameters);
    }

    BrpQueryStringValue(hKey, L"StoreReliablePath",    sd[ixExpress], sizeof(sd[ixExpress]));
    BrpQueryStringValue(hKey, L"StorePersistentPath",  sd[ixRecover], sizeof(sd[ixRecover]));
    BrpQueryStringValue(hKey, L"StoreJournalPath",     sd[ixJournal], sizeof(sd[ixJournal]));
    BrpQueryStringValue(hKey, L"StoreLogPath",         sd[ixLog],     sizeof(sd[ixLog]));
    BrpQueryStringValue(hKey, L"StoreXactLogPath",     sd[ixXact],    sizeof(sd[ixXact]));

    RegCloseKey(hKey);
}


void
BrGetMappingDirectory(
    LPWSTR MappingDirectory,
    DWORD  MappingDirectorySize
    )
{
    //
    // Lookup the mapping directory in registry
    //

    LONG lRes;
    HKEY hKey;
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            xRegNameParameters,
            0,      // reserved
            KEY_READ,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), xRegNameParameters);
    }

    DWORD dwType;
    lRes = RegQueryValueEx(
            hKey,
            MSMQ_MAPPING_PATH_REGNAME,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(MappingDirectory),
            &MappingDirectorySize
            );

    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS)
    {
        return;
    }

    //
    // Not in registry. Generate the default directory: system32\msmq\mapping
    //

    GetSystemDirectory(MappingDirectory, MappingDirectorySize/sizeof(MappingDirectory[0]));
    wcscat(MappingDirectory, L"\\MSMQ\\MAPPING");
}


static
SC_HANDLE
BrpGetServiceHandle(
    LPCWSTR pServiceName,
    DWORD AccessType
    )
{
    SC_HANDLE hSvcCtrl;
    hSvcCtrl = OpenSCManager(
                NULL,   // machine name
                NULL,   // services database
                SC_MANAGER_ALL_ACCESS
                );

    if(hSvcCtrl == NULL)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_SCM);
        BrErrorExit(gle, strErr.Get());
    }

    SC_HANDLE hService;
    hService = OpenService(
                hSvcCtrl,
                pServiceName,
                AccessType
                );

    if(hService == NULL)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_SERVICE);
        BrErrorExit(gle, strErr.Get(), pServiceName);
    }

    CloseServiceHandle(hSvcCtrl);

    return hService;
}


static
bool
BrpIsServiceStopped(
    LPCWSTR pServiceName
    )
{
    SC_HANDLE hService;
    hService = BrpGetServiceHandle(pServiceName, SERVICE_QUERY_STATUS);

    BOOL fSucc;
    SERVICE_STATUS ServiceStatus;
    fSucc = QueryServiceStatus(
                hService,
                &ServiceStatus
                );

    DWORD LastError = GetLastError();

    CloseServiceHandle(hService);

    if(!fSucc)
    {
        CResString strErr(IDS_CANT_QUERY_SERVICE);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    return (ServiceStatus.dwCurrentState == SERVICE_STOPPED);
}


static
void
BrpStopService(
    LPCWSTR pServiceName
    )
{
    SC_HANDLE hService;
    hService = BrpGetServiceHandle(pServiceName, SERVICE_STOP | SERVICE_QUERY_STATUS);

    BOOL fSucc;
    SERVICE_STATUS SrviceStatus;
    fSucc = ControlService(
                hService,
                SERVICE_CONTROL_STOP,
                &SrviceStatus
                );
    
    DWORD LastError = GetLastError();

    if(!fSucc)
    {
        CloseServiceHandle(hService);

        CResString strErr(IDS_CANT_STOP_SERVICE);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }


    //
    // Wait for the service to stop
    //
    for (;;)
    {
        Sleep(50);
        if (!QueryServiceStatus(hService, &SrviceStatus))
        {
            DWORD gle = GetLastError();
            CResString strErr(IDS_CANT_QUERY_SERVICE);
            BrErrorExit(gle, strErr.Get(), pServiceName);
        }
        if (SrviceStatus.dwCurrentState == SERVICE_STOPPED)
        {
            break;
        }

        BrpWriteConsole(L".");
    }


    CloseServiceHandle(hService);

} //BrpStopService


static
void
BrpStopDependentServices(
    LPCWSTR pServiceName,
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    )
{
    SC_HANDLE hService;
    hService = BrpGetServiceHandle(pServiceName, SERVICE_ENUMERATE_DEPENDENTS);

    BOOL fSucc;
    DWORD BytesNeeded;
    DWORD NumberOfEntries;
    fSucc = EnumDependentServices(
                hService,
                SERVICE_ACTIVE,
                NULL,
                0,
                &BytesNeeded,
                &NumberOfEntries
                );

    DWORD LastError = GetLastError();

	if (BytesNeeded == 0)
    {
        CloseServiceHandle(hService);
        return;
    }

    assert(!fSucc);

    if( LastError != ERROR_MORE_DATA)
    {
        CloseServiceHandle(hService);

        CResString strErr(IDS_CANT_ENUM_SERVICE_DEPENDENCIES);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    

    BYTE * pBuffer = new BYTE[BytesNeeded];
    if (pBuffer == NULL)
    {
        CResString strErr(IDS_NO_MEMORY);
        BrErrorExit(0, strErr.Get());
    }

    ENUM_SERVICE_STATUS * pDependentServices = reinterpret_cast<ENUM_SERVICE_STATUS*>(pBuffer);
    fSucc = EnumDependentServices(
                hService,
                SERVICE_ACTIVE,
                pDependentServices,
                BytesNeeded,
                &BytesNeeded,
                &NumberOfEntries
                );

    LastError = GetLastError();
    CloseServiceHandle(hService);

    if(!fSucc)
    {
        CResString strErr(IDS_CANT_ENUM_SERVICE_DEPENDENCIES);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    for (DWORD ix = 0; ix < NumberOfEntries; ++ix)
    {
        BrpStopService(pDependentServices[ix].lpServiceName);
    }

    *ppDependentServices = pDependentServices;
    *pNumberOfDependentServices = NumberOfEntries;
}


BOOL
BrStopMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    )
{
    //
    // MSMQ service is stopped, this is a no-op.
    //
    if (BrpIsServiceStopped(L"MSMQ"))
    {
        return FALSE;
    }

    //
    // Stop dependent services
    //
    BrpStopDependentServices(L"MSMQ", ppDependentServices, pNumberOfDependentServices);

    //
    // Stop MSMQ Service
    //
    BrpStopService(L"MSMQ");
    return TRUE;
}


static
void
BrpStartService(
    LPCWSTR pServiceName
    )
{
    SC_HANDLE hService;
    hService = BrpGetServiceHandle(pServiceName, SERVICE_START);

    BOOL fSucc;
    fSucc = StartService(
                hService,
                0,      // number of arguments
                NULL    // array of argument strings 
                );

    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_START_SERVICE);
        BrErrorExit(gle, strErr.Get(), pServiceName);
    }

    CloseServiceHandle(hService);
}



void
BrStartMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * pDependentServices,
    DWORD NumberOfDependentServices
    )
{
    BrpStartService(L"MSMQ");

    if (pDependentServices == NULL)
    {
        return;
    }

    for (DWORD ix = 0; ix < NumberOfDependentServices; ++ix)
    {
        BrpStartService(pDependentServices[ix].lpServiceName);
    }

    delete [] pDependentServices;
}


inline
DWORD
AlignUp(
    DWORD Size,
    DWORD Alignment
    )
{
    Alignment -= 1;
    return ((Size + Alignment) & ~Alignment);
}


ULONGLONG
BrGetUsedSpace(
    LPCWSTR pDirName,
    LPCWSTR pMask
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, pMask);

    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                FileName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // No matching file, used space is zero. if path does not exists
            // this is another error (3).
            //
            return 0;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    ULONGLONG Size = 0;
    do
    {
        //
        // Round up to sectore alignment and sum up file sizes
        //
        Size += AlignUp(FindData.nFileSizeLow, 512);

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);
    return Size;
}


ULONGLONG
BrGetXactSpace(
    LPCWSTR pDirName
    )
{
    ULONGLONG Size = 0;
    for(int i = 0; i < xXactFileListSize; i++)
    {
        Size += BrGetUsedSpace(pDirName, xXactFileList[i]);
    }

    return Size;
}


ULONGLONG
BrGetFreeSpace(
    LPCWSTR pDirName
    )
{
    BOOL fSucc;
    ULARGE_INTEGER CallerFreeBytes;
    ULARGE_INTEGER CallerTotalBytes;
    ULARGE_INTEGER AllFreeBytes;
    fSucc = GetDiskFreeSpaceEx(
                pDirName,
                &CallerFreeBytes,
                &CallerTotalBytes,
                &AllFreeBytes
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_GET_FREE_SPACE);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    return CallerFreeBytes.QuadPart;
}


HKEY
BrCreateKey(
    void
    )
{
    LONG lRes;
    HKEY hKey;
    lRes = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            xRegNameMSMQ,
            0,      // reserved
            0,      // address of class string
            REG_OPTION_BACKUP_RESTORE,
            0,      // desired security access
            0,      // address of key security structure
            &hKey,
            0       // address of disposition value buffer
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REG);
        BrErrorExit(lRes, strErr.Get(), xRegNameMSMQ);
    }

    return hKey;
}


void
BrSaveKey(
    HKEY hKey,
    LPCWSTR pDirName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, xRegFileName);

    LONG lRes;
    lRes = RegSaveKey(
            hKey,
            FileName,
            NULL    // file security attributes
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_SAVE_MSMQ_REGISTRY);
        BrErrorExit(lRes, strErr.Get());
    }
}


void
BrRestoreKey(
    HKEY hKey,
    LPCWSTR pDirName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, xRegFileName);

    LONG lRes;
    lRes = RegRestoreKey(
            hKey,
            FileName,
            0   // option flags
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_RESTORE_MSMQ_REGISTRY);
        BrErrorExit(lRes, strErr.Get());
    }
}


void
BrSetRestoreSeqID(
    void
    )
{
    LONG lRes;
    HKEY hKey;
    DWORD RegSeqID = 0;
    
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            xRegNameParameters,
            0,      // reserved
            KEY_READ | KEY_WRITE,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_REG_KEY_READ_WRITE);
        BrErrorExit(lRes, strErr.Get(), xRegNameParameters);
    }

    //
    // get last SeqID used before backup
    //
    BrpQueryDwordValue(hKey,  L"SeqID", &RegSeqID);

    //
    // Increment by 1, so we will not use the same SeqID more than once in successive restores.
    //
    ++RegSeqID;

    //
    // Select the max SeqID, Time or Registry. This overcomes date/time changes on this computer 
    // in a following scenario: Backup, Restore, reset time back, Start QM 
    //      (without max with Time here QM at start will not move SeqID enough to avoid races)
    //      
    DWORD TimeSeqID = MqSysTime();
    DWORD dwSeqID = max(RegSeqID, TimeSeqID);

    //
    // Write-back selected SeqID so we will start from this value
    //
    BrpSetDwordValue(hKey,  L"SeqID", dwSeqID);

    //
    // Write-back selected SeqIDAtRestoreTime so that we'll know the boundary
    //
    BrpSetDwordValue(hKey,  L"SeqIDAtLastRestore", dwSeqID);
}


void
BrCloseKey(
    HKEY hKey
    )
{
    RegCloseKey(hKey);
}


void
BrCopyFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pMask,
    LPCWSTR pDstDir
    )
{
    WCHAR SrcPathName[MAX_PATH];
    wcscpy(SrcPathName, pSrcDir);
    wcscat(SrcPathName, pMask);
    LPWSTR pSrcName = wcsrchr(SrcPathName, L'\\') + 1;

    WCHAR DstPathName[MAX_PATH];
    wcscpy(DstPathName, pDstDir);
    if (DstPathName[wcslen(DstPathName)-1] != L'\\')
    {
        wcscat(DstPathName, L"\\");
    }


    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                SrcPathName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // No matching file, just return without copy. if path does not
            // exists this is another error (3).
            //
            return;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pSrcDir);
    }

    do
    {
        //
        // We don't copy sub-directories
        //
        if((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            continue;

        BrpWriteConsole(L".");
        wcscpy(pSrcName, FindData.cFileName);
        WCHAR DstName[MAX_PATH];
        wcscpy(DstName, DstPathName);
        wcscat(DstName, FindData.cFileName);

        BOOL fSucc;
        fSucc = CopyFile(
                    SrcPathName,
                    DstName,
                    TRUE   // fail if file exits
                    );
        if(!fSucc)
        {
            DWORD gle = GetLastError();
            CResString strErr(IDS_CANT_COPY);
            BrErrorExit(gle, strErr.Get(), SrcPathName, DstPathName);
        }

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);
}


void
BrCopyXactFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pDstDir
    )
{
    for(int i = 0; i < xXactFileListSize; i++)
    {
        BrCopyFiles(pSrcDir, xXactFileList[i], pDstDir);
    }
}


void
BrSetDirectorySecurity(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Configures security on a directory. Failures ignored.

    The function sets the security of the given directory such that
    any file that is created in the directory will have full control
    for  the local administrators group and no access at all to
    anybody else.


Arguments:
    pDirName - Directory Path.

Return Value:
    None.

--*/
{
    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid
                ))
    {
        return; 
    }

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    ACL* pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = (WORD)(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    if (NULL == pDacl)
    {
        return; 
    }
    ACCESS_ALLOWED_ACE* pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];
    if (NULL == pAce)
    {
        delete [] pDacl;
        return;
    }

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(pDirName, DACL_SECURITY_INFORMATION, &SD))
    {
        // 
        // Ignore failure
        //
    }

    FreeSid(pAdminSid);
    delete [] pDacl;
    delete [] pAce;

} //BrpSetDirectorySecurity


static
bool
BrpIsDirectory(
    LPCWSTR pDirName
    )
{
    DWORD attr = GetFileAttributes(pDirName);
    
    if ( 0xFFFFFFFF == attr )
    {
        //
        // BUGBUG? Ignore errors, just report to caller this is
        // not a directory.
        //
        return false;
    }
    
    return ( 0 != (attr & FILE_ATTRIBUTE_DIRECTORY) );

} //BrpIsDirectory


void
BrCreateDirectory(
    LPCWSTR pDirName
    )
{
    //
    // First, check if the directory already exists
    //
    if (BrpIsDirectory(pDirName))
    {
        return;
    }

    //
    // Second, try to create it.
    //
    // Don't remove the code for checking ERROR_ALREADY_EXISTS.
    // It could be that we fail to verify that the directory exists
    // (eg security or parsing problems - see documentation of GetFileAttributes() ), 
    // but when trying to create it we get an error that it already exists. 
    // Be on the safe side. (ShaiK, 31-Dec-98)
    //
    if (!CreateDirectory(pDirName, 0) && 
        ERROR_ALREADY_EXISTS != GetLastError())
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_CREATE_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }
} //BrCreateDirectory


void
BrCreateDirectoryTree(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Creates local or remote directory tree

Arguments:
    pDirName - full pathname

Return Value:
    None.

--*/
{
    if (BrpIsDirectory(pDirName))
    {
        return;
    }

    if (CreateDirectory(pDirName, 0) || 
        ERROR_ALREADY_EXISTS == GetLastError())
    {
        return;
    }

    TCHAR szDir[MAX_PATH];
    wcscpy(szDir, pDirName);
    if (szDir[wcslen(szDir)-1] != L'\\')
    {
        wcscat(szDir, L"\\");
    }

    PTCHAR p = &szDir[0];
    if (wcslen(szDir) > 2 && szDir[0] == L'\\' && szDir[1] == L'\\')
    {
        //
        // Remote full path: \\machine\share\dir1\dir2\dir3
        // 
        // Point to top level remote parent directory: \\machine\share\dir1
        //
        p = wcschr(&szDir[2], L'\\');
        if (p != 0)
        {
            p = wcschr(CharNext(p), L'\\');
            if (p != 0)
            {
                p = CharNext(p);
            }
        }
    }
    else
    {
        //
        // Local full path: x:\dir1\dir2\dir3
        //
        // Point to top level parent directory: x:\dir1
        //
        p = wcschr(szDir, L'\\');
        if (p != 0)
        {
            p = CharNext(p);
        }
    }

    for ( ; p != 0 && *p != 0; p = CharNext(p))
    {
        if (*p != L'\\')
        {
            continue;
        }

        *p = 0;
        BrCreateDirectory(szDir);
        *p = L'\\';
    }
} //BrCreateDirectoryTree


void
BrVerifyBackup(
    LPCWSTR pBackupDir,
    LPCWSTR pBackupDirStorage
    )
{
    //
    //  1. Verify that this is a valid backup
    //
    if(BrGetUsedSpace(pBackupDir, xBackupIDFileName) == 0)
    {
        CResString strErr(IDS_NOT_VALID_BK);
        BrErrorExit(0, strErr.Get(), xBackupIDFileName);
    }

    //
    //  2. Verify that all must exist files are there
    //
    if(BrGetUsedSpace(pBackupDir, xRegFileName) == 0)
    {
        CResString strErr(IDS_NOT_VALID_BK);
        BrErrorExit(0, strErr.Get(), xRegFileName);
    }

    for(int i = 0; i < xXactFileListSize; i++)
    {
        if(BrGetUsedSpace(pBackupDirStorage, xXactFileList[i]) == 0)
        {
            CResString strErr(IDS_NOT_VALID_BK);
            BrErrorExit(0, strErr.Get(), xXactFileList[i]);
        }
    }

    //
    //  3. Verify that this backup belong to this machine
    //
} 


BOOL 
BrIsFileInUse(
	LPCWSTR pFileName
	)
/*++

Routine Description:

	Checks whether the given file in the system's directory is in use (loaded)

Arguments:

    pFileName - File name to check

Return Value:

    TRUE             - In use
    FALSE            - Not in use 

--*/
{
    //
    // Form the path to the file
    //   
    WCHAR szFilePath[MAX_PATH ];
	WCHAR szSystemDir[MAX_PATH];
	GetSystemDirectory(szSystemDir, MAX_PATH);

    swprintf(szFilePath, L"%s\\%s", szSystemDir, pFileName);

    //
    // Attempt to open the file for writing
    //
    HANDLE hFile = CreateFile(szFilePath, GENERIC_WRITE, 0, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD err = GetLastError();
	//
    // A sharing violation indicates that the file is already in use
    //
    if (hFile == INVALID_HANDLE_VALUE &&
        err == ERROR_SHARING_VIOLATION)
    {
        return TRUE;
    }

    //
    // The file handle is no longer needed
    //
    CloseHandle(hFile);


    return FALSE;
}

 
BOOL CALLBACK BrFindSpecificModuleCallback(
									LPSTR        Name,
									DWORD_PTR   Base,
									DWORD       Size,
									PVOID       Context
									)

/*++

Routine Description:

    Callback function for module enumeration - search for a specific module

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
	UNREFERENCED_PARAMETER( Base);
	UNREFERENCED_PARAMETER( Size);

	pEnumarateData pEd = reinterpret_cast<pEnumarateData>(Context);

    WCHAR wzName[255];
	ConvertToWideCharString(Name, wzName, sizeof(wzName)/sizeof(wzName[0]));
	BOOL fDiff= CompareStringsNoCase(wzName,pEd->pModuleName);
    if (!fDiff)
	{	
		//
		// The Moudle name was found
		//
        pEd->fFound = TRUE;
        return FALSE; // Found Module so stop enumerating
    }

    return TRUE;// Continue enumeration.
}


BOOL 
BrIsModuleLoaded(
	DWORD processId,
	LPCWSTR pModuleName,
    EnumerateLoadedModules_ROUTINE pfEnumerateLoadedModules
	)
/*++

Routine Description:

	Check if a certain module is loaded

Arguments:

   processId	- process Id 
   pModuleName	- module name
   pfEnumerateLoadedModules - function pointer to EnumerateLoadedModules()
   
Return Value:

    TRUE	-	loaded
	FALSE	-	not loaded

--*/
{
	EnumarateData ed;
	ed.fFound = FALSE;
	ed.pModuleName = pModuleName;
	
	//
	// Note: EnumerateLoadedModules() is supported On NT5 
	// The API enumerate all modles in the process and execute the callback function for every module
	//

    //
    // ISSUE-2000/11/07-erez Backup/Restore does not use correct 64 bit functions
    // Note that the enumeration function and the passed process handle are not correct
    // this need to be changed.
    //

    pfEnumerateLoadedModules(
        (HANDLE)(LONG_PTR)processId,
        BrFindSpecificModuleCallback,
        &ed
        );
	
    return ed.fFound;
	
}


void
BrPrintAffecetedProcesses(
	LPCWSTR pModuleName
	)
/*++

Routine Description:

	Print all processes that loaded a certain module.
	Note: this function assumes that the system is NT5 .

Arguments:

   pModuleName        - Module name
    
Return Value:

    None

--*/
{
    
	
	//
    // Obtain pointers to the tool help functions.
    //
	// Note: we can't call these function in the conventional way becouse that result in
	// an error trying to load this executable under NT4 (undefined entry point)
    //

    assert(BrIsSystemNT5());

    HINSTANCE hKernelLibrary = GetModuleHandle(L"kernel32.dll");
	assert(hKernelLibrary != NULL);

    typedef HANDLE (WINAPI *FUNCCREATETOOLHELP32SNAPSHOT)(DWORD, DWORD);
    FUNCCREATETOOLHELP32SNAPSHOT pfCreateToolhelp32Snapshot =
		(FUNCCREATETOOLHELP32SNAPSHOT)GetProcAddress(hKernelLibrary,
													 "CreateToolhelp32Snapshot");
	if(pfCreateToolhelp32Snapshot == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"CreateToolhelp32Snapshot"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	typedef BOOL (WINAPI *PROCESS32FIRST)(HANDLE ,LPPROCESSENTRY32 );
	PROCESS32FIRST pfProcess32First = (PROCESS32FIRST)GetProcAddress(hKernelLibrary,
																	"Process32First");

    if(pfProcess32First == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"pfProcess32First"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
            BrpWriteConsole(L"\n");
        }
        return;
    }
    
	typedef BOOL (WINAPI *PROCESS32NEXT)(HANDLE ,LPPROCESSENTRY32 );
	PROCESS32NEXT pfProcess32Next = (PROCESS32NEXT)GetProcAddress(hKernelLibrary,
																	"Process32Next");
    
    if(pfProcess32Next == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"pfProcess32Next"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	

    CAutoFreeLibrary hDbghlpLibrary = LoadLibrary(L"dbghelp.dll");
	if (hDbghlpLibrary == NULL)
    {
        CResString strLibProblem(IDS_CANT_SHOW_PROCESSES_LIB_PROBLEM);
        BrpWriteConsole(strLibProblem.Get());
        return;
    }

    
    EnumerateLoadedModules_ROUTINE pfEnumerateLoadedModules = (EnumerateLoadedModules_ROUTINE)
        GetProcAddress(hDbghlpLibrary, "EnumerateLoadedModules");

	if(pfEnumerateLoadedModules == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"EnumerateLoadedModules"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	//
	// Take the current snapshot of the system
	//

	HANDLE hSnapshot = pfCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)	;
    if(hSnapshot == INVALID_HANDLE_VALUE)
    {
        CResString strSnapProblem(IDS_CANT_CREATE_SNAPSHOT);
        BrpWriteConsole(strSnapProblem.Get());
        return;

    }


    PROCESSENTRY32 entryProcess;
    entryProcess.dwSize = sizeof(entryProcess);

	BOOL bNextProcess = pfProcess32First(hSnapshot, &entryProcess);
	//
	// Iterate on all running processes and check if the loaded a certain module
	//
	while (bNextProcess)
	{
    
		//
		// For every process check it's loaded modules and if pModuleName
		// is loaded print the process name 
		//
		if(BrIsModuleLoaded(entryProcess.th32ProcessID,pModuleName,pfEnumerateLoadedModules))
		{
            BrpWriteConsole(entryProcess.szExeFile);
            BrpWriteConsole(L" \n");
		}

		bNextProcess = pfProcess32Next(hSnapshot, &entryProcess);
	}  
}


void
BrVerifyUserWishToContinue()
/*++

Routine Description:

	Verify the user wish to continue.

Arguments:

    None

Return Value:

    None
	
--*/
{
	CResString strVerify(IDS_VERIFY_CONTINUE);
    CResString strY(IDS_Y);
    CResString strN(IDS_N);
	WCHAR szBuf[MAX_PATH] = {0};

    DWORD rc = BrpFormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        strVerify.Get(),
        0,
        0,
        szBuf,
        0,
        strY.Get(),
        strN.Get()
        );

    if (rc == 0)
    {
        //
        // NOTE:  Failed to generate  message, continue as if the user chose yes, not harmful
        //
        return;
    }

    for (;;)
    {
        BrpWriteConsole(szBuf);
        
        WCHAR sz[MAX_PATH] = {0};
        wscanf(L"%s", sz);

        if (0 == CompareStringsNoCase(sz, strY.Get()))
        {
            break;
        }

        if (0 == CompareStringsNoCase(sz, strN.Get()))
        {
            CResString strAbort(IDS_ABORT);
            BrpWriteConsole(strAbort.Get());
            exit(-1);
        }
    }
}//BrVerifyUserWishToContinue


void
BrNotifyAffectedProcesses(
		  LPCWSTR pModuleName
		  )
/*++

Routine Description:

    Checks whether a certain file in the system's directory is loaded by any process,
	and notify the user 

Arguments:

    pModuleName        - Module name
    
Return Value:

    None
--*/

{
	BOOL fUsed = BrIsFileInUse(pModuleName);
	if(!fUsed)
	{
		//
		// The file is not in use -> not loaded ,no reason to continue
		//
		return;
	}
	else 
	{
		CResString str(IDS_SEARCHING_AFFECTED_PROCESSES);
        BrpWriteConsole(str.Get());
		BrPrintAffecetedProcesses(pModuleName);
		BrVerifyUserWishToContinue();
	}
}


BOOL 
BrIsSystemNT5()
/*++

Routine Description:

	Checks whether the operating system is NT5 or later
	Note:if the function can't verify the current running version of the system
		 the assumption is that the version is other than NT5

Arguments:

    None

Return Value:

    TRUE             - Operating system is NT5 or later
    FALSE            - Other

--*/

{	
	OSVERSIONINFO systemVer;
	systemVer.dwOSVersionInfoSize  =  sizeof(OSVERSIONINFO) ;
	BOOL fSucc = GetVersionEx (&systemVer);
	if(!fSucc)
	{
		//
		// could not verify system's version , we return false just to be on the safe side
		//
		return FALSE;
	}
	else 
	{
		if( (systemVer.dwPlatformId == VER_PLATFORM_WIN32_NT) && (systemVer.dwMajorVersion >= 5))
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bkuprstr\restore.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    restore.cpp

Abstract:

    Restore MSMQ 1.0, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include "br.h"
#include "bkupres.h"

void DoRestore(LPCWSTR pBackupDir)
{
    WCHAR BackupDir[MAX_PATH];
    wcscpy(BackupDir, pBackupDir);
    if (BackupDir[wcslen(BackupDir)-1] != L'\\')
    {
        wcscat(BackupDir, L"\\");
    }

    WCHAR BackupDirMapping[MAX_PATH];
    wcscpy(BackupDirMapping, BackupDir);
    wcscat(BackupDirMapping, L"MAPPING\\");

    WCHAR BackupDirStorage[MAX_PATH];
    wcscpy(BackupDirStorage, BackupDir);
    wcscat(BackupDirStorage, L"STORAGE\\");

    WCHAR BackupDirStorageLqs[MAX_PATH];
    wcscpy(BackupDirStorageLqs, BackupDirStorage);
    wcscat(BackupDirStorageLqs, L"LQS\\");

    //
    //  0. Verify user premissions to restore
    //
    CResString str(IDS_VERIFY_RESTORE_PRIV);
    BrpWriteConsole(str.Get());
    BrInitialize(SE_RESTORE_NAME);
    
    //
    //  1. Verify that this is a valid backup
    //
    str.Load(IDS_VERIFY_BK);
    BrpWriteConsole(str.Get());
    BrVerifyBackup(BackupDir, BackupDirStorage);

    //
    //  4.  A. Notify the user on affected application due to the stopping of MSMQ service (only on NT5)
	//		B. Stop MSMQ Service and dependent services if running and remember running state. 
    //      C. Detach MQAC from the files.
    //

	
	if(BrIsSystemNT5())
	{
		BrNotifyAffectedProcesses(L"mqrt.dll");
	}
    //
    // IDS_STOP_SERVICE is used and have different TEXT,
    // i.e. changed to IDS_BKRESTORE_STOP_SERVICE
    //
    str.Load(IDS_BKRESTORE_STOP_SERVICE);
    BrpWriteConsole(str.Get());
    ENUM_SERVICE_STATUS * pDependentServices = NULL;
    DWORD NumberOfDependentServices = 0;
    BOOL fStartService = BrStopMSMQAndDependentServices(&pDependentServices, &NumberOfDependentServices);

    //
    //  5. Restore registry settings from backed-up file
    //
    str.Load(IDS_RESTORE_REGISTRY);
    BrpWriteConsole(str.Get());
    HKEY hKey = BrCreateKey();
    BrRestoreKey(hKey, BackupDir);
    BrCloseKey(hKey);
    
    // 
    //  5a. Keep in registry (SeqIDAtLastRestore) SeqID at restore time
    //
    str.Load(IDS_REMEMBER_SEQID_RESTORE);
    BrpWriteConsole(str.Get());
    BrSetRestoreSeqID();

    //
    //  6. Get Registry Values for subdirectories
    //
    str.Load(IDS_READ_FILE_LOCATION);
    BrpWriteConsole(str.Get());
    STORAGE_DIRECTORIES sd;
    BrGetStorageDirectories(sd);

    WCHAR MappingDirectory[MAX_PATH];
    BrGetMappingDirectory(MappingDirectory, sizeof(MappingDirectory));

    WCHAR WebDirectory[MAX_PATH];
    GetSystemDirectory(WebDirectory, sizeof(WebDirectory)/sizeof(WebDirectory[0]));
    wcscat(WebDirectory, L"\\MSMQ\\WEB");

    //
    //  7. Create all directories: storage, LQS, mapping, web
    //
    str.Load(IDS_VERIFY_STORAGE_DIRS);
    BrpWriteConsole(str.Get());

    BrCreateDirectoryTree(sd[ixExpress]);
    BrCreateDirectoryTree(sd[ixRecover]);
    BrCreateDirectoryTree(sd[ixJournal]);
    BrCreateDirectoryTree(sd[ixLog]);

    WCHAR LQSDir[MAX_PATH];
    wcscpy(LQSDir, sd[ixLQS]);
    wcscat(LQSDir, L"\\LQS");
    BrCreateDirectory(LQSDir);

    BrCreateDirectoryTree(MappingDirectory);
    BrCreateDirectoryTree(WebDirectory);

    //
    //  8. Delete all files in storage/LQS/mapping/web directories
    //
    BrEmptyDirectory(sd[ixExpress]);

    BrEmptyDirectory(sd[ixRecover]);

    BrEmptyDirectory(sd[ixJournal]);

    BrEmptyDirectory(sd[ixLog]);

    BrEmptyDirectory(LQSDir);

    BrEmptyDirectory(MappingDirectory);

    BrEmptyDirectory(WebDirectory);

    //
    //  9  Check for available disk space
    //


    //
    // 10. Restore message files
    //
    str.Load(IDS_RESTORE_MSG_FILES);
    BrpWriteConsole(str.Get());
    BrCopyFiles(BackupDirStorage, L"\\p*.mq", sd[ixRecover]);
    BrCopyFiles(BackupDirStorage, L"\\j*.mq", sd[ixJournal]);
    BrCopyFiles(BackupDirStorage, L"\\l*.mq", sd[ixLog]);

    //
    // 11. Restore logger files and mapping files
    //
    BrCopyXactFiles(BackupDirStorage, sd[ixXact]);
    BrCopyFiles(BackupDirMapping, L"\\*", MappingDirectory);

    //
    // 12. Restore LQS directory
    //
    BrCopyFiles(BackupDirStorageLqs, L"*", LQSDir);
    BrpWriteConsole(L"\n");

    //
    // Set security on all subdirectories
    //
    BrSetDirectorySecurity(sd[ixExpress]);
    BrSetDirectorySecurity(sd[ixRecover]);
    BrSetDirectorySecurity(sd[ixJournal]);
    BrSetDirectorySecurity(sd[ixLog]);

    BrSetDirectorySecurity(LQSDir);
    BrSetDirectorySecurity(WebDirectory);
    BrSetDirectorySecurity(MappingDirectory);

    WCHAR MsmqRootDirectory[MAX_PATH];
    GetSystemDirectory(MsmqRootDirectory, sizeof(MsmqRootDirectory)/sizeof(MsmqRootDirectory[0]));
    wcscat(MsmqRootDirectory, L"\\MSMQ");
    BrSetDirectorySecurity(MsmqRootDirectory);

    //
    // 13. Restart MSMQ and dependent services if needed.
    //
    if(fStartService)
    {
        str.Load(IDS_START_SERVICE);
        BrpWriteConsole(str.Get());
        BrStartMSMQAndDependentServices(pDependentServices, NumberOfDependentServices);
    }


    //
    // 14. Issue a warning about running applications
    //
    str.Load(IDS_DONE);
    BrpWriteConsole(str.Get());











/*                        BUGBUG: localize here

    //
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //     pre allocate 32K for registry save.
    //
    BrpWriteConsole(L"Checking available disk space\n");
    ULONGLONG RequiredSpace = 32768;
    RequiredSpace += BrGetUsedSpace(sd[ixRecover], L"\\p*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixJournal], L"\\j*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixLog],     L"\\l*.mq");

    RequiredSpace += BrGetXactSpace(sd[ixXact]);
    RequiredSpace += BrGetUsedSpace(sd[ixLQS], L"\\LQS\\*");

    ULONGLONG AvailableSpace = BrGetFreeSpace(BackupDir);
    if(AvailableSpace < RequiredSpace)
    {
        BrErrorExit(0, L"Not enought disk space for backup on '%s'", BackupDir);
    }
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\hauthen\hauthen.h ===
//
// file: hauthen.h
//

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

extern "C" RPC_IF_HANDLE hauthen_i_v1_0_s_ifspec ;

typedef unsigned char * LPUSTR ;

#define PROTOSEQ_TCP   ((LPUSTR) "ncacn_ip_tcp")
#define ENDPOINT_TCP   ((LPUSTR) "4000")
#define OPTIONS_TCP    ((LPUSTR) "")

#define PROTOSEQ_LOCAL   ((LPUSTR) "ncalrpc")
#define ENDPOINT_LOCAL   ((LPUSTR) "MyLocalTestEP")
#define OPTIONS_LOCAL    ((LPUSTR) "Security=Impersonation Dynamic True")

//---------------------------------
//
//  Definitions for debugging
//
//---------------------------------

#ifdef _DEBUG
#define DBG_PRINT_ERROR(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_WARN(x)   _tprintf x ; printf("\n") ;
#define DBG_PRINT_TRACE(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_INFO(x)   _tprintf x ; printf("\n") ;
#else
#define DBG_PRINT_ERROR(x)
#define DBG_PRINT_WARN(x)
#define DBG_PRINT_TRACE(x)
#define DBG_PRINT_INFO(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\falset\falset1.c ===
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <direct.h>

#define Usage {fprintf (stderr, "%cUsage: FalSet -s <Server Name> -i <IndClient Name>\n",7); return (1);}
enum FalTypes {Empty, Server, IndClient, DepClient};

void
GetBaseName (char *Path, char *BaseName)
{
	char *cp;
//	char *BaseName = *BaseNamep;

	strcpy (BaseName, Path);
	for (cp = &BaseName[strlen(BaseName)-1] ; cp > BaseName && *cp != '\\' ; cp--);
	if (*cp == '\\') {
		cp++;
		*cp = '\0';
	}
	else
		strcpy (BaseName, ".\\");
}


main (int argc, char *argv[])
{
	enum FalTypes role = Empty;
	char ThisComputer[64];
	char *ServerName = NULL;
	char *IndClientName = NULL;
	char *RemoteMachine = NULL;
	char AnswerFile[256], AnswerFileOff[256];
	char WinDir32[128], TmpFile[128];
	char Command[256];
	char line[256];
	char BaseName[256], TempAnswerFile[256], SetupFile[256];
	int i, rc;
	FILE *fpSrc, *fpOn, *fpOff;

	for (i = 1 ; i < argc ; i++) {
		if (strncmp (argv[i], "-s", 2) == 0) {
			if (ServerName) Usage
			if (argv[i][2]) ServerName = &argv[i][2];
			else if (i == argc-1) Usage
			else ServerName = argv[++i];
		}
		else
		if (strncmp (argv[i], "-i", 2) == 0) {
			if (IndClientName) Usage
			if (argv[i][2]) IndClientName = &argv[i][2];
			else if (i == argc-1) Usage
			else IndClientName = argv[++i];
		}
		else Usage
	}
	if (!ServerName || !IndClientName) Usage

	strcpy (ThisComputer, getenv ("COMPUTERNAME"));		// Note: doesn't work on Win95

	if (stricmp (ThisComputer, ServerName) == 0) {
		printf ("Setting up this machine as the MSMQ Server.\n");
		role = Server;
		RemoteMachine = IndClientName;
	}
	if (stricmp (ThisComputer, IndClientName) == 0) {
		if (role == Server)
			printf ("Warning: Remote machine is itself.\n");
		else {
			printf ("Setting up this machine as the MSMQ Ind Client.\n");
			role = IndClient;
		}
		RemoteMachine = ServerName;
	}
	if (role == Empty) {
		printf ("Setting up this machine as the MSMQ Dep Client.\n");
		role = DepClient;
		RemoteMachine = IndClientName;
	}
//	sprintf (Command, "set remote1=%s", RemoteMachine);
	sprintf (WinDir32, "%s\\system32", getenv ("WinDir"));
	_chdir (WinDir32);
// Create "RemoteMachine" file
/*
	fpOn = fopen ("MSMQRemote", "w");
	fprintf (fpOn, "%s\\%s\n", WinDir32, RemoteMachine);
	fclose (fpOn);
*/
	sprintf (TmpFile, "%s\\MSMQFile1.txt", WinDir32);
	fpOn = fopen (TmpFile, "w");
	fprintf (fpOn, "%s\n", RemoteMachine);
	fclose (fpOn);
	if (role == DepClient) {
		sprintf (TmpFile, "%s\\MSMQFile0.txt", WinDir32);
		fpOn = fopen (TmpFile, "w");
		fprintf (fpOn, "%s\n", ServerName);
		fclose (fpOn);
	}

	sprintf (AnswerFile, "%s\\MSMQUnattendOn.txt", WinDir32);
	if (_access (AnswerFile, 0) == 0) {
		printf ("%s exists already (MSMQ already installed). Setting up only for FalBvt, exiting now.\n",
			AnswerFile);
		return (0);	// File exists
	}
//	if (GetFileAttributes (AnswerFile) >= 0) return (0);

	GetBaseName (argv[0], BaseName);

	sprintf (TempAnswerFile, "%sTempAnswerFile.txt", BaseName); 
	if (_access (TempAnswerFile, 04) != 0) {
		fprintf (stderr, "%cCannot find %s, exiting\n", 7, TempAnswerFile);
		exit (2);
	}
	sprintf (SetupFile, "%sSetup.bat", BaseName); 
	if (_access (SetupFile, 04) != 0) {
		fprintf (stderr, "%cCannot find %s, exiting\n", 7, SetupFile);
		exit (3);
	}

	if (role == Server) {
//		system ("a:\\mqupdate.bat");
		sprintf (Command, "%smqupdate.bat", BaseName); 
		if (_access (Command, 04) != 0) {
			fprintf (stderr, "%cCannot find %s, exiting\n", 7, Command);
			exit (4);
		}

	// NOTE: In the mean time, we must update the registry ourselves
		system (Command);
/*
		system ("RunDLL32.exe SetupAPI,InstallHinfSection DefaultInstall 0 UpdSchem.Inf");
		system ("mqupschm.exe");
*/
	}
//	sprintf (Command, "copy TempAnswerFile %s", AnswerFile);
//	system (Command);
	sprintf (AnswerFileOff, "%s\\MSMQUnattendOff.txt", WinDir32);
//	fpSrc = fopen ("a:\\TempAnswerFile.txt", "r");
	fpSrc = fopen (TempAnswerFile, "r");
	fpOn = fopen (AnswerFile, "w");
	fpOff = fopen (AnswerFileOff, "w");
	while (fgets (line, 256, fpSrc)) {		// Copy original file
		fputs (line, fpOn);
		fputs (line, fpOff);
	}
	fprintf (fpOn, "msmq = ON\n");
	fprintf (fpOff, "msmq = OFF\n");
	fprintf (fpOn, "\n[msmq]\n");
	fprintf (fpOff, "\n[msmq]\n");
	fprintf (fpOn, "ServerAuthenticationOnly = FALSE\n");
	fprintf (fpOff, "ServerAuthenticationOnly = FALSE\n");
	fprintf (fpOn, "ServerType = %s\n", (role == IndClient)?"IND":"DEP");
	fprintf (fpOff, "ServerType = %s\n", (role == IndClient)?"IND":"DEP");
	fprintf (fpOn, "ClientType = %s\n", (role == IndClient)?"IND":"DEP");
	fprintf (fpOff, "ClientType = %s\n", (role == IndClient)?"IND":"DEP");
	fprintf (fpOn, "ControllerServer = %s\n", ServerName);
	fprintf (fpOff, "ControllerServer = %s\n", ServerName);
	fprintf (fpOn, "SupportingServer = %s\n", ServerName);
	fprintf (fpOff, "SupportingServer = %s\n", ServerName);
	fclose (fpSrc);
	fclose (fpOn);
	fclose (fpOff);

	// NOTE: In the mean time, we use our local sysoc.inf

/*
	sprintf (Command, "%s\\sysocmgr.exe /i:sysoc.inf /c /n /u:%s",
		getenv ("windir"), AnswerFile);
	system (Command);
*/
//	sprintf (Command, "a:\\Setup.bat %s", AnswerFile);
	sprintf (Command, "%s %s", SetupFile, AnswerFile);
	rc = system (Command);
	return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\falset\falset.cpp ===
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <direct.h>

#define Usage {fprintf (stderr, "%cUsage: FalSet -s <Server Name> -i <IndClient Name>\n",7); return (1);}
enum FalTypes {Empty, Server, IndClient, DepClient};

void
GetBaseName (char *Path, char *BaseName)
{
	char *cp;

	strcpy (BaseName, Path);
	for (cp = &BaseName[strlen(BaseName)-1] ; cp > BaseName && *cp != '\\' ; cp--);
	if (*cp == '\\') {
		cp++;
		*cp = '\0';
	}
	else
		strcpy (BaseName, ".\\");
}


main (int argc, char *argv[])
{
	enum FalTypes role = Empty;
	char ThisComputer[64];
	char *ServerName = NULL;
	char *IndClientName = NULL;
	char *RemoteMachine = NULL;
	char AnswerFile[256], AnswerFileOff[256];
	char WinDir32[128], TmpFile[128];
	char Command[256];
	char line[256];
	char BaseName[256], TempAnswerFile[256], SetupFile[256];
	int i, rc;
	FILE *fpSrc, *fpOn, *fpOff;

	// Deciding what to set

	for (i = 1 ; i < argc ; i++) {
		if (strncmp (argv[i], "-s", 2) == 0) {
			if (ServerName) Usage
			if (argv[i][2]) ServerName = &argv[i][2];
			else if (i == argc-1) Usage
			else ServerName = argv[++i];
		}
		else
		if (strncmp (argv[i], "-i", 2) == 0) {
			if (IndClientName) Usage
			if (argv[i][2]) IndClientName = &argv[i][2];
			else if (i == argc-1) Usage
			else IndClientName = argv[++i];
		}
		else Usage
	}
	if (!ServerName || !IndClientName) Usage

	strcpy (ThisComputer, getenv ("COMPUTERNAME"));		// Note: doesn't work on Win95

	if (stricmp (ThisComputer, ServerName) == 0) {
		printf ("Setting up this machine as the MSMQ Server.\n");
		role = Server;
		RemoteMachine = IndClientName;
	}
	if (stricmp (ThisComputer, IndClientName) == 0) {
		if (role == Server)
			printf ("Warning: Remote machine is itself.\n");
		else {
			printf ("Setting up this machine as the MSMQ Ind Client.\n");
			role = IndClient;
		}
		RemoteMachine = ServerName;
	}
	if (role == Empty) {
		printf ("Setting up this machine as the MSMQ Dep Client.\n");
		role = DepClient;
		RemoteMachine = IndClientName;
	}

	// Creating role-indicating files

	sprintf (WinDir32, "%s\\system32", getenv ("WinDir"));
	_chdir (WinDir32);
	
	sprintf (TmpFile, "%s\\MSMQFile1.txt", WinDir32);
	fpOn = fopen (TmpFile, "w");
	fprintf (fpOn, "%s\n", RemoteMachine);
	fclose (fpOn);
	if (role == DepClient) {
		sprintf (TmpFile, "%s\\MSMQFile0.txt", WinDir32);
		fpOn = fopen (TmpFile, "w");
		fprintf (fpOn, "%s\n", ServerName);
		fclose (fpOn);
	}

	GetBaseName (argv[0], BaseName);

	// Setting up Falcon
	sprintf (AnswerFile, "%s\\MSMQUnattendOn.txt", WinDir32);
	if (_access (AnswerFile, 0) == 0) {
		printf ("%s exists already (MSMQ already installed). Setting up only for FalBvt, exiting now.\n",
			AnswerFile);
		return (0);	// File exists
	}

	GetBaseName (argv[0], BaseName);

	sprintf (TempAnswerFile, "%sTempAnswerFile.txt", BaseName); 
	if (_access (TempAnswerFile, 04) != 0) {
		fprintf (stderr, "%cCannot find %s, exiting\n", 7, TempAnswerFile);
		exit (2);
	}
	sprintf (SetupFile, "%sSetup.bat", BaseName); 
	if (_access (SetupFile, 04) != 0) {
		fprintf (stderr, "%cCannot find %s, exiting\n", 7, SetupFile);
		exit (3);
	}

	sprintf (AnswerFileOff, "%s\\MSMQUnattendOff.txt", WinDir32);
	fpSrc = fopen (TempAnswerFile, "r");
	fpOn = fopen (AnswerFile, "w");
	fpOff = fopen (AnswerFileOff, "w");
	while (fgets (line, 256, fpSrc)) {		// Copy original file
		fputs (line, fpOn);
		fputs (line, fpOff);
	}
	fprintf (fpOn, "msmq = ON\n");
	fprintf (fpOff, "msmq = OFF\n");
	fprintf (fpOn, "\n[msmq]\n");
	fprintf (fpOff, "\n[msmq]\n");

    fprintf (fpOn, "ServerAuthenticationOnly = FALSE\n");
	fprintf (fpOff, "ServerAuthenticationOnly = FALSE\n");
    if (role != Server)
    {
	    fprintf (fpOn, "Type = %s\n", (role == IndClient)?"IND":"DEP");
	    fprintf (fpOff, "Type = %s\n", (role == IndClient)?"IND":"DEP");
	    fprintf (fpOn, "ControllerServer = %s\n", ServerName);
	    fprintf (fpOff, "ControllerServer = %s\n", ServerName);
	    fprintf (fpOn, "SupportingServer = %s\n", ServerName);
	    fprintf (fpOff, "SupportingServer = %s\n", ServerName);
    }
	fclose (fpSrc);
	fclose (fpOn);
	fclose (fpOff);

	// NOTE: In the mean time, we use our local sysoc.inf

/*
	sprintf (Command, "%s\\sysocmgr.exe /i:sysoc.inf /c /n /u:%s",
		getenv ("windir"), AnswerFile);
	system (Command);
*/
//	sprintf (Command, "a:\\Setup.bat %s", AnswerFile);
	sprintf (Command, "%s %s", SetupFile, AnswerFile);

	
	rc = system (Command);


	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\hauthen\sidtext.cpp ===
//
// file:  sidtext.cpp
//

#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//+---------------------------
//
//  BOOL GetTextualSid()
//
// Routine Description:
//
//    This function generates a printable unicode string representation
//    of a SID.
//
//    The resulting string will take one of two forms.  If the
//    IdentifierAuthority value is not greater than 2^32, then
//    the SID will be in the form:
//
//        S-1-281736-12-72-9-110
//              ^    ^^ ^^ ^ ^^^
//              |     |  | |  |
//              +-----+--+-+--+---- Decimal
//
//    Otherwise it will take the form:
//
//        S-1-0x173495281736-12-72-9-110
//            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
//             Hexidecimal    |  | |  |
//                            +--+-+--+---- Decimal
//
//+---------------------------

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD dwBufferLen    // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = _stprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                       (USHORT)psia->Value[0],
                       (USHORT)psia->Value[1],
                       (USHORT)psia->Value[2],
                       (USHORT)psia->Value[3],
                       (USHORT)psia->Value[4],
                       (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("%lu"),
                      (ULONG)(psia->Value[5]      )   +
                      (ULONG)(psia->Value[4] <<  8)   +
                      (ULONG)(psia->Value[3] << 16)   +
                      (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize += _stprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                                *GetSidSubAuthority(pSid, dwCounter) ) ;
    }

    return TRUE;
}

//+---------------------------
//
//  BOOL GetTextualSidW()
//
//+---------------------------

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
    )
{
    TCHAR *pBuf = new TCHAR[ *pdwBufferLen ] ;
    BOOL f = GetTextualSid( pSid,
                            pBuf,
                            pdwBufferLen ) ;
    if (!f)
    {
        delete pBuf ;
        return FALSE ;
    }

#if defined(UNICODE) || defined(_UNICODE)
    wcscpy(TextualSid, pBuf) ;
#else
    mbstowcs( TextualSid, pBuf, (*pdwBufferLen)+1 ) ;
#endif

    delete pBuf ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\errorh.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\hauthen\hauthenc.cpp ===
//
// file:  hauthenc.cpp
//
#include "hauthen.h"
#include "authni.h"

const char  x_szAuthnSrvConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_NONE          0\n"
                      "\t#define RPC_C_AUTHN_DCE_PRIVATE   1\n"
                      "\t#define RPC_C_AUTHN_DCE_PUBLIC    2\n"
                      "\t#define RPC_C_AUTHN_DEC_PUBLIC    4\n"
                      "\t#define RPC_C_AUTHN_GSS_NEGOTIATE 9\n"
                      "\t#define RPC_C_AUTHN_WINNT        10\n"
                      "\t#define RPC_C_AUTHN_GSS_SCHANNEL 14\n"
                      "\t#define RPC_C_AUTHN_GSS_KERBEROS 16\n"
                      "\t#define RPC_C_AUTHN_MSN          17\n"
                      "\t#define RPC_C_AUTHN_DPA          18\n"
                      "\t#define RPC_C_AUTHN_MQ          100\n"
                      "\t#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL\n" } ;

const char  x_szAuthnLvlConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_LEVEL_DEFAULT       0\n"
                      "\t#define RPC_C_AUTHN_LEVEL_NONE          1\n"
                      "\t#define RPC_C_AUTHN_LEVEL_CONNECT       2\n"
                      "\t#define RPC_C_AUTHN_LEVEL_CALL          3\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT           4\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6\n" } ;

ULONG  RunRpcTest( int    i,
                   WCHAR *wszProtocol,
                   WCHAR *wszServerName,
                   WCHAR *wszEndpoint,
                   WCHAR *wszOptions,
                   WCHAR *wszPrincipalNameIn,
                   ULONG ulAuthnService,
                   ULONG ulAuthnLevel,
                   BOOL  fImpersonate,
                   BOOL  fAuthen,
                   BOOL  fKerbDelegation )
{
    WCHAR *wszStringBinding = NULL;
    RPC_STATUS status = RpcStringBindingCompose( NULL,  // pszUuid,
                                                 wszProtocol,
                                                 wszServerName,
                                                 wszEndpoint,
                                                 wszOptions,
                                                 &wszStringBinding);

    DBG_PRINT_INFO((TEXT("RpcStringBindingCompose() return %s, %lut"),
                                             wszStringBinding, status)) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    handle_t hBind = NULL ;
    status = RpcBindingFromStringBinding( wszStringBinding,
                                          &hBind);

    DBG_PRINT_INFO((TEXT(
                   "RpcBindingFromStringBinding() return %lut"), status)) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcStringFree(&wszStringBinding);
    DBG_PRINT_INFO((TEXT("RpcStringFree() return %lut"), status)) ;

    if (fAuthen)
    {
        RPC_SECURITY_QOS   SecQOS;

        SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
        SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

        LPWSTR pwszPrincipalName = NULL;
        if (wszPrincipalNameIn[0] != 0)
        {
            pwszPrincipalName = wszPrincipalNameIn ;
        }

        if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
            (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
        {
            if (fKerbDelegation)
            {
                SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
            }

            if (pwszPrincipalName == NULL)
            {
                status = RpcMgmtInqServerPrincName( hBind,
                                                    ulAuthnService,
                                                    &pwszPrincipalName );
                if (status != RPC_S_OK)
                {
                    DBG_PRINT_ERROR((TEXT(
                 "ATTENTION !!! RpcMgmtInqServerPrincName() failed, err- %lut, test continue..."),
                                                            status)) ;
                }
                DBG_PRINT_INFO((TEXT(
                 "RpcMgmtInqServerPrincName() return %s, Delegate- %lut"),
                                     pwszPrincipalName, fKerbDelegation)) ;
            }
            else
            {
                DBG_PRINT_INFO((TEXT(
                 "Using user supplied Principal name- %s, Delegate- %lut"),
                                     pwszPrincipalName, fKerbDelegation)) ;
            }
        }

        status = RpcBindingSetAuthInfoEx( hBind,
                                          pwszPrincipalName,
                                          ulAuthnLevel,
                                          ulAuthnService,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                          &SecQOS );

        DBG_PRINT_INFO((TEXT(
        "RpcBindingSetAuthInfoEx(Service- %lut, Level- %lut) returned %lut"),
                                  ulAuthnService, ulAuthnLevel, status)) ;
    }
    else
    {
        DBG_PRINT_INFO((TEXT("Not using authentication !!!"))) ;
    }

    ULONG ul ;
    RpcTryExcept
    {
        ul =  RemoteFunction( hBind,
                              fImpersonate ) ;
        DBG_PRINT_INFO((TEXT(
                     "%4lut: RemoteFunction() returned %lut"), i, ul)) ;
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
        DBG_PRINT_ERROR((TEXT(
         "ERROR: %4lut- Exception while calling RemoteFunction(), err- %lut"),
                                                                  i, ul)) ;
    }
    RpcEndExcept

    status = RpcBindingFree( &hBind ) ;
    DBG_PRINT_INFO((TEXT("RpcBindingFree() return %lut"), status)) ;

    return ul ;
}

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, "\t  -a <authentication service, decimal number>\n") ;
    fprintf(stderr, "\t  -c <number of iterations, decimal number>\n") ;
    fprintf(stderr, "\t  -d (enable Kerberos delegation)\n") ;
    fprintf(stderr, "\t  -i (do NOT impersonate on server)\n");
    fprintf(stderr, "\t  -l <authentication Level, decimal number>\n") ;
    fprintf(stderr, "\t  -n <Server name>\n");
    fprintf(stderr, "\t  -o (use local rpc, tcpip being the default)\n");
    fprintf(stderr, "\t  -p <principal name, for nego>\n");
    fprintf(stderr, "\t  -s (show authentication Services and Levels)\n") ;
    fprintf(stderr, "\t  -t (do NOT use authentication)\n");
    exit(1);
}


void  main(int argc, char * argv[])
{
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;
    BOOL  fAuthen = TRUE ;
    BOOL  fRegister = TRUE ;
    BOOL  fImpersonate = TRUE ;
    BOOL  fKerbDelegation = FALSE ;
    BOOL  fLocalRpc = FALSE ;
    ULONG ulAuthnService = RPC_C_AUTHN_NONE ;
    ULONG ulAuthnLevel  = RPC_C_AUTHN_LEVEL_NONE ;
    ULONG ulIterations = 1 ;
    LPUSTR pszProtocol =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint =  ENDPOINT_TCP ;
    LPUSTR pszOption   =  OPTIONS_TCP ;
    LPUSTR pszServerName = NULL ;
    LPUSTR pszPrincipalName = NULL ;

    for ( int i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (tolower(*(argv[i]+1)))
            {
            case 'a':
                sscanf(argv[++i], "%lu", &ulAuthnService) ;
                break ;

            case 'c':
                sscanf(argv[++i], "%lu", &ulIterations) ;
                break ;

            case 'd':
                fKerbDelegation = TRUE ;
                break ;

            case 'i':
                fImpersonate = FALSE ;
                break ;

            case 'l':
                sscanf(argv[++i], "%lu", &ulAuthnLevel) ;
                break ;

            case 'n':
                pszServerName = (LPUSTR) argv[++i] ;
                break ;

            case 'o':
                fLocalRpc = TRUE ;
                pszProtocol =  PROTOSEQ_LOCAL ;
                pszEndpoint =  ENDPOINT_LOCAL ;
                pszOption   =  OPTIONS_LOCAL ;
                break ;

            case 'p':
                pszPrincipalName = (LPUSTR) argv[++i] ;
                break ;

            case 's':
                printf(x_szAuthnSrvConstants) ;
                printf(x_szAuthnLvlConstants) ;
                return ;

            case 't':
                fAuthen = FALSE ;
                break ;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    if (fLocalRpc)
    {
        pszServerName = NULL ;
    }
    else if (!pszServerName)
    {
        printf("\n\tERROR: you must specify the server\n\n") ;
        Usage(argv[0]);
        return ;
    }

    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (pszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (pszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszOptions[ 512 ] ;
    mbstowcs( wszOptions,
              (char*) (const_cast<unsigned char*> (pszOption)),
              sizeof(wszOptions)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] = {0} ;
    if (pszServerName)
    {
        mbstowcs( wszServerName,
                  (char*) (const_cast<unsigned char*> (pszServerName)),
                  sizeof(wszServerName)/sizeof(WCHAR)) ;
    }

    WCHAR wszPrincipalName[ 512 ] = {0} ;
    if (pszPrincipalName)
    {
        mbstowcs( wszPrincipalName,
                  (char*) (const_cast<unsigned char*> (pszPrincipalName)),
                  sizeof(wszPrincipalName)/sizeof(WCHAR)) ;
    }

    ULONG ul = 0 ;
    for ( i = 0 ; i < (int) ulIterations ; i++ )
    {
        ul = RunRpcTest( i,
                         wszProtocol,
                         wszServerName,
                         wszEndpoint,
                         wszOptions,
                         wszPrincipalName,
                         ulAuthnService,
                         ulAuthnLevel,
                         fImpersonate,
                         fAuthen,
                         fKerbDelegation ) ;
        if (ul != 0)
        {
            //
            // non-0 is an error.
            //
            break ;
        }
    }

    exit(ul) ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\hauthen\hauthens.cpp ===
//
// file:  hauthens.cpp
//
#include "hauthen.h"
#include "authni.h"
#include "sidtext.h"

const char  x_szAuthnConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_NONE          0\n"
                      "\t#define RPC_C_AUTHN_DCE_PRIVATE   1\n"
                      "\t#define RPC_C_AUTHN_DCE_PUBLIC    2\n"
                      "\t#define RPC_C_AUTHN_DEC_PUBLIC    4\n"
                      "\t#define RPC_C_AUTHN_GSS_NEGOTIATE 9\n"
                      "\t#define RPC_C_AUTHN_WINNT        10\n"
                      "\t#define RPC_C_AUTHN_GSS_SCHANNEL 14\n"
                      "\t#define RPC_C_AUTHN_GSS_KERBEROS 16\n"
                      "\t#define RPC_C_AUTHN_MSN          17\n"
                      "\t#define RPC_C_AUTHN_DPA          18\n"
                      "\t#define RPC_C_AUTHN_MQ          100\n"
                      "\t#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL\n" } ;

struct ThreadData
{
    HANDLE hAccessToken;
    BOOL   fSetToken ;
} ;

//+---------------------------
//
//  void ShowThreadUser()
//
//+---------------------------

void ShowThreadUser()
{
   ULONG ulErr = 0 ;
   HANDLE hToken = NULL ;

   if (OpenThreadToken( GetCurrentThread(),
                        TOKEN_QUERY,
                        FALSE,
                        &hToken))
   {
      TCHAR tuBuf[128] ;
      TOKEN_USER *ptu = (TOKEN_USER*) tuBuf ;
      DWORD  dwSize ;

      if (GetTokenInformation( hToken,
                               TokenUser,
                               ptu,
                               sizeof(tuBuf),
                               &dwSize ))
      {
         DWORD dwASize = 1024 ;
         DWORD dwDSize = 1024 ;
         TCHAR szAccount[ 1024 ] = {0} ;
         TCHAR szDomain[ 1024 ] = {0} ;
         SID_NAME_USE su ;

         SID *pSid = (SID*) ptu->User.Sid ;
         if (LookupAccountSid( NULL,
                               pSid,
                               szAccount,
                               &dwASize,
                               szDomain,
                               &dwDSize,
                               &su ))
         {
            DBG_PRINT_INFO((TEXT(
                "LookupAccountSid(): Account- %s, Domain- %s"),
                                                  szAccount, szDomain)) ;
         }
         else
         {
            ulErr = GetLastError() ;
            DBG_PRINT_ERROR((
                       TEXT("LookupAccountSid failed. err- %ldt"), ulErr)) ;
         }

         TCHAR  tBuf[ 256 ] ;
         DWORD  dwBufferLen = 256 ;
         BOOL fText = GetTextualSid( pSid,
                                     tBuf,
                                     &dwBufferLen ) ;
         DBG_PRINT_INFO((TEXT("sid- %s"), tBuf)) ;
      }
      else
      {
         ulErr = GetLastError() ;
         DBG_PRINT_ERROR((TEXT(
            "GetTokenInformation failed. err- %lut, size- %ldt"),
                                                      ulErr, dwSize )) ;
      }
   }
   else
   {
      ulErr = GetLastError() ;
      if (ulErr == ERROR_NO_TOKEN)
      {
        DBG_PRINT_ERROR((TEXT(
               "OpenThreadToken() failed, thread does not have a token"))) ;
      }
      else
      {
        DBG_PRINT_ERROR((TEXT(
                          "OpenThreadToken() failed, err- %lut"), ulErr)) ;
      }
   }

    if (hToken)
    {
        CloseHandle(hToken) ;
    }
}

//+-------------------------
//
//  ULONG WhoCalledUs()
//
//+-------------------------

ULONG WhoCalledUs()
{
   ULONG ulErr = 0 ;
   RPC_STATUS status ;

   status = RpcImpersonateClient(NULL) ;
   DBG_PRINT_INFO((TEXT("RpcImpersonateClient() return %ldt"), status)) ;
   if (status != RPC_S_OK)
   {
      return status ;
   }

    ShowThreadUser() ;

    status = RpcRevertToSelf() ;
    DBG_PRINT_INFO((TEXT("RpcRevertToSelf() return %ldt"), status )) ;
    if (status != RPC_S_OK)
    {
       return status ;
    }

    return ulErr ;
}

//+----------------------------
//
//  ULONG RemoteFunction()
//
//+----------------------------

ULONG RemoteFunction( handle_t       hBind,
                      unsigned long  fImpersonate )
{
    ULONG status = 0 ;
    DBG_PRINT_INFO((TEXT("In RemoteFunction()"))) ;
    if (fImpersonate)
    {
        status = WhoCalledUs() ;
    }
    return status  ;
}

//+-----------------------------
//
//  main() + Usage()
//
//+-----------------------------

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, "\t  -a <authentication service, decimal number>\n") ;
    fprintf(stderr, "\t  -l (use local rpc, tcpip being the default)\n") ;
    fprintf(stderr, "\t  -n do NOT register authentication service\n") ;
    fprintf(stderr, "\t  -s show authentication services\n") ;
    exit(1);
}


int  main(int argc, char * argv[])
{
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;
    BOOL  fRegister = TRUE ;
    ULONG ulAuthnService = RPC_C_AUTHN_NONE ;
    LPUSTR pszProtocol = NULL ;
    LPUSTR pszProtocolTcp =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint = NULL ;
    LPUSTR pszEndpointTcp =  ENDPOINT_TCP ;

    pszProtocol = pszProtocolTcp ;
    pszEndpoint = pszEndpointTcp ;

    for ( int i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (tolower(*(argv[i]+1)))
            {
            case 'a':
                sscanf(argv[++i], "%lu", &ulAuthnService) ;
                break ;

            case 'l':
                pszProtocol = PROTOSEQ_LOCAL ;
                pszEndpoint = ENDPOINT_LOCAL ;
                break ;

            case 'n':
                fRegister = FALSE ;
                break ;

            case 's':
                printf(x_szAuthnConstants) ;
                return 0 ;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (pszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (pszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    RPC_STATUS status = RpcServerUseProtseqEp( wszProtocol,
                                               ulMaxCalls,
                                               wszEndpoint,
                                               NULL ) ;  // Security descriptor
    DBG_PRINT_INFO((TEXT("RpcServerUseProtseqEp(%s, %s) returned %lut"),
                                      wszProtocol, wszEndpoint, status)) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcServerRegisterIf( hauthen_i_v1_0_s_ifspec,
                                  NULL,    // MgrTypeUuid
                                  NULL );  // MgrEpv; null means use default
    DBG_PRINT_INFO((TEXT("RpcServerRegisterIf returned %lut"), status)) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    if (fRegister)
    {
        LPWSTR pwszPrincipalName = NULL;
        if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
            (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
        {
            //
            // kerberos needs principal name
            //
            status = RpcServerInqDefaultPrincName( ulAuthnService,
                                                  &pwszPrincipalName );
            if (status != RPC_S_OK)
            {
               DBG_PRINT_ERROR((TEXT(
                    "RpcServerInqDefaultPrincName() failed, status %lut"),
                                                                  status)) ;
               return(status);
            }
            DBG_PRINT_INFO((TEXT(
              "RpcServerInqDefaultPrincName() return %s"), pwszPrincipalName)) ;
       }

       status = RpcServerRegisterAuthInfo( pwszPrincipalName,
                                           ulAuthnService,
                                           NULL,
                                           NULL );
       DBG_PRINT_INFO((
         TEXT("RpcServerRegisterAuthInfo(Service- %lut) returned %lut"),
                                               ulAuthnService, status)) ;
        if (status != RPC_S_OK)
        {
            return status ;
        }
    }

    DBG_PRINT_INFO((TEXT("Calling RpcServerListen"))) ;
    status = RpcServerListen(ulMinCalls,
                             ulMaxCalls,
                             FALSE) ;
    DBG_PRINT_INFO((TEXT("RpcServerListen returned %lut"), status)) ;

    return 0 ;

} // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file hauthens.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\hauthen\sidtext.h ===
//
// file:  sidtext.h
//

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\client.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Client.cpp

Abstract:
	      This code sends the server request to run again specific machine		
Author:
    
	  Eitan klein (EitanK)  18-Aug-1999

Revision History:

--*/
#include "msmqbvt.h"
using namespace std;

int ClientCode (int argc, char ** argv )
{
    char    inbuf[80];
    char    outbuf[80];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = "\\\\.\\pipe\\simple";	
	string  wcsCommandLineArguments;
    
	
	//
	// Need to send the command line paramters to mqbvt 
	// Need to support those parm -r:  -s  - NT4
	// 
	CInput CommandLineArguments( argc,argv );
	wcsCommandLineArguments = "";
	if(CommandLineArguments.IsExists ("r"))
	{
		wcsCommandLineArguments += ( string )" /r:"+ CommandLineArguments["r"].c_str() + (string)" ";
	}
		
	if(CommandLineArguments.IsExists ("s"))
	{
		wcsCommandLineArguments +=  (string)" /s ";
	}
	if(CommandLineArguments.IsExists ("i"))
	{
		wcsCommandLineArguments += (string) " /i" ;
	}
	if(CommandLineArguments.IsExists ("NT4"))
	{
		wcsCommandLineArguments += (string) " /NT4" ;
	}

	if(CommandLineArguments.IsExists ("t"))
	{
		wcsCommandLineArguments += (string) " /t:" +  CommandLineArguments["t"].c_str();
	}

    strcpy( outbuf, wcsCommandLineArguments.c_str() );
	
    ret = CallNamedPipeA(lpszPipeName,
                         outbuf, sizeof(outbuf),
                         inbuf, sizeof(inbuf),
                         &bytesRead, NMPWAIT_WAIT_FOREVER);

    if (!ret) {
        MqLog("client: CallNamedPipe failed, GetLastError = %d\n", GetLastError());
        exit(1);
    }

    MqLog("client: received: %s\n", inbuf);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\encrpt.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Encrypt.cpp

Abstract:
	
	  Send / receive encrypted message to encrypted queue
		
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "MSMQBvt.h"

#include "Errorh.h"
using namespace std;




//------------------------------------------------------
// PrivateMessage::Start_test
//
// Send encrypted message using 40 and 128 bit encrypted
//


int PrivateMessage::Start_test() 
{
	
	SetThreadName(-1,"PrivateMessage - Start_test ");
	try 
	{
		
		//
		// Send Encrypted messge without body 
		//
				
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		m_DestqinfoHandle  = m_Destqinfo->Open( MQ_SEND_ACCESS,MQ_DENY_NONE );
		
		m_msg->AdminQueueInfo = m_Adminqinfo; 
		m_msg->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;

		if ( g_bDebug )
		{
			wstring wcsDestQueueLabe = m_Destqinfo->Label;
			wMqLog(L"Privq - Try to send encrypted message to :%s\n" , wcsDestQueueLabe.c_str());
		}

		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_BODY;
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Send( m_DestqinfoHandle);
		
		if (g_bDebug)
		{
			wMqLog(L"Privq - Send encrypted messages without body \n");
		}
		//
		// Send encrypted message with body 
		//

		m_msg->Body = "Test Encription With messgae body";
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_BODY;
		m_msg->Send ( m_DestqinfoHandle );
		
		if( g_bDebug )
		{
			wMqLog( L"Privq - Send encrypted messages with body \n" );
		}

		//
		// Send message without priv level need to get NACK in the admin queue
		//

		m_msg->Label = wcsNACKMessageGuid.c_str();
		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_NONE;
		m_msg->Send( m_DestqinfoHandle );
		
		if( g_bDebug )
		{
			wMqLog( L"Privq - Send without encrypt messages to encrypted queue\n");
		}

		m_DestqinfoHandle->Close();

		//-------------------------------------------------------------------------
		// Send encrypted message using 128 bit encryption 
		// This is W2K only & need to install 128 before.
		//
				
		if ( m_bUseEnhEncrypt == TRUE )
		{
			if( g_bDebug )
			{
				wMqLog( L"Privq - Send encrypt messages using 128 bit encryption \n");
			}
						
			const int c_NumOfProp=7;
			cPropVar Sprop( c_NumOfProp );

			
			wcscpy( wcszMlabel , L"Test 128 Encrypt !@#$%^&**");
			
			HANDLE hQueue;
			HRESULT rc = MQOpenQueue( m_Destqinfo->FormatName , MQ_SEND_ACCESS , MQ_DENY_NONE, &hQueue );
			ErrHandle(rc,MQ_OK,L"MQOpenqueue failed to open encrypted queue to send 128 bit encryption ");

			Sprop.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
			wstring tempString = m_Adminqinfo->FormatName;
			Sprop.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , tempString.c_str() );
			UCHAR ucTemp = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
			Sprop.AddProp( PROPID_M_ACKNOWLEDGE , VT_UI1 , &ucTemp );	
			ULONG ulTemp = MQMSG_PRIV_LEVEL_BODY_ENHANCED;
			Sprop.AddProp( PROPID_M_PRIV_LEVEL , VT_UI4, &ulTemp );
			ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
			Sprop.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

			rc = MQSendMessage( hQueue , Sprop.GetMSGPRops() , NULL );	
			ErrHandle(rc,MQ_OK,L"MQSendMessage failed to send 128 bit encrypted message" );

			Sprop.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );	
			
			rc = MQSendMessage( hQueue , Sprop.GetMSGPRops() , NULL );
			ErrHandle(rc,MQ_OK,L"MQSendMessage failed to send 128 bit encrypted message with body");
			
			rc = MQCloseQueue ( hQueue );
			ErrHandle( rc , MQ_OK , L"MQClosequeue failed" );
		}

	}
	catch( _com_error& ComErr )
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}
	
return MSMQ_BVT_SUCC;
}


//------------------------------------------------------
// PrivateMessage::CheckResult() 
// Retrive the messgae from Encrypted queue.
//
//

INT PrivateMessage::CheckResult() 
{
		//
		// Check the Admin queue for ACK / NACK messages
		//
	HRESULT rc = MQ_OK;
	try
	{
	
		map <wstring,wstring> mPrepareBeforeRecive;

		WCHAR wstrMclass[10];
		if (g_bDebug)
		{
			wMqLog (L"Privq - receive from admin queue the ACK & NACK messages\n");
		}

		mPrepareBeforeRecive[L"FormatName"]=m_wcsAdminQFormatName;
		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive from admin queue with direct formant name";
		mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
		swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;
		
		rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC ) 
		{
			wMqLog (L"Privq - can't find ACK in the admin queue (1)\n");
			return MSMQ_BVT_FAILED;
		}

		rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC ) 
		{
			wMqLog (L"Privq - can't find ACK in the admin queue (2)\n");
			return MSMQ_BVT_FAILED;
		}


		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive from admin queue with direct formant name";
		mPrepareBeforeRecive[L"M_Label"]=wcsNACKMessageGuid;

		swprintf(wstrMclass,L"%ld",MQMSG_CLASS_NACK_BAD_ENCRYPTION);
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;

		rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC ) 
		{
			wMqLog (L"Privq - can't find NACK in the admin queue \n");
			return MSMQ_BVT_FAILED;
		} 


 
	}
	catch( _com_error& ComErr )
	{
		MqLog( "Privq- Can't find ACK/NACK message" );
		return CatchComErrorHandle ( ComErr , m_testid );
	}

	try 
	{

		
		map < wstring,wstring > map_ReceiveFromQueue;
		map_ReceiveFromQueue[L"DestFormatName"] = ( wstring ) m_Destqinfo->FormatName;
		map_ReceiveFromQueue[L"mLabel"] = m_wcsGuidMessageLabel;
		// Need to check message class in the Recive need to add new input.
		if (g_bDebug)
		{
				wMqLog (L"Privq - Try to receive message from dest queue \n");
		}
		try
		{
			int iMessageInDestQueue = 2;
			if ( m_bUseEnhEncrypt == TRUE )
			{
				iMessageInDestQueue = 3;
			}
			for (int Index = 0; Index < iMessageInDestQueue ; Index ++ )
			{
				rc = RetrieveMessageFromQueueViaCom( map_ReceiveFromQueue );
				if( rc != MSMQ_BVT_SUCC )
				{
					wMqLog( L"Privq- PrivateMessage::CheckResult can't find message in the queue %d\n",Index );
					return MSMQ_BVT_FAILED;
				}
				if (g_bDebug)
				{	
					wMqLog (L"Privq - Message found. \n");			
				}
			}
		}
		catch( _com_error& ComErr )
		{
			MqLog( "Privq- Error during search of message in the queue \n" );
			return CatchComErrorHandle ( ComErr , m_testid );
		}

	}
	catch(_com_error & ComErr )
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}

	return MSMQ_BVT_SUCC;
}

void PrivateMessage::Description()
{
		MqLog ("Thread %d : Send / Receive encryption messages \n",m_testid );
}

//------------------------------------------------------------------------------
// PrivateMessage Constructor
// This prepare the test for Send / Receive message with encrypted body.
//

PrivateMessage::PrivateMessage (INT index, std :: map <std::wstring, std::wstring > TestParms):
 cTest(index), m_Destqinfo("MSMQ.MSMQQueueInfo"), m_Adminqinfo("MSMQ.MSMQQueueInfo"),m_msg("MSMQ.MSMQMessage")
{

	try 
	{	
		
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;	
		m_Destqinfo->FormatName = TestParms[L"DestFormatName"].c_str();
		m_Destqinfo->Refresh();
		m_Adminqinfo->FormatName = TestParms[L"AdminFormatName"].c_str();
		m_Adminqinfo->Refresh();
		m_wcsAdminQFormatName = TestParms[L"AdminFormatName"];
		m_bUseEnhEncrypt = FALSE;
		if ( TestParms[L"Enh_Encrypt"] ==  L"True" )
		{
			m_bUseEnhEncrypt = TRUE;
		}

		if ( g_bDebug )
		{
			wcout << L"Privq - DestQ Formatname: " << (wstring ) m_Destqinfo->FormatName <<endl;
			wcout << L"Privq - DestQ PathName: " << (wstring ) m_Destqinfo->PathName <<endl;
			wcout << L"Privq - DestQ Label: " << (wstring ) m_Destqinfo->Label <<endl;
			wcout << L"Privq - AdminQ PathName: " << (wstring ) m_Adminqinfo->PathName <<endl;
		}
		
		//
		// Create guid for the NACK message label
		// 
		
		ReturnGuidFormatName( wcsNACKMessageGuid , 0 , true);

	}
	catch ( _com_error & ComErr )
	{		
		CatchComErrorHandle ( ComErr , index );
		throw INIT_Error("Problem during construct PrivateMessage class");
	}

}

//---------------------------------------------------------------------------------------
// PrivateMessage Distractor 
// Empty
//

PrivateMessage::~PrivateMessage() 
{ 
}

//---------------------------------------------------------------------------------------
// RetrieveMessageFromQueueViaCom
// This function search for specific message in the queue with C-API function
// If the message found the function receive the message from the queue
//
// Input parameters:
//	   mRetrieveParms map that expect those keys:
//     mRetrieveParms[L"M_Label"] - Message label to search.
//     mRetrieveParms[L"FormatName"] - Queue format name.
//
// retrun value: 
// True - message found.
// false - message NOT found.
//

HRESULT RetrieveMessageFromQueueViaCom( map <wstring,wstring> & mRetrieveParms )
{
	
	BOOL bMessageFound = FALSE;
	DWORD dwTestId = 66;
	try
	{
	
		MSMQ::IMSMQQueueInfoPtr m_Destqinfo( "MSMQ.MSMQQueueInfo" );
	//	MSMQ::IMSMQMessage2Ptr m_msg( "MSMQ.MSMQMessage" );
		MSMQ::IMSMQMessagePtr m_msg( "MSMQ.MSMQMessage" );
			
		if(g_bDebug)
		{
			wMqLog (L"RetrieveMessageFromQueueViaCom - DestQueueFormatName: %s\n",mRetrieveParms[L"DestFormatName"].c_str());
		}

		m_Destqinfo->FormatName = mRetrieveParms[L"DestFormatName"].c_str();
		wstring wcsQueueuFormatName = mRetrieveParms[L"DestFormatName"];
		if ( wcsstr(wcsQueueuFormatName.c_str(),L"DIRECT=") == NULL )
		{
			m_Destqinfo->Refresh();
		}

		wstring wcsGuidLabel = mRetrieveParms[L"mLabel"];
		
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		m_DestqinfoHandle = m_Destqinfo->Open(MQ_RECEIVE_ACCESS,MQ_DENY_NONE);

		_variant_t timeout( long(BVT_RECEIVE_TIMEOUT) );
		
		
		// Convert string to DWORD.

		wstring wcsTemp = mRetrieveParms[L"TestId"];
		swscanf( wcsTemp.c_str() , L"%d", & dwTestId );
		
		//
		// Test twice PeekCurrent
		// 

		m_msg = m_DestqinfoHandle ->PeekCurrent( &vtMissing , &vtMissing , &timeout );
		BOOL bFirstTime = TRUE;
		while ( m_msg != NULL && ! bMessageFound )
		{
			try 
			{
				if ( bFirstTime )
				{
					m_msg = m_DestqinfoHandle -> PeekCurrent( &vtMissing , &vtMissing , &timeout );
					bFirstTime = FALSE;
				}
				else
				{
					m_msg = m_DestqinfoHandle -> PeekNext( &vtMissing , &vtMissing , &timeout);
				}
		
				if(  m_msg != NULL && ! wcscmp( m_msg->Label , wcsGuidLabel.c_str() ) ) 
				{	
						//
						// Message found need to remove message from the queue.
						//
						m_msg = m_DestqinfoHandle -> ReceiveCurrent( &vtMissing , &vtMissing , &vtMissing , &timeout);
						if ( wcscmp( m_msg->Label , wcsGuidLabel.c_str() ) ) 
						{
							printf ("Mqbvt received messgae that is not the expected one !\n");
							return MSMQ_BVT_FAILED;
						}

						bMessageFound = TRUE ;			
				}
		
				
			}
			catch( _com_error & ComErr )
			{
				if ( ComErr.Error() != MQ_ERROR_IO_TIMEOUT )
				{
					wMqLog(L"RetrieveMessageFromQueueViaCom catch unexpected error :\n");
					return CatchComErrorHandle( ComErr , dwTestId );
				}
				
			}

		}
		
		if( bMessageFound == FALSE )
		{
			wMqLog(L"RetrieveMessageFromQueueViaCom: Can't locate messages in queue \n");
			return MSMQ_BVT_FAILED;
		}
		
		if( _winmajor == Win2K && mRetrieveParms[L"TransBaoundery"] != L"" ) 
		{
			MSMQ::IMSMQMessage2Ptr m_msg2( "MSMQ.MSMQMessage" );
			m_msg2=m_msg;
			// 1 message first &last
			if( m_msg2->IsFirstInTransaction != 0 )
			{
				mRetrieveParms[L"TransBoundary"] = L"First";
			}
			else if( m_msg2->IsLastInTransaction != 0)
			{
				mRetrieveParms[L"TransBoundary"] = L"Last";
			}
			else
			{
			
				mRetrieveParms[L"TransBoundary"]=g_wcsEmptyString;
			}
		}
		if( mRetrieveParms[L"mBody"] == g_wcsEmptyString)
		{
			_bstr_t  bstrBody = m_msg->Body;
			mRetrieveParms[L"mBody"] = (wstring) bstrBody;
		}

		m_DestqinfoHandle->Close();
	}
	catch( _com_error & ComErr )
	{
			wMqLog(L"RetrieveMessageFromQueueViaCom catch unexpected error !\n" );
			return CatchComErrorHandle( ComErr , 66 );
	}
	return bMessageFound ? MSMQ_BVT_SUCC : MSMQ_BVT_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\handleer.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: HandleEr.cpp

Abstract:

	  Log and error handle function 
	
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "MSMQBvt.h"
using namespace std;

#include "Errorh.h"

extern bool g_bRaiseASSERTOnError;
// ------------------------------------------------------------
// INIT_Error::INIT_Error Constructor
// Create the error message into the member variable 
// Input parmeter:
// wcsDescription - Error description.
//


INIT_Error::INIT_Error (const CHAR * wcsDescription) :m_wcsErrorMessages( wcsDescription )
{
} 


//----------------------------------------------------------------------------
// Print to standard error the error description that contain the line & filename 
// 
// Input parmeters:
// wcsMessage - Discription for the error 
// rc - HRESULT value for the related error.
// File - File name from __FILE__ .
// iline - Line number __LINE__ .
//


void ErrorHandleFunction (wstring wcsMessage,HRESULT rc,const CHAR * csFileName ,const INT iLine)
{

	UNREFERENCED_PARAMETER(iLine);
	wMqLog(L"%s rc=0x%x",wcsMessage.c_str(),rc);
	CHAR token[]= "\\";
	CHAR  * pwcString;
	
	P < CHAR > pcsFile = (CHAR * ) malloc( sizeof( CHAR  ) * ( strlen(csFileName) + 1 ) );	
	if ( ! pcsFile )
	{
		MqLog( "malloc failed to allocate memory for error message ! (Exit without error )\n" );
		return ;
	}


	P < CHAR > pcsTemp = ( CHAR * ) malloc( sizeof( CHAR ) * ( strlen(csFileName) + 1 ) );
	if ( ! pcsTemp )
	{
		MqLog("malloc failed to allocate memory for error message ! (Exit without error )\n");
		return ;
	}
	
	//
	// Remove full path name from the __FILE__ value.
	// i.e. \\eitan5\rootc\msmq\src\Init.cpp --> Init.cpp.
	// 

	strcpy( pcsFile , csFileName);
	pwcString = pcsFile;
	CHAR * csFilePos = pcsFile;

	while( pwcString != NULL && csFileName )
	{

		 strcpy( pcsTemp , pwcString);
		 pwcString = strtok(csFilePos , token);
		 csFilePos = NULL;
	}
	MqLog (" Filename: %s\n",pcsTemp);	
	if(g_bRaiseASSERTOnError == false)
	{
		MessageBoxW(NULL,wcsMessage.c_str(),L"Mqbvt ",MB_SETFOREGROUND|MB_OK);
	}
}

//----------------------------------------------------------------------------------------
// CatchComErrorHandle retrieve information from _com_error object
// And Print the error message .
// Input parmeters:
// ComErr - COM error object that cached.
// iTestID - Test Identifier.
//
// Output parmeter:
// MSMQ_BVT_FAILED  only.


INT CatchComErrorHandle ( _com_error & ComErr , int  iTestID)
{

	_bstr_t  bStr = ( ComErr.Description() ); 
	MqLog("Thread %d got error: 0x%x\n",iTestID,ComErr.Error());
	// Check if description is exist for the related error value
	const WCHAR * pbStrString = (WCHAR * ) bStr;
	if(pbStrString != NULL &&  *pbStrString )
	{
		if (!wcscmp (pbStrString,L""))
		{
			MqLog("Bug this com_error error is without description\n");
		}
		wMqLog(L"%s\n",pbStrString);
	}

	return MSMQ_BVT_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\auth.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	
	This is the Test that checks authenticate messages with or without authenticate queue
	This is part of the Security.
		
Author:
    
	  Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning( disable : 4786 )

#include "Msmqbvt.h"
using namespace std;
extern BOOL g_bRunOnWhistler;
	
extern DWORD TestResult[Total_Tests];
INT 
cTest::ThreadMain()
/*++

Function Description:

    Function to run as a speparete thread
    

Arguments:
    None
Return code:
    return MSMQ_BVT_SUCC / MSMQ_BVT_FAILED


--*/
{
	bool fOleInit=true;
	int res;
	
	HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	if ( FAILED (hr) )
	{
			fOleInit=false;
	}
	{
		Description();
		res =  Start_test();
		if( res == MSMQ_BVT_SUCC )
		{
			res = CheckResult();
		}
	}
	if( fOleInit )
	{
		CoUninitialize();
	}
	TestResult[m_testid] = res;
	return res;
}


wstring GetJPNProplematicChars()

/*++
	Function Description:
	 This functions return problematic JPN charcters
		//add buffer for JPN DBCS codes after GUID 
		//0x3042 : Double byte Hiragana
		//0x30A2 : Double byte Katakana
		//0x4FFF,0x5000: normal DBCS Kanji
		//0x8868 : Trailing byte contains symbolic char
		//0x9670 : Trailing byte contains alphabet char
		//0x2121 : Trailing byte contains leading byte char
		//0x3231 : n:1 conversion between ANSI and Unicode
		//0x3305 : JPN char only in Unicode
		//0x30FC : JPN char poteintial issue w CompareString
		//0xFF76, 0xFF9E : single byte Katakana
	Arguments:
		None
	Return code:
		wstring that contains JPN characters.
--*/
	
{

		
		WORD wDbcs[] = {0x3042,0x30A2,0x4FFF,0x5000,0x8868,0x9670,0x2121,0x3231,0x3305,0x30FC,0xFF76,0xFF9E,0x0000};
		wstring wcsTemp = L"{";
		wcsTemp += wDbcs;
		wcsTemp += L"}";
		return wcsTemp;
}

//--------------------------------------------------------------
//
// cTest constructor call from every tests 
// The constructor create common GUID for all the tests
//

cTest::cTest(INT index ) : m_testid( index ) 
{

	UCHAR * csMessageGuid;
	UUID gAllMessageGuid;
	if (UuidCreate( & gAllMessageGuid ) != RPC_S_OK )
	{
		MqLog("cTest::cTest UUIDCreateFailed to Create GUID \n");
		throw INIT_Error("cTest failed to create GUID");
	}	
	const int iMAX_GUID_LEN = MAX_GUID;
	WCHAR wcsMessageGUID[iMAX_GUID_LEN + 1];
	RPC_STATUS  hr = UuidToString( & gAllMessageGuid , & csMessageGuid );
	if( hr != RPC_S_OK )
	{
		throw INIT_Error("cTest failed to create GUID");
	}
	MultiByteToWideChar(CP_ACP,0,(char *)csMessageGuid,-1,wcsMessageGUID,iMAX_GUID_LEN);
	RpcStringFree(&csMessageGuid);
	m_wcsGuidMessageLabel = wcsMessageGUID + GetJPNProplematicChars();
	m_testid ++; 

}; 


//------------------------------------------------------
//
//


void CheckNotAuthQueueWITHAuthMessage::Description()
{
	MqLog("Thread %d Not used \n");
}

//------------------------------------------------
// SecCheackAuthMess::~SecCheackAuthMess () Empty
//

SecCheackAuthMess::~SecCheackAuthMess ()
{
 
}

//-------------------------------------------------------------------
// CheckNotAuthQueueWITHAuthMessage 
// Bugbug need to add this tests to mqbvt

CheckNotAuthQueueWITHAuthMessage::
CheckNotAuthQueueWITHAuthMessage ( 	int iTestId , std::map < std::wstring , std::wstring > & Tparms ) 
: SecCheackAuthMess (iTestId , Tparms ) 
{
	try 
	{	
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;	
		m_Destqinfo->Refresh();	
		m_Destqinfo->Label = "SecurityCheackAuthMessWithNOTAuthQueue";
		m_Destqinfo->Authenticate=MQ_AUTHENTICATE_NONE; 
		m_Destqinfo->Update(); 
		m_Adminqinfo->Refresh();
		m_Adminqinfo->Label = "SecCheackAuthMess_AdminQ";
		m_Adminqinfo->Update();
	}
	catch (_com_error & ComErr)
	{	
	
		CatchComErrorHandle ( ComErr,iTestId );
		throw INIT_Error("Error during construct CheckNotAuthQueueWITHAuthMessage");
	}
}



CheackAuthQueueWithOutAuthMessgae::CheackAuthQueueWithOutAuthMessgae(int i , std :: map < std ::  wstring  ,std :: wstring> & Tparms) :SecCheackAuthMess (i , Tparms)
{
		m_ResualtVal=MQMSG_CLASS_NACK_BAD_SIGNATURE;
} 

// -------------------------------------------------------------------------
// CheackAuthQueueWithOutAuthMessgae::Start_test
// Send express message with authticate to authnticate queue.
//

int CheackAuthQueueWithOutAuthMessgae::Start_test()
{

	SetThreadName(-1,"CheackAuthQueueWithOutAuthMessgae - Start_test ");
	try 
	{
		
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg( "MSMQ.MSMQMessage" );
		m_DestqinfoHandle=m_Destqinfo->Open ( MQ_SEND_ACCESS,MQ_DENY_NONE );	
		m_msg->Label = "Test_Auth_Messgae_NACKExpected";
		m_msg->AdminQueueInfo=m_Adminqinfo; 
		m_msg->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
		m_msg->Send ( m_DestqinfoHandle );
		m_DestqinfoHandle->Close();

	}
	catch (_com_error & ComErr)
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}
return MSMQ_BVT_SUCC;
}

//------------------------------------------------------------------
// SecCheackAuthMess :: Description
// This test send authenticate message to authenticate queue
//

void SecCheackAuthMess::Description()
{
	WCHAR * p = L"";
	if( m_testid == 26 )
	{
		p = L"(HTTP)";
	}
	else if ( m_testid == 28 )
	{
		p = L"(HTTPS)";
	}
	wMqLog(L"Thread %d : Send / Receive Authenticate messages %s\n", m_testid,p);
}

//------------------------------------------------------------------
// SecCheackAuthMess :: CheckResult
// Test receive message from dest queue.
//


INT SecCheackAuthMess::CheckResult() 
{

	map <wstring,wstring> mPrepareBeforeRecive;
	HRESULT rc = MQ_OK;
	int iNumberOfExpectedMessage = cNumerOfMessages - 1 + ( g_bRunOnWhistler == TRUE ) ? 2:0;
	WCHAR wstrMclass[10];
	if(g_bDebug)
	{
		MqLog("Verify that ACK reached to queue\n");
	}
	swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
	mPrepareBeforeRecive[L"MClass"]= wstrMclass;
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	mPrepareBeforeRecive[L"FormatName"] = m_Adminqinfo->FormatName;
	mPrepareBeforeRecive[L"DebugInfromation"] = L"Receive message from dest queue"; 	
	for (INT Index=0; Index < iNumberOfExpectedMessage ; Index++ )
	{
		
		if( Index == cNumerOfMessages - 1  )
		{
			mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel2;
			swprintf(wstrMclass,L"%d",MQMSG_CLASS_NACK_BAD_SIGNATURE);
			mPrepareBeforeRecive[L"MClass"]= wstrMclass;
			if ( m_bUseHttpFormatName )
			{ // No need to check NACK with http format name
				break;
			}
		}
		rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if( rc != MSMQ_BVT_SUCC )
		{
			wMqLog (L"Admin message was not found in the destination queue. (%d)\n",Index);
			return MSMQ_BVT_FAILED;
		}
	}

	if (g_bDebug)
	{
		MqLog("Verify that message reached to queue\n");
	}
	if( g_bDebug && m_bNeedToRefresh )
	{	
		m_Destqinfo->Refresh();
		_bstr_t  bStr =m_Destqinfo->PathName;
		wMqLog( L"Try to receive message from queue: %s \n" , bStr );
	}
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	mPrepareBeforeRecive[L"FormatName"] = m_Destqinfo->FormatName;
	mPrepareBeforeRecive[L"DebugInfromation"] = L"Receive message from dest queue"; 	
	for( INT Index=0; Index < iNumberOfExpectedMessage ; Index ++ )
	{
		rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if(rc != MSMQ_BVT_SUCC)
		{
			wMqLog (L"Message was not found in the destination queue. (%d)\n",Index);
			return MSMQ_BVT_FAILED;
		}
	}
	
	
return MSMQ_BVT_SUCC;
}



//------------------------------------------------------------------
// SecCheackAuthMess :: Start_test
// Send authenticate message to authenticate queue 
// ask for ACK that message reach to queue.
// send auth message with handle that get from MQGetSecurityContext.
//

#define NUMOF_PROPS (8) // This is needed only for this test
int SecCheackAuthMess::Start_test() 
{
	SetThreadName(-1,"SecCheackAuthMess - Start_test ");
	try 
	{
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg;

		m_msg.CreateInstance("MSMQ.MSMQMessage");
		m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);
		if(g_bDebug)
		{
			MqLog("Send authenticate message to queue \n");
		}
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->Body = m_wcsGuidMessageLabel.c_str();
		m_msg->AdminQueueInfo = m_Adminqinfo; 
		m_msg->Ack = (m_bUseHttpFormatName) ? MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL:MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
		m_msg->AuthLevel = MQMSG_AUTH_LEVEL_ALWAYS; // Send Auth Message
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Send ( m_DestqinfoHandle );
		if(g_bRunOnWhistler)
		{
			m_msg->AuthLevel = MQMSG_AUTH_LEVEL_SIG20; // Send Auth Message
			m_msg->Send ( m_DestqinfoHandle );
			m_msg->AuthLevel = MQMSG_AUTH_LEVEL_SIG30; // Send Auth Message
			m_msg->Send ( m_DestqinfoHandle );
		}
		if( g_bDebug )
		{
			wprintf(L"Succeded to send auth message to queue:%s\n",m_DestQueueInfoPathName.c_str());
		}
		if(!m_bUseHttpFormatName) 
		{
		    m_msg->Label = m_wcsGuidMessageLabel2.c_str();
 		    m_msg->Body = m_wcsGuidMessageLabel2.c_str();
		    m_msg->AuthLevel = MQMSG_AUTH_LEVEL_NONE; // Send Auth Message
 		    m_msg->Send ( m_DestqinfoHandle );
 		    if( g_bDebug )
		    {
				wMqLog(L"Succeded to send none - auth message to queue:%s\n",m_DestQueueInfoPathName.c_str());
		    }
		}
		m_DestqinfoHandle->Close();
		HANDLE hSecCtx = NULL ;
		HRESULT hr;
        
		//Call to get Internal certificate Conext
		if(g_bDebug)
		{
			MqLog("call-> MQGetSecurityContext(NULL,,)\n");
		}

        hr = MQGetSecurityContext( NULL,
                                   0,
                                   &hSecCtx );
        
		ErrHandle( hr ,MQ_OK,L"MQGetSecurityContext failed ");
		WCHAR wszFormatName[ BVT_MAX_FORMATNAME_LENGTH+1 ]={0};
		WCHAR wszAdminQFormatName[BVT_MAX_FORMATNAME_LENGTH+1]={0};
		DWORD dwAdminQFormatNamelength = BVT_MAX_FORMATNAME_LENGTH;
		DWORD dwFormatNamelength = BVT_MAX_FORMATNAME_LENGTH;
		MSGPROPID     aMsgPropId[NUMOF_PROPS]={0};
		MQPROPVARIANT aMsgPropVar[NUMOF_PROPS]={0};
		HRESULT aResult[NUMOF_PROPS]={0};

		// Convert Form COM To C API By Take the Queue Format Name
		// From now using only C API .
		if( ! m_bUseHttpFormatName)
		{
			hr = MQPathNameToFormatName( m_Destqinfo->PathName,wszFormatName,&dwFormatNamelength );
			ErrHandle(hr,MQ_OK,L"MQPathNameToFormatName failed to retrive dest queue");

			hr = MQPathNameToFormatName( m_Adminqinfo->PathName,wszAdminQFormatName,&dwAdminQFormatNamelength );
			ErrHandle(hr,MQ_OK,L"MQPathNameToFormatName failed to retrive admin queue ");
		}
		else
		{
				wcscpy(wszFormatName,(WCHAR * ) m_Destqinfo->FormatName);
				wcscpy(wszAdminQFormatName,(WCHAR * ) m_Adminqinfo->FormatName);
		}
		HANDLE hQueue;
		hr = MQOpenQueue( wszFormatName, MQ_SEND_ACCESS, MQ_DENY_NONE, &hQueue );
		ErrHandle(hr,MQ_OK,L"MQOpenQueue failed to open authenticate queue");
		
		if( g_bDebug )
		{
			wMqLog(L"Succeded to send authenticated message with MQGetSecurityContext to queue:%s\n",m_DestQueueInfoPathName.c_str());
		}

		//------------------------------------------
		// Send message using security context.
		//

		ULONG uIndex = 0 ;

		aMsgPropId[ uIndex ] = PROPID_M_SECURITY_CONTEXT ;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = PtrToLong( hSecCtx );
		uIndex++ ; 
		 
		 
		aMsgPropId [ uIndex ] = PROPID_M_BODY ;
	    aMsgPropVar[ uIndex ].vt = VT_VECTOR|VT_UI1;         
		aMsgPropVar[ uIndex ].caub.pElems = (UCHAR *) m_wcsGuidMessageLabel.c_str();
		aMsgPropVar[ uIndex ].caub.cElems = ( (ULONG)(wcslen (m_wcsGuidMessageLabel.c_str()))) * sizeof (WCHAR) ;
        uIndex++;

		 		 
		aMsgPropId [ uIndex ] = PROPID_M_LABEL ;
	    aMsgPropVar[ uIndex ].vt = VT_LPWSTR;
		aMsgPropVar[ uIndex ].pwszVal =(USHORT *) m_wcsGuidMessageLabel.c_str() ;
        uIndex++;

		aMsgPropId [ uIndex ] = PROPID_M_ADMIN_QUEUE ;
		aMsgPropVar[ uIndex ].vt = VT_LPWSTR;
		aMsgPropVar[ uIndex ].pwszVal = wszAdminQFormatName; //Admin Queue Format Name
		uIndex++;

		aMsgPropId [ uIndex ] = PROPID_M_ACKNOWLEDGE ;
		aMsgPropVar[ uIndex ].vt = VT_UI1;
		aMsgPropVar[ uIndex ].bVal = (UCHAR)((m_bUseHttpFormatName) ? MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL:MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE);
		uIndex++ ; 
		
	    aMsgPropId [ uIndex ] = PROPID_M_AUTH_LEVEL;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = MQMSG_AUTH_LEVEL_ALWAYS;	
        uIndex++ ;  

		aMsgPropId [ uIndex ] = PROPID_M_TIME_TO_BE_RECEIVED;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = MQBVT_MAX_TIME_TO_BE_RECEIVED;	
        uIndex++ ;  
			
		MQMSGPROPS MsgProps = { uIndex, aMsgPropId, aMsgPropVar, aResult};
		hr = MQSendMessage( hQueue, &MsgProps, NULL);
		MQFreeSecurityContext(hSecCtx);
		if( FAILED(hr)) 
		{
			MqLog ("Error can't send authenticated message rc=0x%x\n",hr);
			return MSMQ_BVT_FAILED;
		}
	
	}
	
	catch(_com_error & ComErr)
	{	
		return CatchComErrorHandle ( ComErr , m_testid);
	}
return MSMQ_BVT_SUCC;
}

SecCheackAuthMess::SecCheackAuthMess( INT iTestid ,   map <wstring,wstring> TestParms ) 
: cTest(iTestid) , m_Destqinfo("MSMQ.MSMQQueueInfo") , m_Adminqinfo("MSMQ.MSMQQueueInfo") 
, cNumerOfMessages(3),m_bUseHttpFormatName(TRUE)
{
	try 
	{	
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;
		m_DestqinfoFormatName = TestParms [L"DestFormatName"];
		m_Destqinfo->FormatName = m_DestqinfoFormatName.c_str();
		m_bNeedToRefresh = TestParms [L"FormatNameType"] == L"Http" ? 0:1 ;
		m_AdminqinfoFormatName = TestParms [L"AdminFormatName"];
		m_Adminqinfo->FormatName = m_AdminqinfoFormatName.c_str() ;
		if( m_bNeedToRefresh )
		{
			//
			// No need to refresh Qinfo when used with HTTP format name
			//
			m_bUseHttpFormatName = FALSE;
			m_Destqinfo -> Refresh();		
			m_Adminqinfo ->Refresh(); 
		}
		m_DestQueueInfoPathName = TestParms[L"DestQueuePathName"];
		ReturnGuidFormatName( m_wcsGuidMessageLabel2 , 0 , true);
 	}
	catch( _com_error & ComErr )
	{	
		CatchComErrorHandle ( ComErr , m_testid);
		wMqLog(L"SecCheackAuthMess::SecCheackAuthMess failed with error 0x%x\n",ComErr.Error());
		throw INIT_Error("SecCheackAuthMess: constructor refresh queue parameters failed");
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\imp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	
		
Author:
	Written by:Gilsh@microsoft.com
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning( push, 3 )	
#include <sstream>
#include <iostream>
#pragma warning( pop ) 	

#include "msmqbvt.h"
using namespace std;
#include <mq.h>
#include <rpc.h>
#include "sec.h"
#include "ptrs.h"
#pragma warning( disable: 4786)


//
// Auto handle class
//

inline Handle_t::Handle_t(HANDLE handle):m_handle(handle)
{
 
}
inline HANDLE Handle_t::get()
{
	return m_handle;
}

inline Handle_t::~Handle_t()
{
	CloseHandle(m_handle);
}




// impersonate with given tokem
inline Impersonate_t::Impersonate_t(HANDLE hToken):m_impersonated(true)
{
   bool bResult=(ImpersonateLoggedOnUser(hToken)==TRUE);
   if(bResult == FALSE)
   {
	   throw INIT_Error("could not impersonate");
   }
}

//does impersonation for the calling thread

// 
// End of impersonate class
//


inline void LoadCurrentThreadHive( wstring & szAccoutName )
{
   std::basic_string<unsigned char> sid=GetCurrentThreadSid( szAccoutName );
   LoadHiveForSid(sid);
}

inline std::basic_string<unsigned char> GetCurrentThreadSid( wstring & wcsAccountName )
{
	//WCHAR szAccountName[]=L"middleeast\\v-ofiry";
	//WCHAR pwszDomainController[]=L"middleeast";


	BYTE abSidBuff[128];
    PSID pSid = (PSID)abSidBuff;
    DWORD dwSidBuffSize = sizeof(abSidBuff);
    WCHAR szRefDomain[128];
    DWORD dwRefDomainSize = sizeof(szRefDomain) / sizeof(WCHAR);
    SID_NAME_USE eUse;
    
	// WCHAR szTextSid[256];
    // DWORD szTextSidBuffSize = sizeof(szTextSid);


	
	if (!LookupAccountNameW( NULL,
                                wcsAccountName.c_str(),
                                pSid,
                                &dwSidBuffSize,
                                szRefDomain,
                                &dwRefDomainSize,
                                &eUse ))
        {
            MqLog("Failed in LookupAccountName(%S), error = %lut\n",
                                          wcsAccountName.c_str(), GetLastError()) ;
        }

 /* HANDLE  hToken;
  if(!OpenThreadToken(GetCurrentThread(),
	                  TOKEN_QUERY,
					  TRUE,
					  &hToken))
  {
     if(GetLastError() != ERROR_NO_TOKEN)
     {
	  
		 throw INIT_Error("could not get thread token");     
       
	 }

     if(!OpenProcessToken(GetCurrentProcess(),
	                     TOKEN_QUERY,
					      &hToken))
	 {
	   
		 throw INIT_Error("could not get thread token");     
       
     }
  }
  Handle_t Token(hToken);
  DWORD cbBuf=0; 	  
  BOOL b=GetTokenInformation(hToken,
	                  TokenUser,
					  NULL,
					  0,
					  &cbBuf);

  assert(b == 0);

  SPTR<BYTE> rgbTokenUserSid(new(BYTE[cbBuf]));
  b=GetTokenInformation(Token.get(),
                        TokenUser,
  			            rgbTokenUserSid.get(),
					    cbBuf,
					    &cbBuf);
  


  if(b == FALSE)
  {
	   throw INIT_Error("could not token information");   
  }
*/
//  TOKEN_USER* ptokenuser=reinterpret_cast<TOKEN_USER*>(rgbTokenUserSid.get());
  //PSID sid = ptokenuser->User.Sid;

  if(IsValidSid(pSid) == FALSE)
  {
	throw INIT_Error("sid is invalid");
  }
  
	
  DWORD sidlen=GetLengthSid(pSid);
  std::basic_string <unsigned char> retsid(reinterpret_cast<unsigned char*>(pSid),sidlen); 
  return retsid;
}


inline void UnloadHiveForSid(const std::basic_string<unsigned char>& sid)
{
   std::string textsid=GetTextualSid((void*)sid.c_str());
   RegUnLoadKey(HKEY_USERS, textsid.c_str());    
   SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, FALSE);
}

inline void LoadHiveForSid(const std::basic_string<unsigned char>& sid)
{
  std::string textsid=GetTextualSid((void*)sid.c_str());
  HKEY hProf;

  //
  // Remark if user never do logon on that machine this key doesn't exist
  // need to Logon as user before run this tests !!
  //
  std::string reg="Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\"+textsid;
  HRESULT hr=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		                  reg.c_str(),
				          0,
				          KEY_QUERY_VALUE,
				          &hProf);

  if(hr != ERROR_SUCCESS)
  {
    
	  throw INIT_Error("You try to use user that never logon on that machine  \n");
  }
  
  DWORD dwType;
  DWORD dwProfileImagePathBuffSize=0;
  hr=RegQueryValueExA(hProf,
	                 "ProfileImagePath",
					 0,
					 &dwType,
					 NULL,
					 &dwProfileImagePathBuffSize);

  SPTR<unsigned char> szProfileImagePath( new unsigned char[dwProfileImagePathBuffSize]);

  hr=RegQueryValueExA(hProf,
	                 "ProfileImagePath",
					 0,
					 &dwType,
					 szProfileImagePath.get(),
					 &dwProfileImagePathBuffSize);

  if(hr != ERROR_SUCCESS)
  {
    RegCloseKey(hProf);
    throw INIT_Error("");
  }
  RegCloseKey(hProf);

  char szExpandProfileImagePath[MAX_PATH];
  if(!ExpandEnvironmentStringsA((char*)szProfileImagePath.get(),
	                         szExpandProfileImagePath,
						     sizeof(szExpandProfileImagePath)))

  {
    throw INIT_Error("");
  }
  
  std::string StrszExpandProfileImagePath=szExpandProfileImagePath+std::string("\\NTUSER.DAT");

  SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, TRUE);

  hr=RegLoadKeyA(HKEY_USERS,
	            textsid.c_str(),
				StrszExpandProfileImagePath.c_str());


  if(hr != ERROR_SUCCESS)
  {
     throw INIT_Error("");
  }
 
 SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, FALSE);
                                   

  hr=RegCloseKey(HKEY_CURRENT_USER);     
  
}

inline std::basic_string<unsigned char> GetSidFromUser(const std::string& username)
{

  
  SPTR<unsigned char> sid(NULL);
  DWORD cbSid=0;
  SPTR<unsigned char> ReferencedDomainName(NULL);
  SID_NAME_USE eUse ;
  DWORD cbReferencedDomainName=0;
  BOOL b=LookupAccountName(NULL,
	                     username.c_str(),
                         sid.get(),
                         &cbSid,
						 reinterpret_cast<char*>(ReferencedDomainName.get()),
                         &cbReferencedDomainName, 
                         &eUse);
                         


 
						 
 
 sid = SPTR<unsigned char>(new(unsigned char[cbSid]));

 

 ReferencedDomainName = SPTR<unsigned char>(new(unsigned char[cbReferencedDomainName]));



 b=LookupAccountName(NULL,
                     username.c_str(),
                     sid.get(),
                     &cbSid,
 				     reinterpret_cast<char*>(ReferencedDomainName.get()),
                     &cbReferencedDomainName, 
                     &eUse);
                         
 
 
  if(b == FALSE)
  {
    throw INIT_Error("");    
  }
  
 

  std::basic_string<unsigned char> ret(sid.get(),cbSid);

  return ret;


}


//unload current thread hive
inline void UnloadHiveForUser(const std::string & username)
{
   std::basic_string<unsigned char> sid=GetSidFromUser(username);
   UnloadHiveForSid(sid);
}

//unload current thread hive
inline void UnlLoadCurrentThreadHive( std::wstring wcsAccountName )
{
   std::basic_string<unsigned char> sid=GetCurrentThreadSid(wcsAccountName);

   //
   //  Bubgug - There is NT5 bug Need to Unloadhive after using it ..
   //
   //
  // UnloadHiveForSid(sid);
  
}

//class that load current thread hive and unload it in the destructor
class LoadCurrentThreadHive_t
{

public:
	LoadCurrentThreadHive_t( wstring & szAccoutName)
	{
	  m_szAccountName = szAccoutName;
      LoadCurrentThreadHive( m_szAccountName );
    } 
    virtual ~LoadCurrentThreadHive_t()
    {
      UnlLoadCurrentThreadHive(m_szAccountName);
    }
private:
	std::wstring m_szAccountName;

}; 

//return user name string for given user SID
inline std::string UserNameFromSid(PSID  sid)
{
  LPCTSTR lpSystemName=NULL;
  SPTR<char> Name(NULL);
  DWORD cbName=0;
  SPTR<char> ReferencedDomainName(NULL);
  DWORD cbReferencedDomainName=0;
  SID_NAME_USE peUse;
  
  BOOL b= LookupAccountSid(lpSystemName, // address of string for system name
                           sid,             // address of security identifier
                           Name.get(),          // address of string for account name
                           &cbName,       // address of size account string
                           ReferencedDomainName.get(),                // address of string for referenced domain
                           &cbReferencedDomainName, // address of size domain string
                           &peUse);// address of structure for SID type);



  Name=SPTR<char>(new(char[cbName])); 
  ReferencedDomainName=SPTR<char>(new(char[cbReferencedDomainName])); 


   b= LookupAccountSidA(lpSystemName, // address of string for system name
                           sid,             // address of security identifier
                           Name.get(),          // address of string for account name
                           &cbName,       // address of size account string
                           ReferencedDomainName.get(),                // address of string for referenced domain
                           &cbReferencedDomainName, // address of size domain string
                           &peUse);// address of structure for SID type);

  if(b == FALSE)
  {
     throw INIT_Error("");
  }

  std::string ret=std::string(ReferencedDomainName.get())+ "\\" + Name.get();

  return ret;
}

//
// This function return thread Security context 
// Needs to do impersonate as user before preform 
// MQGetSecuritycontext
// 
HANDLE FAL_GetThreadSecurityContext(Impersonate_t  & user, wstring & szAccoutName)
{
   LoadCurrentThreadHive_t hive (szAccoutName);
   HANDLE hSec;
   user.ImpersonateUser();
   
   HRESULT hr=MQGetSecurityContext(NULL,0,&hSec);
   if (hr != MQ_OK)
   {
	    throw INIT_Error("Can't Retrive the computer name");
   }

   hr=RegCloseKey(HKEY_CURRENT_USER);
   
   if(hr != ERROR_SUCCESS)
   {
    throw INIT_Error("");
   }

  return hSec;
}



//return textual string for given sid
inline std::string GetTextualSid(PSID pSid)
{
  if(!IsValidSid(pSid))
  {
    throw INIT_Error("");
  }
  PSID_IDENTIFIER_AUTHORITY psia=GetSidIdentifierAuthority(pSid);
  if(psia == NULL)
  {
    throw INIT_Error("");
  }

  DWORD dwSubAuthorities=*GetSidSubAuthorityCount(pSid);
  DWORD dwSidRev=SID_REVISION;

  std::stringstream TextualSid;
  TextualSid<<"S-"<<dwSidRev<<"-";

  if( (psia->Value[0] !=0) ||(psia->Value[1] != 0))
  {
	 TextualSid.width(2);
	 TextualSid<<std::hex<<psia->Value[0]<<psia->Value[1]<<psia->Value[2]<<psia->Value[3]<<psia->Value[4]<<psia->Value[5];	  
  }
  else
  {
	  TextualSid<<std::dec<<(psia->Value[5])+(psia->Value[4]<<8)+(psia->Value[3]<<16)+(psia->Value[2]<<24);
  }
  for(DWORD i=0;i<dwSubAuthorities;i++)
  {
    TextualSid<<std::dec<<"-"<<*GetSidSubAuthority(pSid,i);
  }

  return TextualSid.str();
}

inline
void
SetSpecificPrivilegeInThreadAccessToken(LPCTSTR lpwcsPrivType, BOOL bEnabled)
{

    HANDLE hAccessToken;
    BOOL bRet=OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES, TRUE, &hAccessToken);
	if(bRet == FALSE)
    {
       bRet=OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hAccessToken);
	   if(bRet == FALSE)
	   {
         throw INIT_Error("");
	   }
    }
	SetSpecificPrivilegeInAccessToken(hAccessToken, lpwcsPrivType, bEnabled);
	CloseHandle(hAccessToken);
    if (bRet == FALSE)
    {
       throw INIT_Error("");
    }
}

//+-------------------------------------------------------------------
//
// Function:
//      SetSpecificPrivilegeInAccessToken.
//
// Description:
//      Enable/Disable a security privilege in the access token.
//
// Parameters:
//      hAccessToken - the access token on which the function should operate.
//          The toekn should be opened with the TOKEN_ADJUST_PRIVILEGES flag.
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//          disabled.
//
//+-------------------------------------------------------------------
inline
void
SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
                                   LPCTSTR lpwcsPrivType,
                                   BOOL    bEnabled )
{
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;

    if (!LookupPrivilegeValue(NULL,
                              lpwcsPrivType,
                              &luidPrivilegeLUID))
    {
        throw INIT_Error("");
    }


    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = bEnabled?SE_PRIVILEGE_ENABLED:0;
    if(! AdjustTokenPrivileges (hAccessToken,
                                  FALSE,  // Do not disable all
                                  &tpTokenPrivilege,
                                  sizeof(TOKEN_PRIVILEGES),
                                  NULL,   // Ignore previous info
                                  NULL))

    {
         throw INIT_Error("");
    }
								  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\level8.cpp ===
//
// This Test is written for tests level 8 problem
// In our ATCM  3904 
//
// Written by: Eitank @ Microsoft.com 
//


#include "msmqbvt.h"
#include <iostream.h>
#include <mq.h>
#include "sec.h"
#include <_mqreg.h> //to support falcon registry entries, andysm added
#include <_mqini.h> //also to support falcon registry entries, andysm added
#include <wincrypt.h>
using namespace std;

 
//
// Ctor - Do those steps:
// 1. Retrive parmeters from INI file
// 2. Impersonate to other user
// 3. Load Hive
// 4. Retrive Security context.
// 5. Revert to self.
// 
cLevel8::cLevel8 (std::map <std::wstring,std::wstring> & Params)
{
	 m_DestQueueFormatName= Params[L"DESTQFN"];
	 
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"UsrName",m_wcsUserName);
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"domain",m_wcsDomainName);
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"Password",m_wcsPassWord);
	
	try
	 {
		

		 string csUserName=My_WideTOmbString( m_wcsUserName );
		 string csDomainName=My_WideTOmbString( m_wcsDomainName );
		 string csPassword=My_WideTOmbString( m_wcsPassWord );
		 
	 	 wstring wcsAccountName = m_wcsDomainName;
		 wcsAccountName +=L"\\";
		 wcsAccountName += m_wcsUserName;
		 // This Class impersonate to other user
		 Impersonate_t  user(csUserName.c_str(),csDomainName.c_str(),csPassword.c_str());
		 //
		 // Load hive + MQGetSecurityContext
		 //
		 m_hSeCtxt=FAL_GetThreadSecurityContext(user,wcsAccountName);
		 
		 // Revert To self called by the destractor 
	 }
	 catch (INIT_Error & err )
	 {
		wcout << L"Problem with Impersonate\n";
		throw err;
	 }
}

//
// Test tests related to level 8 problem
// With MQGetSecurityConext 
// FMQclient send auth messgae with using logon as other - mirror acount
// and send it with his securty conext
// This tests is in the atcm in test = 3904
//
//

//
// Need to modify all the tests that can get map as passed value 
//

//
// This Method writes to debug the application 
// This check if the HIVE is loaded well
//

//
// This code is written to debug load hive problems.
// You can logon as some one write in the registry.
//
int cLevel8::DebugIt()
{
		
		WCHAR szRegName[255];
		HKEY hProf = NULL ;
		LONG lRegError = 0 ;
		WCHAR szProfileImagePath[256];
        DWORD dwProfileImagePathBuffSize = sizeof(szProfileImagePath);


		wcscpy(szRegName, L"Software\\Microsoft\\MSMQ") ;
        lRegError = RegOpenKeyExW( HKEY_CURRENT_USER,
                                  szRegName,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hProf );
        if (lRegError != ERROR_SUCCESS)
        {
            MqLog("Failed in RegOpenKeyEx(%S), other hive, err- %lut\n",
                                                    szRegName, lRegError);
            return MSMQ_BVT_FAILED;
        }

        dwProfileImagePathBuffSize = sizeof(szProfileImagePath);
        DWORD dwType = REG_SZ ;

        lRegError = RegQueryValueExW( hProf,
                                     L"OtherHiveValue",
                                     0,
                                     &dwType,
                                     (PBYTE)szProfileImagePath,
                                     &dwProfileImagePathBuffSize );
        if (lRegError != ERROR_SUCCESS)
        {
            MqLog(
             "Failed in RegQueryValueEx(%S, OtherHiveValue), err- %lut\n",
                                                     szRegName, lRegError);
            return MSMQ_BVT_FAILED;
        }
        MqLog("Successfully RegQueryValueEx(), other hive, value- %S\n",
                                                     szProfileImagePath) ;

        lRegError = RegCloseKey(hProf);
return MSMQ_BVT_SUCC;    
}

//
// Send messages as other user. 
//

 
INT cLevel8::Start_test()
{
	HRESULT hRc;
	HANDLE Qh;
	cPropVar Level8Mprop (7);
	wstring Body (L"Test");
	wstring Label (L"Test");

	hRc=MQOpenQueue (m_DestQueueFormatName.c_str(),MQ_SEND_ACCESS,MQ_DENY_NONE, &Qh);
	Level8Mprop.AddProp (PROPID_M_BODY,VT_UI1|VT_VECTOR,Body.c_str());
	Level8Mprop.AddProp (PROPID_M_LABEL,VT_LPWSTR,Label.c_str());
	INT iTemp=MQMSG_PRIV_LEVEL_BODY;

	iTemp=MQMSG_AUTH_LEVEL_ALWAYS;
	Level8Mprop.AddProp (PROPID_M_AUTH_LEVEL,VT_UI4,&iTemp);

	if (g_bDebug)
	{
		wcout <<L"Try to send messages without security context" <<endl;
	}
	//
	//  Send message without security context - check if there is any problem.
	// 
	hRc=MQSendMessage (Qh, Level8Mprop.GetMSGPRops() ,NULL);
	ErrHandle(hRc,MQ_OK,L"MQSendMessage Failed");
	
	//
    // Add Security context to the message prop
	// 
	Level8Mprop.AddProp (PROPID_M_SECURITY_CONTEXT,VT_UI4,&m_hSeCtxt);		
	hRc=MQSendMessage(Qh, Level8Mprop.GetMSGPRops() ,NULL);
	ErrHandle(hRc,MQ_OK,L"MQSendMessage Failed");

return MSMQ_BVT_FAILED;
}

	
INT cLevel8::CheckResult()
{
	
	// Bugbug need to retrive the message and check the user SID
	MQFreeSecurityContext (m_hSeCtxt);
	//  ErrHandle(hRc,MQ_OK,L"MQFreeSecurityContext");

	return MSMQ_BVT_SUCC;
}


void cLevel8::Description() 
{
	wMqLog(L"Thread %d : Send auth message as other user\n", m_testid);
}

cLevel8::~cLevel8 ()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqadmapi.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqAdmAPI.cpp

Abstract:
	1. Send a message to a nonexisting queue. By doing so an outgoing queue is created that contains the message.
	2. Call MQMgmtGetIngo on the outgoing queue.
	3. Check the queue properties returned by it.
		
Author:
    
	Tal Kariv (talk) 1-7-2001
	
Revision History:

--*/
#include "msmqbvt.h"
using namespace std;
using namespace MSMQ;

void FreeMemory(PROPVARIANT* propVar);
void FreeValue(PROPVARIANT* propVar , INT PlaceToFree);

#define NUM_OF_ADMIN_PROPS 11
#define MESSAGE_COUNT_SENT_TO_EMPTY 1
#define EMPTY_QUOTA 236
#define ADMIN_TEST_QUEUE L"DIRECT=OS:Empty\\bvt-AdminTest"
#define NO_MESSAGES 0


void CMqAdminApi::Description()
{
	wMqLog(L"Thread %d : Admin API Thread\n", m_testid);
}

CMqAdminApi::CMqAdminApi(const INT iIndex , std::wstring wcsLocalComputerNetBiosName)
 :cTest(iIndex),m_wcsFormatName(L"")
{
	m_wcsFormatName = ADMIN_TEST_QUEUE;
	m_wcsFormatName += m_wcsGuidMessageLabel;

	m_wcsLocalComputerNetBiosName = wcsLocalComputerNetBiosName;
}
CMqAdminApi::~CMqAdminApi()
{
	if (propVar != NULL)
	{
		FreeMemory(propVar);
	}
}

CMqAdminApi::Start_test()
/*++  
	Function Description:
		sends a message to a nonexisting queue Empty\bvt-AdminTest
	Arguments:
		none
	Return code:
		none
--*/
{
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle = NULL;
	cPropVar AdmMessageProps(2);
	wstring Label(L"Admin Test");
	
	//
	//	open outgoing queue Empty\bvt-AdminTest, purge it and close it.
	//
	if(g_bDebug)
	{
		MqLog("open outgoing queue Empty\\bvt-AdminTest and purge it\n");
	}
	rc=MQOpenQueue( m_wcsFormatName.c_str() , MQ_RECEIVE_ACCESS|MQ_ADMIN_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	if( rc != MQ_ERROR_ACCESS_DENIED )
	{
	   ErrHandle(rc,MQ_OK,L"MQOpenQueue with receive access failed");
	   rc=MQPurgeQueue(QueueuHandle);
  	   ErrHandle(rc,MQ_OK,L"MQPurgeQueue failed");
   	   rc=MQCloseQueue(QueueuHandle);
       ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
    }
	else
	{
		//
		// This error happend on depenetet client and in du that is not local admin
		// 
		if(g_bDebug)
		{
			MqLog("MQOpenQueue return MQ_ERROR_ACCESS_DENIED happened because user is not local admin\n");
		}
	}

	//
	//	open nonexisting queue Empty\bvt-AdminTest
	//
	if(g_bDebug)
	{
		MqLog("open nonexisting queue Empty\\bvt-AdminTest\n");
	}
	rc=MQOpenQueue( m_wcsFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue with send access failed");
	//
	// Send express message to a nonexisting queue Empty\bvt-AdminTest
	//
	if(g_bDebug)
	{
		MqLog("Send message to nonexisting queue Empty\\bvt-AdminTest\n");
	}
	AdmMessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , L"Admin Test" );
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	AdmMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );
	rc = MQSendMessage( QueueuHandle , AdmMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage Failed");
	//
	// MQCloseQueue queue Empty\bvt-AdminTest
	//
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	return MSMQ_BVT_SUCC;
}


CMqAdminApi::CheckResult()
/*++  
	Function Description:
		Calls MQMgmtGetInfo on outgoing queue direct=os:Empty\bvt-AdminTest and checks the values returned
	Arguments:
		none
	Return code:
		none
--*/
{
	DWORD cPropId = 0;

	
	// 0 
	propId[cPropId] = PROPID_MGMT_QUEUE_PATHNAME;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 1
	propId[cPropId] = PROPID_MGMT_QUEUE_FORMATNAME;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 2 
	propId[cPropId] = PROPID_MGMT_QUEUE_TYPE;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 3 
	propId[cPropId] = PROPID_MGMT_QUEUE_LOCATION ;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 4 
	propId[cPropId] = PROPID_MGMT_QUEUE_XACT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 5 
	propId[cPropId] = PROPID_MGMT_QUEUE_FOREIGN;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 6 
	propId[cPropId] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 7 
	propId[cPropId] = PROPID_MGMT_QUEUE_USED_QUOTA;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 8 
	propId[cPropId] = PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 9 
	propId[cPropId] = PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 10 
	propId[cPropId] = PROPID_MGMT_QUEUE_STATE;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	mqProps.cProp = cPropId;
	mqProps.aPropID = propId;
	mqProps.aPropVar = propVar;
	mqProps.aStatus = NULL;

	//
	//	calling MQMgmtGetInfo
	//
	wstring QueueToPassToMgmt = L"QUEUE=";
	QueueToPassToMgmt += m_wcsFormatName;
	if(g_bDebug)
	{
		MqLog("Calling MqMgmtGetInfo on machine %S for queue %S\n" , m_wcsLocalComputerNetBiosName.c_str(), QueueToPassToMgmt.c_str());
	}
	HRESULT hr = MQMgmtGetInfo(m_wcsLocalComputerNetBiosName.c_str() , QueueToPassToMgmt.c_str() , &mqProps);
	ErrHandle(hr,MQ_OK,L"MQMgmtGetInfo Failed");
	
	//
	//	check queue pathname - should be unknown (since the target queue doesn't really exist)
	//
	if (propVar[0].pwszVal !=  NULL)
	{
		MqLog("Got incorrect pathname - %S\n" , propVar[0].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue pathname - OK\n");
		}
	}

	//
	//	check queue format name
	//
	if ( m_wcsFormatName != propVar[1].pwszVal)
	{
		MqLog("Got incorrect format name - %S\n" , propVar[1].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue format name - OK\n");
		}
	}

	//
	//	check queue type. should be public.
	//
	if (wcscmp(propVar[2].pwszVal , MGMT_QUEUE_TYPE_PUBLIC))
	{
		MqLog("Got incorrect type - %S\n" , propVar[2].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue type - OK\n");
		}
	}

	//
	//	check queue location. should be remote.
	//
	if (wcscmp(propVar[3].pwszVal , MGMT_QUEUE_REMOTE_LOCATION))
	{
		MqLog("Got incorrect location - %S\n" , propVar[3].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue location - OK\n");
		}
	}

	//
	//	check if queue is transactional. should be unknown since the target queue doesn't exist
	//
	if (wcscmp(propVar[4].pwszVal , MGMT_QUEUE_UNKNOWN_TYPE)) 
	{
		MqLog("Got incorrect transactional status - %S\n" , propVar[4].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue transactional status - OK\n");
		}
	}

	//
	//	check queue foreign status. should be unknown since target queue doesn't exist.
	//
	if (wcscmp(propVar[5].pwszVal , MGMT_QUEUE_UNKNOWN_TYPE))
	{
		MqLog("Got incorrect foreign status - %S\n" , propVar[5].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue foreign status - OK\n");
		}
	}

	//
	//	check queue message count. should be MESSAGE_COUNT_SENT_TO_EMPTY (1)
	//
	if (propVar[6].ulVal !=  MESSAGE_COUNT_SENT_TO_EMPTY) 
	{
		MqLog("Got incorrect message count - %d\n" , propVar[6].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue message count - OK\n");
		}
	}
	
	//
	//	check queue quota > 0 can't be prepdict the exact quota
	//
	if (propVar[7].ulVal <= 0 ) 
	{
		MqLog("Got incorrect used quota - %d\n" , propVar[7].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue used quota - OK\n");
		}
	}
	
	//
	//	check journal message count. should be NO_MESSAGES (0)
	//
	if (propVar[8].ulVal != NO_MESSAGES) 
	{
		MqLog("Got incorrect journal message count - %d\n" , propVar[8].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue journal message count - OK\n");
		}
	}

	//
	//	check journal used quota. should be NO_MESSAGES (0)
	//
	if (propVar[9].ulVal != NO_MESSAGES) 
	{
		MqLog("Got incorrect journal used quota - %d\n" , propVar[9].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue journal used quota - OK\n");
		}
	}

	//
	//	check outgoing queue state. should be "waiting" or "nonactive" depending on how much time passed since it was created
	//
	if (wcscmp(propVar[10].pwszVal , MGMT_QUEUE_STATE_WAITING) && wcscmp(propVar[10].pwszVal , MGMT_QUEUE_STATE_NONACTIVE))
	{
		MqLog("Got incorrect state - %S\n" , propVar[10].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue state - OK\n");
		}
	}

	//
	//	open outgoing queue Empty\bvt-AdminTest and purge it
	//
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle = NULL;
	
	if(g_bDebug)
	{
		MqLog("open outgoing queue Empty\\bvt-AdminTest and purge it\n");
	}
	rc=MQOpenQueue( m_wcsFormatName.c_str(), MQ_RECEIVE_ACCESS+MQ_ADMIN_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	if ( rc == MQ_ERROR_ACCESS_DENIED )
	{	
		//
		// This error happend on depenetet client and in du that is not local admin
		// 
		if(g_bDebug)
		{
			MqLog("MQOpenQueue return MQ_ERROR_ACCESS_DENIED happened because user is not local admin\n");
		}
		return MSMQ_BVT_SUCC;
	}	
	ErrHandle(rc,MQ_OK,L"MQOpenQueue with receive access failed");
	rc=MQPurgeQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQPurgeQueue failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	return MSMQ_BVT_SUCC;
}

void FreeMemory(PROPVARIANT* propVar)
/*++  
	Function Description:
		free memory allocated by MQMgmtGetInfo
	Arguments:
		propVar
	Return code:
		none
--*/
{
	FreeValue(propVar , 0);
	FreeValue(propVar , 1);
	FreeValue(propVar , 2);
	FreeValue(propVar , 3);
	FreeValue(propVar , 4);
	FreeValue(propVar , 5);
	FreeValue(propVar , 10);
}

void FreeValue(PROPVARIANT* propVar , INT PlaceToFree)
/*++  
	Function Description:
		free a string allocated by MQMgmtGetInfo
	Arguments:
		propVar , place in struct to free
	Return code:
		none
--*/
{
	if (propVar[PlaceToFree].vt == VT_LPWSTR)
	{
		MQFreeMemory(propVar[PlaceToFree].pwszVal);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\locateq.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	Locate thread preform DS operation.	
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/



#include "msmqbvt.h"

using namespace std;
extern BOOL g_bRunOnWhistler;

void cLocateTest::Description()
{
	wMqLog(L"Thread %d : Locate queues in the DS\n", m_testid);
}

//----------------------------------------------------------------------------
// cLocateTest::cLocateTest
// Retrive the queue label that need to search
// 

cLocateTest::cLocateTest( INT iIndex , map <wstring ,wstring > Tparms )
: cTest(iIndex),icNumberOfQueues(2),m_bUseStaticQueue(true),m_bWorkAgainstNT4(false),
  m_iEmbedded(COM_API)

{
	wcsLocateForLabel = Tparms [L"QCommonLabel"];
	m_wcsLocalMachineComputerName = ToLower(Tparms[L"CurrentMachineName"]);
	m_wcsLocalMachineName = Tparms[L"CurrentMachineName"] + L"\\" + Tparms[L"CurrentMachineName"] + L"-";
	m_wcsLocalMachineName = ToLower(m_wcsLocalMachineName);
	m_wcsLocalMachineFullDNSName = ToLower(Tparms[L"CurrentMachineNameFullDNS"]);
	if ( Tparms[L"UseStaticQueue"] == L"No" )
	{
		m_bUseStaticQueue =  false;
	}
	if( Tparms[L"NT4SuportingServer"] == L"true" )
	{
		m_bWorkAgainstNT4 = true;
	}
	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}
}

//----------------------------------------------------------------------------
// cLocateTest::CheckResult ( Empty )
// 
//

cLocateTest::CheckResult ()
{
	return MSMQ_BVT_SUCC;
}

//----------------------------------------------------------------------------
// cLocateTest::Start_test 
// Locate queue using C API + Com interface 
//
// Return value:
// Pass - MSMQ_BVT_SUCC 
// Fail - MSMQ_BVT_FAIL
//

#define MaXColumnArray 5
#define iNumberofRestrication 4

INT cLocateTest::Start_test()
{

	//
	// Locate queue using C api.
	// 
	SetThreadName(-1,"cLocateTest - Start_test ");	
	
	MQPROPERTYRESTRICTION MyPropertyRestriction [ iNumberofRestrication ];
	MQPROPVARIANT mPropVar [ iNumberofRestrication ];
	int iNumberOfClumn = 0;
	PROPID MyColumnArray [ MaXColumnArray ];
	const int ciLabelInArray = iNumberOfClumn;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_LABEL;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_BASEPRIORITY;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_PATHNAME;
	int iPathNameColmn = -1;
	if( g_bRunOnWhistler && !m_bWorkAgainstNT4 )
	{
		iPathNameColmn = iNumberOfClumn;
		MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_PATHNAME_DNS;
	}
    
	//
	// Init MQCOLUMNSET structures
    // 

	MQCOLUMNSET MyColumns;
	MyColumns.cCol = iNumberOfClumn;
	MyColumns.aCol = MyColumnArray;
	
	int iIndex = 0;
	MyPropertyRestriction[iIndex].rel = PREQ;
	MyPropertyRestriction[iIndex].prop = PROPID_Q_LABEL;
	MyPropertyRestriction[iIndex].prval.vt = VT_LPWSTR;
	MyPropertyRestriction[iIndex].prval.pwszVal = ( unsigned short * ) wcsLocateForLabel.c_str();
	iIndex ++;

	MQRESTRICTION MyRestriction;
	
	MyRestriction.cRes = iIndex;
	MyRestriction.paPropRes = MyPropertyRestriction;

	if( g_bDebug )
	{	
		wMqLog( L" Thread 4 - Start to locate all queues with label:=%s \n",wcsLocateForLabel.c_str() );		
		wMqLog( L"Call-> MQLocateBegin( NULL, &MyRestriction , &MyColumns , NULL , &hEnum );\n" \
				L" PROPID_Q_LABEL=%s",wcsLocateForLabel.c_str());
	}
	
	HANDLE hEnum;
	HRESULT rc = MQLocateBegin( NULL, &MyRestriction , &MyColumns , NULL , &hEnum );
	ErrHandle( rc , MQ_OK , L"MQLocateBegin failed to search queue in the DS " );
	DWORD dwCountProp = MaXColumnArray;
	
	//
	// Retrive all the queue that contain the same queue label.
	int iFoundNumber = 0;
	do
	{
	
		dwCountProp = 4;
		if( g_bDebug )
		{
			wMqLog( L"Call-> MQLocateNext( hEnum, &dwCountProp,  mPropVar ) ");			
		}
		rc = MQLocateNext( hEnum, &dwCountProp,  mPropVar );
		ErrHandle( rc , MQ_OK , L"MQLocateNext failed to search queue in the DS " );
		if( g_bDebug )
		{	
			wMqLog( L"Thread 4 - MQLocateNext return with dwCountProp = %ld\n",dwCountProp);
		}
		WCHAR * pwcsPos = NULL;
		if ( mPropVar[2].pwszVal )
		{
			std::wstring wcsQueuePathName = mPropVar[2].pwszVal;
			pwcsPos = wcsstr(wcsQueuePathName.c_str(),m_wcsLocalMachineName.c_str());
			if( ! m_bUseStaticQueue && pwcsPos == NULL )
			{
				pwcsPos = wcsstr( wcsQueuePathName.c_str(),m_wcsLocalMachineComputerName.c_str() );
			}
		}
		//
		// if pwcsPos != NULL is means that queue is exist in the domain and need check if full dns name is exist.
		// 
		if( g_bRunOnWhistler && pwcsPos != NULL && ! m_bWorkAgainstNT4 )
		{
			if (g_bDebug)
			{
				wMqLog(L"Thread 4 - MQLocateNext check PROPID_Q_PATHNAME_DNS  %s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
			}
			if ( mPropVar[iPathNameColmn].pwszVal != NULL )
			{
				std::wstring wcsQueuePathName = mPropVar[3].pwszVal;
				if ( wcsQueuePathName.find_first_of(m_wcsLocalMachineFullDNSName) == -1 )
				{ 
					//
					// Machine full dns name is not exist in domain
					//
					wMqLog(L"Thread 4 - MQLocateNext Failed to retrive PROPID_Q_PATHNAME_DNS found:%s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
					return MSMQ_BVT_FAILED;
				}
				
			}
			else
			{
				wMqLog(L"Thread 4 - MQLocateNext Failed to retrive PROPID_Q_PATHNAME_DNS found:%s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
				return MSMQ_BVT_FAILED;
			}
		}
		if( dwCountProp != 0  &&
			mPropVar[ ciLabelInArray ].pwszVal != NULL &&
			wcsLocateForLabel ==  (wstring) mPropVar[0].pwszVal &&
			pwcsPos  
		  )
		{
			iFoundNumber ++;
			if( g_bDebug )
			{
				MqLog("Found %d from %d queues\n",iFoundNumber,icNumberOfQueues);
			}
		}
		
		
	} while( dwCountProp != 0 );  
	
	
	// 
	// Check if found all what we ask to .
	//
	
	if ( iFoundNumber != icNumberOfQueues  )
	{
		MqLog("Found %d from %d queues using C API\n",iFoundNumber,icNumberOfQueues);
		return MSMQ_BVT_FAILED;
	}

	rc = MQLocateEnd ( hEnum );
	ErrHandle( rc , MQ_OK , L"MQLocateEnd failed ");
	
	//
	// Need to contue to check sort as basepriprty
	//
	if( g_bDebug )
	{
		MqLog("	Thread 4 - try to locate queue using com interface \n" \
			  " Succeeded to search using C-API \n");
	}
	
	//
	// Locate queue via com objects
	// 
	if( m_iEmbedded != C_API_ONLY )
	{
		try
		{
			
			MSMQ::IMSMQQueueInfosPtr qinfos("MSMQ.MSMQQueueInfos");
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueryPtr query("MSMQ.MSMQQuery");
			
			INT iNumberOfQueue = 0;
			_variant_t vQLabel(wcsLocateForLabel.c_str());
			
			qinfos = query->LookupQueue ( &vtMissing , &vtMissing, & vQLabel );
			qinfos->Reset();
			qinfo = qinfos->Next();
			while( qinfo != NULL )
			{
				wstring wcsQueuePathName = qinfo->PathName;
				WCHAR * pwcsPos = wcsstr(wcsQueuePathName.c_str(),m_wcsLocalMachineName.c_str());
				if(  ! m_bUseStaticQueue && pwcsPos == NULL )
				{
					pwcsPos = wcsstr( wcsQueuePathName.c_str(),m_wcsLocalMachineComputerName.c_str() );
				}
				if( wcsLocateForLabel == ( wstring )  qinfo -> Label && pwcsPos )
				{
					iNumberOfQueue ++;
				}
				else if( wcsLocateForLabel != ( wstring )  qinfo -> Label )
				{
					wMqLog (L"Thread 4 - Error to compare result:\n found: %s \n expected: %s\n" , qinfo -> Label , wcsLocateForLabel.c_str() );
					return MSMQ_BVT_FAILED;
				}
				qinfo = qinfos->Next();
				if( g_bDebug && qinfo != NULL )
				{
					if( qinfo )
					{
						wstring wcsLabel = (wstring)qinfo->Label;
						wMqLog(L"Thread 4 - qinfos->Next, queue found with label =%s\n",wcsLabel.c_str());
					}
				}					
			}  
			if( iNumberOfQueue != icNumberOfQueues )
			{
				MqLog("Found %d from %d queues using COM API\n",iNumberOfQueue,icNumberOfQueues);
				return MSMQ_BVT_FAILED;
			}
		}
		catch(_com_error & ComErr )
		{
			wcout  << L"Thread 4 - Locate using com interface failed " <<endl;
			CatchComErrorHandle( ComErr , m_testid );
			return MSMQ_BVT_FAILED;
		}
	}  
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\init.cpp ===
/*

  	//
	// bugbug - place this code in separate cpp for re-use
	//


This is the MQBvt setup stage in this stage all the queue create before the tests
This creates to solve replication delay for the tests.
There is two ways to run the BVT
1. Work with static queue ( queue create before the tests ).
2. Create the queue during the tests, ( Need to Sleep Before use this tests ).

Written by :Eitank @ Microsoft.com

*/

#define MAX_MACH_NAME_LEN (100)
#define Configuration_Detect (7)
#define Configuration_Detect_Failed (8)
#define Configuration_Detect_Warning (9)
#define MAX_RANDOM_CHAR		(10)



#include <winsock2.h>
#include <svcguid.h>
#include "MSMQBvt.h"
#include "mqf.h"

#include <mq.h>
#include <_mqreg.h>
#include <_mqini.h>
#include <wincrypt.h>
#include "errorh.h"
#include "Randstr.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include <comdef.h>
using namespace std;

extern BOOL g_bRunOnWhistler;
extern BOOL g_bRemoteWorkgroup ;

std::string InitpGetAnonymousUserName ();
std::string InitpGetAllWorldUserName (); 

class cQueueProp
{
	public:
			cQueueProp ():m_wcsFormatName (g_wcsEmptyString),m_wcsPathName(g_wcsEmptyString),
				m_wcsQueueLabel(g_wcsEmptyString),m_wcsMultiCastAddress(g_wcsEmptyString) {};

			cQueueProp (const cQueueProp & cObject);

			cQueueProp (wstring wcsPathname,wstring Qlabel):
				m_wcsFormatName (wcsPathname),m_wcsPathName(Qlabel),m_wcsQueueLabel(L"") {};

			void SetProp (wstring wcsPathname,wstring Qlabel,ULONG ulFlag,wstring wcsMutliCast = g_wcsEmptyString );
			virtual ~cQueueProp () {};

			void SetFormatName(WCHAR * wcsFormatName) { m_wcsFormatName=wcsFormatName; }
			const wstring getFormatName() {return m_wcsFormatName;  }
			const wstring getQLabel() { return  m_wcsQueueLabel; }
			const wstring getPathName () { return m_wcsPathName; }

			INT CreateQ (bool bTryToCreate , SetupType eSetupType , cBvtUtil & cTestParms );
			friend 	HRESULT APIENTRY  MQCreateQueue( IN PSECURITY_DESCRIPTOR , IN OUT MQQUEUEPROPS* ,OUT LPWSTR ,
					IN OUT LPDWORD lpdwFormatNameLength);
   private: 
	 wstring m_wcsFormatName;
	 wstring m_wcsPathName;
	 wstring m_wcsQueueLabel;
	 wstring m_wcsMultiCastAddress;
	 ULONG ulQCreateFalgs;
};

HRESULT SetMulticastAddress ( WCHAR * wcsFormatName, const WCHAR * wcsMulticastAddress )
/*++
	Function Description:
		SetMulticastAddress
	Arguments:
		wcsFormatName queue format name
		wcsMulticastAddress multicast address.
	Return code:
		HRESULT
--*/
{
		int iProps = 0;
		QUEUEPROPID QPid[1]={0};
		MQPROPVARIANT QPVar[1]={0};
		HRESULT hQStat[1]={0};
		MQQUEUEPROPS QProps;
	
		QPid [0] = PROPID_Q_MULTICAST_ADDRESS;
		QPVar[0].vt = VT_LPWSTR;
		QPVar[0].pwszVal = const_cast <WCHAR *>(wcsMulticastAddress);
		iProps = 1;

		// modify the queue
		QProps.cProp = iProps;
		QProps.aPropID = QPid;
		QProps.aPropVar = QPVar;
		QProps.aStatus = hQStat;

		HRESULT rc = MQSetQueueProperties( wcsFormatName,&QProps );
		if (FAILED(rc))
		{
			MqLog("MQSetQueueProperties failed to set queue multicast address error 0x%x\n",rc);
		}
		return rc;
}

//---------------------------------------------------------------------------
// This metod return the Evreyone string in all lang.
//

string InitpGetAllWorldUserName ()
/*++
	Function Description:
		Return string the describe all world user name dependent on the machine locale
	Arguments:
		None
	Return code:
		std::string.
--*/
{
	//
	// Create Evreyone SID
	//

	PSID   pWorldSid = NULL ;
	SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	BOOL bRet = AllocateAndInitializeSid( &WorldAuth,
                                     1,
                                     SECURITY_WORLD_RID,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     &pWorldSid );

	if ( ! bRet )
	{
		MqLog ("Can't Init everyone's SID \n ");
	}
	char csAccountName[100];
	DWORD dwAccountNamelen = 100;
	char csDomainName[100];
	DWORD dwDomainNamelen = 100;
	
	csAccountName[0] = NULL;
	SID_NAME_USE eUse;

	//
	// Ask the account name for the user SID
	//

	bRet = LookupAccountSid(NULL,pWorldSid,csAccountName,&dwAccountNamelen,csDomainName,&dwDomainNamelen,&eUse);
	if (! bRet )
	{
		MqLog ("Can't get everyone's account name\n");
	}
	
	FreeSid (pWorldSid);
	
		
	if ( csDomainName)
		return csAccountName;
	else
		return "Everyone";
}



string InitpGetAnonymousUserName ()
/*++
	Function Description:
		Return string the describe Anonymous user name dependent on the machine locale
	Arguments:
		None
	Return code:
		std::string.
--*/
{
	//
	// Create AnonyMouse SID
	//
	BOOL bRet = TRUE;
	PSID pAnonymSid = NULL ;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    //
    // Anonymous logon SID.
    //
    bRet = AllocateAndInitializeSid( &NtAuth,
                                     1,
                                     SECURITY_ANONYMOUS_LOGON_RID,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     &pAnonymSid );

	if ( ! bRet )
	{
		MqLog ("Can't Init Anonymous SID \n ");
		return "";
	}
	char csAccountName[100];
	DWORD dwAccountNamelen = 100;
	char csDomainName[100];
	DWORD dwDomainNamelen = 100;
	
	csAccountName[0] = NULL;
	SID_NAME_USE eUse;

	//
	// Retrive the account name for the user SID
	//
	bRet = LookupAccountSid(NULL,pAnonymSid,csAccountName,&dwAccountNamelen,csDomainName,&dwDomainNamelen,&eUse);
	if (! bRet )
	{
		MqLog ("Can't get Anonymous account name\n");
		FreeSid (pAnonymSid);
		return "";
	}
	
	FreeSid (pAnonymSid);
	
		
	if ( csDomainName )
		return csAccountName;
	else
		return "ANONYMOUS LOGON";
}




//---------------------------------------------------------------------------
// cPropVar::ReturnMSGValue
//
// This method locates a value in the property structure
// of a received message
//
// For integer and char values, the value is returned through the OUT arument,
// else the vlaue is already in the outside buffer.
//
// The method returns success if it finds the property,
// else it returns fail.
//
int cPropVar::ReturnMSGValue ( QUEUEPROPID cPropID ,VARTYPE MQvt  ,/*OUT*/void  * pValue )
{
	 INT iPlace = -1 ;
	 for (INT iIndex=0 ; iIndex < iNumberOfProp && iPlace == -1  ; iIndex ++)
	 {
		if ( pQueuePropID[iIndex] == cPropID )
			iPlace = iIndex;
	 }

	 if ( iPlace != -1 )
	 {
		 switch (MQvt)
		 {
		   case VT_UI1: {
							* (UCHAR * ) pValue = pPropVariant[ iPlace ].bVal;
						}
						break;

  		  case VT_UI2:	{
							
							*( (USHORT * ) pValue) = pPropVariant[ iPlace ].uiVal;
						}
						break;

		case VT_UI4:	{
							* (ULONG * ) pValue = pPropVariant[ iPlace ].ulVal;
						}
						break;
		case VT_UI8:	{
							* (ULONGLONG * ) pValue = pPropVariant[ iPlace ].hVal.QuadPart;
						}
						break;
		default:
			pValue = NULL;
		
		 };
	 }
	 return ( iPlace != -1 ) ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}

//
// cPropVar::ReturnOneProp
//
// This method locates and returns a MQPROPVARIANT property structure
// of a received message.
//
// The method returns and empty structure if it doesn't find
// the desired propid.
//
MQPROPVARIANT cPropVar::ReturnOneProp( QUEUEPROPID aPropID)
{

	 INT ifound = -1 ;
	 for (INT iIndex=0 ; iIndex < iNumberOfProp && ifound == -1  ; iIndex ++)
	 {
		if ( pQueuePropID[iIndex] == aPropID)
			ifound = iIndex;
	 }

	 if (ifound != -1 )
		return pPropVariant[ifound];

	 //
	 // propid not found
	 //
	 MQPROPVARIANT Empty;
	 Empty.vt=VT_EMPTY;
	 return Empty;

}

//
// Create uuid for queue pathname, solve the duplicate path name
// Input value:
// wcsQueuePathname - string to init with guid
// GUID type - 0 / 1 / 2 Type of guid
// QType - False - Public.
//         TRUE - Private.
//

INT ReturnGuidFormatName( std::wstring & wcsQueuePath , INT GuidType , BOOL bWithOutLocalString )
{

	// Acoring to stl bug
	wstring wcsQueuePathName;
	if (  GuidType == 0  )
	{
		wcsQueuePathName = L".\\";
	}
	else if (  GuidType == 1  )
	{
		wcsQueuePathName = L".\\private$\\";
	}
	else if (  GuidType == 2  )
	{
	 	wcsQueuePathName = L"";
	}
	
	GUID GuidName;
	unsigned char* csName= NULL;
	UuidCreate(&GuidName);
	RPC_STATUS  hr = UuidToString(&GuidName,&csName);
	if(hr != RPC_S_OK )
	{
		MqLog("ReturnGuidFormatName - UuidToString failed to covert guid to string return empty string \n");
		return MSMQ_BVT_FAILED;
	}

	wstring wcsTempString;
	wcsTempString =  My_mbToWideChar ((char *) csName );
	
	if ( ! bWithOutLocalString )
	{
		DWORD lcid = LocalSystemID ();
		WCHAR wcsTemp[MAX_RANDOM_CHAR + 2];
		wstring  wcsTemp1 = L"{";
		int iBuffer = MAX_RANDOM_CHAR;
		
		INT ix = GetRandomStringUsingSystemLocale (lcid, wcsTemp , iBuffer );
		if ( ix != 0 )
		{
			wcsTemp1 += wcsTemp;
		}
		wcsTemp1 += L"}";
		wcsTempString += wcsTemp1;
	}

	wcsQueuePathName += wcsTempString;
	RpcStringFree(&csName);
	wcsQueuePath = wcsQueuePathName;
return MSMQ_BVT_SUCC;
}

//
// cQueueProp::CreateQ
//
// This method create the queues for all the BVT tests
// -- or just retrieve the format name if they already exist.
//
INT cQueueProp::CreateQ (bool bTryToCreate ,SetupType eSetupType ,cBvtUtil & cTestParms )
{
	cPropVar MyPropVar(5);
	HRESULT rc=MQ_OK;
	WCHAR wcsFormatName [BVT_MAX_FORMATNAME_LENGTH];
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	UCHAR Flag=0;
	MQPROPVARIANT vrPathName;
	string csAllWorldAccountName="";
	string csAnonymousAccountName="";;
	MyPropVar.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,m_wcsPathName.c_str());
	MyPropVar.AddProp (PROPID_Q_LABEL,VT_LPWSTR,m_wcsQueueLabel.c_str());
	bool bNeedToSetMulticastAddress = false;
	if (ulQCreateFalgs == CREATEQ_TRANSACTION )
	{
		Flag=MQ_TRANSACTIONAL;
		MyPropVar.AddProp (PROPID_Q_TRANSACTION,VT_UI1,&Flag);
	}
	else if (ulQCreateFalgs == CREATEQ_AUTHENTICATE )
	{
		Flag=MQ_AUTHENTICATE;
		MyPropVar.AddProp (PROPID_Q_AUTHENTICATE,VT_UI1,&Flag);
	}

	else if (ulQCreateFalgs == CREATEQ_PRIV_LEVEL )
	{
		ULONG ulFlag=MQ_PRIV_LEVEL_BODY;
		MyPropVar.AddProp (PROPID_Q_PRIV_LEVEL,VT_UI4,&ulFlag);
	}
	else if( wcsstr(m_wcsMultiCastAddress.c_str(),L":") != NULL && g_bRunOnWhistler && ulQCreateFalgs == MULTICAST_ADDRESS )
	{
		MyPropVar.AddProp(PROPID_Q_MULTICAST_ADDRESS,VT_LPWSTR,m_wcsMultiCastAddress.c_str());
		bNeedToSetMulticastAddress = true;
	}

	//
	// All queues receive the same type GUID
	//
	BSTR AllQueueType = _bstr_t("{00000000-1111-2222-3333-444444444444}");
	MyPropVar.AddProp (PROPID_Q_TYPE,VT_CLSID,& AllQueueType );

	//
	// Create Security descriptor.
	//
	
	PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL;
	CSecurityDescriptor cSD;

	
	if ( eSetupType == ONLYSetup )
	{
		csAllWorldAccountName = InitpGetAllWorldUserName ();
		csAnonymousAccountName = InitpGetAnonymousUserName ();
		cSD.InitializeFromThreadToken();
		if (ulQCreateFalgs == CREATEQ_DENYEVERYONE_SEND )
		{
			rc = cSD.Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Deny(csAllWorldAccountName.c_str(), MQSEC_WRITE_MESSAGE);
			rc = cSD.Deny(csAnonymousAccountName.c_str(), MQSEC_WRITE_MESSAGE);

		}
		else
		{
			rc = cSD.Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
		}		
		
		if (rc != S_OK)
		{
			 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
		}
		pSecurityDescriptor=cSD;
	}
		

	//
	// Create the queue
	//
	vrPathName = MyPropVar.ReturnOneProp (PROPID_Q_PATHNAME);
	bool bApiType = TRUE;
	if ( bTryToCreate )
	{
		rc=MQCreateQueue(pSecurityDescriptor,MyPropVar.GetMQPROPVARIANT() , wcsFormatName , &ulFormatNameLength );
		if( rc == MQ_ERROR_QUEUE_EXISTS &&
			bNeedToSetMulticastAddress 
		  )
		{
			//
			// This will fix the problem when user run -I without -multicast and he want to set the multicast address
			//
			rc = MQPathNameToFormatName ( vrPathName.pwszVal, wcsFormatName , & ulFormatNameLength);
			if(FAILED(rc))
			{
				MqLog("MQPathNameToFormatName failed for queue that already exists\n");
				throw INIT_Error("MQPathNameToFormatName failed \n");
			}
			if ( SetMulticastAddress(wcsFormatName,m_wcsMultiCastAddress.c_str()) != MQ_OK )
			{
				wMqLog(L"Please check if user can set queue props on queue %s\n",vrPathName.pwszVal);
			}
		}
	}
	else
	{
		
		bApiType = FALSE;
		if (vrPathName.vt )
		{
			if ( cTestParms.m_eMSMQConf != WKG )
			{
				rc = MQPathNameToFormatName ( vrPathName.pwszVal, wcsFormatName , & ulFormatNameLength);
			
			}
			else
			{
				if ( ulFormatNameLength >= ( wcslen (L"Direct=os:")+  wcslen (vrPathName.pwszVal) + 1 ))
				{
					wcscpy( wcsFormatName , L"DIRECT=os:" );
					wcscat( wcsFormatName , vrPathName.pwszVal);
					rc = MQ_OK;
				}
				else
				{	
					// Buffer to small need to relocate new buffer
					rc = MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;
				}
					
			}
			
		}
	}

	if ( rc == MQ_OK || rc == MQ_ERROR_QUEUE_EXISTS )
	{
		m_wcsFormatName = wcsFormatName;
	}
	else // rc != MQ_OK
	{

		wstring wcstemp = bTryToCreate ? L"MQCreateQueue" : L"MQPathNameToFormatName";
		
		
		wMqLog(L"%s failed with error:0x%x\n", wcstemp.c_str() , rc);
		MQPROPVARIANT vrQueueLabel = MyPropVar.ReturnOneProp (PROPID_Q_LABEL);
		wMqLog(L"With queue label: %s\n",vrQueueLabel.pwszVal );
		//
		// Print machine name from the tests
		//
		vrPathName = MyPropVar.ReturnOneProp (PROPID_Q_PATHNAME);
		if( vrPathName.pwszVal == NULL )
		{
			throw INIT_Error( "Init Stage : Can't create or update queue parameters.\n");
		}
		wstring csQueueName = vrPathName.pwszVal;
		wstring Token=L"\\";
		size_t iPos = csQueueName.find_first_of ( Token );	
		wstring csMachineName = csQueueName.substr(0,iPos);
		wMqLog(L"Can't create / refresh queue path name: %s\n",vrPathName.pwszVal);
		wMqLog(L"On machine: %s\n",csMachineName.c_str());
		throw INIT_Error( "Init Stage : Can't create or update queue parameters.\n");
	}
	return MSMQ_BVT_SUCC; // error handle in
}

//---------------------------------------------------------------------------
// Init cQueueProp with PathName , Qlabel , ulFalg
//

void cQueueProp::SetProp(wstring wcsPathname,wstring wcsQlabel,ULONG ulFlag,wstring wcsMultiCastAddress)
{
	m_wcsQueueLabel=wcsQlabel;
	m_wcsPathName=wcsPathname;
	
	if( wcsMultiCastAddress != g_wcsEmptyString )
	{
		m_wcsMultiCastAddress = wcsMultiCastAddress + PGM_PORT;
	}

	ulQCreateFalgs = ulFlag;
}

////---------------------------------------------------------------------------
// Create everyone security descriptor
//

PSECURITY_DESCRIPTOR CreateFullControllSecDesc()
{
	CSecurityDescriptor *  pcSD = new CSecurityDescriptor();
	HRESULT rc=MQ_OK;
	string csAllWorldAccountName = InitpGetAllWorldUserName ();
	string csAnonymousAccountName = InitpGetAnonymousUserName ();
	pcSD->InitializeFromThreadToken();
	rc = pcSD->Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
	if (rc != S_OK)
	{
		 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
	}
	rc = pcSD->Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
	if (rc != S_OK)
	{
		 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
	}
	return pcSD;
}
////---------------------------------------------------------------------------
// Copy constructor
//


cQueueProp::cQueueProp(const cQueueProp & cObject)
{

	m_wcsFormatName=cObject.m_wcsFormatName;
	m_wcsPathName=cObject.m_wcsPathName;
	m_wcsQueueLabel=cObject.m_wcsQueueLabel;
	ulQCreateFalgs = cObject.ulQCreateFalgs;

}

void my_Qinfo::PutFormatName (std::wstring wcsFormatName )
{
   wcsQFormatName = wcsFormatName;
}


//---------------------------------------------------------------------------
// This function preform the setup process - Create all queues
// Those Queues:
// 1. Private Queue Defualt Security Descriptor
// 2. Private Admin Q
// 3. BVT Log State Q
// 4. Private Transaction Q
// 5. Public authenticate Q
// 6. Public Privacy level Q
// 7. Public Trans  Q
//
//10.Public support
//11.
//12.
//
//


//
// cMQSetupStage
//
// This routine
//
// Parameters;
//	CurrentTest - pointer to configuration information
//	eSetupType	- see Setup stage comment
//
// INT cMQSetupStage (wstring pwcsLocalComputerName , cBvtUtil & CurrentTest , SetupType eSetupType )


INT cMQSetupStage ( SetupType eSetupType ,  cBvtUtil & CurrentTest  )
{
	//
	// Create queue info structure for the BVT queues
	//
	const int NumberOfqueue = 30;
	vector<cQueueProp> AllQueues(NumberOfqueue);
	vector<cQueueProp>::iterator itpCurrentObject=AllQueues.begin();

	wstring wcsBasePrivateQPath = CurrentTest.m_wcsCurrentLocalMachine + L"\\Private$\\" + CurrentTest.m_wcsCurrentLocalMachine;
	wstring wcsBasePublicQPath;

	wcsBasePublicQPath = CurrentTest.m_wcsCurrentLocalMachine + L"\\" + CurrentTest.m_wcsCurrentLocalMachine;
	wstring wcPathName,wcsQLabel;

	int iNumberOfQueue =0;

	//
	// Register certificate before use the setup.
	//
	// NT5 Only & ! Local user || workgroup computer.
	//
	// Remove this code no need to register certificate
	/*
	if( _winmajor ==  Win2K &&  ( CurrentTest.m_eMSMQConf !=  LocalU ) && ( CurrentTest.m_eMSMQConf !=  WKG )
		&& ( CurrentTest.m_eMSMQConf != DepClientLocalU))
	{
		my_RegisterCertificate (TRUE);
	}
    */
	//
	// Prepare queues
	//

	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName= CurrentTest.m_wcsCurrentLocalMachine + L"\\Private$\\" + L"Private-MQBVT";
	}


	wcsQLabel=L"Defualt PrivateQ";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);

	itpCurrentObject++;
	iNumberOfQueue++;

	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 , CurrentTest.bWin95);
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-Private-AdminQ";
	}

	wcsQLabel=L"Private Admin Q";
	//itpCurrentObject->SetProp( wcPathName ,wcsQLabel,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject->SetProp(wcPathName,wcsQLabel,NULL);
	itpCurrentObject++;
	iNumberOfQueue++;

	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-StateInfo";
	}

	wcsQLabel=L"MSMQ-BVT-State";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
	itpCurrentObject++;
	iNumberOfQueue++;


	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		if ( eSetupType == ONLYUpdate && CurrentTest.m_eMSMQConf == WKG )
		{
			wcPathName = CurrentTest.m_wcsCurrentRemoteMachine + L"\\private$\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-PrivateTrans";
		}
		else
		{
			wcPathName =wcsBasePrivateQPath + L"-PrivateTrans";
		}
		
	}

	wcsQLabel=L"Private Transaction";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
	itpCurrentObject++;
	iNumberOfQueue++;


	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"1";
	}
	wcsQLabel= L"MQCast1";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;

	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"2";
	}

  	wcsQLabel= L"MQCast2";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;


	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"3";
	}

  	wcsQLabel= L"MQCast3";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;

	if ( eSetupType != RunTimeSetup  )
	{
		//
		// Trigger Queues
		// 
		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-PeekTriggerQueue";
		}
		wcsQLabel = L"PeekTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-RetrievalTriggerQueue";
		}
		wcsQLabel = L"RetrievalTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-TxRetrievalTriggerQueue";
		}
		wcsQLabel = L"TxRetrievalTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;

		
		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=(wstring)L".\\private$\\" + L"TriggerTestQueue";
		}
		wcsQLabel = L"TriggerTest";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;
	}

	if ( CurrentTest.m_eMSMQConf != WKG )
	{

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Public-MQBVT";
		}

		wcsQLabel=L"Regular PublicQ";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		//
		// This is remote queue.
		// In MSMQ2 enteprize need to create queue with full dns name.
		//

		if ( eSetupType == ONLYUpdate || eSetupType == RunTimeSetup )
		{
			if ( eSetupType != RunTimeSetup )
			{
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-RemotePublic-MQBVT";
			}
			else
			{
				wstring wcsTemp;
				ReturnGuidFormatName ( wcsTemp , 0 , CurrentTest.bWin95);
				// Need to remove the
				wstring Token=L"\\";
				size_t iPos = wcsTemp.find_first_of (Token);
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + wcsTemp.substr(iPos);
			}

			wcsQLabel=L"Remote Read Queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
			itpCurrentObject++;
			iNumberOfQueue++;
		}

		else
		{
			if ( eSetupType == RunTimeSetup )
			{
				ReturnGuidFormatName(wcPathName , 0 ,CurrentTest.bWin95);
			}
			else
			{
				wcPathName=wcsBasePublicQPath +  L"-RemotePublic-MQBVT";
			}
			wcsQLabel=L"Remote Read Queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
			itpCurrentObject++;
			iNumberOfQueue++;
			//
			// Create remote machine with Full DNS name / need to find the SP4 support this ?
			//
			if ( _winmajor ==  Win2K )
			{

				if ( eSetupType == RunTimeSetup )
				{
					ReturnGuidFormatName (wcPathName , 0 );
				}
				else
				{
					wcPathName=L".\\"+ CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-RemotePublic-MQBVT";
				}
				wcsQLabel=L"Remote Read Queue";
				itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
				itpCurrentObject++;
				iNumberOfQueue++;
			}
		}
		
		//
		// Remote transaction queue.
		//

		
		if ( eSetupType != RunTimeSetup )
		{
			if ( eSetupType == ONLYUpdate )
			{
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-Remote-Transaction-Queue";
			}
			else
			{
				wcPathName= CurrentTest.m_wcsCurrentLocalMachine + L"\\" + CurrentTest.m_wcsCurrentLocalMachine +  L"-Remote-Transaction-Queue";
			}
		}
		else
		{
			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		wcsQLabel=L"Remote Transaction queue";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		}
		else
		{
			wcPathName=wcsBasePrivateQPath + L"-Trans";
		}

		wcsQLabel=L"Private Transaction";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;

		//
		// Remote transaction queue with FULL dns name / Only on NT5
		//	
		if( _winmajor == Win2K )
		{
			if ( eSetupType != RunTimeSetup )
			{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteMachineNameFullDNSName + L"\\" + CurrentTest.m_wcsRemoteMachineNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNameFullDNSName + L"\\" + CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
			}
			else
			{
				wstring wcsTemp;
				ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95);
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
			}

			wcsQLabel=L"Remote Transaction queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
			itpCurrentObject++;
			iNumberOfQueue++;
		}
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePrivateQPath + L"-Trans";
		}

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName(wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-TransQ1";
		}
		

		wcsQLabel=L"TransQ1";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;




		if ( eSetupType == RunTimeSetup )
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		else
			wcPathName=wcsBasePublicQPath + L"-TransQ2";

		wcsQLabel=L"TransQ2";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Auth";
		}

		wcsQLabel=L"Authnticate Q";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;

				
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//
			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2,CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteComputerNetBiosName + L"\\" + CurrentTest.m_wcsRemoteComputerNetBiosName +  L"-Remote-Auth-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNetBiosName + L"\\" + CurrentTest.m_wcsLocalComputerNetBiosName +  L"-Remote-Auth-Queue";
				}
		}

		wcsQLabel=L"Remote authenticate";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		//
		// Local encryption queue.
		//

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Encrypt";
		}

		wcsQLabel=L"Local encrypt";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;


		//
		// Create encrypted queue used by remote thread - Netbios name.
		//
			
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//

			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95);
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteComputerNetBiosName + L"\\" + CurrentTest.m_wcsRemoteComputerNetBiosName +  L"-Remote-Encrypt-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNetBiosName + L"\\" + CurrentTest.m_wcsLocalComputerNetBiosName +  L"-Remote-Encrypt-Queue";
				}
		}

		wcsQLabel=L"privQ";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;
/*
		//
		// Create encrypted queue used by remote thread - with full DNS name.
		//
		
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//

			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteMachineNameFullDNSName + L"\\" + CurrentTest.m_wcsRemoteMachineNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNameFullDNSName + L"\\" + CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
		}

		wcsQLabel=L"privQ"
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;

*/


		//
		// Create queue for the locate thread
		// Label it with the machine GUID
		//
		wstring wcsLocalQmID;
		
		wcsLocalQmID = CurrentTest.m_wcsLocateGuid;
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName( wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName = wcsBasePublicQPath + L"-Locate1";
		}
		wcsQLabel=L"LocateQ";
		itpCurrentObject->SetProp( wcPathName ,wcsLocalQmID ,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		else
			wcPathName=wcsBasePublicQPath + L"-Locate2";

  		wcsQLabel=L"LocateQ";
		itpCurrentObject->SetProp( wcPathName ,wcsLocalQmID ,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL1";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"1";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}
  		
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL2";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"2";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}

  		
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL3";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"3";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}

		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
				ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"Admin";
		}

  		wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		itpCurrentObject->SetProp( wcPathName , L"DL Admin Queue" , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;
	
	}


	//
	// Create the queues - or just retrieve the format name if they already exist.
	//
	
	bool bTryToCreate = ( eSetupType ==  ONLYUpdate ) ?  FALSE: TRUE ;

	INT iIndex=0;
	DebugMqLog(" +++++++++ Update internal sturcture about queue format names +++++++++\n");
	
	for (itpCurrentObject=AllQueues.begin(),iIndex=0; iIndex < iNumberOfQueue  ; itpCurrentObject++ , iIndex++)
	{
		if (g_bDebug)
		{
			if( bTryToCreate )
			{
				wMqLog(L"MQCreateQueue path= %s\n" ,(itpCurrentObject->getPathName()).c_str());
				
			}
			else
			{
				wMqLog(L"MQPathNameToFormatName path= %s\n" ,(itpCurrentObject->getPathName()).c_str());
			}
		}
		itpCurrentObject->CreateQ( bTryToCreate , eSetupType ,CurrentTest);
		CurrentTest.UpdateQueueParams( itpCurrentObject->getPathName(),itpCurrentObject->getFormatName(),itpCurrentObject->getQLabel());
		
	}
	
	DebugMqLog("-------------------------------------------------------------------\n");
	
	//
	// errors are handled in catch and destructor
	//

	return MSMQ_BVT_SUCC;
}

//
// cPropVar::GetMQPROPVARIANT
//
// This method assigns pointers from the MSMQ propety
// structures to the MQQUEUEPROPS structure
//
// Return value is a pointer to the private member structure.
// Since the MQCreateQueue function is a friend of this class,
// it has access to the structure to use during the API call.
//
MQQUEUEPROPS * cPropVar::GetMQPROPVARIANT ()
{
	m_QueueProps.cProp=iNumberOfProp;
	m_QueueProps.aPropID=pQueuePropID;
	m_QueueProps.aPropVar=pPropVariant;
	m_QueueProps.aStatus=hResultArray;
	return &m_QueueProps;
}

//
// cPropVar::GetMSGPRops
//
// This method assigns pointers from the MSMQ propety
// structures to the MQMSGPROPS structure
//
// Return value is a pointer to the private member structure.
// Since the MQSendMessage and MQReceiveMessage functions are friends of this class,
// they have access to the structure to use during the API call.
//
MQMSGPROPS * cPropVar::GetMSGPRops ()
{
	m_myMessageProps.cProp=iNumberOfProp;
	m_myMessageProps.aPropID=pQueuePropID;
	m_myMessageProps.aPropVar=pPropVariant;
	m_myMessageProps.aStatus=hResultArray;
	return & m_myMessageProps;
}

//
// cPropVar::cPropVar
//
// This constructor creates a buffer for the MSMQ property structures
// Input is number of properties the buffer must hold.
//
cPropVar::cPropVar ( INT iNumberOFProp ) : pQueuePropID(NULL),pPropVariant(NULL), hResultArray(NULL),iNumberOfProp(0)
{
	if ( iNumberOFProp > 0 ) // Not minus
	{
		pQueuePropID = ( QUEUEPROPID * ) malloc ( sizeof ( QUEUEPROPID ) * iNumberOFProp);
		if ( ! pQueuePropID )
		{
			throw INIT_Error( "Can't allocate memory for pQueuePropID" );
		}
		
		pPropVariant =  ( MQPROPVARIANT * ) malloc ( sizeof (MQPROPVARIANT) * iNumberOFProp );
		if ( ! pPropVariant )
		{
			throw INIT_Error("Can't allocate memory for pQueuePropID" );
		}
		hResultArray = ( HRESULT * ) malloc ( sizeof ( HRESULT ) * iNumberOFProp );
		if ( ! hResultArray )
		{
			throw INIT_Error("Can't allocate memory for pQueuePropID" );
		}
	}
}


cPropVar::~cPropVar ()
{

	//
	// bugbug - I don't know why I can't free pPropvariant
	//
	free ( pPropVariant ); 
	free ( hResultArray );
	free ( pQueuePropID );
}

//
// cPropVar:: AddProp
//
// This method adds a entries to the  MSMQ property structures
//
// Return value:  success / falied.
//

INT cPropVar:: AddProp( QUEUEPROPID cPropID , VARTYPE MQvt , const void *pValue ,DWORD dwsize )
{
    BOOL bOperationSucess = TRUE ;
	
	//
	// Look for this property in the existing PROPID array
	// reuse the entry if found.
	//
	INT iSaveIndex = -1;
	INT iPlace;
	for ( INT iIndex=0 ; iIndex < iNumberOfProp && iSaveIndex == -1 ; iIndex ++)
	{
		if ( pQueuePropID [ iIndex ] == cPropID )
			iSaveIndex = iIndex ;
	}

	//
	// If PROPID not found. Add it to the end of the array
	//
	if (iSaveIndex != -1 )
		iPlace = iSaveIndex;
	else
		iPlace = iNumberOfProp;

	//
	// Create the requested VT entry
	//
	switch (MQvt)
	{
	case VT_UI1:	{
						UCHAR * bVal=(UCHAR * )  pValue;
						pPropVariant[iPlace].vt=VT_UI1;
						if ( pValue )
							pPropVariant[ iPlace ].bVal = * bVal;
					}
					break;

	case VT_UI2:	{
						USHORT * ulVal=(USHORT * )  pValue;
						pPropVariant[iPlace].vt=VT_UI2;
						if ( pValue )
							pPropVariant[ iPlace ].ulVal = * ulVal;
					}
					break;

	case VT_UI4:	{
						ULONG * ulVal=(ULONG * )  pValue;
						pPropVariant[iPlace].vt=VT_UI4;
						if ( pValue )
							pPropVariant[ iPlace ].ulVal = * ulVal;
					}
					break;
	case VT_UI8:	{
						pPropVariant[iPlace].vt=VT_UI8;
					}
					break;
	 case VT_UI1|VT_VECTOR:
					{
						UCHAR * pwcsBuffer= (UCHAR * ) pValue;
						pPropVariant[iNumberOfProp].vt=VT_UI1|VT_VECTOR;
						if (dwsize == 0 )
							pPropVariant[iPlace].caub.cElems = sizeof (WCHAR) *( (ULONG)(wcslen ((WCHAR * )pwcsBuffer)) + 1);
						else
							pPropVariant[iPlace].caub.cElems = dwsize;

						pPropVariant[iPlace].caub.pElems= pwcsBuffer;


					}
					break;

	 case VT_LPWSTR:
					{
						WCHAR * pwcstr = (WCHAR * ) pValue ;
						pPropVariant[iPlace].vt=VT_LPWSTR;
						if ( pValue )
							pPropVariant[iPlace].pwszVal = pwcstr;
					}
					break;

	 case VT_CLSID:	{
						GUID gQtype;
						UuidFromString( (unsigned char *) pValue,&gQtype);
 						pPropVariant[iPlace].vt=VT_CLSID;
						if ( pValue )
							pPropVariant[ iPlace ].puuid = &gQtype;
					}
					break;
    default:
		bOperationSucess = FALSE;
	};


	if ( bOperationSucess && iSaveIndex == -1)
	{
	    pQueuePropID [ iNumberOfProp ] = cPropID;
		iNumberOfProp ++;
		//
		// Need to update all the vector in the Memory
		//
		m_myMessageProps.cProp=iNumberOfProp;
		m_myMessageProps.aPropID=pQueuePropID;
		m_myMessageProps.aPropVar=pPropVariant;
		m_myMessageProps.aStatus=hResultArray;
	}
	
	
	return bOperationSucess ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}

//
// cBvtUtil Installation stage
//

//
// Check the Encrypt installation type
//
EncryptType cBvtUtil::GetEncryptionType ()
{
	return m_EncryptType;
}
//
// Check the Encryption type if the machine has Enhanced Encryption support.
//
EncryptType cBvtUtil::HasEnhancedEncryption( wstring wcsMachineName )
{	
	const int iNumberOfPropId = 1;
	QMPROPID QMPropId[iNumberOfPropId];
	MQPROPVARIANT QMPropVar[iNumberOfPropId];
	MQQMPROPS QMProps = {iNumberOfPropId,QMPropId,QMPropVar,NULL};
	
	int iIndex = 0;
	QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK_ENHANCED;
	QMPropVar[iIndex].vt = VT_NULL;
	iIndex ++ ;

	HRESULT rc = MQGetMachineProperties(wcsMachineName.c_str(),NULL,&QMProps);
    if( rc == MQ_OK )
	{
		if( QMPropVar[0].vt == (VT_UI1 | VT_VECTOR )) 
		{
			MQFreeMemory(QMPropVar[0].caub.pElems);
		}
		return Enh_Encrypt;
	}
	else if ( FAILED (rc) )
	{
		int iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++ ;
		rc = MQGetMachineProperties(wcsMachineName.c_str(),NULL,&QMProps);
		if (FAILED (rc))
		{
			MqLog("MQGetMachineProperties failed to detect any encryption support 0x%x\n",rc);
		}
		else
		{
			if(QMPropVar[0].vt == (VT_UI1 | VT_VECTOR)) 
			{
				MQFreeMemory(QMPropVar[0].caub.pElems);
				return Base_Encrypt;
			}
			else
			{
				MqLog("MQGetMachineProperties return value the is not matched to the expected result(2)\n");
			}
		}
  }
  return No_Encrypt;
}

EncryptType cBvtUtil::DetectEnhancedEncrypt ()
{

		HCRYPTPROV hProv = NULL;
		char pwszContainerName[]="Eitank";

		//
		BOOL bRet = CryptAcquireContext( &hProv,
										 pwszContainerName,
										 MS_ENHANCED_PROV,
										 PROV_RSA_FULL,
										(CRYPT_MACHINE_KEYSET | CRYPT_DELETEKEYSET));
		//
		// Re-create the key container.
		//
		bRet = CryptAcquireContext( &hProv,
									pwszContainerName,
									MS_ENHANCED_PROV,
									PROV_RSA_FULL,
									(CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET));
		if (bRet)
		{
			if (!CryptReleaseContext(hProv, 0))
			{
				MqLog("Error %x during CryptReleaseContext!\n", GetLastError());
			}		
		}
		
		return  bRet ? Enh_Encrypt:Base_Encrypt;

}
//
// This Function get queue pathname and return the queue format name
//


wstring cBvtUtil::ReturnQueueFormatName ( wstring wcsQueueLabel )
{
	return AllQueuesInTheTest.ReturnQueueProp (wcsQueueLabel);

}

INT cBvtUtil::Delete ()
{
	if ( DeleteAllQueues() == MSMQ_BVT_FAILED )
	{
		return MSMQ_BVT_FAILED;
	}
	return AllQueuesInTheTest.del_all_queue();
}


wstring cBvtUtil::ReturnQueuePathName ( wstring wcsQueueLabel )
{
	return AllQueuesInTheTest.ReturnQueueProp (wcsQueueLabel, 2);
}



void cBvtUtil::dbg_PrintAllQueueInfo ()
{
	AllQueuesInTheTest.dbg_printAllQueueProp();
}


inline
void cBvtUtil::UpdateQueueParams (std::wstring wcsQueuePathName,std::wstring wcsQueueFormatName , std::wstring wcsQueueLabel )
{

	AllQueuesInTheTest.UpdateQueue ( wcsQueuePathName,wcsQueueFormatName, wcsQueueLabel);
}



//
// AmIWin9x method tried to detect win9x configuration.
//
// Return value:
// True - this is win9x
// False - other operating system
//

bool cBvtUtil::AmIWin9x ()
{
	SC_HANDLE hSCManager;
	hSCManager = OpenSCManager( "NoComputer" , NULL, GENERIC_READ );
	DWORD err= GetLastError();
	if ( err == ERROR_CALL_NOT_IMPLEMENTED )
		return TRUE;
	
	CloseServiceHandle (hSCManager);
	return FALSE;

}

//
// iAmDC method tried to detect dependent client configuration
// And retrieve the supporting server and local computer name
//


INT cBvtUtil::iAmDC ( void )
{

	
	DWORD dwType;
	HKEY  hKey;
	LONG rc = RegOpenKeyEx(
		          FALCON_REG_POS,
				  FALCON_REG_KEY,
				  0,
				  KEY_QUERY_VALUE,
				  &hKey
				  );

	if (ERROR_SUCCESS != rc)
	{
		MqLog("Can't open registry, to retrieve information about MSMQ configuration\n");
		return Configuration_Detect_Warning;
	}
	
	ULONG ulServerNameSize = MAX_MACH_NAME_LEN;
	char csRemoteMachineName[MAX_MACH_NAME_LEN + 1 ];

	rc = RegQueryValueEx(	hKey,				// handle to key to query
							RPC_REMOTE_QM_REGNAME,// address of name of value to query
							NULL,				// reserved
							&dwType,			// address of buffer for value type
							(LPBYTE) csRemoteMachineName, // address of data buffer
							&ulServerNameSize   // address of data buffer size
						);
		
	if(ERROR_SUCCESS == rc)							//ERROR_SUCCESS return = reg key exists for DC
    {
    	m_eMSMQConf = DepClient;
		m_wcsLocalComputerNetBiosName = My_mbToWideChar(csRemoteMachineName);   	
    }
	RegCloseKey(hKey);

	return Configuration_Detect;
}

//------------------------------------------------------------
// TypeDef for cluster api use for dynmic link to clusapi.dll
//

typedef HCLUSTER
(WINAPI * DefOpenCluster)
(LPCWSTR lpszClusterName );
	
typedef DWORD
(WINAPI * DefGetClusterInformation)
(HCLUSTER hCluster,LPWSTR lpszClusterName,LPDWORD lpcchClusterName,LPCLUSTERVERSIONINFO lpClusterInfo);

typedef BOOL
(WINAPI * DefCloseCluster)
(HCLUSTER hCluster);

//------------------------------------------------------------
// iAmCluster method tried to detect cluster installation,
// The function retrieve the cluster name from cluster API.
//

INT cBvtUtil::iAmCluster()
{
	
	HCLUSTER hCluster = NULL;
    DWORD    dwError  = ERROR_SUCCESS;
    DWORD    cbNameSize = MAX_MACH_NAME_LEN;
    DWORD    cchNameSize = cbNameSize;
    HMODULE  h_ClusDll;
    FARPROC  pFuncOpenCluster;
    FARPROC  pFuncGetClusterInformation;
	FARPROC  pFuncCloseCluster;

    CLUSTERVERSIONINFO ClusterInfo;
    ClusterInfo.dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);

    LPWSTR lpszClusterName = (LPWSTR) LocalAlloc( LPTR, cbNameSize );
    if( lpszClusterName == NULL )
    {
		MqLog ("LocalAlloc failed to allocate memory for the cluster name\n");
		return Configuration_Detect_Warning;
    }

	h_ClusDll = GetModuleHandle("clusapi.dll");
	if( h_ClusDll == NULL )
	{
		LocalFree( lpszClusterName );
		return Configuration_Detect;
	}

	pFuncOpenCluster = GetProcAddress(h_ClusDll,"OpenCluster");
    if (pFuncOpenCluster == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return Configuration_Detect;
	}
	
	DefOpenCluster xOpenCluster =(DefOpenCluster) pFuncOpenCluster;
	hCluster = xOpenCluster(NULL);
    if( hCluster == NULL )
	{
	    LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
	    return Configuration_Detect;
    }

	pFuncGetClusterInformation = GetProcAddress(h_ClusDll,"GetClusterInformation");
    if (pFuncGetClusterInformation == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return Configuration_Detect;
	}
	
	DefGetClusterInformation xGetClusterInformation = (DefGetClusterInformation) pFuncGetClusterInformation;
		
    dwError = xGetClusterInformation( hCluster,
                                     lpszClusterName,
                                     &cchNameSize,
                                     &ClusterInfo );
    //
    // Reallocate if the name buffer was too small
    // The cchNameSize parameter now holds the count of
    // characters in the cluster name minus the terminating NULL
    //

    if ( dwError == ERROR_MORE_DATA )
    {
        LocalFree( lpszClusterName );
		
        cchNameSize++;

		lpszClusterName = (LPWSTR) LocalAlloc( LPTR, cchNameSize );

        if( lpszClusterName == NULL )
        {
            MqLog ("LocalAlloc failed to allocate memory for the cluster name\n");
			FreeLibrary(h_ClusDll);
            return Configuration_Detect_Warning;
        }


   		dwError = xGetClusterInformation( hCluster,
                                         lpszClusterName,
                                         &cchNameSize,
                                         &ClusterInfo );
    }

    if ( dwError != ERROR_SUCCESS )
    {
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return Configuration_Detect;
    }
	
	pFuncCloseCluster = GetProcAddress(h_ClusDll,"CloseCluster");//amir
    if (pFuncCloseCluster == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
	    return Configuration_Detect;
	}
	
	DefCloseCluster xCloseCluster =(DefCloseCluster) pFuncCloseCluster;//amir
    BOOL bRes = xCloseCluster( hCluster );
	if ( bRes == FALSE )
	{
		MqLog ("CloseCluster failed with error 0x%x\n",GetLastError());
	}

    m_eMSMQConf = Cluster;
	m_wcsClusterNetBiosName=lpszClusterName;

	FreeLibrary(h_ClusDll);
    LocalFree( lpszClusterName );

    return Configuration_Detect;
}



std::wstring GetFullDNSNameEx(std::wstring wcsHostName)
/*++

	Function Description:  
 	  This function use WinSock2 API to get full DNS name for computer.
	Arguments:
		Compuetr name netbios name.
	Return code:
		return FULL DNS name.
--*/
{

	WSADATA WSAData;
    if ( WSAStartup(MAKEWORD(2,0), &WSAData) != 0)
	{
		return g_wcsEmptyString;
	}
	DWORD           dwResult;
    DWORD           dwError = NO_ERROR;
    WSAQUERYSETW    qset;
    HANDLE          hLookUp = INVALID_HANDLE_VALUE;
    DWORD           dwRespLength = 0;
    static AFPROTOCOLS afp[2] = { {AF_INET, IPPROTO_UDP}, {AF_INET, IPPROTO_TCP} };
    static GUID guidSvc =SVCID_INET_HOSTADDRBYNAME;

	memset(&qset, 0x0, sizeof(WSAQUERYSET)); 
    qset.dwSize = sizeof(WSAQUERYSET);
    qset.lpszServiceInstanceName =const_cast<WCHAR*>(wcsHostName.c_str());
    qset.lpServiceClassId = &guidSvc;
    qset.dwNameSpace = NS_ALL;
    qset.dwNumberOfProtocols = 2;
    qset.lpafpProtocols = &afp[0];

	dwResult = WSALookupServiceBeginW(&qset, LUP_RETURN_BLOB | LUP_RETURN_NAME, &hLookUp);
    if(dwResult != NO_ERROR)
    {
        dwError = WSAGetLastError();
		return g_wcsEmptyString;
    }
    dwResult = WSALookupServiceNextW(hLookUp, 0, &dwRespLength, &qset);
    dwError =  WSAGetLastError();
    if(dwError == WSAEFAULT && dwRespLength > 0)
    {
        WSAQUERYSETW * prset = (WSAQUERYSETW*)malloc(dwRespLength);
        if(prset == NULL)
        {
			printf("GetFullDNSNameEx failed to allocate memory \n");
            return g_wcsEmptyString;
        }
        dwResult = WSALookupServiceNextW(hLookUp, 0, &dwRespLength, prset);
        if(dwResult != NO_ERROR)
        {
            dwError = WSAGetLastError();
        }
        else
        {
			if( prset->lpszServiceInstanceName != NULL ) 
			{	
				wstring wcsTemp = prset->lpszServiceInstanceName;
				free(prset);
				WSACleanup ();    
				return wcsTemp;
			}
		}
		free(prset);
	}

	WSACleanup ();    
	return g_wcsEmptyString;

}

//
// GetFullDNSName method Retrieve  Full DNS Name using WinSock API
//
// Input parmeters:
// WcsHostName - Netbios name for computer name.
// Return value:
// Success - Full DNS name.
// Failed - Empty string .
//

std::wstring cBvtUtil::GetFullDNSName(std::wstring  wcsHostName)
{
    //
    // initialize winsock
    //
	if( _winmajor >= Win2K )
	{
		return GetFullDNSNameEx(wcsHostName);
	}

    WSADATA WSAData;
	WCHAR MachName[MAX_MACH_NAME_LEN];
	BOOL bFlag=TRUE;
    int iRc = WSAStartup(MAKEWORD(1,1), &WSAData);
	if (iRc)
	{
		//	Rem try to find winsock DLL
		std::cout << "GetFullDNSName function failed to find WinSock dll";
		return g_wcsEmptyString;
	}
	CHAR wcsMultiMachiNeme[MAX_MACH_NAME_LEN * 2 ];
	INT T=1;
	WideCharToMultiByte(  CP_ACP, WC_COMPOSITECHECK,  wcsHostName.c_str(),
							-1,wcsMultiMachiNeme, MAX_MACH_NAME_LEN,NULL,&T);
	struct hostent* pHost = gethostbyname(wcsMultiMachiNeme);
	WSACleanup();
	if (pHost == NULL)
		bFlag=FALSE;
    else
		MultiByteToWideChar(CP_ACP,0,pHost->h_name,-1,MachName,MAX_MACH_NAME_LEN);

	return bFlag ? (wstring)MachName:g_wcsEmptyString;
}

//
// iAmLocalUser method check if MSMQ work on local user
// Supported only in NT4 ( > Sp4 ) & W2K machines only
//
// Return value :
// True  - Local user.
// False - Domain user.
//

BOOL cBvtUtil::iAmLocalUser ()
{
	WCHAR wcsEnvSpecifyDomainName[]=L"USERDOMAIN";
	WCHAR wcsDomainNameBuffer[100]={0};
	DWORD dDomainNameBufferSize=100;
	WCHAR wcsComputerName[100]={0};
	DWORD dComputerName=100;
	GetEnvironmentVariableW(wcsEnvSpecifyDomainName,wcsDomainNameBuffer,dDomainNameBufferSize);
	GetComputerNameW(wcsComputerName,&dComputerName);
	return ! wcscmp (wcsComputerName,wcsDomainNameBuffer);
}

//
// iAmMSMQInWorkGroup method return if the machine installed as workgroup computer
//


INT cBvtUtil::iAmMSMQInWorkGroup ()
{
	HKEY pkey;
	HRESULT hResult;
	
	//
	// Open Registry to decide the type of msmqInstallation
	//
	 hResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\MSMQ\\Parameters", 0, KEY_QUERY_VALUE, &pkey);
	
	 if (hResult  != ERROR_SUCCESS )
	 {
		MqLog ("iAmMSMQInWorkGroup - Can't open registry file error :0x%x\n",hResult);
		return Configuration_Detect_Warning;
	 }
	
	 DWORD dwInstallType;
	 ULONG ulInstallTypeSize=sizeof (dwInstallType);
	 ULONG RegType=REG_DWORD;
	
	 hResult=RegQueryValueEx(pkey,"Workgroup",0, & RegType, (UCHAR * ) & dwInstallType, & ulInstallTypeSize);	
		
	 RegCloseKey(pkey);
	
	// update member varible workgroup detected.
	if ( hResult == ERROR_SUCCESS )
	{
		if ( dwInstallType == 1 )
		{
			m_eMSMQConf = WKG;
		}		
		
	}
	return Configuration_Detect;
}

//
// Ctor - Collect the computer parameters
// 1. Dep client.
// 2. Cluster name.
// 3. Machine name.
// 4. Workgroup / local user
//

cBvtUtil::cBvtUtil (std::wstring wcsRemoteComputerName,
				    const std::list<wstring> & listOfRemoteMachine,
					const std::wstring & wcsMultiCastAddress,
					BOOL bUseFullDNSName,
					SetupType eSetupType,
					BOOL bTriggers
				   )
				   : m_listOfRemoteMachine(listOfRemoteMachine),
					 m_bDeleteFullDNSQueue(false),
					 m_MuliCastAddress(wcsMultiCastAddress),
					 m_bIncludeTrigger(bTriggers)
{




	// Check the insatllation process.

	// Check if the computer is Win9x
	
	bWin95 = AmIWin9x ();

	
	m_eMSMQConf=DomainU;
	// 1. Try to detect workgroup setup.
	if ( iAmMSMQInWorkGroup () == Configuration_Detect_Warning )
		throw INIT_Error ("Workgroup detect failed");
	
    if (g_bRemoteWorkgroup)
    {
	    m_eMSMQConf = WKG;
    }
	
	
	// 2. Try to Detect domain Envirment

	if( iAmDC() == Configuration_Detect_Warning )
	   throw INIT_Error ("Dependent client failed during detect confguration");
	else if ( iAmCluster() == Configuration_Detect_Warning )
	   throw INIT_Error ("Cluster detect failed during detect confguration");
	else if ( m_eMSMQConf !=DepClient && m_eMSMQConf != Cluster )
	{
		ULONG ulMachineNameLength = MAX_MACH_NAME_LEN;
		
		CHAR csLocalComputerName [MAX_MACH_NAME_LEN+1];
		DWORD dwErrorCode = GetComputerName( csLocalComputerName , &ulMachineNameLength);
		
		if(!dwErrorCode)
		{
			throw INIT_Error("GetComputerName failed to retrive the local computer name");
		}
		else
		{
			m_wcsLocalComputerNetBiosName = My_mbToWideChar( csLocalComputerName );
		}
	}
	if( m_eMSMQConf == Cluster )
	{
		CHAR csLocalComputerName[MAX_MACH_NAME_LEN+1];
		ULONG ulMachineNameLength = MAX_MACH_NAME_LEN;
		DWORD dwErrorCode = GetComputerName( csLocalComputerName , &ulMachineNameLength);
		
		if(!dwErrorCode)
		{
			throw INIT_Error("GetComputerName failed to retrive the local computer name");
		}
		else
		{
			m_wcsLocalComputerNetBiosName = My_mbToWideChar( csLocalComputerName );
			wMqLog(L"A cluster is installed on this computer. Cluster name is %s\n", m_wcsClusterNetBiosName.c_str());
			if( m_wcsLocalComputerNetBiosName !=  m_wcsClusterNetBiosName )
			{
				wMqLog (L"Mqbvt is using computer name '%s'\n", m_wcsLocalComputerNetBiosName.c_str());
			}
		}
	
	}

	if( g_bDebug )
	{
	  wMqLog(L"Found computer NetBIOS name = %s \n",m_wcsLocalComputerNetBiosName.c_str());
	}	
	if (m_eMSMQConf != WKG )
	{
	
	   if ( iAmLocalUser() )
		{
		
		   if ( m_eMSMQConf == DepClient )
		   {
				m_eMSMQConf = DepClientLocalU;
		   }
		   else
		   {
			    m_eMSMQConf = LocalU;
		   }
	    }

	   if ( ( m_eMSMQConf != DepClientLocalU && m_eMSMQConf != DepClient )  && ! IsMSMQInstallSucceded() )
	   {
			throw INIT_Error("Failed to verify installation type");
	   }
	}

	// If Not depended client Need to check The service status.
	if ( m_eMSMQConf != DepClient && ! bWin95 && m_eMSMQConf != Cluster )
		if ( ! CheckIfServiceRuning (m_wcsLocalComputerNetBiosName,"MSMQ")  )
		{
			MqLog (" ******************************************\n");
			MqLog (" MSMQ is not currently running as a service\n");
			MqLog (" ******************************************\n");
		}

	// Get from command line arguments
	m_wcsRemoteComputerNetBiosName = wcsRemoteComputerName;

	// Retrieve full dns name using winsock API,
	// This will failed if there is problem with dns configuration on the computer,
	
	
	//
	// If machine has IPX only protocol or has problem with DNS HostName is missing
	// Mqbvt will use only NetBios name.
	//

	m_wcsLocalComputerNameFullDNSName = GetFullDNSName( m_wcsLocalComputerNetBiosName );
	if ( ! IsDnsHostNameExist(m_wcsLocalComputerNameFullDNSName) )
	{
		wMqLog ( L"Local machine full DNS name is missing \n",m_wcsLocalComputerNetBiosName);
		m_wcsLocalComputerNameFullDNSName = m_wcsLocalComputerNetBiosName;
	}
	BOOL bNeedRemoteMachine = TRUE;

	
	if ( m_wcsRemoteComputerNetBiosName != g_wcsEmptyString )
	{
		m_wcsRemoteMachineNameFullDNSName=GetFullDNSName( m_wcsRemoteComputerNetBiosName );
		if ( ! IsDnsHostNameExist(m_wcsRemoteMachineNameFullDNSName) )
		{
			wMqLog ( L"Remote machine full DNS name is missing \n",m_wcsLocalComputerNetBiosName);
			m_wcsRemoteMachineNameFullDNSName = m_wcsRemoteComputerNetBiosName;
		}
	}
	else
	{
		bNeedRemoteMachine = FALSE;
		m_wcsRemoteMachineNameFullDNSName = g_wcsEmptyString;
	}

	if ( eSetupType != ONLYSetup && m_wcsRemoteMachineNameFullDNSName == g_wcsEmptyString)
	{
		MqLog("Init Error : Remote machine is not available !! check remote machine name \n" );
	}
	if (g_bDebug)
	{
		wMqLog(L"GetHostbyname found the full dns name for the following machines:\n");
		wMqLog(L"Local machine full DNS: %s\n",m_wcsLocalComputerNameFullDNSName.c_str());
		wMqLog(L"Remote machine full DNS: %s\n",m_wcsRemoteMachineNameFullDNSName.c_str());

	}
	if ( ( m_wcsLocalComputerNameFullDNSName == g_wcsEmptyString ) || (! bNeedRemoteMachine &&  m_wcsRemoteComputerNetBiosName == g_wcsEmptyString  ))
	{
		if (bUseFullDNSName)
		{
			wMqLog( L"cBVTInit - Can't retrieve full DNS name using winsock api \n");
		}
	}


	if ( bUseFullDNSName )
	{
		m_wcsCurrentLocalMachine  = m_wcsLocalComputerNameFullDNSName;
		m_wcsCurrentRemoteMachine = m_wcsRemoteMachineNameFullDNSName;
	}
	else
	{
		m_wcsCurrentLocalMachine  = m_wcsLocalComputerNetBiosName;
		m_wcsCurrentRemoteMachine = m_wcsRemoteComputerNetBiosName;
	}

	//
	// Detect if Enhanced encrypt installed on the machine ( Win2k only )
	//

	if( eSetupType != ONLYSetup && m_eMSMQConf != WKG && _winmajor ==  Win2K )
	{
		//m_EncryptType = DetectEnhancedEncrypt ();
		if ( HasEnhancedEncryption( m_wcsCurrentLocalMachine ) == Enh_Encrypt  && HasEnhancedEncryption(m_wcsCurrentRemoteMachine) == Enh_Encrypt )
		{
			m_EncryptType = Enh_Encrypt;
		}
	}
	

	//	
	// Retreive local & Remote machine guid
	//
	// Not need in workgroup

	if ( m_eMSMQConf != WKG )
	{
		
		m_wcsMachineGuid = GetMachineID( g_wcsEmptyString );
		if( eSetupType != ONLYSetup )
		{
			m_wcsRemoteMachineGuid = GetMachineID( m_wcsCurrentRemoteMachine );
		}
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName( m_wcsLocateGuid , 2 , bWin95 );		
		}
		else
		{
			m_wcsLocateGuid = m_wcsMachineGuid;
		}
	}

}


//
// Retrieve parameter form INI file
//


INT RetriveParmsFromINIFile (wstring wcsSection,wstring wcsKey , wstring & wcsValue, wstring csFileName )
{
	const int iMaxInputStringAllow=MAX_GUID;
	WCHAR * wcsTempVal = ( WCHAR * ) malloc ( sizeof (WCHAR) * (iMaxInputStringAllow + 1 ));
	if ( ! wcsTempVal )
	{
		wMqLog (L"Can't Allocate memory at GetStrParameter\n");
		return MSMQ_BVT_FAILED;
	}
	DWORD dwString_len=GetPrivateProfileStringW( wcsSection.c_str(),wcsKey.c_str(),NULL,wcsTempVal,iMaxInputStringAllow,csFileName.c_str());
	if ( ! dwString_len )
	{
		wMqLog (L"Can't retrieve key from register\n");
		free (wcsTempVal);
		return MSMQ_BVT_FAILED;
	}
	wcsValue=wcsTempVal;
	free (wcsTempVal);
	return MSMQ_BVT_SUCC; // Strlen or Zero if didn't find the string
}

//
// My_mbToWideChar function convert from string to wstring.
//

std::wstring My_mbToWideChar( std::string csString)
{

	size_t dwStringLen = (csString.length() + 1)   * sizeof(WCHAR);
	WCHAR * wcsWideCharString = (WCHAR *) malloc ( dwStringLen );
	if( wcsWideCharString == NULL )
	{
		return g_wcsEmptyString;
	}
	if ( ! MultiByteToWideChar(CP_ACP,0,csString.c_str(),-1,wcsWideCharString,(DWORD)dwStringLen))
	{
		long lErorr = GetLastError();
		MqLog("Error converting string '%s' using MultiByteToWideChar. error:%x\n",csString.c_str(),lErorr);
		free(wcsWideCharString);
		return g_wcsEmptyString;
	}
	wstring wcsTemp = wcsWideCharString;
	free(wcsWideCharString);
	return wcsTemp;
}

//
// My_WideTOmbString function convert from wstring to string
//

std::string My_WideTOmbString( std::wstring wcsString)
{
	char * csValue;
	INT ciMaxMBlen = MAX_GUID;
	csValue = (char * ) malloc (sizeof (char) * (ciMaxMBlen + 1));
	if (! csValue )
	{
		return "Empty";
	}
	
	int ilen=WideCharToMultiByte (CP_ACP,WC_COMPOSITECHECK,wcsString.c_str (),-1,csValue,ciMaxMBlen,NULL,&ciMaxMBlen);
	if( !ilen )
	{
		free (csValue);
		return "Empty";
	}
	string wcTemp(csValue);
	free (csValue);
	return wcTemp;
}

//
// Dynamic link to MQRegisterCertificate,
// Need to use this because MQBvt need to be compatible with MSMQ 1.0.
// Inputs:
// bool bInstallType - Declare if mwregistercertificate need to work.
// dwRegisterFlag - Flag to mqregistercertificate one of MQCERT_REGISTER_ALWAYS / MQCERT_REGISTER_IF_NOT_EXIST
// returns value
// Pass / Fail


DWORD my_RegisterCertificate (bool bInstallType, DWORD dwRegisterFlag )
{
	HMODULE h_MqrtDll;
	h_MqrtDll=GetModuleHandle("MQRT.Dll");
	FARPROC pFunc;
	pFunc=GetProcAddress(  h_MqrtDll, "MQRegisterCertificate"  );
	//
	// check if the function exist
	//
	if (pFunc == NULL)
	{
		// Only for MSMQ 1.0
		return MSMQ_BVT_FAILED;
	}
	else
	{
		HRESULT Rc;
		DefMQRegisterCertificate  xMQRegisterCertificate=NULL;
		xMQRegisterCertificate=(DefMQRegisterCertificate) pFunc;
		Rc=xMQRegisterCertificate(dwRegisterFlag,NULL,0);
		
		
		FreeLibrary (h_MqrtDll);

		if (Rc != MQ_OK && Rc != MQ_INFORMATION_INTERNAL_USER_CERT_EXIST&& bInstallType == FALSE)
		{
			MqLog ("Can't Create Internal Certificate rc=0x%x\n",Rc);
			return MSMQ_BVT_FAILED;
		}
	
	}

return MSMQ_BVT_SUCC;
}


//
// GetMachineID retrieve the machine GUID for the Locate queue
// Using this for the static queues for locate operation created with label equal to the machine guid
//
// Input parameters:
// wcsRemoteMachineName - Remote machine
// If the parmers is empty that mean local machine.
//
// return value:
// Guid for the queue label.
//



wstring cBvtUtil::GetMachineID ( wstring wcsRemoteMachineName )
{
	
	  wstring wcsQmID;
	  DWORD cPropId=0;
	  const int iNumberOfProp = 1;
	  MQQMPROPS qmprops;
	  QMPROPID aQMPropId[iNumberOfProp];
	  PROPVARIANT aQMPropVar[iNumberOfProp];
	  HRESULT aQMStatus[iNumberOfProp];
	  HRESULT rc;
	  CLSID guidMachineId;
	  
	  aQMPropId[cPropId] = PROPID_QM_MACHINE_ID;
	  aQMPropVar[cPropId].vt = VT_CLSID;
	  aQMPropVar[cPropId].puuid = &guidMachineId;
	  cPropId++;
	  qmprops.cProp = cPropId;
	  qmprops.aPropID = aQMPropId;
	  qmprops.aPropVar = aQMPropVar;
	  qmprops.aStatus = aQMStatus;

	
	  const WCHAR *pMachineName = NULL;
	  if( wcsRemoteMachineName != g_wcsEmptyString )
	  {
		  pMachineName = wcsRemoteMachineName.c_str();
	  }

	  if( g_bDebug )
	  {
		  wMqLog(L"Try to retrive QMID using MQGetMachineProperties for machine %s\n",pMachineName ? pMachineName:L"NULL<LocalMachine>");
	  }

	  rc = MQGetMachineProperties(pMachineName,
								  NULL,
								  &qmprops);
	  if (FAILED(rc))
	  {
		 wMqLog(L"Failed to retrive QM ID for machine %s , using MQGetMachineProperties , error = 0x%x\n",pMachineName ? pMachineName:L"NULL<LocalMachine>",rc);
		 throw INIT_Error("Failed to retrive QM ID for machine using MQGetMachineProperties");
	  }

		
  	  UCHAR * pcsTempBuf;
	  RPC_STATUS  hr = UuidToString ( & guidMachineId , & pcsTempBuf );
	  if(hr != RPC_S_OK )
	  {
			MqLog("GetMachineID - UuidToString failed to covert guid to string return empty string \n");
			return L"";
	  }
	  wcsQmID = My_mbToWideChar( (CHAR *)pcsTempBuf );
	  RpcStringFree( &pcsTempBuf );
	  return wcsQmID;
}

//
// CheckMSMQServiceStatus method check if the MSMQ service is started
//
// Return value:
// True - MSMQ service is started.
// False - MSMQ service is stop.
//

bool cBvtUtil::CheckIfServiceRuning( wstring wcsMachineName , string csServiceName )
{
		
		
		BOOL bControlState;
		SC_HANDLE hSCManager = OpenSCManagerW( wcsMachineName.c_str() , NULL, GENERIC_READ );
		if (! hSCManager)
		{
			MqLog ("Can't open Service menager \n");
			return FALSE;
		}
		SC_HANDLE hService = OpenService( hSCManager, csServiceName.c_str() , GENERIC_READ );
		if (! hService)
		{
			CloseServiceHandle(hSCManager);
			return FALSE;	
		}
		SERVICE_STATUS  ssServiceStatus;
		bControlState = ControlService( hService, SERVICE_CONTROL_INTERROGATE, &ssServiceStatus );
		CloseServiceHandle(hSCManager);
		CloseServiceHandle(hService);
		return bControlState ? TRUE:FALSE;
}

//
// IsMSMQInstallSucceded method checks if MSMQ finish installation process.
//

bool cBvtUtil::IsMSMQInstallSucceded ()
{
				
		HKEY  hKey = NULL;
		HRESULT rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\MSMQ\\Parameters\\MachineCache", 0, KEY_QUERY_VALUE , &hKey);
		//
		// Local user can open registry
		//
		if ( rc == ERROR_ACCESS_DENIED )
		{
			return TRUE;
		}
		if (ERROR_SUCCESS != rc)
		{
			return FALSE;
		}
	    RegCloseKey(hKey);
		return TRUE;

}
//****************************************************************
//
// IsDnsHostNameExist - Check if DNSHostNameExist
// If machine has IPX only protocol or has problem with DNS HostName
// Mqbvt will use only NetBios name.
// return value
// True - exist
// False - not exist
//

bool cBvtUtil::IsDnsHostNameExist (wstring wcsRemoteMachineFullDNSname )
{
	cPropVar MyPropVar(1);
	HRESULT rc = MQ_OK;
	WCHAR wcsFormatName [BVT_MAX_FORMATNAME_LENGTH] = {0};
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	wstring wcsQueuePathName = wcsRemoteMachineFullDNSname + L"\\TestFullDnsName";
	MyPropVar.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,wcsQueuePathName.c_str());
	PSECURITY_DESCRIPTOR pSec = CreateFullControllSecDesc();
	rc = MQCreateQueue(pSec,MyPropVar.GetMQPROPVARIANT() , wcsFormatName , &ulFormatNameLength );
	delete pSec;
	if ( rc == MQ_ERROR_INVALID_OWNER )
	{
		return false;
	}
	if( rc == MQ_OK || rc == MQ_ERROR_QUEUE_EXISTS )
	{
		if( rc != MQ_OK && wcsRemoteMachineFullDNSname == m_wcsLocalComputerNameFullDNSName )
		{
			ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH;
			rc = MQPathNameToFormatName(wcsQueuePathName.c_str(),wcsFormatName,&ulFormatNameLength);
			if( SUCCEEDED( rc ))
			{	
				//
				// Remote duplicate format name from the list.
				//

				list<my_Qinfo> ::iterator it = m_listQueuesFormatName.begin();
				while(  it != m_listQueuesFormatName.end() && it->GetQFormatName() != wcsFormatName )
				{
					it ++;
				}
				if( it == m_listQueuesFormatName.end() )
				{
					my_Qinfo mQueueInfoTempObject(wcsQueuePathName,wcsFormatName,L"");
					m_listQueuesFormatName.push_back(mQueueInfoTempObject);
				}
			}
		}
		m_bDeleteFullDNSQueue = true;
	}
	return true;
}

int cBvtUtil::DeleteAllQueues ()
/*
	Clean queues that are not used directly in the test.
*/
{
	list<my_Qinfo> ::iterator it;
	for( it = m_listQueuesFormatName.begin(); it != m_listQueuesFormatName.end(); it++ )
	{
		if( g_bDebug )
		{
			wMqLog(L"cBvtUtil::DeleteAllQueues Try to delete queue pathname=%s \nFormatName:%s\n",(it->GetQPathName()).c_str(),(it->GetQFormatName()).c_str());
		}
		HRESULT rc = MQDeleteQueue( (it->GetQFormatName()).c_str() );
		if ( rc != MQ_OK && rc != MQ_ERROR_QUEUE_NOT_FOUND )
		{
			wMqLog(L"cBvtUtil::DeleteAllQueues failed to delete queue %s\n",(it->GetQFormatName()).c_str() );
			ErrHandle ( rc,MQ_OK,L"MQDelete queue failed");
		}
	}
	return MSMQ_BVT_SUCC;
}




BOOL cBvtUtil::iamWorkingAgainstPEC()
{
	HKEY  hKey = NULL;
	LONG rc = RegOpenKeyEx(
						    FALCON_REG_POS,
						    FALCON_REG_KEY,
							0,
							KEY_QUERY_VALUE,
							&hKey
							);

	if (ERROR_SUCCESS != rc)
	{
		MqLog("Can't open registry, to retrieve information about MSMQ configuration\n");
		return Configuration_Detect_Warning;
	}
	
	ULONG ulBufSize = 4;
	byte pBufValue[4];
	DWORD dwType = 0;
	rc = RegQueryValueEx(	hKey,				// handle to key to query
							MSMQ_DS_ENVIRONMENT_REGNAME,// address of name of value to query
							NULL,				// reserved
							&dwType,			// address of buffer for value type
							(LPBYTE) pBufValue, // address of data buffer
							&ulBufSize   // address of data buffer size
						);
	RegCloseKey(hKey);	
	if( rc == ERROR_SUCCESS  && dwType == REG_DWORD && *pBufValue == MSMQ_DS_ENVIRONMENT_MQIS )
	{
		if( g_bRunOnWhistler && g_bDebug )
		{
			MqLog("--- Found windows XP installed in MQIS Enterprise ----\n");
		}
		return true;
	}
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqbvtse.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   simple.c
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\simple, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//              
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  Changed by:Eitank for Mqbvt
//


#include <tchar.h>
#include "msmqbvt.h"
#include "service.h"
using namespace std;

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;


//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//
INT WINAPIV main( INT argc , CHAR ** argv);
int RebuildCommandLineArguements ( int * iArgumentCount , char *** argv , char * csCommandLineArgument );

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szIn[80];
    TCHAR                   szOut[80];
    LPTSTR                  lpszPipeName = TEXT("\\\\.\\pipe\\simple");
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    // allow user tp define pipe name
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {

        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }

    }

    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE) {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
	
					


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0))                    // wait hint
        goto cleanup;

    //
    // End of initialization
    //
    ////////////////////////////////////////////////////////
//************************************************************************* //

    ////////////////////////////////////////////////////////
    //
    // Service is now running, perform work until shutdown
    //
	if ( ! SetStdHandle( STD_OUTPUT_HANDLE , hPipe ))
	{
	/*	HANDLE hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

//        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
		const char * lpszStrings="RO";
        //szStrings[0] = szMsg;
        //szStrings[1] = lpszMsg;

        if (hEventSource != NULL) {
     							ReportEvent(hEventSource, // handle of event source
								EVENTLOG_ERROR_TYPE,  // event type
								0,                    // event category
								0,                    // event ID
								NULL,                 // current user's SID
								2,                    // strings in lpszStrings
								0,                    // no bytes of raw data
								lpszStrings, // array of error strings
								NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);  */
     }
	wcsFileName = L"ServiceLog.log";
    for(;;)
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

       
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
	
				
		char ** ppcsMainArgv=NULL;
		int iArgc=0;
		int iRes = RebuildCommandLineArguements (&iArgc , &ppcsMainArgv , szIn );
		if ( iRes == MSMQ_BVT_SUCC )
		{
			int y = main ( iArgc , ppcsMainArgv );
			if ( y == MSMQ_BVT_SUCC )
			{
				_stprintf(szOut, TEXT("Mqbvt Pass"));
			}
			else
			{
				_stprintf(szOut, TEXT("Mqbvt failed"));
			}		
		}

		//
		// Need to return Pass or failed client need to wait..
		//
        
		bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }

  cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}


//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//    
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}

//*****************************************************************
// RebuildCommandLineArguements - 
// This function get string and build from that argc,argv argument.
//


int RebuildCommandLineArguements ( int * iArgumentCount , char *** pppargv , char * csCommandLineArgument )
{

	char *p=csCommandLineArgument;
	string cspTemp=p;
	size_t pos=1;
	char ** argv;
	
	for ( (*iArgumentCount) = 0; pos !=0 ; (*iArgumentCount)++)
	{
		
		pos = cspTemp.find_first_of("/") + 1;
		if (pos != 0 )
		{
			cspTemp = cspTemp.substr(pos);
		}
	}
	
	
	argv = (char ** ) malloc (sizeof (char * ) * (*iArgumentCount));
	if (argv == NULL )
	{
		return MSMQ_BVT_FAILED;
	}
	argv[0]=NULL;
	
	char * t;
	t=p;
	
	char token[] = " /";
	t = strtok ( p ,token);

	for (int i=1; i < *iArgumentCount ; i ++ )
	{
		char csTemp[255];
		strcpy (csTemp,"-");
		strcat (csTemp,t);
		argv[i]= (char * ) malloc (sizeof (char) * (strlen (csTemp) + 1));
		if ( *argv[i] == NULL )
		{
			return MSMQ_BVT_FAILED;
		}
		strcpy( argv[i] , csTemp );
		t = strtok ( NULL ,token);
	}
	*pppargv =  argv;
return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqdlrt.h ===
#ifndef _MQDLRT
#define _MQDLRT
	#include <windows.h>
	#include <string>

	typedef enum MQDlTypes
	{	
		MQ_GLOBAL_GROUP	= 0x2,
		MQ_DOMAIN_LOCAL_GROUP = 0x4,
		MQ_UNIVERSAL_GROUP	= 0x8,
	};
					
	/*++ 
		Function Description:
		
		  MQCreateDistList - Create distribution list and return distribution list object GUID.
		
		Arguments:
			
		   pwcsContainerDnName - DL continer name.
		   pwcsDLName - New DL Name.
		   pSecurityDescriptor - pointer to SD.
		   lpwcsFormatNameDistList 
		   lpdwFormatNameLength
		
		Return code:
			
			 HRESULT 
			
	--*/
	HRESULT
	APIENTRY
	MQCreateDistList(
					 IN LPCWSTR pwcsContainerDnName,
					 IN LPCWSTR pwcsDLName,
					 IN MQDlTypes eCreateFlag,
					 IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   					 OUT LPWSTR lpwcsFormatNameDistList,
					 IN OUT LPDWORD lpdwFormatNameLength
					);

					
	/*++ 
		Function Description:
		
		  Delete DL object.
		
		Arguments:
			
			lpwcsFormatNameElem - DL format name.

		Return code:
			
			 HRESULT 
			
	--*/
	HRESULT
	APIENTRY
	MQDeleteDistList(
						IN LPCWSTR lpwcsFormatNameElem
					);

				
	/*++ 
		Function Description:	
			MQAddElementToDistList - add queue guid to the DL object.
		Arguments:
			lpwcsFormatNameElem - DL GUID
			lpwcsFormatNameDistList - DL GUID
		Return code:
			HRESULT 
	--*/

	HRESULT
	APIENTRY
	MQAddElementToDistList(
							IN LPCWSTR lpwcsFormatNameDistList,
							IN LPCWSTR lpwcsFormatNameElem
						  );

	/*++ 
		Function Description:	
			MQRemoveElementFromDistList - add queue guid to the DL object.
		Arguments:
			lpwcsFormatNameElem - DL GUID
			lpwcsFormatNameDistList - DL GUID
		Return code:
			HRESULT 
	--*/
	HRESULT
	APIENTRY
	MQRemoveElementFromDistList(
						  		  IN LPCWSTR lpwcsFormatNameDistList,
								  IN LPCWSTR lpwcsFormatNameElem
							   );

	/*++ 
		Function Description:	

			MQGetDistListElement - add queue guid to the DL object.

		Arguments:
			lpwcsFormatNameDistList - DL GUID
			pwcsElementsFormatName - DL GUID
			lpdwFormatNameLength
		Return code:
			HRESULT 
	--*/

	HRESULT
	APIENTRY
	MQGetDistListElement(
						  IN LPCWSTR lpwcsFormatNameDistList,
	  					  OUT LPWSTR pwcsElementsFormatName,
						  IN OUT LPDWORD lpdwFormatNameLength
						 );



	HRESULT
	APIENTRY
	MQCreateAliasQueue (
						IN LPCWSTR pwcsContainerDnName,
						IN LPCWSTR pwcsAliasQueueName,
						IN LPCWSTR pwcsFormatName,
						std::wstring & wcsADsPath
						);




	HRESULT
	APIENTRY
	MQDnNameToFormatName(
						  IN LPCWSTR lpwcsPathNameDistList,  
						  OUT LPWSTR lpwcsFormatNameDistList,
						  IN OUT LPDWORD lpdwFormatNameLength
						 );


	HRESULT
	APIENTRY
	MQDeleteAliasQueue(	IN LPCWSTR lpwcsAdsPath );

#endif //_MQDLRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqdlimp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqDLimp.cpp

Abstract:

	Contain a function that manipulate DL objects,
		
Author:

  Eitan klein (EitanK)  5-Sep-2000

Revision History:

--*/


#include "msmqbvt.h"
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <mq.h>
using namespace std;
#include "mqdlrt.h"

#define MQ_DL_PREFIX L"DL="
#define MQ_ALIAS_OBJECT L"MSMQ-Custom-Recipient"
#define LDAP_GUID_FORMAT L"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
#define LDAP_GUID_PREFIX L"LDAP://<GUID="
#define LDAP_PREFIX L"LDAP://"
#define LDAP_GUID_SUFFIX L">"
#define LDAP_PRINT_GUID_ELEMENTS(p)	\
	p[0],  p[1],  p[2],  p[3],	\
	p[4],  p[5],  p[6],  p[7],	\
	p[8],  p[9],  p[10], p[11],	\
	p[12], p[13], p[14], p[15]

#define LDAP_SCAN_GUID_ELEMENTS(p)	\
	p,		p + 1,	p + 2,	p + 3,	\
	p + 4,	p + 5,	p + 6,	p + 7,	\
	p + 8,	p + 9,	p + 10, p + 11,	\
	p + 12, p + 13, p + 14, p + 15


#define MQ_ERROR_OBJECT_NOT_FOUND 1



static GUID FnpString2Guid(LPCWSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = swscanf(
						GuidStr,
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);    
	if( nFields == 16 )
	{
	
		for(size_t i = 0; i < 16; i++)
		{
			((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
		}
	}
	return Guid;
}

const wstring ConvertFromADGuidToMSMQGuidFormat(const WCHAR * pwcsAdGuid)
/*++ 
	Function Description:
		Convert from AD guid format to MSMQ guid format name  
	Arguments:
		 pwcsMSMQGuidFormat - pointer to string contain MSMQ guid Format name.
	Return code:
		  String that contain the DN format name.
		
--*/
{
	    wstring wcsQueueGuid=L"";
		GUID uuid = FnpString2Guid(pwcsAdGuid);
		WCHAR * pwcsTempBuffer=NULL;
		if ( UuidToStringW(&uuid,&pwcsTempBuffer) == RPC_S_OK )
		{
			wcsQueueGuid = pwcsTempBuffer;
			RpcStringFreeW(&pwcsTempBuffer);
		}
		return wcsQueueGuid;

}


const wstring ConvertFromMSMQGUIDFormatToAdGuidFormat(const WCHAR * pwcsMSMQGuidFormat )
/*++ 
	Function Description:
		Convert from MSMQ guid format to DS format name  
	Arguments:
		 pwcsMSMQGuidFormat - pointer to string contain MSMQ guid Format name.
	Return code:
		  String that contain the DN format name.
		
--*/
{

	UUID pGuid={0};
	HRESULT hr = UuidFromStringW(const_cast <WCHAR *>(pwcsMSMQGuidFormat),&pGuid);
	if( hr != RPC_S_OK )
	{
		SetLastError(hr);
		return L"";
	}
	WCHAR ADsQueuePath[MAX_PATH]={0};
	_snwprintf(	ADsQueuePath,MAX_PATH,LDAP_GUID_FORMAT,
				LDAP_PRINT_GUID_ELEMENTS(((BYTE*)&pGuid)));
	return ADsQueuePath;
}


const wstring ConvertFromDNNameToDotDomainName(LPCWSTR wcsFullDotDnName )

/*++ 
	Function Description:
	  
		Convert from microsoft.com to DC=Microsoft,DC=Com.
	  
	Arguments:
			
	Return code:
		string that contain the full DN name or an empty string.
		
--*/
{
	if(!wcsFullDotDnName)
	{
		return L"";
	}
	wstring wcsObjectDnName = wcsFullDotDnName;
	wstring wcsDomainDotName=L"";
	size_t iPos=0;
	do 
	{
		iPos = wcsObjectDnName.find(L"DC=");
		wcsObjectDnName = wcsObjectDnName.substr(iPos+3,wcsObjectDnName.length());
		iPos = wcsObjectDnName.find_first_of(L",");
		wcsDomainDotName += wcsObjectDnName.substr(0,iPos);
		if (iPos != -1 )
		{
			wcsDomainDotName += L".";
		}
	}
	while(iPos != -1);
	return wcsDomainDotName;
}

/*++ 
	Function Description:
	
	  MQCreateDistList - Create distribution list and return distribution list object GUID.
	
	Arguments:
		
	   pwcsContainerDnName - DL continer name.
	   pwcsDLName - New DL Name.
	   pSecurityDescriptor - pointer to SD.
	   lpwcsFormatNameDistList 
	   lpdwFormatNameLength
	
	Return code:
		
		 HRESULT 
		
--*/



HRESULT
APIENTRY
MQCreateDistList(
					IN LPCWSTR pwcsContainerDnName,
					IN LPCWSTR pwcsDLName,
					MQDlTypes eCreateFlag,
					IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   					OUT LPWSTR lpwcsFormatNameDistList,
					IN OUT LPDWORD lpdwFormatNameLength
					)
{
	//
	// Currently is not implemented
	// 
	UNREFERENCED_PARAMETER(pSecurityDescriptor);
	assert(pSecurityDescriptor==NULL);
	if( !pwcsContainerDnName || ! pwcsDLName || !lpwcsFormatNameDistList )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}

	wstring wcsContainerPathName = LDAP_PREFIX;
	wcsContainerPathName += pwcsContainerDnName;

	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPathName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if(FAILED(hr))
	{
		SetLastError(hr);
		return hr;
	}
	//
	// First, bind to the parent container
	//
	wstring wcsGroupDnName=L"CN=";
	wcsGroupDnName+=pwcsDLName;

	IADsGroup * pGroup = NULL;
	hr = pContainer->Create(L"group",const_cast <WCHAR *>(wcsGroupDnName.c_str()),(IDispatch **)&pGroup);
	pContainer->Release();
	if( FAILED (hr))
	{
		return hr;
	}
	_variant_t vGroupName(pwcsDLName);
	VARIANT  vGroupType;
	vGroupType.vt=VT_UI4;
	vGroupType.lVal = eCreateFlag;
	pGroup->Put( L"sAMAccountName",vGroupName );
	pGroup->Put( L"groupType",vGroupType );
	hr = pGroup->SetInfo ();
	if(FAILED(hr))
	{
		MqLog("pGroup->SetInfo failed in MQCreateDistList 0x%x\n",hr);
		return hr;
	}
	
	// 
	// Need to return the attribute 
	//
	BSTR bsObjectGuid=L"";
	hr = pGroup->get_GUID(&bsObjectGuid);
	pGroup->Release();
	if (FAILED(hr))
	{
		return hr;
	}
	wstring wcsFullObjectName = (wstring)LDAP_GUID_PREFIX + bsObjectGuid + LDAP_GUID_SUFFIX;
	hr = MQDnNameToFormatName(wcsFullObjectName.c_str(),lpwcsFormatNameDistList,lpdwFormatNameLength);
	if(FAILED(hr))
	{
		MqLog("MQADsPathToFormatName failed to retrive DL format name error 0x%x\n",hr);
		return hr;
	}
	if( g_bDebug )
	{
		wMqLog(L"DL format name is %s\n",lpwcsFormatNameDistList);
	}
	SysFreeString(bsObjectGuid);	
	
	return hr;
}




int ParseDLGuidString(	const wstring wcsDistListFormatName,
						wstring & wcsActiveDGuidFormat,
						wstring & wcsDomainScope
					  )
{
	
		wstring wcsTemp=L"";
		size_t iPos = wcsDistListFormatName.find_first_of(L"=");
		if( iPos == -1 )
		{
			return 1;
		}

		wcsTemp = wcsDistListFormatName.substr(iPos+1,wcsDistListFormatName.length());

		iPos = wcsTemp.find_first_of(L"@");
		if(iPos != -1)
		{
			wcsActiveDGuidFormat=wcsTemp.substr(0,iPos);
		}
		else
		{
			wcsActiveDGuidFormat=wcsTemp;
		}
		wcsDomainScope =L"";
		if(iPos != 0 )
		{
			wstring wcsp=wcsTemp.substr(iPos+1,wcsTemp.length());		
			do
			{
				wcsDomainScope += L"DC=";
				iPos = wcsp.find_first_of(L".");
				wcsDomainScope += wcsp.substr(0,iPos);
				wcsp = wcsp.substr(iPos+1,wcsp.length());
				if( iPos != -1 )
				{
					wcsDomainScope += L",";
				}			
			}
			while(iPos != -1 );
		}
		wcsActiveDGuidFormat = ConvertFromMSMQGUIDFormatToAdGuidFormat(wcsActiveDGuidFormat.c_str());
	return MQ_OK;	
}


HRESULT BindGuidAndReturnFullDnName( LPCWSTR pcwcsGuidPath, 
									 wstring & wcsFullDNPath )
{

	wstring wcsGuidDnPath = LDAP_GUID_PREFIX;
	wcsGuidDnPath += pcwcsGuidPath;
	wcsGuidDnPath += LDAP_GUID_SUFFIX;

	IADs * pIADS=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsGuidDnPath.c_str()),IID_IADs,(void **)&pIADS);
	if(FAILED(hr))
	{
		return hr;
	}
	
	VARIANT  vObjectDisName;
 	hr = pIADS->Get(L"distinguishedName",&vObjectDisName);
	pIADS->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	wcsFullDNPath = vObjectDisName.bstrVal;
	VariantClear(&vObjectDisName);
	return MQ_OK;

}


HRESULT
APIENTRY
MQDeleteDistList(
					IN LPCWSTR lpwcsFormatNameElem
				)
{

	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameElem,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	//
	// Convert the GUID To AD format
	// 
	
	wstring wcsGuidDnPath = LDAP_GUID_PREFIX;
	wcsGuidDnPath += wcsDistListGuidPath;
	wcsGuidDnPath += LDAP_GUID_SUFFIX;
	IADs * pIADS=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsGuidDnPath.c_str()),IID_IADs,(void **)&pIADS);
	if(FAILED(hr))
	{
		return hr;
	}
	
	VARIANT  vObjectDisName;
 	hr = pIADS->Get(L"distinguishedName",&vObjectDisName);
	if(FAILED(hr))
	{
		pIADS->Release();
		return hr;
	}
	
	
	VARIANT  vObjectName;
	hr = pIADS->Get(L"Name",&vObjectName);
	pIADS->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	
	wstring wcsTempObjectDN = vObjectDisName.bstrVal;
	wstring wcsToken = L",";
	VariantClear(&vObjectDisName);
	
	wstring wcsGroupCnName = L"CN=";
	wcsGroupCnName +=vObjectName.bstrVal;
	VariantClear(&vObjectName);

	size_t iPos = wcsTempObjectDN.find_first_of(wcsToken);
	if( iPos == 0 )
	{
		return MQ_ERROR_OBJECT_NOT_FOUND;
	}
	//
	// Bind to the parent container
	// 
	wcsTempObjectDN = wcsTempObjectDN.substr(iPos+1,wcsTempObjectDN.length());
	wstring wcsParentDnName = LDAP_PREFIX;
	wcsParentDnName += wcsTempObjectDN;
	IADsContainer * pContainer=NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsParentDnName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if( FAILED(hr))
	{
		return hr;
	}
	//
	// Delete the container object.
	// 
	hr = pContainer->Delete(L"group",const_cast <WCHAR *>(wcsGroupCnName.c_str()));
	pContainer->Release();
	return hr;
}


HRESULT	 ConvertFromQueueGuidToDistList( IN LPCWSTR lpwcsFormatNameElem, 
									     wstring & wcsActiveDFormatName 
					  				   )
/*++ 
	Function Description:	
		ConvertFromQueueGuidToDistList - 
		Translate GUID from MSMQ format to AD format
	Arguments:
		lpwcsFormatNameElem - MSMQ style
		wcsActiveDFormatName - AD style
	Return code:
	    ERROR Code
--*/
{
	//
	// Remove public= 
	// 
	wstring wcsQueueFormatName = lpwcsFormatNameElem;
	size_t iPos = wcsQueueFormatName.find_first_of(L"=");
	if( iPos == 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}

	wcsQueueFormatName = wcsQueueFormatName.substr(iPos+1,wcsQueueFormatName.length());
	wcsActiveDFormatName = ConvertFromMSMQGUIDFormatToAdGuidFormat(wcsQueueFormatName.c_str());
	return MQ_OK;
}
/*++ 
	Function Description:	
		MQAddElementToDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/

HRESULT
APIENTRY
MQAddElementToDistList(
							IN LPCWSTR lpwcsFormatNameDistList,
							IN LPCWSTR lpwcsFormatNameElem
					  )
/*++ 
	Function Description:	
		MQAddElementToDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/
{

	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameDistList,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsQueueFormatName=L"";
	if( ConvertFromQueueGuidToDistList(lpwcsFormatNameElem,wcsQueueFormatName) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsTemp=L"";
	HRESULT hr = BindGuidAndReturnFullDnName(wcsQueueFormatName.c_str(),wcsTemp);
	if(FAILED(hr))
	{
		return hr;
	}
	wstring wcsQueueFullDnName = LDAP_PREFIX + wcsTemp;

	wstring wcsGroupGuidAdPath = LDAP_GUID_PREFIX + wcsDistListGuidPath + LDAP_GUID_SUFFIX;
	//
	// bind to the group element.
	//
	IADsGroup * pGroup = NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsGroupGuidAdPath.c_str()),IID_IADsGroup,(void**)&pGroup);
	if(FAILED(hr)) 
	{
		return hr;
	}
	hr = pGroup->Add(const_cast <WCHAR *>(wcsQueueFullDnName.c_str()));
	pGroup->Release();
	return hr;
}




HRESULT
APIENTRY
MQDnNameToFormatName(
								  IN LPCWSTR lpwcsPathNameDistList,  
								  OUT LPWSTR lpwcsFormatNameDistList,
								  IN OUT LPDWORD lpdwFormatNameLength
							  )

/*++ 
	Function Description:	
		MQDistListToFormatName convert ADSPath to MSMQ format name.
	Arguments:
		lpwcsPathNameDistList - DL in DN format name.
	Return code:
	    lpwcsFormatNameDistList contain the format name.
		lpdwFormatNameLength contains the formant name length.

--*/
{
	try 
	{
		AutoFreeLib cMqrt("Mqrt.dll");
		DefMQADsPathToFormatName pfMQADsPathToFormatName = (DefMQADsPathToFormatName) GetProcAddress( cMqrt.GetHandle() ,"MQADsPathToFormatName");
		if ( pfMQADsPathToFormatName == NULL )
		{
			MqLog("Mqbvt failed to GetProcAddress MQADsPathToFormatName proc address \n");
			return MQ_ERROR;
		}
		return pfMQADsPathToFormatName(lpwcsPathNameDistList,lpwcsFormatNameDistList,lpdwFormatNameLength);
	}
	catch( INIT_Error & err )
	{
		UNREFERENCED_PARAMETER(err);
		MqLog("Failed to load mqrt.dll error 0x%x\n",GetLastError());
		return MQ_ERROR;
	}
}


/*++ 
	Function Description:	
		MQRemoveElementFromDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/
HRESULT
APIENTRY
MQRemoveElementFromDistList(
						  	  IN LPCWSTR lpwcsFormatNameDistList,
							  IN LPCWSTR lpwcsFormatNameElem
							 )
{
	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameDistList,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsQueueFormatName=L"";
	if( ConvertFromQueueGuidToDistList(lpwcsFormatNameElem,wcsQueueFormatName) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsTemp=L"";
	HRESULT hr = BindGuidAndReturnFullDnName(wcsQueueFormatName.c_str(),wcsTemp);
	if(FAILED(hr))
	{
		return hr;
	}
	wstring wcsQueueFullDnName = LDAP_PREFIX + wcsTemp;

	//
	// bind to the group element.
	//
	wstring wcsGroupGuidAdPath = LDAP_GUID_PREFIX + wcsDistListGuidPath + LDAP_GUID_SUFFIX;
	IADsGroup * pGroup = NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsGroupGuidAdPath.c_str()),IID_IADsGroup,(void**)&pGroup);
	if(FAILED(hr)) 
	{
		return hr;
	}
	hr = pGroup->Remove(const_cast <WCHAR *>(wcsQueueFullDnName.c_str()));
	pGroup->Release();
	return hr;
}




HRESULT
APIENTRY
MQCreateAliasQueue (
					IN LPCWSTR pwcsContainerDnName,
					IN LPCWSTR pwcsAliasQueueName,
					IN LPCWSTR pwcsFormatName,
					std::wstring & wcsADsPath
					)

/*++ 
	Function Description:	
		MQCreateAliasQueue - create an alias queue in the AD
	Arguments:
		
	Return code:
	    HRESULT 
--*/
{

	if( !pwcsContainerDnName || ! pwcsAliasQueueName )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wstring wcsContainerPathName = LDAP_PREFIX;
	wcsContainerPathName += pwcsContainerDnName;

	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPathName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if(FAILED(hr))
	{
		return hr;
	}
	//
	// First, bind to the parent container
	//
	wstring wcsGroupDnName=L"CN=";
	wcsGroupDnName += pwcsAliasQueueName;

	IADs * pIAds = NULL;
	hr = pContainer->Create(MQ_ALIAS_OBJECT,const_cast <WCHAR *>(wcsGroupDnName.c_str()),(IDispatch **)&pIAds);				  
	pContainer->Release();
	if( FAILED (hr))
	{
		return hr;
	}

	_variant_t vAliasQueueMapTo(pwcsFormatName);
	pIAds->Put( L"MSMQ-Recipient-FormatName",vAliasQueueMapTo );		   
	hr = pIAds->SetInfo ();
	if(FAILED(hr))
	{
		if( g_bDebug )
		{
			MqLog("pIAds->SetInfo failed in MQCreateAliasQueue 0x%x\n",hr);
		}
		return hr;
	}


	BSTR bsObjectAdsPath=L"";
	hr = pIAds->get_ADsPath(&bsObjectAdsPath);
	pIAds->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	wcsADsPath = bsObjectAdsPath;
	SysFreeString(bsObjectAdsPath);
	return hr;
}

HRESULT
APIENTRY
MQDeleteAliasQueue(	IN LPCWSTR lpwcsAdsPath )
/*++ 
	Function Description:	
		Delete queue alias from directory service
	Arguments:
		lpwcsAdsPath ADsPath
	Return code:
	    HRESULT 
--*/
{

	wstring wcsAliasQueueName = lpwcsAdsPath;
	size_t iPos = wcsAliasQueueName.find_first_of(L",");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wstring wcsTemp = wcsAliasQueueName.substr(iPos+1,wcsAliasQueueName.length());
	wstring wcsContainerPath = LDAP_PREFIX;
	wcsContainerPath += wcsTemp;
	iPos = wcsAliasQueueName.find_first_of(L",");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wcsTemp = wcsAliasQueueName.substr(0,iPos);
	//
	// remove LDAP://
	// 
	iPos = wcsTemp.find_last_of(L"/");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wcsTemp = wcsTemp.substr(iPos+1,wcsTemp.length());
	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPath.c_str()),IID_IADsContainer,(void **)&pContainer);
	if( FAILED(hr))
	{
		return hr;
	}
	//
	// Delete the container object.
	// 
	hr = pContainer->Delete(MQ_ALIAS_OBJECT,const_cast <WCHAR *>(wcsTemp.c_str()));
	if( FAILED(hr))
	{
		return hr;
	}
	pContainer->Release();
	return hr;
}
HRESULT
APIENTRY
MQSetAliasQueueElem( 
					IN LPCWSTR pwcsAliasQueueName,
					IN LPCWSTR pwcsFormatName
					)
/*++ 
	Function Description:	
		
		  Update queue alias properites,

	Arguments:
		
	Return code:
	    HRESULT 
--*/
{

	IADs * pIAds=NULL;
	HRESULT hr = ADsGetObject(pwcsAliasQueueName,IID_IADs,(void **)&pIAds);
	if(FAILED(hr))
	{
		return hr;
	}
	_variant_t vAliasQueueMapTo(pwcsFormatName);
	pIAds->Put(L"MSMQ-Recipient-FormatName",vAliasQueueMapTo);
	hr = pIAds->SetInfo();
	if(FAILED(hr))
	{
		MqLog("pIAds->SetInfo  failed in MQSetAliasQueueElem 0x%x\n",hr);
		return hr;
	}

	pIAds->Release();
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqf.h ===
#ifndef __MQF

#include "msmqbvt.h"
/*
1. Tests scenarions.
2. Locate all the relevents formatnames.
3. Send messages using the mqf format name.

Result check
4. Recive ack reach queue for dest queue name.
5. Consume the messages and receive ack.
6. Check the jornal queue if the message are there.

All these need for transcotinal and re
*/
using namespace std;
typedef std::map<std::wstring,std::wstring> mTable;
typedef std::list<my_Qinfo> liQueues;
typedef std::list<my_Qinfo> ::iterator itliQueues;
#pragma warning(disable:4786)
#include "errorh.h"
#define MQBVTMULTICASTADDRESS L"255.255.0.1:1805"

typedef enum _PubType
{
	pub_DL = 0,
	pub_MqF,
	pub_multiCast
} PubType;

#define PGM_PORT L":1972"

class MqDl:public cTest
{
	public:	
		MqDl( const INT iIndex,
			  std::map<std::wstring,std::wstring> Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration,
			  PubType ePubType 
			 );
		virtual ~MqDl() = 0;
		void Description();
		INT Start_test();
		INT CheckResult(); 
	protected:
		std::wstring m_wcsAdminQueueFormatName; // destination admin format name.
		std::list<wstring> m_MachineList;		// machines list.
		liQueues m_QueueInfoList;
		void LocateDestinationQueues();
		void dbgSendMessage();
		void CreateMqFormatName();
		std::wstring wcsMqFFormatName;
		std::wstring m_wcsGuidMessageLabel2;
		std::wstring m_wcsPublicAdminQueue;
	private:
		void operator = (const MqDl & Csrc );
		PubType m_ePubType;
		void LocateQueuesOnSpecificMachine(const std::wstring & wcsLookupInformation , bool bSearchInAD );
		InstallType m_eMachineCobfiguration;
		const int m_iNumberOfQueuesPerMachine;
		void dbgPrintListOfQueues( const liQueues & pList);
		bool m_bSearchForQueues;
};	
 
class MqF:public MqDl
{
	public:
		~MqF ();
		MqF ( const INT iIndex, 
			  const mTable & Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration,
			  bool bWkg
			 );
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		void operator = ( MqF & cDRC );
		bool m_bWorkgroup;
		
};


class cSendUsingDLObject:public MqDl
{
	public:
		~cSendUsingDLObject ();
		 cSendUsingDLObject ( const INT iIndex, 
							  mTable & Tparms,
							  const list<wstring> &  ListOfMachine,
							  const InstallType eMachineConfiguration
							 );

		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		void operator = (cSendUsingDLObject & );
		void AddMemberToDlObject();
		void GetCurrentDomainName();
		std::wstring m_wcsDistListFormatName;
		std::wstring m_wcsCurrentDomainName;
		std::wstring m_wcsAdminDestFormatName;
		std::wstring m_wcsQueueAliasFormatName;
		bool bCheckAliasQueue;
};


class CMultiCast:public MqDl
{
	public:
		~CMultiCast ();
		CMultiCast ( const INT iIndex, 
					 mTable & Tparms,
					 const list<wstring> &  ListOfMachine,
					 const InstallType eMachineConfiguration
				   );

		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:	
		void operator = ( CMultiCast & );
		wstring CreateMultiCastFormatName();
		wstring m_wcsMultiCastAddress;
		wstring m_wcsAdminMultiCastAddress;
		
};



#endif __MQF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqf.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Mqf.cpp

Abstract:
	      Send message using Mqf format name
Author:
    
	  Eitan klein (EitanK)  8-May-2000

Revision History:

--*/

#include "msmqbvt.h"
#include "mqdlrt.h"
#include <iads.h>
#include <adshlp.h>
#include <oleauto.h>
using namespace std;
#include "mqf.h"
using namespace MSMQ;

extern BOOL g_bRunOnWhistler;
/*
1. Tests scenarions.
2. Locate all the relevents formatnames.
3. Send messages using the mqf format name.

Result check
4. Recive ack reach queue for dest queue name.
5. Consume the messages and receive ack.
6. Check the jornal queue if the message are there.

All these need for transcotinal and re

*/
#pragma warning(disable:4786)
const int g_ciMachineQueues =3;




void
MqDl::dbgPrintListOfQueues( 
						   const liQueues & pList
						  )
/*++


  
	Function Description:

		Debug function dump list of my_Qinfo to output
		use for debug infotmation 

	Arguments:
		None
	Return code:
		None

	
--*/
{
	itliQueues pq = pList.begin();
	wMqLog(L"Dump list of my_Qinfo information - \n");
	for(;pq != pList.end();pq++)
	{
		wstring qcsTempQueuePathName = pq->GetQPathName();
		wMqLog(L"QPath=%s\n",qcsTempQueuePathName.c_str());
	}

}


MqDl::MqDl( const INT iIndex ,
			std::map<wstring,wstring> Tparms,
			const list<wstring> &  ListOfMachine,
			const InstallType eMachineConfiguration,
			PubType ePubType 
		   ):
			m_iNumberOfQueuesPerMachine( g_ciMachineQueues ),
		    cTest(iIndex),
			m_MachineList(ListOfMachine),
			m_eMachineCobfiguration(eMachineConfiguration),
			m_ePubType(ePubType),
			m_bSearchForQueues(true)

/*++
	
	  

	Function Description:
	
		constructor

	Arguments:
		  iIndex - test id
		  Tparms - specific test argument.
		  ListOfMachine list that contain remote machine name.
		  eMachineConfiguration - Machine configuration domain / workgroup.
		  
	
	Return code:

		throw Init_error;  
	
--*/
{
	 m_wcsAdminQueueFormatName = Tparms[L"AdminQFormatName"];
	 ReturnGuidFormatName( m_wcsGuidMessageLabel2 , 0 , true);
	 if (Tparms[L"SearchForQueue"] == L"Yes")
	 {
		 my_Qinfo mqQTemp(g_wcsEmptyString,g_wcsEmptyString,g_wcsEmptyString);
		 mqQTemp.PutFormatName( Tparms[L"q1"]);
		 m_QueueInfoList.push_back(mqQTemp);
 		 mqQTemp.PutFormatName( Tparms[L"q2"]);
		 m_QueueInfoList.push_back(mqQTemp);
		 mqQTemp.PutFormatName( Tparms[L"q3"]);
		 m_QueueInfoList.push_back(mqQTemp);
		 m_bSearchForQueues = false;
	 }
}
				

void MqDl::LocateDestinationQueues()
/*++


	Function Description:
   
 	  Search for the relevent queues in the DS verify that queues exist,
	  in workgroup mode try to open queues for remote read to verify that queue are exist
	  All the machines that participate in the DL/MQF test must have 
	  three queues for the test	  

	Arguments:
		
		None
	Return code:
		
		throw Init_error;  
--*/
{
	// 
	// For each machine search for the relevent queue and update list<mq_Qinfo>
	// structure
	//
		if( m_bSearchForQueues == false )
		{
			//
			// No need to search for the queues
			//
			return ; 
		}
		list<wstring>::iterator itMachineList;
		for( itMachineList = m_MachineList.begin(); 
			 itMachineList != m_MachineList.end();
			 itMachineList++ )
		{
			
			if( g_bDebug)
			{
				wMqLog(L"Locate dest queues for machine %s\n",itMachineList->c_str());
			}
			if( m_ePubType != pub_MqF && m_ePubType != pub_multiCast )
			{ 
				//
				// Search for the queue in the AD
				//
				wstring wcsTempQueueName = *itMachineList + g_cwcsDlSupportCommonQueueName;
				LocateQueuesOnSpecificMachine(itMachineList->c_str(),true);
			}
			else
			{
			
				//
				//  Workgroup mode verify that queue exist using open for read.
				//*/
				int i;
				for( i=1; i<=m_iNumberOfQueuesPerMachine; i++)
				{
					//
					// Direct=os:machine\private\machine-DLQueues
					// Send MQF useing HTTP will be solve throw COM bugbug Need to think about Direct HTTP ...
					//
					WCHAR wcsTemp[2]={0};
					_itow(i,wcsTemp,10);
					wstring wcsTempbuf=L"Direct=OS:";
					wcsTempbuf+=*itMachineList + L"\\private$\\"+ *itMachineList + L"-" + g_cwcsDlSupportCommonQueueName + wcsTemp;
					LocateQueuesOnSpecificMachine(wcsTempbuf,false);
					//
					//	 Remove the format name man to different class.
					//

				}

			}

		}

		//
		// Verify that all the queues exist.
		// TotalNumberOfQueues = TotalNumberOfMachines * NumbersOfQueuesPerMachine
		//
		if( m_QueueInfoList.size() != ( m_MachineList.size() * m_iNumberOfQueuesPerMachine ))
		{
			MqLog("Found only %d from %d \n",
				   m_QueueInfoList.size(),
					m_MachineList.size() * m_iNumberOfQueuesPerMachine );
			if( g_bDebug )
			{
				dbgPrintListOfQueues(m_QueueInfoList);
			}
		}	

}


void MqDl::LocateQueuesOnSpecificMachine( const wstring & wcsLookupInformation , bool bSearchInAD )
/*++
	Function Description:
		
		  This function Search for the queues in the AD,
		  or try to open queus in workgroup mode.

	Arguments:
		
		  wcsLookupInformation - list that contain all the DL /MQF queues format names.

	Return code:

  

--*/

{
		
		list<my_Qinfo> ListQueuePerSpecificMachine;
		int iCounter=0;
		if( bSearchInAD )
		{
			wstring wcsQueueLabel =  wcsLookupInformation + g_cwcsDlSupportCommonQueueName ;
			MSMQ::IMSMQQueueInfosPtr qinfos("MSMQ.MSMQQueueInfos");
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueryPtr query("MSMQ.MSMQQuery");
			
			
			_variant_t vQLabel(wcsQueueLabel.c_str());
			try
			{
				qinfos = query->LookupQueue ( &vtMissing , &vtMissing, & vQLabel );
				qinfos->Reset();
				qinfo = qinfos->Next();			
				while( qinfo != NULL )
				{
					wstring wcsTemp=qinfo->Label;
					if( ! _wcsicmp(wcsQueueLabel.c_str(),wcsTemp.c_str()) )
					{
						my_Qinfo mqQTemp((wstring)qinfo->PathName,
										 (wstring)qinfo->FormatName,
										 (wstring)qinfo->Label );
						ListQueuePerSpecificMachine.push_back(mqQTemp);
						iCounter++;
						if (g_bDebug)
						{
							wstring wcstemp = qinfo->PathName;
							wMqLog(L"Thread %d found queue %s \n",m_testid,wcstemp.c_str());
						}
					}
					qinfo = qinfos->Next();			
					
				}
				if ( iCounter != m_iNumberOfQueuesPerMachine )
				{
					MqLog("LocateQueuesOnSpecificMachine Failed to search all queues from the AD found %d from %d \n",iCounter,iCounter);
					throw INIT_Error("Failed to retrive all queues properites");
				}		
			}
			catch( _com_error & err )
			{
				printf("MqDl::LocateQueuesOnSpecificMachine failed with error 0x%x\n",err.Error());
			}
		}
		else
		{ 
			//
			// machine is in workgroup can't verify that queue exist by using remote read 
			// expected queue names are static queues
			//
			wstring wcsFormatName =  wcsLookupInformation;
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueuePtr qh;
			try
			{
				qinfo->FormatName = wcsFormatName.c_str();
				qh = qinfo->Open(MQ_RECEIVE_ACCESS,MQ_DENY_NONE);
				qh->Close();

				my_Qinfo mqQTemp(L"Empty",
								 (wstring)qinfo->FormatName,
								 L"Empty");
				ListQueuePerSpecificMachine.push_back(mqQTemp);
				if (g_bDebug)
				{
					wMqLog(L"Thread %d found queue %s \n",m_testid,qinfo->FormatName);
				}
			}
			catch( _com_error & cErr )
			{
				if( cErr.Error() == MQ_ERROR_QUEUE_NOT_FOUND )
				{
					wMqLog(L"Mqf:failed to open dest queue for receive %s \n Error:0x%p\n",
						    wcsLookupInformation.c_str(),cErr.Error()); //missing debug information
				}
				else
				{
					CatchComErrorHandle ( cErr , m_testid);
				}
				throw INIT_Error("Mqf: Failed to check if the dest queue is exist \n");
			}

					
					
		}
		m_QueueInfoList.merge(ListQueuePerSpecificMachine);
}



MqF::MqF ( const INT iIndex, 
		   const mTable & Tparms,
		   const list<wstring> &  ListOfMachine,
		   const InstallType eMachineConfiguration,
		   bool bWkg
		 )
:MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_MqF),m_bWorkgroup(bWkg)
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
 
{
 
}

MqF::~MqF(void)
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{

}


void MqF::Description()
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MqLog("Thread %d : Send messages using mqf format name\n", m_testid);
}

void MqDl::CreateMqFormatName()
/*++
	Function Description:
		CreateMqFormatName 
		This function concat all the formatnames into one string.
	Arguments:
		None
	Return code:
		None
--*/
{
	std::list<my_Qinfo> ::iterator itListOfQueue;
	wcsMqFFormatName=L"";
	for( itListOfQueue = m_QueueInfoList.begin(); 
		 itListOfQueue  != m_QueueInfoList.end() ; 
		 itListOfQueue ++ 
		)
	{
		
		if( itListOfQueue != m_QueueInfoList.begin() )
		{
			wcsMqFFormatName += L","; 
		}
		wcsMqFFormatName += itListOfQueue->GetQFormatName();
		
	}
}

//
// Need to dbgSendMessaga against MQF format name
// 

void MqDl::dbgSendMessage()
/*++
	Function Description:
		dbgSendMessage - this is a debug function that help to debug MQF,
		The function send messages to list of queues.
	Arguments:
		None
	Return code:
		None
--*/
{
	itliQueues p;
	for( p= m_QueueInfoList.begin();p != m_QueueInfoList.end(); 
		p++)
	{
		try
		{	
			
			IMSMQQueueInfoPtr qinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueueInfoPtr AdminQinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueuePtr qSend;
			IMSMQMessagePtr m("MSMQ.MSMQMessage");
			
			AdminQinfo->FormatName = m_wcsAdminQueueFormatName.c_str();
			wstring wcsFormatName = p->GetQFormatName();
			qinfo->FormatName =  wcsFormatName.c_str();
			qSend = qinfo->Open(MQ_SEND_ACCESS, MQ_DENY_NONE);
			m->AdminQueueInfo = AdminQinfo;
			m->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
			m->Body = m_wcsGuidMessageLabel.c_str();
			m->Label = m_wcsGuidMessageLabel.c_str();
			m->Send(qSend);
			qSend->Close();

		}
		catch (_com_error & cErr )
		{
			MqLog("Thread %d failed to send message to a queue error 0x%x\n",m_testid,cErr.Error());
			throw INIT_Error("dbgSendMessage failed to send message to dest");
		}
	}
}
INT MqF::Start_test()
/*++
	Function Description:
		Implement the tests
		Send messages to all the destination queues.
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
	//
	// Locate all the relevent queue from the enterpise 
	//
	SetThreadName(-1,"MqF - Start_test ");	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		wMqLog(L"Mqf tests exist didn't found all the queues\n error:0x%x\n ",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}

	MqDl::CreateMqFormatName();


	
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle=NULL;
	cPropVar MqfMessageProps(8);
	wstring Label(L"T1-3");
	MqfMessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MqfMessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MqfMessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MqfMessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	MqfMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

	if ( !m_bWorkgroup )
	{
		ULONG ulType = g_bRunOnWhistler ? MQMSG_AUTH_LEVEL_SIG30:MQMSG_AUTH_LEVEL_SIG10;
		MqfMessageProps.AddProp(PROPID_M_AUTH_LEVEL ,VT_UI4,&ulType);
	}
	//
	// Send message using to using MQF format name and one admin queues.
	//
	
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",wcsMqFFormatName.c_str());
	}
	rc = MQOpenQueue( wcsMqFFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed to open using Mqf Format Name");
	
	rc=MQSendMessage( QueueuHandle , MqfMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	//
	// Send message using to one queue and specify MQF format name to the admin queues.
	//

	if( g_bDebug )
	{
		MqLog("MqF: Send message to admin queue and wait for ACK for all admin queues\n");
	}
	
	return MSMQ_BVT_SUCC;	
}
	
INT MqDl::CheckResult()
/*++
	Function Description:
		This function collects the information from the Mqf using remote read.

		a. Receive from admin messages.
		b. Collect all the messages from the queues.
		
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
			
			HRESULT rc;
			mTable mPrepareBeforeRecive;
			WCHAR wstrMclass[10];
			
			//
			// receive ACK for admin queue
			// 

			mPrepareBeforeRecive[L"FormatName"]=m_wcsAdminQueueFormatName;
			mPrepareBeforeRecive[L"DebugInformation"]=L"Recive from admin queue with direct formant name";
			mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
			swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
			mPrepareBeforeRecive[L"MClass"]= wstrMclass;
			for(DWORD i =0;i<MqDl::m_QueueInfoList.size();i++)
			{
				DebugMqLog("------ Retreive admin messages from queue ------- \n");
				rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );	
				if( rc !=  MSMQ_BVT_SUCC ) 
				{
					//
					//bugbug need to specify the queue name.
					//
					MqLog("Failed to get receive ack on queue //bugbug");
					return MSMQ_BVT_FAILED;
				}
			}
			
			
			//
			// Receive message from the queue
			//
						
			itliQueues it;
			for( it = MqDl::m_QueueInfoList.begin(); 
				 it  != MqDl::m_QueueInfoList.end() ;
				 it ++
				)
			{
					 mPrepareBeforeRecive[L"FormatName"]=it->GetQFormatName();
		   			 mPrepareBeforeRecive[L"DebugInformation"]=L"Receive message from queue=" 
																+it->GetQPathName();
					 mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
					 DebugMqLog("------ Retreive messages from queues ------- \n");
					 rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
					 if( rc != MSMQ_BVT_SUCC )
					 {
						  return MSMQ_BVT_FAILED;
					 }

			}

				//
				// Check for duplicate messages
				//
				mPrepareBeforeRecive[L"CheckForDuplicate"]=L"CheckForDuplicate";

	 		for( it = MqDl::m_QueueInfoList.begin(); 
				 it  != MqDl::m_QueueInfoList.end() ;
				 it ++
				)
			{
				 
				 mPrepareBeforeRecive[L"FormatName"]=it->GetQFormatName();
		   		 mPrepareBeforeRecive[L"DebugInformation"]=L"Receive message from queue=" +it->GetQPathName();
				 swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
				 mPrepareBeforeRecive[L"MClass"]= wstrMclass;
					 
				 mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel2;
				 DebugMqLog("------ Check for duplicate messages from the queues ------- \n");
				 rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
				 if( rc != MSMQ_BVT_SUCC )
				 {
					 wMqLog(L"Mqf: Error found duplicate message \n");
					 return MSMQ_BVT_FAILED;
				 }
			}
return MSMQ_BVT_SUCC;
} 

MqDl::~MqDl()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/

{
}




void cSendUsingDLObject::AddMemberToDlObject()
/*++
	Function Description:
		CreateMqFormatName 
		This function concat all the formatnames into one string.
	Arguments:
		None
	Return code:
		None
--*/
{
	std::list<my_Qinfo> ::iterator itListOfQueue;
	for( itListOfQueue = m_QueueInfoList.begin(); 
		 itListOfQueue  != m_QueueInfoList.end() ; 
		 itListOfQueue ++ 
		)
	{

		MQAddElementToDistList(	
								m_wcsDistListFormatName.c_str(),
								(itListOfQueue->GetQFormatName()).c_str()
							  );				
	}
}

INT MqDl::Start_test() 
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/

{
	return 1;
}
void MqDl::Description()
{
}

MqF::CheckResult()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
{
	SetThreadName(-1,"MqDistList - CheckResult ");	
	return MqDl::CheckResult();
}


cSendUsingDLObject::cSendUsingDLObject ( const INT iIndex, 
									     mTable & Tparms,
									     const list<wstring> &  ListOfMachine,
									     const InstallType eMachineConfiguration
	  								   ):MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_DL),
m_wcsDistListFormatName(L""),m_wcsQueueAliasFormatName(L""),bCheckAliasQueue(true)								
{

	WCHAR wcsFormatName[BVT_MAX_FORMATNAME_LENGTH]={0};
	DWORD dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	GetCurrentDomainName();
	wstring wcsDLContainerName=L"CN=Computers,"+m_wcsCurrentDomainName;
	HRESULT hr = MQCreateDistList(wcsDLContainerName.c_str(),m_wcsGuidMessageLabel.c_str(),MQ_GLOBAL_GROUP,NULL,wcsFormatName,&dwFormatNameBufferLen);
	if(FAILED(hr))
	{
		MqLog("cSendUsingDLObject Failed to create DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}
 	m_wcsDistListFormatName = wcsFormatName;

	//
	// Create admin queue mach for DL
	// Currently use DL and replace it with queue alias.
	// 

	wstring m_wcsAdminDLGuid;
	dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	wstring wcsAdminDLGuid;
	ReturnGuidFormatName( wcsAdminDLGuid , 2 , true);
	hr = MQCreateDistList(wcsDLContainerName.c_str(),wcsAdminDLGuid.c_str(),MQ_GLOBAL_GROUP,NULL,wcsFormatName,&dwFormatNameBufferLen);
	if(FAILED(hr))
	{
		MqLog("cSendUsingDLObject Failed to create DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}
 	m_wcsAdminDestFormatName = wcsFormatName;
	m_wcsPublicAdminQueue = Tparms[L"PublicAdminQueue"];
	hr = MQAddElementToDistList(m_wcsAdminDestFormatName.c_str(),m_wcsPublicAdminQueue.c_str());
	if(FAILED(hr))
	{
		MqLog("MQAddElementToDistList Failed to add queue DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}

	dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	wstring wcsQueueAliasFullDN = L"CN=Computers,"+ m_wcsCurrentDomainName;
	wstring wcsQueueAliasNameGuid =L"";
	ReturnGuidFormatName( wcsQueueAliasNameGuid , 2 , true);
	hr = MQCreateAliasQueue(wcsQueueAliasFullDN.c_str(),
							wcsQueueAliasNameGuid.c_str(),
							m_wcsPublicAdminQueue.c_str(),
							m_wcsQueueAliasFormatName
						   );
	if(FAILED(hr))
	{
		if ( hr == 0x8007200a ) // Schema attribute is not exist in Win2K schema.
		{ 
			//
			//  Happend because this alias queue is not part of Win2K schema.
			//
			bCheckAliasQueue = false;
		}
		else
		{
			MqLog("MQCreateAliasQueue Failed to create alias queue error 0x%x\n",hr);
			throw INIT_Error("cSendUsingDLObject:Failed to create alias queue under Computers container ");
		}
	}
}


wstring GetCurrentDomainNameDN()
/*++
	Function Description:
		
	Arguments:
		None
	Return code:
		None
--*/
{
	
    IADs * pRoot = NULL;
    HRESULT hr=ADsGetObject( L"LDAP://RootDSE",
							 IID_IADs,
							 (void**) &pRoot
						   );
    if(FAILED(hr)) 
	{ 
		return L"";
	}
	VARIANT varDSRoot;
	hr = pRoot->Get(L"defaultNamingContext",&varDSRoot);
	pRoot->Release();
	if ( FAILED(hr))
	{
		return L"";
	}
    wstring wcsCurrentDomainName = varDSRoot.bstrVal;
	VariantClear(&varDSRoot);
	return wcsCurrentDomainName;
}

void cSendUsingDLObject::GetCurrentDomainName()
/*++
	Function Description:
		Get Full DN name.
	Arguments:
		None
	Return code:
		None
--*/
{
	m_wcsCurrentDomainName = GetCurrentDomainNameDN();
}

cSendUsingDLObject::~cSendUsingDLObject(void)
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MQDeleteDistList(m_wcsDistListFormatName.c_str());
	MQDeleteDistList(m_wcsAdminDestFormatName.c_str());
	if ( bCheckAliasQueue )
	{
		MQDeleteAliasQueue(m_wcsQueueAliasFormatName.c_str());
	}
}


void cSendUsingDLObject::Description()
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MqLog("Thread %d : Send Messages using DL object \n", m_testid);
}
 

cSendUsingDLObject::CheckResult()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
{
	
	if( bCheckAliasQueue )
	{

		AutoFreeLib cMqrt("Mqrt.dll");
		DefMQADsPathToFormatName pfMQADsPathToFormatName = (DefMQADsPathToFormatName) GetProcAddress( cMqrt.GetHandle() ,"MQADsPathToFormatName");
		if ( pfMQADsPathToFormatName == NULL )
		{
			MqLog("Mqbvt failed to GetProcAddress MQADsPathToFormatName proc address \n");
			return MQ_ERROR;
		}
		WCHAR * pwcsFormtName = NULL;
		DWORD dwFormatNameLen = 0;
		HRESULT hr = pfMQADsPathToFormatName(m_wcsQueueAliasFormatName.c_str(),
										     NULL,
										     &dwFormatNameLen
										     );
		if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) 
		{
			  pwcsFormtName = (WCHAR*) malloc( sizeof(WCHAR) * (dwFormatNameLen+1));
			  if(pwcsFormtName == NULL) 
			  {
					MqLog("Failed to allocate memory\n");
					return MSMQ_BVT_FAILED;
			  }
			  
			  hr = pfMQADsPathToFormatName(m_wcsQueueAliasFormatName.c_str(),
										   pwcsFormtName,
										   &dwFormatNameLen
										  );
			  ErrHandle(hr,MQ_OK,L"MQADsPathToFormatName Failed");
			  if( m_wcsPublicAdminQueue != pwcsFormtName )
			  {
					wMqLog(L"MQADsPathToFormatName failed to retrive queue \
						   format name \nFound %s \n Expected:%s\n",pwcsFormtName,m_wcsAdminDestFormatName.c_str());
					free(pwcsFormtName);
					return MSMQ_BVT_FAILED;
			  }
			  free(pwcsFormtName);
			  
		}
		else
		{
			ErrHandle(hr,MQ_OK,L"MQADsPathToFormatName Failed");
		}
	}
	return MqDl::CheckResult();
}



INT cSendUsingDLObject::Start_test()
/*++
	Function Description:
		Implement the tests
		Send messages to all the destination queues.
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
	SetThreadName(-1,"cSendUsingDLObject - Start_test ");	
	//
	// Locate all the relevent queue from the enterpise 
	//
	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		wMqLog(L"ComMqF tests exist didn't found all the queues\n %s",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}
	//
	// TBD use the DL / MQF API to propgate the message
	//
	
	AddMemberToDlObject();

	HRESULT rc;
	HANDLE QueueuHandle;
	cPropVar MqDLMessageProps(8);
	
	
	wstring Label(L"T1-3");
	
	MqDLMessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MqDLMessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MqDLMessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR ,m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MqDLMessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulType = MQMSG_PRIV_LEVEL_BODY_BASE;
	MqDLMessageProps.AddProp(PROPID_M_PRIV_LEVEL ,VT_UI4,&ulType);
	ulType = MQMSG_AUTH_LEVEL_SIG30;
	MqDLMessageProps.AddProp(PROPID_M_AUTH_LEVEL ,VT_UI4,&ulType);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	MqDLMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );	

	//
	// Send message using to using MQF format name and one admin queues.
	//
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",wcsMqFFormatName.c_str());
	}
	rc = MQOpenQueue( m_wcsDistListFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed to open using DL=GUID Name");
	rc=MQSendMessage( QueueuHandle , MqDLMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	
	//
	// Verify that MqHandleToFormat works fine with DL.
	//

	WCHAR * pwcsFormatName = NULL;
	DWORD dwFormatNameLength = 0;
	rc = MQHandleToFormatName(QueueuHandle,pwcsFormatName,&dwFormatNameLength);
	if( rc != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL )
	{
		MqLog("cSendUsingDLObject::Start_test MQHandleToFormatName expected to return %d found %d\n",MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL,rc);
		return MSMQ_BVT_FAILED;
	}
	dwFormatNameLength += 1;
	pwcsFormatName = (WCHAR *) malloc (sizeof(WCHAR) * (dwFormatNameLength));
	if(!pwcsFormatName)
	{
		MqLog("cSendUsingDLObject::Start_test Failed to allocate memory for pwcsFormatName buffer\n");
		return MSMQ_BVT_FAILED;
	}
	
	rc = MQHandleToFormatName(QueueuHandle,pwcsFormatName,&dwFormatNameLength);
	ErrHandle(rc,MQ_OK,L"MQHandleToFormatName Failed to return format name using DL=GUID Name");
	if( m_wcsDistListFormatName != pwcsFormatName )
	{
		wMqLog(L"MQHandleToFormatName failed expected:%s\nFound %s\n",m_wcsDistListFormatName.c_str(),pwcsFormatName);
		free(pwcsFormatName);
		return MSMQ_BVT_FAILED;
	}
	free(pwcsFormatName);
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	//
	// Send message using to one queue and specify MQF format name to the admin queues.
	//

	if( g_bDebug )
	{
		MqLog("MqF: Send message to admin queue and wait for ACK for all admin queues\n");
	}

	return MSMQ_BVT_SUCC;	
}


HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN HANDLE hQueue,
    IN ULONG ulLookupId,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    );



	

extern DWORD  g_dwRxTimeOut ;


typedef
HRESULT
(APIENTRY * DefMQReceiveMessageByLookupId)
	(
		IN HANDLE hQueue,
		IN ULONGLONG ulLookupId,
		IN DWORD dwAction,
		IN MQMSGPROPS* pmp,
		IN OUT LPOVERLAPPED lpOverlapped,
		IN PMQRECEIVECALLBACK fnReceiveCallback,
		IN ITransaction *pTransaction
    );

typedef
HRESULT
(APIENTRY * DefMQGetOverlappedResult)
 (
 LPOVERLAPPED lpOverlapped
 );


HRESULT RetrieveMessageFromQueueById(map <wstring,wstring> & mRetriveParms )
/*++
	Function Description:
		
		Retrive message from queue by using LookupID
		Call three times to MQReceiveMessageByLookupId
		1. Peek Current Message
		2. Receive Current
		3. Peek Current and failed with Message has been deleted

	Arguments:
		
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
		
		AutoFreeLib cMqrt("Mqrt.dll");
		FARPROC pfMQReceiveMessageByLookupId = GetProcAddress( cMqrt.GetHandle() ,"MQReceiveMessageByLookupId");
		FARPROC pfMQGetOverlappedResult = GetProcAddress( cMqrt.GetHandle() ,"MQGetOverlappedResult");
		if( pfMQReceiveMessageByLookupId == NULL || pfMQGetOverlappedResult == NULL )
		{
			MqLog("LookUpID: Faile to get MQReceiveMessageByLookupId proc address\n");
			return MSMQ_BVT_FAILED;
		}
		DefMQReceiveMessageByLookupId xMQReceiveMessageByLookupId = (DefMQReceiveMessageByLookupId) pfMQReceiveMessageByLookupId;
		DefMQGetOverlappedResult xMQGetOverlappedResult =  (DefMQGetOverlappedResult) pfMQGetOverlappedResult;
		
		ULONGLONG uLookUPID=0;
		mRetriveParms[L"MessageID"]=L"MessageID";
		HRESULT hr = RetrieveMessageFromQueue(mRetriveParms);
		if( hr != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Failed to retrive messages ID using MQRecevieMessage return LookupID=%s\n",mRetriveParms[L"MessageID"].c_str());
			return MSMQ_BVT_FAILED;
		}
		if( mRetriveParms[L"MessageID"] != L"MessageID" )
		{
			string strMyVal = My_WideTOmbString(mRetriveParms[L"MessageID"]);
			uLookUPID = _atoi64(strMyVal.c_str());
		}
		
		
		if( g_bDebug )
		{
			wMqLog(L"Search For Message ID 0x%I64d ",uLookUPID);
			wMqLog(L"@Queue %s\n",mRetriveParms[L"FormatName"].c_str());
		}
		wstring wcsQueueFormatName=mRetriveParms[L"FormatName"];
		HANDLE hQueue=NULL;
		HRESULT rc=MQOpenQueue( wcsQueueFormatName.c_str(), MQ_RECEIVE_ACCESS , MQ_DENY_NONE  , &hQueue );
		ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");		

		cPropVar Rprop(2);
		WCHAR Label[MAX_GUID+1];
		Rprop.AddProp( PROPID_M_LABEL, VT_LPWSTR, Label , MAX_GUID );
		ULONG uTemp=MAX_GUID;
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		OVERLAPPED pOv = {0};
		pOv.hEvent= CreateEvent( NULL, FALSE, FALSE, NULL );
		if ( pOv.hEvent == 0 )
		{
			MqLog("CreateEvent failed with error 0x%x\n",GetLastError());
		}
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_PEEK_CURRENT,
										  Rprop.GetMSGPRops(),
										  &pOv,
										  NULL,
										  NULL
										);
			
		if( rc != MQ_INFORMATION_OPERATION_PENDING )
		{
			ErrHandle(rc,MQ_OK,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_PEEK_CURRENT");
		}
		else
		{
			DWORD  dwAsync = WaitForSingleObject(pOv.hEvent,INFINITE); //g_dwRxTimeOut);
			ErrHandle(dwAsync,WAIT_OBJECT_0,L"WaitForSingleObject Failed to MQ_LOOKUP_PEEK_CURRENT");	
			hr = xMQGetOverlappedResult(&pOv);
			ErrHandle(hr,MQ_OK,L"MQGetOverlappedResult return error");
		}
		
		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}
				
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_RECEIVE_CURRENT,
										  Rprop.GetMSGPRops(),
										  NULL,
										  NULL,
										  NULL
										);
			
		ErrHandle(rc,MQ_OK,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_RECEIVE_CURRENT");

		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_RECEIVE_CURRENT,
										  Rprop.GetMSGPRops(),
										  NULL,
										  NULL,
										  NULL
										);
			

		ErrHandle(rc,MQ_ERROR_MESSAGE_NOT_FOUND,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_RECEIVE_CURRENT");

		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}

		rc = MQCloseQueue( hQueue );
		ErrHandle(rc,MQ_OK,L"MQcloseQueue Failed");

		return MSMQ_BVT_SUCC;
}


typedef (__stdcall *fptr)();
typedef HRESULT  
	(APIENTRY * 
	DefMQGetPrivateComputerInformation ) 
	(
	  IN LPCWSTR lpwcsComputerName,
	  IN OUT MQPRIVATEPROPS* pPrivateProps
	);


INT MSMQMajorVersion(const wstring & wcsComputerName )
/*++
	Function Description:
		MSMQMajorVersion
		Return MSMQ version 
	Arguments:
		wcsComputerName remote machine name
	Return code:
		0 - NT4
		2 - W2K
		5 - Whistler
--*/

{
	if ( _winmajor == NT4 )
	{
	      return 0;
	}
	INT index = 0;
	QMPROPID aQmPropId[1];
	MQPROPVARIANT aPropVar[1];
	MQPRIVATEPROPS aMqPrivateProps;
	HRESULT hr;
	fptr pFunc=NULL;
	DefMQGetPrivateComputerInformation xMQGetPrivateComputerInformation=NULL;

	aQmPropId[index] = PROPID_PC_VERSION;
	aPropVar[index].vt = VT_UI4;
	index ++;
	
	aMqPrivateProps.cProp = index;
	aMqPrivateProps.aPropID = aQmPropId;
	aMqPrivateProps.aPropVar = aPropVar;
	aMqPrivateProps.aStatus=NULL;
		
	AutoFreeLib cMqrt("Mqrt.dll");
		
	if (! cMqrt.GetHandle() )
	{
		return 0;
	}
	pFunc=(fptr)GetProcAddress( cMqrt.GetHandle(), "MQGetPrivateComputerInformation");
	
	if ( pFunc == NULL )
	{
		DWORD dw = GetLastError();
		MqLog("Mqbvt failed to get proc address of MQGetPrivateComputerInformation error:%d\n",dw);
		return 1;
	}
	
	xMQGetPrivateComputerInformation=(DefMQGetPrivateComputerInformation) pFunc;
	const WCHAR * pwcsComputerName = (wcsComputerName == L"") ? NULL : wcsComputerName.c_str();
	//
	// Workaround because BUG 5573 
	//
	WCHAR wcsLocalComputerName[MAX_COMPUTERNAME_LENGTH+1]={0};
	DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH;


	GetComputerNameW(wcsLocalComputerName,&dwComputerName);

	if ( pwcsComputerName && ! _wcsicmp(wcsLocalComputerName,pwcsComputerName))
	{
		pwcsComputerName = NULL;
	}

	hr = xMQGetPrivateComputerInformation( pwcsComputerName , &aMqPrivateProps );
  	if( hr != MQ_OK )
	{
		return 0;
	}
	return aPropVar[0].lVal >> 24;
}



void CMultiCast::Description()
{
	MqLog("Thread %d : Send messages using multicast format name\n", m_testid);
}

CMultiCast::CMultiCast ( const INT iIndex, 
			  mTable & Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration
			  )
			  :MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_multiCast),
			  m_wcsMultiCastAddress(L""),m_wcsAdminMultiCastAddress(L"")
{
	m_wcsMultiCastAddress =  Tparms[L"MultiCastAddress"];
}

CMultiCast::~CMultiCast()
/*++
	Function Description:
	Arguments:

	Return code:
--*/

{
}

wstring CMultiCast::CreateMultiCastFormatName()
/*++
	Function Description:
	Arguments:

	Return code:
--*/

{
	wstring wcsMultiCastFormatName = L"MULTICAST=";
	wcsMultiCastFormatName += m_wcsMultiCastAddress;
	wcsMultiCastFormatName += PGM_PORT;
	return wcsMultiCastFormatName;
}

//
//  
//

CMultiCast::Start_test()
/*++
	Function Description:
		1. Send messages to multi cast group and ask for admin reach queue ACK.
		2. Send message to queue and set admin as multicast address.
	Arguments:

	Return code:
--*/
{

	SetThreadName(-1,"CMultiCast - Start_test ");	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		wMqLog(L"Mqf tests exist didn't found all the queues\n error:0x%x\n ",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}

	m_wcsMultiCastAddress = CreateMultiCastFormatName();
	// send it as Mqf m_wcsMultiCastAddress += L"," + CreateMultiCastFormatName();

	m_wcsAdminMultiCastAddress = CreateMultiCastFormatName();
	
	HRESULT rc;
	HANDLE QueueuHandle;
	cPropVar MultiCastProps(7),MultiCastProps1(7);
	
	
	wstring Label(L"T1-3");
	
	MultiCastProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MultiCastProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MultiCastProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MultiCastProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulVal = 180; 
	MultiCastProps.AddProp(PROPID_M_TIME_TO_BE_RECEIVED,VT_UI4,&ulVal);
	
	//
	// Send message using to using MQF format name and one admin queues.
	//
	
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",m_wcsMultiCastAddress.c_str());
	}
	rc = MQOpenQueue( m_wcsMultiCastAddress.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc	,MQ_OK,L"MQOpenQueue Failed to open using multicast Format Name");
	
	rc=MQSendMessage( QueueuHandle , MultiCastProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	
	return MSMQ_BVT_SUCC;	

}

CMultiCast::CheckResult()
/*++
	Function Description:
		CheckResult receive messages from the destination queues.
	Arguments:
		None
	Return code:
		MSMQBVT_SUCC / MSMQBVT_FAILED
--*/
{
	SetThreadName(-1,"CMultiCast - CheckResult ");	
	return MqDl::CheckResult();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqparams.h ===
/*++

Class Description:
    This class takes the arguments from the command line
    and puts them into a container. You can get each
    argument by calling GetPrm. You can find if argument 
    exists by calling	.

Written By:
    Ofer Gigi.

Version:
	1.01  - 16/11/2000

--*/
        
#ifndef PARAMINPUT_H
#define PARAMINPUT_H

#pragma warning(disable :4786)

#include "msmqbvt.h"



class CInput     
{    
public:  
    CInput(int argc, char *argv[]);
	CInput(const CInput& in);
    CInput(const std::string& str);
    virtual ~CInput(){};
    bool IsExists(const std::string& str)const;
    std::string operator[](const std::string& str)const ;
	long CInput::GetNumber(const std::string& str)const ;
	CInput& operator=( const CInput& in);
    std::map<std::string,std::string> GetMap()const;
    
private:
    mutable std::map<std::string,std::string> m;
    void ParseToken(const std::string& str,
                    std::string::size_type tokenstart,std::string::size_type tokenfinish);
};    

inline std::map<std::string,std::string> CInput::GetMap()const
{
  return m;
}

inline CInput& CInput::operator=(const CInput& in)
{
  if( static_cast<const void*>(this) != static_cast<const void*>(&in))
  {
    m=in.m;
  }
  return *this;
}

 

inline CInput::CInput(const CInput& in):m(in.m)
{


}

/*++
Routine Description:
    This routine takes the arguments from the command line
    and puts them into a container. Each token 
    ("/command:value") is already apart from the other tokens.

Arguments:
    argc(IN) - number of arguments in the command line.
    argv(IN) - the arguments in the command line.
        
Return Value:
    none.

Note:
    When you are creating this object using THIS constructor
    the first argument is THE NAME OF THE PROGRAM so this 
    argument is not included in the container. 
--*/

inline CInput::CInput(int argc, char *argv[])
{
    int i;
    for (i=1;i<argc;i++)
    {
        ParseToken(argv[i],0,std::string::npos);
    }
}


/*++
Routine Description:
    This routine takes the string from the command line,
    then takes the tokens ("/command:value") from it and
    puts them into a container. 

Arguments:
    str (IN) - all the arguments contained in one string.

Return Value:
    none.
--*/

inline CInput::CInput(const std::string& str)
{
    std::string::size_type tokenstart=0;
    std::string::size_type tokenfinish=0;
    while ((tokenstart!=std::string::npos) && (tokenfinish!=std::string::npos))
    {
        tokenstart=str.find_first_not_of(' ',tokenfinish);
        if (tokenstart!=std::string::npos)
        {
            tokenfinish=str.find_first_of(' ',tokenstart);     
            if (tokenfinish==std::string::npos)
            {
                ParseToken(str,tokenstart,tokenfinish);
            }
            else
            {
                ParseToken(str,tokenstart,tokenfinish-1);
            }
        }
    }
}

/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    str (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/

inline void CInput::ParseToken(const std::string& str,
                               std::string::size_type tokenstart,
                               std::string::size_type tokenfinish)
{
    std::string command;
    std::string value;
    std::string::size_type commandstart;
    std::string::size_type valuestart;
    commandstart=str.find("-",tokenstart)+1;
    valuestart=str.find(":",tokenstart)+1;
    if ((commandstart!=std::string::npos) &&
        (valuestart!=std::string::npos) &&
        (commandstart<valuestart) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish) &&
        (valuestart>=tokenstart) &&
        (valuestart<=tokenfinish))
    {
        command=str.substr(commandstart,valuestart-1-commandstart);
        if (tokenfinish!=std::string::npos)
        {
            value=str.substr(valuestart,tokenfinish+1-valuestart);
        }
        else
        { 
            value=str.substr(valuestart);
        }
        m[command]=value;
		return;
    }

    if ((commandstart!=std::string::npos) &&
        ((valuestart==std::string::npos) || (valuestart>tokenfinish) || (valuestart==0)) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish))
    {
        if (tokenfinish!=std::string::npos)
        {
            command=str.substr(commandstart,tokenfinish+1-commandstart);
        }
        else 
        {
            command=str.substr(commandstart);
        }
        m[command]="";
    }
}

/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    str (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/

inline bool CInput::IsExists(const std::string& str)const
{
    std::map<std::string,std::string>::const_iterator p=m.find(str);
    if (p==m.end())
    { 
        return false;
    }
    else
    {
        return true;
    }
}

/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    str (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/

inline std::string CInput::operator[](const std::string& str)const
{
   if (IsExists(str))
    {
      return m[str];
    }
    else
    {    
       return "";
    }
}
 

/*++
Routine Description:
  return numeric value for given
  key

Arguments:
    str (IN) - the key.


--*/

inline long CInput::GetNumber(const std::string& str)const
{
	std::string s=operator[](str);
	return atol(s.c_str());
}


 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqtrig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqTrig.cpp

Abstract:
	
	1.	Creates the key "TriggerTest" in registry in order to enable the Triggers service test hook.
	1.	Creates 3 triggers, one of each type
	2.	Attaches 2 rules to each 1 rule with COM action and one with EXE action
	3.	Sends two messages to each queue
	4.	Waits for the results

	The results are checked by using the Triggers service hook for testing.
	By defining the key "TriggerTest" in registry, the service sends messages with infomation about invoked action.

	Between initialization phase and functionality test phase, "net stop msmqtriggers" and "net start msmqtriggers"
	are required.
		
Author:
    
	Tal Kariv (t-talik) 1-1-2001
	
Revision History:

--*/
#include "msmqbvt.h"
#include <vector>
using namespace std;
using namespace MSMQ;
#import "mqtrig.tlb" no_namespace 

#define TRIGGER_SERIALIZED 1
#define TRIGGER_ENABLED 1

#define EXE_ACTION L"EXE\tnet.exe"
#define COM_ACTION L"COM\tMSMQ.MSMQApplication\tConnect"


		 

void CMqTrig::Description()
{
	wMqLog(L"Thread %d : Trigger Thread\n", m_testid);
}

HRESULT TrigSetRegKeyParams()
/*++  
	Function Description:
		Set the key "TriggerTest" in registry (under the key Triggers as REG_SZ)	
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	HKEY hKey = NULL;
	HRESULT hr =  RegOpenKeyExW(
								HKEY_LOCAL_MACHINE,         
								L"SOFTWARE\\Microsoft\\MSMQ\\Triggers", 
								0,   
								KEY_WRITE,
								&hKey
							  );

	ErrHandle(hr,ERROR_SUCCESS,L"Triggers not installed");
	
	//
	//	set the key "TriggerTest" to NULL
	//
	hr = RegSetValueExW(
		  				hKey,
						L"TriggerTest" ,
						NULL ,
						REG_SZ ,
						(unsigned char*)"" ,
						2
					  );

	ErrHandle(hr,ERROR_SUCCESS,L"RegSetValueEx failed");
	RegCloseKey(hKey);
	return hr;

}

HRESULT TrigCheckRegKeyParams()
/*++  
	Function Description:
		verifies that the key "TriggerTest" in registry (under the key Triggers as REG_SZ)	
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	HKEY hKey = NULL;
	HRESULT hr =  RegOpenKeyExW(
								HKEY_LOCAL_MACHINE,         
								L"SOFTWARE\\Microsoft\\MSMQ\\Triggers", 
								0,   
								KEY_QUERY_VALUE,
								&hKey
							  );

	ErrHandle(hr,ERROR_SUCCESS,L"Triggers not installed");

	//
	// check if "TriggersTest" is registered in registry
	//
	hr = RegQueryValueExW(
		hKey ,				
		L"TriggerTest" ,	
		NULL ,			
		NULL ,
		NULL ,				
		NULL	
		);

	ErrHandle(hr,ERROR_SUCCESS,L"RegQueryValueEx failed");
	RegCloseKey(hKey);
	return hr;

}

HRESULT CMqTrig::TrigInit()
/*++  
	Function Description:
		Creates the triggers and rules and attaches them.
		If a trigger or a rule already exists, it skips the creation.
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	try
	{
		if (TrigCheckRegKeyParams())
		{
			return (MSMQ_BVT_FAILED);
		}
		
		//
		//	add new triggers
		//
		
		IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		

		HRESULT hr = TriggerSet->Init((LPWSTR)NULL);
		if( g_bDebug )
		{	
			MqLog ("Init trigger set\n");
		}
		ErrHandle(hr,MQ_OK,L"TriggerSet init trigger failed");
		//
		// Update data to registry
		// 
		if( g_bDebug )
		{	
			MqLog ("Refreshing trigger set\n");
		}
		hr = TriggerSet->Refresh();
		ErrHandle(hr,MQ_OK,L"TriggerSet refresh failed");

		
		bool bTriggerExistsFlag[3] = {0};
		BSTR bstrTriggerGUIDs[3] = {NULL};
		BSTR bstrTempTriggerGUID = NULL;
		DWORD dwNumOfTriggers = TriggerSet->GetCount();
		BSTR bstrTriggerName = NULL;
		if( g_bDebug )
		{	
			MqLog ("Checking if triggers exist\n");
		}
		for (DWORD i=0 ; i<dwNumOfTriggers ; i++)
		{
			
			TriggerSet->GetTriggerDetailsByIndex(i , &bstrTempTriggerGUID , &bstrTriggerName , NULL , NULL , NULL , NULL , NULL , NULL);
			if (!wcscmp(bstrTriggerName , L"bvt-PeekTrigger"))
			{
				bTriggerExistsFlag[0] = true;
				bstrTriggerGUIDs[0] = bstrTempTriggerGUID;
			}
			else if (!wcscmp(bstrTriggerName , L"bvt-RetrievalTrigger"))
			{
				bTriggerExistsFlag[1] = true;
				bstrTriggerGUIDs[1] = bstrTempTriggerGUID;

			}
			else if (!wcscmp(bstrTriggerName , L"bvt-TransactionalRetrievalTrigger"))
			{
				bTriggerExistsFlag[2] = true;
				bstrTriggerGUIDs[2] = bstrTempTriggerGUID;
			}
			else
			{
				SysFreeString(bstrTempTriggerGUID);
				SysFreeString(bstrTriggerName);
			}
			bstrTempTriggerGUID = NULL;
			bstrTriggerName = NULL;
		}

		
		//
		//	create the peek trigger
		//
		
		if( !bTriggerExistsFlag[0] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new peek trigger\n");
			}
			hr = TriggerSet->AddTrigger(L"bvt-PeekTrigger" , m_wcsPeekQueuePathName.c_str() , SYSTEM_QUEUE_NONE,
				TRIGGER_ENABLED , TRIGGER_SERIALIZED , PEEK_MESSAGE , &bstrTriggerGUIDs[0]);
			ErrHandle(hr,MQ_OK,L"Add peek trigger failed");	
		}
		
		//
		//	create the retrieval trigger
		//
		if( !bTriggerExistsFlag[1] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new retrieval trigger\n");
			}

			hr = TriggerSet->AddTrigger(L"bvt-RetrievalTrigger" , m_wcsReceiveQueuePathName.c_str() , SYSTEM_QUEUE_NONE,
					TRIGGER_ENABLED , TRIGGER_SERIALIZED , RECEIVE_MESSAGE , &bstrTriggerGUIDs[1]);
			ErrHandle(hr,MQ_OK,L"Add retrieval trigger failed");
		}
		//
		//	create the retrieval transaction trigger
		//
		if( !bTriggerExistsFlag[2] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new transactional retrieval trigger\n");
			}

			hr = TriggerSet->AddTrigger(L"bvt-TransactionalRetrievalTrigger" , m_wcsTxReceiveQueuePathName.c_str() , SYSTEM_QUEUE_NONE,
					TRIGGER_ENABLED , TRIGGER_SERIALIZED , RECEIVE_MESSAGE_XACT , &bstrTriggerGUIDs[2]);
			ErrHandle(hr,MQ_OK,L"Add transactional retrieval trigger failed");
		}

		if( g_bDebug )
		{	
			MqLog ("Detaching all rules from all triggers\n");
		}
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[0]);
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[1]);
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[2]);

		//
		//	add new rules
		//
		IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		if( g_bDebug )
		{	
			MqLog ("Init the rule set\n");
		}
		hr = RuleSet->Init((LPWSTR)NULL);
		ErrHandle(hr,MQ_OK,L"Init rule failed");
		
		if( g_bDebug )
		{	
			MqLog ("Refreshing the rule set\n");
		}
		hr = RuleSet->Refresh();
		ErrHandle(hr,MQ_OK,L"Rule refresh Failed");
		
		bool bRuleExistsFlag[2] = {false};
		BSTR bstrRuleGUIDs[2] = {NULL};
		DWORD dwNumOfRules = RuleSet->GetCount();
		BSTR bstrRuleName = NULL;
		BSTR bstrTempRuleGUID = NULL;
		if( g_bDebug )
		{	
			MqLog ("Checking if rules exist\n");
		}
		for (i=0; i < dwNumOfRules ; i++)
		{
			bstrTempRuleGUID = NULL;
			bstrRuleName = NULL;
			RuleSet->GetRuleDetailsByIndex(i , &bstrTempRuleGUID , &bstrRuleName , NULL , NULL , NULL , NULL , NULL);
			if (!wcscmp(bstrRuleName , L"bvt-EXERule"))
			{
				bRuleExistsFlag[0] = true;
				bstrRuleGUIDs[0] = bstrTempRuleGUID;
			}
			else if (!wcscmp(bstrRuleName , L"bvt-COMRule"))
			{
				bRuleExistsFlag[1] = true;
				bstrRuleGUIDs[1] = bstrTempRuleGUID;
			}
			else
			{
				SysFreeString(bstrTempRuleGUID);
				SysFreeString(bstrRuleName);
			}
			bstrTempRuleGUID = NULL;
			bstrRuleName = NULL;

		}
			
		//
		//	create EXE action rule
		//
		if( !bRuleExistsFlag[0] )
		{
			if( g_bDebug )
			{	
				MqLog ("Creating a new EXE action rule\n");
			}
			hr = RuleSet->Add(L"bvt-EXERule" , L"" , L"" , EXE_ACTION , L"" , FALSE , &bstrRuleGUIDs[0]);
			ErrHandle(hr,MQ_OK,L" AddRule Failed(for exe)");
		}
		
		
		//
		//	create COM action rule
		//
		if( !bRuleExistsFlag[1] )
		{
			if( g_bDebug )
			{	
				MqLog ("Creating a new COM action rule\n");
			}
			hr = RuleSet->Add(L"bvt-COMRule" , L"" , L"" , COM_ACTION , L"" , FALSE , &bstrRuleGUIDs[1]);
			ErrHandle(hr,MQ_OK,L" AddRule Failed(for com)");
		}

		//
		//	 now , attach the rules to the triggers
		//
		if( g_bDebug )
		{	
			MqLog ("Attaching the two rules to each \n");
		}
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[0] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and peek Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[1] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and retrieval Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[2] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and transactional retrieval Trigger");

		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[0] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and peek Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[1] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and retrieval Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[2] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and transactional retrieval Trigger");
		
		
		SysFreeString(bstrTriggerGUIDs[0]);
		SysFreeString(bstrTriggerGUIDs[1]);
		SysFreeString(bstrTriggerGUIDs[2]);
		SysFreeString(bstrRuleGUIDs[0]);
		SysFreeString(bstrRuleGUIDs[1]);

	}
	catch (_com_error & comerr) 
	{
		if (comerr.Error() == REGDB_E_CLASSNOTREG)
		{
			MqLog ("CMqTrig - Trigger DLL - MqTrig.dll not registered. This is OK only if you're running 32bit BVT on IA64 machine\n");
		}
		else
		{
			MqLog ("CMqTrig - Got Error: 0x%x\n" , comerr.Error());	
		}
		return MSMQ_BVT_FAILED;
		
	}
	return MSMQ_BVT_SUCC;
	

}






CMqTrig::CMqTrig(
				 const INT iIndex,
				 std::map<std::wstring,std::wstring> Tparms
			 	 )
:iNumberOfTestMesssges(2),cTest(iIndex),m_wcsPeekQueuePathName(L""),m_wcsReceiveQueuePathName(L""),
m_wcsTxReceiveQueuePathName(L""),m_wcsTriggerTestQueueFormatName(L""),
m_wcsPeekQueueQFormatName(L""),m_wcsReceiveQueueQFormatName(L"") , m_wcsTxReceiveQFormatName(L"")
{
	m_wcsPeekQueueQFormatName = Tparms[L"PeekQueueFormatName"];
	m_wcsPeekQueuePathName = Tparms[L"PeekQueuePathName"];
	m_wcsReceiveQueueQFormatName = Tparms[L"ReceiveQueueFormatName"];
	m_wcsReceiveQueuePathName = Tparms[L"ReceiveQueuePathName"];
	m_wcsTxReceiveQFormatName = Tparms[L"TxQueueFormatName"];
	m_wcsTxReceiveQueuePathName = Tparms[L"TxQueuePathName"];
	m_wcsTriggerTestQueueFormatName = Tparms[L"TriggerTestQueueFormatName"];

	m_vecQueuesFormatName.push_back(m_wcsPeekQueueQFormatName);
	m_vecQueuesFormatName.push_back(m_wcsReceiveQueueQFormatName);
	m_vecQueuesFormatName.push_back(m_wcsTxReceiveQFormatName);
	if( g_bDebug )
	{	
		MqLog ("Purge trigger queues\n");
	}
	for(unsigned int i=0;i<m_vecQueuesFormatName.size();i++)
	{
		HANDLE hRecQueue = NULL;
		if( g_bDebug )
		{
			wMqLog(L"CMqTrig - Try to open trigger queue %s\n",m_vecQueuesFormatName[i].c_str());
		}
		HRESULT hr = MQOpenQueue(m_vecQueuesFormatName[i].c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hRecQueue);
		if(FAILED(hr))
		{
			wMqLog(L"CMqTrig - Failed to open queue %s error 0x%x \n",m_vecQueuesFormatName[i].c_str(),hr);
			throw INIT_Error("Failed to open queue");
		}
		hr = MQPurgeQueue(hRecQueue);
		if(FAILED(hr))
		{
			wMqLog(L"CMqTrig - Failed to purge queue %s error 0x%x \n",m_vecQueuesFormatName[i].c_str(),hr);
			throw INIT_Error("Failed to purge queue");
		}
		MQCloseQueue(hRecQueue);
	}
	HANDLE hRecQueue = NULL;
	HRESULT hr = MQOpenQueue(m_wcsTriggerTestQueueFormatName.c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hRecQueue);
	if(FAILED(hr))
	{
		wMqLog(L"CMqTrig - Failed to open queue %s error 0x%x \n",m_wcsTriggerTestQueueFormatName.c_str(),hr);
		throw INIT_Error("Failed to open queue");
	}
	hr = MQPurgeQueue(hRecQueue);
	if(FAILED(hr))
	{
		wMqLog(L"CMqTrig - Failed to purge queue %s error 0x%x \n",m_wcsTriggerTestQueueFormatName.c_str(),hr);
		throw INIT_Error("Failed to purge queue");
	}
	MQCloseQueue(hRecQueue);

	if (FAILED(TrigInit()))
	{
		wMqLog(L"CMqTrig - Failed to initialize triggers and rules\n");
		throw INIT_Error("Failed to initialize triggers and rules");
	}

}

CMqTrig::Start_test()
/*++  
	Function Description:
		sends two messages, one for each queue and check the results
	Arguments:
		none
	Return code:
		none
--*/
{
	try
	{

		//
		//	open the queue to which the messages will be sent to
		//
		IMSMQQueueInfoPtr qinfo("MSMQ.MSMQQueueInfo");
		IMSMQQueuePtr qSend;
		IMSMQMessagePtr m("MSMQ.MSMQMessage");
		_variant_t bTransaction((LONG_PTR)MQ_SINGLE_MESSAGE);     
		
		//
		//	send 2 messages to each queue
		//
		if( g_bDebug )
		{	
			MqLog ("Sending two messages to each queue\n");
		}
		for( unsigned int i=0; i < m_vecQueuesFormatName.size(); i++)
		{
			qinfo->FormatName = m_vecQueuesFormatName[i].c_str();
			qSend = qinfo->Open(MQ_SEND_ACCESS,MQ_DENY_NONE);
			for(int j=0; j <iNumberOfTestMesssges; j++) 
			{
				m->Label = m_vecQueuesFormatName[i].c_str();
				if( i == 2 )
				{
					m->Send(qSend , &bTransaction);
				}
				else
				{
					m->Send(qSend);
				}

			}
		}
			qSend->Close();
	}
	catch( _com_error & cErr )
	{
		MqLog("CMqTrig::Start_test failed with error 0x%x",cErr.Error());
		return MSMQ_BVT_FAILED;
	}
	return MSMQ_BVT_SUCC;
}

CMqTrig::CheckResult()
/*++  
	Function Description:
		trying to receive 13 messages - 6 that were send as a result of an EXE invocation.
		6 that were sent as a result of a COM invocation. and the retrieval of the last message
		should fail.
	Arguments:
		none
	Return code:
		none
--*/
{
	try
	{
		if( g_bDebug )
		{	
			MqLog ("checking the results\n");
		}
		IMSMQQueueInfoPtr qRinfo("MSMQ.MSMQQueueInfo");
		IMSMQQueuePtr qRSend;
		IMSMQMessagePtr mR("MSMQ.MSMQMessage");
		_variant_t bReceiveTimeout((long)3000);      
		_variant_t bWantBody((bool)true);   
		DWORD dwArrOfInvocations[2] = {0,0};
		qRinfo->FormatName = m_wcsTriggerTestQueueFormatName.c_str();
		qRSend = qRinfo->Open( MQ_RECEIVE_ACCESS , MQ_DENY_NONE);

		for(unsigned int i=0 ; i < (m_vecQueuesFormatName.size() * iNumberOfTestMesssges*2)+1 ; i++ )
		{
			mR = qRSend->Receive(&vtMissing, &vtMissing, &bWantBody, &bReceiveTimeout);
			if ((mR == NULL) && (i < (m_vecQueuesFormatName.size() * iNumberOfTestMesssges*2)))
			{
				MqLog("MqTrig - %d actions did not invoke\n" , iNumberOfTestMesssges*6- i);
				MqLog("MqTrig - %d actions with COM action invoked\n" , dwArrOfInvocations[0]);
				MqLog("MqTrig - %d actions with EXE action invoked\n" , dwArrOfInvocations[1]);
				return MSMQ_BVT_FAILED;
			}
			if ((mR != NULL))
			{
				if (i < (m_vecQueuesFormatName.size() * iNumberOfTestMesssges*2)+1)
				{
					_bstr_t bstrMessageLabel = mR->Label;
					_bstr_t bstrMessageBody = mR->Body;
					if (wcsstr((LPWSTR)bstrMessageBody , L"COM") != NULL)
					{
						if( g_bDebug )
						{	
							MqLog ("COM action number %d has invoked\n" , dwArrOfInvocations[0]+1);
						}
						dwArrOfInvocations[0]++;
					}
					if (wcsstr((LPWSTR)bstrMessageBody , L"EXE") != NULL)
					{
						if( g_bDebug )
						{	
							MqLog ("EXE action number %d has invoked\n" , dwArrOfInvocations[1]+1);
						}
						dwArrOfInvocations[1]++;
					}
				}
				else
				{
					MqLog("too many actions invoked\n");
					return MSMQ_BVT_FAILED;
				}
			}	
		}
		qRSend->Close();
	}
	catch( _com_error & cErr )
	{
		MqLog("CMqTrig::CheckResult failed with error 0x%x",cErr.Error());		
		return MSMQ_BVT_FAILED;
	}
	return MSMQ_BVT_SUCC;
}

HRESULT DeleteAllTriggersAndRules()
/*++  
	Function Description:
		Deletes all triggers and rules
	Arguments:
		none
	Return code:
		none
--*/
{
	//
	//	initialize TriggerSet
	//
	IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet");
	HRESULT hr = TriggerSet->Init((LPWSTR)NULL);
	ErrHandle(hr,MQ_OK,L"TriggerSet init failed");
	
	hr = TriggerSet->Refresh();
	ErrHandle(hr,MQ_OK,L"TriggerSet refresh failed");

	if( g_bDebug )
	{	
		MqLog ("deleting all triggers\n");
	}

	DWORD dwNumOfExistingTriggers = TriggerSet->Count;
	DWORD nLoopIndex = 0;
	BSTR bstrTempTriggerGUID = NULL;
	BSTR bstrTriggerName = NULL;
	DWORD dwNumOfDeletedTriggers = 0;
	for (nLoopIndex = 0 ; nLoopIndex < dwNumOfExistingTriggers ; nLoopIndex++)
	{
		bstrTempTriggerGUID = NULL;
		bstrTriggerName = NULL;
		TriggerSet->GetTriggerDetailsByIndex(nLoopIndex-dwNumOfDeletedTriggers , &bstrTempTriggerGUID , &bstrTriggerName,NULL,NULL,NULL,NULL,NULL,NULL); 
		if (wcscmp(bstrTriggerName , L"bvt-PeekTrigger") || 
			wcscmp(bstrTriggerName , L"bvt-RetrievalTrigger") ||
			wcscmp(bstrTriggerName , L"bvt-TransactionalRetrievalTrigger"))
		{
			hr = TriggerSet->DeleteTrigger(bstrTempTriggerGUID);
			ErrHandle(hr,MQ_OK,L"DeleteTrigger failed");
			dwNumOfDeletedTriggers++;

		}
		SysFreeString(bstrTempTriggerGUID);
		SysFreeString(bstrTriggerName);
		bstrTempTriggerGUID = NULL;
		bstrTriggerName = NULL;
	}

	if( g_bDebug )
	{	
		MqLog ("Successfully deleted all triggers\n");
	}

	//
	//	initialize RuleSet
	//

	IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet");
	hr = RuleSet->Init((LPWSTR)NULL);
	ErrHandle(hr,MQ_OK,L"RuleSet init failed");
	hr = RuleSet->Refresh();
	ErrHandle(hr,MQ_OK,L"RuleSet refresh failed");

	if( g_bDebug )
	{	
		MqLog ("deleting all Rules\n");
	}

	DWORD dwNumOfExistingRules = RuleSet->Count;
	BSTR bstrTempRuleGUID = NULL;
	BSTR bstrRuleName = NULL;
	DWORD dwNumOfDeletedRules = 0;
	for (nLoopIndex = 0 ; nLoopIndex < dwNumOfExistingRules ; nLoopIndex++)
	{
		RuleSet->GetRuleDetailsByIndex(nLoopIndex-dwNumOfDeletedRules , &bstrTempRuleGUID , &bstrRuleName,NULL,NULL,NULL,NULL,NULL); 
		if (wcscmp(bstrRuleName , L"bvt-EXERule") || wcscmp(bstrRuleName , L"bvt-COMRule"))
		{
			hr = RuleSet->Delete(bstrTempRuleGUID);
			ErrHandle(hr,MQ_OK,L"Delete (Rule) failed");
			dwNumOfDeletedRules++;
		}
		SysFreeString(bstrTempRuleGUID);
		SysFreeString(bstrRuleName);
		bstrTempRuleGUID = NULL;
		bstrRuleName = NULL;
	}

	if( g_bDebug )
	{	
		MqLog ("Successfully deleted all rules\n");
	}

	return MSMQ_BVT_SUCC;




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\msmqbvt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: msmqbvt.h

Abstract:

	Mqbvt header file

Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning( disable : 4786 )
#ifndef _MSMQBVT
#define _MSMQBVT
#ifdef  __cplusplus
extern "C" {
#endif

void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif


#include <assert.h>
#ifdef _DEBUG
	#define _DEBUGASSERT
	#undef _DEBUG
	#undef ASSERT
#endif
#define ASSERT(x)
#include <windows.h>
#pragma warning( push, 3 )	
	#include <iostream>
	#include <string>
	#include <tchar.h>
	#include <vector>
	#include <list>
	#include <map>
	#include <clusapi.h>

#pragma warning( pop ) 	

	#include "mqparams.h"
	#include <transact.h>
	#include <xolehlp.h>
	#include <winsock.h>
	#include <process.h>
	#include "errorh.h"

    #import "mqoa.tlb"
	
	#include <mq.h>

    #include <autoptr.h>
	
    #pragma warning( disable : 4786)
	
    // Declare const value for BVT operation
	
	
	#define Win2K (5)
	#define NT4 (4)
	
	#define MQBVTMULTICASTADDRESS L"255.255.0.1:1805"

	#define BVT_RECEIVE_TIMEOUT (3000)
	#define BVT_MAX_FORMATNAME_LENGTH (255)
	#define MSMQ_BVT_SUCC (0)
	#define MSMQ_BVT_FAILED (1)
	#define MAX_GUID 200
	#define MQBVT_MAX_TIME_TO_BE_RECEIVED		(3600)

	#define CREATEQ_AUTHENTICATE	        	(0x4000)
	#define CREATEQ_TRANSACTION					(0x8000)
	#define CREATEQ_PRIV_LEVEL                  (0x6000)
	#define	CREATEQ_DENYEVERYONE_SEND           (0x1000)
	#define MULTICAST_ADDRESS					(0x0100)


	#define C_API_ONLY 0x1
	#define COM_API 0x3


	extern BOOL g_bDebug;
	extern std::wstring wcsFileName;

	enum InstallType 
	{
		DepClient,
		Cluster,
		DomainU,
		LocalU,
		DepClientLocalU,
		WKG
	};


	enum e_InstallationType
	{
		LocalUser,
		WorkGroup,
		DomainUser
	};
	enum SetupType 
	{
		ONLYSetup ,
		RunTimeSetup,
		ONLYUpdate,
		WorkWithStaticQueue,
		DeleteQueue
	};

	
	enum EncryptType 
	{ 
		No_Encrypt,
		Base_Encrypt,
		Enh_Encrypt
	};

std::string My_WideTOmbString( std::wstring wcsString);
std::wstring My_mbToWideChar( std::string wcsString);

INT RetriveParmsFromINIFile ( std::wstring wcsSection, std::wstring wcsKey , std::wstring & wcsValue, std::wstring csFileName=L".\\MSMQbvt.INI" );
int iDetactEmbededConfiguration ();
HRESULT RetrieveMessageFromQueue (std::map < std::wstring, std::wstring> & mRetriveParms );
HRESULT RetrieveMessageFromQueueViaCom (std::map <std::wstring,std::wstring> & mRetriveParms );
INT ReturnGuidFormatName( std::wstring & wcsQueuePath , INT GuidType , BOOL bWithOutLocalString = FALSE );
extern const WCHAR* const g_wcsEmptyString;
DWORD __stdcall TimeOutThread(void * param);
class INIT_Error
{
	public:
		INIT_Error (const CHAR * wcsDescription);
		std::string GetErrorMessgae () const { return m_wcsErrorMessages; };
		virtual ~INIT_Error() {};
	private:	
		std::string m_wcsErrorMessages;
}; 

//
// This class hold all queue params,
// All the releation operator need to use STL link list !
//
class my_Qinfo
{

	public:
		 my_Qinfo ();
		 my_Qinfo(std::wstring wcsPathName , std::wstring wcsFormatName , std::wstring wcsLabel );
		 my_Qinfo (const my_Qinfo & cObject);
		 inline std::wstring GetQPathName () { return wcsQpathName; }
		 inline std::wstring GetQLabelName () { return wcsQLabel; }
		 inline std::wstring GetQFormatName () { return wcsQFormatName; }
		 void PutFormatName (std::wstring wcsFormatName );
		 void dbg_printQueueProp ();
		 virtual ~my_Qinfo() {};
		 friend bool operator == (my_Qinfo objA, my_Qinfo B );
		 friend bool operator != (my_Qinfo objA, my_Qinfo B );
		 friend bool operator > (my_Qinfo objA, my_Qinfo B );
		 friend bool operator < (my_Qinfo objA, my_Qinfo B );
	private:
	     std::wstring wcsQpathName;
		 std::wstring wcsQFormatName;
		 std::wstring wcsQLabel;
};


//
// This class contain all the Queue in link list
//
class QueuesInfo
{
	public:	
		virtual ~QueuesInfo() {};
		INT UpdateQueue (std::wstring wcsQPathName,std::wstring wcsQFormatName,std::wstring wcsQueueLabel =L"Empty");
		void dbg_printAllQueueProp ();
		INT del_all_queue ();
		std::wstring ReturnQueueProp ( std::wstring QwcsPathName ,  int iValue = 1 );
	private:
		std::list <my_Qinfo> m_listofQueues;

};




	class cBvtUtil 
	{
	
	public:
		cBvtUtil ( std::wstring wcsRemoteComputerName , const std::list<std::wstring> & listOfRemoteMachine,const std::wstring & wcsMultiCastAddress ,BOOL bUseFullDnsName , SetupType eSetupType, BOOL bTriggerInclude );
		INT Delete ();
		e_InstallationType GetInstallationType ();
		EncryptType GetEncryptionType (); // Return 128 / 40  Encryption Support.
		InstallType m_eMSMQConf;
		
		std::list<std::wstring> m_listOfRemoteMachine;
		std::wstring m_wcsRemoteComputerNetBiosName;
		std::wstring m_wcsRemoteMachineNameFullDNSName;
		

		std::wstring m_wcsLocalComputerNetBiosName;
		std::wstring m_wcsLocalComputerNameFullDNSName;
		
		// This hold The current MachineName Should be one of Full DNS NAME Machine Name
		std::wstring m_wcsCurrentLocalMachine;
		std::wstring m_wcsCurrentRemoteMachine;
		// String the contain the local machine guid
		std::wstring m_wcsMachineGuid;
		std::wstring m_wcsRemoteMachineGuid;
		std::wstring m_wcsLocateGuid;
		std::wstring m_wcsClusterNetBiosName;
		
		void UpdateQueueParams(std::wstring wcsQueuePathName,std::wstring wcsQueueFormatName , std::wstring wcsQueueLabel = L"Empty");
		std::wstring ReturnQueueFormatName( std::wstring wcsQueueLabel );
		std::wstring ReturnQueuePathName( std::wstring wcsQueueLabel );
		void dbg_PrintAllQueueInfo();
		virtual ~cBvtUtil() {};
		std::wstring GetMachineID( std::wstring wcsRemoteMachineName );
		bool bWin95 ;
		const std::wstring GetMultiCastAddress() { return m_MuliCastAddress; }
		BOOL GetTriggerStatus() { return m_bIncludeTrigger; }
		BOOL iamWorkingAgainstPEC ();
	private:
		EncryptType HasEnhancedEncryption( std::wstring wcsMachineName ); // Return 128 / 40  Encryption Support
		EncryptType DetectEnhancedEncrypt (); // Return 128 / 40  Encryption Support.
		INT iAmMSMQInWorkGroup ();
		BOOL iAmLocalUser ();
		INT iAmCluster();
		std::wstring GetFullDNSName(std::wstring wcsHostName);
		INT iAmDC (void);
		bool AmIWin9x ();
		bool CheckIfServiceRuning( std::wstring wcsMachineName , std::string csServiceName );
		bool IsMSMQInstallSucceded ();
		bool IsDnsHostNameExist (std::wstring wcsRemoteMachineFullDNSname );
		int DeleteAllQueues ();
		e_InstallationType m_InstallationType;
		EncryptType m_EncryptType;
		BOOL m_bUseOnlyDirectFormatName;
		bool m_bDeleteFullDNSQueue;
		QueuesInfo AllQueuesInTheTest;
		std::list<my_Qinfo> m_listQueuesFormatName;
		std::wstring m_MuliCastAddress;
		BOOL m_bIncludeTrigger;
	};

	class ThreadBase_t
	{

	public:
	  ThreadBase_t();
	  virtual ~ThreadBase_t();  
	  void StartThread();
	  virtual void Suspend();
	  virtual void Resume();
	  HANDLE GetHandle()const;
	  DWORD GetID()const; 
	private:
	   virtual INT ThreadMain()=0; 
	   static unsigned int __stdcall ThreadFunc(void* params);
	   HANDLE m_hThread;
	   DWORD m_Threadid;
	};


	class cTest :public ThreadBase_t
	{
	
	public:
		cTest( const INT iTestNumber ); 
		cTest() :m_testid(0) {};
		virtual ~cTest(){};
		INT Get_Testid() { return m_testid; } // Return Test Number
		//
		// Pure Virtual Member All tests need to implement those function
		//
		virtual void Description() = 0 ;  // Print Test Description
		virtual INT Start_test()  = 0 ;   // Start Test
		virtual INT CheckResult() = 0 ; // Check The Pass \ Fail
		std::wstring m_wcsGuidMessageLabel;
		INT m_testid;
		INT ThreadMain();
	private:
		
		std::wstring All_queue_type; // All the Queue must Create with the Same Type For Delete process
		GUID m_gTestguid; // Test has a guid per instance

	};

	//
	// Path To support NT4 Machines
	// MQRegisterCertificate Api.
	//

	typedef HRESULT  
	(APIENTRY * DefMQRegisterCertificate) 
	(
    IN DWORD   dwFlags,
    IN PVOID   lpCertBuffer,
    IN DWORD   dwCertBufferLength
	);

	

	typedef
	HRESULT
	(APIENTRY * DefMQADsPathToFormatName)
	(
		IN LPCWSTR lpwcsADsPath,
		OUT LPWSTR lpwcsFormatName,
		IN OUT LPDWORD lpdwFormatNameLength
	);





    
//
// bugbug - Default parmerter is for recive operation needs to know abot the buffers size
//

//
// class cPropVar 
// 
// This class provides methods for manipulating
// the PROPVARIANT structure and array.
//
// It is called by threads that create queues
// and threads that send or receive messages.
//
class cPropVar 
{
public:
	cPropVar ( INT iNumberOFProp ); 
	//cPropVar () : pQueuePropID(NULL),pPropVariant(NULL),hResultArray(NULL),iNumberOfProp(0) {};
	virtual ~cPropVar ();
	virtual INT AddProp( QUEUEPROPID cPropID , VARTYPE MQvt , const void *pValue , DWORD dwsize = 0 );
	int ReturnMSGValue ( QUEUEPROPID cPropID , VARTYPE MQvt  ,void * pValue );
	MQQUEUEPROPS * GetMQPROPVARIANT ();
	MQQUEUEPROPS m_QueueProps;
	MQMSGPROPS * GetMSGPRops ();
	MQPROPVARIANT ReturnOneProp( QUEUEPROPID aPropID) ;
	MQMSGPROPS m_myMessageProps;
	
	friend HRESULT APIENTRY MQCreateQueue(
					IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
					IN OUT MQQUEUEPROPS* pQueueProps,
					OUT LPWSTR lpwcsFormatName,
					IN OUT LPDWORD lpdwFormatNameLength    );

	friend HRESULT 	APIENTRY MQSendMessage(
											IN QUEUEHANDLE hDestinationQueue,
											IN MQMSGPROPS* pMessageProps,
											IN ITransaction *pTransaction  );
	friend HRESULT APIENTRY MQReceiveMessage(
												IN QUEUEHANDLE hSource,
												IN DWORD dwTimeout,
												IN DWORD dwAction,
												IN OUT MQMSGPROPS* pMessageProps,
												IN OUT LPOVERLAPPED lpOverlapped,
												IN PMQRECEIVECALLBACK fnReceiveCallback,
												IN HANDLE hCursor,
											    IN ITransaction* pTransaction
											);


	
private:
	INT iNumberOfProp;
	QUEUEPROPID *  pQueuePropID;
	MQPROPVARIANT *  pPropVariant;
	HRESULT *  hResultArray;
};



DWORD my_RegisterCertificate (bool bInstallType, DWORD dwRegisterFlag = MQCERT_REGISTER_IF_NOT_EXIST);
INT cMQSetupStage ( SetupType eSetupType ,  cBvtUtil & CurrentTest  );
DWORD RegisterCertificate (bool bInstallType);

class cLevel8:public cTest
{
	public:
		cLevel8 (std::map <std::wstring,std::wstring> & Params);
		~cLevel8 ();
		virtual void Description();     // Print Test Description
		virtual INT Start_test();       // Start Test
		virtual INT CheckResult();    // Check The Pass \ Fail
		INT DebugIt();
	private:		
		std::wstring m_DestQueueFormatName;
		std::wstring m_wcsPassWord,m_wcsUserName,m_wcsDomainName;
		HANDLE m_hSeCtxt;
};

class cSendMessages :public cTest 
{
	public:
		
		cSendMessages (INT iTid, std::map <std::wstring,std::wstring> Params );
		virtual ~cSendMessages () {};
		void Description();   // Print Test Description
		INT Start_test();     // Start Test
		INT CheckResult();  // Check The Pass \ Fail
	
	private:
		HRESULT FindMessageInQueue (HANDLE hQueue , HANDLE & Cursor ,GUID );
		
		std::wstring wcsGuidMessageLabel;
		std::wstring m_wcsDestQueueFullPathName; // the Full Path name need to incluse the machine name
		std::wstring m_wcsDestQFormatName,m_wcsAdminQFormatName;
		std::wstring m_wcsDestDirectFormatName;
		std::wstring m_wcsAdminDirectFormatName;
		std::wstring m_wcsDestHTTPDirectFormatName;
		BOOL m_bUseHTTPDirectFormatName;
		BOOL m_bUseOnlyDirectFormatName; 
	
};


// Transaction test class






class StrManp 
{
public:
	StrManp (int size,std::wstring str);
	StrManp (int size);
	~StrManp();
	void SetStr(std::wstring str);
	std::wstring  GetStr(int Index) { return ((Index < Size) ? array[Index].c_str():NULL); }
	void print ();
	void Clear();
	friend int operator != (StrManp& s1,StrManp &s2);
	friend int operator == (StrManp& s1,StrManp &s2);
private:
	void operator = (StrManp Csrc);
	std::vector<std::wstring> array;
	const int Size;
};
int operator == (const StrManp& s1,const StrManp &s2);



class OrderTransaction 
{
	
public:
	OrderTransaction ( bool bUseExVersion );
	virtual ~OrderTransaction();
	INT OrderTransaction::xDTCBeginTransaction(ITransaction ** ppXact );
private:
	HINSTANCE m_hxolehlp;
	ITransactionDispenser* g_pDispenser ;
};

class cTrans : public cTest
{
public:
	cTrans (INT index , std::map < std :: wstring , std:: wstring > Tparms,bool bTemp);
	virtual ~cTrans();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	virtual void CleanAfterTest () {};
private:
	void operator = (cTrans Csrc);
	StrManp * m_pSendBlock;
	std::wstring m_wcsFormatNameBufferQ1;
	std::wstring m_wcsFormatNameBufferQ2;
	const int m_ciNumberOfMessages;
	OrderTransaction cOrderTransaction;
	wchar_t m_wcsTempBuf[20];
	bool m_bRunOnDependetClient;
protected:
	DWORD m_ResualtVal; 
};




class SecCheackAuthMess : public cTest
{
protected:
	MSMQ::IMSMQQueueInfoPtr  m_Destqinfo; //Dest queue
	MSMQ::IMSMQQueueInfoPtr  m_Adminqinfo;// Admin queue
	std::wstring  m_DestqinfoFormatName;
	std::wstring  m_AdminqinfoFormatName;
	std::wstring  m_wcsGuidMessageLabel2;
	std::wstring  m_DestQueueInfoPathName;
	DWORD m_ResualtVal;
	MSMQ::IMSMQMessagePtr m_msg;
	const int cNumerOfMessages;
public:
	void operator = (SecCheackAuthMess Csrc);
	SecCheackAuthMess (int Tnumber ,  std :: map <std::wstring,std::wstring> TestParms );
	virtual ~SecCheackAuthMess();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	virtual void CleanAfterTest () {};
	bool m_bTryToRefreshLater;
	BOOL m_bUseHttpFormatName;
	bool m_bNeedToRefresh;
};

//
// Check Get machine name 
//
class MachineName : public cTest
{
public:
	MachineName (int iTestIndex , std::map < std::wstring , std :: wstring > Tparmes );
	int Start_test ();
	int CheckResult (){ return MSMQ_BVT_SUCC; };
	void Description();   // Print Test Description
private:
	std::wstring wcsLocalMachineName,wcsLocalMachineFullDns,wcsRemoteMachine,wcsRemoteMachineFullDns;
	bool m_bWorkWithFullDNSName;
};

class xToFormatName  : public cTest
{
public:
	xToFormatName (int iTestIndex , std::map < std::wstring , std :: wstring > Tparmes );
	
	int Start_test ();
	int CheckResult ();
	void Description() ;   // Print Test Description

private:
	bool m_bWorkGroupInstall;
	bool m_bCanWorksOnlyWithMqAD;
	int m_iEmbedded;
	std::wstring m_wcsFormatNameArray[2];
	std::wstring m_wcsPathNameArray[2];
	
};


class PrivateMessage :public cTest
{
public:
	PrivateMessage (INT index, std :: map <std::wstring, std::wstring >);
	virtual ~PrivateMessage();
	void Description();
	INT CommonMsgProperty();
	virtual INT Start_test();
	virtual INT CheckResult();
	virtual void CleanAfterTest () {} ;
private:
	DWORD Private_level;
	WCHAR m_DestqinfoFormatName[BVT_MAX_FORMATNAME_LENGTH];
	WCHAR m_AdminqinfoFormatName[BVT_MAX_FORMATNAME_LENGTH];
	BOOL m_bUseEnhEncrypt;
	wchar_t wcszMlabel[30]; // Message Label for 128 bit encrypt
	std::wstring wcsNACKMessageGuid;
	std::wstring m_wcsAdminQFormatName;
protected:
	MSMQ::IMSMQQueueInfoPtr m_Destqinfo;
	MSMQ::IMSMQQueueInfoPtr m_Adminqinfo;
	DWORD m_ResualtVal;
	MSMQ::IMSMQMessagePtr m_msg;
};

/*
	Send transaction message using DTC to remote queue.
	using com interface.

*/
class xActViaCom : public cTest
{
public:
	xActViaCom (INT index , std::map < std :: wstring , std:: wstring > Tparms );
	virtual ~xActViaCom();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	void operator = (xActViaCom Csrc);
protected:
	std::wstring m_wcsDestQueueFormatName;
	std::wstring m_SeCTransactionGuid;
	BOOL m_bNT4WithSp6;
	MSMQ::IMSMQQueueInfoPtr  m_Destqinfo;
	INT m_ixActIndex;
	StrManp * m_pSendBlock;
	const INT m_iMessageInTransaction;
};

class xActUsingCapi: public xActViaCom
{
	public:
		xActUsingCapi (INT index , std::map < std :: wstring , std:: wstring > Tparms );
		virtual INT CheckResult();
	private:
		void operator = (xActUsingCapi Csrc);
		
};


/*
	This class check authenticate messages with NOT authenticate queue !
	The tests is to send authenticate and see if the message reach to the queue
	This check by Admin queue ACK/NACK


  */


class CheckNotAuthQueueWITHAuthMessage :public SecCheackAuthMess 
{
public:
	CheckNotAuthQueueWITHAuthMessage(int i , std::map < std::wstring , std::wstring > & Tparms );
	virtual ~CheckNotAuthQueueWITHAuthMessage()	{};
	void Description();
};

class CheackAuthQueueWithOutAuthMessgae:public SecCheackAuthMess 
{
public:
	CheackAuthQueueWithOutAuthMessgae(int i , std :: map < std ::  wstring  ,std :: wstring> & Tparms);
    int Start_test();
};

//
// 
//

class COpenQueues :public cTest
{
public:
	COpenQueues ( INT Index,  std::map<std::wstring,std::wstring>  & Tparms );
	~COpenQueues () {};
	INT Start_test ();
	INT CheckResult();
	void Description();
private:
	INT iWorkGroupFlag;
	void dbg_printAllQueue();
	int m_iEmbedded;
	std::wstring m_wcsLocalMachineName;
	std::vector <std::wstring> m_MachineName;
	std::vector <std::wstring> m_IPaddress;
	std::vector <std::wstring> m_MachineGuid;
	std::vector <std::wstring> m_vSpeceilFormatNames;
};


//
// This class check if mqoa register, 
// this check the IDispatch machnizem.
//
class isOARegistered : public cTest
{
public:
	isOARegistered (int Tnumber ): cTest( Tnumber ) {};
	virtual ~isOARegistered() {};
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult() { return MSMQ_BVT_SUCC;	}
	virtual void CleanAfterTest () {};
};

INT CatchComErrorHandle ( _com_error & ComErr , int  ITestID);
void ErrorHandleFunction (std::wstring Message,HRESULT hRc,const CHAR * File,const INT Line);
#define ErrHandle(hRc,ExpectedResualt,Message) if (hRc != ExpectedResualt) { ErrorHandleFunction (Message,hRc,__FILE__,__LINE__); return MSMQ_BVT_FAILED; }

std::wstring ToLower(std::wstring wcsLowwer);

class cLocateTest : public cTest
{
public:
	cLocateTest (INT index , std::map < std :: wstring , std:: wstring > Tparms );
	virtual ~cLocateTest() {};
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
private:
	std::wstring wcsLocateForLabel;
	INT icNumberOfQueues;
	std::wstring m_wcsLocalMachineName;
	std::wstring m_wcsLocalMachineComputerName;
	std::wstring m_wcsLocalMachineFullDNSName;
	int m_iEmbedded;
	bool m_bUseStaticQueue;
	bool m_bWorkAgainstNT4;
};


class cSetQueueProp : public cTest
{
public:
	cSetQueueProp (int iTestIndex,std::map < std :: wstring , std:: wstring > Tparms );
	~cSetQueueProp();
	int Start_test ();
	int CheckResult ();
	void Description() ;   // Print Test Description

private:
	std::wstring m_destQueueFormatName;
	std::wstring m_QueuePathName;
	std::wstring m_RandQueueLabel;
	std::wstring m_publicQueueFormatName;
	BOOL VerifyQueueHasOwner (SECURITY_DESCRIPTOR *pSD);
	BOOL GetOnerID( PSID pSid );

};

//
// This class tests the Triggers functionality.
// It uses the hack in the Triggers service that sends a MSMQ message to queue
// .\private$\TriggerTestQueue containing information about invoked action.
// This hack works only if "TriggerTest" REG_SZ with empty string  is defined in registry in path:
// HKLM MSMQ\Triggers. In order to get the messages from the Triggers service, after defining the key, 
// it is requiered to stop and start the service
// 

class CMqTrig:public cTest
{
	public:
		CMqTrig():iNumberOfTestMesssges(2){ assert(0); }
	    CMqTrig( const INT iIndex,
				 std::map<std::wstring,std::wstring> Tparms
			   );
		CMqTrig( CMqTrig & );
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		HRESULT TrigInit();
		std::vector<std::wstring> m_vecQueuesFormatName;
		const int iNumberOfTestMesssges;
		std::wstring m_wcsPeekQueueQFormatName;
		std::wstring m_wcsReceiveQueueQFormatName;
		std::wstring m_wcsTxReceiveQFormatName;
		std::wstring m_wcsPeekQueuePathName;
		std::wstring m_wcsReceiveQueuePathName;
		std::wstring m_wcsTxReceiveQueuePathName;
		std::wstring m_wcsTriggerTestQueueFormatName;
		void operator = (const CMqTrig & Csrc );
};		


class CMqAdminApi:public cTest
{
	public:
		CMqAdminApi( const INT iIndex , std::wstring m_wcsLocalComputerNetBiosName);
		~CMqAdminApi();
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		MQMGMTPROPS mqProps;
		PROPVARIANT propVar[11];
		PROPID propId[11];
		std::wstring m_wcsLocalComputerNetBiosName;
		std::wstring m_wcsFormatName;
	
};		

class CSRMP:public cTest
{
	public:
		CSRMP( const INT iIndex , std::wstring m_publicQueueFormatName);
		~CSRMP();
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		LPWSTR m_pEnvelope;
		HANDLE m_hCursor;
		HANDLE m_hQueue;
		std::wstring m_publicQueueFormatName;

};			

class Log 
{
public:
	Log(std::wstring wcsLogFileName);
	~Log();
		
	int WriteToFile ( std::wstring wcsLine );
private:
	// critical Section
	CRITICAL_SECTION CriticalSection;
	HANDLE hLogFileHandle;
	bool m_bCanWriteToFile;
};

//
// Bvt global log file
// 
#define DebugMqLog(params)\
	if (g_bDebug)     \
	{                 \
		MqLog(params);\
	}                 

#define DebugwMqLog(params)\
	if (g_bDebug)     \
	{                 \
		wMqLog(params);\
	}    
extern P<Log> pGlobalLog;
#define MAXCOMMENT 200
void MqLog(LPCSTR lpszFormat, ...);
void wMqLog(LPWSTR lpszFormat, ...);
#define MqBvt_SleepBeforeWait (5000) // time in Sec sleep before test.
#define Total_Tests 30

//bugbug
#define g_cwcsDlSupportCommonQueueName L"DLQueues"

/*
	ThreadBase_t class function implementation.
*/

//constructor
inline ThreadBase_t::ThreadBase_t():m_hThread(NULL),m_Threadid(0)
{
  
}


//destructor
inline ThreadBase_t::~ThreadBase_t()
{
	if(m_hThread != NULL)
	{
		CloseHandle(m_hThread);
	}
}


//return the thread handle
inline HANDLE ThreadBase_t::GetHandle ()const
{
  return m_hThread;
}
 
//return the thread id
inline DWORD ThreadBase_t::GetID()const
{
  return m_Threadid;
}

//create the actual thread-must be called first
inline void ThreadBase_t::StartThread()
/*++
	Create Thread and duplicate handle
--*/
{

  
 HANDLE h=(HANDLE)_beginthreadex(NULL,
	                              8192,
								  ThreadBase_t::ThreadFunc,
								  this,
								  CREATE_SUSPENDED,
								  reinterpret_cast<unsigned int *>(&m_Threadid));
  if(h == NULL)
  {
	 INIT_Error("Failed to create thread \n");  
  }

  BOOL b=DuplicateHandle(GetCurrentProcess(),
	              h,
				  GetCurrentProcess(),
				  &m_hThread,
				  0,
				  FALSE,
				  DUPLICATE_SAME_ACCESS);

  if(b != TRUE)
  {
	INIT_Error("Falied to duplicate handle");
  }
  ResumeThread(h);
  b=CloseHandle(h);
  assert(b);

}

//thread function - calls to the drived class Run method
inline  unsigned int __stdcall ThreadBase_t::ThreadFunc(void* params)
{
  // 
  // Casting this pointer to the drived class ThreadMain
  //
  ThreadBase_t* thread = static_cast<ThreadBase_t*>(params);
  unsigned int ret=thread->ThreadMain();
  return ret;
}


//suspend the thread
inline void ThreadBase_t::Suspend()
{
  SuspendThread(m_hThread);
}


//resume the thread
inline void ThreadBase_t::Resume()
{
  ResumeThread(m_hThread);
}


//
// Auto class for free library
//


class AutoFreeLib
{
public:
	AutoFreeLib(const CHAR * csLibName )
	{
		m_hModule = LoadLibrary( csLibName );
		if( !m_hModule )
		{
			throw INIT_Error("Failed to load DLL\n");
		}
		
	}
	virtual ~AutoFreeLib () { FreeLibrary(m_hModule); }
	inline HMODULE GetHandle() { return m_hModule; }

private:
	
	HMODULE m_hModule;
	
};


class cMqNTLog
{
public:
	cMqNTLog( const std::string & csFileName  );
	~cMqNTLog();
	cMqNTLog( const cMqNTLog & CCopy);
	void ReportResult(bool bRes , CHAR * pcsString);
	void LogIt( const std::string & csLine );
	BOOL VLog( DWORD dwFlags, char* fmt, va_list arglist );
	BOOL CreateLog( char *szLogFile );
	BOOL __cdecl Info( char* fmt, ... );
    BOOL __cdecl Sev1( char* fmt, ... );
    BOOL __cdecl Warn( char* fmt, ... );
    BOOL __cdecl Pass( char* fmt, ... );
	void Report();
	BOOL BeginCase( char* szVariation );
	BOOL EndCase ();

private:
	void operator = ( const cMqNTLog & CLog);
	P<AutoFreeLib>m_NTLog;
	HANDLE m_hLog;
	char * m_szVariation;
//
// HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
//
	typedef HANDLE 
	(APIENTRY * tlCreateLog_A) 
	(LPCSTR,DWORD);
//
// BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);	
//
	typedef BOOL  
	(APIENTRY * tlAddParticipant)
	(HANDLE,DWORD,int);
//
// DWORD  APIENTRY  tlEndVariation(HANDLE);
//
	typedef DWORD
	(APIENTRY * tlEndVariation)
	(HANDLE);

//
// DWORD  APIENTRY  tlEndVariation(HANDLE);
//
	typedef DWORD
	(APIENTRY * tlEndVariation)
	(HANDLE);
	
//
// BOOL FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
//
	typedef BOOL
	(FAR cdecl * tlLog_A)
	(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
//
// VOID   APIENTRY  tlReportStats(HANDLE);
//
	typedef VOID
	(APIENTRY * tlReportStats)
	(HANDLE);
//
//  BOOL   APIENTRY  tlStartVariation(HANDLE);
//
	typedef BOOL
	(APIENTRY * tlStartVariation)
	(HANDLE);
//
//  BOOL	tlDestroyLog(HANDLE)
//
	typedef BOOL
	(APIENTRY * tlDestroyLog)
	(HANDLE);

	tlCreateLog_A m_pCreateLog_A;
	tlAddParticipant m_ptlAddParticipant;
	tlEndVariation m_ptlEndVariation;
	tlLog_A m_ptlLog_A;
	tlReportStats m_ptlReportStats;
	tlStartVariation m_ptlStartVariation;
	tlDestroyLog m_ptlDestroyLog;
};

void SetThreadName ( int dwThreadId , LPCSTR szThreadName );
std::wstring CreateHTTPFormatNameFromPathName(const std::wstring & wcsPathName,bool bHTTPS );
long GetADSchemaVersion();


#ifdef _DEBUGASSERT
//	#undef ASSERT
//	#define ASSERT(f)          _assert(f)
#endif // !_DEBUG

#endif _MSMQBVT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqmain.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: mqmain.cpp

Abstract:
		

Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace std;
#include "service.h"
#include "mqf.h"
#include <conio.h>

/*




#pragma warning( push, 3 )	
	
	#define ASSERT(x)
	#include "mqtempl.h"


	using namespace std;
#pragma warning( pop ) 	

*/
void PrintHelp();
//
// Declare global varibels.
//


// Test names and numbers

#define SendLocalPrivate (0)
#define SendLocalPublic (1)
#define SendRemotePublic (2)
#define Locate (3)
#define xFormatName (4)
#define GetMachineProp (5)
#define LocalAuth (6)
#define RemoteEncrypt (7)
#define ComTx (8)
#define SendRemotePublicWithDirectFN (9)
#define IsMqOA (10)
#define RemoteTransactionQueue (11)
#define OpenSystemQueue (12)
#define LocalEncryption (13)
#define RemoteAuth (14)
#define RemoteTransactionQueueUsingCapi (15)
#define Mqf (16)
#define HTTPToLocalPrivateQueue (17)
#define HTTPToLocalQueue (18)
#define HTTPToRemoteQueue (19)
#define HTTPToRemotePrivateQueue (20)
#define	MqDistList (21)
#define MqSetGet (22)
#define EODHTTP (23)
#define MultiCast (24)
#define AuthHTTP (25)
#define Triggers (26)
#define HTTPS (27)
#define AdminAPI (28)
#define SRMP (29)


bool g_bRaiseASSERTOnError = true;
std::string GetLogDirectory();
BOOL CheckMSMQVersion(list<wstring> & ListOfRemoteMachineName);
void ExcludeTests ( string & szExludeString, bool * bArray );
HRESULT TrigSetRegKeyParams();
HRESULT TrigCheckRegKeyParams();
HRESULT DeleteAllTriggersAndRules();
void CleanOAInitAndExit();
BOOL WINAPI fHandleCtrlRoutine( DWORD dwCtrlType );
BOOL g_bDebug=FALSE;
BOOL g_bRunOnWhistler = FALSE;
DWORD  g_dwRxTimeOut = BVT_RECEIVE_TIMEOUT ; 
LONG g_hrOLEInit=-1;
const WCHAR* const g_wcsEmptyString=L"Empty";
P<cMqNTLog> pNTLogFile;
// ---------------------------------------------------------------------------
// SetupStage
//
// This routine gets the setup type - one of three types
//
// 1. Only create queues and exit
// 2. Create the queue at runttime (must wait for replication if needed)
// 3. Use only the static queues created above.
//
// Parameters:
//		eStBflag is the setup type from above.
//		cTestParms pointer to configuration structure
//
// Return Values: pass or fail
//
INT SetupStage( SetupType eStBflag , cBvtUtil & cTestParms)
{
   if( eStBflag == RunTimeSetup )
   {
	   //
	   // If we are running at runtime you need to wait for replication
	   //
	   cout <<"Warning -  You are creating new queues, replication might delay queue usage" <<endl;
	
   }

    try
	{
		//
		// Do all the initialization - E.g. Create queues.
		//
		cMQSetupStage( eStBflag ,  cTestParms );	
		if(cTestParms.GetTriggerStatus() && eStBflag == ONLYSetup )
		{
			if(TrigSetRegKeyParams() != MQ_OK )
			{
				MqLog("Failed to update registry for the trigger tests\n");
				return MSMQ_BVT_FAILED;
			}
		}
		
	}
	catch( INIT_Error & err )
	{
		MqLog ("cMQSetupStage threw unexpected exception\n");
		cout <<err.GetErrorMessgae();
		return MSMQ_BVT_FAILED;
	}
	return MSMQ_BVT_SUCC;
}



DWORD TestResult[Total_Tests];

struct TestContainer
{
	// cTest *
	P<cTest> AllTests [Total_Tests];
	BOOL bCreateTest[Total_Tests];
	void operator= (TestContainer &);
	TestContainer( const TestContainer & );
	TestContainer() { };
};

TestContainer TestArr;
CRITICAL_SECTION CriticalSection;



DWORD CreateSetOfTests( TestContainer * TestArr ,
						cBvtUtil & cTestParms ,
						map <wstring,wstring> & mapCreateFlag,
						DWORD * TestResult,
						SetupType eStBflag,
						int iEmbeddedState,
						wstring wcsMultiCastAddress
					  );
int EnableEmbeddedTests (TestContainer * pTestCont,InstallType eInstallType);
int RunTest( TestContainer * TestArr ,  cBvtUtil & cTestParms , map <wstring,wstring> & mTestParams , bool bMultiThread);
int ClientCode (int argc, char ** argv );
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);

P<Log> pGlobalLog;
wstring wcsFileName=L"Mqbvt.log";

bool g_bRunAsMultiThreads=false;
BOOL g_bRemoteWorkgroup= FALSE;


INT WINAPIV main( INT argc , CHAR ** argv)
{
	//
	// This tests get command line parmeters
	//
	DWORD dwRetCode=MSMQ_BVT_FAILED;
	try
	{
		ZeroMemory( & TestArr ,sizeof ( TestArr ));
		if( argc < 2 )
		{
			PrintHelp();
			
			SERVICE_TABLE_ENTRY dispatchTable[] =
			{	
				{ TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
				{ NULL, NULL }
			};
			if (!StartServiceCtrlDispatcher(dispatchTable))
				AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
			return MSMQ_BVT_FAILED;
		}

		CInput CommandLineArguments( argc,argv );
		g_hrOLEInit = CoInitializeEx(NULL,COINIT_MULTITHREADED);
		map <wstring,wstring> mapCreateFlag;
		mapCreateFlag.clear();
		bool bVerbose=TRUE;
		pGlobalLog = new Log( wcsFileName );	
		BOOL bTestTrigger = FALSE;
		
		// clear all the value field.
		// Need to be Globel because the CTRL + Break
		// TestContainer TestArr;

		SetupType eSTtype;
		INT iStatus;
		BOOL bNT4RegisterCertificate = FALSE;
		BOOL bDelete=FALSE;
		BOOL bUseFullDNSNameAsComputerName=FALSE; // Use the tests with FullDNSName as machine name
		BOOL bWorkagainstMSMQ1=FALSE;			  // work against MSMQ1.0
		wstring wcsRemoteMachineName=g_wcsEmptyString; //start with Empty string
		eSTtype = RunTimeSetup;
		DWORD dwSleepUntilRep=0;		
		BOOL bSingleTest = FALSE;
		DWORD dwTid = 0;
		DWORD dwTimeOut=0;
		BOOL bNeedRemoteMachine = TRUE;
		int iEmbeddedState = 0;
		InitializeCriticalSection( &CriticalSection );
		SetConsoleCtrlHandler( fHandleCtrlRoutine, TRUE );
		BOOL bRunDLTest=FALSE;
		
		
		
		//
		// Start to parse all the command line argument
		//

		if( CommandLineArguments.IsExists ("?") )
		{
		   // Print help about the tests
		   PrintHelp();
		   CleanOAInitAndExit();
		   return(MSMQ_BVT_SUCC);
		}
		
		if(CommandLineArguments.IsExists ("mt"))
		{
			g_bRunAsMultiThreads = true;
		}
		if(CommandLineArguments.IsExists ("emb"))
		{
			// init for min value.
			iEmbeddedState = C_API_ONLY;
		}
		if(CommandLineArguments.IsExists ("wsl"))
		{
			g_bRunOnWhistler = TRUE;
		}

		if(CommandLineArguments.IsExists ("dl"))
		{
			bRunDLTest = TRUE;
		}


		list<wstring> ListOfRemoteMachineName;
		
		if( CommandLineArguments.IsExists ("g"))
		{
				g_bRemoteWorkgroup= TRUE;
		}
		if(CommandLineArguments.IsExists ("r"))
		{
		   _bstr_t bStr( CommandLineArguments["r"].c_str() );
		    wcsRemoteMachineName=bStr;
			wstring wcsToken=L";";
			size_t iPos = 0;
			do
			{
				iPos =wcsRemoteMachineName.find_first_of ( wcsToken );	
				ListOfRemoteMachineName.push_back(wcsRemoteMachineName.substr(0,iPos));
				wcsRemoteMachineName = wcsRemoteMachineName.substr(iPos+1,wcsRemoteMachineName.length());
			}
			while (iPos != -1 );
		}
		mapCreateFlag[L"eSTtype"] = L"RunTimeSetup";
		if(CommandLineArguments.IsExists ("s"))
		{
			eSTtype	= ONLYUpdate ;
			mapCreateFlag[L"eSTtype"]=L"WorkWithStaticQueue";
		}
		if(CommandLineArguments.IsExists ("i"))
		{
		   // Init Stage this part the computer create all the queues
		   eSTtype = ONLYSetup;
		   bNeedRemoteMachine = FALSE;
		}
		mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = L"false";
		if(CommandLineArguments.IsExists ("DNS"))
		{
				// The Tests will use full DNS name for all operation.
				mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = L"true";
				// bugbug should be removed .!
				bUseFullDNSNameAsComputerName = true;
		}
		mapCreateFlag[L"W2KAgainstNT4PEC"]=L"false";
		if( CommandLineArguments.IsExists ("NT4")|| CommandLineArguments.IsExists("nt4") )
		{
				// Run against NT4 PEC
				// Mising BUG ID:
			mapCreateFlag[L"W2KAgainstNT4PEC"]=L"true";
			bWorkagainstMSMQ1 = TRUE;
		}
			
		if(CommandLineArguments.IsExists ("C") || CommandLineArguments.IsExists ("c"))
		{
			bNT4RegisterCertificate = TRUE;
		}
		bool bWithoutHttp = false;
		if(CommandLineArguments.IsExists ("nohttp"))
		{
			bWithoutHttp = TRUE;
		}

		
		if( CommandLineArguments.IsExists ("d"))
		{
				// needs debug information
				g_bDebug = TRUE;
				wcout << L"Enable debug log" <<endl;
		}
		BOOL bDeleteQueueAfterTest = TRUE;
		if( CommandLineArguments.IsExists ("ddq"))
		{
			bDeleteQueueAfterTest=FALSE;
			wcout << L"Test will not delete the queue " <<endl;
		}

		bool bServicePack6=FALSE;
		mapCreateFlag[L"bServicePack6"]=L"false";
		if( CommandLineArguments.IsExists ("sp6"))
		{
				// needs debug information
				wcout <<L"Enable tests for Service Pack 6"<<endl;
				mapCreateFlag[L"bServicePack6"]=L"true";
				bServicePack6=TRUE;

		}
		mapCreateFlag[L"bVerbose"] = L"true";
		if( CommandLineArguments.IsExists ("v"))
		{
				// needs debug information
				// bugbug need to be remove
				bVerbose= TRUE;
				mapCreateFlag[L"bVerbose"] = L"true";
		}

		if(CommandLineArguments.IsExists ("w"))
		{
			
				// Replication time delay
				_bstr_t  bStr (CommandLineArguments["w"].c_str());
				// Need to convert this to DWORD value
				string wcsTemp=bStr;
				sscanf (wcsTemp.c_str(),"%d", & dwSleepUntilRep);
				
			
		}
			
		if (CommandLineArguments.IsExists ("delete"))
		{
		
		   // Need to delete all the static queue in the tests.
		   bNeedRemoteMachine = false;
		   eSTtype	= ONLYUpdate ;
		   bDelete = TRUE;
		
		}
		if (CommandLineArguments.IsExists("trig"))
		{
			bTestTrigger = true;
		}
		bool bHTTPS = false;
		if (CommandLineArguments.IsExists("https"))
		{
			bHTTPS = true;
		}

		BOOL bLevel8 = FALSE ;

		if (CommandLineArguments.IsExists ("level8"))
		{
		   // Delete all BVT queue from the computer.
		   bLevel8 = TRUE;
		}
		
		if (CommandLineArguments.IsExists ("install"))
		{
		   	CmdInstallService();
			cout <<"To start Mqbvt service type : net start mqbvtsrv"<<endl;
			CleanOAInitAndExit();
			
			return MSMQ_BVT_SUCC;
		}

		if (CommandLineArguments.IsExists ("service"))
		{	
			//
			//  Need to check service status
			
			ClientCode( argc,argv );		   	
			return MSMQ_BVT_SUCC;
		}

		if (CommandLineArguments.IsExists ("remove"))
		{
			CmdRemoveService();	
			CleanOAInitAndExit();
			return MSMQ_BVT_SUCC;
		}

		bool bRegisterNewCertificate = FALSE;
		if (CommandLineArguments.IsExists ("cert"))
		{
			bRegisterNewCertificate = TRUE;
		}
		
		if (CommandLineArguments.IsExists ("timeout"))
		{
			
			_bstr_t  bStr (CommandLineArguments["w"].c_str());
			// Need to convert this to DWORD value
			string wcsTemp=bStr;
			sscanf (wcsTemp.c_str(),"%d", & dwTimeOut );
		}
		
		if (CommandLineArguments.IsExists ("RxTime"))
		{
			
			_bstr_t  bStr (CommandLineArguments["RxTime"].c_str());
			// Need to convert this to DWORD value
			string wcsTemp=bStr;
			sscanf (wcsTemp.c_str(),"%d", & g_dwRxTimeOut );
			wcout <<L"Using Receive timeout of " << g_dwRxTimeOut << L" Milliseconds"  <<endl;
		}
		
		//
		// enable to debug the MQBvt with Kernel Debuger.
		//
		if (CommandLineArguments.IsExists ("PAUSE"))
		{
			wcout << L"Press any key to continue " <<endl;
			_getch();
		}
		mapCreateFlag[L"bSingleTest"] = L"false";
		// -t:3 Number of tests
		if (CommandLineArguments.IsExists ("t"))
		{
			bSingleTest = TRUE;
			mapCreateFlag[L"bSingleTest"] = My_mbToWideChar (CommandLineArguments["t"]);
			_bstr_t  bStr (CommandLineArguments["t"].c_str());
			string wcsTemp=bStr;
			
			sscanf (wcsTemp.c_str(),"%d", & dwTid);
			TestArr.bCreateTest[dwTid-1]= TRUE;
			
			
		}
		BOOL bRunOnlyStartTest=FALSE;
		if (CommandLineArguments.IsExists ("OStart"))
		{
			bRunOnlyStartTest = TRUE;
		}
		wstring wcsMultiCastAddress = g_wcsEmptyString;
		if (CommandLineArguments.IsExists ("multicast"))
		{
			_bstr_t bStr( CommandLineArguments["multicast"].c_str() );
			wcsMultiCastAddress = bStr;
		}
		bool bExcludedByUserTest[Total_Tests] = {false};		
		string strExcludeTest = "";
		if (CommandLineArguments.IsExists ("exclude"))
		{
			strExcludeTest = CommandLineArguments["exclude"];
			ExcludeTests(strExcludeTest,bExcludedByUserTest);
		}
		if (CommandLineArguments.IsExists ("assert"))
		{
			g_bRaiseASSERTOnError = false;
		}
		BOOL bUseNTLog = FALSE;
		wstring wcsNTLogPath = L"";
		if (CommandLineArguments.IsExists ("ntlog"))
		{
			_bstr_t bStr( CommandLineArguments["ntlog"].c_str() );
			wcsNTLogPath = bStr;
			string csFileName = My_WideTOmbString(wcsNTLogPath);
			pNTLogFile = NULL;
			try
			{
				pNTLogFile = new cMqNTLog(csFileName);
				bUseNTLog = TRUE;
			}
			catch (INIT_Error & err )
			{
				pNTLogFile = NULL;
				cout << err.GetErrorMessgae() << endl;
			}
		}		
		BOOL bRunOnlyCheckResult=FALSE;
		if (CommandLineArguments.IsExists ("OCheckR"))
		{
			bRunOnlyCheckResult = TRUE;
		}

		if( pNTLogFile == NULL )
		{
			try
			{
				string csFilePath = GetLogDirectory();
				csFilePath += "\\MqBvtLog.txt";
				pNTLogFile = new cMqNTLog(csFilePath);
				bUseNTLog = TRUE;
				printf("Mqbvt succeded to create log file@ %s\n",csFilePath.c_str());
			}
			catch( INIT_Error & err )
			{
				UNREFERENCED_PARAMETER(err);
				pNTLogFile = NULL;
			}
		}
		
		if ( bNeedRemoteMachine && wcsRemoteMachineName == g_wcsEmptyString ) // && ! eSTtype == ONLYSetup )
		{
			// Can't start the tests if there is no remote machine.
			// Option 1. Remote - Local machien & continue.
			//        2. Exit and ask for that parmeter.
			cout << "can't find - remote machine" <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;

		}
		if( !bNeedRemoteMachine )
		{
			WCHAR wcsLocalComputerName[MAX_COMPUTERNAME_LENGTH+1]={0};
			DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH;
			GetComputerNameW(wcsLocalComputerName,&dwComputerName);
			wcsRemoteMachineName = wcsLocalComputerName;
		}

		// Start the time out thread
		if ( dwTimeOut )
		{
			DWORD tid;
			// This thread will kill the process no need to wait for his finish
			HANDLE hRestrictionThread  = CreateThread(NULL , 0 , TimeOutThread , (LPVOID)(ULONG_PTR) dwTimeOut , 0, &tid);
			if( hRestrictionThread == NULL )
			{
				printf("Failed to set timeout thread, Mqbvt continue to run and ignore the timeout flag\n");
			}
		}

		//
		//  Check if the tests in avalibe
		//


		if ( bSingleTest &&  dwTid > Total_Tests )
		{
			wcout << L"Error: Test number is out of range. test numbers are available from 1 to " << Total_Tests <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;
		}
		
		
		
		/*
		Remove this code because Bug in MqGetPrivateComputerInformation for remote machine
		if ( g_bRunOnWhistler == false	)
		{
			g_bRunOnWhistler = CheckMSMQVersion(ListOfRemoteMachineName);
		} */
		
		//
		// Init Tests parmeters like local/Remote machine name.
		//
		
		cBvtUtil cTestParms( wcsRemoteMachineName ,
                             ListOfRemoteMachineName,
							 wcsMultiCastAddress,
                             bUseFullDNSNameAsComputerName,
                             eSTtype,
							 bTestTrigger
						   );

		if ( _winmajor == Win2K && bRegisterNewCertificate == TRUE )
		{
			my_RegisterCertificate (TRUE,MQCERT_REGISTER_ALWAYS);
			if (dwSleepUntilRep == 0)
			{
				MqLog ("You didn't wait for replication, there might be problems\n");
			}
			else
			{
				if( g_bDebug )
				{
					MqLog ("MqBvt sleep for %d\n until certificate is replicated \n",dwSleepUntilRep);
				}
				Sleep (dwSleepUntilRep);
			}
		}
		
		//
		//
		//

		if( cTestParms.bWin95 )
		{
			wcout << L"Static queues on Win9x are not supported" <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;
		}

	

		iStatus=SetupStage(eSTtype,cTestParms);

		//	
		// Delete all the queue from the test.
		// For delete static queue need to use with -s: -delete:
		//

		if( bDelete == TRUE)
		{
			INT iRes = cTestParms.Delete();
			if ( iRes == MSMQ_BVT_SUCC)
			{
				wcout << L"Mqbvt deleted all the static queues successfully" << endl;
			}
			else
			{
				wcout << L"Mqbvt failed to delete all the static queues" << endl;
			}
			
			//
			// Delete all triggers and rules (if exists) 
			// 
			if( g_bRunOnWhistler )
			{
				DeleteAllTriggersAndRules();
			}
			CleanOAInitAndExit();
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
			}
			return MSMQ_BVT_SUCC;
		}


		if ( iStatus != MSMQ_BVT_SUCC )
		{
			wMqLog (L"Failed to update queues parameters \n Try to run Mqbvt -i again or check replication \n ");
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
			}
			return MSMQ_BVT_FAILED;
		}

		// This code needs only for the installation part.
		if( eSTtype  == ONLYSetup )
		{
			if( iStatus == MSMQ_BVT_SUCC )
			{
				if( pNTLogFile )
				{
					pNTLogFile -> ReportResult(true,"Mqbvt setup passed");
				}
				wMqLog (L"Mqbvt setup passed\n");;
			}
			else
			{	
				if( pNTLogFile )
				{	
					pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
				}
				wMqLog (L"Mqbvt setup failed !!\n");
			}
			
			CleanOAInitAndExit();
			return iStatus == MSMQ_BVT_SUCC ? 0:1;
		}

		
		
		//
		// By defualt dwSleepUntilRep = 0; else need to sleep the Wait time.
		//

		
		if( dwSleepUntilRep )
		{

		  // need to change the sleep time for Sec to mili sec.
			 Sleep( dwSleepUntilRep * 1000 );
			 if( g_bDebug )
			 {
				cout << "Wait for replication, sleep for " << dwSleepUntilRep << " Sec"<<endl;
			 }
		}
		
		//
		// Enable all tests
		//
	/*	if ( cTestParms.iAmDC() )
		{
			g_bRunOnWhistler = false;
		}
*/
		if( ! bSingleTest )
			if ( cTestParms.m_eMSMQConf != WKG )
				{
					for(INT dwTid=0; dwTid < Total_Tests ; dwTid ++ )
					{
						if( bExcludedByUserTest[dwTid] == false ) //if tests is not excluded
						{
							TestArr.bCreateTest[dwTid]= TRUE;
						}
					}

					TestArr.bCreateTest[MultiCast] = (wcsMultiCastAddress != g_wcsEmptyString) ? TRUE:FALSE;
					TestArr.bCreateTest[MqDistList] = bRunDLTest;
					TestArr.bCreateTest[Triggers] = bTestTrigger;
					TestArr.bCreateTest[HTTPS] = bHTTPS;
					if( eSTtype != ONLYUpdate )
					{	
						TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
					}
					if ( cTestParms.m_eMSMQConf == DepClient)
					{
						TestArr.bCreateTest[SRMP] = FALSE;
					}
					if( iEmbeddedState == C_API_ONLY) 
					{
						iEmbeddedState = EnableEmbeddedTests(&TestArr,cTestParms.m_eMSMQConf );
					}
					else
					{	
						if( !g_bRunOnWhistler )
						{
							TestArr.bCreateTest[HTTPToLocalPrivateQueue]= FALSE;
							TestArr.bCreateTest[HTTPToLocalQueue]= FALSE;
							TestArr.bCreateTest[HTTPToRemoteQueue]= FALSE;
							TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
							TestArr.bCreateTest[EODHTTP] = FALSE;
							TestArr.bCreateTest[AuthHTTP] = FALSE;
							TestArr.bCreateTest[MqDistList] = FALSE;
							TestArr.bCreateTest[MultiCast] = FALSE;
							TestArr.bCreateTest[Triggers] = FALSE;
							TestArr.bCreateTest[HTTPS] = FALSE;
							TestArr.bCreateTest[Mqf] = FALSE;
							TestArr.bCreateTest[SRMP] = FALSE;

						}
					}

				}
				else
				{
					//
					// WorkGroup tests to run
					//
					// 1. Local private queue.
					// 4. GetMachineProp
					// 9. Remote read from private queue using direct format name
					// 13. Open system queue.
					//
					TestArr.bCreateTest[SendLocalPrivate] = TRUE;
					TestArr.bCreateTest[GetMachineProp] = TRUE;
					TestArr.bCreateTest[SendRemotePublicWithDirectFN] = TRUE;
					TestArr.bCreateTest[OpenSystemQueue]= TRUE;
					TestArr.bCreateTest[RemoteTransactionQueue] = TRUE;
					TestArr.bCreateTest[AdminAPI] = TRUE;

				
					if( g_bRunOnWhistler )
					{
						TestArr.bCreateTest[HTTPToLocalPrivateQueue] = TRUE;
						TestArr.bCreateTest[Mqf] = TRUE;
						TestArr.bCreateTest[HTTPToRemotePrivateQueue]= TRUE;
						TestArr.bCreateTest[EODHTTP] = TRUE;
						if( bTestTrigger && eSTtype != RunTimeSetup )
						{
							TestArr.bCreateTest[Triggers] = TRUE;
						}

					}
					if( iEmbeddedState == C_API_ONLY) 
					{
						iEmbeddedState = EnableEmbeddedTests(&TestArr,cTestParms.m_eMSMQConf);
					}
					

				}
	
	

		if( bWithoutHttp )
		{
			//
			// if machine configured without IIS
			//
			TestArr.bCreateTest[HTTPToLocalPrivateQueue]= FALSE;
			TestArr.bCreateTest[HTTPToLocalQueue]= FALSE;
			TestArr.bCreateTest[HTTPToRemoteQueue]= FALSE;
			TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
			TestArr.bCreateTest[EODHTTP] = FALSE;
			TestArr.bCreateTest[AuthHTTP] = FALSE; 	
		}
		//
		// Need to run only on NT4 sp6
		//
		
		TestArr.bCreateTest[RemoteTransactionQueueUsingCapi] = ( bServicePack6 == TRUE ) ? TRUE : FALSE;

		//
		// Can't run against MSMQ1
		//
		
		if ( bWorkagainstMSMQ1 == TRUE || _winmajor == 4 )
		{
			TestArr.bCreateTest[OpenSystemQueue] = FALSE;
		}
		//
		// Work only with static queue mode on NT5 only.
		//
		if( eSTtype == RunTimeSetup ||  _winmajor ==  4 )
		{
			TestArr.bCreateTest[SendRemotePublicWithDirectFN] = FALSE;
			if ( bServicePack6 == TRUE )
				TestArr.bCreateTest[SendRemotePublicWithDirectFN] = TRUE;
		}
		
		//
		// Local user dosn't support those tests.
		//

		if( cTestParms.m_eMSMQConf == LocalU ||  cTestParms.m_eMSMQConf == DepClientLocalU )
		{
			TestArr.bCreateTest[LocalAuth] = FALSE;
			TestArr.bCreateTest[RemoteAuth] = FALSE;
		}
		//
		// test that dosen't work in NT4
		if( ! bNT4RegisterCertificate &&  _winmajor ==  NT4 )
		{			
			MqLog("Disable authentication test on NT4/ Win9x \n -C will enable this\n");
			TestArr.bCreateTest[LocalAuth] = FALSE;	
			TestArr.bCreateTest[RemoteAuth]= FALSE;	
		}

		if ( _winmajor == Win2K  && bWorkagainstMSMQ1 == TRUE && eSTtype == ONLYUpdate )
		{	
			
			//
			// W2K against nt4 pec disable remote read using direct format name.
			//

			TestArr.bCreateTest[SendRemotePublicWithDirectFN] = FALSE;

		}
	
		CreateSetOfTests(&TestArr,cTestParms,mapCreateFlag,TestResult,eSTtype,iEmbeddedState,wcsMultiCastAddress);

		//
		// This tests is related to level 8 problem
		//
		if( bLevel8 )
		{
			map <wstring,wstring> Level8Map;

			Level8Map[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Authnticate Q");
			Level8Map[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");

			cLevel8 Level8Test(Level8Map);
			Level8Test.Start_test();
			return MSMQ_BVT_SUCC;
		}

		 dwRetCode = RunTest( & TestArr , cTestParms , mapCreateFlag, g_bRunAsMultiThreads);
					
	}
	catch(INIT_Error & err )
	{
		try
		{	
			MqLog("%s\n",(err.GetErrorMessgae()).c_str());
			wMqLog (L"Mqbvt failed !!\n");
			CHAR csLine[]="Mqbvt failed!";
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,csLine);
			}
		}
		catch (...)
		{
			MqLog("Exception inside catch ... \n" );
			throw;
		}

		CleanOAInitAndExit();
		return MSMQ_BVT_FAILED;
	}
	catch(...)
	{
		MqLog("Mqbvt got unexpected exception\n");
		throw;
	}

	CleanOAInitAndExit();
	return dwRetCode;
	
}

//
// CleanOAInitAndExit -
// this function release all the OA information before call the
// OleUninitialize.
//
//


void CleanOAInitAndExit()
{
	DeleteCriticalSection(&CriticalSection);
	for ( INT Index = 0 ; Index < Total_Tests ; Index ++ )
	{
		if( TestArr.bCreateTest[Index] == TRUE )
		{
			delete (TestArr.AllTests[Index]).detach();
		}
	
	}
	if( SUCCEEDED(g_hrOLEInit) )
	{
		CoUninitialize();
	}

}

void PrintHelp ()
{
	wcout <<L"Mqbvt is the BVT for Microsoft Message Queue" <<endl;
	wcout <<L" -d	   Enable debug information." <<endl;
	wcout <<L" -i        Create static queue." <<endl;
	wcout <<L" -v        verbose." <<endl;
	wcout <<L" -r:       <remote machine name > " <<endl;
	wcout <<L" -g        remote machine is workgroup " <<endl;
	wcout <<L" -s        Work with static queues. " <<endl;
	wcout <<L" -w:       < Sleep time in sec >  Sleep time while waiting for replication." <<endl;
	wcout <<L" -C:       run security test on NT4 client." <<endl;
	wcout <<L" -mt       Multithread enable" <<endl;
	wcout <<L" -wsl		 Support for whistler." <<endl;
	wcout <<L" -RxTime:  < Time in MilliSec >  Receive timeout." <<endl;
	wcout <<L" -timeout: < Time in Sec >  Maximum time to run." <<endl;
	wcout <<L" -delete:  delete the static queues." <<endl;
	wcout <<L" -DNS      always use full dns name as machine names." <<endl;
	wcout <<L" -NT4      Works against MSMQ1.0 MQIS server." <<endl;
	wcout <<L" -sp6      Enable new tests for msmq service pack 6" <<endl;
	wcout <<L" -PAUSE    < Time in Sec >  Press key to run test." <<endl;
	wcout <<L" -t:#number  Specific test number " <<endl;
	wcout <<L" -ntlog:    Specify file name     " <<endl;
	wcout <<L" -cert     always Create new certificate" <<endl;
	wcout <<L" -install	 install Mqbvt service" <<endl;
	wcout <<L" -remove	 Remove Mqbvt service" <<endl;
	wcout <<L" -service  use to pass parameters to the Mqbvt service" <<endl;
	wcout <<L" -exclude: 1,2,3 (disable set of tests) " <<endl;
	wcout <<L" -dl       use dl object" <<endl;
	wcout <<L" -nohttp     don't use http test" <<endl;
	wcout <<L" -trig     triggers functionality test. note that you need to start and stop the service after initialization phase" <<endl;
	wcout <<L"Example" <<endl;
	wcout <<L"Setup: Mqbvt -i" <<endl;
	wcout <<L"Runing using static queue: Mqbvt -r:Eitan5 -s" <<endl;
	wcout <<L"How to run as a service" <<endl;
	wcout <<L"To run the service use Net start mqbvtsrv"<<endl;
	wcout <<L"Mqbvt.exe -service -r:eitan5 -s"<<endl;
	wcout <<L"Mqbvt.exe -r:eitan5 -s -ntlog:c:\\Temp\\Mqbvt.log"<<endl;
}





//
// Handle CTRL+C / CTRL Break
// Call tests distractors.
//


BOOL
WINAPI fHandleCtrlRoutine(
		DWORD  dwCtrlType )		//  control signal type
{

	UNREFERENCED_PARAMETER(dwCtrlType);
	MqLog ("Mqbvt , Is now exiting \n");
	EnterCriticalSection( &CriticalSection );

	CleanOAInitAndExit();

	LeaveCriticalSection( &CriticalSection );
	//
	// Exit the Process without clean ..
	//
	exit (MSMQ_BVT_FAILED);
}
//****************************************************************
//
// CreateSetOfTests this function allocate all the tests
// Input paramters:
// 1. TestContainer * TestArr - Container for all the tests.
// 2. cBvtUtil & cTestParms - Test paramters
// 3. map <wstring,wstring> & mapCreateFlag - additional arguments to function
// List of additional arguments
//	
// mapCreateFlag[L"W2KAgainstNT4PEC"] = true / false - Specify if the supporting server is NT4/
// mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = true / false - mean use full dns name as computer name
// mapCreateFlag[L"bServicePack6"]
// mapCreateFlag[L"bVerbose"] =
// mapCreateFlag[L"bSingleTest"] = TidNumber
//
//
// return value:
//
// dwNumberOfTest - number of tests.
//


DWORD CreateSetOfTests( TestContainer * TestArr ,
						cBvtUtil & cTestParms ,
						map <wstring,wstring> & mapCreateFlag,
						DWORD * TestResult,
						SetupType eStBflag,
						int iEmbeddedState,
						wstring wcsMultiCastAddress
					  )
{
	DWORD dwNumberOfTest = 0;
	

	map <wstring,wstring> mapSendRecive1,mapSendRecive2,mapSendRecive3,map_MachineName,map_xxxFormatName,mapLocateParm;
		
		try
		{
			// tests 1 Send Receive from private Queue
			if( TestArr -> bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive1[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendRecive1[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive1[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendRecive1[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendRecive1);
			}
				
			
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send receive message to private queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;
		// tests 2 Send Receive from public local queue.
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive2[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				mapSendRecive2[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive2[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				mapSendRecive2[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendRecive2);
			}	
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send receive message to local public queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		// tests 3 Send Receive from public remote queue.
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive3[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Remote Read Queue");
				mapSendRecive3[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive3[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Remote Read Queue");
				mapSendRecive3[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mapSendRecive3[L"UseOnlyDirectFN"] = L"TRUE";
				if ( mapCreateFlag[L"W2KAgainstNT4PEC"] == L"true")  //  bWorkagainstMSMQ1
				{
					mapSendRecive3[L"UseOnlyDirectFN"] = L"FALSE";
				}
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest , mapSendRecive3);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send receive message to Remote public queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		try
		{
			if (TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapLocateParm[L"QCommonLabel"]=cTestParms.m_wcsLocateGuid;
				mapLocateParm[L"UseFullDNSName"] = L"No";
				mapLocateParm[L"CurrentMachineName"] = cTestParms.m_wcsCurrentLocalMachine;
				mapLocateParm[L"CurrentMachineNameFullDNS"] = cTestParms.m_wcsLocalComputerNameFullDNSName;
				mapLocateParm[L"NT4SuportingServer"] = L"false";
				if ( mapCreateFlag[L"W2KAgainstNT4PEC"] == L"true" || 
				    ( g_bRunOnWhistler && cTestParms.iamWorkingAgainstPEC() == TRUE))  //  bWorkagainstMSMQ1
				{
					mapLocateParm[L"NT4SuportingServer"] = L"true";
				}
				
				if( mapCreateFlag[L"bUseFullDNSNameAsComputerName"] == L"true" )
				{
					mapLocateParm[L"UseFullDNSName"]=L"Yes";
				}	
				mapLocateParm[L"UseStaticQueue"] = L"UseStaticQueue";
				if( eStBflag == RunTimeSetup )
				{
					mapLocateParm[L"UseStaticQueue"] = L"No";
				}
				mapLocateParm[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					mapLocateParm[L"SkipOnComApi"] = L"Yes";
				}
				TestArr ->AllTests[dwNumberOfTest]=new cLocateTest(dwNumberOfTest , mapLocateParm);
				
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Locate queues )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		
		// tests 5 MachineProperty
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				map_MachineName [L"LMachine"] = cTestParms.m_wcsLocalComputerNetBiosName;
				map_MachineName [L"LMachineFDNS"] = cTestParms.m_wcsLocalComputerNameFullDNSName;
				map_MachineName [L"RMachine"] = cTestParms.m_wcsRemoteComputerNetBiosName;
				map_MachineName [L"RMachineFDNS"]= cTestParms.m_wcsRemoteMachineNameFullDNSName;

				//
				//  Need to know if supporting service is NT4
				//
				map_MachineName[L"MSMQ1Limit"] = mapCreateFlag[L"W2KAgainstNT4PEC"];
				map_MachineName [L"UseFullDns"]= L"No";				
				if( _winmajor ==  Win2K && mapCreateFlag[L"W2KAgainstNT4PEC"] == L"false" )
				{
				   map_MachineName [L"UseFullDns"]= L"Yes";
				}
				if( g_bRunOnWhistler && cTestParms.iamWorkingAgainstPEC() )
				{
					map_MachineName [L"MSMQ1Limit"]= L"true";
				}
				TestArr ->AllTests[dwNumberOfTest]=new MachineName( dwNumberOfTest , map_MachineName );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( GetMachine Propery )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// tests 6 xToFormatName
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				
				if( cTestParms.m_eMSMQConf == WKG )
				{
					map_xxxFormatName [L"Wkg"]=L"Wkg";
				}

				map_xxxFormatName [L"PrivateDestFormatName"] = cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				map_xxxFormatName [L"PrivateDestPathName"] = cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				map_xxxFormatName [L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				map_xxxFormatName [L"DestPathName"] = cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				if( g_bRunOnWhistler )
				{
					map_xxxFormatName [L"WorkingAgainstPEC"] = cTestParms.iamWorkingAgainstPEC() ? L"Yes":L"No";
				}
				map_xxxFormatName[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					map_xxxFormatName[L"SkipOnComApi"] = L"Yes";
				}
				TestArr ->AllTests[dwNumberOfTest]=new xToFormatName(dwNumberOfTest , map_xxxFormatName );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( xToFormatName )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;

		// tests 7 Security Authntication !!!.

		map <wstring,wstring> mapAuth , DTCMap , Encrypt;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapAuth[L"DestFormatName"]  = cTestParms.ReturnQueueFormatName(L"Authnticate Q");
				mapAuth[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapAuth[L"DestQueuePathName"] = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				wstring temp = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mapAuth);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		
		dwNumberOfTest ++;
		
		//
		// Test 8 Privacy level ...  Encrepted messages
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				Encrypt[L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"privQ");
				Encrypt[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				Encrypt[L"Enh_Encrypt"] = L"False";
				if( _winmajor == Win2K && cTestParms.GetEncryptionType() ==  Enh_Encrypt && mapCreateFlag[L"W2KAgainstNT4PEC"] == L"false" )
				{
					Encrypt[L"Enh_Encrypt"] = L"True";
				}
				TestArr ->AllTests[dwNumberOfTest]= new PrivateMessage( dwNumberOfTest ,Encrypt );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Encryption  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Transaction tests.
		// trans Test
		
		map <wstring,wstring> RmapAuth,mapTrans, mapSendReciveDirectPrivateQ,SendTransUsingComI,TOpenQueues,LEncrypt;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapTrans[L"DestQFormatName1"]= cTestParms.ReturnQueueFormatName(L"TransQ1");
				mapTrans[L"DestQFormatName2"]= cTestParms.ReturnQueueFormatName(L"TransQ2");
				
				// bugbug need to load dtc on w2k depe client
				bool bStartDtc = FALSE;
				if( cTestParms.m_eMSMQConf == DepClient && _winmajor ==   Win2K)
				{
					bStartDtc=TRUE;
				}
				
				TestArr ->AllTests[dwNumberOfTest]= new cTrans( dwNumberOfTest , mapTrans , bStartDtc );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Tranacation  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Send receive tests using direct format name
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendReciveDirectPrivateQ[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"UseOnlyDirectFN"]=L"TRUE";
				mapSendReciveDirectPrivateQ[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendReciveDirectPrivateQ);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;
		
		// Test 9 use Check if MQOA registered..
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new isOARegistered ( dwNumberOfTest );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Is MqOA registered? )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Send transaction message to remote queue using DTC via com interface
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				
				if ( cTestParms.m_eMSMQConf == WKG )
				{
					// Use private queue.
					SendTransUsingComI[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Private Transaction");
				}
				else
				{
					// Use public queue.
					SendTransUsingComI[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				}
				SendTransUsingComI[L"Sp6"]=L"NO";
				TestArr ->AllTests[dwNumberOfTest]= new xActViaCom ( dwNumberOfTest , SendTransUsingComI);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// System queue open tests
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TOpenQueues[L"LocalMachineName"] = cTestParms.m_wcsCurrentLocalMachine;
				TOpenQueues[L"RemoteMachineName"] = cTestParms.m_wcsCurrentRemoteMachine;
				TOpenQueues[L"LocalMachineNameGuid"] = cTestParms.m_wcsMachineGuid;
				TOpenQueues[L"RemoteMachineNameGuid"] = cTestParms.m_wcsRemoteMachineGuid ;
				TOpenQueues[L"Wkg"]=L"";
				if( cTestParms.m_eMSMQConf == WKG )
				{
					TOpenQueues[L"Wkg"]=L"Wkg";
				}
				TOpenQueues[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					TOpenQueues[L"SkipOnComApi"] = L"Yes";
				}
		   		TestArr ->AllTests[dwNumberOfTest]= new COpenQueues ( dwNumberOfTest , TOpenQueues);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Open System queue )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				LEncrypt[L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"Local encrypt");
				LEncrypt[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				LEncrypt[L"Enh_Encrypt"] = L"False";
				if( _winmajor ==   Win2K && cTestParms.GetEncryptionType() ==  Enh_Encrypt )
					LEncrypt[L"Enh_Encrypt"] = L"True";
				TestArr ->AllTests[dwNumberOfTest]= new PrivateMessage( dwNumberOfTest ,LEncrypt );			
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( local Encryption  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

	
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				RmapAuth[L"DestFormatName"]  = cTestParms.ReturnQueueFormatName(L"Remote authenticate");
				RmapAuth[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				wstring temp = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,RmapAuth);
			
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		//
		// transaction boundaries - for service pack 6
		//
		map <wstring , wstring > RemoteTransaction;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				RemoteTransaction[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				RemoteTransaction[L"Sp6"]=L"NO";
				if( mapCreateFlag[L"bServicePack6"]  == L"true" )
				{
					RemoteTransaction[L"Sp6"]=L"YES";
				}
				TestArr ->AllTests[dwNumberOfTest]= new xActUsingCapi ( dwNumberOfTest , RemoteTransaction );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		


		dwNumberOfTest ++;
		//
		// MqFsupport
		//
		map <wstring , wstring > mMqFTestParams;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMqFTestParams[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				mMqFTestParams[L"Sp6"]=L"NO";
				mMqFTestParams[L"AdminQFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				if ( eStBflag == RunTimeSetup )
				{
					mMqFTestParams[L"q1"]=cTestParms.ReturnQueueFormatName(L"MQCast1");
					mMqFTestParams[L"q2"]=cTestParms.ReturnQueueFormatName(L"MQCast2");
					mMqFTestParams[L"q3"]=cTestParms.ReturnQueueFormatName(L"MQCast3");
					mMqFTestParams[L"SearchForQueue"]=L"Yes";
				}
				
				TestArr ->AllTests[dwNumberOfTest]= new MqF ( dwNumberOfTest , mMqFTestParams ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf,cTestParms.m_eMSMQConf == WKG);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Mqf support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;


		//
		// SendReceive using direct http = format name to private local queue
		//
		map<std::wstring,std::wstring> mSendReciveUsingHTTPToLocalPrivate,
									   mSendLocalPublicUsingHTTPToLocalQueue,
									   mSendLocalPublicUsingHTTPToRemoteQueue,
									   mSendRemPrivateQueueUsingHTTP;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendReciveDirectPrivateQ[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"UseDirectHTTP"]=L"TRUE";
				mapSendReciveDirectPrivateQ[L"LocalMachName"] = mapSendReciveDirectPrivateQ[L"MachName"]= cTestParms.m_wcsCurrentLocalMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendReciveDirectPrivateQ);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send to local private queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;


		//
		// SendReceive using direct http = format name to public local queue
		//

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mSendLocalPublicUsingHTTPToLocalQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				mSendLocalPublicUsingHTTPToLocalQueue[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				mSendLocalPublicUsingHTTPToLocalQueue[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToLocalQueue[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToLocalQueue[L"UseDirectHTTP"]=L"TRUE";
				mSendLocalPublicUsingHTTPToLocalQueue[L"LocalMachName"] = mSendLocalPublicUsingHTTPToLocalQueue[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendLocalPublicUsingHTTPToLocalQueue);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send to local public queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// SendReceive using direct http = to remote public format name.
		//
		
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mSendLocalPublicUsingHTTPToRemoteQueue[L"UseDirectHTTP"]=L"TRUE";
				
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Remote Read Queue");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Remote Read Queue");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mSendLocalPublicUsingHTTPToRemoteQueue[L"LocalMachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendLocalPublicUsingHTTPToRemoteQueue);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send to public remote queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		
		//
		// Send message to remote machine using direct http format name
		//

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mSendRemPrivateQueueUsingHTTP[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mSendRemPrivateQueueUsingHTTP[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mSendRemPrivateQueueUsingHTTP[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendRemPrivateQueueUsingHTTP[L"UseOnlyDirectFN"]=L"TRUE";
				mSendRemPrivateQueueUsingHTTP[L"UseDirectHTTP"]=L"TRUE";	
				mSendRemPrivateQueueUsingHTTP[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendRemPrivateQueueUsingHTTP[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mSendRemPrivateQueueUsingHTTP[L"LocalMachName"]=cTestParms.m_wcsCurrentLocalMachine;

				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendRemPrivateQueueUsingHTTP);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Send to private remote queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// MqDl
		//
		map <wstring , wstring > mMqDlTestParameters;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMqDlTestParameters[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				mMqDlTestParameters[L"Sp6"]=L"NO";
				mMqDlTestParameters[L"AdminQFormatName"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mMqDlTestParameters[L"PublicAdminQueue"]=cTestParms.ReturnQueueFormatName(L"DL Admin Queue");
				if ( eStBflag == RunTimeSetup )
				{
					mMqDlTestParameters[L"q1"]=cTestParms.ReturnQueueFormatName(L"MqDL1");
					mMqDlTestParameters[L"q2"]=cTestParms.ReturnQueueFormatName(L"MqDL2");
					mMqDlTestParameters[L"q3"]=cTestParms.ReturnQueueFormatName(L"MqDL3");
					mMqDlTestParameters[L"SearchForQueue"]=L"Yes";
				}

				TestArr ->AllTests[dwNumberOfTest]= new cSendUsingDLObject ( dwNumberOfTest , mMqDlTestParameters ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf);
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( Mqf support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;


		try
		{	
			map <wstring , wstring > mSetQueueProps;
			mSetQueueProps.clear();
			if( cTestParms.m_eMSMQConf == WKG )
			{
				mSetQueueProps[L"Wkg"]=L"Wkg";
			}
			else
			{
				mSetQueueProps[L"Wkg"]=L"xxx";
				mSetQueueProps[L"FormatName"] = cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
			}
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new cSetQueueProp ( dwNumberOfTest,mSetQueueProps );
			}
		}
		catch(INIT_Error & err )
		{
			wMqLog(L"Failed create tests %d ( MqSetGetQueue support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;

		//
		// Send transaction message to remote queue using HTTP format name using COM interface.
		//
		try
		{
			map <wstring , wstring > mEODTestParams;
			mEODTestParams.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{			
				if ( cTestParms.m_eMSMQConf == WKG )
				{
					mEODTestParams[L"FormatName"] = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Transaction"),FALSE);
				}
				else
				{
					// Use public queue.
					mEODTestParams[L"FormatName"] = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote Transaction queue"),FALSE);
				}
				SendTransUsingComI[L"Sp6"]=L"NO";
				TestArr ->AllTests[dwNumberOfTest]= new xActViaCom ( dwNumberOfTest , mEODTestParams);
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
	
		dwNumberOfTest ++;
		//
		// Send message using multicast address.
		//
	
		map<wstring,wstring> mMultiCast;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMultiCast[L"AdminQFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mMultiCast[L"MultiCastAddress"] = wcsMultiCastAddress;
				mMultiCast[L"SearchForQueue"]=L"No";
				if ( eStBflag == RunTimeSetup )
				{
					mMultiCast[L"q1"]=cTestParms.ReturnQueueFormatName(L"MQCast1");
					mMultiCast[L"q2"]=cTestParms.ReturnQueueFormatName(L"MQCast2");
					mMultiCast[L"q3"]=cTestParms.ReturnQueueFormatName(L"MQCast3");
					mMultiCast[L"SearchForQueue"]=L"Yes";
				}

				TestArr ->AllTests[dwNumberOfTest]= new CMultiCast ( dwNumberOfTest , mMultiCast ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf);
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( multi cast support )\n",dwNumberOfTest+1);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// Check HTTP authtication level.
		//
		try
		{
			map<wstring,wstring> mHTTPAuth;
			mHTTPAuth.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mHTTPAuth[L"DestFormatName"]  = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote authenticate"),FALSE);
				mHTTPAuth[L"AdminFormatName"] = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Admin Q"),FALSE);
				mHTTPAuth[L"FormatNameType"] = L"Http";
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mHTTPAuth);
			
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( http Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;


		try
		{
			map<wstring,wstring> mTriggerTest;
			mTriggerTest.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mTriggerTest[L"PeekQueueFormatName"] = cTestParms.ReturnQueueFormatName(L"PeekTrigger");
				mTriggerTest[L"PeekQueuePathName"] = cTestParms.ReturnQueuePathName(L"PeekTrigger");
				mTriggerTest[L"ReceiveQueueFormatName"] = cTestParms.ReturnQueueFormatName(L"RetrievalTrigger");
				mTriggerTest[L"ReceiveQueuePathName"] = cTestParms.ReturnQueuePathName(L"RetrievalTrigger");
				mTriggerTest[L"TxQueueFormatName"] = cTestParms.ReturnQueueFormatName(L"TxRetrievalTrigger");
				mTriggerTest[L"TxQueuePathName"] = cTestParms.ReturnQueuePathName(L"TxRetrievalTrigger");
				mTriggerTest[L"TriggerTestQueueFormatName"]= cTestParms.ReturnQueueFormatName(L"TriggerTest");
				TestArr ->AllTests[dwNumberOfTest]= new CMqTrig( dwNumberOfTest ,mTriggerTest);			
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Trigger test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			map<wstring,wstring> mHTTPSConnection;
			mHTTPSConnection.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mHTTPSConnection[L"DestFormatName"]  = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote authenticate"),TRUE);
				mHTTPSConnection[L"AdminFormatName"] = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Admin Q"),TRUE);
				mHTTPSConnection[L"FormatNameType"] = L"Http";
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mHTTPSConnection);			
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( HTTPS )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new CMqAdminApi( dwNumberOfTest , cTestParms.m_wcsLocalComputerNetBiosName);			
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Admin API Test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			wstring wcsPublicQueueFormatName;
			if( TestArr->bCreateTest[ dwNumberOfTest ] )
			{
				wcsPublicQueueFormatName = CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote Read Queue"), FALSE);
				TestArr->AllTests[dwNumberOfTest]= new CSRMP( dwNumberOfTest , wcsPublicQueueFormatName );			
			}
		}
		catch(INIT_Error & err )
		{
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( SRMP Test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = FALSE; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;





	return dwNumberOfTest;
}

//
//
// RunTest
//
// input paramters:
//
// 1. TestContainer * TestArr - Container for all the tests.
// 2.
// 3. map <wstring,wstring> & mapCreateFlag - additional arguments to function
//
// mTestParams[L"bVerbose"] = true / false ;
// mTestParams[L"eSTtype"] =
// mTestParams[L"bDeleteQueueAfterTest"] = ...


int RunTest( TestContainer * TestArr ,  cBvtUtil & cTestParms , map <wstring,wstring> & mTestParams , bool bMultiThread)
{
		//
		// Start the tests
		//
		
		DWORD TestResult[Total_Tests];
		DWORD dwTid=0;
		if( bMultiThread == false )
		{
			
			string wcsTemp=My_WideTOmbString( mTestParams[L"bSingleTest"] ) ;
			swscanf (mTestParams[L"bSingleTest"].c_str(),L"%d", & dwTid );

			for ( INT Index = 0 ; Index < Total_Tests ; Index ++ )
			{	
				if(TestArr->AllTests[Index] && TestArr -> bCreateTest[Index] )
				{		
					if ( mTestParams[L"bVerbose"] == L"true" )
					{
						( TestArr -> AllTests[Index] ) -> Description();
					}
					TestResult [Index] = ( TestArr->AllTests[Index] ) ->Start_test();
				}
			}

			//
			//  need to sleep for resp time until chech the resualt.
			//
			


			Sleep (MqBvt_SleepBeforeWait);

			for ( Index =0 ; Index < Total_Tests ; Index ++ )
			{
				if( TestArr->AllTests[Index] && TestArr -> bCreateTest[Index])
				{
					if ( mTestParams[L"bVerbose"] == L"true" )
					{
							MqLog ("Result check:");
							(TestArr->AllTests[Index]) -> Description();
					}
				
					if ( TestResult [Index] == MSMQ_BVT_SUCC )
					  TestResult [Index] = (TestArr -> AllTests[Index]) -> CheckResult();
				}
			}
		}
		else
		{
			int Index;
			HANDLE hArr[Total_Tests];
			int i=0;
			g_dwRxTimeOut *= 5;
			for ( Index =0 ; Index < Total_Tests ; Index ++ )
			{
				if (TestArr->bCreateTest[Index])
				{
				   //TestResult [Index] =
					(TestArr->AllTests[Index]) -> StartThread();
				   hArr[i++]=(TestArr->AllTests[Index])->GetHandle();
				}
			}
			
			WaitForMultipleObjects(i,hArr,TRUE,INFINITE);	
			

		}
		//
		// Check the array to decide Mqbvt pass / Failed
		//
		int Index;
		BOOL bTestPass = TRUE;
		if ( mTestParams[L"bSingleTest"] != L"false" )
		{
			if ( TestResult [dwTid-1] != MSMQ_BVT_SUCC )
				bTestPass = FALSE;
		}
		else
		{
			for ( Index = 0 ; Index < Total_Tests ; Index ++ )
			{
				if ( TestArr->bCreateTest[Index] &&  TestResult [Index] != MSMQ_BVT_SUCC )
				{

					bTestPass = FALSE;
					
					
					MqLog("Mqbvt Failed in thread: %d \n", Index + 1 );
					CHAR csLine[100];
					sprintf(csLine,"Mqbvt Failed in thread: %d",Index + 1);
					if( pNTLogFile )
					{
						pNTLogFile -> ReportResult(false,csLine);
					}
				}
			}
		}
		
		
		//
		// Delete temp queue On Pass / Fail
		//
		INT bSuccToDelte = MSMQ_BVT_SUCC;
		if( mTestParams[L"eSTtype"] == L"RunTimeSetup" )
		{
			bSuccToDelte = cTestParms.Delete();
		}		

		
		// Print summary Pass / Failed. bubug need to change error in wkg
		string cswkg = "";
		if( cTestParms.m_eMSMQConf == WKG )
		{
			cswkg = " ( for workgroup configuration ) ";
		}
		if( bTestPass && ! bSuccToDelte )
		{
			MqLog("Mqbvt Passed! %s\n" ,cswkg.c_str());
			CHAR csLine[100];
			sprintf(csLine,"Mqbvt Passed! %s",cswkg.c_str());
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(true,csLine);
			}
		}
		else
		{
			MqLog("Mqbvt Failed. %s\n" ,cswkg.c_str());
			CHAR csLine[100];
			sprintf(csLine,"Mqbvt failed! %s",cswkg.c_str());
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,csLine);
			}
		}
		
		
		return bTestPass ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}

INT MSMQMajorVersion(const wstring & wcsComputerName );

BOOL CheckMSMQVersion(list<wstring> & ListOfRemoteMachineName)
{
		int iLocalMachine = MSMQMajorVersion(L"");
		if ( iLocalMachine != 5 )
		{
				return FALSE;
		}
		list<wstring> ::iterator pMachine = ListOfRemoteMachineName.begin();
		int i;
		for (;pMachine != ListOfRemoteMachineName.end();pMachine++)
		{
			i = MSMQMajorVersion(*pMachine);
			if ( i != 5 )
			{
				return FALSE;
			}
		}
		return TRUE;
}


void ExcludeTests ( string & szExludeString, bool * bArray )
/*++
	Function Description:
		disable specfic tests 
	Arguments:
		szExludeString contains test or set of test separated by , to exclude
		bArray - Pointer to array that contain set of tests.
	Return code:
		None
--*/
{
	size_t iPos = 0;
	int i = 0;
	string str="";
	do
	{
		iPos = szExludeString.find_first_of(",");
		if(iPos != -1 )
		{
			string str = szExludeString.substr(0,iPos);
			i = atoi (str.c_str());
			szExludeString=szExludeString.substr(iPos+1,szExludeString.length());
		}
		else
		{
			i = atoi (szExludeString.c_str());
		}
		if ( i>0 && i < Total_Tests )
		{
			bArray[i-1] = true;
		}
	}
	while ( iPos != -1 );
}



int EnableEmbeddedTests (TestContainer * pTestCont,InstallType eInstallType)
/*++
	Function Description:
		Disable not relevant tests for Embedded configuration
	Arguments:
		TestContainer 
	Return code:
		int - Embedded state
--*/
{
	int iStatus = iDetactEmbededConfiguration();
	if( eInstallType != WKG )
	{
		if( iStatus == C_API_ONLY )
		{
			//
			// disable com thread.
			//
			pTestCont->bCreateTest[IsMqOA] = FALSE;
			pTestCont->bCreateTest[LocalAuth] = FALSE;
			pTestCont->bCreateTest[LocalEncryption] = FALSE;
			pTestCont->bCreateTest[RemoteAuth] = FALSE;
			pTestCont->bCreateTest[RemoteEncrypt] = FALSE;
			pTestCont->bCreateTest[ComTx] = FALSE;
			pTestCont->bCreateTest[RemoteTransactionQueue] = FALSE;
			pTestCont->bCreateTest[EODHTTP] = FALSE;
			pTestCont->bCreateTest[AuthHTTP] = FALSE;
			pTestCont->bCreateTest[Mqf] = FALSE;
		}
	}
	else
	{
		if( iStatus == C_API_ONLY )
		{
			pTestCont->bCreateTest[Mqf] = FALSE;
			pTestCont->bCreateTest[EODHTTP] = FALSE;
		}

	}
	return iStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\qsetget.cpp ===
#include "msmqbvt.h"
#include "randstr.h"


//+---------------------------
//
//  BOOL  ShowOGandSID()
//
//+---------------------------

#define NUMBEROFPROPERTIES 3

BOOL cSetQueueProp::GetOnerID( PSID pSid)
{
    if (!pSid)
    {
        MqLog("pSid is not available\n");
		return FALSE;
    }
	const int NameBufferSize = 500;
	CHAR NameBuffer[ NameBufferSize ];
    CHAR DomainBuffer[ NameBufferSize ];
    ULONG NameLength = NameBufferSize;
    ULONG DomainLength = NameBufferSize;
    SID_NAME_USE SidUse;
    DWORD ErrorValue;
    DWORD dwSize = GetLengthSid(pSid) ;

    if (!LookupAccountSid( NULL,
                           pSid,
                           NameBuffer,
                           &NameLength,
                           DomainBuffer,
                           &DomainLength,
                           &SidUse))
    {
        ErrorValue = GetLastError();
        MqLog ("LookupAccountSid() failed, LastErr- %lut\n",
                                                         ErrorValue) ;
		return FALSE;
    }
    else
    {
		if(g_bDebug)
		{
			MqLog (TEXT("Get queue owner size- %lut, %lxh, %s\\%s\n"),
                        dwSize, dwSize, DomainBuffer, NameBuffer);
		}
    }

    return TRUE ;
}

//+-----------------------------------------------------------
//
//   HRESULT  ShowNT5SecurityDescriptor()
//
//+-----------------------------------------------------------

BOOL cSetQueueProp::VerifyQueueHasOwner (SECURITY_DESCRIPTOR *pSD)
{
	PSID pSid = NULL;
	BOOL bDefualt;
    if (!GetSecurityDescriptorOwner(pSD, &pSid, &bDefualt))
    {
        MqLog("ERROR - couldn't get Security Descriptor Owner\n");
        return FALSE;
    }
    return GetOnerID( pSid );
}



cSetQueueProp::~cSetQueueProp()
{

}

cSetQueueProp::cSetQueueProp (int iTestIndex,std::map < std :: wstring , std:: wstring > Tparms )
:cTest(iTestIndex),m_destQueueFormatName(L""),m_QueuePathName(L""),m_RandQueueLabel(L""),m_publicQueueFormatName(L"")
{
	DWORD lcid = LocalSystemID ();
	WCHAR wcsTemp[60];
	int iBuffer = 60 ;
	GetRandomStringUsingSystemLocale(lcid,wcsTemp,iBuffer);
	m_RandQueueLabel = wcsTemp;
	ReturnGuidFormatName(m_QueuePathName,1);
	if ( Tparms[L"Wkg"] != L"Wkg")
	{
		m_publicQueueFormatName =Tparms[L"FormatName"];
	}
}

void cSetQueueProp::Description()
{
	wMqLog(L"Thread %d : cSetQueueProp Set and Get Queue props\n", m_testid);
}

int cSetQueueProp::Start_test()
/*++
  
	Function Description:

		Start_test -
		This function create an new private queue on the local computer and call to MQSetQueueProperties
		to update information about the queue.

	Arguments:
		None
	Return code:
		
		MSMQ_BVT_SUCC
		MSMQ_BVT_FAILED

	
--*/

{
	//
	// Need to Create a temp queue
	//
	
	
	cPropVar QueueProps(1);
	WCHAR wcsFormatName[BVT_MAX_FORMATNAME_LENGTH+1];
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	QueueProps.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,m_QueuePathName.c_str());
	HRESULT rc = MQCreateQueue(NULL,QueueProps.GetMQPROPVARIANT() , wcsFormatName , &ulFormatNameLength );
	ErrHandle(rc,MQ_OK,L"MQCreateQueue failed to create private queue ");
	m_destQueueFormatName = wcsFormatName;

	//
	// Set Queue 
	//
	 
	cPropVar SetQueueProp(NUMBEROFPROPERTIES);
	
	SetQueueProp.AddProp(PROPID_Q_LABEL,VT_LPWSTR,m_RandQueueLabel.c_str());
	DWORD dwTemp = MQ_PRIV_LEVEL_BODY;
	SetQueueProp.AddProp(PROPID_Q_PRIV_LEVEL,VT_UI4,&dwTemp);
	bool bTemp = MQ_JOURNAL;
	SetQueueProp.AddProp(PROPID_Q_JOURNAL,VT_UI1,&bTemp);
	rc = MQSetQueueProperties(m_destQueueFormatName.c_str(),SetQueueProp.GetMQPROPVARIANT());
	ErrHandle(rc,MQ_OK,L"MQSetQueueProperties failed");
	return MSMQ_BVT_SUCC;
}

int cSetQueueProp::CheckResult()
/*++
  
	Function Description:

		CheckResult -
		Call to MQGetQueueProperties and verify that MQSetQueueProperties succeded to set queue props

	Arguments:
		None
	Return code:
		MSMQ_BVT_SUCC
		MSMQ_BVT_FAILED

	
--*/
{
	
	DWORD cPropId = 0;
	MQQUEUEPROPS qprops;
	PROPVARIANT aQueuePropVar[NUMBEROFPROPERTIES];
	QUEUEPROPID aQueuePropId[NUMBEROFPROPERTIES];
	HRESULT aQueueStatus[NUMBEROFPROPERTIES];
  
	aQueuePropId[cPropId] = PROPID_Q_LABEL;
	aQueuePropVar[cPropId].vt=VT_NULL;
	cPropId++;
	
	aQueuePropId[cPropId] = PROPID_Q_PRIV_LEVEL;
	aQueuePropVar[cPropId].vt=VT_UI4;
	cPropId++;
	
	aQueuePropId[cPropId] = PROPID_Q_JOURNAL;
	aQueuePropVar[cPropId].vt=VT_UI1;
	cPropId++;

	
	qprops.cProp = cPropId;           // Number of properties
	qprops.aPropID = aQueuePropId;        // Ids of properties
	qprops.aPropVar = aQueuePropVar;      // Values of properties
	qprops.aStatus = aQueueStatus;        // Error reports
  
	
	HRESULT rc = MQGetQueueProperties(m_destQueueFormatName.c_str(),&qprops);
	ErrHandle(rc,MQ_OK,L"MQGetQueueProperties failed");

	
	//
	//  Compare the results
	// 
	if(aQueuePropVar[1].ulVal != MQ_PRIV_LEVEL_BODY )
	{
		wMqLog(L"QSetGet.cpp - Expected PROPID_Q_PRIV_LEVEL found %d\n",aQueuePropVar[1].ulVal);
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	if(aQueuePropVar[2].bVal != MQ_JOURNAL )
	{
		wMqLog(L"QSetGet.cpp - Expected MQ_JOURNAL found %d\n",aQueuePropVar[2].iVal);
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	if(wcscmp(m_RandQueueLabel.c_str(),aQueuePropVar[0].pwszVal) )
	{
		wMqLog(L"QSetGet.cpp failed to compare queue label\nFound:%s\nExpected:%s\n",aQueuePropVar[0].pwszVal,m_RandQueueLabel.c_str());
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	MQFreeMemory(aQueuePropVar[0].pwszVal);

	DWORD dwSize = 1;
	DWORD dwReqLen = 0;
	SECURITY_DESCRIPTOR * pSd = (SECURITY_DESCRIPTOR *) malloc (dwSize *sizeof(BYTE));
	rc = MQGetQueueSecurity(m_destQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
	if( rc == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL )
	{
		free(pSd);
		pSd = (SECURITY_DESCRIPTOR *) malloc (dwReqLen *sizeof(BYTE));
		dwSize = dwReqLen ;
		rc = MQGetQueueSecurity(m_destQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
		ErrHandle(rc,MQ_OK,L"MQGetQueueSecurity failed");		
		if (!VerifyQueueHasOwner(pSd))
		{
			MqLog("cSetQueueProp:failed to verify queue owner\n");
			return MSMQ_BVT_FAILED;
		}
		free(pSd);
	}
	else
	{
		wMqLog(L"Failed to call MQGetQueueSecurity expected:%d found %d\n",MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL,rc);
		return MSMQ_BVT_FAILED;
	}
	rc = MQDeleteQueue(m_destQueueFormatName.c_str());
	ErrHandle(rc,MQ_OK,L"MQDeleteQueue failed");

	if(m_publicQueueFormatName != L"")
	{
		DWORD dwSize = 1;
		DWORD dwReqLen = 0;
		SECURITY_DESCRIPTOR * pSd = (SECURITY_DESCRIPTOR *) malloc (dwSize *sizeof(BYTE));
		rc = MQGetQueueSecurity(m_publicQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
		if( rc == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL )
		{
			delete pSd;
			pSd = (SECURITY_DESCRIPTOR *) new BYTE[ dwReqLen ] ;
			dwSize = dwReqLen ;
			rc = MQGetQueueSecurity(m_publicQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
			ErrHandle(rc,MQ_OK,L"MQGetQueueSecurity failed");		
			if (!VerifyQueueHasOwner(pSd))
			{
				MqLog("cSetQueueProp:failed to verify public queue owner\n");
				return MSMQ_BVT_FAILED;
			}
			delete pSd;
		}
		else
		{
			wMqLog(L"Failed to call MQGetQueueSecurity expected:%d found %d\n",MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL,rc);
			return MSMQ_BVT_FAILED;
		}
	}
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.
#define TLS_XML       0x20000000L    // write log file as an XML (eXtensible Markup Language).


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\randstr.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: randstr.cpp

Abstract:
	
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
#include <time.h>
bool g_bInitRand = false;
int StrGen(
		   LCID lcid,           //Locale ID               
		   int nStyle,			//0 for ansi 
							    //1 for DBCS and 2 for Mixed
		   int length,			//the lenght of string 
								//0 for random MAX Limit is 255,
								//-1  for random MAX Limit is 65535,
		   int nFormat,			//0: ANSI 1:UNICODE
		   void **pStr
		   );

//
// This function retrieves the default system locale for the machine.
// Return value:
// Succ - DWORD lcid; 
// Failed - 0;
//



DWORD LocalSystemID ( void )
{
	CHAR csSystemLocaleBuffer[10];
	DWORD dwSystemLocaleBufferSize = 10;
	
	int ret = GetLocaleInfo( 
							 LOCALE_SYSTEM_DEFAULT, 
							 LOCALE_IDEFAULTLANGUAGE,
							 csSystemLocaleBuffer,
							 dwSystemLocaleBufferSize
							);
	if ( ret == 0 )
	{
		return GetLastError();
	}
	LCID currentSystemlcid;
	//
	// Convert to dword format
	// 
	sscanf(csSystemLocaleBuffer,"%x",&currentSystemlcid);
	return currentSystemlcid;
}
//
// GetRandomStringUsingSystemLocale
// Function return string that contain Alpha char from the default system locale
// input paramters:
// DWORD lcid - system locale.
// WCHAR * pBuffer - buffer to contain.
// DWORD dwBufferLen - buffer size.
//
//

INT GetRandomStringUsingSystemLocale (DWORD lcid, WCHAR * pBuffer , INT iBufferLen )
{	

   USHORT * uCurType;
   void * vp=NULL;
   int index = 0;
   do
   {
		StrGen( lcid ,1, (iBufferLen * 20) ,1,&vp);
		if(! wcscmp((WCHAR * )vp,L"") )
		{
			free (vp);
			return 0;
		}
		uCurType = (USHORT * ) calloc ( sizeof( USHORT ) * (iBufferLen * 21) , sizeof ( USHORT ) );
		
		if( uCurType == NULL )
		{
			return 0;
		}

		WCHAR * pwcsRandomstring=NULL;
		pwcsRandomstring = (WCHAR * ) malloc ( sizeof (WCHAR * ) *  ( wcslen ((WCHAR *) vp) + 1 ));
		if( pwcsRandomstring == NULL )
		{
			return 0;
		}
		wcscpy (pwcsRandomstring ,  (WCHAR * ) vp);
		BOOL bHr = GetStringTypeExW( LOCALE_SYSTEM_DEFAULT,
									 CT_CTYPE3,  
	     			  			     pwcsRandomstring,  
								     -1,
								     uCurType
								    );
		if ( bHr == FALSE )
		{
			DWORD dwHr = GetLastError ();
			MqLog( "GetStringTypeExW failed %d\n" , dwHr );
			
			return 0;
		}
		for ( int i = 0 ; i < ( iBufferLen * 20 ) ; i ++ )
		{	
			if( uCurType[i] & C3_ALPHA  )
			{
				pBuffer[index]=pwcsRandomstring[i];
				index ++;
			}
			if ( index == ( iBufferLen ) )
			{
				break;
			}
		}
		free(pwcsRandomstring);
		free (vp);
		free (uCurType);		
		if ( index == ( iBufferLen ) )
		{
			break;
		}
   }
   while ( index < iBufferLen );
   pBuffer[index-1] = L'\0';
      
   return 1;
}




int StrGen(    LCID lcid,           //Locale ID               
		       int nStyle,			//0 for ansi 
								    //1 for DBCS and 2 for Mixed
		       int length,			//the lenght of string 
									//0 for random MAX Limit is 255,
									//-1  for random MAX Limit is 65535,
		       int nFormat,			//0: ANSI 1:UNICODE
		       void **pStr
		  )
{
	WCHAR *awString = NULL;
    WORD UnicodeRangeUpper=0x7f,UnicodeRangeLower=0;
    int i=0;
	
	//for jpn character (Test!)
	BOOL fJpn = FALSE;													//added
	WORD wKanji[6] = {0x4fff,0x5000,0x9F9E,0x7aef,0x7d6d,0x6c5f};		//added

    if ( (0 !=nFormat) && (1 !=nFormat) )
	{
		assert(0 && "unsupported format");
		nFormat = 0;
	}
    if (nFormat)
    {
        awString = (WCHAR *) malloc(sizeof(WCHAR)*(length+1));
        if (awString == NULL)
		{
		    return 2;
		}
        if  (LANG_ARABIC == LOBYTE(lcid)) 
        {
            UnicodeRangeUpper=0x06FF;
            UnicodeRangeLower=0x0600;
        }
        else if (0x040D == lcid)  //Hebrew
        {
            UnicodeRangeUpper=0x05FF;
            UnicodeRangeLower=0x0590;
        }
		else if (0x0409 == lcid) // Latin
		{
            UnicodeRangeUpper = 0x007F;
            UnicodeRangeLower = 0x0000;
		}
		else if (0x0411 == lcid) // Those are real JPN chrcater 
		{
			fJpn = TRUE;
			// use Hiragana & KATAKANA charcter legal 
			UnicodeRangeUpper = 0x30ff;
		    UnicodeRangeLower = 0x3040;
		}
		else // Fix bug in whistler.
		{
			  UnicodeRangeUpper = 0x00FF;
              UnicodeRangeLower = 0x0000; 
		}

        /*else  // Latin-1 supplement.
        {
              UnicodeRangeUpper = 0x00FF;
              UnicodeRangeLower = 0x0000; 
			awString[0]=L'\0';
			nStyle = 0;
        } */
		
    }
	if ( g_bInitRand == false )
	{
		srand( (unsigned)time( NULL ) );
		g_bInitRand = true;
	}
	//
	// Pure locale string
	// 
	if( 1 == nStyle )
	{
		if ( 1 == length) 
		{
			length++;
		}
       
		if (fJpn)	//added
		{
			for (i=0;i<length;i++)
			{
				if (i<sizeof(wKanji)/sizeof(WCHAR))
				{
					awString[i] = (WCHAR)wKanji[i];
				}
				else
				{
					awString[i] = (WCHAR)(rand() % (UnicodeRangeUpper-UnicodeRangeLower+1)+UnicodeRangeLower); 
				}
			}
		}
		else
		{
			for (i=0;i<length;i++)
			{
			     awString[i] = (WCHAR)(rand() % (UnicodeRangeUpper-UnicodeRangeLower+1)+UnicodeRangeLower); 
			}
        }

        awString[length]=L'\0';
        
	}

	*pStr = awString;
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\ptrs.h ===
// -*-Mode:c++;-*-
#ifndef __PTRS_H
#define __PTRS_H

#include <windows.h>

#pragma warning( disable: 4284)

/*
 * Pointers classes
 *
 * Counter - A thread safe counter class
 * SPTR - Smart pointer with, a pointer class with reference count
 * aptr - Auto pointer
 * aaptr - Array Auto pointer
 */

/*
 * A thread safe counter class
 */
class Counter
{
public:
  typedef LONG value_type;
  
  Counter(value_type v = 0) : value(v) {};
  
  operator value_type() const {return value;}

  value_type operator++() { return InterlockedIncrement(&value); }
  value_type operator++(int) { return InterlockedIncrement(&value)-1;}
  value_type operator--() { return InterlockedDecrement(&value);}
  value_type operator--(int)  { return InterlockedDecrement(&value)+1;} 
  value_type operator=(value_type v) {return InterlockedExchange(&value, v);}

private:
  value_type value;
};

/*
 * Smart pointer - pointer with reference count.
 *                 When the reference count reaches 0, the pointer is deleted.
 *
 * Usage directions:
 * SPTR<C> pi(new int);
 * SPTR<C> p2 = pi;
...
 * NOTES:
 *   - operator=(T*) is not supported on purpose.
 */

class SPTR_ANY;

/*
 * Base class for Smart Pointer, so I can implement SPTR_ANY.
 */
class SPTR_base
{
public:
  virtual ~SPTR_base() {}
  bool operator==(const SPTR_base& ptr) { return eq(ptr); }
  bool operator< (const SPTR_base& ptr) { return lt(ptr); }

protected:
  virtual bool eq(const SPTR_base& ptr) const = 0;
   virtual bool lt(const SPTR_base& ptr) const = 0;
  virtual SPTR_base* clone() const = 0;

  friend class SPTR_ANY;
};

template<class T>
class SPTR : public SPTR_base
{
public:
  explicit SPTR(T* ptr = NULL) : p(ptr) { new_counter(); }

  template<class T2> SPTR(const SPTR<T2>& ptr) :
    counter(ptr.get_counter()),
    /*
     * If you want to be able to copy a base class to a
     * derived class, you should change the following line
     * to something line:
     *    p(dynamic_cast<T*>(ptr.get()))
     * NOTES: dynamic_cast returns 0 if the cast had failed.
     */
    p(ptr.get())
  {
    ++*counter;
  }

  SPTR(const SPTR& ptr) : 
    counter(ptr.counter),
    p(ptr.p)
  {
    ++*counter;
  }

  ~SPTR() { unlink(); }

  bool operator==(const SPTR& ptr) const { return p == ptr.p; }
  bool operator< (const SPTR& ptr) const { return p < ptr.p; }

  template <class T2> SPTR& operator=(const SPTR<T2>& ptr)
  {
    if (static_cast<const SPTR_base*>(this) != static_cast<const SPTR_base*>(&ptr))
    {
      unlink();
    /*
     * If you want to be able to copy a base class to a
     * derived class, you should change the following line
     * to something line:
     *    p = dynamic_cast<T*>(ptr.get());
     * NOTE: dynamic_cast returns 0 if the cast had failed.
     */
      p = ptr.get();
      counter = ptr.get_counter();
      ++*counter;
    }
    return *this;
  }

  SPTR& operator=(const SPTR& ptr)
  {
    if (this != &ptr)
    {
      unlink();
      p = ptr.p;
      counter = ptr.counter;
      ++*counter;
    }
    return *this;
  }

  T* get() const  {return p;}
  T* release()
  {
    if (!--(*counter)) {
      delete counter;
    }
    T* retval = p;
    p = NULL;
    return retval;
  }
    
  T* operator-> () {return get();}
  T& operator*() { return *get(); }
//  T** operator&(); // Don't remember why I don't like this operator.
  operator T*() { return get(); }

  Counter* get_counter() const {return counter;}

protected:

  void unlink()
  {
    if (!--(*counter)) {
      delete p;
      delete counter;
    }
  }

  bool eq(const SPTR_base& ptr) const
  {
    const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
    return *this == sptr_ptr;
  }

  bool lt(const SPTR_base& ptr) const
  {
    const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
    return *this < sptr_ptr;
  }

  SPTR_base* clone() const { return new SPTR(*this); }

  void new_counter() { counter = new Counter(1); }

  T* p;
  Counter *counter;
};

/*
 * SPTR_ANY: A class that can hold any type of smart pointer.
 */
class SPTR_ANY
{
public:
  SPTR_ANY(const SPTR_base& ptr) { p = ptr.clone(); }
  SPTR_ANY(const SPTR_ANY& ptr) { p = ptr.p->clone(); }
  ~SPTR_ANY() { delete p; }
  SPTR_ANY& operator=(const SPTR_ANY& ptr) {delete p; p = ptr.p->clone(); return *this;}
  bool operator==(const SPTR_ANY& ptr) { return *p == *ptr.p; }
  bool operator< (const SPTR_ANY& ptr) { return *p < *ptr.p; }

protected:
  SPTR_base* p;
};

/*
 * Smart pointer for storage of data in STL sets, etc
 * The difference is in the < and == operators, so that find will work
 * on the value and no on the pointers.
 *
 * Never tested, probably does not work....
 */
template<class T>
class SPSTL : public SPTR<T>
{
  SPSTL(T* ptr = NULL) : SPTR<T>(ptr) {}
  SPSTL(const SPSTL& ptr) : SPTR<T>(ptr) {}
  bool operator==(const SPSTL& a2) {return *this == *a2;}
  bool operator<(const SPSTL& a2) {return *this < *a2;}
};

/*------------------------- Auto pointer class -------------------------*/

template<class T>
class aptr
{
protected:
  T* p;
  void cleanup() { delete p; }
public:
  aptr(T* value = NULL) : p(value) {}
  ~aptr() { cleanup(); }
  T* operator=(T* value) { cleanup(); p = value; return p; }
  T* operator->() { return p; }
  T& operator*() { return *p; }
  T** operator&() { return &p; }
  operator T*() { return p;}
  T* get() {return p;}
  T* release() { T* t = p; p = NULL; return t; }
};

/*----------------------- Array Auto pointer class ---------------------*/

template<class T>
class aaptr
{
protected:
  T* p;
  void cleanup() { delete[] p; }
public:
  aaptr(T* value = NULL) : p(value) {}
  ~aaptr() { cleanup(); }
  T* operator=(T* value) { cleanup(); p = value; return p; }
  T* operator->() { return p; }
  T& operator*() { return *p; }
  T** operator&() { return &p; }
  operator T*() { return p;}
  T* get() {return p;}
  T* release() { T* t = p; p = NULL; return t; }
};
#endif // __PTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\randstr.h ===
#ifndef _MyLang 
#define _MyLang 

	INT GetRandomStringUsingSystemLocale(
										DWORD lcid,
										WCHAR * pBuffer,
										INT dwBufferLen 
										);
													

	DWORD LocalSystemID (void);


#endif _MyLang
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\sendrcv.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Sendrcv.cpp

Abstract:

	     Use this class for send receive messages:
		 a. Private local queues.
		 b. Public local queues.
		 c. Public remote queue.
		 Those tests try to Send & receive messages from destination queue.
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning(disable :4786)


//
// cAllSentMessageProp
// All message that sent written in array
// need to enhanced to check if all the propety recive in the messgae block
//


#include "msmqbvt.h"
using namespace std;



extern BOOL g_bRunOnWhistler;
HRESULT RetrieveMessageFromQueue(map <wstring,wstring> & mRetriveParms );


extern DWORD  g_dwRxTimeOut ;
extern BOOL g_bRunOnWhistler;

void cSendMessages::Description()
{
	wMqLog(L"Thread %d : Send receive message", m_testid);

	switch (m_testid)
	{
		case 1:
				wMqLog (L" from local private queue\n");
				break;
		case 2:
				wMqLog (L" ,local public Q\n");
				break;
		case 3:
				wMqLog (L" ,remote public Q(RemoteRead)\n");
				break;
		case 10:
				wMqLog (L" ,remote private Q using direct=os(RemoteRead)\n");
				break;
		case 18:
				wMqLog (L" ,local private Q (HTTP)\n");
				break;
		case 19:
				wMqLog (L" ,local public Q (HTTP)\n");
				break;
		case 20:
				wMqLog (L" ,remote public Q (HTTP)(RemoteRead)\n");
				break;
		case 21:
				wMqLog (L" ,remote private Q (HTTP)(RemoteRead)\n");
				break;

		default:
				MqLog (" \n");

	}
	
}

//------------------------------------------------------------------------------
// cSendMessages
//
// Contructor for this test's class.
//
//
// This Tests Get FormatName To:
// a. Dest Queue - strote in the map as DESTQFN.
// b. Admin Queue - map <wstring,wstring> ADMINFN.
//
//

cSendMessages::cSendMessages( INT iTid , map <wstring,wstring> Params ): 
	cTest( iTid ),
	m_bUseHTTPDirectFormatName(FALSE),
	m_bUseOnlyDirectFormatName(FALSE)
{

	if( Params[L"UseOnlyDirectFN"] == L"TRUE" )
	{
		m_bUseOnlyDirectFormatName = TRUE;
	}
	if( Params[L"UseDirectHTTP"] == L"TRUE" )
	{
		m_bUseHTTPDirectFormatName = TRUE;
	}
	// Retrive all the parmeters from the Map
	m_wcsDestQFormatName = Params[L"DESTQFN"];
	m_wcsAdminQFormatName = Params[L"ADMINFN"];
	//
	// check if get not empty strings
	//
	if( m_wcsDestQFormatName == L"Empty" || m_wcsAdminQFormatName == L"Empty" )
	{
	  if(g_bDebug)
	  {
		 wcout <<L"Q1 FN:"<< m_wcsDestQFormatName<<endl<<L"Q2 FN:" << m_wcsAdminQFormatName << endl;
	  }

	    throw INIT_Error("Can't Use this Queues");
	}
	
	//
	// Create Messgae Guid
	//
	wcsGuidMessageLabel = m_wcsGuidMessageLabel;
	//
	// Build the direct formatName "direct = os: machine name \ Qname "
	//
	wstring QueueName = Params[L"DestQName"];	
	wstring Token=L"\\";
	size_t iPos = QueueName.find_first_of(Token);	
	m_wcsDestDirectFormatName = ( m_bUseHTTPDirectFormatName ) ? L"Direct=htTP://":L"Direct=os:";
	m_wcsDestDirectFormatName += Params[L"MachName"];
	if( m_bUseHTTPDirectFormatName )
	{
		m_wcsDestDirectFormatName += L"\\MsMq";
	}
	m_wcsDestDirectFormatName += QueueName.substr( iPos );
	//
	// DIRECT=HTTP://mycomputer.microsoft.com/msmq/mypublicq
	//
	wstring wcsIISNameSpace =  L"\\msmq";
	if( m_bUseHTTPDirectFormatName == TRUE )
	{
		m_wcsDestHTTPDirectFormatName = L"Direct=HtTp://";
		m_wcsDestHTTPDirectFormatName += Params[L"MachName"];
		m_wcsDestHTTPDirectFormatName += wcsIISNameSpace;
		m_wcsDestHTTPDirectFormatName += QueueName.substr( iPos );

		wstring wcsQueueName = Params[L"AdminQueuePathName"];	
		wstring Token=L"\\";
		size_t iPos = wcsQueueName.find_first_of(Token);	
		
		if( iPos != -1 )
		{
			wstring wcsTempString;		
			wcsTempString = L"Direct=hTtP://";
			wcsTempString += Params[L"LocalMachName"];
			wcsTempString += wcsIISNameSpace;
			wcsTempString += wcsQueueName.substr( iPos );
			m_wcsAdminQFormatName = wcsTempString;
		}
		
		
	}


	if( g_bDebug )
	{	
		wMqLog(L"Send Receive messages tests will use these queues\n" );
		wMqLog(L"DestQ  guid:%s\n",m_wcsDestQFormatName.c_str());
		wMqLog(L"DestQ  direct fn:%s \n",m_wcsDestDirectFormatName.c_str());
		wMqLog(L"AdminQ direct fn:%s \n",m_wcsAdminQFormatName.c_str());
	}
}

HRESULT RetrieveMessageFromQueueById(map <wstring,wstring> & mRetriveParms );
//
// This tests recive messages from queue those steps:
// 1. regular format name.
// 2. Direct format name.
// 3. Admin Queue message
//

cSendMessages::CheckResult()
{

	map <wstring,wstring> mPrepareBeforeRecive;
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	
	//
	// Check the admin messages for Ack/Nack.
	//
	if( m_bUseOnlyDirectFormatName != NULL)
	{
		WCHAR wstrMclass[10]={0};
		swprintf(wstrMclass,L"%d\n",MQMSG_CLASS_ACK_REACH_QUEUE);
		mPrepareBeforeRecive[L"FormatName"]=m_wcsAdminQFormatName;
		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive from admin queue with direct formant name";
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;
		
		if( g_bDebug)
		{
			wMqLog (L"Try to receive ACK / NACK from admin queue: %s\n",m_wcsAdminQFormatName.c_str());
			wMqLog (L"Expected result is MQMSG_CLASS_ACK_REACH_QUEUE \n");
		}
		HRESULT rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC )
		{
			return MSMQ_BVT_FAILED;	
		}
	}
	//
	// Look for and receive a message with a specific GUID label
	// Other tests will have messages in the queue with different
	// GUID labels.
	//	
	if( ! m_bUseOnlyDirectFormatName )
	{	
		if( g_bDebug)
		{
			wMqLog (L"Try to receive from queue :%s\n",m_wcsDestQFormatName.c_str());
		}
		mPrepareBeforeRecive[L"FormatName"] = m_wcsDestQFormatName;
		mPrepareBeforeRecive[L"DebugInfromation"]=L"Receive message from dest queue";
		HRESULT rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if( rc != MSMQ_BVT_SUCC  )
		{
			return MSMQ_BVT_FAILED;		
		}
	}
	if( _winmajor == Win2K && ( m_bUseOnlyDirectFormatName  ) )
	{
		//
		// Try to receive with direct format name.
		//
		mPrepareBeforeRecive[L"FormatName"]=m_wcsDestDirectFormatName;
		if( g_bDebug)
		{
			wMqLog (L"Try to receive from queue :%s\n",m_wcsDestDirectFormatName.c_str());
		}
		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive message from queue with direct formant name"; // bugbug need to add + wcstestName;
		HRESULT rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC )
		{
			MqLog("Information:Receive with direct failed , Please check ping \n");
			return MSMQ_BVT_FAILED;	
		}

	}

	if( m_bUseHTTPDirectFormatName )
	{
		if( g_bDebug )
		{
			MqLog("Try to receive message from queue using MQReceiveMessageByLookupId API \n");
		}
		HRESULT rc = RetrieveMessageFromQueueById( mPrepareBeforeRecive );
		if(rc != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Failed to locate messages by using lookup ID\n");
			return MSMQ_BVT_FAILED;
		}
	}

	return MSMQ_BVT_SUCC;
}

//-----------------------------------------------------------------------------
// cSendMessages::Start_test()
//
// This is the Send-receive messages test
// There are four tests -- Send to and receive from:
//		1. Local private
//		2. Local public
//		3. Remote public
//		4. Remote private
//

INT cSendMessages::Start_test()
{
	
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle = NULL;
	cPropVar T13MessageProps(8);
	SetThreadName(-1,"cSendMessages - Start_test ");
	wstring Label(L"T1-3");
	//
	// Open the queue for send
	//
	//
	// Send express message with GUID format name.
	//
	T13MessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	T13MessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	T13MessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	T13MessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	T13MessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

	//
	// Send message using GUID FormatName
	//
	wstring wcsTempFormatName = m_wcsDestQFormatName;
	if( m_bUseOnlyDirectFormatName )
	{
		wcsTempFormatName = m_wcsDestDirectFormatName;
	}
	else if (m_bUseHTTPDirectFormatName)
	{
		wcsTempFormatName = m_wcsDestHTTPDirectFormatName;
	}
	if( g_bDebug )
	{
		wcout << L"DestQ FN: " << wcsTempFormatName.c_str() <<endl;
		wMqLog(L"Call->MQOpenQueue(%s,MQ_SEND_ACCESS , MQ_DENY_NONE ,,)\n",wcsTempFormatName.c_str());
	}
	rc=MQOpenQueue( wcsTempFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");
	if(g_bDebug)
	{
		MqLog("Send message to queue with properties PROPID_M_BODY,PROPID_M_LABEL,PROPID_M_ADMIN_QUEUE,MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL\n");
		wMqLog(L"Admin queue %s\n",m_wcsAdminQFormatName.c_str());
	}
	rc = MQSendMessage( QueueuHandle , T13MessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage (1) Failed");
	//
	// Send recoverable message with direct format name
	//
	if( g_bDebug )
	{
		MqLog("Add prop MQMSG_DELIVERY_RECOVERABLE\n");
	}
	tempValue=MQMSG_DELIVERY_RECOVERABLE;
	T13MessageProps.AddProp( PROPID_M_DELIVERY , VT_UI1 , &tempValue );
	rc = MQSendMessage( QueueuHandle , T13MessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage (2) Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	return MSMQ_BVT_SUCC;
}

//----------------------------------------------------------------------------------
// This function search for specific message in the queue with C-API function
// If the message found the function receive the message from the queue
// Input parameters:
// MRetriveParms map that expect those keys:
// mRetriveParms[L"M_Label"] - Message label to search.
// mRetriveParms[L"FormatName"] - Queue format name.
// mRetriveParms[L"CheckForDuplicate"] - this paramter check for duplicate messages
//

	

HRESULT RetrieveMessageFromQueue(map <wstring,wstring> & mRetriveParms )
{
	wstring wcsGuidBody=L"";
	wstring wcsQueueFormatName=L"";
	
	// ULONG uAccessMode;
	cPropVar Rprop(7);

	//
	// Create structure to receive body, label, and message class
	//
	WCHAR wcsBody[MAX_GUID+1]={0},Label[MAX_GUID+1]={0};
	USHORT uiMsgClass=9;
	wcscpy( wcsBody , L"Copy");
	Rprop.AddProp( PROPID_M_LABEL, VT_LPWSTR, Label , MAX_GUID );
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
	Rprop.AddProp( PROPID_M_CLASS , VT_UI2,&uiMsgClass );
	Rprop.AddProp( PROPID_M_BODY_SIZE , VT_UI4, &uiMsgClass );
	if( mRetriveParms[L"TransBaoundery"] != L"" )
	{
		Rprop.AddProp( PROPID_M_FIRST_IN_XACT , VT_UI1, &uiMsgClass );
		Rprop.AddProp( PROPID_M_LAST_IN_XACT , VT_UI1, &uiMsgClass );
	}
	if( mRetriveParms[L"MessageID"] != L"" )
	{
		ULONGLONG ululTemp;
		Rprop.AddProp( PROPID_M_LOOKUPID , VT_UI8, &ululTemp );
	}
	if( g_bDebug )
	{
		//
		// Print Debug Information with all the input paramters
		//
		wcout << L"RetrieveMessageFromQueue gets these parameters:"
		<< mRetriveParms[L"FormatName"] <<endl << L"message label = " << mRetriveParms[L"M_Label"] <<endl;
	}

	//
	// Retrieve expected results from the map ..
	//

	//
	// Which message are we looking for? We need to resolve the
	// format name of the message to GUID it's label will hold.
	//
	wcsGuidBody=mRetriveParms[L"M_Label"];
	wcsQueueFormatName=mRetriveParms[L"FormatName"];


	//
	// If ack requested, what is expected? ACK or NACK?
	//
	USHORT uTemp1=0;
	USHORT uExpectedMessageClass=0;
	if (mRetriveParms[L"MClass"] != L"" )
	{
		wstring wcsTemp = mRetriveParms [L"MClass"];
		swscanf (wcsTemp.c_str(),L"%d", &uExpectedMessageClass );
		Rprop.AddProp( PROPID_M_CLASS , VT_UI2 , &uTemp1 );
	}
	
	//
	// Peek through all the queue message. Look for message
	// with desired GUID label
	//

	HANDLE hQueue = NULL;
	HRESULT rc=MQOpenQueue( wcsQueueFormatName.c_str(), MQ_RECEIVE_ACCESS , MQ_DENY_NONE  , &hQueue );
	if( g_bDebug || hQueue == NULL )
	{
		wcout << L"Try to open queue format name:" << wcsQueueFormatName.c_str() << endl;
		wMqLog(L"Call-> MQOpenQueue( %s, MQ_RECEIVE_ACCESS , MQ_DENY_NONE)\n",wcsQueueFormatName.c_str());
	}
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");
	
	HANDLE hCursor=NULL;
	rc = MQCreateCursor( hQueue,&hCursor );
	if( g_bDebug || hQueue == NULL )
	{
		MqLog("Call->MQCreateCursor( hQueue,&hCursor )\n");
	}
	ErrHandle(rc,MQ_OK,L"MQCreateCursor Failed");
	
	DWORD dwReceiveTimeOut = g_dwRxTimeOut;
	BOOL bCheckForDuplicate=FALSE;
	if( mRetriveParms[L"CheckForDuplicate"] == L"CheckForDuplicate" )
	{
		bCheckForDuplicate=TRUE;
		dwReceiveTimeOut = 0;
	}
	bool bMessageFound = FALSE;
	DWORD  dwAction=MQ_ACTION_PEEK_CURRENT;
	if( g_bDebug )
	{
		MqLog("Search for message in queue using Cursor and Peek operation \n");
	}
	while( rc != MQ_ERROR_IO_TIMEOUT )
	{
		rc = MQReceiveMessage( hQueue , dwReceiveTimeOut , dwAction , Rprop.GetMSGPRops() , NULL , NULL , hCursor  ,NULL);
		if( !bCheckForDuplicate  )
		{
			ErrHandle(rc,MQ_OK,L"MQReceiveMessage failed with peek operation ");			
		}
		else // bCheckForDuplicate == TRUE
		{
			//
			// Expected MQ_ERROR_IO_TIMEOUT because all the messages has been received.
			// 
			if( rc != MQ_ERROR_IO_TIMEOUT ) 
			{
				if( rc == MQ_OK && ! wcscmp( Label , wcsGuidBody.c_str()))
				{
					wMqLog (L"Thread66: Found duplicate message test failed \n");
					return MSMQ_BVT_FAILED;
				}
				else if( FAILED(rc) )
				{
					wMqLog(L"RetrieveMessageFromQueue: Unexpected error code 0x%x\n", rc);
				}
				dwAction = MQ_ACTION_PEEK_NEXT;
				uTemp = MAX_GUID;
				Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp);
				continue;
			}
			else // rc == MQ_ERROR_IO_TIMEOUT 
			{
				return MSMQ_BVT_SUCC;
			}
		}
		uTemp = 200;
		Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
		dwAction=MQ_ACTION_PEEK_NEXT;
		Rprop.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , wcsBody , MAX_GUID);		
		if(!wcscmp( Label , wcsGuidBody.c_str()))
		{
			bMessageFound = TRUE;
			//
			// Found it. Receive the message (destructively) from the queue.
			//
			DWORD dwAction=MQ_ACTION_RECEIVE;
			if (mRetriveParms[L"MessageID"] != L"")
			{
				dwAction=MQ_ACTION_PEEK_CURRENT;
			}
			if(g_bDebug)
			{
				MqLog("Found message in queue call to MQReceiveMessage to remove the message\n");
			}
			rc = MQReceiveMessage( hQueue , dwReceiveTimeOut , dwAction, Rprop.GetMSGPRops() , NULL , NULL , hCursor , NULL);
			ErrHandle(rc,MQ_OK,L"MQReceiveMessage failed with peek ");
			break;
		}

	}
	wstring wcsBodyAsString=L"";
	if( bMessageFound == TRUE )
	{
		ULONG ulBodyLength = 0;
		Rprop.ReturnMSGValue( PROPID_M_BODY_SIZE , VT_UI4 , &ulBodyLength);
		wcsBody[ulBodyLength/sizeof(WCHAR)]= '\0';
		//
		// Check the message class. If it is a regular message,
		// then confirm that the body is equal to the label.
		//
		Rprop.ReturnMSGValue( PROPID_M_CLASS , VT_UI2 , &uiMsgClass );
		wcsBodyAsString = wcsBody;	
	}
	
	//
	// Check Message body for regular messages
	//
	if( bMessageFound == TRUE && uiMsgClass  == MQMSG_CLASS_NORMAL && mRetriveParms[L"TransBaoundery"] == L"" )
	{
		if(  wcsBodyAsString != wcsGuidBody )
		{
			MqLog("Message found without expected body ");
			wMqLog(L"Found:%s slen:%d\n",wcsBodyAsString.c_str(),wcsBodyAsString.length());
			wMqLog(L"Expected: %s slen:%d\n",wcsGuidBody.c_str(),wcsGuidBody.length());
			bMessageFound = FALSE; 		
		}
	}
	else if ( uiMsgClass  != MQMSG_CLASS_NORMAL )
			{
				if ( uiMsgClass != uExpectedMessageClass )
				{
					wMqLog (L"Expected to find class %x , found %x \n", uExpectedMessageClass , uiMsgClass );
					bMessageFound = FALSE; 		
				}
					
			}
	//
	// Translate message ID to String
	//
	
	if ( mRetriveParms[L"MessageID"] != L"" )
	{
		ULONGLONG ulLookupID;
		Rprop.ReturnMSGValue( PROPID_M_LOOKUPID , VT_UI8 , &ulLookupID );
		WCHAR buffer[100];
		swprintf(buffer,L"%I64d",ulLookupID);
		mRetriveParms[L"MessageID"] = buffer;
	}
	//
	// Add Transaction baundery tests
	//

	if( mRetriveParms[L"TransBaoundery"] != L"" )
	{
		// 1. Need to check if this is the first message
		UCHAR ucFirstMessage , ucLastMessage;
		Rprop.ReturnMSGValue( PROPID_M_FIRST_IN_XACT , VT_UI1 , &ucFirstMessage );
		Rprop.ReturnMSGValue( PROPID_M_LAST_IN_XACT , VT_UI1 , &ucLastMessage );
		if( ucFirstMessage != 0 )
		{
			mRetriveParms[L"TransBoundary"] = L"First";
		}
		else if( ucLastMessage != 0)
		{
			mRetriveParms[L"TransBoundary"] = L"Last";
		}
		else
		{
			mRetriveParms[L"TransBoundary"]=g_wcsEmptyString;
		}
		mRetriveParms[L"mBody"]=wcsBodyAsString;
	}
	rc = MQCloseCursor( hCursor );
	ErrHandle(rc,MQ_OK,L"MQCloseCursor Failed");
	rc=MQCloseQueue( hQueue );
	ErrHandle( rc , MQ_OK , L"MQCloseQueue Failed");
	return( bMessageFound ==  TRUE ) ? MSMQ_BVT_SUCC : MSMQ_BVT_FAILED;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\srmp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: SRMP.cpp

Abstract:
	Send / receive SRMP envelope
Author:
    
	Tal Kariv (talk) 12-7-2001
	
Revision History:

--*/
#include "msmqbvt.h"
using namespace std;
using namespace MSMQ;
static const wstring xSoapHeader = L"<BVT_Header>BVT - SRMP soap header</BVT_Header>";
static const wstring xSoapBody = L"<BVT_Body>BVT - SRMP soap body</BVT_Body>";

void CSRMP::Description()
{
	wMqLog(L"Thread %d : SRMP Thread\n", m_testid);
}

CSRMP::CSRMP(const INT iIndex , wstring wcsPublicQueueFormatName ):
cTest(iIndex),m_pEnvelope (NULL),m_hQueue(NULL),m_hCursor(NULL),m_publicQueueFormatName(L"")
{
	m_publicQueueFormatName = wcsPublicQueueFormatName;
}
CSRMP::~CSRMP()
{
	delete[] m_pEnvelope;
	if (m_hCursor != NULL)
	{
		MQCloseCursor(m_hCursor);
	}
	if (m_hQueue != NULL)
	{
		MQCloseQueue(m_hQueue);
	}
	

}

CSRMP::Start_test()
/*++  
	Function Description:
		send a SRMP message to a queue
	Arguments:
		none
	Return code:
		none
--*/
{
	HRESULT hr = MQ_OK;
	if(g_bDebug)
	{
		wMqLog(L"Opening queue %s\n" , m_publicQueueFormatName.c_str());
	}
	hr = MQOpenQueue(m_publicQueueFormatName.c_str(), MQ_SEND_ACCESS , MQ_DENY_NONE , &m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQOpenQueue Failed");

	// message props
	cPropVar SRMPProps(3);
	SRMPProps.AddProp( PROPID_M_SOAP_HEADER , VT_LPWSTR , xSoapHeader.c_str() );
	SRMPProps.AddProp( PROPID_M_SOAP_BODY , VT_LPWSTR , xSoapBody.c_str() );
	SRMPProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str());

	if(g_bDebug)
	{
		MqLog("Sending SRMP message (header + body)\n");
	}
	hr = MQSendMessage(m_hQueue , SRMPProps.GetMSGPRops(), NULL); 
	ErrHandle(hr,MQ_OK,L"MQSendMessage Failed");
	
	hr = MQCloseQueue(m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hQueue = NULL;
	
	return MSMQ_BVT_SUCC;
}


CSRMP::CheckResult()
/*++  
	Function Description:
		receive the message that was sent from queue and check its envelope
	Arguments:
		none
	Return code:
		none
--*/
{
	if(g_bDebug)
	{
		wMqLog(L"Opening queue %s\n" , m_publicQueueFormatName.c_str());
	}
	HRESULT hr = MQOpenQueue(m_publicQueueFormatName.c_str(), MQ_RECEIVE_ACCESS , MQ_DENY_NONE , &m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQOpenQueue Failed");
	
	WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN+1] = L"";
	ULONG ulMessageLabelLength = MQ_MAX_MSG_LABEL_LEN + 1;
	
	// message props
	cPropVar SRMPPropsPeek(3);
	SRMPPropsPeek.AddProp( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , 0 );
	SRMPPropsPeek.AddProp( PROPID_M_LABEL , VT_LPWSTR , wcsLabel  , MAX_GUID+1);
	SRMPPropsPeek.AddProp( PROPID_M_LABEL_LEN , VT_UI4 , &ulMessageLabelLength);
	
	hr = MQCreateCursor(m_hQueue , &m_hCursor);
	ErrHandle(hr,MQ_OK,L"MQCreateCursor Failed");

	if(g_bDebug)
	{
		MqLog("Peeking SRMP envelope\n");
	}
	hr = MQReceiveMessage(m_hQueue, 1000 , MQ_ACTION_PEEK_CURRENT , SRMPPropsPeek.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
	ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_PEEK_CURRENT) Failed");
	for (;;)
	{
		if( m_wcsGuidMessageLabel == wcsLabel )
		{
			// found message
			if(g_bDebug)
			{
				MqLog("Message found in queue\n");
			}
			break;
		}
	    SRMPPropsPeek.AddProp( PROPID_M_LABEL_LEN , VT_UI4 , &ulMessageLabelLength);
		hr = MQReceiveMessage(m_hQueue, 1000 , MQ_ACTION_PEEK_NEXT , SRMPPropsPeek.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
		ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_PEEK_NEXT) Failed");
		if(g_bDebug)
		{
			MqLog("Try next message\n");
		}

	}

	ULONG ulEnvelopeLength =0;
	SRMPPropsPeek.ReturnMSGValue( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , &ulEnvelopeLength);
	if(g_bDebug)
	{
		MqLog("Envelope length %d\n" , ulEnvelopeLength);
	}
	
	m_pEnvelope = new WCHAR[ulEnvelopeLength+1];
	if (m_pEnvelope == NULL)
	{
		MqLog("New failed\n");
		return (MSMQ_BVT_FAILED);
	}	
	// message props
	cPropVar SRMPPropsReceive(2);
	SRMPPropsReceive.AddProp( PROPID_M_SOAP_ENVELOPE , VT_LPWSTR , m_pEnvelope , ulEnvelopeLength);
	SRMPPropsReceive.AddProp( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , &ulEnvelopeLength );
	
	if(g_bDebug)
	{
		MqLog("Receiving SRMP envelope\n");
	}
	hr = MQReceiveMessage(m_hQueue, 1000 , MQ_ACTION_RECEIVE , SRMPPropsReceive.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
	ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_RECEIVE) Failed");
	if(g_bDebug)
	{
		MqLog("Verifying header\n");
	}
	if (!wcsstr(m_pEnvelope , xSoapHeader.c_str()))
	{
		MqLog("Cannot find SRMP header\n");
		return (MSMQ_BVT_FAILED);
	}
	if(g_bDebug)
	{
		MqLog("Header - OK\nVerifying body\n");
	}
	if (!wcsstr(m_pEnvelope , xSoapBody.c_str()))
	{
		MqLog("Cannot find SRMP body\n");
		return (MSMQ_BVT_FAILED);
	}
	if(g_bDebug)
	{
		MqLog("Body - OK\n");
	}

	hr = MQCloseCursor(m_hCursor);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hCursor = NULL;
	hr = MQCloseQueue(m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hQueue = NULL;
	

	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\sec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Sec.h

Abstract:
	This is the Test that checks authenticate messages with or without authenticate queue
	This is part of the Security Test that add to the BVT after W2L beta 2.
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include <windows.h>


#ifndef MQBVT_SEC
#define FALBVT_SEC 1


class Handle_t 
{
public:
  Handle_t(HANDLE handle);
  HANDLE get();
  virtual ~Handle_t();

private:
  HANDLE m_handle;
};


class Impersonate_t
{
public:
	Impersonate_t(const std::string& user,const std::string& domain,const std::string& password);
	Impersonate_t(HANDLE hToken);
	void ImpersonateUser ();
	virtual ~Impersonate_t();

private:
	bool m_impersonated;
	HANDLE	m_hToken; 
};

inline void Impersonate_t::ImpersonateUser ()
{
	bool  bResult;
    bResult=(ImpersonateLoggedOnUser(m_hToken)==TRUE);
	CloseHandle(m_hToken);
	if(bResult == FALSE)
    {
	  throw INIT_Error("could not impersonate"); 
    }
}

inline  Impersonate_t::Impersonate_t(const std::string& user,const std::string& domain,const std::string& password):m_impersonated(true)
{
  	
    bool  bResult;

    if(user == "")
    {
      m_impersonated=FALSE;
      return;  
    }
	
	if (domain == "")
    { 
      bResult=(LogonUserA(const_cast<char*>(user.c_str()),
		                 NULL,
					   const_cast<char*>(password.c_str()),
					   LOGON32_LOGON_INTERACTIVE,
					   LOGON32_PROVIDER_DEFAULT,
					   &m_hToken)==TRUE);
	 
    } 
    else
    {
      bResult=(LogonUserA(const_cast<char*>(user.c_str()),
		                 const_cast<char*>(domain.c_str()),
					   const_cast<char*>(password.c_str()),
					   LOGON32_LOGON_INTERACTIVE,
					   LOGON32_PROVIDER_DEFAULT,
					   &m_hToken)==TRUE);  
       

    }

    if(bResult == FALSE )
    {
       throw INIT_Error("could not logon as the user");     
    }
/*
    bResult=(ImpersonateLoggedOnUser(hToken)==TRUE);
	BOOL b=CloseHandle(hToken);
	assert(b);
    if(bResult == false)
    {
	  throw INIT_Error("could not impersonate"); 
    }
	*/
}


inline Impersonate_t::~Impersonate_t()
{
 if(m_impersonated)
 {
   RevertToSelf();
 } 
}


inline std::basic_string<unsigned char> GetCurrentThreadSid( std::wstring & wcsAccountName );
inline void LoadHiveForSid(const std::basic_string<unsigned char>& sid);
inline std::string GetTextualSid(PSID pSid);
inline void SetSpecificPrivilegeInThreadAccessToken(LPCTSTR lpwcsPrivType, BOOL bEnabled);
inline void SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
											   LPCTSTR lpwcsPrivType,
											   BOOL    bEnabled );

HANDLE FAL_GetThreadSecurityContext(Impersonate_t  & user,std::wstring & szAccoutName);

#endif // Mqbvt_SEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\string.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: String.cpp

Abstract:
	
	  This build the message that sent from transaction tests.
	  This code check the message order.
	  		
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning(disable :4786)

#include "msmqbvt.h"
using namespace std;

int operator != (StrManp& s1,StrManp &s2)
{
	return ! (s1==s2);
}
int operator == ( StrManp& s1, StrManp &s2)
{
	if (s1.array.size() != s2.array.size()) 
	{
		return 0;
	}
	vector<wstring> ::iterator p = s1.array.begin();
	vector<wstring> ::iterator s = s2.array.begin();
	while( p != s1.array.end())
	{
		if ( *p != *s )
		{
			return 0;
		}
		p++;
		s++;
	}
	return 1;
}

StrManp::~StrManp()
{

}
void StrManp::Clear()
{
	array.clear();
}
void StrManp::SetStr( wstring str)
{
	array.push_back(str);
}

void StrManp::print()
{
	for(vector <wstring> ::iterator it = array.begin();
		it != array.end();
		it++
	   )
	{
		wcout << *it <<endl;
	}
}

StrManp::StrManp( INT iSize ) : Size(iSize)
{
	array.clear();
}

StrManp::StrManp( INT iSize , wstring str) : Size( iSize )
{
	
	WCHAR csIndexAswstring[10];
	array.clear();
	for( int Index=0 ; Index <iSize ; Index ++ )
	{
		_itow( Index,csIndexAswstring, 9 );
		array.push_back( str + csIndexAswstring );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif

void CmdRemoveService();
VOID CmdInstallService();
//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "Mqbvt"
// internal name of the service
#define SZSERVICENAME        "Mqbvtsrv"
// displayed name of the service
#define SZSERVICEDISPLAYNAME "Mqbvt Service"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPTSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.cpp
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  Changed by:Eitank for Mqbvt
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "service.h"



// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // ServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        fResult = SetServiceStatus( sshStatusHandle, &ssStatus);
		if( !fResult )
		{
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


    if ( !bDebug )
    {
        dwErr = GetLastError();

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL) 
		{
			// Need to  
        }
    }
}




///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
	//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\trans.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Trans.cpp

Abstract:

  1. Contain Send transaction messages to remote queue and read 
     it using transaction baoundery.
  2. Open system queue using direct format name NT5 only
  

Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace MSMQ;
#include "errorh.h"
#include <time.h>
using namespace std;
extern BOOL g_bRunOnWhistler;
#pragma warning(disable:4786)

//------------------------------------------------------------
// xActViaCom::Description Print test description
//

void xActViaCom::Description()
{
	wMqLog(L"Thread %d : Send xAct messages to remote queues %s\n", m_testid,(m_testid==24) ? L"(HTTP)":L"");
}

//------------------------------------------------------------
// 
// xActViaCom::xActViaCom constructor receive the queue format name.
//

xActViaCom::xActViaCom (INT index , map< wstring , wstring > Tparms )
:cTest(index), m_Destqinfo("MSMQ.MSMQQueueInfo"),m_ixActIndex(0),m_iMessageInTransaction(3),m_pSendBlock(NULL)
{
   m_wcsDestQueueFormatName = Tparms[L"FormatName"];
   ReturnGuidFormatName( m_SeCTransactionGuid , 2 , true );
   
   m_bNT4WithSp6=FALSE;
   if ( Tparms[L"Sp6"] == L"YES")
   {
	   m_bNT4WithSp6=TRUE;
   }
   
   m_pSendBlock= new StrManp( m_iMessageInTransaction,L"RemoteTrans" );
   if( !m_pSendBlock )
   {
			MqLog("xActViaCom::Start_test Failed to allocate memory for StrManp \n");
			throw INIT_Error("xActViaCom::Start_test Failed to allocate memory for StrManp \n");
   }
}

xActViaCom::~xActViaCom ()
{
   delete m_pSendBlock;
}

//-----------------------------------------------
// xActViaCom::Start_test
// Send transacted message to remote queue using DTC transaction.
// 
// Return value:
// MSMQ_BVT_SUCC - Pass// MSMQ_BVT_FAILED - Fail
//

INT xActViaCom::Start_test()
{

	SetThreadName(-1,"xActViaCom - Start_test ");	
	try 
	{
		m_Destqinfo->FormatName = m_wcsDestQueueFormatName.c_str();
		wstring wcsToken=L"DIRECT=";
		size_t iDirectExist = m_wcsDestQueueFormatName.find_first_of(wcsToken);
		
		if ( iDirectExist != 0 )
		{ // Can do refresh on direct format name on remote machine
			m_Destqinfo->Refresh();
		}

		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg("MSMQ.MSMQMessage");
		
		
		//
		// Print Debug information
		//
		
		if( g_bDebug )
		{
			wMqLog (L"xActViaCom::Start_test, Send message to queue PathName:%s \n QueueFormatName: %s\n",m_Destqinfo->PathName,m_Destqinfo->FormatName);
		}

		m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);	
		
		MSMQ::IMSMQTransactionDispenserPtr xdispenser ("MSMQ.MSMQTransactionDispenser");
		MSMQ::IMSMQTransactionPtr xact("MSMQ.MSMQTransaction");
		
		xact = xdispenser->BeginTransaction ();

		_variant_t vTrans(static_cast<IDispatch*>(xact));
		
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		//
		// Send three messages 
		//
		
		for( INT Index=0 ; Index<m_iMessageInTransaction ; Index++)
		{
			if ( g_bDebug )
			{
				wMqLog (L"xActViaCom::Start_test, Send message label %s Body %s\n",m_wcsGuidMessageLabel.c_str(),(m_pSendBlock->GetStr( Index )).c_str());
			}
			m_msg->Body = (m_pSendBlock->GetStr( Index )).c_str();
			m_msg->Send( m_DestqinfoHandle , &vTrans );	
		}
		
		xact->Commit();
		m_ixActIndex++;
	
		xact = xdispenser->BeginTransaction ();
		_variant_t vTrans2(static_cast<IDispatch*>(xact));
		m_msg->Label = m_SeCTransactionGuid.c_str();
		
		for( Index=0 ; Index<m_iMessageInTransaction ; Index++)
		{
			if ( g_bDebug )
			{
				wcout << L"xActViaCom::Start_test, Send message label:"<<m_SeCTransactionGuid.c_str()<< L"body" << m_pSendBlock->GetStr( Index ).c_str() <<endl;
			}
			m_msg->Body = (m_pSendBlock->GetStr( Index )).c_str();
			m_msg->Send( m_DestqinfoHandle , &vTrans2 );	
		}
		xact->Commit();
		m_ixActIndex++;
		
		if( g_bDebug )
		{
			wMqLog (L"xActViaCom::Start_test, Send message using DTC transaction");
		}
	}
	catch (_com_error & ComErr)
	{
		
		return CatchComErrorHandle( ComErr , m_testid );
	}
	return MSMQ_BVT_SUCC;
}

//--------------------------------------------------------
// Receive message from dest queue without transaction.
// 
// Return value:
// MSMQ_BVT_SUCC - Pass
// MSMQ_BVT_FAILED - Fail
//

INT xActViaCom::CheckResult()
{
		
	HRESULT rc;
	if ( g_bDebug )
	{	
		wMqLog (L"Try to receive from QFN:%s\n",m_wcsDestQueueFormatName.c_str());
	}
	
	INT iNumberOfTransaction=0;
	INT iMessageInTrans = 0;
	map < wstring,wstring > map_ReceiveFromQueue;
	map_ReceiveFromQueue[L"DestFormatName"] = m_wcsDestQueueFormatName;
	map_ReceiveFromQueue[L"mLabel"] = m_wcsGuidMessageLabel;
	StrManp pwcsMessgeBody(m_iMessageInTransaction);				
	do
	{
		if ( _winmajor == Win2K )
		{	
			map_ReceiveFromQueue[L"mBody"] = g_wcsEmptyString;
			map_ReceiveFromQueue[L"TransBaoundery"] = g_wcsEmptyString;
		}
		if( g_bDebug )
		{
			wcout <<L"Try to receive message with guid:" << m_wcsGuidMessageLabel <<endl;
		}
		rc = RetrieveMessageFromQueueViaCom( map_ReceiveFromQueue );
		if( rc != MSMQ_BVT_SUCC )
		{
			MqLog("Message not found in the destination queue. (1)\n");
			wMqLog(L"Message number: %d Not found in dest queue \n", m_ixActIndex );
			return MSMQ_BVT_FAILED;
		}
		if( g_bDebug )
		{
			wcout <<L"Receive Messages" << map_ReceiveFromQueue[L"mBody"] <<endl;
		}
		//
		// bugbug delete all meessage in the queue.
		// 
		if( _winmajor ==  NT4 && m_bNT4WithSp6 == FALSE )
		{
			break;
		}
		
		if( map_ReceiveFromQueue[L"TransBoundary"] == L"First")
		{
			iMessageInTrans=0;
		}
		pwcsMessgeBody.SetStr(map_ReceiveFromQueue[L"mBody"]);
		iMessageInTrans ++;
		
		if( g_bDebug )
		{
				wMqLog(L"Found message %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
		}	

		if( map_ReceiveFromQueue[L"TransBoundary"] == L"Last")
		{
		
			iNumberOfTransaction ++;
			if( iMessageInTrans != m_iMessageInTransaction )
			{
				wMqLog (L"xActViaCom::CheckResult Can't find the last message Found %d messages \n Sent %d messages \n", 
					iMessageInTrans , m_iMessageInTransaction );
				wMqLog(L"Message body %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
				return MSMQ_BVT_FAILED;
			}
			if( *m_pSendBlock != pwcsMessgeBody )
			{
				wMqLog (L"Error message are not in expected order\n");
				return MSMQ_BVT_FAILED;
			}
			pwcsMessgeBody.Clear();
			map_ReceiveFromQueue[L"mLabel"]=m_SeCTransactionGuid;
		}
		
	} while ( iNumberOfTransaction != m_ixActIndex );
	
	if( rc != MSMQ_BVT_SUCC )
	{
		MqLog( "Message not found in the destination queue. (1)");
		return MSMQ_BVT_FAILED;
	}
	if ( g_bDebug )
	{	
		wcout<<L"xActViaCom::CheckResult - message found in the queue" <<endl;
	}
	return MSMQ_BVT_SUCC;
}

// Add to check trnsaction baounder 
// Need to ask in the return value 


//-------------------------------------------------------------------
// COpenQueues::COpenQueues
// This test try to open system queues with differnt format names
// 
// 
//


COpenQueues::COpenQueues( int Index,  map<wstring,wstring> & Tparms ) : cTest(Index),m_wcsLocalMachineName(L""),
	m_iEmbedded(COM_API)
{
	m_wcsLocalMachineName =  Tparms[L"LocalMachineName"];
	m_MachineName.push_back( Tparms[L"LocalMachineName"] );
	m_MachineName.push_back( Tparms[L"RemoteMachineName"] );
	m_MachineGuid.push_back( Tparms[L"LocalMachineNameGuid"] );
	m_MachineGuid.push_back( Tparms[L"RemoteMachineNameGuid"] );
	iWorkGroupFlag = 0;
	if ( Tparms[L"Wkg"] == L"Wkg" )
	{
		iWorkGroupFlag = 1;
	}
	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}

}



//-------------------------------------------------------------
// COpenQueues::Start_test
// Prepare all queue direct format names
// Example direct=os:machinename\\System$;jornal / deadletter / deadxact
// return values:
// Pass - MSMQ_BVT_SUCC	
// Fail - MSMQ_BVT_FAILED

INT COpenQueues::Start_test()
{
	SetThreadName(-1,"COpenQueues - Start_test ");	

	WSADATA WSAData;
	if ( WSAStartup(MAKEWORD(1,1), &WSAData) != 0 )
	{
		MqLog("WSAStartup failed with error 0x%x\n",GetLastError());
		return MSMQ_BVT_FAILED;
	}
	
	vector <wstring> vSpeceilQueueName(3),vGuidName(3);
	vector <wstring> vOpenQueuMode(3);
	//
	// Direct format name 
	// 
	const int iJORNAL=0;
	const int iDADLATER=1;
	const int iDADXACT=2;
	vSpeceilQueueName[iJORNAL]=L"\\SYSTEM$;JOURNAL";
	vSpeceilQueueName[iDADLATER]=L"\\SYSTEM$;DEADLETTER";
	vSpeceilQueueName[iDADXACT]=L"\\SYSTEM$;DEADXACT";
	
	vGuidName[iJORNAL]=L";JOURNAL";
	vGuidName[iDADLATER]=L";DEADLETTER";
	vGuidName[iDADXACT]=L";DEADXACT";

	vOpenQueuMode[0]=L"Direct=os:";
	vOpenQueuMode[1]=L"Direct=tcp:";
	vOpenQueuMode[2]=L"machine=";
	
	//
	// Init the local & Remote machine IP address
	// 

	string Temp = My_WideTOmbString( m_MachineName.front());
	for ( int Index = 0 ; Index < 2 ; Index ++ )
	{
	
		struct hostent* pHost = gethostbyname( Temp.c_str() );
		if ( pHost && pHost->h_length == 4)
		{
			in_addr Address;
			Address.S_un.S_addr = *(u_long*)(pHost->h_addr);
			char* pszAddress = inet_ntoa(Address);
			if ( pszAddress != NULL)
			{
				m_IPaddress.push_back( My_mbToWideChar (pszAddress) );
			}
			else
			{
				m_IPaddress.push_back( g_wcsEmptyString );
			}

		}
		else
		{
			wMqLog (L"Can't retrieve local machine IP address\n");
			m_IPaddress.push_back( g_wcsEmptyString );
			WSACleanup();
			return MSMQ_BVT_FAILED;
		}
		string Temp = My_WideTOmbString( m_MachineName.back());
	}

	WSACleanup();
	
	//
	// Create all format name permoation.
	// 

	vector <wstring>::iterator pIpAddress = m_IPaddress.begin();
	vector <wstring>::iterator pMachineGuid = m_MachineGuid.begin();
    for	( vector <wstring>::iterator p= m_MachineName.begin(); p != m_MachineName.end(); 
		p++ , pIpAddress ++ , pMachineGuid ++ )
	{
		vector <wstring>::iterator pGuidQueueName = vGuidName.begin();
		for	( vector <wstring>::iterator pQueueName = vSpeceilQueueName.begin(); pQueueName != vSpeceilQueueName.end(); 
		pQueueName ++ , pGuidQueueName ++)
		{
			m_vSpeceilFormatNames.push_back( vOpenQueuMode[0]+ *p + *pQueueName );

			if (*pIpAddress != g_wcsEmptyString )
			{
				m_vSpeceilFormatNames.push_back( vOpenQueuMode[1]+ *pIpAddress+ *pQueueName );	
			}
		
			if (*pIpAddress != g_wcsEmptyString)
			{
				m_vSpeceilFormatNames.push_back( vOpenQueuMode[2]+ *pMachineGuid+ *pGuidQueueName );	
			}		
		}
	}

	if ( g_bDebug )
	{
		MqLog("---------------------------\n");
		dbg_printAllQueue();
	}
	//
	// Send Tx messages and expected TTL = 0;
	// 
	if(g_bRunOnWhistler && m_iEmbedded != C_API_ONLY )
	{
		if(g_bDebug)
		{
			MqLog("Send xACT Message to non existing destination with MaxTimeToReachQueue=0\n" \
				  "Expected result messages should be in XACT-Dead Letter queue\n");
		}
		try
		{
			IMSMQQueueInfoPtr m_Destqinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueuePtr m_DestqinfoHandle;
			IMSMQMessagePtr m_msg("MSMQ.MSMQMessage");
			m_Destqinfo->FormatName = "direct=os:UnKnownComp\\private$\\Nothing";
			m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);	
			IMSMQTransactionDispenserPtr xdispenser ("MSMQ.MSMQTransactionDispenser");
			IMSMQTransactionPtr xact("MSMQ.MSMQTransaction");	
			xact = xdispenser->BeginTransaction ();
			_variant_t vTrans(static_cast<IDispatch*>(xact));
			m_msg->Label = m_wcsGuidMessageLabel.c_str();
			m_msg->Body = m_wcsGuidMessageLabel.c_str();
			m_msg->MaxTimeToReachQueue = 0;
			m_msg->Journal = MQMSG_JOURNAL | MQMSG_DEADLETTER;
			m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
			m_msg->Send( m_DestqinfoHandle , &vTrans );	
			xact->Commit();
		}
		catch (_com_error & ComErr)
		{	
			return CatchComErrorHandle( ComErr , m_testid );
		}
	}


return MSMQ_BVT_SUCC;	
}

//----------------------------------------------------
// COpenQueues::dbg_printAllQueue
// Use for debug print all queue formatnames
// 

void COpenQueues::dbg_printAllQueue() 
{
	for	( vector <wstring>::iterator p= m_vSpeceilFormatNames.begin(); p != m_vSpeceilFormatNames.end(); 
		p++)
		{
			wcout << *p <<endl;
		}
}

//----------------------------------------------------
// Try to open queue format name 
//

INT COpenQueues::CheckResult()  
{
	bool bUserCanOpenSystemQueues = true;
	for	( vector <wstring>::iterator p= m_vSpeceilFormatNames.begin(); p != m_vSpeceilFormatNames.end(); 
	p++)
	{
		
		
		
		//
		// Need this because workgroup could not open queue using machine=GUID...
		// 
		if ( iWorkGroupFlag == 1 )
		{
			wstring wcsToken=L"machine=";
			size_t iPos = p->find_last_of (wcsToken);	
			if ( iPos != 0 )	
			{
				continue;
			}
		}


		if( g_bDebug )
		{
			wMqLog(L"Try to open queue with Special format name: %s\n",p->c_str());
		}
		
		HANDLE hQueue;
		HRESULT rc = MQOpenQueue( p->c_str() , MQ_RECEIVE_ACCESS , MQ_DENY_NONE, & hQueue );
		if( rc != MQ_OK )
		{
			if ( rc != MQ_ERROR_ACCESS_DENIED )
			{
				wMqLog( L"Failed to open queue Path:%s with error rc=%x\n", p->c_str() , rc);
				ErrHandle( rc , MQ_OK , L"MQOpenQeueue failed" );
				return MSMQ_BVT_FAILED; 
			}
			else
			{ // MQ_ERROR_ACCESS_DENIED 
				//
				// Need to check if you are Administrator on the localmachine.
				// 
				bUserCanOpenSystemQueues = false;
			}
		}
		else
		{ // MQ_OK
			bUserCanOpenSystemQueues = true;
			rc = MQCloseQueue( hQueue );
			ErrHandle( rc , MQ_OK , L"MQCloseQueue failed\n");
		}
	}

	if(g_bRunOnWhistler && bUserCanOpenSystemQueues && m_iEmbedded != C_API_ONLY )
	{
		if(g_bDebug)
		{
			MqLog("Receive message from XACT-Dead Letter queue\n");
		}
		map < wstring,wstring > map_ReceiveFromQueue;
		wstring wcsFormatName =  L"DIRECT=OS:";
		wcsFormatName += m_wcsLocalMachineName;
		wcsFormatName += L"\\SYSTEM$;DEADXACT";
		map_ReceiveFromQueue[L"FormatName"] = wcsFormatName;
		map_ReceiveFromQueue[L"M_Label"] = m_wcsGuidMessageLabel;
		map_ReceiveFromQueue[L"mBody"] = m_wcsGuidMessageLabel;
		WCHAR wstrMclass[10]={0};
		swprintf(wstrMclass,L"%d\n",MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT);
		map_ReceiveFromQueue[L"MClass"] = wstrMclass;
		HRESULT rc = RetrieveMessageFromQueue ( map_ReceiveFromQueue );
		if(rc!=MSMQ_BVT_SUCC)
		{
			wMqLog(L"Message not found in the destination queue. (1)");
			return MSMQ_BVT_FAILED;
		}
	}
		
return MSMQ_BVT_SUCC;
}
//----------------------------------------------------------
//
//

void COpenQueues::Description(void)
{
	wMqLog(L"Thread %d : Try open system queues\n", m_testid);
}
//----------------------------------------------------------
// Transaction Boundaries tests for Service pack 6
// check those using the C API,
//
//

xActUsingCapi::xActUsingCapi (INT index , std::map < std :: wstring , std:: wstring > Tparms ) : xActViaCom( index , Tparms )
{
 /* Empty */
}

//--------------------------------------------------
// xActUsingCapi::CheckResult
// Transaction Boundaries CheckeResult using C-API
//
INT xActUsingCapi::CheckResult()
{

	HRESULT rc;
	if ( g_bDebug )
	{	
		wMqLog (L"Try to receive from QFN:%s\n",m_wcsDestQueueFormatName.c_str());
	}

	INT iNumberOfTransaction=0;
	INT iMessageInTrans=0;
	map < wstring,wstring > map_ReceiveFromQueue;
	map_ReceiveFromQueue[L"FormatName"] = m_wcsDestQueueFormatName;
	map_ReceiveFromQueue[L"M_Label"] = xActViaCom::m_wcsGuidMessageLabel;
	StrManp pwcsMessgeBody(m_iMessageInTransaction); 
	do
	{
		map_ReceiveFromQueue[L"mBody"] = g_wcsEmptyString;
		map_ReceiveFromQueue[L"TransBaoundery"] = g_wcsEmptyString;
		
		rc = RetrieveMessageFromQueue ( map_ReceiveFromQueue );
		if( rc != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Message not found in the destination queue. (1)");
			return MSMQ_BVT_FAILED;
		}
	
		if( map_ReceiveFromQueue[L"TransBoundary"] == L"First")
		{
			iMessageInTrans=0;
		}
		pwcsMessgeBody.SetStr(map_ReceiveFromQueue[L"mBody"]);
		iMessageInTrans ++;
		if( g_bDebug )
		{
				wMqLog(L"Found message %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
		}	

		if( map_ReceiveFromQueue[L"TransBoundary"] == L"Last")
		{
		
			iNumberOfTransaction ++;
			if( iMessageInTrans != m_iMessageInTransaction )
			{
				wMqLog (L"xActViaCom::CheckResult Can't find the last message Found %d messages \n Sent %d messages \n", 
					iMessageInTrans , m_iMessageInTransaction );
				return MSMQ_BVT_FAILED;
			}
			if( *m_pSendBlock != pwcsMessgeBody )
			{
				wMqLog (L"Error message are not in expected order\n");
				return MSMQ_BVT_FAILED;
			}
			pwcsMessgeBody.Clear();
			map_ReceiveFromQueue[L"M_Label"]=xActViaCom::m_SeCTransactionGuid;
		}
		
	} while ( iNumberOfTransaction != m_ixActIndex );

	if( rc != MSMQ_BVT_SUCC )
	{
		MqLog("Message not found in the destination queue. (1)\n");
		return MSMQ_BVT_FAILED;
	}

	if ( g_bDebug )
	{	
		wcout<<L"xActViaCom::CheckResult - message found in the queue" <<endl;
	}
	return MSMQ_BVT_SUCC;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secall.h ===
//
// file:  secall.h
//
// definitions which are common to all executables.
//

//
// Size definitions
//
#define PIPE_BUFFER_LEN  8192

//------------------------------------
//
// BSTRING auto-free wrapper class
//
//------------------------------------

class BS
{
public:
    BS()
    {
        m_bstr = NULL;
    };

    BS(LPCWSTR pwszStr)
    {
        m_bstr = SysAllocString(pwszStr);
    };

    BS(LPWSTR pwszStr)
    {
        m_bstr = SysAllocString(pwszStr);
    };

    BSTR detach()
    {
        BSTR p = m_bstr;
        m_bstr = 0;
        return p;
    };

    ~BS()
    {
        if (m_bstr)
        {
            SysFreeString(m_bstr);
        }
    };

public:
    BS & operator =(LPCWSTR pwszStr)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(LPWSTR pwszStr)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(BS bs)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(LPWSTR(bs));
        return *this;
    };

    operator LPWSTR()
    {
        return m_bstr;
    };

    BOOL Empty()
    {
        return (m_bstr==NULL);
    };

private:
    BSTR  m_bstr;
};

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//-----------------------------
//
//  Auto delete pointer
//
template<class T>
class P {
private:
    T* m_p;

public:
    P() : m_p(0)            {}
    P(T* p) : m_p(p)        {}
   ~P()                     { delete m_p; }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    P<T>& operator=(T* p)   { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//-----------------------------
//
//  Auto relese pointer
//
template<class T>
class R {
private:
    T* m_p;

public:
    R() : m_p(0)            {}
    R(T* p) : m_p(p)        {}
   ~R()                     { if(m_p) m_p->Release(); }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    R<T>& operator=(T* p)   { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\seccli.h ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: seccli.h
//
//  AUTHOR: Craig Link
//          Doron Juster
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and
//  implement the ServiceStart() and ServiceStop() functions.
//
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "SecServC"

// internal name of the service.
// this name is used in the "net start" and "net stop" commands.
#define SZCLISERVICENAME        "AdsCliService"

// displayed name of the service
#define SZCLISERVICEDISPLAYNAME  TEXT("DoronJ ADSI Security Client Service")

// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

//
// Name of Pipe to be used.
//
#define PIPE_CLI_NAME  TEXT("\\\\.\\pipe\\SecCliService")

//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType = EVENTLOG_ERROR_TYPE) ;
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\util.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Util.cpp

Abstract:
	
	  Common function for msmq tests.
	  
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/


#include "msmqbvt.h"
#include "ntlog.h"
#include <iads.h>
#include <adshlp.h>

#pragma warning(disable:4786)
using namespace std;
const DWORD g_dwDefaultLogFlags = TLS_INFO | TLS_SEV1 | TLS_SEV2 | TLS_SEV3 | TLS_WARN | TLS_PASS | TLS_VARIATION | TLS_REFRESH | TLS_TEST;
extern P<cMqNTLog> pNTLogFile;

//-----------------------------------------------------------------------------------
// TimeOutThread - Kill the Test after time out period.
// This thread kill the test there is no need to return value from the tests.
//


DWORD __stdcall TimeOutThread(void * iTimeOut)
{	
	INT SleepTime = PtrToInt(iTimeOut);
    Sleep( SleepTime );
	MqLog("Test cancelled by time restriction after %d sec.\n", SleepTime );
    abort();  // Return error code = 3 
}



//------------------------------------------------------------------
// QueuesInfo::del_all_queue
// Delete all the in the list
//
// return value:
// pass - MSMQ_BVT_SUCC.
// fail - MSMQ_BVT_FAILED.
//


INT QueuesInfo::del_all_queue()
{
	std::list <my_Qinfo> :: iterator itQp;
	wstring wcsDeleteQueueFormatName;
	itQp = m_listofQueues.begin();
	while( itQp !=m_listofQueues.end())
	{
		wcsDeleteQueueFormatName  = itQp->GetQFormatName();
		if ( g_bDebug )
		{
			wcout << L"Delete queue pathname:" << itQp->GetQPathName() <<endl;
		}
		HRESULT rc = MQDeleteQueue( wcsDeleteQueueFormatName.c_str() );
		if ( rc != MQ_OK && rc != MQ_ERROR_QUEUE_NOT_FOUND )
			ErrHandle ( rc,MQ_OK,L"MQDelete queue failed");
		itQp ++ ;
	}

 return MSMQ_BVT_SUCC;
}
//------------------------------------------------------------------------------
// QueuesInfo::ReturnQueueProp 
// This function return specific prorperty form the queues list
//
// input parmeters:
// 
// return value:
//

wstring QueuesInfo::ReturnQueueProp( wstring wcsQLabel , int iValue  )
{
	
	BOOL bFound=FALSE;
	
	for ( list <my_Qinfo> :: iterator itQp = m_listofQueues.begin() ; itQp != m_listofQueues.end() ;	itQp ++ )
	{
		if (itQp->GetQLabelName() == wcsQLabel )
		{
			bFound=TRUE;
			break;
		}
	}

	if ( bFound && iValue == 1 )
	{
		return itQp->GetQFormatName();
	}
	else if ( bFound && iValue == 2 )
	{
		return itQp->GetQPathName();
	}
	//
	// Not found the return empty string 
	//
	return g_wcsEmptyString;
}



bool operator == (my_Qinfo objA, my_Qinfo objB )
{
	return  objA.wcsQpathName == objB.wcsQpathName  ? TRUE : FALSE;
}

bool operator != (my_Qinfo objA, my_Qinfo objB )
{
	return !( objA==objB);
}


//
// Declare the operator no current need to declare only because list ask that
// use for sort, is not relevant to queues parameters
//
 
bool operator < (my_Qinfo objA, my_Qinfo objB )
{
	return TRUE;
}

bool operator > (my_Qinfo objA, my_Qinfo objB )
{
	return ! (objA < objB);
}



int QueuesInfo::UpdateQueue (wstring wcsQPathName,wstring wcsQFormatName,wstring wcsQueueLabel)
{
	// Serech if this queue exist in the list
	list <my_Qinfo> :: iterator itp;
	bool bFound = FALSE ; 
	for (itp=m_listofQueues.begin ();itp != m_listofQueues.end () && ! bFound ; itp ++)
	{
		wstring wcsTempQname =(*itp).GetQPathName();
		if ( wcsTempQname == wcsQPathName )
			bFound = TRUE;
	}
	
	if (! bFound )
	{ // Update list queue not found in the list
		my_Qinfo Temp (wcsQPathName,wcsQFormatName,wcsQueueLabel);
		m_listofQueues.push_back(Temp);
	}
	
	 // Does not need to update Queue is exist in the 
	return MSMQ_BVT_SUCC; 
}

void QueuesInfo::dbg_printAllQueueProp ()
{
	std::list <my_Qinfo> ::iterator itp;
	for (itp= m_listofQueues.begin(); itp != m_listofQueues.end(); itp ++)
	{
		itp ->dbg_printQueueProp();
	}

}

my_Qinfo::my_Qinfo(const my_Qinfo & cObject):
wcsQpathName(cObject.wcsQpathName), wcsQFormatName(cObject.wcsQFormatName),wcsQLabel(cObject.wcsQLabel)
{}

my_Qinfo::my_Qinfo(std::wstring wcsPathName , std::wstring wcsFormatName , std::wstring wcsLabel ):
wcsQpathName(wcsPathName), wcsQFormatName(wcsFormatName),wcsQLabel(wcsLabel)
{}

void my_Qinfo::dbg_printQueueProp ()
{
	wcout<< L"PathL:" << wcsQpathName << L"\n" << L"FName:" << wcsQFormatName <<endl;
}

//----------------------------------------------------------------------
// Check if MQOA is registered use Idispatch interface for interface.
// If mqoa exist and not registered ( regsvr32 ) this function will failed
//


void isOARegistered::Description()
{
  MqLog("Thread %d : Check if MQOA is registered \n",m_testid);
}

HRESULT CheckIfMQOARegister()
/*++
	Function Description:
		function check if mqoa.dll is register on the machine by trying to get IDispInterface 
	Arguments:
		None.
	Return code:	
		HRESULT;  
--*/
{
	try
	{
		IDispatchPtr QueueInfoID( "MSMQ.MSMQQueueInfo");
		OLECHAR FAR* szMember = L"PathName";
		DISPID dispid = 0;
		return	QueueInfoID->GetIDsOfNames(IID_NULL,
										   &szMember,
										   1, 
										   LOCALE_SYSTEM_DEFAULT,
										   &dispid
										  );
	}
	catch(_com_error & comerr) 
	{
		return  comerr.Error();
	}
}
INT isOARegistered :: Start_test()
{
		 //
		 // In VB user can do those thinks.
		 // Dim x as Object
		 // x = new MSMQQueueInfo
		 // This is the IDispatch Interface 
		 // Check this interface exist ask the number of method example PathName
		 //
		SetThreadName(-1,"isOARegistered - Start_test ");			

		if ( g_bDebug )
		{
			MqLog ("Check Idispatch pointer for msmq com objects\n");
		}
		HRESULT hr = CheckIfMQOARegister();
		if ( hr != S_OK )
		{
			MqLog("Mqoa.dll is not registered !\n");
			return MSMQ_BVT_FAILED;
		}

	return MSMQ_BVT_SUCC;
}


//------------------------------------------------------------------------
// Log file class use to log tests information to file 
//
 


std::string GetLogDirectory()
/*++
	Function Description:
		GetLogDirectory - Retrive %windir%\debug path.
	Arguments:
		None
	Return code:
		Directory name.
--*/
{
	CHAR csSystemDir[MAX_PATH+1];
	UINT dwSysteDirBefferLen=MAX_PATH;
	string csLogPathName="";
	
	DWORD hr = GetSystemDirectory( csSystemDir,dwSysteDirBefferLen);
	if ( hr > 0 )
	{
		csLogPathName = csSystemDir;
		string csToken = "\\";
		size_t iPos = csLogPathName.find_last_of (csToken);	
		csLogPathName = csLogPathName.substr(0,iPos);
		csLogPathName +="\\Debug";
	}
	return csLogPathName;
}
	
Log::~Log()
{
		if(m_bCanWriteToFile)
		{
			CloseHandle( hLogFileHandle);
			DeleteCriticalSection( &CriticalSection );
		}
}

Log::Log( wstring wcsLogFileName ) : hLogFileHandle(NULL) 
{
	
		m_bCanWriteToFile = FALSE;
		
		// 
		// Retrive syetem directroy 
		//

		WCHAR wcsSystemDir[MAX_PATH+1];
		UINT dwSysteDirBefferLen=MAX_PATH;
		wstring wcsLogPathName;
		
		DWORD hr = GetSystemDirectoryW( wcsSystemDir,dwSysteDirBefferLen);
		if ( hr > 0 )
		{
			wcsLogPathName = wcsSystemDir;
			wstring wcsToken=L"\\";
			size_t iPos = wcsLogPathName.find_last_of (wcsToken);	
			wcsLogPathName = wcsLogPathName.substr(0,iPos);
			wcsLogPathName+=L"\\Debug";
		}
		
		
		// change drive to %widir%\debug\. 
		
		

		BOOL fSucc = SetCurrentDirectoryW(wcsLogPathName.c_str());
		
		if ( ! fSucc )
		{
			// Retrive the temp directory 
			WCHAR wcsEnvName[]=L"Temp";
			WCHAR wcsTempDir[MAX_PATH + 1];
			DWORD dwTempDirBufLen = MAX_PATH;
			GetEnvironmentVariableW( wcsEnvName, wcsTempDir , dwTempDirBufLen );
			wcsLogPathName=wcsTempDir;
			fSucc = SetCurrentDirectoryW( wcsLogPathName.c_str() );
			if ( ! fSucc )
			{
				MqLog("Mqbvt will create the log in the current directory\n");
			}
			
		}
		
		//
		// Create the log file 
		//
		
		// wstring wcsLogFileName = L"Mqbvt.log";
		
		hLogFileHandle = CreateFileW(wcsLogFileName.c_str(),GENERIC_WRITE,FILE_SHARE_READ,NULL,
			CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);

		if (hLogFileHandle != INVALID_HANDLE_VALUE )
		{
			//
			// CreateCritalSection 
			// 

			InitializeCriticalSection( &CriticalSection ); 
			m_bCanWriteToFile = TRUE;	

			//
			// Write to file tests title
			//

			wstring Title = L"Mqbvtlog file start at:";
			WriteToFile ( Title );
		}
		//
		// Else is not need because log file is optional.
		// 
		
		
}

Log::WriteToFile ( wstring wcsLine )
{
	if ( m_bCanWriteToFile ) 
	{
		EnterCriticalSection( &CriticalSection );
		string csLine;
		// Need to convert wstring to string ..
		csLine = My_WideTOmbString (wcsLine);
		
		DWORD dwWrittenSize = 0;
		char cNewline[]= { 0xD , 0xA , 0 };
		/*cNewline[1]=10;
		cNewline[2]=0; */
		WriteFile( hLogFileHandle , csLine.c_str() , (DWORD)(strlen(csLine.c_str())), &dwWrittenSize , NULL);
		WriteFile( hLogFileHandle , cNewline , (DWORD)(strlen (cNewline)) , &dwWrittenSize,NULL);
		FlushFileBuffers( hLogFileHandle ); 
		LeaveCriticalSection( &CriticalSection );
	}
	return MSMQ_BVT_SUCC;	
}



//#define MAXCOMMENT 200
void
MqLog(LPCSTR lpszFormat, ...)
{
    CHAR  szLogStr[MAXCOMMENT] = "";
    va_list  pArgs;
	int nCount = 0;
	wstring wcsTemp;

    va_start(pArgs, lpszFormat);
    nCount = _vsnprintf(szLogStr, MAXCOMMENT, lpszFormat, pArgs);
	szLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(szLogStr);
	}
	wcsTemp = My_mbToWideChar( szLogStr );
	pGlobalLog->WriteToFile( wcsTemp.c_str() );
	printf ("%s",szLogStr);

}


void
wMqLog(LPWSTR lpszFormat, ...)
{
    WCHAR  wszLogStr[MAXCOMMENT] = L"";
    va_list  pArgs;
	int nCount =0;
	
	std::string csTemp="";

    va_start(pArgs, lpszFormat);
    nCount = _vsnwprintf(wszLogStr, MAXCOMMENT, lpszFormat, pArgs);
	wszLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	pGlobalLog->WriteToFile( wszLogStr );
	csTemp = My_WideTOmbString(wszLogStr);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(csTemp);
	}
	wprintf (L"%s",wszLogStr);

}
/**************************************************************
	this code was copied from mpllib 
 **************************************************************/

cMqNTLog::cMqNTLog( const string & csFileName )
:m_NTLog(NULL),
 m_ptlEndVariation(NULL),
 m_pCreateLog_A(NULL),
 m_ptlLog_A(NULL),
 m_ptlReportStats(NULL),
 m_ptlAddParticipant(NULL),
 m_ptlDestroyLog(NULL)
 
/*++
	Function Description:
		cMqNTLog constructor load NT Log DLL and GetProcAddress
	Arguments:
		csFileName file name
	Return code:
		throw INIT_ERROR when failed

--*/
{
	
	//
	// Load NTLOG.DLL
	//
	m_NTLog = new AutoFreeLib("NTLog.dll");
	if( m_NTLog == NULL )
	{
		throw INIT_Error("MqBVT: Failed to initilize NTLOG.DLL !\n BVT will continue to run and log to stdout");
	}
	//
	// Init function pointers
	//

	m_pCreateLog_A =(tlCreateLog_A) GetProcAddress( m_NTLog->GetHandle() ,"tlCreateLog_A");
	m_ptlAddParticipant = (tlAddParticipant) GetProcAddress(m_NTLog->GetHandle() ,"tlAddParticipant");
	m_ptlEndVariation = (tlEndVariation) GetProcAddress(m_NTLog->GetHandle() ,"tlEndVariation");
	m_ptlLog_A = (tlLog_A) GetProcAddress(m_NTLog->GetHandle() ,"tlLog_A");
	m_ptlReportStats = (tlReportStats)GetProcAddress(m_NTLog->GetHandle() ,"tlReportStats");
	m_ptlStartVariation = (tlStartVariation)GetProcAddress(m_NTLog->GetHandle() ,"tlStartVariation");
	m_ptlDestroyLog=(tlDestroyLog)GetProcAddress(m_NTLog->GetHandle() ,"tlDestroyLog");
	
	if( !( m_pCreateLog_A && m_ptlAddParticipant && m_ptlEndVariation && m_ptlLog_A && 
		   m_ptlReportStats &&	m_ptlStartVariation && m_ptlDestroyLog ) )
	{
		throw INIT_Error("MqBVT: Failed to initilize NTLOG.DLL !\n BVT will continue to run and log to stdout");
	}
	
	if ( !CreateLog(const_cast<char*> (csFileName.c_str())) )
	{
		throw INIT_Error("Mqbvt:Can't create new log file\n");
	}
	Info("%s", GetCommandLineA());	
	BeginCase("run Mqbvt ");

}


BOOL
cMqNTLog::BeginCase( char* szVariation )
/*++
	Function Description:
		Begin NTLog case
	Arguments:
		szVariation - Case name
	Return code:
		TRUE/FALSE
--*/

{
       
    if( m_ptlStartVariation( m_hLog ) )
    {
		m_szVariation = szVariation;
        return TRUE;
    }
    return FALSE;
}




BOOL
cMqNTLog::EndCase( )
/*++
	Function Description:
		Close NTLog case test
	Arguments:
		None
	Return code:
		TRUE/FALSE
--*/

{
    DWORD dwVariation;
    BOOL fResult;

    dwVariation = m_ptlEndVariation( m_hLog );

    fResult = m_ptlLog_A(
							m_hLog,
							dwVariation | TL_VARIATION,
							"End variation %s",
							m_szVariation
							);

    return fResult;
}

BOOL cMqNTLog::CreateLog( char *szLogFile )
/*++
	Function Description:
		Create Log file in NTLog format
	Arguments:
		szLogFile - log file name.
	Return code:
		True/false
--*/

{

    int nMachineId = 33; // BUGBUG - should be calculated
    m_hLog = m_pCreateLog_A( szLogFile, g_dwDefaultLogFlags );
    if( m_hLog == NULL )
	{
        return FALSE;
	}
	return m_ptlAddParticipant( m_hLog, NULL, nMachineId );
}


#define LOGFUNC(name,dw)                                        \
BOOL __cdecl cMqNTLog::name( char* fmt, ... ) {                 \
    BOOL fResult;                                               \
    va_list arglist;                                            \
                                                                \
    va_start( arglist, fmt );                                   \
    fResult = VLog( dw | TLS_VARIATION, fmt, arglist );         \
    va_end( arglist );                                          \
    return fResult;                                             \
}

char g_String[ MAXCOMMENT + 1  ];
static char* l_szSource = "n/a";
BOOL
cMqNTLog::VLog( DWORD dwFlags, char* fmt, va_list arglist )
/*++
	Function Description:

	Arguments:
		
	Return code:
		TRUE/FALSE

--*/

{

    
	_vsnprintf( g_String, MAXCOMMENT ,fmt, arglist );
	g_String[MAXCOMMENT-1] = 0;
    return m_ptlLog_A(
						m_hLog,
						dwFlags, 
						l_szSource,
						0,
						"%s",
						g_String
					  );
}

void
cMqNTLog::Report( )
/*++
	Function Description:
		Report 
	Arguments:
		None
	Return code:

--*/
{
    m_ptlReportStats( m_hLog );
}



LOGFUNC(Info,TLS_INFO)
LOGFUNC(Warn,TLS_WARN)
LOGFUNC(Sev1,TLS_SEV1)
LOGFUNC(Pass,TLS_PASS)



void cMqNTLog::LogIt( const std::string & csLine )
/*++
	Function Description:
		print a LogIt to the file
	Arguments:
		None
	Return code:

--*/

{
	Info("%s",csLine.c_str());
}
cMqNTLog::~cMqNTLog () 
/*++
	Function Description:

	Arguments:
		None
	Return code:

--*/

{
	EndCase();
	Report();
	m_ptlDestroyLog(m_hLog);
} 

void cMqNTLog::ReportResult(bool bRes ,CHAR * pcsString )
/*++
	Function Description:
		ReportResult - Report if Mqbvt pass or failed
	Arguments:
		None
	Return code:

--*/
{
	if( pNTLogFile )
	{
		if ( bRes )
		{
			Pass(pcsString);
		}
		else
		{
			Sev1(pcsString);
		}
	}
}



typedef struct tagTHREADNAME_INFO
{
	DWORD dwType;
	LPCSTR szName;
	DWORD dwThreadId;
	DWORD dwFlags;
} THREADNAME_INFO;

void SetThreadName ( int dwThreadId , LPCSTR szThreadName )
/*++
	Function Description:
		SetThreadName - 
		Report the Thread name to the debugger
		This exception si undocumented.
	Arguments:
		None
	Return code:

--*/
{
#ifndef _WIN64
	THREADNAME_INFO info;
	info.dwType = 0x1000;
	info.szName = szThreadName;
	info.dwThreadId = dwThreadId;
	info.dwFlags = 0;
	__try
	{	

		RaiseException( 0x406d1388 , 0 , sizeof(info) / sizeof (DWORD) ,(DWORD*) &info);
	}
	__except(EXCEPTION_CONTINUE_EXECUTION)
	{

	}
#else
	THREADNAME_INFO info;
	UNREFERENCED_PARAMETER(info);
	UNREFERENCED_PARAMETER(dwThreadId);
	UNREFERENCED_PARAMETER(szThreadName);
#endif
}


std::wstring CreateHTTPFormatNameFromPathName(const std::wstring & wcsPathName, bool bHTTPS )
/*++	  

	Function Description:

	  CreateHTTPFormatNameFromPathName convert queue path name to HTTP direct direct format name

	Arguments:

		 wcsPathName - Queue PathName
		 bool HTTPS - true return direct=hTTPS://
	Return code:

		wstring contain a queue format name or an empty string if there is an error during parsing
	
--*/

{
	
	//
	// Build DIRECT=HTTP://MachineName\MsMq\QueuePath from Path Name
	//

	std::wstring wcsMachineName = wcsPathName;
	size_t iPos = wcsMachineName.find_first_of(L"\\");
	if(iPos == -1)
	{
		return g_wcsEmptyString;
	}
	wcsMachineName = wcsMachineName.substr(0,iPos);
	std::wstring wcsHTTPFormatName = bHTTPS ?  L"DIRECT=hTTpS://":L"DIRECT=hTTp://";
	wcsHTTPFormatName += wcsMachineName;
	wcsHTTPFormatName += (std::wstring)L"/mSmQ/";
	wcsHTTPFormatName += (std::wstring) wcsPathName.substr(iPos+1,wcsPathName.length());
	return wcsHTTPFormatName;
}




HRESULT GetSpecificAttribute(
						  CONST WCHAR * pwcsDsPath,
						  WCHAR * pwcsAttributeName,
						  VARIANT * val
						)
/*++

	Function Description:
		Return attribute of specific DN.
	Arguments:
		None
	Return code:
		None

	
--*/
{

	IADs *pObject=NULL; 

	HRESULT hr = ADsGetObject(pwcsDsPath, IID_IADs, (void**)&pObject);
	if(FAILED(hr))
	{
		return hr;
	}
	hr = pObject->Get(pwcsAttributeName,val);
	pObject->Release();
 	if (FAILED(hr)) 
	{
		val->vt=VT_EMPTY;
	}
	return hr;
}


long GetADSchemaVersion()
{
    IADs * pRoot = NULL;
    HRESULT hr=ADsGetObject( L"LDAP://RootDSE",
							 IID_IADs,
							 (void**) &pRoot
						   );
    if(FAILED(hr)) 
	{ 
		return 0;
	}
	
	VARIANT varDSRoot;
	hr = pRoot->Get(L"schemaNamingContext",&varDSRoot);
	pRoot->Release();
	if ( FAILED(hr))
	{
		return 0;
	}
	wstring m_wcsCurrentDomainName = L"LDAP://";
	m_wcsCurrentDomainName += varDSRoot.bstrVal;
	VariantClear(&varDSRoot);
	GetSpecificAttribute(m_wcsCurrentDomainName.c_str(),L"ObjectVersion",&varDSRoot);
	long dwSchemaVersion = varDSRoot.lVal;
	VariantClear(&varDSRoot);
	return dwSchemaVersion;
}



std::wstring ToLower(std::wstring wcsLowwer)
{

	WCHAR * wcsLocalMachineName = (WCHAR * )malloc (sizeof(WCHAR) * (wcsLowwer.length() + 1 ));
	if( ! wcsLocalMachineName )
	{
		MqLog("Thread 4: Failed to allocate memory\n");
		throw INIT_Error("Thread 4 - failed to allocate memory");
	}
	const WCHAR * p = wcsLowwer.c_str();
	int i=0;
	while( *p )
	{	
		wcsLocalMachineName[i++] = towlower( *p );
		p++;
	}
	
	wcsLocalMachineName[i]=L'\0';
	wstring temp=wcsLocalMachineName;
	free(wcsLocalMachineName);
	return temp;
}


int iDetactEmbededConfiguration ()
/*++
	Function Description:
		Deteact embeded components.
	Arguments:
		None
	Return code:
		int
--*/
{
	if ( CheckIfMQOARegister() == S_OK )
	{
		return COM_API;
	}
	return C_API_ONLY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\xact.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: xact.cpp

Abstract:
	
	  
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/



#include "msmqbvt.h"
#define INITGUID

// 
// Define DtcGetTransactionManagerEx 
// 

typedef     ( * my_DtcGetTransactionManagerEx)(
									/* in */ char * i_pszHost,
									/* in */ char * i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);


// 
// This number define the number of transaction in the test
//

const int ciNumberTransaction=5;

using namespace std;

void cTrans::Description ()
{
	wMqLog(L"Thread %d : Send transacted messages using DTC to local machine\n", m_testid);
}


#define NofQueueProp (9)
//
// Create Transactional Queue 
//

cTrans::cTrans (INT index , std::map < std :: wstring , std:: wstring > Tparms ,bool bTemp) :cTest (index),
 cOrderTransaction(bTemp),m_pSendBlock(NULL),m_ciNumberOfMessages(5)
{	
	m_wcsFormatNameBufferQ1 = Tparms[L"DestQFormatName1"];
	m_wcsFormatNameBufferQ2 = Tparms[L"DestQFormatName2"];
	m_bRunOnDependetClient=FALSE;
	if ( Tparms[L"DepClient"] == L"true")
		m_bRunOnDependetClient=TRUE;

	m_pSendBlock= new StrManp( ciNumberTransaction,L"TRANSACTION" );
	if( !m_pSendBlock )
	{
			MqLog("cTrans::Start_test Failed to allocate memory for StrManp \n");
			throw INIT_Error("cTrans::Start_test Failed to allocate memory for StrManp \n");
	}
}

cTrans::~cTrans()
{
	delete m_pSendBlock;
}

//
// Send Transacation messgaes to the queue
//

#define NofMessageProp (10)
INT cTrans::Start_test()
{

	SetThreadName(-1,"cTrans - Start_test ");			
	HRESULT rc;
	MSGPROPID aMsgPropId[NofMessageProp]={0};
	MQPROPVARIANT aMsgPropVar[NofMessageProp]={0};
	HRESULT aMsgStatus[NofMessageProp]={0};
	MQMSGPROPS MsgProps={0};
	DWORD dCountMProps=0;

	ITransaction *pXact=NULL;
	HANDLE WriteHandle,hReadHandle;
		
	rc = MQOpenQueue( m_wcsFormatNameBufferQ1.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &WriteHandle );
	ErrHandle( rc , MQ_OK , L"MQopenQueue failed with error" );
	if ( g_bDebug )
	{
		MqLog("xact.cpp Succeeded to open queue1 \n");
	}

	
	aMsgPropId[dCountMProps] = PROPID_M_LABEL;            //PropId
	aMsgPropVar[dCountMProps].vt = VT_LPWSTR;             //Type
	aMsgPropVar[dCountMProps].pwszVal =(USHORT * ) m_wcsGuidMessageLabel.c_str(); // send with guid label
	dCountMProps++;    	

	DWORD dM_BodyIndex=dCountMProps;
	aMsgPropId[dCountMProps] = PROPID_M_BODY;             //PropId
	aMsgPropVar[dCountMProps].vt = VT_VECTOR | VT_UI1;
	dCountMProps++;

	aMsgPropId[dCountMProps] = PROPID_M_TIME_TO_BE_RECEIVED; 
	aMsgPropVar[dCountMProps].vt = VT_UI4;
	aMsgPropVar[dCountMProps].ulVal = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	dCountMProps++;

	
    	
	//Set the MQMSGPROPS structure.
	MsgProps.cProp = dCountMProps;       //Number of properties.
	MsgProps.aPropID = aMsgPropId;      //Id of properties.
	MsgProps.aPropVar= aMsgPropVar;    //Value of properties.
	MsgProps.aStatus = aMsgStatus;     //Error report.
	
	rc = cOrderTransaction.xDTCBeginTransaction(&pXact); // begin DTC transaction
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction failed, Check MSDTC service\n");
		return MSMQ_BVT_FAILED;
	}
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp Succeeded to order transaction \n");
	}
	for (int index = 0; index < m_ciNumberOfMessages ;index ++)  
	{
			WCHAR wcsTempstring[100];
			wstring wcsTemp=m_pSendBlock->GetStr(index);
			wcscpy(wcsTempstring,wcsTemp.c_str());
			aMsgPropVar[dM_BodyIndex].caub.pElems =(UCHAR *)wcsTempstring;
			aMsgPropVar[dM_BodyIndex].caub.cElems = ((ULONG)(wcslen((WCHAR *) wcsTempstring)) + 1) * sizeof(WCHAR);
			rc= MQSendMessage(WriteHandle, &MsgProps,pXact);
			ErrHandle( rc , MQ_OK , L"MQSendMessage failed during send transactional messages:" );

	}	
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp finish to send transactions \n");
	}
	
	rc=MQCloseQueue(WriteHandle);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue close queue" );
	rc = pXact->Commit(0,0,0);
	pXact->Release();
	
	wcscpy (m_wcsTempBuf,L"Eitan");
	aMsgPropVar[dM_BodyIndex].caub.pElems = (UCHAR * )m_wcsTempBuf;
	aMsgPropVar[dM_BodyIndex].caub.cElems = sizeof (m_wcsTempBuf);
	
	HANDLE hQ2Send;
	rc=cOrderTransaction.xDTCBeginTransaction(&pXact ); // begin DTC transaction
	
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction (2) failed\n");
		return MSMQ_BVT_FAILED;
	}

	rc= MQOpenQueue(m_wcsFormatNameBufferQ2.c_str(),MQ_SEND_ACCESS,MQ_DENY_NONE,&hQ2Send);
	
	ErrHandle( rc , MQ_OK , L"MQOpenQueue failed");	
	
	rc= MQSendMessage(hQ2Send, &MsgProps,pXact);
	ErrHandle( rc , MQ_OK , L"MQSendMessage failed");	
	
	rc = pXact->Commit(0,0,0);
	pXact->Release();
	
	rc=MQCloseQueue(hQ2Send);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp finish to send to the other queue \n");
	}
	
	WCHAR Label[MQ_MAX_Q_LABEL_LEN+1]; 
	cPropVar Rprop(4);
	Rprop.AddProp(PROPID_M_LABEL,VT_LPWSTR,Label,MQ_MAX_Q_LABEL_LEN );
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );

	
	rc= MQOpenQueue(m_wcsFormatNameBufferQ2.c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE,&hReadHandle);
	
	ErrHandle( rc , MQ_OK , L"MQOpenQueue failed");	

	rc=cOrderTransaction.xDTCBeginTransaction(&pXact ); // begin DTC transaction

	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction (2) failed\n");
		return MSMQ_BVT_FAILED;
	}

	rc=MQReceiveMessage( hReadHandle , 3000, MQ_ACTION_RECEIVE ,Rprop.GetMSGPRops(),NULL,NULL,NULL, pXact );
	ErrHandle( rc , MQ_OK , L"MQReceiveMessgaes failed during receive using transaction");	

	pXact->Abort(0,0,0);
		
	// Bug bug in the Relase Operation need to preform release
	// and try catch for the error

	//pXact->Release () ;


	
 
	HANDLE hCursor;
	rc=MQCreateCursor(hReadHandle ,& hCursor);
	
	ErrHandle( rc , MQ_OK , L"MQCreateCursor failed");	
	//
	// Need to prefrom Peek until find the current message 
	// 
	BOOL bMessageNotFound = false;
	DWORD dwAction = MQ_ACTION_PEEK_CURRENT;
	do 
	{
		Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
		
		rc=MQReceiveMessage( hReadHandle , 3000, dwAction ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
		ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to search message in the queue ");	

		if( dwAction == MQ_ACTION_PEEK_CURRENT )
		{
			dwAction = MQ_ACTION_PEEK_NEXT;
		}
		if ( ! wcscmp( Label, m_wcsGuidMessageLabel.c_str()) )
		{
			bMessageNotFound = TRUE;
		}
	
	} while( rc !=  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound );

	if( rc ==  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound )
	{
		MqLog("Erorr while trying to find the message in the queue\n");
		return MSMQ_BVT_FAILED;
	}
	

	rc=MQCloseQueue(hReadHandle);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");	
		
	return MSMQ_BVT_SUCC;
}


INT cTrans::CheckResult()
{

	
	ITransaction *pXact = NULL;
	HANDLE hCursor = NULL; 
	QUEUEHANDLE hRecQueue = NULL;
	HRESULT rc = MQOpenQueue(m_wcsFormatNameBufferQ1.c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hRecQueue);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");	
	
		

	rc = MQCreateCursor( hRecQueue,&hCursor );
	ErrHandle( rc , MQ_OK , L"MQCreateCursor failed");	

/*	MQMSGPROPS MsgProps;
	MQPROPVARIANT aVariant[10];
	MSGPROPID aMessPropId[10];
	DWORD dwPropIdCount = 0;
	WCHAR wcsMsgBody[20];

	//DWORD dwAppspecificIndex;
	
	// Set the PROPID_M_BODY property.
	aMessPropId[dwPropIdCount] = PROPID_M_BODY;               //PropId
	aVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;        //Type
	aVariant[dwPropIdCount].caub.cElems = 20 * sizeof(WCHAR);   //Value
	aVariant[dwPropIdCount].caub.pElems = (UCHAR *)wcsMsgBody;
	dwPropIdCount++;
	

	/// BUG BUG need to check Why i need this code pass !!!

	//Set the PROPID_M_APPSPECIFIC property.

	//Set the MQMSGPROPS structure.
	MsgProps.cProp = dwPropIdCount;       //Number of properties.
	MsgProps.aPropID = aMessPropId;         //Ids of properties.
	MsgProps.aPropVar = aVariant;       //Values of properties.
	MsgProps.aStatus  = NULL;           //No Error report.


*/
	cPropVar Rprop(4);	
	//
	// Body and label are equel.
	//
	WCHAR wcsBody[MQ_MAX_Q_LABEL_LEN + 1 ]={0},Label[MQ_MAX_Q_LABEL_LEN+1 ]={0};

	Rprop.AddProp(PROPID_M_BODY,VT_UI1|VT_VECTOR,wcsBody,MQ_MAX_Q_LABEL_LEN);
	Rprop.AddProp(PROPID_M_LABEL,VT_LPWSTR,Label,MQ_MAX_Q_LABEL_LEN);
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );


	StrManp pwcsMessgeBody(ciNumberTransaction-1);    
	
	rc = cOrderTransaction.xDTCBeginTransaction( &pXact );
	
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction failed, Check MSDTC service\n");
		return MSMQ_BVT_FAILED;
	}


	//might be bugbug DWORD dwAction = MQ_ACTION_RECEIVE;  //Peek at first msg.

	for (int index=0;index < m_ciNumberOfMessages;index++) 
	{

		BOOL bMessageNotFound = FALSE;
		DWORD dwAction = MQ_ACTION_PEEK_CURRENT;


		do 
		{
			Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
			rc = MQReceiveMessage( hRecQueue , 3000, dwAction ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
			ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to peek the messgaes ");	
			dwAction = MQ_ACTION_PEEK_NEXT;
			
			if (rc != MQ_OK) 	
			{
				MqLog("MQReceiveMessage failed when trying to receive message from transactional queue 0x%x\n",rc);
				return MSMQ_BVT_FAILED;
			}	
		
			if ( ! wcscmp( Label, m_wcsGuidMessageLabel.c_str()) )
			{
				bMessageNotFound = TRUE;
				rc=MQReceiveMessage( hRecQueue , 3000, MQ_ACTION_PEEK_CURRENT ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
				ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to receive the message");	
			}
		}	
		while (rc !=  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound );

		if (rc ==  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound )
		{
			MqLog ("Erorr while trying to find the message in the queue\n");
			return MSMQ_BVT_FAILED;
		}
		
			
		pwcsMessgeBody.SetStr(wcsBody);

	}
	//
	// BUGBug Need to check the recive messgaes
	// release the comoboject 

	rc = pXact->Commit(0,0,0);    
	ErrHandle( rc , MQ_OK , L"Commit failed");	
	rc = MQCloseCursor( hCursor);
	ErrHandle( rc , MQ_OK , L"MQCloseCursor failed ");	
	
	rc= MQCloseQueue(hRecQueue);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");
	return	(*m_pSendBlock==pwcsMessgeBody);
 
}


OrderTransaction::~OrderTransaction()
{
	g_pDispenser->Release();
	FreeLibrary (m_hxolehlp);
}


OrderTransaction::OrderTransaction( bool bUseExVersion )
:g_pDispenser(NULL)
{

	HRESULT hr=MQ_OK;

	if(! bUseExVersion )
	{
		hr = DtcGetTransactionManager ( 
												NULL,						//Host Name
												NULL,						//TmName
												IID_ITransactionDispenser,
												0,							//reserved
												0,							//reserved
												0,							//reserved
												(LPVOID*)&g_pDispenser
												);
		if (hr != S_OK)
		{
			MqLog ("DtcGetTransactionManager Failed with Error %x\n Please check MSDTC service\n",hr);
			throw INIT_Error("DtcGetTransactionManager Failed");
		}
	}
	else
	{
		m_hxolehlp=LoadLibrary("xolehlp.dll"); 
 		
		if ( ! m_hxolehlp )
		{
			MqLog ("Error can't load X0lehlp.dll to memory\n");
		}

		my_DtcGetTransactionManagerEx My_DTCBeginTransEx=NULL;
		My_DTCBeginTransEx = (my_DtcGetTransactionManagerEx) GetProcAddress( m_hxolehlp , "DtcGetTransactionManagerEx");
		if( My_DTCBeginTransEx == NULL )
		{
			MqLog ("Error can't get DtcGetTransactionManagerEx pointer from xolehlp.dll\n");
			throw INIT_Error("DtcGetTransactionManager Failed");
		}

		hr = My_DTCBeginTransEx( 
						NULL,						//Host Name
						NULL,						//TmName
						IID_ITransactionDispenser,
						0,							//reserved
						0,							//reserved
						(LPVOID*)&g_pDispenser
						);
	
	}

	if (hr != S_OK)
	{
			MqLog ("DtcGetTransactionManager Failed with Error %x\nPlease check MSDTC service\n",hr);
			throw INIT_Error("DtcGetTransactionManager Failed");
	}
	
	
	//
	// bugbug neet to release the pointer
	//
}

INT OrderTransaction::xDTCBeginTransaction(ITransaction ** ppXact )
{

	try
	{
		return g_pDispenser->BeginTransaction (
											   NULL,                       // IUnknown __RPC_FAR *punkOuter,
											   ISOLATIONLEVEL_ISOLATED,    // ISOLEVEL isoLevel,
											   ISOFLAG_RETAIN_DONTCARE,    // ULONG isoFlags,
											   NULL,                       // ITransactionOptions *pOptions
											   ppXact
											   );
	}
	catch ( ... )
	{
		MqLog ("BeginTransaction Failed Please check the MSDTC service\n");
		return MSMQ_BVT_FAILED;		
	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secrpc.h ===
//
// file: secrpc.h
//
//  Common definitions for the rpc part of this test.
//
#include "secsif.h"

typedef unsigned char * LPUSTR ;

#define PROTOSEQ_TCP_A  ((LPUSTR) "ncacn_ip_tcp")
#define PROTOSEQ_TCP_W  (L"ncacn_ip_tcp")
#define ENDPOINT_TCP_A  ((LPUSTR) "4010")
#define ENDPOINT_TCP_W  (L"4010")
#define OPTIONS_TCP_A   ((LPUSTR) "")
#define OPTIONS_TCP_W   (L"")

#define PROTOSEQ_LOCAL_A   ((LPUSTR) "ncalrpc")
#define PROTOSEQ_LOCAL_W   (L"ncalrpc")
#define ENDPOINT_LOCAL_A   ((LPUSTR) "MyLocalTestEP")
#define ENDPOINT_LOCAL_W   (L"MyLocalTestEP")
#define OPTIONS_LOCAL_A    ((LPUSTR) "Security=Impersonation Dynamic True")
#define OPTIONS_LOCAL_W    (L"Security=Impersonation Dynamic True")


RPC_STATUS  PerformADSITestQueryA( unsigned char  aszProtocol[],
                                   unsigned char  aszEndpoint[],
                                   unsigned char  aszOptions[],
                                   unsigned char  aszServerName[],
                                   ULONG          ulAuthnService,
                                   ULONG          ulAuthnLevel,
                                   unsigned char  *pszSearchFilter,
                                   unsigned char  *pszSearchRoot,
                                   BOOL           fWithCredentials,
                                   unsigned char  *pszUserName,
                                   unsigned char  *pszUserPwd,
                                   BOOL           fWithSecuredAuthentication,
                                   BOOL           fImpersonate,
                                   BOOL           fAlwaysIDO,
                                   DWORD          seInfo,
                                   char           **ppBuf,
                                   BOOL           fService = FALSE ) ;

RPC_STATUS  PerformADSITestCreateA( unsigned char  aszProtocol[],
                                    unsigned char  aszEndpoint[],
                                    unsigned char  aszOptions[],
                                    unsigned char  aszServerName[],
                                    ULONG          ulAuthnService,
                                    ULONG          ulAuthnLevel,
                                    unsigned char  *pszFirstPath,
                                    unsigned char  *pszObjectName,
                                    unsigned char  *pszObjectClass,
                                    unsigned char  *pszContainer,
                                    BOOL           fWithCredentials,
                                    unsigned char  *pszUserName,
                                    unsigned char  *pszUserPwd,
                                    BOOL           fWithSecuredAuthentication,
                                    BOOL           fImpersonate,
                                    char           **ppBuf,
                                    BOOL           fService = FALSE );


#ifdef UNICODE
#define PROTOSEQ_TCP    PROTOSEQ_TCP_W
#define ENDPOINT_TCP    ENDPOINT_TCP_W
#define OPTIONS_TCP     OPTIONS_TCP_W
#else
#define PerformADSITestQuery  PerformADSITestQueryA
#define PerformADSITestCreate PerformADSITestCreateA

#define PROTOSEQ_TCP          PROTOSEQ_TCP_A
#define ENDPOINT_TCP          ENDPOINT_TCP_A
#define OPTIONS_TCP           OPTIONS_TCP_A

#define PROTOSEQ_LOCAL        PROTOSEQ_LOCAL_A
#define ENDPOINT_LOCAL        ENDPOINT_LOCAL_A
#define OPTIONS_LOCAL         OPTIONS_LOCAL_A
#endif

//---------------------------------
//
//  Definitions for debugging
//
//---------------------------------

#ifdef _DEBUG
#define DBG_PRINT_ERROR(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_WARN(x)   _tprintf x ; printf("\n") ;
#define DBG_PRINT_TRACE(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_INFO(x)   _tprintf x ; printf("\n") ;
#else
#define DBG_PRINT_ERROR(x)
#define DBG_PRINT_WARN(x)
#define DBG_PRINT_TRACE(x)
#define DBG_PRINT_INFO(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\mqbvt\xtofn.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: xTofn.cpp

Abstract:

  Contain xxxToFormatName & MQMachineName information		

Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
#include "mqdlrt.h"
using namespace std;

extern BOOL g_bRunOnWhistler;
extern BOOL g_bRemoteWorkgroup ;

void MachineName::Description()
{
	wMqLog(L"Thread %d : Get machine prop\n", m_testid);
	
}

//
// bugbug MachineName - not supported in workgroup installation need to check it.
//

// -------------------------------------------------------------------------
// MachineName:: MachineName
// Constructor retrive the local & remote machine name.
// Need to decide if use full dns Yes / No.


MachineName:: MachineName(int iTestIndex , map < wstring , wstring > Tparmes )
: cTest(iTestIndex)
{

	wcsLocalMachineName = Tparmes [L"LMachine"] ;
	wcsLocalMachineFullDns = Tparmes [L"LMachineFDNS"];
	wcsRemoteMachine = Tparmes [L"RMachine"];
	wcsRemoteMachineFullDns = Tparmes [L"RMachineFDNS"];
	m_bWorkWithFullDNSName = TRUE;
	if( Tparmes[L"MSMQ1Limit"] == L"true" )
	{
		m_bWorkWithFullDNSName = FALSE;
	}
}

// ----------------------------------------------------------------
// MachineName::Start_test
// retrive machine name for queue.
//
int MachineName::Start_test()
{

	SetThreadName(-1,"MachineName - Start_test ");			
    GUID guidMachineId;
	const int iNumberOfPropId = 4;
	QMPROPID QMPropId[iNumberOfPropId];
	MQPROPVARIANT QMPropVar[iNumberOfPropId];
	HRESULT hResult[iNumberOfPropId]={NULL};
	MQQMPROPS QMProps = {iNumberOfPropId,QMPropId,QMPropVar,hResult};
	HRESULT rc = MQ_OK;
	wstring lpMachineName=L"";
	for( int i = 0 ; i < 2 ; i++)
	{
		if (i == 0)
		{
			 lpMachineName = wcsLocalMachineName;
		}
		else
		{
		 	 lpMachineName = wcsRemoteMachine;
		}
		int iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_SITE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = new GUID;
		iIndex ++ ;
		
		GUID MachineIDGuid;
		QMPropId[iIndex] = PROPID_QM_MACHINE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = &MachineIDGuid;
		iIndex ++ ;
		
		QMPropId[iIndex] = PROPID_QM_SITE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = new GUID;
		iIndex ++ ;

		QMPropId[iIndex] = PROPID_QM_PATHNAME;
		QMPropVar[iIndex].vt = VT_LPWSTR;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++ ;
		
		QMProps.cProp = iIndex;
		if( g_bDebug )
		{
			wMqLog(L"Call->MQGetMachineProperties and with 4 params PROPID_QM_SITE_ID,PROPID_QM_MACHINE_ID,PROPID_QM_SITE_ID,PROPID_QM_PATHNAME\n");
			wMqLog(L"Expected result is MQ_INFORMATION_PROPERTY because asked twice for PROPID_QM_SITE_ID\n");
		}
		rc = MQGetMachineProperties(lpMachineName.c_str(), NULL, &QMProps);
		ErrHandle(rc,MQ_INFORMATION_PROPERTY,L"MQGetMachineProperties(1)");
		//
		// Verify parameters
		//
		if( QMProps.aPropVar[3].vt != VT_NULL && _wcsicmp(lpMachineName.c_str(),QMProps.aPropVar[3].pwszVal) != 0 )
		{
			MqLog("MQGetMachineProperties failed to retrive the PROPID_QM_PATHNAME\nFound %s,Expected %s",
				   QMProps.aPropVar[3].pwszVal,lpMachineName);
			return MSMQ_BVT_FAILED;
		}
		//
		// Release params.
		// 
		ErrHandle(QMProps.aPropVar[3].vt,VT_LPWSTR,L"MQGetMachineProperties failed to retrieve the PROPID_QM_PATHNAME");
		MQFreeMemory(QMPropVar[3].pwszVal);
		delete QMPropVar[2].puuid;
		delete QMPropVar[0].puuid;
		iIndex = 0;

		QMPropId[iIndex] = PROPID_QM_BASE;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		
		QMPropId[iIndex] = PROPID_QM_PATHNAME;
		QMPropVar[iIndex].vt = VT_LPWSTR;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMProps.cProp = iIndex;
		if( g_bDebug )
		{
			MqLog("Call-> MQGetMachineProperties with PROPID_QM_BASE that is an invalid property\n");
		}
		rc = MQGetMachineProperties(NULL, &MachineIDGuid, &QMProps);
		ErrHandle(rc,MQ_INFORMATION_PROPERTY,L"MQGetMachineProperties (2)");
		ErrHandle(QMProps.aPropVar[1].vt,VT_LPWSTR,L"MQGetMachineProperties failed to retrieve the PROPID_QM_PATHNAME");
		MQFreeMemory(QMPropVar[1].pwszVal);
		
				
		//
		// Try to retrive full DNS name as computer name
		// Works only at W2K machine in W2K domain only !
		//
		if ( _winmajor ==  Win2K && m_bWorkWithFullDNSName )
		{
			
			QMPropId[0] = PROPID_QM_PATHNAME_DNS;
			QMPropVar[0].vt = VT_NULL;
			QMProps.cProp = 1;
			if( g_bDebug )
			{	
				MqLog ("MQGetMachineProperties - Try to retrieve full dns name\n");
			}
			rc = MQGetMachineProperties(NULL, NULL, &QMProps);
			ErrHandle(rc,MQ_OK,L"MQGetMachineProperties(3)");
			ErrHandle(QMPropVar[0].vt ,VT_LPWSTR ,L"Can not get machine DNS name");		
			// QMPropVar[0].pwszVal contain full DNS name.
			if ( QMPropVar[0].pwszVal && _wcsicmp (QMPropVar[0].pwszVal ,wcsLocalMachineFullDns.c_str ()))
			{
				MqLog ("MachineName - MQGetMachineProperties failed to retrieve full DNS name\n");
				wMqLog (L"MQGetMachineProperties Found: %s \n", QMPropVar[0].pwszVal);
				MQFreeMemory(QMPropVar[0].pwszVal);
				return MSMQ_BVT_FAILED;	
			}
			if ( QMPropVar[0].vt == VT_LPWSTR )
			{
				MQFreeMemory(QMPropVar[0].pwszVal);
			}
			else
			{
				MqLog("MQGetMachineProperties return value that doesn't match with the expected result\n Expected.vt=%d, Found.vt %d\n",VT_LPWSTR,QMPropVar[0].vt);
			    return MSMQ_BVT_FAILED;				  
			}
		}

		iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_CONNECTION;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMProps.cProp = iIndex;		  // Should be 2, but 1 until bug is fixed
 		rc = MQGetMachineProperties(lpMachineName.c_str(), NULL, &QMProps);
		ErrHandle(rc,MQ_OK,L"MQGetMachineProperties(4)");
		
	}

	rc = MQGetMachineProperties(lpMachineName.c_str(), &guidMachineId, &QMProps);
	ErrHandle(rc,MQ_ERROR_INVALID_PARAMETER,L"MQGetMachineProperties(5)");
	QMPropId[0] = PROPID_QM_CONNECTION;
	QMPropVar[0].vt = VT_NULL;
	QMProps.cProp = 2;		  // Should be 2, but 1 until bug is fixed
	
	rc = MQGetMachineProperties(L"NoName", NULL, &QMProps);
	ErrHandle(rc,MQ_ERROR_MACHINE_NOT_FOUND,L"MQGetMachineProperties(6)");

	return MSMQ_BVT_SUCC;
}

void xToFormatName::Description()
{
	wMqLog(L"Thread %d : xxxToFormatName tests\n", m_testid);
}

// ------------------------------------------------------------------------------------
// xToFormatName :: xToFormatName
// Constructor retrieve test parameters
// Machines name, Workgroup Yes now
//

xToFormatName :: xToFormatName (INT iTestIndex , map < wstring , wstring > Tparms )
: cTest(iTestIndex),m_bCanWorksOnlyWithMqAD(true),m_iEmbedded(COM_API)
{
	
	m_wcsFormatNameArray[0] = Tparms [L"PrivateDestFormatName"];
	m_wcsPathNameArray[0] = Tparms [L"PrivateDestPathName"];
	m_wcsFormatNameArray[1] = Tparms [L"DestFormatName"];
	m_wcsPathNameArray[1]  = Tparms [L"DestPathName"];
	m_bWorkGroupInstall = FALSE;

	if ( Tparms [L"Wkg"]== L"Wkg" )
	{
		m_bWorkGroupInstall = TRUE;
	}
	if ( g_bRunOnWhistler && Tparms [L"WorkingAgainstPEC"] == L"Yes" )
	{
		m_bCanWorksOnlyWithMqAD = false;
	}

	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}
}

//------------------------------------------------------------------------------------
// xToFormatName::Start_test
// This method check the api : MQPathNameToFormatName , MQHandleToFormatName
//

int xToFormatName::Start_test ()
{
	SetThreadName(-1,"xToFormatName - Start_test ");			
	DWORD  dwFormatNameLength=0;
	WCHAR  * lpwcsFormatName=NULL;

	// Need to run this on private / Publib queue
	//	1. Private Queue.
	//	2. Public Queue.

	wstring wcsQueueFormatName = m_wcsFormatNameArray[0];
	wstring wcsQueuePathName =  m_wcsPathNameArray[0] ;
	int iNumberOfIteration = m_bWorkGroupInstall ? 1:2;
	do
	{
		if(g_bDebug)
		{
			wMqLog(L"-- Verify MQPathNameToFormatName and MQHandleToFormatName for queue %s\n",wcsQueuePathName.c_str());
			wMqLog(L"Call->MQPathNameToFormatName(PathName=%s,buffer,Size=%d) \n",wcsQueuePathName.c_str(),dwFormatNameLength);
		}
		HRESULT rc = MQPathNameToFormatName( wcsQueuePathName.c_str(), lpwcsFormatName, &dwFormatNameLength);
		if ( rc != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL && dwFormatNameLength == 0 )
		{
			wMqLog(L"MQPathNametoFormatName failed to retrieve the buffer size for format name \n");
			return MSMQ_BVT_FAILED;
		}
		lpwcsFormatName = (WCHAR*) malloc( sizeof (WCHAR) * dwFormatNameLength );
		if ( ! lpwcsFormatName )
		{
			wMqLog(L"malloc failed to allocate memory format name buffer \n");
			return MSMQ_BVT_FAILED;
		}	
		if(g_bDebug)
		{
			wMqLog(L"Call->MQPathNameToFormatName(PathName=%s,buffer,Size=%d) \n",wcsQueuePathName.c_str(),dwFormatNameLength);
		}
		rc = MQPathNameToFormatName( wcsQueuePathName.c_str() , lpwcsFormatName, &dwFormatNameLength);
		ErrHandle(rc,MQ_OK,L"MQPathNameToFormatName failed");
		if ( _wcsicmp( wcsQueueFormatName.c_str() , lpwcsFormatName ))
		{
            if (!g_bRemoteWorkgroup)
            {
                //
                // this is ok if we're in domain and running against remote
                // comptuer that is in workgroup.
                //
			    wMqLog(L"MQPathNameToFormatName failed during compare expected result to return value\n");
			    wMqLog(L"Expected resualt: %s\n MQPathNameToFormatName return:%s \n",wcsQueueFormatName.c_str (),lpwcsFormatName);
			    return MSMQ_BVT_FAILED;
            }
		}
		
		if(g_bDebug)
		{
			wMqLog(L"Call->MQOpenQueue(%s,MQ_SEND_ACCESS , MQ_DENY_NONE,&hQueue)\n",wcsQueueFormatName.c_str());
		}
		HANDLE hQueue=NULL;
		rc = MQOpenQueue( wcsQueueFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &hQueue );
		ErrHandle(rc,MQ_OK,L"MQOpenQueue failed");
		if(g_bDebug)
		{
			wMqLog(L"Call->MQHandleToFormatName(hQueue , lpwcsFormatName ,%d) \n",dwFormatNameLength);
		}
		rc = MQHandleToFormatName( hQueue , lpwcsFormatName , &dwFormatNameLength );
		if( m_bWorkGroupInstall && rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL )
		{
			lpwcsFormatName = (WCHAR *) realloc(lpwcsFormatName,dwFormatNameLength * sizeof(WCHAR));
			if( lpwcsFormatName == NULL )
			{
				wMqLog(L"malloc failed to allocate memory format name buffer \n");
				return MSMQ_BVT_FAILED;
			}
			rc = MQHandleToFormatName( hQueue , lpwcsFormatName , &dwFormatNameLength );
		}
		ErrHandle(rc,MQ_OK,L"MQHandleToFormatName failed");
		//
		// close queue handle this is not related if MQHandleToFormatName Pass / Fail.
		//
		rc = MQCloseQueue ( hQueue );
		ErrHandle(rc,MQ_OK,L"MQCloseQueue failed");
     	//
		// Check MQHandleToFormatName return value == expected value.
		//
		if(! m_bWorkGroupInstall && _wcsicmp( wcsQueueFormatName.c_str(), lpwcsFormatName ) )
		{
            if( !g_bRemoteWorkgroup )
            {
			    wMqLog(L"MQHandleToFormatName failed during compare expected result to return value\n");
			    wMqLog(L"Expected resualt: %s \nMQHandleToFormatName return: %s \n" ,wcsQueueFormatName.c_str (),lpwcsFormatName);
			    return MSMQ_BVT_FAILED;
            }
		}
		else if ( m_bWorkGroupInstall )
		{
			//
			// Search for the private$ in the orginal queue.
			//
			wcsQueueFormatName = ToLower(wcsQueueFormatName);
			wstring wcsToken = L"\\";
			size_t iPos = wcsQueueFormatName.find_first_of(wcsToken);
			if( iPos == -1 )
			{
				wMqLog(L"MQHandleToFormatName return invalid format name %s\n",wcsQueueFormatName.c_str());
				return MSMQ_BVT_FAILED;
			}
			wstring wcspTemp = wcsQueueFormatName.substr(iPos,wcsQueuePathName.length());
			if ( wcsstr(lpwcsFormatName,wcspTemp.c_str()) == NULL )
			{
			    wMqLog(L"MQHandleToFormatName failed during compare expected result to return value\n");
			    wMqLog(L"Expected resualt: %s \nMQHandleToFormatName return: %s \n" ,wcsQueueFormatName.c_str (),lpwcsFormatName);
			    return MSMQ_BVT_FAILED;
            }

		}
		
		//
		// Run again with Public queue.
		//
		wcsQueueFormatName = m_wcsFormatNameArray[1];
		wcsQueuePathName =  m_wcsPathNameArray[1] ;
		free( lpwcsFormatName );
		dwFormatNameLength=0;
	}
	while(--iNumberOfIteration);
	return MSMQ_BVT_SUCC;
}

//---------------------------------------------------------------
// xToFormatName::CheckResult
// This method check Illegal value that pass to the API.
// Return value: MSMQ_BVT_SUCC / MSMQ_BVT_FAILED.
//

int xToFormatName::CheckResult()
{
	//
	// Check MQADsPathToFormatName only in whistler
	//
	if( g_bRunOnWhistler && m_bCanWorksOnlyWithMqAD && ! m_bWorkGroupInstall && m_iEmbedded != C_API_ONLY )
	{
		MSMQ::IMSMQQueueInfo3Ptr qinfo("MSMQ.MSMQQueueInfo");
		qinfo->FormatName = m_wcsFormatNameArray[1].c_str();
		qinfo->Refresh();
		DWORD dwFormatNameLen = 0;
		if( g_bDebug )
		{
			wMqLog(L"Qinfo->AdsPath=%s",qinfo->ADsPath);
		}
		HRESULT hr = MQDnNameToFormatName(qinfo->ADsPath,NULL,& dwFormatNameLen );
		if ( hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL && dwFormatNameLen == 0 )
		{
			wMqLog(L"MQADsPathToFormatName failed to retrieve the buffer size for format name \n");
			return MSMQ_BVT_FAILED;
		}
		WCHAR * lpwcsFormatName = (WCHAR*) malloc( sizeof (WCHAR) * dwFormatNameLen );
		if ( ! lpwcsFormatName )
		{
			wMqLog(L"malloc failed to allocate memory format name buffer \n");
			return MSMQ_BVT_FAILED;
		}
		if( g_bDebug )
		{
			wMqLog(L"Call to MQDnNameToFormatName(%s,lpwcsFormatName,& dwFormatNameLen ) \n",qinfo->ADsPath);
		}
		hr = MQDnNameToFormatName(qinfo->ADsPath,lpwcsFormatName,& dwFormatNameLen );
		if( FAILED(hr) || m_wcsFormatNameArray[1] != lpwcsFormatName )
		{
			wMqLog(L"MQADsPathToFormatName failed to retrive format name hr=0x%x\nFound:%s\n",hr,lpwcsFormatName);
			free( lpwcsFormatName );
			return MSMQ_BVT_FAILED;
		}
		free( lpwcsFormatName );
	}

	DWORD dwFormatNameLength = BVT_MAX_FORMATNAME_LENGTH;
	WCHAR lpwcsFormatName [BVT_MAX_FORMATNAME_LENGTH+1] = {0};
	if(g_bDebug)
	{
		wMqLog(L"Call-> MQPathNameToFormatName with Illegal value\n");
	}
	wstring TmpBuf = L".\\private$\\F41ED5B2-1C81-11d2-B1F4-00E02C067C8BEitan";
	HRESULT rc = MQPathNameToFormatName( TmpBuf.c_str(), lpwcsFormatName, &dwFormatNameLength);
	ErrHandle(rc,MQ_ERROR_QUEUE_NOT_FOUND,L"MQPathNameToFormatName Illegal return value" );
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\cliserv\client.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   client.cpp
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\SecService, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "seccli.h"
#include "secrpc.h"
#include "cliserv.h"

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(rg[0]))

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

TCHAR  g_tszLastRpcString[ PIPE_BUFFER_LEN ] ;

BOOL  g_fImpersonate = TRUE ;
TCHAR g_tszFirstPath[ 128 ] = {0} ;
TCHAR g_tszObjectName[ 128 ] = {0};
TCHAR g_tszObjectClass[ 128 ] = {0};
TCHAR g_tszContainer[ 1024 ] = {0};
TCHAR g_tszSearchRoot[ 1024 ] = {0};
TCHAR g_tszSearchFilter[ 128 ] = {0};
TCHAR g_tszUserName[ 128 ] = {0};
TCHAR g_tszUserPwd[ 128 ] = {0};
BOOL  g_fWithCredentials = FALSE;
BOOL  g_fWithSecuredAuthentication = FALSE;
BOOL  g_fAlwaysIDO = FALSE ;
ULONG g_ulAuthnService = RPC_C_AUTHN_WINNT ;
ULONG g_ulAuthnLevel   = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ;
ULONG g_ulSeInfo = 7 ; // no SACL by default.

HRESULT  MQSec_SetPrivilegeInThread( LPCTSTR lpwcsPrivType,
                                     BOOL    bEnabled ) ;

//+--------------------------------------
//
//  void PrepareResultBuffer()
//
//+--------------------------------------

void PrepareResultBuffer( IN DWORD   dwStatus,
                          IN TCHAR  *tBuf,
                          OUT TCHAR *tResult )
{
    DWORD *pdw = (DWORD *) tResult ;
    *pdw = dwStatus ;

    char *pBuf = (char*) tResult ;
    pBuf += sizeof(DWORD) ;

    TCHAR *ptBuf = (TCHAR*)  pBuf ;
    _tcscpy(ptBuf, tBuf) ;
}

//+--------------------------------------
//
//  void  _ResetTestParameters()
//
//+--------------------------------------

static void  _ResetTestParameters()
{
    g_fAlwaysIDO     = FALSE ;
    g_ulAuthnService = RPC_C_AUTHN_WINNT ;
    g_ulAuthnLevel   = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ;
}

//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szOut[ PIPE_BUFFER_LEN ];
    TCHAR                   szBuf[ PIPE_BUFFER_LEN ];
    LPTSTR                  lpszPipeName = PIPE_CLI_NAME ;
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;
    BOOL                    fContinue = TRUE ;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
                SERVICE_START_PENDING, // service state
                NO_ERROR,              // exit code
                3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    //
    // allow user tp define pipe name
    //
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {
        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }
    }
    //
    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0))                    // wait hint
        goto cleanup;

    AddToMessageLog(TEXT("Ready to accept commands"),
                    EVENTLOG_INFORMATION_TYPE) ;

    ////////////////////////////////////////////////////////////
    //
    // End of initialization
    //
    //
    // Service is now running, perform work until shutdown
    //
    ////////////////////////////////////////////////////////////

    do
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        TCHAR  szIn[ PIPE_BUFFER_LEN ];

        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

		DWORD dlastErr0 = GetLastError();
        if ( !bRet && (  dlastErr0 == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
			if ( dwWait != WAIT_OBJECT_0+1 )
            {
                //
                // not overlapped i/o event - error occurred,
                // or server stop signaled.
                //
                break;
            }
        }

        //
        // Parse the command
        //
        TCHAR  szCommand[ 5 ] ;
        memcpy(szCommand, szIn, 4 * sizeof(TCHAR)) ;
        szCommand[4] = TEXT('\0') ;
        LPTSTR lpszParam = &szIn[4] ;

        if (_tcsicmp( szCommand, TEXT("quit")) == 0)
        {
            fContinue = FALSE ;
            _stprintf(szOut, TEXT("%s Quitting !!!"), SZCLISERVICEDISPLAYNAME);
        }
        else if (_tcsicmp( szCommand, CMD_NIMP ) == 0)
        {
            _tcscpy(szOut, TEXT("Impersonation disabled")) ;
            g_fImpersonate = FALSE ;
        }
        else if (_tcsicmp( szCommand, CMD_YIMP ) == 0)
        {
            _tcscpy(szOut, TEXT("Impersonation enabled")) ;
            g_fImpersonate = TRUE ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTG ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC call to server uses negotiation")) ;
            g_ulAuthnService = RPC_C_AUTHN_GSS_NEGOTIATE ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTK ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC call to server uses kerberos")) ;
            g_ulAuthnService = RPC_C_AUTHN_GSS_KERBEROS ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTN ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC call to server uses ntlm")) ;
            g_ulAuthnService = RPC_C_AUTHN_WINNT ;
        }
        else if (_tcsicmp( szCommand, CMD_FIDO ) == 0)
        {
             g_fAlwaysIDO = FALSE ;
        }
        else if (_tcsicmp( szCommand, CMD_USER ) == 0)
        {
            _tcscpy(g_tszUserName, lpszParam) ;
            g_fWithCredentials = TRUE;
            sprintf(szOut,
              "enabled credentials in ADSI binding, user=%hs, pswd=%hs, ",
                                             g_tszUserName, g_tszUserPwd);
        }
        else if (_tcsicmp( szCommand, CMD_PSWD ) == 0)
        {
            _tcscpy(g_tszUserPwd, lpszParam) ;
            _tcscpy(szOut, g_tszUserPwd) ;
        }
        else if (_tcsicmp( szCommand, CMD_NUSR ) == 0)
        {
            g_fWithCredentials = FALSE;
            _tcscpy(szOut, TEXT("disabled credentials in ADSI binding"));
        }
        else if (_tcsicmp( szCommand, CMD_YKER ) == 0)
        {
            g_fWithSecuredAuthentication = TRUE;
            _tcscpy(szOut,
              "enabled secured authentication(kerberos) in ADSI binding");
        }
        else if (_tcsicmp( szCommand, CMD_NKER ) == 0)
        {
            g_fWithSecuredAuthentication = FALSE;
            _tcscpy(szOut,
              "disabled secured authentication(kerberos) in ADSI binding") ;
        }
        else if (_tcsicmp( szCommand, CMD_CNCT ) == 0)
        {
            g_ulAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
            sprintf(szOut, "RPC authen level- CONNECT") ;
        }
        else if (_tcsicmp( szCommand, CMD_1STP ) == 0)
        {
            _tcscpy(g_tszFirstPath, lpszParam) ;
            sprintf(szOut, "First path- %hs", g_tszFirstPath);
        }
        else if (_tcsicmp( szCommand, CMD_NAME ) == 0)
        {
            _tcscpy(g_tszObjectName, lpszParam) ;
            sprintf(szOut, "name of object to create - %hs", g_tszObjectName);
        }
        else if (_tcsicmp( szCommand, CMD_OBJC ) == 0)
        {
            _tcscpy(g_tszObjectClass, lpszParam) ;
            sprintf(szOut, "class of object to create - %hs", g_tszObjectClass);
        }
        else if (_tcsicmp( szCommand, CMD_SIDO ) == 0)
        {
             g_fAlwaysIDO = TRUE ;
        }
        else if (_tcsicmp( szCommand, CMD_SINF ) == 0)
        {
            _stscanf(lpszParam, TEXT("%lx"), &g_ulSeInfo) ;

            HRESULT hr = S_FALSE ;
            if (g_ulSeInfo & SACL_SECURITY_INFORMATION)
            {
                hr =  MQSec_SetPrivilegeInThread( SE_SECURITY_NAME, TRUE ) ;
            }
            sprintf(szOut, "Security_Information- %lxh, SetPriv- %lxh",
                                                         g_ulSeInfo, hr) ;
        }
        else if (_tcsicmp( szCommand, CMD_CONT ) == 0)
        {
            _tcscpy(g_tszContainer, lpszParam) ;
            sprintf(szOut, "Dn of container- %hs", g_tszContainer);
        }
        else if (_tcsicmp( szCommand, CMD_SRCH ) == 0)
        {
            _tcscpy(g_tszSearchFilter, lpszParam) ;
            sprintf(szOut, "search filter: %hs", g_tszSearchFilter);
        }
        else if (_tcsicmp( szCommand, CMD_ROOT ) == 0)
        {
            _tcscpy(g_tszSearchRoot, lpszParam) ;
            sprintf(szOut, "distinguished name of root-search where testing query - %hs\n", g_tszSearchRoot);
        }
        else if (_tcsicmp( szCommand, CMD_ADSC) == 0)
        {
            g_tszLastRpcString[0] = TEXT('\0') ;
            //
            // Call server side via rpc.
            //
#ifndef UNICODE
            LPUSTR lpszServer = (LPUSTR) lpszParam ;
#endif
            RPC_STATUS status ;
            char *pBuf = NULL ;
            status = PerformADSITestCreate( PROTOSEQ_TCP,
                                            ENDPOINT_TCP,
                                            OPTIONS_TCP,
                                            lpszServer,
                                            g_ulAuthnService,
                                            g_ulAuthnLevel,
                                      (unsigned char *)g_tszFirstPath,
                                      (unsigned char *)g_tszObjectName,
                                      (unsigned char *)g_tszObjectClass,
                                      (unsigned char *)g_tszContainer,
                                            g_fWithCredentials,
                                      (unsigned char *)g_tszUserName,
                                      (unsigned char *)g_tszUserPwd,
                                            g_fWithSecuredAuthentication,
                                            g_fImpersonate,
                                            &pBuf,
                                            TRUE ) ;
            _stprintf(szBuf, TEXT(
               "%hsPerformADSITestCreate on %hs returned %lxh\n%s\n"),
                TEXT("\n\n**********  New Create Test  *****************\n\n"),
                                              lpszServer, status, pBuf) ;
            _tcscat(g_tszLastRpcString, szBuf) ;

            PrepareResultBuffer( status,
                                 szBuf,
                                 szOut ) ;
            if (pBuf)
            {
                midl_user_free(pBuf) ;
            }

            //
            // reset test parameters.
            //
            _ResetTestParameters() ;
        }
        else if (_tcsicmp( szCommand, CMD_ADSQ) == 0)
        {
             g_tszLastRpcString[0] = TEXT('\0') ;
            //
            // Call server side via rpc.
            //
#ifndef UNICODE
            LPUSTR lpszServer = (LPUSTR) lpszParam ;
#endif
            RPC_STATUS status ;
            char *pBuf = NULL ;
            status = PerformADSITestQuery( PROTOSEQ_TCP,
                                           ENDPOINT_TCP,
                                           OPTIONS_TCP,
                                           lpszServer,
                                           g_ulAuthnService,
                                           g_ulAuthnLevel,
                                      (unsigned char *)g_tszSearchFilter,
                                      (unsigned char *)g_tszSearchRoot,
                                      g_fWithCredentials,
                                      (unsigned char *)g_tszUserName,
                                      (unsigned char *)g_tszUserPwd,
                                      g_fWithSecuredAuthentication,
                                           g_fImpersonate,
                                           g_fAlwaysIDO,
                                           g_ulSeInfo,
                                           &pBuf,
                                           TRUE ) ;
            _stprintf(szBuf, TEXT(
                 "%hsPerformADSITestQuery on %hs returned %lxh\n%s\n"),
                TEXT("\n\n**********  New Query Test  *****************\n\n"),
                                                lpszServer, status, pBuf) ;
            _tcscpy(g_tszLastRpcString, szBuf) ;

            PrepareResultBuffer( status,
                                 szBuf,
                                 szOut ) ;
            if (pBuf)
            {
                midl_user_free(pBuf) ;
            }

            //
            // reset test parameters.
            //
            _ResetTestParameters() ;
        }
        else if (_tcsicmp( szCommand, CMD_LAST) == 0)
        {
             _tcscpy(szOut, g_tszLastRpcString) ;
             g_tszLastRpcString[0] = TEXT('\0') ;
        }
        else
        {
            //
            // return the string to client.
            //
            _stprintf(szOut, TEXT("Hello! [%s]"), szIn);
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
        //
        // send it back out...
        //
		printf("szout, before WriteFile = %s\n", szOut);
        bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }
        //
        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }
    while (fContinue) ;

cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}

//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\cliserv\cliserv.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   cliserv.cpp
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "seccli.h"


// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZCLISERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            LPTSTR lpszLogonName = NULL;
            LPTSTR lpszLogonPwd = NULL;
            if (argc > 2)
            {
                lpszLogonName = argv[2];
                //lpszLogonPwd = TEXT("");
            }
            if (argc > 3)
            {
                lpszLogonPwd = argv[3];
            }
            CmdInstallService(lpszLogonName, lpszLogonPwd);
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else if (( _tcsicmp( TEXT("?"), argv[1]+1 ) == 0 ) ||
                 ( _tcsicmp( TEXT("h"), argv[1]+1 ) == 0 ))
        {
            printf( "%s -install          to install the service\n", SZAPPNAME );
            printf( "%s -remove           to remove the service\n", SZAPPNAME );
            printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
            printf( "\n To start the service: net start %s\n", SZCLISERVICENAME) ;
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
dispatch:
        // this is just to be friendly
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( SZCLISERVICENAME,
                                                  service_ctrl ) ;

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ServiceStop();
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);

}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//

VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


//    if ( !bDebug )
    {
        if (wType == EVENTLOG_ERROR_TYPE)
        {
            DWORD dwErr = GetLastError();
            _stprintf( szMsg,
                       TEXT("%s error: %d"),
                       SZCLISERVICENAME,
                       dwErr ) ;
        }
        else if (wType == EVENTLOG_INFORMATION_TYPE)
        {
            _stprintf( szMsg,
                       TEXT("%s information "),
                       SZCLISERVICENAME ) ;
        }
        else
        {
            _stprintf( szMsg,
                       TEXT("%s unknown "),
                       SZCLISERVICENAME ) ;
        }

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZCLISERVICENAME));

        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL)
        {
            ReportEvent(hEventSource,         // handle of event source
                        wType,                // event type
                        0,                    // event category
                        0,                    // event ID
                        NULL,                 // current user's SID
                        2,                    // strings in lpszStrings
                        0,                    // no bytes of raw data
                        (LPCTSTR *) lpszStrings,          // array of error strings
                        NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
}

///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf( TEXT("Unable to install %s - %s\n"),
                  SZCLISERVICEDISPLAYNAME,
                  GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZCLISERVICENAME),        // name of service
            TEXT(SZCLISERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            lpszLogonName,              // NULL means LocalSystem account
            lpszLogonPwd);              // NULL means no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZCLISERVICEDISPLAYNAME) );
            _tprintf(TEXT("to start: net start %s\n"), SZCLISERVICENAME) ;
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        _tprintf(TEXT("Successfully opened the ServiceManager\n")) ;

        schService = OpenService( schSCManager,
                                  SZCLISERVICENAME,
                                  SERVICE_ALL_ACCESS ) ;

        if (schService)
        {
            _tprintf(TEXT("Successfully opened the Service\n")) ;
            //
            // try to stop the service
            //
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZCLISERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf( TEXT("\n%s stopped.\n"),
                              SZCLISERVICEDISPLAYNAME );
                else
                    _tprintf( TEXT("\n%s failed to stop.\n"),
                              SZCLISERVICEDISPLAYNAME );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), SZCLISERVICEDISPLAYNAME );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZCLISERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZCLISERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\cliserv\cliserv.h ===
//
// file: clieserv.h
//
#include "..\secall.h"

//
// command for cliserv
//

#define CMD_1STP  (TEXT("1stp"))
#define CMD_ADSQ  (TEXT("adsq"))
#define CMD_ADSC  (TEXT("adsc"))
#define CMD_AUTG  (TEXT("autg"))
#define CMD_AUTK  (TEXT("autk"))
#define CMD_AUTN  (TEXT("autn"))
#define CMD_CNCT  (TEXT("cnct"))
#define CMD_CONT  (TEXT("cont"))

#define CMD_FIDO  (TEXT("fido"))
 //
 // use IDirectoryObject to query the security descriptor only if
 // IDirectorySearch fail.
 //

#define CMD_LAST  (TEXT("last"))
#define CMD_NAME  (TEXT("name"))
#define CMD_NIMP  (TEXT("nimp"))
#define CMD_NKER  (TEXT("nker"))
#define CMD_NUSR  (TEXT("nusr"))

#define CMD_OBJC  (TEXT("objc"))
 //
 // object class for "Create" test
 //

#define CMD_PSWD  (TEXT("pswd"))
#define CMD_QUIT  (TEXT("quit"))
#define CMD_ROOT  (TEXT("root"))

#define CMD_SIDO  (TEXT("sido"))
 //
 // unconditionally use IDirectoryObject to query the security descriptor.
 //

#define CMD_SINF  (TEXT("sinf"))
 //
 // SECURITY_INFORMATION value, in hex.
 //

#define CMD_SRCH  (TEXT("srch"))
 //
 // define search filter. filter string is required.
 //

#define CMD_USER  (TEXT("user"))
#define CMD_YIMP  (TEXT("yimp"))
#define CMD_YKER  (TEXT("yker"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secserv.h ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: secserv.h
//
//  AUTHOR: Craig Link
//          Doron Juster
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and
//  implement the ServiceStart() and ServiceStop() functions.
//
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H

#include <tchar.h>
#include "secall.h"

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "SecServS"

// internal name of the service.
// this name is used in the "net start" and "net stop" commands.
#define SZSERVICENAME        "AdsSecService"

// displayed name of the service
#define SZSERVICEDISPLAYNAME  TEXT("DoronJ ADSI Security Server Service")

// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

//
// Name of Pipe to be used.
//
#define SRV_PIPE_NAME  TEXT("\\\\.\\pipe\\SecSrvService")

//////////////////////////////////////////////////////////////////////////////

/////////////////////
//
//  Commands
//
/////////////////////

#define CMD_LAST  (TEXT("last"))
#define CMD_CRED  (TEXT("cred"))
#define CMD_RPCS  (TEXT("rpcs"))
#define CMD_QUIT  (TEXT("quit"))

//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType = EVENTLOG_ERROR_TYPE) ;
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\cliserv\rpccli.cpp ===
//
// file:  srpcli.cpp
//
#ifndef UNICODE
#define  UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "secrpc.h"
#include "secserv.h"

//+-----------------------------------
//
// RPC_STATUS  CreateRpcBindingW()
//
//+-----------------------------------

RPC_STATUS  CreateRpcBindingW( WCHAR  wszProtocol[],
                               WCHAR  wszEndpoint[],
                               WCHAR  wszOptions[],
                               WCHAR  wszServerName[],
                               ULONG  ulAuthnService,
                               ULONG  ulAuthnLevel,
                               BOOL   fService,
                               handle_t *phBind )
{
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;
    handle_t hBind = NULL ;
    WCHAR *wszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,  // pszUuid,
                                                 wszProtocol,
                                                 wszServerName,
                                                 wszEndpoint,
                                                 wszOptions,
                                                 &wszStringBinding);
    if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RpcStringBindingCompose() return %s, %lut"),
                                               wszStringBinding, status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcBindingFromStringBinding(wszStringBinding,
                                         &hBind);
    if (!fService)
    {
        DBG_PRINT_INFO((
            TEXT("RpcBindingFromStringBinding() return %lut"), status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcStringFree(&wszStringBinding);
    if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RpcStringFree() return %lut"), status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    WCHAR * wszPrincipalName = NULL ;
    BOOL fRpcFree = FALSE ;

    if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
        (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
    {
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
        SecQOS.Capabilities |= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH ;

        //
        // kerberos needs principal name
        //
        status = RpcMgmtInqServerPrincName(hBind, ulAuthnService, &wszPrincipalName);
        if (status != RPC_S_OK)
        {
            if (!fService)
            {
                DBG_PRINT_INFO((TEXT(
                  "RpcMgmtInqServerPrincName(Service- %lut) returned %lut"),
                                           ulAuthnService, status)) ;
            }
            wszPrincipalName = NULL;
            fRpcFree = FALSE;
        }
        else
        {
            fRpcFree = TRUE;
        }
    }
    else //ntlm
    {
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        wszPrincipalName = NULL;
    }

    status = RpcBindingSetAuthInfoEx( hBind,
                                      wszPrincipalName,
                                      ulAuthnLevel,
                                      ulAuthnService,
                                      NULL,
                                      RPC_C_AUTHZ_NONE,
                                      &SecQOS );
    if (wszPrincipalName && fRpcFree)
    {
        RpcStringFree(&wszPrincipalName);
    }
    if (!fService)
    {
         DBG_PRINT_INFO((TEXT(
          "RpcBindingSetAuthInfoEx(Service- %lut, Level- %lut) returned %lut"),
                                   ulAuthnService, ulAuthnLevel, status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    *phBind = hBind ;
    return status ;
}

//+---------------------------------------
//
//  RPC_STATUS  PerformADSITestQueryA()
//
//+---------------------------------------

RPC_STATUS  PerformADSITestQueryA( unsigned char  aszProtocol[],
                                   unsigned char  aszEndpoint[],
                                   unsigned char  aszOptions[],
                                   unsigned char  aszServerName[],
                                   ULONG          ulAuthnService,
                                   ULONG          ulAuthnLevel,
                                   unsigned char  *pszSearchFilter,
                                   unsigned char  *pszSearchRoot,
                                   BOOL           fWithCredentials,
                                   unsigned char  *pszUserName,
                                   unsigned char  *pszUserPwd,
                                   BOOL           fWithSecuredAuthentication,
                                   BOOL           fImpersonate,
                                   BOOL           fAlwaysIDO,
                                   DWORD          seInfo,
                                   char           **ppBuf,
                                   BOOL           fService )
{
    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (aszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (aszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] ;
    mbstowcs( wszServerName,
              (char*) (const_cast<unsigned char*> (aszServerName)),
              sizeof(wszServerName)/sizeof(WCHAR)) ;

    WCHAR *pwszOptions = NULL ;
    WCHAR wszOptions[ 512 ] ;
    if (aszOptions)
    {
        mbstowcs( wszOptions,
                  (char*) (const_cast<unsigned char*> (aszOptions)),
                  sizeof(wszOptions)/sizeof(WCHAR)) ;
    }

    handle_t hBind = NULL ;
    RPC_STATUS status =  CreateRpcBindingW( wszProtocol,
                                            wszEndpoint,
                                            wszOptions,
                                            wszServerName,
                                            ulAuthnService,
                                            ulAuthnLevel,
                                            fService,
                                            &hBind ) ;
    if (status != RPC_S_OK)
    {
        if (ppBuf && (*ppBuf == NULL))
        {
            *ppBuf = (char*) midl_user_allocate(256) ;
            sprintf(*ppBuf,
             "Failed to create binding handle on local machine, err- %lut\n",
                                               status) ;
        }
        return status ;
    }

    ULONG ul = (ULONG) -1 ;
    unsigned char * pbBuf = NULL;
    BOOL fException = FALSE ;

    RpcTryExcept
    {
        ul =  RemoteADSITestQuery( hBind,
                                  &pbBuf,
                                   pszSearchFilter,
                                   pszSearchRoot,
                                   fWithCredentials,
                                   pszUserName,
                                   pszUserPwd,
                                   fWithSecuredAuthentication,
                                   fImpersonate,
                                   fAlwaysIDO,
                                   seInfo ) ;
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
        fException = TRUE ;
    }
    RpcEndExcept

    if (pbBuf)
    {
        if (!fService)
        {
            WCHAR wszOut[ PIPE_BUFFER_LEN ] ;
            mbstowcs( wszOut,
                      (char*) (const_cast<unsigned char*> (pbBuf)),
                      sizeof(wszOut)/sizeof(WCHAR)) ;

            DBG_PRINT_INFO(( TEXT(
            "RemoteADSITestQuery() used auth-service %lu, returned %lx\n%s"),
                                        ulAuthnService, ul, wszOut)) ;
        }

        if (ppBuf)
        {
            *ppBuf = (char*) pbBuf ;
        }
        else
        {
            midl_user_free(pbBuf) ;
        }
    }
    else if (!fService)
    {
        DBG_PRINT_INFO((TEXT(
          "RemoteADSITestQuery() used auth-service %lu, returned %lx"),
                                                   ulAuthnService, ul)) ;
    }
    else if (fException && ppBuf && (*ppBuf == NULL))
    {
        *ppBuf = (char*) midl_user_allocate(256) ;
        sprintf(*ppBuf,
               "Exception while calling remote server, err- %lut\n", ul) ;
    }

    status = RpcBindingFree(&hBind);

    if (ul != 0)
    {
        return ul ;
    }
    return status ;
}

//+----------------------------------------
//
//  RPC_STATUS  PerformADSITestCreateA()
//
//+----------------------------------------

RPC_STATUS  PerformADSITestCreateA( unsigned char  aszProtocol[],
                                    unsigned char  aszEndpoint[],
                                    unsigned char  aszOptions[],
                                    unsigned char  aszServerName[],
                                    ULONG          ulAuthnService,
                                    ULONG          ulAuthnLevel,
                                    unsigned char  *pszFirstPath,
                                    unsigned char  *pszObjectName,
                                    unsigned char  *pszObjectClass,
                                    unsigned char  *pszContainer,
                                    BOOL           fWithCredentials,
                                    unsigned char  *pszUserName,
                                    unsigned char  *pszUserPwd,
                                    BOOL        fWithSecuredAuthentication,
                                    BOOL           fImpersonate,
                                    char           **ppBuf,
                                    BOOL           fService )
{
    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (aszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (aszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] ;
    mbstowcs( wszServerName,
              (char*) (const_cast<unsigned char*> (aszServerName)),
              sizeof(wszServerName)/sizeof(WCHAR)) ;

    WCHAR *pwszOptions = NULL ;
    WCHAR wszOptions[ 512 ] ;
    if (aszOptions)
    {
        mbstowcs( wszOptions,
                  (char*) (const_cast<unsigned char*> (aszOptions)),
                  sizeof(wszOptions)/sizeof(WCHAR)) ;
    }

    handle_t hBind = NULL ;
    RPC_STATUS status =  CreateRpcBindingW( wszProtocol,
                                            wszEndpoint,
                                            wszOptions,
                                            wszServerName,
                                            ulAuthnService,
                                            ulAuthnLevel,
                                            fService,
                                            &hBind ) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    ULONG ul = (ULONG) -1 ;
    unsigned char * pbBuf = NULL;

    RpcTryExcept
    {
        ul =  RemoteADSITestCreate( hBind,
                                   &pbBuf,
                                    pszFirstPath,
                                    pszObjectName,
                                    pszObjectClass,
                                    pszContainer,
                                    fWithCredentials,
                                    pszUserName,
                                    pszUserPwd,
                                    fWithSecuredAuthentication,
                                    fImpersonate) ;
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
    }
    RpcEndExcept

    if (pbBuf)
    {
        WCHAR wszOut[ PIPE_BUFFER_LEN ] ;
        mbstowcs( wszOut,
                  (char*) (const_cast<unsigned char*> (pbBuf)),
                  sizeof(wszOut)/sizeof(WCHAR)) ;
        if (!fService)
        {
            DBG_PRINT_INFO(( TEXT(
            "RemoteADSITestCreate() used auth-service %lu, returned %lx\n%s"),
                                        ulAuthnService, ul, wszOut)) ;
        }

        if (ppBuf)
        {
            *ppBuf = (char*) pbBuf ;
        }
        else
        {
            midl_user_free(pbBuf) ;
        }
    }
    else if (!fService)
    {
        DBG_PRINT_INFO((TEXT(
        "RemoteADSITestCreate() used auth-service %lu, returned %lx"),
                                                   ulAuthnService, ul)) ;
    }

    status = RpcBindingFree(&hBind);

    if (ul != 0)
    {
        return ul ;
    }
    return status ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservc\secservc.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   client.c
//
//  PURPOSE:  This program is a command line oriented
//            demonstration of the Simple service sample.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//
//  COMMENTS:
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "secserv.h"


VOID main(int argc, char *argv[])
{
    char    inbuf[ PIPE_BUFFER_LEN ];
    char    outbuf[ PIPE_BUFFER_LEN ];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = SRV_PIPE_NAME ;
    int     ndx;

    // allow user to define pipe name
    for ( ndx = 1; ndx <= argc-1; ndx++ )
    {
        BOOL fPrintHelp = FALSE ;

        if ( (*argv[ndx] == '-') || (*argv[ndx] == '/') )
        {
            LPTSTR lpszArg = argv[ndx]+ 1 ;

            if (( _tcsicmp( CMD_LAST, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_CRED, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_QUIT, lpszArg ) == 0 ))
            {
                _tcscpy(outbuf, lpszArg) ;
            }
            else if ( _tcsicmp( CMD_RPCS, lpszArg ) == 0 )
            {
                _tcscpy(outbuf, lpszArg) ;
                _tcscpy(outbuf + _tcslen(outbuf) + 1, argv[++ndx]) ;
            }
            else if ( _tcsicmp( "s", lpszArg ) == 0 )
            {
                _tcscpy(outbuf, TEXT("string: ")) ;
                _tcscat(outbuf, argv[++ndx]) ;
            }
            else
            {
                fPrintHelp = TRUE ;
            }
        }
        else
        {
            fPrintHelp = TRUE ;
        }

        if (fPrintHelp)
        {
            printf("usage: %s -s    <test string>\n", argv[0]);
            printf("\t     -quit (service will stop)\n") ;
            printf("\t     -cred (show service credentials)\n") ;
            printf("\t     -rpcs [ntlm, kerb, nego, all] (register RPC server with authentication service)\n") ;
            printf("\t     -last (get last RPC string)\n") ;
            exit(1);
        }
    }

    ret = CallNamedPipeA( lpszPipeName,
                          outbuf,
                          sizeof(outbuf),
                          inbuf,
                          sizeof(inbuf),
                          &bytesRead,
                          NMPWAIT_WAIT_FOREVER);

    if (!ret)
    {
        printf("client: CallNamedPipe failed, GetLastError = %d\n",
                                                     GetLastError()) ;
        exit(1);
    }

    printf("%s received:\n%s\n", argv[0], inbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secclic\secclic.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   secclic.cpp
//
//  PURPOSE:  This program is a command line oriented
//            demonstration of the Simple service sample.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//
//  COMMENTS:
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "seccli.h"
#include "..\cliserv\cliserv.h"


VOID main(int argc, char *argv[])
{
    char    inbuf[ PIPE_BUFFER_LEN ];
    char    outbuf[ PIPE_BUFFER_LEN ];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = PIPE_CLI_NAME ;
    int     ndx;
    BOOL    fExit = FALSE ;
    BOOL    fCopyArg = FALSE ;

    // allow user to define pipe name
    for ( ndx = 1; ndx <= argc-1; ndx++ )
    {
        BOOL fPrintHelp = FALSE ;

        if ( (*argv[ndx] == '-') || (*argv[ndx] == '/') )
        {
            LPTSTR lpszArg = argv[ndx]+ 1 ;

            if (( _tcsicmp( CMD_LAST, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_YIMP, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTG, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTK, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTN, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_CNCT, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_FIDO, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NIMP, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NKER, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NUSR, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_SIDO, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_YKER, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_QUIT, lpszArg ) == 0 ))
            {
                _tcscpy(outbuf, lpszArg) ;
            }
            else if (( _tcsicmp( CMD_ADSQ, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_ADSC, lpszArg ) == 0 ))
            {
                //
                // we'll end with exit(status), where status is first
                // dword of buffer we get back from service.
                //
                fExit = TRUE ;
                fCopyArg = TRUE ;
            }
            else if (( _tcsicmp( CMD_USER, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_PSWD, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_NAME, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_OBJC, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_CONT, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_1STP, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_SRCH, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_SINF, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_ROOT, lpszArg ) == 0 ))
            {
                fCopyArg = TRUE ;
            }
            else if ( _tcsicmp( TEXT("s"), lpszArg ) == 0 )
            {
                _tcscpy(outbuf, TEXT("string: ")) ;
                _tcscat(outbuf, argv[++ndx]) ;
            }
            else
            {
                fPrintHelp = TRUE ;
            }

            if (fCopyArg)
            {
                _tcscpy(outbuf, lpszArg) ;
                ndx++ ;
                if ((ndx >= argc)        ||
                    (*argv[ndx] == '-')  ||
                    (*argv[ndx] == '/'))
                {
                    printf("\n ERROR: missing input\n\n") ;
                    return ;
                }
                _tcscat(outbuf, argv[ndx]) ;
            }
        }
        else
        {
            fPrintHelp = TRUE ;
        }

        if (fPrintHelp)
        {
            printf("usage: %s\n", argv[0]);
            printf("\t-1stp <first path to bind>\n") ;
            printf("\t-autg (Use Negotiate in RPC binding)\n") ;
            printf("\t-autk (Use Kerberos in RPC binding)\n") ;
            printf("\t-autn (Use NTLM in RPC binding)\n") ;
            printf("\t-cnct (Use CONNECT level RPC authentication)\n") ;
            printf("\t-cont <DN of container, for create test>\n") ;
            printf("\t-fido (Use IDirectoryObject only on failure)\n") ;
            printf("\t-yimp (use impersonation on server)\n") ;
            printf("\t-nimp (no impersonation on server)\n") ;
            printf("\t-user <user name>\n") ;
            printf("\t \t..user name for credentials in ADSI bind\n") ;
            printf("\t-pswd <password>\n") ;
            printf("\t \t..user password for credentials in ADSI bind\n") ;
            printf("\t-nusr (don't use credentials in ADSI bind)\n") ;
            printf("\t-nker (don't use ADS_SECURE_AUTHENTICATION in ADSI bind)\n") ;
            printf("\t-quit (service will stop)\n") ;
            printf("\t-yker (use ADS_SECURE_AUTHENTICATION in ADSI bind)\n") ;
            printf("\t-sido (Always Use IDirectoryObject)\n") ;
            printf("\t-sinf <SECURITY_INFORMATION>, hex\n") ;
            printf("\t-srch <search-Filter>\n") ;
            printf("\t-root <root-search DN>\n") ;
            printf("\t \t..DN of root for ADSI query test\n") ;
            printf("\t-name <object's name>\n") ;
            printf("\t \t..name of object to create in ADSI create test\n") ;
            printf("\t-objc <object's class>\n") ;
            printf("\t \t..name of objectClass to create in ADSI create test\n") ;
            printf("\t-adsc <server name>\n") ;
            printf("\t \t..ADSI create test (rpc). fill domn & name before\n") ;
            printf("\t-adsq <server name>\n") ;
            printf("\t \t..ADSI query test (rpc). fill root before\n") ;
            printf("\t-last (get last RPC string)\n") ;
            exit(1);
        }
    }

    ret = CallNamedPipeA( lpszPipeName,
                          outbuf,
                          sizeof(outbuf),
                          inbuf,
                          sizeof(inbuf),
                          &bytesRead,
                          NMPWAIT_WAIT_FOREVER);

    if (!ret)
    {
        printf("client: CallNamedPipe failed, GetLastError = %d\n",
                                                     GetLastError()) ;
        exit(1);
    }

    DWORD  dwExit = 0 ;
    TCHAR *pszResult = inbuf ;

    if (fExit)
    {
        dwExit = *((DWORD*) inbuf) ;
        pszResult = (TCHAR*) ((char*) inbuf + sizeof(DWORD)) ;
    }

    if (strlen(inbuf) < 60)
    {
        _tprintf(TEXT("%s received: %s\n"), argv[0], pszResult);
    }
    else
    {
        _tprintf(TEXT("%s received from pipe %s:\n%s\n"),
                                    argv[0], lpszPipeName, pszResult);
    }

    exit(dwExit) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\cliserv\privlg.cpp ===
//
// file: privlg.cpp
//
#include <windows.h>
#include "\msmq\src\bins\mqsecmsg.h"

//+-------------------------------------------------------------------
//
// Function:   SetSpecificPrivilegeInAccessToken()
//
// Description:
//      Enable/Disable a security privilege in the access token.
//
// Parameters:
//      hAccessToken - the access token on which the function should operate.
//          The token should be opened with the TOKEN_ADJUST_PRIVILEGES flag.
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//          disabled.
//
//+-------------------------------------------------------------------

HRESULT SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
                                           LPCTSTR lpwcsPrivType,
                                           BOOL    bEnabled )
{
    DWORD             dwErr = 0 ;
    HRESULT           hr = MQSec_OK ;
    LUID              luidPrivilegeLUID;
    TOKEN_PRIVILEGES  tpTokenPrivilege;

    if (!LookupPrivilegeValue( NULL,
                               lpwcsPrivType,
                               &luidPrivilegeLUID) )
    {
        hr = MQSec_E_LOOKUP_PRIV ;
        dwErr = GetLastError() ;
        return hr ;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes =
                                      bEnabled ? SE_PRIVILEGE_ENABLED : 0 ;

    if (!AdjustTokenPrivileges( hAccessToken,
                                FALSE,         // Do not disable all
                                &tpTokenPrivilege,
                                0,
                                NULL,           // Ignore previous info
                                NULL ))         // Ignore previous info
    {
        hr = MQSec_E_ADJUST_TOKEN ;
        dwErr = GetLastError() ;
        return hr ;
    }
    else
    {
        dwErr = GetLastError() ;
        if ((dwErr != ERROR_SUCCESS) &&
            (dwErr != ERROR_NOT_ALL_ASSIGNED))
        {
            hr = MQSec_E_UNKNOWN ;
            return hr ;
        }
    }

    return hr ;
}

//+-------------------------------------------------------------------
//
// Function:  MQSec_SetPrivilegeInThread()
//
// Description:
//      Enable/Disable a security privilege in the access token of the
//      current thread.
//
// Parameters:
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//                 disabled.
//
//+-------------------------------------------------------------------

HRESULT  MQSec_SetPrivilegeInThread( LPCTSTR lpwcsPrivType,
                                     BOOL    bEnabled )
{
    HRESULT hr = MQSec_OK ;
    HANDLE  hAccessToken = NULL ;

    BOOL bRet = OpenThreadToken( GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES,
                                 TRUE,
                                 &hAccessToken ) ;
    if (!bRet)
    {
        if (GetLastError() == ERROR_NO_TOKEN)
        {
            bRet = OpenProcessToken( GetCurrentProcess(),
                                     TOKEN_ADJUST_PRIVILEGES,
                                     &hAccessToken ) ;
        }
    }

    if (bRet)
    {
        hr = SetSpecificPrivilegeInAccessToken( hAccessToken,
                                                lpwcsPrivType,
                                                bEnabled );
        CloseHandle(hAccessToken) ;
        hAccessToken = NULL ;
    }
    else
    {
        hr = MQSec_E_OPEN_TOKEN ;
        DWORD dwErr = GetLastError() ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\secadsi.h ===
//
//  file:  secadsi.h
//

ULONG  ADSITestQuery( char *pszSearchValue,
                      char *pszSearchRoot,
                      BOOL  fWithCredentials,
                      char *pszUserName,
                      char *pszUserPwd,
                      BOOL  fWithSecuredAuthentication,
                      BOOL  fAlwaysIDO,
                      ULONG seInfo ) ;

ULONG  ADSITestCreate( char * pszFirstPath,
                       char * pszObjectName,
                       char * pszObjectClass,
                       char * pszContainer,
                       BOOL fWithCredentials,
                       char * pszUserName,
                       char * pszUserPwd,
                       BOOL fWithSecuredAuthentication ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\adsistub.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   adsistub.cpp
//
//  PURPOSE: implement stubs for ADSI apis. The stubs load the activeds dll.
//      This enable the test to run on nt4 too, where adsi is not installed
//      by default.
//
//  FUNCTIONS:
//
//  AUTHOR: Doron Juster (DoronJ)
//

#include "secservs.h"
#include "_adsi.h"

HINSTANCE g_hAdsi = NULL ;

//+----------------------------
//
//  ULONG  LoadAdsiDll()
//
//+----------------------------

ULONG  LoadAdsiDll()
{
    TCHAR tBuf[ 256 ] ;

    if (!g_hAdsi)
    {
        g_hAdsi = LoadLibrary(TEXT("activeds.dll")) ;
    }

    if (!g_hAdsi)
    {
        _stprintf(tBuf, TEXT("Can not load activeds.dll, err- %lut"),
                                                          GetLastError()) ;
        LogResults(tBuf, FALSE) ;

        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ;
    }

    return 0 ;
}

//+------------------------
//
//  MyADsOpenObject()
//
//+------------------------

HRESULT WINAPI
MyADsOpenObject(
    LPWSTR lpszPathName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    TCHAR tBuf[ 256 ] ;
    static ADsOpenObject_ROUTINE s_pfnOpen = NULL ;

    if (!s_pfnOpen)
    {
        ULONG ul =  LoadAdsiDll() ;
        if (ul != 0)
        {
            return ul ;
        }
        s_pfnOpen = (ADsOpenObject_ROUTINE)
                            GetProcAddress(g_hAdsi, "ADsOpenObject") ;
        if (!s_pfnOpen)
        {
            return E_FAIL ;
        }
    }

    if (lpszUserName)
    {
        _stprintf(tBuf, TEXT(
            "Calling ADsOpenObject(%S, dwReserve- %lxh, user- %S)"),
                                  lpszPathName, dwReserved, lpszUserName) ;
    }
    else
    {
        _stprintf(tBuf, TEXT("Calling ADsOpenObject(%S, dwReserve- %lxh)"),
                                              lpszPathName, dwReserved) ;
    }
    LogResults(tBuf, FALSE) ;

    HRESULT hr = (*s_pfnOpen) ( lpszPathName,
                                lpszUserName,
                                lpszPassword,
                                dwReserved,
                                riid,
                                ppObject ) ;
    return hr ;
}

//+------------------------
//
//   MyADsGetObject()
//
//+------------------------

HRESULT WINAPI
MyADsGetObject(
    LPWSTR lpszPathName,
    REFIID riid,
    VOID * * ppObject
    )
{
    TCHAR tBuf[ 256 ] ;
    static ADsGetObject_ROUTINE s_pfnGet = NULL ;

    if (!s_pfnGet)
    {
        ULONG ul =  LoadAdsiDll() ;
        if (ul != 0)
        {
            return ul ;
        }
        s_pfnGet = (ADsGetObject_ROUTINE)
                            GetProcAddress(g_hAdsi, "ADsGetObject") ;
        if (!s_pfnGet)
        {
            return E_FAIL ;
        }
    }

    _stprintf(tBuf, TEXT("Calling ADsGetObject(%S)"), lpszPathName) ;
    LogResults(tBuf, FALSE) ;

    HRESULT hr = (*s_pfnGet) ( lpszPathName,
                               riid,
                               ppObject ) ;
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\dirobj.cpp ===
//
// file:  dirobj.cpp
//
#include "secservs.h"
#include "_Adsi.h"
#include "sidtext.h"

#define NameBufferSize 500

typedef struct _ACCESS_ALLOWED_OBJECT_ACE_1 {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE_1 ;

//+----------------------------
//
//  BOOL PrintSID( PSID pSid )
//
//+----------------------------

BOOL PrintSID( PSID pSid )
{
    TCHAR tBuf[ 256 ] ;
    TCHAR NameBuffer[NameBufferSize];
    TCHAR DomainBuffer[NameBufferSize];
    ULONG NameLength = NameBufferSize;
    ULONG DomainLength = NameBufferSize;
    SID_NAME_USE SidUse;
    DWORD ErrorValue;

    DWORD dwSize = GetLengthSid(pSid) ;

    if (!LookupAccountSid( NULL,
                           pSid,
                           NameBuffer,
                           &NameLength,
                           DomainBuffer,
                           &DomainLength,
                           &SidUse))
    {
        ErrorValue = GetLastError();
        _stprintf( tBuf,
               TEXT("\nERROR - LookupAccountSid() failed, LastErr- %lut"),
                                                          ErrorValue) ;
        LogResults(tBuf) ;
        return FALSE ;
    }
    else
    {
        _stprintf(tBuf,
            TEXT("size- %lut, %lxh, %s\\%s"),
                                dwSize, dwSize, DomainBuffer, NameBuffer) ;
        LogResults(tBuf) ;

    	TCHAR TmpBuffer[500];
	    DWORD TmpBufferLength = sizeof(TmpBuffer) / sizeof(TmpBuffer[0]) ;

	    if (GetTextualSid(pSid, TmpBuffer, &TmpBufferLength) == FALSE)
        {
            _stprintf(tBuf, TEXT("ERROR - couldn't get Textual Sid")) ;
            LogResults(tBuf) ;
            return FALSE ;
        }
        _stprintf(tBuf, TEXT("\t%s"), TmpBuffer);
        LogResults(tBuf) ;
    }

    return TRUE ;
}

//+-------------------------
//
//  void PrintACEs()
//
//+-------------------------

BOOL PrintACEs(PACL pAcl)
{
    TCHAR tBuf[ 256 ];
    TCHAR NameBuffer[NameBufferSize];
    TCHAR DomainBuffer[NameBufferSize];
    ULONG NameLength = NameBufferSize;
    ULONG DomainLength = NameBufferSize;
    SID_NAME_USE SidUse;
    DWORD ErrorValue;
	ACCESS_ALLOWED_ACE* pAce;
	ACCESS_ALLOWED_OBJECT_ACE* pObjAce;
	ACCESS_ALLOWED_OBJECT_ACE_1* pObjAce1;
	WORD NumberOfACEs;
	TCHAR TmpBuffer[500];
	DWORD TmpBufferLength = 500;
    PSID  pSid ;
    BOOL  fObjAce = FALSE ;
    int i;
	
    _stprintf(tBuf, TEXT(" Revision: %lut,"), (ULONG) pAcl->AclRevision) ;
    LogResults(tBuf, FALSE) ;

	NumberOfACEs = pAcl->AceCount;
    _stprintf(tBuf, TEXT("  Numof ACEs: %lut"), pAcl->AceCount) ;
    LogResults(tBuf) ;

    for ( i = 0 ; i < NumberOfACEs ; i++ )
    {
        if (GetAce(pAcl, i, (LPVOID* )&(pAce)) == FALSE)
        {
            _stprintf(tBuf,
                   TEXT("ERROR - couldn't get Access Controll Entry"));
            LogResults(tBuf) ;

            return FALSE ;
        }
        _stprintf(tBuf, TEXT("....ACE(%d), size- %lut %lxh, "), i,
                             pAce->Header.AceSize,  pAce->Header.AceSize);

        fObjAce = FALSE ;
	    pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*) pAce ;

        switch (pAce->Header.AceType)
        {
           case ACCESS_ALLOWED_ACE_TYPE:

             pSid = (PSID) &(pAce->SidStart) ;
             _tcscat(tBuf, TEXT("ACCESS_ALLOWED,"));
             break;

           case ACCESS_DENIED_ACE_TYPE:

             pSid = (PSID) &(pAce->SidStart) ;
             _tcscat(tBuf, TEXT("ACCESS_DENIED,")) ;
             break;

           case SYSTEM_AUDIT_ACE_TYPE:

             pSid = (PSID) &(pAce->SidStart) ;
             _tcscat(tBuf, TEXT("SYSTEM_AUDIT,")) ;
             break;

           case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

             fObjAce = TRUE ;
             pSid = (PSID) &(pObjAce->SidStart) ;
             _tcscat(tBuf, TEXT("ACCESS_ALLOWED_OBJECT")) ;
             break;

           case ACCESS_DENIED_OBJECT_ACE_TYPE:

             fObjAce = TRUE ;
             pSid = (PSID) &(pObjAce->SidStart) ;
             _tcscat(tBuf, TEXT("ACCESS_DENIED_OBJECT")) ;
             break;

           case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

             fObjAce = TRUE ;
             pSid = (PSID) &(pObjAce->SidStart) ;
             _tcscat(tBuf, TEXT("SYSTEM_AUDIT_OBJECT")) ;
             break;

           default:

             _tcscat(tBuf, TEXT("ERROR - Unknown AceType")) ;
             LogResults(tBuf) ;
             return FALSE ;
             break;
        }
        LogResults(tBuf, FALSE) ;

        if (fObjAce)
        {
            _stprintf(tBuf,
                     TEXT("\n......ObjFlags- %lxh,"), pObjAce->Flags) ;
            LogResults(tBuf, FALSE) ;

            if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
            {
	            pObjAce1 = (ACCESS_ALLOWED_OBJECT_ACE_1*) pObjAce;
                pSid = (PSID) &(pObjAce1->SidStart) ;
            }
        }
        _stprintf(tBuf, " HeaderFlags- %lxh, Mask- %lxh",
                                 pAce->Header.AceFlags, pAce->Mask) ;
        LogResults(tBuf) ;

        if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
        {
            TCHAR *pwszGuid = NULL ;

            RPC_STATUS status = UuidToString( &(pObjAce->ObjectType),
                                            (unsigned char**) &pwszGuid ) ;

            _stprintf(tBuf, TEXT("......ObjectType- %s"), pwszGuid) ;
            LogResults(tBuf) ;
        }

        NameLength = NameBufferSize;
        DomainLength = NameBufferSize;
        if (!LookupAccountSid( NULL,
                               pSid,
                               NameBuffer,
                               &NameLength,
                               DomainBuffer,
                               &DomainLength,
                               &SidUse))
        {
            ErrorValue = GetLastError();
            _stprintf(tBuf,
                TEXT("ERROR - LookupAccountSid failed, LastErr- %lut"),
                                                             ErrorValue) ;
        }
        else
        {
            DWORD dwSize = GetLengthSid(pSid) ;
            _stprintf(tBuf, TEXT("......Name: (SID size- %lut) %s\\%s"),
                                        dwSize, DomainBuffer, NameBuffer) ;
        }
        LogResults(tBuf) ;

		if (!GetTextualSid( pSid,
                            TmpBuffer,
                            &TmpBufferLength))
	    {
            _stprintf(tBuf, TEXT("ERROR - couldn't get Textual Sid")) ;
		}
        else
        {
            _stprintf(tBuf, TEXT("\t\t%s"), TmpBuffer) ;
        }
        LogResults(tBuf) ;
    }

    return TRUE ;
}

//+---------------------------
//
//  BOOL  ShowOGandSID()
//
//+---------------------------

BOOL  ShowOGandSID( PSID pSid, BOOL Defaulted )
{
    BOOL f = TRUE ;

    if (Defaulted)
    {
        LogResults(TEXT("Defaulted "), FALSE) ;
    }
    else
    {
        LogResults(TEXT("NotDefaulted "), FALSE) ;
    }

    if (!pSid)
    {
        LogResults(TEXT(", Not available")) ;
    }
    else
    {
        f = PrintSID( pSid ) ;
    }

    return TRUE ;
}

//+-----------------------------------------------------------
//
//   HRESULT  ShowNT5SecurityDescriptor()
//
//+-----------------------------------------------------------

HRESULT  ShowNT5SecurityDescriptor( SECURITY_DESCRIPTOR *pSD,
                                    BOOL  fAllData = TRUE )
{
    TCHAR tBuf[ 256 ] ;
    PSID  pSid;
    BOOL  Defaulted = FALSE ;

    DWORD dwRevision = 0 ;
    SECURITY_DESCRIPTOR_CONTROL sdC ;
    BOOL f = GetSecurityDescriptorControl( pSD, &sdC, &dwRevision ) ;
    _stprintf(tBuf, TEXT("Control- %lxh, Revision- %lut"),
                                               (DWORD) sdC, dwRevision) ;
    LogResults(tBuf) ;

    if (!GetSecurityDescriptorOwner(pSD, &pSid, &Defaulted))
    {
        _stprintf(tBuf, TEXT("ERROR - couldn't get Security Descriptor Owner"));
        LogResults(tBuf) ;
        return FALSE ;
    }

    LogResults(TEXT("...Owner : "), FALSE) ;
    f =  ShowOGandSID( pSid, Defaulted ) ;

    if (!GetSecurityDescriptorGroup(pSD, &pSid, &Defaulted))
    {
        _stprintf(tBuf, TEXT("ERROR - couldn't get Security Descriptor Group")) ;
        LogResults(tBuf) ;
        return FALSE ;
    }

    LogResults(TEXT("...Group : "), FALSE) ;
    f =  ShowOGandSID( pSid, Defaulted ) ;


    BOOL fAclExist;
    PACL pAcl;

    if (!GetSecurityDescriptorDacl( pSD,
                                    &fAclExist,
                                    &pAcl,
                                    &Defaulted))
    {
        _stprintf(tBuf, TEXT(
            "ERROR - couldn't get Security Descriptor discretionary ACL")) ;
        LogResults(tBuf) ;
        return FALSE ;
    }

	if (fAclExist == FALSE)
    {
        LogResults(TEXT("...DACL : NotPresent"));
    }
	else
	{
		if (Defaulted)
        {
            LogResults(TEXT("...DACL: Defaulted"), FALSE) ;
		}
        else
        {
            LogResults(TEXT("...DACL: NotDefaulted"), FALSE) ;
        }
        _stprintf(tBuf, TEXT(", Size- %lut, %lxh"),
                                        pAcl->AclSize, pAcl->AclSize) ;
        LogResults(tBuf) ;

		if (pAcl == NULL)
        {
            LogResults(TEXT("...DACL: NULL")) ;
		}
        else
        {
            if (fAllData)
            {
                LogResults(TEXT("...DACL:"), FALSE) ;
    			BOOL f = PrintACEs(pAcl) ;
            }
        }
	}

    if (!GetSecurityDescriptorSacl( pSD,
                                    &fAclExist,
                                    &pAcl,
                                    &Defaulted))
    {
        _stprintf(tBuf, TEXT(
              "ERROR - couldn't get Security Descriptor System ACL")) ;
        LogResults(tBuf) ;
        return FALSE ;
    }

	if (!fAclExist)
    {
        LogResults(TEXT("...SACL : NotPresent"));
	}
    else
	{
		if (Defaulted)
        {
            LogResults(TEXT("...SACL : Defaulted"));
		}
        else
        {
            LogResults(TEXT("...SACL : NotDefaulted"));
        }

		if (pAcl == NULL)
        {
            LogResults(TEXT("...SACL: NULL")) ;
		}
        else
        {
            if (fAllData)
            {
                LogResults(TEXT("...SACL:"), FALSE) ;
    			BOOL f = PrintACEs(pAcl) ;
            }
        }
	}

    return TRUE ;
}

//+----------------------------------
//
//  HRESULT QueryWithIDirObject()
//
//+----------------------------------

HRESULT QueryWithIDirObject( WCHAR wszBaseDN[],
                             WCHAR *pwszUser,
                             WCHAR *pwszPassword,
                             BOOL  fWithAuthentication,
                             ULONG seInfo )
{
    TCHAR   tBuf[ 256 ] ;
    HRESULT hr ;
    _stprintf(tBuf, TEXT("DirObj: BaseDN- %S"), wszBaseDN ) ;
    LogResults(tBuf) ;

    R<IDirectoryObject> pDirObj = NULL ;
    if (fWithAuthentication)
    {
        hr = MyADsOpenObject( wszBaseDN,
                              pwszUser,
                              pwszPassword,
                              ADS_SECURE_AUTHENTICATION,
                              IID_IDirectoryObject,
                              (void**) &pDirObj );
    }
    else
    {
        hr = MyADsGetObject( wszBaseDN,
                             IID_IDirectoryObject,
                             (void**) &pDirObj );
    }
    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT(
                  "ERROR: ADs[Open/Get]Object() failed, hr- %lxh"), hr) ;
        LogResults(tBuf) ;
        return hr ;
    }

    if (seInfo != 0)
    {
        //
        // set the Security Information option.
        // not supported on beta2
        //
        R<IADsObjectOptions> pObjOptions = NULL ;
        hr = pDirObj->QueryInterface (IID_IADsObjectOptions,
                                      (LPVOID *) &pObjOptions);
        if (FAILED(hr))
        {
            _stprintf(tBuf,
               TEXT("ERROR: QI(IADsObjectOptions) failed, hr- %lxh"), hr) ;
            LogResults(tBuf) ;
            return hr ;
        }

        VARIANT var ;
        var.vt = VT_I4 ;
        var.ulVal = (ULONG) seInfo ;

        hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
        if (FAILED(hr))
        {
            _stprintf(tBuf,
             TEXT("ERROR: SetOption() failed, hr- %lxh, seInfo- %lxh"),
                                                           hr, var.ulVal) ;
            LogResults(tBuf) ;
            return hr ;
        }
        _stprintf(tBuf, TEXT("SetOption(%lxh) succeeded"), var.ulVal) ;
        LogResults(tBuf) ;
    }

    LPWSTR  ppAttrNames[1] = {L"nTSecurityDescriptor"} ;
    DWORD   dwAttrCount = 0 ;
    ADS_ATTR_INFO *padsAttr = NULL ;

    hr = pDirObj->GetObjectAttributes( ppAttrNames,
                                       1,
                                       &padsAttr,
                                       &dwAttrCount ) ;
    if (padsAttr)
    {
        _stprintf(tBuf, TEXT(
              "GetObjectAttributes() return %lxh, count- %lut"),
                                                     hr, dwAttrCount) ;
        LogResults(tBuf) ;

        ADS_ATTR_INFO adsInfo = padsAttr[0] ;
        if (adsInfo.dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
        {
            DWORD dwLength = adsInfo.pADsValues->SecurityDescriptor.dwLength ;
            SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *)
                         adsInfo.pADsValues->SecurityDescriptor.lpValue;
            ShowNT5SecurityDescriptor(pSD) ;
        }
    }
    else
    {
        _stprintf(tBuf, TEXT(
          "GetObjectAttributes return %lxh, with null attrib, count- %lut !"),
                                                  hr, dwAttrCount) ;
        LogResults(tBuf) ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\secservs.h ===
//
// File: secservs.h
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "secserv.h"

extern TCHAR  *g_pResults ;
void  LogResults( LPTSTR  pszString,
                  BOOL    fAddNL = TRUE ) ;

void  ShowTokenCredential( HANDLE hToken ) ;
void  ShowImpersonatedThreadCredential(BOOL fImpersonated);
void  ShowProcessCredential() ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\sidtext.h ===
//
// file:  sidtext.h
//

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\sidtext.cpp ===
//
// file:  sidtext.cpp
//

#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//+---------------------------
//
//  BOOL GetTextualSid()
//
// Routine Description:
//
//    This function generates a printable unicode string representation
//    of a SID.
//
//    The resulting string will take one of two forms.  If the
//    IdentifierAuthority value is not greater than 2^32, then
//    the SID will be in the form:
//
//        S-1-281736-12-72-9-110
//              ^    ^^ ^^ ^ ^^^
//              |     |  | |  |
//              +-----+--+-+--+---- Decimal
//
//    Otherwise it will take the form:
//
//        S-1-0x173495281736-12-72-9-110
//            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
//             Hexidecimal    |  | |  |
//                            +--+-+--+---- Decimal
//
//+---------------------------

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD dwBufferLen    // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = _stprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                       (USHORT)psia->Value[0],
                       (USHORT)psia->Value[1],
                       (USHORT)psia->Value[2],
                       (USHORT)psia->Value[3],
                       (USHORT)psia->Value[4],
                       (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("%lu"),
                      (ULONG)(psia->Value[5]      )   +
                      (ULONG)(psia->Value[4] <<  8)   +
                      (ULONG)(psia->Value[3] << 16)   +
                      (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize += _stprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                                *GetSidSubAuthority(pSid, dwCounter) ) ;
    }

    return TRUE;
}

//+---------------------------
//
//  BOOL GetTextualSidW()
//
//+---------------------------

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
    )
{
    TCHAR *pBuf = new TCHAR[ *pdwBufferLen ] ;
    BOOL f = GetTextualSid( pSid,
                            pBuf,
                            pdwBufferLen ) ;
    if (!f)
    {
        delete pBuf ;
        return FALSE ;
    }

#if defined(UNICODE) || defined(_UNICODE)
    wcscpy(TextualSid, pBuf) ;
#else
    mbstowcs( TextualSid, pBuf, (*pdwBufferLen)+1 ) ;
#endif

    delete pBuf ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\secservs.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   secservs.cpp
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\SecService, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//


#include "secservs.h"
#include <process.h>

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

void  ShowProcessCredential() ;
DWORD __stdcall  ServerThread( void *dwP ) ;

extern TCHAR  g_tszLastRpcString[] ;

//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szOut[ PIPE_BUFFER_LEN ];
    LPTSTR                  lpszPipeName = SRV_PIPE_NAME ;
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;
    BOOL                    fContinue = TRUE ;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
                SERVICE_START_PENDING, // service state
                NO_ERROR,              // exit code
                3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    //
    // allow user tp define pipe name
    //
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {
        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }
    }
    //
    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0))                    // wait hint
        goto cleanup;

    AddToMessageLog(TEXT("Ready to accept commands"),
                    EVENTLOG_INFORMATION_TYPE) ;

    ////////////////////////////////////////////////////////////
    //
    // End of initialization
    //
    //
    // Service is now running, perform work until shutdown
    //
    ////////////////////////////////////////////////////////////

    do
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        TCHAR  szIn[ PIPE_BUFFER_LEN ];

        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        //
        // Parse the command
        //
        if (_tcsicmp( szIn, TEXT("quit")) == 0)
        {
            fContinue = FALSE ;
            _stprintf(szOut, TEXT("%s Quitting !!!"), SZSERVICEDISPLAYNAME);
        }
        else if (_tcsicmp( szIn, TEXT("cred")) == 0)
        {
            //
            // show credentials.
            //
            ShowProcessCredential() ;
            _tcscpy(szOut, g_pResults) ;
        }
        else if (_tcsicmp( szIn, TEXT("last")) == 0)
        {
             _tcscpy(szOut, g_tszLastRpcString) ;
             g_tszLastRpcString[0] = TEXT('\0') ;
        }
        else if (_tcsicmp( szIn, TEXT("rpcs")) == 0)
        {
            //
            // register as rpc server.
            //
            DWORD dwID ;
            HANDLE hT = CreateThread( NULL,
                                      0,       // stack size
                                      ServerThread,
                                      szIn + _tcslen(szIn) + 1,
                                      0,       // creation flag
                                      &dwID ) ;
            if (hT)
            {
                _tcscpy(szOut, TEXT("Rpc Server thread created OK")) ;
            }
            else
            {
                _tcscpy(szOut, TEXT("Failed to create Rpc Server thread")) ;
            }
        }
        else
        {
            //
            // return the string to client.
            //
            _stprintf(szOut, TEXT("Hello! [%s]"), szIn);
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
        //
        // send it back out...
        //
        bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }
        //
        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }
    while (fContinue) ;

cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}

//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\secadsi.cpp ===
//
// file:  secadsi.cpp
//
#include "secservs.h"
#include "_Adsi.h"

extern char g_tszLastRpcString[] ;

HRESULT  ShowNT5SecurityDescriptor(SECURITY_DESCRIPTOR *pSD) ;

HRESULT QueryWithIDirObject( WCHAR wszBaseDN[],
                             WCHAR *pwszUser,
                             WCHAR *pwszPassword,
                             BOOL  fWithAuthentication,
                             ULONG seInfo ) ;

//+---------------------------------------
//
//  HRESULT _GetObjectOwnerFromAttr()
//
//+---------------------------------------

static HRESULT _GetObjectOwnerFromAttr( IUnknown * punkVal,
                                        LPWSTR * ppwszOwner )
{
    HRESULT hr;

    R<IADsSecurityDescriptor> pIADsSec;
    hr = punkVal->QueryInterface( IID_IADsSecurityDescriptor,
                                  (void **)&pIADsSec ) ;
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
          "QueryInterface(IID_IADsSecurityDescriptor) failed %lx\n", hr) ;
        return hr;
    }

    BSTR bstrTmpOwner;
    hr = pIADsSec->get_Owner(&bstrTmpOwner);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pIADsSec->get_Owner failed %lx\n", hr);
        return hr;
    }

    *ppwszOwner = new WCHAR[1+wcslen(bstrTmpOwner)];
    wcscpy(*ppwszOwner, bstrTmpOwner);
    SysFreeString(bstrTmpOwner);
    return S_OK;
}


static HRESULT GetObjectOwner(IADs * pIADs, LPWSTR * ppwszOwner)
{
    BS bsTmp = L"nTSecurityDescriptor";
    CAutoVariant varTmp;
    VARIANT * pvarTmp = &varTmp;
    HRESULT hr = pIADs->Get(bsTmp, pvarTmp);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pIADs->Get(ntsec) failed %lx\n", hr);
        return hr;
    }

    return _GetObjectOwnerFromAttr(pvarTmp->punkVal, ppwszOwner);
}

//+----------------------
//
//  void ToWideStr()
//
//+----------------------

static inline void ToWideStr(char *psz, LPWSTR *ppwsz)
{
    if (psz)
    {
        *ppwsz = new WCHAR [1+strlen(psz)];
        swprintf(*ppwsz, L"%hs", psz);
    }
}


static HRESULT _BindToObject(
                    LPWSTR lpszPathName,
                    REFIID riid,
                    BOOL fWithCredentials,
                    LPWSTR lpszUserName,
                    LPWSTR lpszPassword,
                    BOOL fWithSecuredAuthentication,
                    void ** ppObject )
{
    HRESULT hr ;
    TCHAR tBuf[ 256 ] ;
    DWORD dwReserved = 0;

    if (fWithSecuredAuthentication)
    {
       dwReserved = ADS_SECURE_AUTHENTICATION;
    }

    if (fWithCredentials)
    {

        hr = MyADsOpenObject( lpszPathName,
                              lpszUserName,
                              lpszPassword,
                              dwReserved,
                              riid,
                              ppObject );
    }
    else if (fWithSecuredAuthentication)
    {

        hr = MyADsOpenObject( lpszPathName,
                              NULL,
                              NULL,
                              dwReserved,
                              riid,
                              ppObject );
    }
    else
    {
        hr = MyADsGetObject( lpszPathName,
                             riid,
                             ppObject) ;

    }

    if (SUCCEEDED(hr))
    {
        LogResults(TEXT(" Succeeded!")) ;
    }
    else
    {
        _stprintf(tBuf, TEXT(" Failed, hr- %lxh"), hr) ;
        LogResults(tBuf) ;
    }

    return hr ;
}

//+----------------------------
//
//  void PutDescCredentials()
//
//+----------------------------

static void PutDescCredentials(BOOL fWithCredentials,
                               LPWSTR pwszUserName,
                               LPWSTR pwszUserPwd,
                               BOOL fWithSecuredAuthentication)
{
    if (fWithCredentials)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
          "using UserName: %ls, UserPwd: %ls\n", pwszUserName, pwszUserPwd);
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                                                 "using default user\n");
    }

    if (fWithSecuredAuthentication)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                             "with secured authentication (kerberos)\n");
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                                      "without secured authentication\n");
    }
}

//+---------------------------------------
//
//  static HRESULT _FetchAnObject()
//
//+---------------------------------------

static HRESULT _FetchAnObject( IDirectorySearch *pDirSearch,
                               ADS_SEARCH_HANDLE hSearch,
                               BOOL              fWithCredentials,
                               LPWSTR            pwszUserName,
                               LPWSTR            pwszUserPwd,
                               BOOL           fWithSecuredAuthentication,
                               ULONG             seInfo )
{
    HRESULT hr ;
    TCHAR   tBuf[ 256 ] ;

    ADS_SEARCH_COLUMN columnDN;
    hr = pDirSearch->GetColumn(hSearch, L"distinguishedName", &columnDN);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                        "pDirSearch->GetColumn(dn) failed %lxh\n", hr);
        return hr;
    }
    CAutoReleaseColumn cAutoReleaseColumnDN(pDirSearch, &columnDN);

    ADS_SEARCH_COLUMN columnCN;
    hr = pDirSearch->GetColumn(hSearch, L"cn", &columnCN);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->GetColumn(cn) failed for %ls %lx\n", columnDN.pADsValues->DNString, hr);
        return hr;
    }
    CAutoReleaseColumn cAutoReleaseColumnCN(pDirSearch, &columnCN);

    ADS_SEARCH_COLUMN columnNTSec;
    P<CAutoReleaseColumn> pAutoReleaseColumnNTSec;
    BOOL fNTSecFound;
    hr = pDirSearch->GetColumn(hSearch, L"nTSecurityDescriptor", &columnNTSec);

    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT(
        "pDirSearch->GetColumn(ntsec) failed for %ls, hr- %lx, ignored"),
                                  columnDN.pADsValues->DNString, hr);
        LogResults(tBuf) ;

        fNTSecFound = FALSE;

        //
        // OK, now try iDirectoryObject()
        //
        ADS_SEARCH_COLUMN columnPath;
        hr = pDirSearch->GetColumn( hSearch,
                                    L"ADsPath",
                                    &columnPath ) ;

        LogResults(TEXT("Try again with IDirectoryObject ... ")) ;
        hr =  QueryWithIDirObject( columnPath.pADsValues->DNString,
                                   pwszUserName,
                                   pwszUserPwd,
                                   fWithSecuredAuthentication,
                                   seInfo ) ;
    }
    else
    {
        pAutoReleaseColumnNTSec = new
                          CAutoReleaseColumn(pDirSearch, &columnNTSec) ;
        fNTSecFound = TRUE;
    }

    _stprintf(tBuf, TEXT("==>> cn: %ls, dn: %ls"),
                             columnCN.pADsValues->CaseIgnoreString,
                             columnDN.pADsValues->DNString ) ;
    LogResults(tBuf) ;

    if (fNTSecFound)
    {
        _stprintf(tBuf, TEXT(
          "...IDIrectorySearch: attr- %ls, type- %lut, len- %lut"),
                  columnNTSec.pszAttrName, columnNTSec.dwADsType,
                  columnNTSec.pADsValues->ProviderSpecific.dwLength ) ;
        LogResults(tBuf) ;

        SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *)
                 columnNTSec.pADsValues->ProviderSpecific.lpValue ;
//////////////            ShowNT5SecurityDescriptor(pSD) ;

        ADS_SEARCH_COLUMN columnPath;
        hr = pDirSearch->GetColumn( hSearch,
                                    L"ADsPath",
                                    &columnPath ) ;
        if (SUCCEEDED(hr))
        {
            R<IADs> pIADs ;
            hr = _BindToObject( columnPath.pADsValues->DNString,
                                IID_IADs,
                                fWithCredentials,
                                pwszUserName,
                                pwszUserPwd,
                                fWithSecuredAuthentication,
                                (void **) &pIADs ) ;
            if (SUCCEEDED(hr))
            {
                WCHAR *pwszOwner ;
                hr = GetObjectOwner( pIADs, &pwszOwner ) ;
                if (SUCCEEDED(hr))
                {
                    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                      "...Owner (from IADs/IDirectorySearch): %ls\n",
                                                       pwszOwner) ;
                }
            }
        }
    }

    return hr ;
}

//+---------------------------------------
//
//  HRESULT _ADSITestQueryObjects()
//
//+---------------------------------------

static HRESULT _ADSITestQueryObjects( LPWSTR pwszSearchFilter,
                                      LPWSTR pwszSearchRoot,
                                      BOOL   fWithCredentials,
                                      LPWSTR pwszUserName,
                                      LPWSTR pwszUserPwd,
                                      BOOL   fWithSecuredAuthentication,
                                      BOOL   fAlwaysIDO,
                                      ULONG  seInfo )
{
    TCHAR   tBuf[ 256 ] ;
    CCoInit cCoInit;
    HRESULT hr;

    LogResults(TEXT("_ADSITestQueryObjects"));
    _stprintf(tBuf, TEXT("searchFilter: %ls"), pwszSearchFilter) ;
    LogResults(tBuf) ;
    _stprintf(tBuf, TEXT("search root: %ls"), pwszSearchRoot);
    LogResults(tBuf) ;

    PutDescCredentials( fWithCredentials,
                        pwszUserName,
                        pwszUserPwd,
                        fWithSecuredAuthentication ) ;

    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "CoInitialize() failed %lx\n", hr);
        return hr;
    }

    if (fAlwaysIDO)
    {
        LogResults(TEXT("Using only IDirectoryObject")) ;
        hr =  QueryWithIDirObject( pwszSearchRoot,
                                   pwszUserName,
                                   pwszUserPwd,
                                   fWithSecuredAuthentication,
                                   seInfo ) ;
        return hr ;
    }

    R<IDirectorySearch> pDirSearch;
    hr = _BindToObject( pwszSearchRoot,
                        IID_IDirectorySearch,
                        fWithCredentials,
                        pwszUserName,
                        pwszUserPwd,
                        fWithSecuredAuthentication,
                        (void **) &pDirSearch);
    if (FAILED(hr))
    {
        return hr;
    }

    #define NUMOF_SEARCH_PERFS  2
    ADS_SEARCHPREF_INFO   sSearchPrefs[ NUMOF_SEARCH_PERFS ] ;

    sSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    sSearchPrefs[0].vValue.dwType = ADSTYPE_BOOLEAN;
    sSearchPrefs[0].vValue.Boolean = FALSE;

    sSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    sSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    sSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = pDirSearch->SetSearchPreference( sSearchPrefs,
                                          NUMOF_SEARCH_PERFS ) ;

    LPWSTR sSearchAttrs[] = { L"cn",
                              L"distinguishedName",
                              L"nTSecurityDescriptor" };
    ADS_SEARCH_HANDLE hSearch;
    hr = pDirSearch->ExecuteSearch( pwszSearchFilter,
                                    sSearchAttrs,
                                    (sizeof(sSearchAttrs) /
                                             sizeof(sSearchAttrs[0])),
                                    &hSearch ) ;
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                          "pDirSearch->ExecuteSearch failed %lx\n", hr) ;
        return hr;
    }
    CAutoCloseSearchHandle cCloseSearchHandle(pDirSearch, hSearch);

    int cRows = 0 ;
    hr = pDirSearch->GetFirstRow(hSearch);

    while (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
    {
        LogResults(TEXT("************ New Row **************************")) ;
        cRows++ ;

        hr = _FetchAnObject( pDirSearch,
                             hSearch,
                             fWithCredentials,
                             pwszUserName,
                             pwszUserPwd,
                             fWithSecuredAuthentication,
                             seInfo ) ;

        hr = pDirSearch->GetNextRow(hSearch);
    }
    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT("pDirSearch->GetFirst/NextRow failed %lx"), hr);
        LogResults(tBuf) ;
        return hr;
    }

    _stprintf(tBuf, TEXT(
     "****************************************\n...Done query test, %ldt objects found"),
                                                                cRows) ;
    LogResults(tBuf) ;

    return S_OK;
}

//+--------------------------------------
//
//  HRESULT _ADSITestCreateObject()
//
//+--------------------------------------

static HRESULT _ADSITestCreateObject( LPWSTR pwszFirstPath,
                                      LPWSTR pwszObjectName,
                                      LPWSTR pwszObjectClass,
                                      LPWSTR pwszContainer,
                                      BOOL   fWithCredentials,
                                      LPWSTR pwszUserName,
                                      LPWSTR pwszUserPwd,
                                      BOOL   fWithSecuredAuthentication )
{
    CCoInit cCoInit;
    HRESULT hr;
    TCHAR   tBuf[ 256 ] ;

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                                   "object name: %ls\n", pwszObjectName);
    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                                        "Container: %ls\n", pwszContainer) ;
    PutDescCredentials( fWithCredentials,
                        pwszUserName,
                        pwszUserPwd,
                        fWithSecuredAuthentication );

    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                                         "CoInitialize() failed %lx\n", hr) ;
        return hr;
    }

    if (pwszFirstPath && pwszFirstPath[0])
    {
        IADsContainer *pContainerLocal ;
        hr = _BindToObject( pwszFirstPath,
                            IID_IADsContainer,
                            fWithCredentials,
                            pwszUserName,
                            pwszUserPwd,
                            fWithSecuredAuthentication,
                           (void **) &pContainerLocal);
        if (FAILED(hr))
        {
           //
           // continue even if failed.
           //
        }
        else
        {
            pContainerLocal->Release() ;
        }
    }

    WCHAR wszPath[ 1000 ];
    wcscpy(wszPath, pwszContainer) ;

    R<IADsContainer> pContainer;
    hr = _BindToObject( wszPath,
                        IID_IADsContainer,
                        fWithCredentials,
                        pwszUserName,
                        pwszUserPwd,
                        fWithSecuredAuthentication,
                       (void **) &pContainer);
    if (FAILED(hr))
    {
        return hr;
    }

    WCHAR wszCN[200];
    swprintf(wszCN, L"cn=%ls", pwszObjectName);
    BS bstrCN(wszCN);

    BS bsClass(pwszObjectClass) ;
    R<IDispatch> pDisp;
    hr = pContainer->Create(bsClass, bstrCN, &pDisp);
    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT("pContainer->Create(%ls, %ls) failed %lx\n"),
                                       (LPWSTR)bsClass, (LPWSTR)bstrCN, hr);
        LogResults(tBuf) ;

        return hr;
    }

    R<IADs> pChild;
    hr = pDisp->QueryInterface(IID_IADs,(LPVOID *) &pChild);
    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT(
                    "pDisp->QueryInterface(IID_IADs) failed %lx\n"), hr);
        LogResults(tBuf) ;

        return hr;
    }

    VARIANT varPropVal;

    BS bstrPropCNName(L"cn");
    BS bstrPropCNVal(pwszObjectName);
    varPropVal.vt = VT_BSTR;
    varPropVal.bstrVal = bstrPropCNVal;
    hr = pChild->Put(bstrPropCNName, varPropVal);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pChild->Put(%ls, %ls) failed %lx\n", (LPWSTR)bstrPropCNName, (LPWSTR)(varPropVal.bstrVal), hr);
        return hr;
    }

    if (wcsicmp(pwszObjectClass, L"Computer") == 0)
    {
        BS bstrPropSamAccName(L"sAMAccountName");
        BS bstrPropSamAccVal(pwszObjectName);
        varPropVal.vt = VT_BSTR;
        varPropVal.bstrVal = bstrPropSamAccVal;
        hr = pChild->Put(bstrPropSamAccName, varPropVal);
        if (FAILED(hr))
        {
            _stprintf(tBuf, TEXT("pChild->Put(%ls, %ls) failed %lx\n"),
              (LPWSTR)bstrPropSamAccName, (LPWSTR)(varPropVal.bstrVal), hr);
            LogResults(tBuf) ;

            return hr;
        }

        BS bstrPropUserAccContName(L"userAccountControl") ;
        BS bstrPropUserAccContVal(L"4128") ;
        varPropVal.vt = VT_BSTR;
        varPropVal.bstrVal = bstrPropUserAccContVal;

        hr = pChild->Put(bstrPropUserAccContName, varPropVal);
        if (FAILED(hr))
        {
            _stprintf(tBuf, TEXT("pChild->Put(%ls) failed %lx\n"),
                                    (LPWSTR)bstrPropUserAccContName, hr);
            LogResults(tBuf) ;

            return hr;
        }
    }

    hr = pChild->SetInfo();
    if (FAILED(hr))
    {
        _stprintf(tBuf, TEXT("pChild->SetInfo failed %lx\n"), hr);
        LogResults(tBuf) ;

        return hr;
    }

    P<WCHAR> pwszOwner;
    hr = GetObjectOwner(pChild, &pwszOwner);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "failed to get computer's owner, ignored %lx\n", hr);
    }

    _stprintf(tBuf, "done create object %ls, owner %ls\n",
                                (LPWSTR)pwszObjectName, (LPWSTR)pwszOwner) ;
    LogResults(tBuf) ;

    return S_OK;
}

//+---------------------
//
//  BOOL  IsNt4()
//
//+---------------------

BOOL  IsNt4()
{
    OSVERSIONINFO os ;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    BOOL f = GetVersionEx( &os ) ;
    if (f && (os.dwMajorVersion < 5))
    {
        //
        // OK, we're NT4
        //
        return TRUE ;
    }

    return FALSE ;
}

//+----------------------------------------
//
//  ULONG  _TranslateError(ULONG ulErr)
//
//+----------------------------------------

ULONG  _TranslateError(ULONG ulErr)
{
    if (ulErr != (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
    {
        return ulErr ;
    }

    //
    // this error is ok on NT4. Check if we're NT4.
    //
    if (IsNt4())
    {
        return 0 ;
    }

    return ulErr ;
}

//+--------------------------
//
//  ULONG ADSITestQuery()
//
//+--------------------------

ULONG  ADSITestQuery( char *pszSearchFilter,
                      char *pszSearchRoot,
                      BOOL  fWithCredentials,
                      char *pszUserName,
                      char *pszUserPwd,
                      BOOL  fWithSecuredAuthentication,
                      BOOL  fAlwaysIDO,
                      ULONG seInfo )
{
    BOOL f4 =  IsNt4() ;
    if (f4)
    {
        //
        // don't run adsi tests on nt4. They require ldap provider.
        //
        return 0 ;
    }

    ULONG ul = LoadAdsiDll() ;
    if (ul != 0)
    {
        ul = _TranslateError(ul) ;
        return ul ;
    }

    P<WCHAR> pwszSearchFilter, pwszSearchRoot, pwszUserName, pwszUserPwd;
    ToWideStr(pszSearchFilter, &pwszSearchFilter);
    ToWideStr(pszSearchRoot, &pwszSearchRoot);
    if (fWithCredentials)
    {
        ToWideStr(pszUserName, &pwszUserName);
        ToWideStr(pszUserPwd, &pwszUserPwd);
    }

    ul = _ADSITestQueryObjects( pwszSearchFilter,
                                pwszSearchRoot,
                                fWithCredentials,
                                pwszUserName,
                                pwszUserPwd,
                                fWithSecuredAuthentication,
                                fAlwaysIDO,
                                seInfo ) ;
    ul = _TranslateError(ul) ;
    return ul ;
}

//+--------------------------
//
//  ULONG ADSITestCreate()
//
//+--------------------------

ULONG  ADSITestCreate( char *pszFirstPath,
                       char *pszObjectName,
                       char *pszObjectClass,
                       char *pszContainer,
                       BOOL  fWithCredentials,
                       char *pszUserName,
                       char *pszUserPwd,
                       BOOL fWithSecuredAuthentication )
{
    BOOL f4 =  IsNt4() ;
    if (f4)
    {
        //
        // don't run adsi tests on nt4. They require ldap provider.
        //
        return 0 ;
    }

    ULONG ul = LoadAdsiDll() ;
    if (ul != 0)
    {
        ul = _TranslateError(ul) ;
        return ul ;
    }

    P<WCHAR> pwszFirstPath   = NULL ;
    P<WCHAR> pwszObjectName  = NULL ;
    P<WCHAR> pwszObjectClass = NULL ;
    P<WCHAR> pwszContainer   = NULL ;
    P<WCHAR> pwszUserName    = NULL ;
    P<WCHAR> pwszUserPwd     = NULL ;

    ToWideStr(pszFirstPath,   &pwszFirstPath);
    ToWideStr(pszObjectName,  &pwszObjectName);
    ToWideStr(pszObjectClass, &pwszObjectClass);
    ToWideStr(pszContainer,   &pwszContainer);

    if (fWithCredentials)
    {
        ToWideStr(pszUserName, &pwszUserName);
        ToWideStr(pszUserPwd, &pwszUserPwd);
    }

    ul = _ADSITestCreateObject( pwszFirstPath,
                                pwszObjectName,
                                pwszObjectClass,
                                pwszContainer,
                                fWithCredentials,
                                pwszUserName,
                                pwszUserPwd,
                                fWithSecuredAuthentication ) ;
    ul = _TranslateError(ul) ;
    return ul ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\secrpcs.cpp ===
//
// file: secrpcs.cpp
//
#include "secservs.h"
#include "secrpc.h"
#include "secadsi.h"

//
// make the buffer large enough for all our purposes. We'll then see if
// it fit into the pipe.
//
TCHAR  g_tszLastRpcString[ PIPE_BUFFER_LEN * 5 ] = {TEXT("")} ;

TCHAR  *g_pResults = NULL ;
DWORD   g_dwResultsSize = 0 ;

//+-------------------------------------------
//
//  LPTSTR  LogResults( LPTSTR  szString )
//
//+-------------------------------------------

void  LogResults( LPTSTR  pszString,
                  BOOL    fAddNL )
{
    LPTSTR *ppszResults = &g_pResults ;
    DWORD  *pdwSize = &g_dwResultsSize ;

    if (!(*ppszResults))
    {
        *pdwSize = 512 ;
        *ppszResults = new TCHAR[ *pdwSize ] ;
        _tcscpy(*ppszResults, TEXT("\n")) ;
    }

    if ( (_tcslen(*ppszResults) + _tcslen(pszString) + 1) >= *pdwSize)
    {
        *pdwSize = *pdwSize + (512 + _tcslen(pszString)) ;
        LPTSTR pTmp = *ppszResults ;
        *ppszResults = new TCHAR[ *pdwSize ] ;
        _tcscpy(*ppszResults, pTmp) ;
        delete pTmp ;
    }

    _tcscat(*ppszResults, pszString) ;
    if (fAddNL)
    {
        _tcscat(*ppszResults, TEXT("\n")) ;
    }
}

//+------------------------------------------------------
//
//  void _ShowBindingAuthentication(handle_t   hBind)
//
//+------------------------------------------------------

static void _ShowBindingAuthentication(handle_t   hBind)
{
    TCHAR tBuf[ 256 ] ;
    ULONG status;
    ULONG ulAuthnLevel, ulAuthnSvc;
    status = RpcBindingInqAuthClient(hBind,
                                     NULL,
                                     NULL,
                                     &ulAuthnLevel,
                                     &ulAuthnSvc,
                                     NULL);
    if ((status != RPC_S_OK))
    {
        _stprintf(tBuf, TEXT(
           "RpcBindingInqAuthClient() failed, err-%lut"), (DWORD)status) ;
        LogResults(tBuf) ;
        return;
    }

    TCHAR szAuthnSvc[ 64 ];
    switch(ulAuthnSvc)
    {
    case RPC_C_AUTHN_GSS_KERBEROS:
        _tcscpy(szAuthnSvc, TEXT("kerberos")) ;
        break;
    case RPC_C_AUTHN_WINNT:
        _tcscpy(szAuthnSvc, TEXT("ntlm")) ;
        break;
    default:
        _stprintf(szAuthnSvc, TEXT("%lu"), ulAuthnSvc);
        break;
    }

    _stprintf(tBuf, TEXT("Binding Authentication is %s, level- %lut"),
                                              szAuthnSvc, ulAuthnLevel) ;
    LogResults(tBuf) ;
}

//+----------------------------------------------
//
//  ULONG  _ImpersonateClientCall()
//
//+----------------------------------------------

static ULONG  _ImpersonateClientCall(BOOL fImpersonate)
{
    ULONG status = RPC_S_OK ;

    if (fImpersonate)
    {
        status = RpcImpersonateClient(NULL) ;
        if (status != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString),
                "FAIL: RpcImpersonateClient() failed, status- %lut\n",
                                                        (DWORD) status) ;
            return status ;
        }
        _tcscat(g_tszLastRpcString, "impersonated thread credentials: ");
        ShowImpersonatedThreadCredential(TRUE) ;
    }
    else
    {
        _tcscat(g_tszLastRpcString, "without impersonation\n");
    }

    return status ;
}

//+----------------------------------
//
//  ULONG  RemoteADSITestCreate()
//
//+----------------------------------

ULONG  RemoteADSITestCreate( handle_t         hBind,
                             unsigned char  **achBuf,
                             unsigned char   *pszFirstPath,
                             unsigned char   *pszObjectName,
                             unsigned char   *pszObjectClass,
                             unsigned char   *pszContainer,
                             unsigned long    fWithCredentials,
                             unsigned char   *pszUserName,
                             unsigned char   *pszUserPwd,
                             unsigned long    fWithSecuredAuthentication,
                             unsigned long    fImpersonate )
{
    LogResults( TEXT("RemoteADSITestCreate") ) ;

    ShowProcessCredential() ;
    _ShowBindingAuthentication(hBind);

    ULONG status = _ImpersonateClientCall(fImpersonate) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = ADSITestCreate( (char *)pszFirstPath,
                             (char *)pszObjectName,
                             (char *)pszObjectClass,
                             (char *)pszContainer,
                             fWithCredentials,
                             (char *)pszUserName,
                             (char *)pszUserPwd,
                             fWithSecuredAuthentication ) ;

    if (fImpersonate)
    {
        LogResults(TEXT("Before revert, "), FALSE) ;
        ShowImpersonatedThreadCredential(TRUE) ;

        RPC_STATUS status1 = RpcRevertToSelf() ;
        if (status1 != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcRevertToSelf failed %lx\n", (DWORD)status) ;

            if (status == 0)
            {
                status = status1 ;
            }
        }
    }

    _tcscat(g_tszLastRpcString, "\n");

    ULONG ulBufSize = PIPE_BUFFER_LEN ;
    *achBuf = (unsigned char *) midl_user_allocate(ulBufSize) ;

    if ((_tcslen(g_pResults) * sizeof(TCHAR)) > (PIPE_BUFFER_LEN - 512))
    {
        //
        // Leave roomfor 512 bytes of header to be added by the client side.
        //
        _tcscpy((char*) *achBuf,
               TEXT("Buffer overflow. Please allocate larger buffers\n")) ;
    }
    else
    {
        _tcscpy((char*) *achBuf, g_pResults) ;
    }

    delete g_pResults ;
    g_pResults = NULL ;

    return status ;
}

//+--------------------------------
//
//  ULONG  RemoteADSITestQuery()
//
//+--------------------------------

ULONG  RemoteADSITestQuery( handle_t         hBind,
                            unsigned char  **achBuf,
                            unsigned char  *pszSearchFilter,
                            unsigned char  *pszSearchRoot,
                            unsigned long  fWithCredentials,
                            unsigned char  *pszUserName,
                            unsigned char  *pszUserPwd,
                            unsigned long  fWithSecuredAuthentication,
                            unsigned long  fImpersonate,
                            unsigned long  fAlwaysIDO,
                            unsigned long  seInfo )
{
    LogResults( TEXT("RemoteADSITestQuery") ) ;

    ShowProcessCredential() ;
    _ShowBindingAuthentication(hBind);

    ULONG status = _ImpersonateClientCall(fImpersonate) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = ADSITestQuery( (char *)pszSearchFilter,
                            (char *)pszSearchRoot,
                                    fWithCredentials,
                            (char *)pszUserName,
                            (char *)pszUserPwd,
                                    fWithSecuredAuthentication,
                                    fAlwaysIDO,
                                    seInfo ) ;
    if (fImpersonate)
    {
        LogResults(TEXT("Before revert, "), FALSE) ;
        ShowImpersonatedThreadCredential(TRUE) ;

        RPC_STATUS status1 = RpcRevertToSelf() ;
        if (status1 != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcRevertToSelf failed %lx\n", (DWORD)status) ;

            if (status == 0)
            {
                status = status1 ;
            }
        }
    }

    _tcscat(g_tszLastRpcString, "\n");

    ULONG ulBufSize = PIPE_BUFFER_LEN ;
    *achBuf = (unsigned char *) midl_user_allocate(ulBufSize) ;

    if ((_tcslen(g_pResults) * sizeof(TCHAR)) > (PIPE_BUFFER_LEN - 512))
    {
        //
        // Leave roomfor 512 bytes of header to be added by the client side.
        //
        _tcscpy((char*) *achBuf,
               TEXT("Buffer overflow. Please allocate larger buffers\n")) ;
    }
    else
    {
        _tcscpy((char*) *achBuf, g_pResults) ;
    }

    delete g_pResults ;
    g_pResults = NULL ;

    return status ;
}

void Shutdown(void)
{
}

//+--------------------------------------------
//
//  RPC_STATUS RegisterServiceAsRpcServer()
//
//+--------------------------------------------

RPC_STATUS RegisterServiceAsRpcServer(LPTSTR pszAuthSvc)
{
    static BOOL s_fAlreadyInit = FALSE ;
    if (s_fAlreadyInit)
    {
        return RPC_S_OK ;
    }

    TCHAR tBuf[ 256 ] ;

    TCHAR  tszError[ 128 ] ;
    ULONG  ulMaxCalls = 1000 ;
    ULONG  ulMinCalls = 1 ;
    LPUSTR pszProtocol =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint =  ENDPOINT_TCP ;

    RPC_STATUS status = RpcServerUseProtseqEp( pszProtocol,
                                               ulMaxCalls,
                                               pszEndpoint,
                                               NULL ) ;  // Security descriptor
    if (status != RPC_S_OK)
    {
        _stprintf( tszError,
                  TEXT("RpcServerUseProtoseqEp(tcp) failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    status = RpcServerRegisterIf( SecServ_i_v1_0_s_ifspec,
                                  NULL,    // MgrTypeUuid
                                  NULL );  // MgrEpv; null means use default
    if (status != RPC_S_OK)
    {
        _stprintf( tszError,
                  TEXT("RpcServerRegisterIf failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    //
    // register negotiate
    //
    if ((_tcsicmp(pszAuthSvc, TEXT("nego")) == 0)     ||
        (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
    {
        // kerberos needs principal name
        unsigned char * szPrincipalName;
        status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE,
                                              &szPrincipalName);
        if (status != RPC_S_OK)
        {
            _stprintf( tszError,
                      TEXT("RpcServerInqDefaultPrincName(negotiate) failed, err- %lut"),
                      status) ;
            AddToMessageLog(tszError) ;
            return status ;
        }
        else
        {
            status = RpcServerRegisterAuthInfo( szPrincipalName,
                                                RPC_C_AUTHN_GSS_NEGOTIATE,
                                                NULL,
                                                NULL );
            if (status != RPC_S_OK)
            {
                _stprintf( tszError,
                       TEXT("RpcServerRegisterAuthInfo(%hs, negotiate) returned %lut"),
                       szPrincipalName, status) ;
                AddToMessageLog(tszError) ;
                return status ;
            }

            _stprintf(tBuf, TEXT(
                 "NEGOTIATE registered OK, princ name- %s"),
                                                  szPrincipalName);
            LogResults(tBuf) ;

            RpcStringFree(&szPrincipalName);
        }
    }

    //
    // register ntlm
    //
    if ((_tcsicmp(pszAuthSvc, TEXT("ntlm")) == 0)     ||
        (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
    {
        status = RpcServerRegisterAuthInfo( NULL,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,
                                            NULL );
        if (status != RPC_S_OK)
        {
            _stprintf( tszError,
                   TEXT("RpcServerRegisterAuthInfo(ntlm) returned %lut"),
                   status) ;
            AddToMessageLog(tszError) ;
            return status ;
        }

        LogResults(TEXT("NTLM registered OK")) ;
    }

    //
    // register kerberos
    //
    if ((_tcsicmp(pszAuthSvc, TEXT("kerb")) == 0)     ||
        (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
    {
        // kerberos needs principal name
        unsigned char * szPrincipalName;
        status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_KERBEROS,
                                              &szPrincipalName);
        if (status != RPC_S_OK)
        {
            _stprintf( tszError,
                      TEXT("RpcServerInqDefaultPrincName failed, err- %lut"),
                      status) ;
            AddToMessageLog(tszError) ;
            return status ;
        }
        else
        {
            status = RpcServerRegisterAuthInfo( szPrincipalName,
                                                RPC_C_AUTHN_GSS_KERBEROS,
                                                NULL,
                                                NULL );
            if (status != RPC_S_OK)
            {
                _stprintf( tszError,
                       TEXT("RpcServerRegisterAuthInfo(%hs, kerberos) returned %lut"),
                       szPrincipalName, status) ;
                AddToMessageLog(tszError) ;
                return status ;
            }

            _stprintf(tBuf, TEXT(
                 "KERBEROS registered OK, princ name- %s"),
                                                  szPrincipalName);
            LogResults(tBuf) ;

            RpcStringFree(&szPrincipalName);
        }
    }

    s_fAlreadyInit = TRUE ;
    char szMsg[1024];
    _stprintf(szMsg, "RPC server registered successfully");
    AddToMessageLog( szMsg,
                     EVENTLOG_INFORMATION_TYPE ) ;

    if (sizeof(g_tszLastRpcString) >=
        (sizeof(TCHAR) * (1 + _tcslen(g_pResults))))
    {
        _tcscpy(g_tszLastRpcString, g_pResults) ;
    }

    status = RpcServerListen(ulMinCalls,
                             ulMaxCalls,
                             FALSE) ;
    if (status != RPC_S_OK)
    {
        s_fAlreadyInit = FALSE ;
        _stprintf( tszError,
                  TEXT("RpcServerListen failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    return status ;

} // end main()


DWORD __stdcall  ServerThread( void *dwP )
{
    RPC_STATUS status = RegisterServiceAsRpcServer((TCHAR *)dwP) ;
    return status ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\showcred.cpp ===
//
// file: showcred.cpp
//
#include "secservs.h"
#include "sidtext.h"

//+-----------------------------------------------------------
//
//   HRESULT _GetLocalSystemAccountSid(OUT PSID *ppsid)
//
//+-----------------------------------------------------------

static HRESULT _GetLocalSystemAccountSid(OUT PSID *ppsid)
{
    PSID psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&sidAuth,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &psid))
    {
        return GetLastError();
    }
    *ppsid = psid;
    return S_OK;
}

//+---------------------------
//
//  void  GetSIDNames()
//
//+---------------------------

void GetSIDNames( PSID  pSid )
{
    TCHAR  tBuf[ 512 ] ;
    TCHAR szAccount[ 512 ] ;
    DWORD dwASize = sizeof(szAccount) / sizeof(szAccount[0]) ;
    TCHAR szDomain[ 512 ] ;
    DWORD dwDSize = sizeof(szDomain) / sizeof(szDomain[0]) ;
    SID_NAME_USE su ;

    if (LookupAccountSidA( NULL,
                           pSid,
                           szAccount,
                           &dwASize,
                           szDomain,
                           &dwDSize,
                           &su ))
    {
        _tcscpy(tBuf, TEXT("\tAccount: ")) ;
        _tcscat(tBuf, szAccount) ;
        _tcscat(tBuf, TEXT(", Domain: ")) ;
        _tcscat(tBuf, szDomain) ;
    }
    else
    {
        _tcscpy(tBuf, TEXT("LookupAccountSid failed")) ;
    }

    PSID psidLocalSystemAccount;
    HRESULT hr = _GetLocalSystemAccountSid(&psidLocalSystemAccount);
    if (SUCCEEDED(hr))
    {
        if (EqualSid(pSid, psidLocalSystemAccount))
        {
            _tcscat(tBuf, TEXT(". (LocalSystem account)")) ;
        }
        FreeSid(psidLocalSystemAccount);
    }
    else
    {
        _tcscat(tBuf, TEXT(". GetLocalSystemAccountSid failed")) ;
    }

    dwASize = 128 ;
    WCHAR  wszSidText[ 128 ] ;
    BOOL f = GetTextualSidW( pSid,
                             wszSidText,
                             &dwASize ) ;
    if (f)
    {
        TCHAR szSidT[ 128 ] ;
#ifdef UNICODE
        _stprintf(szSidT, "\n\tSid- %s", wszSidText) ;
#else
        _stprintf(szSidT, "\n\tSid- %S", wszSidText) ;
#endif
        _tcscat(tBuf, szSidT) ;
    }

    LogResults(tBuf) ;
}

//+--------------------------------
//
//  void  ShowTokenCredential()
//
//+--------------------------------

void  ShowTokenCredential( HANDLE hToken )
{
    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    P<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            LogResults(TEXT("GetTokenInformation(2) failed")) ;
        }
    }
    else
    {
        LogResults(TEXT("GetTokenInformation(1) failed")) ;
    }

    if (pTokenUser)
    {
        SID *pSid = (SID*) pTokenUser->User.Sid ;
        GetSIDNames( pSid ) ;
    }
}

//+--------------------------------
//
//  void  ShowProcessCredential()
//
//+--------------------------------

void  ShowProcessCredential()
{
    TCHAR tBuf[ 128 ] ;
    HANDLE hToken = NULL ;

    if (OpenProcessToken( GetCurrentProcess(),
                          TOKEN_READ,
                          &hToken))
    {
        LogResults(TEXT("Process Credentials:")) ;
        ShowTokenCredential( hToken ) ;
    }
    else
    {
        _stprintf(tBuf, TEXT(
          "ShowProcessCredential: OpenProcessToken() failed, err-%lut"),
                                                        GetLastError()) ;
        LogResults(tBuf) ;
    }
}

//+---------------------------------------------
//
//  void  ShowImpersonatedThreadCredential()
//
//+---------------------------------------------

void  ShowImpersonatedThreadCredential(BOOL fImpersonated)
{
    TCHAR tBuf[ 128 ] ;
    HANDLE hToken = NULL ;
    if (OpenThreadToken( GetCurrentThread(),
                          TOKEN_READ,
                          !fImpersonated /* OpenAsSelf */,
                          &hToken))
    {
        LogResults(TEXT("Impersonated Thread Credentials:")) ;
        ShowTokenCredential( hToken ) ;
    }
    else
    {
        _stprintf(tBuf, TEXT(
         "ShowImpersonatedCredential: OpenThreadToken() failed, err-%lut"),
                                                     GetLastError());
        LogResults(tBuf) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\_adsi.h ===
#include "activeds.h"

//
// Helper class to auto-release variants
//
class CAutoVariant
{
public:
    CAutoVariant()                          { VariantInit(&m_vt); }
    ~CAutoVariant()                         { VariantClear(&m_vt); }
    operator VARIANT&()                     { return m_vt; }
    VARIANT* operator &()                   { return &m_vt; }
    VARIANT detach()                        { VARIANT vt = m_vt; VariantInit(&m_vt); return vt; }
private:
    VARIANT m_vt;
};

//
// Helper class to auto-release search columns
//
class CAutoReleaseColumn
{
public:
    CAutoReleaseColumn( IDirectorySearch  *pSearch, ADS_SEARCH_COLUMN * pColumn)
    {
        m_pSearch = pSearch;
        m_pColumn = pColumn;
    }
    ~CAutoReleaseColumn()
    {
        m_pSearch->FreeColumn(m_pColumn);
    };
private:
    ADS_SEARCH_COLUMN * m_pColumn;
    IDirectorySearch  * m_pSearch;
};

//
// helper class - Auto release for CoInitialize
//
class CCoInit
{
public:
    CCoInit()
    {
        m_fInited = FALSE;
    }

    ~CCoInit()
    {
        if (m_fInited)
            CoUninitialize();
    }

    HRESULT CoInitialize()
    {
        HRESULT hr;

        hr = ::CoInitialize(NULL);
        m_fInited = SUCCEEDED(hr);
        return(hr);
    }

private:
    BOOL m_fInited;
};

//-------------------------------------------------------
//
// auto release for search handles
//
class CAutoCloseSearchHandle
{
public:
    CAutoCloseSearchHandle()
    {
        m_pDirSearch = NULL;
    }

    CAutoCloseSearchHandle(IDirectorySearch * pDirSearch,
                           ADS_SEARCH_HANDLE hSearch)
    {
        pDirSearch->AddRef();
        m_pDirSearch = pDirSearch;
        m_hSearch = hSearch;
    }

    ~CAutoCloseSearchHandle()
    {
        if (m_pDirSearch)
        {
            m_pDirSearch->CloseSearchHandle(m_hSearch);
            m_pDirSearch->Release();
        }
    }

    void detach()
    {
        if (m_pDirSearch)
        {
            m_pDirSearch->Release();
            m_pDirSearch = NULL;
        }
    }

private:
    IDirectorySearch * m_pDirSearch;
    ADS_SEARCH_HANDLE m_hSearch;
};

//
// stubs for ADSI api.
//

typedef HRESULT (WINAPI *ADsOpenObject_ROUTINE) (
    LPWSTR lpszPathName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    );

HRESULT WINAPI
MyADsOpenObject(
    LPWSTR lpszPathName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    );


typedef HRESULT (WINAPI *ADsGetObject_ROUTINE) (
    LPCWSTR lpszPathName,
    REFIID riid,
    VOID * * ppObject
    );

HRESULT WINAPI
MyADsGetObject(
    LPWSTR lpszPathName,
    REFIID riid,
    VOID * * ppObject
    );

ULONG  LoadAdsiDll() ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\bvt\tservice\secservs\service.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "secserv.h"


// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            LPTSTR lpszLogonName = NULL;
            LPTSTR lpszLogonPwd = NULL;
            if (argc > 2)
            {
                lpszLogonName = argv[2];
                //lpszLogonPwd = TEXT("");
            }
            if (argc > 3)
            {
                lpszLogonPwd = argv[3];
            }
            CmdInstallService(lpszLogonName, lpszLogonPwd);
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else if (( _tcsicmp( TEXT("?"), argv[1]+1 ) == 0 ) ||
                 ( _tcsicmp( TEXT("h"), argv[1]+1 ) == 0 ))
        {
            printf( "%s -install          to install the service\n", SZAPPNAME );
            printf( "%s -remove           to remove the service\n", SZAPPNAME );
            printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
            printf( "\n To start the service: net start %s\n", SZSERVICENAME) ;
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
dispatch:
        // this is just to be friendly
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{
    HRESULT hr = CoInitialize(NULL) ;

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ServiceStop();
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);

}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}

//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//

extern TCHAR  g_tszLastRpcString[ PIPE_BUFFER_LEN * 5 ] ;

VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


    if (wType == EVENTLOG_ERROR_TYPE)
    {
        DWORD dwErr = GetLastError();
        _stprintf( szMsg,
                   TEXT("%s error: %d"),
                   SZSERVICENAME,
                   dwErr ) ;
    }
    else if (wType == EVENTLOG_INFORMATION_TYPE)
    {
        _stprintf( szMsg,
                   TEXT("%s information "),
                   SZSERVICENAME ) ;
    }
    else
    {
        _stprintf( szMsg,
                   TEXT("%s unknown "),
                   SZSERVICENAME ) ;
    }

    // Use event logging to log the error.
    //
    hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

    lpszStrings[0] = szMsg;
    lpszStrings[1] = lpszMsg;

    if (hEventSource != NULL)
    {
        ReportEvent(hEventSource,         // handle of event source
                    wType,                // event type
                    0,                    // event category
                    0,                    // event ID
                    NULL,                 // current user's SID
                    2,                    // strings in lpszStrings
                    0,                    // no bytes of raw data
                    (LPCTSTR *) lpszStrings,          // array of error strings
                    NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);
    }

    if (sizeof(g_tszLastRpcString) >=
                     (sizeof(TCHAR) * (1 + _tcslen(lpszMsg))))
    {
        _tcscpy(g_tszLastRpcString, lpszMsg) ;
    }
}

///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    szLogonName - logon account name (NULL for local system account)
//    szLogonPwd  - logon account password (NULL for local system account)
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            lpszLogonName,              // NULL means LocalSystem account
            lpszLogonPwd);              // NULL means no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            _tprintf(TEXT("to start: net start %s\n"), SZSERVICENAME) ;
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\delques\delques.cpp ===
#define INC_OLE2
#include <windows.h>
 
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

#include <activeds.h>

#define BAIL_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                wprintf (L"Error! hr = 0x%x\n", hr);   \
				exit(0);							   \
        }

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//----------------------------------------------------------------------------
INT _CRTAPI1
main(int argc, char * argv[])
{

    HRESULT hr=S_OK;
    IDirectorySearch *pDSSearch=NULL;
    IDirectoryObject *pDSObject=NULL;
    ADS_SEARCH_HANDLE hSearchHandle=NULL;

	if (argc != 3)
	{
        wprintf (L"Usage: delques computer domain  [deletes all mSMQueues under this object]");
		exit(0);
	}

	WCHAR wszComp[50], wszDom[50], wszParent[100];
	mbstowcs(wszComp,  argv[1], strlen(argv[1])+1);   // computer name
	mbstowcs(wszDom,   argv[2], strlen(argv[2])+1);   // domain name
	wsprintf(wszParent, L"LDAP://CN=msmq,CN=%s,CN=Computers,DC=%s,DC=ntdev,DC=microsoft,DC=com", wszComp, wszDom);	

    hr = CoInitialize(NULL);
	BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
                wszParent,
                IID_IDirectorySearch,
                (void **)&pDSSearch
                );
	BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
                wszParent,
                IID_IDirectoryObject,
                (void **)&pDSObject
                );
	BAIL_ON_FAILURE(hr);

	LPWSTR pszAttrNames[1];
	pszAttrNames[0] = L"name"; 

    hr = pDSSearch->ExecuteSearch(
             L"(objectClass=mSMQQueue)",
             pszAttrNames,
             1,
             &hSearchHandle
              );
    BAIL_ON_FAILURE(hr);

    hr = pDSSearch->GetNextRow(hSearchHandle);
    BAIL_ON_FAILURE(hr);

	DWORD nRows = 0;
	DWORD dwNumberAttributes = 1;
    ADS_SEARCH_COLUMN Column;
    LPWSTR pszColumnName = NULL;

    while (hr != S_ADS_NOMORE_ROWS) {
        nRows++;

        hr = pDSSearch->GetColumn(
                 hSearchHandle,
                 pszAttrNames[0],
                 &Column
                 );
        BAIL_ON_FAILURE(hr);

		WCHAR wszQueuePath[256];
		wsprintf(wszQueuePath, L"CN=%s", (LPWSTR) Column.pADsValues[0].DNString);	

		hr = pDSObject->DeleteDSObject(wszQueuePath);
        BAIL_ON_FAILURE(hr);

		pDSSearch->FreeColumn(&Column);
        hr = pDSSearch->GetNextRow(hSearchHandle);
        BAIL_ON_FAILURE(hr);
    }

    wprintf (L"Total Rows: %d\n", nRows);

	if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    pDSSearch->Release();
    pDSObject->Release();
    CoUninitialize();

    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\diag\xtime\xtime.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>




int _cdecl main( int argc, char *argv[ ])
{
    time_t   tm;
    char szTime[100] = "0x";
    strcat(szTime, argv[1]);

    sscanf(szTime, "%i64x", &tm);
   
    printf("%s", ctime( &tm ) );
    
    return (argc-argc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\closqdlg.h ===
// ClosQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog dialog

class CCloseQueueDialog : public CDialog
{
// Construction
public:
	CCloseQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCloseQueueDialog)
	enum { IDD = IDD_CLOSE_QUEUE_DIALOG };
	CComboBox	m_PathNameCB;
	CString	m_szPathName;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCloseQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCloseQueueDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathName[256])
	{
		_tcscpy (szPathName, m_szPathName);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\crqdlg.cpp ===
// CrQDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "CrQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog dialog


CCreateQueueDialog::CCreateQueueDialog(CWnd* pParent /*=NULL*/)
   : CDialog(CCreateQueueDialog::IDD, pParent)
{
   TCHAR szTmpBuffer[BUFFERSIZE];
   DWORD dwTmpBufferSize = BUFFERSIZE;

   GetComputerName(szTmpBuffer, &dwTmpBufferSize);

   _tcscat(szTmpBuffer, TEXT("\\"));

   //{{AFX_DATA_INIT(CCreateQueueDialog)
   m_strLabel = TEXT("MQ API test");
   m_strPathName = szTmpBuffer;
   //}}AFX_DATA_INIT
}


void CCreateQueueDialog::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CCreateQueueDialog)
   DDX_Text(pDX, IDC_QUEUE_LABEL, m_strLabel);
   DDV_MaxChars(pDX, m_strLabel, 128);
   DDX_Text(pDX, IDC_QUEUE_PATHNAME, m_strPathName);
   DDV_MaxChars(pDX, m_strPathName, 128);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateQueueDialog, CDialog)
   //{{AFX_MSG_MAP(CCreateQueueDialog)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\closqdlg.cpp ===
// ClosQDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "ClosQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog dialog


CCloseQueueDialog::CCloseQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*  pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(CCloseQueueDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(CCloseQueueDialog)
	m_szPathName = _T("");
	//}}AFX_DATA_INIT
}


void CCloseQueueDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCloseQueueDialog)
	DDX_Control(pDX, IDC_COMBO, m_PathNameCB);
	DDX_CBString(pDX, IDC_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCloseQueueDialog, CDialog)
	//{{AFX_MSG_MAP(CCloseQueueDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog message handlers

BOOL CCloseQueueDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	int i;
	
	// TODO: Add extra initialization here
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
		VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
	
    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);        

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\locatdlg.cpp ===
// LocatDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "LocatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocateDialog dialog


CLocateDialog::CLocateDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CLocateDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLocateDialog)
	m_szLabel = TEXT("MQ API test");
	//}}AFX_DATA_INIT
}


void CLocateDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLocateDialog)
	DDX_Text(pDX, IDC_LOCATE_LABEL, m_szLabel);
	DDV_MaxChars(pDX, m_szLabel, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLocateDialog, CDialog)
	//{{AFX_MSG_MAP(CLocateDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocateDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\crqdlg.h ===
// CrQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog dialog

class CCreateQueueDialog : public CDialog
{
// Construction
public:
	CCreateQueueDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateQueueDialog)
	enum { IDD = IDD_CREATE_QUEUE_DIALOG };
	CString	m_strLabel;
	CString	m_strPathName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateQueueDialog)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathNameBuffer[256])
	{
		_tcscpy (szPathNameBuffer, LPCTSTR(m_strPathName));
	}

	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetLabel(TCHAR szLabelBuffer[256])
	{
		_tcscpy (szLabelBuffer, LPCTSTR(m_strLabel));
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\delqdlg.h ===
// DelQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog dialog

class CDeleteQueueDialog : public CDialog
{
// Construction
public:
	CDeleteQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteQueueDialog)
	enum { IDD = IDD_DELETE_QUEUE_DIALOG };
	CComboBox	m_PathNameCB;
	CString	m_szPathName;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteQueueDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathName[256])
	{
		_tcscpy (szPathName, m_szPathName);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\delqdlg.cpp ===
// DelQDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "DelQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog dialog


CDeleteQueueDialog::CDeleteQueueDialog(CArray<ARRAYQ*, ARRAYQ*>* pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteQueueDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(CDeleteQueueDialog)
	m_szPathName = _T("");
	//}}AFX_DATA_INIT
}


void CDeleteQueueDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteQueueDialog)
	DDX_Control(pDX, IDC_DELETE_QUEUE_COMBO, m_PathNameCB);
	DDX_CBString(pDX, IDC_DELETE_QUEUE_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteQueueDialog, CDialog)
	//{{AFX_MSG_MAP(CDeleteQueueDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog message handlers

BOOL CDeleteQueueDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int i;
	
	// TODO: Add extra initialization here
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
		VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
	
    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);        

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\locatdlg.h ===
// LocatDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLocateDialog dialog

class CLocateDialog : public CDialog
{
// Construction
public:
	CLocateDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLocateDialog)
	enum { IDD = IDD_LOCATE_DIALOG };
	CString	m_szLabel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLocateDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLocateDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetLabel(TCHAR szLabelBuffer[256])
	{
		_tcscpy (szLabelBuffer, m_szLabel);
	}


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\mainfrm.cpp ===
/* ************************************************************************ */
/*                                                                          */
/* Main file of the application MQ API test.                                */
/*                                                                          */
/* ************************************************************************ */

//
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "MQApitst.h"
#include <afxtempl.h>

#include "MainFrm.h"
#include "CrQDlg.h"
#include "DelQDlg.h"
#include "OpenQDlg.h"
#include "ClosQDlg.h"
#include "SendMDlg.h"
#include "RecvMDlg.h"
#include "RecWDlg.h"
#include "LocatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPSTR UnicodeStringToAnsiString(LPCWSTR lpcsUnicode)
{
    LPSTR lpAnsiString = NULL;

    if (lpcsUnicode)
    {
        DWORD dwSize = wcstombs(NULL, lpcsUnicode, 0);
        lpAnsiString = new char[dwSize+1];
        size_t rc = wcstombs(lpAnsiString, lpcsUnicode, dwSize);
        ASSERT(rc != (size_t)(-1));
        lpAnsiString[dwSize] = '\0';
    }

    return lpAnsiString;
}

void AnsiStringToUnicode(LPWSTR lpsUnicode, LPSTR  lpsAnsi, DWORD  nSize)
{
    if (lpsUnicode == NULL)
    {
        return;
    }

    ASSERT(lpsAnsi != NULL);

    size_t rc = mbstowcs(lpsUnicode, lpsAnsi, nSize);
    ASSERT(rc != (size_t)(-1));
    if (lpsUnicode[nSize-1] != L'\0')
        lpsUnicode[nSize] = L'\0';
}

#ifdef UNICODE
#define _mqscpy(dest, src)  wcscpy(dest, src)
#else
#define _mqscpy(dest, src)  AnsiStringToUnicode(dest, src, _tcslen(src)+1)
#endif

BOOL GetTextualSid(
    PSID pSid,          // binary SID
    LPTSTR TextualSID,   // buffer for textual representation of SID
    LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // obtain SidIdentifierAuthority
    psia=&((SID *)pSid)->IdentifierAuthority;

    // obtain sidsubauthority count
    dwSubAuthorities=(DWORD)((SID *)pSid)->SubAuthorityCount;

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    TextualSID += _stprintf(TextualSID, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        TextualSID += _stprintf(TextualSID,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        TextualSID += _stprintf(TextualSID, TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        TextualSID += _stprintf(TextualSID, TEXT("-%lu"),
                    ((SID *)pSid)->SubAuthority[ dwCounter] );
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
   ON_WM_CREATE()
   ON_COMMAND(ID_API_CREATE_QUEUE, OnApiCreateQueue)
   ON_COMMAND(ID_API_DELETE_QUEUE, OnApiDeleteQueue)
   ON_COMMAND(ID_API_OPEN_QUEUE, OnApiOpenQueue)
   ON_COMMAND(ID_API_CLOSE_QUEUE, OnApiCloseQueue)
   ON_COMMAND(ID_API_SEND_MESSAGE, OnApiSendMessage)
   ON_COMMAND(ID_API_RECEIVE_MESSAGE, OnApiReceiveMessage)
   ON_COMMAND(ID_API_LOCATE, OnApiLocate)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
   ID_SEPARATOR,           // status line indicator
   ID_INDICATOR_CAPS,
   ID_INDICATOR_NUM,
   ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
   // TODO: add member initialization code here.
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
        sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips or a resizeable toolbar
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

#define MAXINDEX 31


/* ************************************************************************ */
/*                        RemoveFromPathNameArray                           */
/* ************************************************************************ */
/* This function goes through the PathName Array and compares the given     */
/* PathName to the PathName's of the items in the array.                    */
/* If a match is found the item is removed from the array and the function  */
/* returns a pointer to the item, otherwise a NULL pointer is returned.     */
/* ************************************************************************ */
ARRAYQ* CMainFrame::RemoveFromPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_PathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_PathNameArray[Index];
            m_PathNameArray.RemoveAt(Index);
            return pQueue;
        }
    }
    return NULL; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                             CleanPathNameArray                           */
/* ************************************************************************ */
/* This function goes through the PathName array and deletes all the items  */
/* in it. the function frees the allocated memory.                          */
/* ************************************************************************ */
void CMainFrame::CleanPathNameArray()
{
    ARRAYQ* pQueue;

    while (m_PathNameArray.GetSize() > 0)
    {
        pQueue = m_PathNameArray[0];
        m_PathNameArray.RemoveAt(0);
        delete pQueue;
    }
}

/* ************************************************************************ */
/*                        RemoveFromOpenedQueuePathNameArray                */
/* ************************************************************************ */
/* This function goes through the OpenedPathName Array and compares the     */
/* given PathName to the PathName's of the items in the array.              */
/* If a match is found the item is removed from the array and the function  */
/* returns a pointer to the item, otherwise a NULL pointer is returned.     */
/* ************************************************************************ */
ARRAYQ* CMainFrame::RemoveFromOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            m_OpenedQueuePathNameArray.RemoveAt(Index);
            return pQueue;
        }
    }
    return NULL; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                           IsOpenedQueueArrayEmpty                        */
/* ************************************************************************ */
/* This function checks if the size of the OpenedPathName array is zero or  */
/* less and if so it returns TRUE otherwise it returns FALSE.               */
/* ************************************************************************ */
BOOL CMainFrame::IsOpenedQueueArrayEmpty()
{
    if (m_OpenedQueuePathNameArray.GetSize() <= 0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/* ************************************************************************ */
/*                        MoveToOpenedQueuePathNameArray                    */
/* ************************************************************************ */
/* This function moves an item from the PathName array to the               */
/* OpenedPathName array. also it updates the hadle and the access rights    */
/* to the moved queue.                                                      */
/* ************************************************************************ */
void CMainFrame::MoveToOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                                QUEUEHANDLE hQueue, DWORD dwAccess)
{
    ARRAYQ* pQueue;

    pQueue = RemoveFromPathNameArray(szPathName);
    pQueue->hHandle = hQueue;                     // add Queue Handle.
    pQueue->dwAccess = dwAccess;                  // add Queue Access rights.
    Add2OpenedQueuePathNameArray(pQueue);
}

/* ************************************************************************ */
/*                              MoveToPathNameArray                         */
/* ************************************************************************ */
/* This function moves an item from the OpenedPathName array to the         */
/* PathName array.                                                          */
/* ************************************************************************ */
void CMainFrame::MoveToPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    ARRAYQ* pQueue;

    pQueue = RemoveFromOpenedQueuePathNameArray(szPathName);
    Add2PathNameArray(pQueue);
}

/* ************************************************************************ */
/*                             UpdatePathNameArrays                         */
/* ************************************************************************ */
/* This function goes through the Opened Queue PathName array and for every */
/* item in it, it checkes if the item is found in the PathName array as     */
/* well, if so the function removes the item from the PathName array.       */
/* ************************************************************************ */
void CMainFrame::UpdatePathNameArrays()
{
    int PathNameIndex;
    int OpenedPathNameIndex;
    int MaxPathNameIndex = m_PathNameArray.GetSize();
    int MaxOpenedPathNameIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (OpenedPathNameIndex=0; OpenedPathNameIndex<MaxOpenedPathNameIndex; OpenedPathNameIndex++)
    {
        for (PathNameIndex=0; PathNameIndex<MaxPathNameIndex; PathNameIndex++)
        {
            if (_tcscmp(m_OpenedQueuePathNameArray[OpenedPathNameIndex]->szPathName,
                m_PathNameArray[PathNameIndex]->szPathName) == 0)
            {
                //
                // Found a match, remove it from PathName Array.
                //
                pQueue = m_PathNameArray[PathNameIndex];
                m_PathNameArray.RemoveAt(PathNameIndex);
                delete pQueue;
                //
                // get out of inner for loop.
                //
                break;
            }
        }
    }
}


/* ************************************************************************ */
/*                              GetQueueHandle                              */
/* ************************************************************************ */
/* This function goes through the OpenedPathName array and retrieve the     */
/* Handle to the queue which matches the given PathName. If no match was    */
/* found the function returns FALSE.                                        */
/* ************************************************************************ */
BOOL CMainFrame::GetQueueHandle(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                QUEUEHANDLE* phClosedQueueHandle)
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            *phClosedQueueHandle = pQueue->hHandle;
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                       TranslatePathNameToFormatName                      */
/* ************************************************************************ */
/* This function goes through the PathName array and retrieve the           */
/* FormatName to the queue which matches the given PathName. If no match    */
/* was found the function returns FALSE.                                    */
/* ************************************************************************ */
BOOL CMainFrame::TranslatePathNameToFormatName(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                               TCHAR szFormatName[MAX_Q_FORMATNAME_LEN])
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_PathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_PathNameArray[Index];
            _tcsncpy (szFormatName, pQueue->szFormatName, MAX_Q_FORMATNAME_LEN);
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                  TranslateOpenedQueuePathNameToFormatName                */
/* ************************************************************************ */
/* This function goes through the OpenedPathName array and retrieve the     */
/* FormatName to the queue which matches the given PathName. If no match    */
/* was found the function returns FALSE.                                    */
/* ************************************************************************ */
BOOL CMainFrame::TranslateOpenedQueuePathNameToFormatName(
    TCHAR szPathName[MAX_Q_PATHNAME_LEN],
    TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]
    )
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            _tcsncpy (szFormatName, pQueue->szFormatName, MAX_Q_FORMATNAME_LEN);
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}


/* ************************************************************************ */
/*                         DisplayPathNameArray                             */
/* ************************************************************************ */
/* This function goes through the PathName Array and prints it to screen.   */
/* ************************************************************************ */
void CMainFrame::DisplayPathNameArray()
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    TCHAR szMsgBuffer[BUFFERSIZE];

    _stprintf(szMsgBuffer, TEXT("   Located Queues Path Name :"));
    PrintToScreen(szMsgBuffer);
    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        //
        // Print the PathNames.
        //
        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_PathNameArray[Index]->szPathName);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                    DisplayOpenedQueuePathNameArray                       */
/* ************************************************************************ */
/* This function goes through the Opened Queues PathName Array and          */
/* prints it to screen.                                                     */
/* ************************************************************************ */
void CMainFrame::DisplayOpenedQueuePathNameArray()
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    TCHAR szMsgBuffer[BUFFERSIZE];

    _stprintf(szMsgBuffer, TEXT("   Currently Opened Queues Path Names:"));
    PrintToScreen(szMsgBuffer);
    //
    // Loop through the OpenedQueuePathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        //
        // Print the PathNames.
        //
        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_OpenedQueuePathNameArray[Index]->szPathName);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                          GetMsgClassStatus                               */
/* ************************************************************************ */
/* This function sets proper status string based on a given MQMSG class.    */
/* ************************************************************************ */

struct
{
	unsigned short	mclass;
	LPTSTR          pszDescription;
} StringClass[] =
  {
	{ MQMSG_CLASS_NORMAL, TEXT("The Message was received successfully.")},
	{ MQMSG_CLASS_ACK_REACH_QUEUE, TEXT("The REACH QUEUE ACK Message was read successfully.")},
	{ MQMSG_CLASS_ACK_RECEIVE, TEXT("The RECEIVE ACK Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_DST_Q, TEXT("The DESTINATION QUEUE HANDLE INVALID Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, TEXT("The TIME TO RECEIVE EXPIRED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, TEXT("The TIME TO REACH QUEUE EXPIRED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_Q_EXCEED_QUOTA, TEXT("The QUEUE IS FULL Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_ACCESS_DENIED, TEXT("The SENDER HAVE NO SEND ACCESS RIGHTS ON QUEUE Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED, TEXT("The HOP COUNT EXCEEDED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_SIGNATURE, TEXT("The MESSAGE RECEIVED WITH BAD SIGNATURE Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_ENCRYPTION, TEXT("The MSG COULD NOT DECRYPTED Nack Message was read successfully.")},
    { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, TEXT("The SOURCE QM COULD NOT ENCRYPT MSG FOR DEST QM Nack Message was read successfully.")},
	{ 0, NULL}
  };
	
void CMainFrame::ClassToString(unsigned short MsgClass,LPTSTR pszStatus)
{
	//
	// loop the StringClass array to find MsgClass
	//
	DWORD dwIndex = 0;
	while (StringClass[dwIndex].pszDescription != NULL)
	{
		if (StringClass[dwIndex].mclass == MsgClass)
		{
			_stprintf(pszStatus,StringClass[dwIndex].pszDescription);
			return;
		}
		dwIndex++;
	}

	//
	// MsgClass not found - print default error
	//
	_stprintf(pszStatus,TEXT("The NACK (0x%X) Message was read successfully."),MsgClass);
}


/* ************************************************************************ */
/*                            OnApiCreateQueue                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and Label. Then it creates the specified queue.                 */
/*                                                                          */
/* Uses: MQCreateQueue.                                                     */
/* ************************************************************************ */
void CMainFrame::OnApiCreateQueue()
{
    // TODO: Add your command handler code here

    TCHAR szMsgBuffer[BUFFERSIZE];

    MQQUEUEPROPS QueueProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    QUEUEPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;
    HRESULT hr;

    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    TCHAR szLabelBuffer[MAX_Q_PATHNAME_LEN];
    DWORD dwFormatNameBufferLength = MAX_Q_FORMATNAME_LEN;


    //
    // Display CreateQueue Dialog.
    //
    CCreateQueueDialog CreateQueueDialog;

    if(CreateQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }
    CreateQueueDialog.GetPathName(szPathNameBuffer);
    CreateQueueDialog.GetLabel(szLabelBuffer);

    //
    // Get the input fields from the dialog box
    // and prepare the property array PROPVARIANT
    //


    //
    // Set the PROPID_Q_PATHNAME property
    //
    aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN];
    _mqscpy(aVariant[PropIdCount].pwszVal, szPathNameBuffer); //Value

    PropIdCount++;

    //
    // Set the PROPID_Q_LABEL property
    //
    aPropId[PropIdCount] = PROPID_Q_LABEL;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;     //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN];
    _mqscpy(aVariant[PropIdCount].pwszVal, szLabelBuffer); //Value

    PropIdCount++;


    //
    // Set the MQEUEUPROPS structure
    //
    QueueProps.cProp = PropIdCount;           //No of properties
    QueueProps.aPropID = aPropId;             //Id of properties
    QueueProps.aPropVar = aVariant;           //Value of properties
    QueueProps.aStatus = NULL;                //No error reports

    //
    // No security (default)
    //
    pSecurityDescriptor = NULL;

    //
    // Create the queue
    //
#ifdef UNICODE
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szFormatNameBuffer,             //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szwFormatNameBuffer,            //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );

    if (SUCCEEDED(hr))
    {
        size_t rc =wcstombs(szFormatNameBuffer, szwFormatNameBuffer, dwFormatNameBufferLength);
        ASSERT(rc != (size_t)(-1));
    }
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQCreateQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
    }
    else
    {
        //
        // Success - write in edit control.
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was created successfully. ( FormatName: %s )"),
            szPathNameBuffer, szFormatNameBuffer);
        PrintToScreen(szMsgBuffer);

        //
        // Add the new queue to the PathName Array.
        //
        ARRAYQ* pNewQueue = new ARRAYQ;
        //
        // Save PathName and FormatName in the ARRAYQ structure.
        //
        _tcsncpy (pNewQueue->szPathName, szPathNameBuffer, MAX_Q_PATHNAME_LEN);
        _tcsncpy (pNewQueue->szFormatName, szFormatNameBuffer, MAX_Q_FORMATNAME_LEN);
        Add2PathNameArray(pNewQueue);
    }

    //
    // Free allocated memory
    //
    delete   aVariant[0].pwszVal;
    delete   aVariant[1].pwszVal;
}

/* ************************************************************************ */
/*                            OnApiDeleteQueue                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it deletes the specified queue.                           */
/*                                                                          */
/* Uses: MQDeleteQueue.                                                     */
/* ************************************************************************ */
void CMainFrame::OnApiDeleteQueue()
{
    // TODO: Add your command handler code here
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;

    CDeleteQueueDialog DeleteQueueDialog(&m_PathNameArray);

    //
    // Display DeleteQueue Dialog.
    //
    if (DeleteQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    DeleteQueueDialog.GetPathName(szPathNameBuffer);

    //
    // Translate the path name to format name using the ARRAYQ arrays.
    //
    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("Queue wasn't found"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Delete the queue.
    //
#ifdef UNICODE
    hr = MQDeleteQueue(szFormatNameBuffer);  // FormatName of the Queue to be deleted.
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));
    hr = MQDeleteQueue(szwFormatNameBuffer);  // FormatName of the Queue to be deleted.
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQDeleteQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was deleted successfully."), szPathNameBuffer);
        PrintToScreen(szMsgBuffer);
        //
        // Delete the name from the Path Names array.
        //
        ARRAYQ* DeletedQueue = RemoveFromPathNameArray(szPathNameBuffer);
        if (DeletedQueue != NULL)
        {
            delete DeletedQueue;
        }
    }
}

/* ************************************************************************ */
/*                             OnApiOpenQueue                               */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it opens the specified queue.                             */
/*                                                                          */
/* Uses: MQOpenQueue.                                                       */
/* ************************************************************************ */
void CMainFrame::OnApiOpenQueue()
{
    // TODO: Add your command handler code here
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAccessBuffer[50]; // BUGBUG - maybe set with a define
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;
    DWORD dwAccess;

    QUEUEHANDLE hQueue;

    COpenQueueDialog OpenQueueDialog(&m_PathNameArray);

    //
    // Display the OpenQueue dialog.
    //
    if (OpenQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    OpenQueueDialog.GetPathName(szPathNameBuffer);
    dwAccess = OpenQueueDialog.GetAccess();
    //
    // Set the access buffer string.
    //
    switch (dwAccess)
    {
    case (MQ_RECEIVE_ACCESS | MQ_SEND_ACCESS):

        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS, MQ_SEND_ACCESS."));
        break;

    case MQ_RECEIVE_ACCESS:

        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS."));
        break;

    case MQ_SEND_ACCESS:

        _tcscpy(szAccessBuffer, TEXT("MQ_SEND_ACCESS."));
        break;

    default:

        _tcscpy(szAccessBuffer, TEXT("NONE."));
        break;
    }

    //
    // Translate the path name to format name using the ARRAYQ arrays.
    //
    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("Queue wasn't found"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Open the queue. (no sharing)
    //
#ifdef UNICODE
    hr = MQOpenQueue(
            szFormatNameBuffer,     // Format Name of the queue to be opened.
            dwAccess,               // Access rights to the Queue.
            0,                      // No receive Exclusive.
            &hQueue                 // OUT: handle to the opened Queue.
            );
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));

    hr = MQOpenQueue(
            szwFormatNameBuffer,    // Format Name of the queue to be opened.
            dwAccess,               // Access rights to the Queue.
            0,                      // No receive Exclusive.
            &hQueue                 // OUT: handle to the opened Queue.
            );
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQOpenQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer,
            TEXT("The queue %s was opened successfully.\r\n\tQueueHandle: 0x%x\r\n\tQueue Access : %s"),
            szPathNameBuffer,
            hQueue,
            szAccessBuffer);
        PrintToScreen(szMsgBuffer);

        //
        // move the queue to the opened queues array.
        //
        MoveToOpenedQueuePathNameArray(szPathNameBuffer, hQueue, dwAccess);
    }
}

/* ************************************************************************ */
/*                            OnApiCloseQueue                               */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it closes the specified queue.                            */
/*                                                                          */
/* Uses: MQCloseQueue.                                                      */
/* ************************************************************************ */
void CMainFrame::OnApiCloseQueue()
{
    // TODO: Add your command handler code here

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;

    QUEUEHANDLE hClosedQueueHandle;

    //
    // Display CloseQueue Dialog.
    //
    CCloseQueueDialog CloseQueueDialog(&m_OpenedQueuePathNameArray);

    if (CloseQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    CloseQueueDialog.GetPathName(szPathNameBuffer);

    //
    // Get the closed queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hClosedQueueHandle) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("The Queue couldn't be closed since it was not opened before."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Close the queue.
    //
    hr = MQCloseQueue(hClosedQueueHandle);   // the handle of the Queue to be closed.
    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQCloseQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was closed successfully."), szPathNameBuffer);
        PrintToScreen(szMsgBuffer);
        //
        // Move the queue form the opened queues array to the path name array.
        //
        MoveToPathNameArray(szPathNameBuffer);
    }
}

/* ************************************************************************ */
/*                            OnApiSendMessage                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and some message properties. Then it sends the message to the   */
/* specified queue.                                                         */
/*                                                                          */
/* Uses: MQSendMessage.                                                     */
/* ************************************************************************ */

//
// two static buffers to hold the last message body and label for the next time.
//
TCHAR szLastMessageBody[BUFFERSIZE];
TCHAR szLastMessageLabel[BUFFERSIZE];

void CMainFrame::OnApiSendMessage()
{
    // TODO: Add your command handler code here

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAdminPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    MQMSGPROPS MsgProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    MSGPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;

    HRESULT hr;

    unsigned char bPriority;
    unsigned char bDelivery;
    unsigned char bJournal;
    unsigned char bDeadLetter;
	unsigned char bAuthenticated;
	unsigned char bEncrypted;
    unsigned char bAcknowledge;

    WCHAR szMessageBodyBuffer [BUFFERSIZE];
    WCHAR szMessageLabelBuffer[BUFFERSIZE];
    DWORD dwTimeToReachQueue;
	DWORD dwTimeToBeReceived;

    QUEUEHANDLE hQueue;

    CSendMessageDialog SendMessageDialog(&m_OpenedQueuePathNameArray);

    //
    // Display the SendMessage dialog.
    //
    if (SendMessageDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    //
    // Retrieve the properties from the dialog box.
    //
    SendMessageDialog.GetPathName(szPathNameBuffer);
    SendMessageDialog.GetAdminPathName(szAdminPathNameBuffer);
    bPriority = SendMessageDialog.GetPriority();
    bDelivery = SendMessageDialog.GetDelivery();
    bJournal = SendMessageDialog.GetJournal();
    bDeadLetter = SendMessageDialog.GetDeadLetter();
	bAuthenticated = SendMessageDialog.GetAuthenticated();
	bEncrypted = SendMessageDialog.GetEncrypted();
    bAcknowledge = SendMessageDialog.GetAcknowledge();
    SendMessageDialog.GetMessageBody(szLastMessageBody);
    SendMessageDialog.GetMessageLabel(szLastMessageLabel);
    dwTimeToReachQueue = SendMessageDialog.GetTimeToReachQueue();
	dwTimeToBeReceived = SendMessageDialog.GetTimeToBeReceived();

    //
    // Update the Last message properties.
    //
    _mqscpy(szMessageBodyBuffer, szLastMessageBody);
    _mqscpy(szMessageLabelBuffer, szLastMessageLabel);

    //
    // Get the target queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hQueue) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue not opened yet."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Get the admin queue FormatName.
    //
    if (TranslateOpenedQueuePathNameToFormatName(szAdminPathNameBuffer, szAdminFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("TranslatePathNameToFormatName failed, Queue has not been opened yet."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // prepare the property array PROPVARIANT.
    //

    //
    // Set the PROPID_M_PRIORITY property.
    //
    aPropId[PropIdCount] = PROPID_M_PRIORITY;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bPriority;      //Value

    PropIdCount++;

    //
    // Set the PROPID_M_DELIVERY property.
    //
    aPropId[PropIdCount] = PROPID_M_DELIVERY;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bDelivery;      //Value

    PropIdCount++;

    //
    // Set the PROPID_M_ACKNOWLEDGE property.
    //
    aPropId[PropIdCount] = PROPID_M_ACKNOWLEDGE; //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bAcknowledge;   //Value

    PropIdCount++;

    //
    // Set the PROPID_M_BODY property.
    //
    aPropId[PropIdCount] = PROPID_M_BODY;                  //PropId
    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;           //Type
    aVariant[PropIdCount].caub.cElems =
        (wcslen(szMessageBodyBuffer) + 1) * sizeof(WCHAR); //Value
    aVariant[PropIdCount].caub.pElems = (unsigned char *)szMessageBodyBuffer;

    PropIdCount++;

    //
    // Set the PROPID_M_LABEL property.
    //
    aPropId[PropIdCount] = PROPID_M_LABEL;                  //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                   //Type
    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer;     //Value

    PropIdCount++;

    //
    // Set the PROPID_M_TIME_TO_REACH_QUEUE property.
    //
    aPropId[PropIdCount] = PROPID_M_TIME_TO_REACH_QUEUE;    //PropId
    aVariant[PropIdCount].vt = VT_UI4;                      //Type
    aVariant[PropIdCount].ulVal = dwTimeToReachQueue;       //Value

    PropIdCount++;

    //
    // Set the PROPID_M_TIME_TO_BE_RECEIVED property.
    //
    aPropId[PropIdCount] = PROPID_M_TIME_TO_BE_RECEIVED;    //PropId
    aVariant[PropIdCount].vt = VT_UI4;                      //Type
    aVariant[PropIdCount].ulVal = dwTimeToBeReceived;       //Value

    PropIdCount++;


    if (bJournal || bDeadLetter)
    {
        //
        // Set the PROPID_M_JOURNAL property.
        //
        aPropId[PropIdCount] = PROPID_M_JOURNAL;            //PropId
        aVariant[PropIdCount].vt = VT_UI1;                  //Type

        if (bJournal)
            aVariant[PropIdCount].bVal = MQMSG_JOURNAL;
        else
            aVariant[PropIdCount].bVal = 0;
        if (bDeadLetter)
            aVariant[PropIdCount].bVal |= MQMSG_DEADLETTER;

        PropIdCount++;
    }


	if (bAuthenticated)
	{
		//
		// Set the PROPID_M_AUTH_LEVEL property.
		//
		aPropId[PropIdCount] = PROPID_M_AUTH_LEVEL;            //PropId
		aVariant[PropIdCount].vt = VT_UI4;                     //Type
		aVariant[PropIdCount].ulVal = MQMSG_AUTH_LEVEL_ALWAYS; //Value

		PropIdCount++;
	}

	if (bEncrypted)
	{
		//
		// Set the PROPID_M_ENCRYPTION_ALG property.
		//
		aPropId[PropIdCount] = PROPID_M_PRIV_LEVEL;            //PropId
		aVariant[PropIdCount].vt = VT_UI4;                     //Type
		aVariant[PropIdCount].ulVal = MQMSG_PRIV_LEVEL_BODY;   //Value

		PropIdCount++;
	}


    //
    // Set the PROPID_M_ADMIN_QUEUE property.
    //
    aPropId[PropIdCount] = PROPID_M_ADMIN_QUEUE;               //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                      //Type
#ifdef UNICODE
    aVariant[PropIdCount].pwszVal = szAdminFormatNameBuffer;   //Value
#else
    WCHAR szwAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwAdminFormatNameBuffer,
                    szAdminFormatNameBuffer,
                    _tcslen(szAdminFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));
    aVariant[PropIdCount].pwszVal = szwAdminFormatNameBuffer;  //Value
#endif

    PropIdCount++;

    //
    // Set the MQMSGPROPS structure
    //
    MsgProps.cProp = PropIdCount;       //Number of properties.
    MsgProps.aPropID = aPropId;         //Id of properties.
    MsgProps.aPropVar = aVariant;       //Value of properties.
    MsgProps.aStatus  = NULL;           //No Error report.

    //
    // Send the message.
    //
    hr = MQSendMessage(
            hQueue,                     // handle to the Queue.
            &MsgProps,                  // Message properties to be sent.
            NULL                        // No transaction
            );

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQSendMessage failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The Message \"%s\" was sent successfully."), szLastMessageLabel);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                           OnApiReceiveMessage                            */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and the Time to wait for the message. Then it tries to get a    */
/* message from the specified queue at the given time.                      */
/*                                                                          */
/* Uses: MQReceiveMessage, MQFreeMemory.                                    */
/* ************************************************************************ */
void CMainFrame::OnApiReceiveMessage()
{
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[2*BUFFERSIZE];
    TCHAR szDomainName[BUFFERSIZE];
	 TCHAR szAccountName[BUFFERSIZE];
    DWORD dwActNameSize = sizeof(szAccountName);
    DWORD dwDomNameSize = sizeof(szDomainName);
    TCHAR szTextSid[BUFFERSIZE];
    DWORD dwTextSidSize = sizeof(szTextSid);
    BYTE  blobBuffer[BUFFERSIZE];

    MQMSGPROPS MsgProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    MSGPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;

    HRESULT hr;

    WCHAR szMessageLabelBuffer[BUFFERSIZE];
    DWORD dwTimeout;

    QUEUEHANDLE hQueue;

    CReceiveWaitDialog    WaitDialog;
    CReceiveMessageDialog ReceiveMessageDialog(&m_OpenedQueuePathNameArray);

    //
    // Display the ReceiveMessage dialog.
    //
    if (ReceiveMessageDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    ReceiveMessageDialog.DestroyWindow();
    ReceiveMessageDialog.GetPathName(szPathNameBuffer);

    //
    // Get the queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hQueue) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue was not found in Opened Queue Array"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Retrieve the properties form the dialog box.
    //
    dwTimeout = ReceiveMessageDialog.GetTimeout();


    //
    // prepare the property array PROPVARIANT of
    // message properties that we want to receive
    //

    //
    // Set the PROPID_M_BODY property.
    //
    aPropId[PropIdCount] = PROPID_M_BODY;                                //PropId
    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;                         //Type
    aVariant[PropIdCount].caub.cElems = ReceiveMessageDialog.GetBodySize() ;
    aVariant[PropIdCount].caub.pElems = (unsigned char *) new
                               char [ aVariant[PropIdCount].caub.cElems ] ;

    int iBodyIndex = PropIdCount ;
    PropIdCount++;

    //
    // Set the PROPID_M_LABEL property.
    //
    aPropId[PropIdCount] = PROPID_M_LABEL;                   //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                    //Type
    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer;

    PropIdCount++;

    //
    // Set the PROPID_M_PRIORITY property.
    //
    aPropId[PropIdCount] = PROPID_M_PRIORITY;               //PropId
    aVariant[PropIdCount].vt = VT_UI1;                      //Type

    PropIdCount++;

    //
    // Set the PROPID_M_CLASS property.
    //
    aPropId[PropIdCount] = PROPID_M_CLASS;                  //PropId
    aVariant[PropIdCount].vt = VT_UI2;                      //Type

    PropIdCount++;

    //
    // Set the PROPID_M_AUTHENTICATED property.
    //
    aPropId[PropIdCount] = PROPID_M_AUTHENTICATED;          //PropId
    aVariant[PropIdCount].vt = VT_UI1;                      //Type

    PropIdCount++;

	//
	// Set the PROPID_M_SENDERID property
	//
	aPropId[PropIdCount] = PROPID_M_SENDERID;               //PropId
	aVariant[PropIdCount].vt = VT_UI1|VT_VECTOR;            //Type
	aVariant[PropIdCount].blob.pBlobData = blobBuffer;
	aVariant[PropIdCount].blob.cbSize = sizeof(blobBuffer);

	PropIdCount++;

	//
	// Set the PROPID_M_PRIV_LEVEL property
	//
	aPropId[PropIdCount] = PROPID_M_PRIV_LEVEL;             //PropId
	aVariant[PropIdCount].vt = VT_UI4          ;            //Type

	PropIdCount++;

    //
    // Set the PROPID_M_LABEL_LEN property.
    //
    aPropId[PropIdCount] = PROPID_M_LABEL_LEN;              //PropId
    aVariant[PropIdCount].vt = VT_UI4;                      //Type
    aVariant[PropIdCount].ulVal = BUFFERSIZE;               //Value

    PropIdCount++;


    //
    // Set the MQMSGPROPS structure
    //
    MsgProps.cProp = PropIdCount;       //Number of properties.
    MsgProps.aPropID = aPropId;         //Id of properties.
    MsgProps.aPropVar = aVariant;       //Value of properties.
    MsgProps.aStatus  = NULL;           //No Error report.

    //
    // Display a message window until the message from the queue will be received.
    //
    WaitDialog.Create(IDD_WAIT_DIALOG,pMainView);
    WaitDialog.ShowWindow(SW_SHOWNORMAL);
    WaitDialog.UpdateWindow();
    WaitDialog.CenterWindow();
    pMainView->RedrawWindow();

    //
    // Receive the message.
    //
    hr = MQReceiveMessage(
               hQueue,               // handle to the Queue.
               dwTimeout,            // Max time (msec) to wait for the message.
               MQ_ACTION_RECEIVE,    // Action.
               &MsgProps,            // properties to retrieve.
               NULL,                 // No overlaped structure.
               NULL,                 // No callback function.
               NULL,                 // No Cursor.
               NULL                  // No transaction
               );

    WaitDialog.ShowWindow(SW_HIDE);


	if(hr == MQ_ERROR_IO_TIMEOUT)
	{
        _stprintf(szMsgBuffer, TEXT("MQReceiveMessage failed, Timeout expired."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
	}
	else if(hr != MQ_OK)
	{
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQReceiveMessage failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
	}
	else
	{
        //
        // Success - write in edit control
        //
		ClassToString(aVariant[3].uiVal,szMsgBuffer);
        PrintToScreen(szMsgBuffer);

        //
        // Print some of the Message properties.
        //
#ifdef UNICODE
        _stprintf(szMsgBuffer, TEXT("\tLabel: %s"), (WCHAR *)(aVariant[1].pwszVal));
#else
        {
            PCHAR lpLable = UnicodeStringToAnsiString((WCHAR *)(aVariant[1].pwszVal));
            _stprintf(szMsgBuffer, TEXT("\tLabel: %s"), lpLable);
            delete [] lpLable;
        }
#endif
        PrintToScreen(szMsgBuffer);

        //
        // Only if the message is not a falcon message print the body.
        // (this is done since in ACK messages there is no message body).
        //
        if (aVariant[3].bVal == MQMSG_CLASS_NORMAL)
        {
#ifdef UNICODE
            _stprintf(szMsgBuffer, TEXT("\tBody : %s"), (WCHAR *)(aVariant[0].caub.pElems));
#else
            {
                PCHAR pBody = UnicodeStringToAnsiString((WCHAR *)(aVariant[0].caub.pElems));
                _stprintf(szMsgBuffer, TEXT("\tBody : %s"), pBody);
                delete [] pBody;
            }
#endif
            PrintToScreen(szMsgBuffer);
        }

        _stprintf(szMsgBuffer, TEXT("\tPriority : %d"), aVariant[2].bVal);
        PrintToScreen(szMsgBuffer);


		//
		// Print Sender ID
		//
        //
        // See if we're running on NT or Win95.
        //
        OSVERSIONINFO OsVerInfo;

        OsVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&OsVerInfo);

        if (OsVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            //
            //  On NT
            //
		    SID_NAME_USE peUse;
		    if (LookupAccountSid(NULL,
							     blobBuffer,
							     szAccountName,
							     &dwActNameSize,
							     szDomainName,
							     &dwDomNameSize,
							     &peUse) )
            {
                _stprintf(szMsgBuffer, TEXT("\tUser: %s\\%s"),
			        (WCHAR *)(szDomainName),(WCHAR *)(szAccountName));
		        PrintToScreen(szMsgBuffer);
            }
        }
        else
        {
            //
            // LookupAccountSid is not implemented on Win95,
            // instead print textual sid
            //
            if ( GetTextualSid((PSID)blobBuffer, szTextSid, &dwTextSidSize))
            {
                _stprintf(szMsgBuffer, TEXT("\tUser SID : %s"), szTextSid);
		        PrintToScreen(szMsgBuffer);
            }
        }
		//
		// Print "Authenticated" or "Non Authenticated"
		//
		if (aVariant[4].bVal)
			PrintToScreen(TEXT("\tMessage is Authenticated."));
		else
			PrintToScreen(TEXT("\tMessage is Not Authenticated."));


		//
		// Print "Encrypted" or "Non Encrypted"
		//
		if (aVariant[6].ulVal)
			PrintToScreen(TEXT("\tMessage is Encrypted."));
		else
			PrintToScreen(TEXT("\tMessage is Not Encrypted."));
   }

   delete aVariant[ iBodyIndex ].caub.pElems ;
}

/* ************************************************************************ */
/*                               OnApiLocate                                */
/* ************************************************************************ */
/* This function opens a dialog box and ask the user to give a Label. Then  */
/* it locates all the Queues in the DS with a matching label.               */
/* The function updates the PathName Array with those queues.               */
/*                                                                          */
/* Uses: MQLocateBegin, MQLocateNext, MQLocateEnd,                          */
/*       MQInstanceToFormatName, MQFreeMemory.                              */
/* ************************************************************************ */
void CMainFrame::OnApiLocate()
{
    // TODO: Add your command handler code here
    TCHAR szMsgBuffer[BUFFERSIZE];
    TCHAR szLabelBuffer[BUFFERSIZE];

    HRESULT hr;

    MQPROPERTYRESTRICTION PropertyRestriction;
    MQRESTRICTION  Restriction;
    MQCOLUMNSET    Column;
    QUEUEPROPID    aPropId[2]; // only two properties to retrieve.
    HANDLE         hEnum;
    DWORD       cQueue;
    MQPROPVARIANT   aPropVar[MAX_VAR] = {0};
    ARRAYQ*         pArrayQ;
    DWORD       i;
    DWORD           dwColumnCount = 0;
    DWORD dwFormatNameLength = MAX_Q_FORMATNAME_LEN;

    CLocateDialog LocateDialog;

    //
    // Display the ReceiveMessage dialog.
    //
    if (LocateDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    //
    // Retrieve the label from the dialog box.
    //
    LocateDialog.GetLabel(szLabelBuffer);

    //
    // Clean the PathNameArray before locate.
    //
    CleanPathNameArray();

    //
    // Prepare Parameters to locate a queue.
    //

    //
    // Prepare property restriction.
    // Restriction = All queue with PROPID_Q_LABEL equal to "MQ API test".
    //
    PropertyRestriction.rel = PREQ;
    PropertyRestriction.prop = PROPID_Q_LABEL;
    PropertyRestriction.prval.vt = VT_LPWSTR;
#ifdef UNICODE
    PropertyRestriction.prval.pwszVal = szLabelBuffer;
#else
    DWORD size = _tcslen(szLabelBuffer) +1;
    PropertyRestriction.prval.pwszVal = new WCHAR[size];
    AnsiStringToUnicode(PropertyRestriction.prval.pwszVal, szLabelBuffer,size);
#endif

    //
    // prepare a restriction with one property restriction.
    //
    Restriction.cRes = 1;
    Restriction.paPropRes = &PropertyRestriction;

    //
    // Columset (In other words what property I want to retrieve).
    // Only the PathName is important.
    //
    aPropId[dwColumnCount] = PROPID_Q_PATHNAME;
    dwColumnCount++;

    aPropId[dwColumnCount] = PROPID_Q_INSTANCE;
    dwColumnCount++;

    Column.cCol = dwColumnCount;
    Column.aCol = aPropId;

    //
    // Locate the queues. Issue the query
    //
    hr = MQLocateBegin(
            NULL,           //start search at the top.
            &Restriction,   //Restriction
            &Column,        //ColumnSet
            NULL,           //No sort order
            &hEnum          //Enumeration Handle
            );

    if(FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer,
            TEXT("MQLocateBegin failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Get the results.
    //
    cQueue = MAX_VAR;

    //
    // If cQueue == 0 it means that no Variants were retrieved in the last MQLocateNext.
    //
    while (cQueue != 0)
    {
        hr = MQLocateNext(
                hEnum,      // handle returned by MQLocateBegin.
                &cQueue,    // size of aPropVar array.
                aPropVar    // OUT: an array of MQPROPVARIANT to get the results in.
                );

        if(FAILED(hr))
        {
            //
            // Error - display message
            //
            _stprintf(szMsgBuffer,
                TEXT("MQLocateNext failed, Error code = 0x%x."),hr);
            MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
            PrintToScreen(szMsgBuffer);
            return;
        }

        for (i=0; i<cQueue; i++)
        {
            //
            // add the new path names to the path name array.
            //
            pArrayQ = new ARRAYQ;
#ifdef UNICODE
            wcsncpy (pArrayQ->szPathName, aPropVar[i].pwszVal, MAX_Q_PATHNAME_LEN);
#else
            size_t rc = wcstombs(pArrayQ->szPathName, aPropVar[i].pwszVal, MAX_Q_PATHNAME_LEN);
            ASSERT(rc != (size_t)(-1));
#endif

            //
            // Free the memory allocated by MSMQ
            //
            MQFreeMemory(aPropVar[i].pwszVal);


            //
            // move to the next property.
            //
            i = i + 1;

            //
            // Get the FormatName of the queue and set it in the PathName array.
            //
#ifdef UNICODE
            hr = MQInstanceToFormatName(aPropVar[i].puuid, pArrayQ->szFormatName, &dwFormatNameLength);
#else
            WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
            hr = MQInstanceToFormatName(aPropVar[i].puuid, szwFormatNameBuffer, &dwFormatNameLength);
            if (SUCCEEDED(hr))
            {
                size_t rwc =wcstombs(pArrayQ->szFormatName, szwFormatNameBuffer, dwFormatNameLength);
                ASSERT(rwc != (size_t)(-1));
            }
#endif

            if(FAILED(hr))
            {
                //
                // Error - display message
                //
                _stprintf (szMsgBuffer,
                    TEXT("MQGUIDToFormatName failed, Error code = 0x%x."),hr);
                MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
                PrintToScreen(szMsgBuffer);
            }
            //
            // Free the memory allocated by MSMQ
            //
            MQFreeMemory(aPropVar[i].puuid);

            //
            // Add the new Queue to the PathNameArray.
            //
            Add2PathNameArray(pArrayQ);
        }
    }

    //
    // End the locate operation.
    //
    hr = MQLocateEnd(hEnum);   // handle returned by MQLocateBegin.
    if(FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf (szMsgBuffer,
            TEXT("MQLocateEnd failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        PrintToScreen(szMsgBuffer);
        return;
    }

    //
    // Display the Queues found on the locate.
    //
    _stprintf (szMsgBuffer, TEXT("Locate Operation completed successfully"));
    PrintToScreen(szMsgBuffer);
    UpdatePathNameArrays();
    DisplayPathNameArray();
    DisplayOpenedQueuePathNameArray();
}

/* ************************************************************************ */
/*                           OnUpdateFrameTitle                             */
/* ************************************************************************ */
void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    SetWindowText (TEXT("MQ API test"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\mqapitst.cpp ===
// test.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "MQApitst.h"

#include "MainFrm.h"
#include "testDoc.h"
#include "testView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestApp

BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
	//{{AFX_MSG_MAP(CTestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestApp construction

CTestApp::CTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CTestApp object

CTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CTestApp initialization

BOOL CTestApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CTestDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CTestView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CTestApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CTestApp commands


//
// Pointer to hold the main window pointer.
//
CWnd* pMainView;

extern "C" void  PrintToScreen(const TCHAR * Format, ...)
{
   

   TCHAR szText[500];
   va_list l;
   static len = 0;


    //Format the string
    va_start(l, Format); 
#ifdef UNICODE
    vswprintf(szText, Format, l);
#else
    vsprintf(szText, Format, l);
#endif


   	CEdit& rfMainEdit = ((CTestView*)pMainView)->GetEditCtrl();

	int i = rfMainEdit.GetLineCount();

	((CTestView*)pMainView)->GetEditCtrl().SetSel(INT_MAX,INT_MAX);
	((CTestView*)pMainView)->GetEditCtrl().ReplaceSel(szText);
	((CTestView*)pMainView)->GetEditCtrl().ReplaceSel(TEXT("\r\n"));
	len += lstrlen(szText) + 2;
	((CTestView*)pMainView)->GetDocument()->SetModifiedFlag(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\recvmdlg.cpp ===
// RecvMDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "RecvMDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReceiveMessageDialog dialog


CReceiveMessageDialog::CReceiveMessageDialog(CArray <ARRAYQ*, ARRAYQ*>* pStrArray, CWnd* pParent /*=NULL*/)
   : CDialog(CReceiveMessageDialog::IDD, pParent)
{
   m_pStrArray = pStrArray;

   //{{AFX_DATA_INIT(CReceiveMessageDialog)
   m_szPathName = _T("");
   m_iTimeout = 20000;
	m_dwBodySize = BUFFERSIZE;
	//}}AFX_DATA_INIT
}


void CReceiveMessageDialog::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CReceiveMessageDialog)
   DDX_Control(pDX, IDC_COMBO, m_PathNameCB);
   DDX_CBString(pDX, IDC_COMBO, m_szPathName);
   DDV_MaxChars(pDX, m_szPathName, 128);
   DDX_Text(pDX, IDC_TIMEOUT, m_iTimeout);
	DDX_Text(pDX, IDC_EDT_BODY_SIZE, m_dwBodySize);
	DDV_MinMaxDWord(pDX, m_dwBodySize, 1, 100000000);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReceiveMessageDialog, CDialog)
   //{{AFX_MSG_MAP(CReceiveMessageDialog)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReceiveMessageDialog message handlers

BOOL CReceiveMessageDialog::OnInitDialog()
{
   CDialog::OnInitDialog();

   // TODO: Add extra initialization here

   int i;

   for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
   {
      if (((*m_pStrArray)[i]->dwAccess & MQ_RECEIVE_ACCESS) != FALSE)
      {
         VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
      }
   }

    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);

    return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\openqdlg.h ===
// OpenQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COpenQueueDialog dialog

class COpenQueueDialog : public CDialog
{
// Construction
public:
	COpenQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COpenQueueDialog)
	enum { IDD = IDD_OPEN_QUEUE_DIALOG };
	CComboBox	m_PathNameCB;
	BOOL	m_bReceiveAccessFlag;
	BOOL	m_bPeekAccessFlag;
	BOOL	m_SendAccessFlag;
	CString	m_szPathName;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpenQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COpenQueueDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathName[256])
	{
		_tcscpy (szPathName, m_szPathName);
	}

	DWORD GetAccess()
	{
		return (
			((m_bReceiveAccessFlag) ? MQ_RECEIVE_ACCESS : 0) |
			((m_bPeekAccessFlag)	? MQ_PEEK_ACCESS	: 0) |
			((m_SendAccessFlag)		? MQ_SEND_ACCESS	: 0)
			);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\recwdlg.cpp ===
// RecWDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "RecWDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReceiveWaitDialog dialog


CReceiveWaitDialog::CReceiveWaitDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CReceiveWaitDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CReceiveWaitDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CReceiveWaitDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReceiveWaitDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReceiveWaitDialog, CDialog)
	//{{AFX_MSG_MAP(CReceiveWaitDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReceiveWaitDialog message handlers


